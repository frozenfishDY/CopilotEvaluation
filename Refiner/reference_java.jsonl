{"id": "1", "ref_java": ["class Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int n = nums.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] + nums[j] == target) {\\n                    return new int[]{i, j}", "class Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] + nums[j] == target) {\\n                    return new int[] {i, j}", "class Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int n=nums.length;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int[] result=new int[2];\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(target-nums[i])){\\n                result[1]=i;\\n                result[0]=map.get(target-nums[i]);\\n                return result;\\n            }"]}
{"id": "2", "ref_java": ["class Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }", "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = String.valueOf(x); ", "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {return false;}"]}
{"id": "3", "ref_java": ["class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        \\n        m.put(\\'I\\', 1);\\n        m.put(\\'V\\', 5);\\n        m.put(\\'X\\', 10);\\n        m.put(\\'L\\', 50);\\n        m.put(\\'C\\', 100);\\n        m.put(\\'D\\', 500);\\n        m.put(\\'M\\', 1000);\\n        \\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && m.get(s.charAt(i)) < m.get(s.charAt(i + 1))) {\\n                ans -= m.get(s.charAt(i));\\n            }", "class Solution {\\n  public int romanToInt(String s) {\\n    int ans = 0;\\n    \\n    ", "class Solution {\\n  public int romanToInt(String s) {\\n    int ans = 0;\\n    \\n    "]}
{"id": "4", "ref_java": ["class Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }", "class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            }", "class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for (String s : strs)\\n            while (s.indexOf(prefix) != 0)\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n        return prefix;\\n    }"]}
{"id": "5", "ref_java": ["class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>(); ", "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>(); \\n        for (char c : s.toCharArray()) { \\n            if (c == \\'(\\') \\n                stack.push(\\')\\'); \\n            else if (c == \\'{\\') \\n                stack.push(\\'}", "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st=new Stack<Character>();\\n        for(int i=0;i<s.length();i++){\\n            \\n        if(s.charAt(i)==\\'(\\' || s.charAt(i)==\\'{\\' || s.charAt(i)==\\'[\\'){\\n                st.push(s.charAt(i));\\n            }"]}
{"id": "6", "ref_java": ["class Solution {\\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\\n\\n        if(list1!=null && list2!=null){\\n        if(list1.val<list2.val){\\n            list1.next=mergeTwoLists(list1.next,list2);\\n            return list1;\\n            }", "class Solution {\\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\\n\\n        if(list1!=null && list2!=null){\\n        if(list1.val<list2.val){\\n            list1.next=mergeTwoLists(list1.next,list2);\\n            return list1;\\n            }", "class Solution {\\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\\n\\n        if(list1!=null && list2!=null){\\n        if(list1.val<list2.val){\\n            list1.next=mergeTwoLists(list1.next,list2);\\n            return list1;\\n            }"]}
{"id": "7", "ref_java": ["class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[i - 1]) {\\n                nums[j] = nums[i];\\n                j++;\\n            }", "class Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=0;\\n        for(int j=1;j<arr.length;j++){\\n            if(arr[i]!=arr[j]){\\n                i++;\\n                arr[i]=arr[j];\\n            }", "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {\\n            return 0;\\n        }"]}
{"id": "8", "ref_java": ["class Solution {\\r\\n    public int removeElement(int[] nums, int val) {\\r\\n        int index = 0;\\r\\n        for (int i = 0; i < nums.length; i++) {\\r\\n            if (nums[i] != val) {\\r\\n                nums[index] = nums[i];\\r\\n                index++;\\r\\n            }", "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }", "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int idx=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=val){\\n                nums[idx]=nums[i];\\n                idx++;\\n            }"]}
{"id": "9", "ref_java": ["class Solution {\\n    public int strStr(String haystack, String needle) {\\n        String[] words = haystack.split(needle);\\n\\n        if (words.length == 0)\\n            return 0;\\n        if (words[0].length() == haystack.length())\\n            return -1;\\n        if (words.length == 1)\\n            return words[0].length();\\n\\n        for (int i = 0; i < words.length - 1; i++) {\\n            if (!words[i + 1].equals(\"\")) {\\n                return words[i].length();\\n            }", "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int haylength=haystack.length();\\n        int needlelength=needle.length();\\n        if(haylength<needlelength)\\n            return -1;\\n        for(int i=0;i<=haystack.length()-needle.length();i++){\\n            int j=0;\\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\\n                j++;\\n            if(j==needle.length()){\\n                return i;\\n            }", "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            "]}
{"id": "10", "ref_java": ["class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n        while (start <= end) {\\n            int mid = start + (end-start)/2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) end = mid-1;\\n            else start = mid+1;\\n        }", "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while(left<=right){\\n            int mid = (left+right)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }", "class Solution {\\n   public int searchInsert(int[] nums, int target) {\\n        int left = 0 ;\\n        int right = nums.length-1;\\n        while (left<=right){\\n            int mid  = left + (right-left)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }"]}
{"id": "11", "ref_java": ["class Solution {\\n  public int lengthOfLastWord(String s) {\\n    int i = s.length() - 1;\\n\\n    ", "class Solution {\\n    public int lengthOfLastWord(String s) {\\n\\n        int first = 0;\\n        for(int i = s.length()-1 ; i>0;i--){\\n\\n\\n            if(s.charAt(i)!=\\' \\' && s.charAt(i-1) == \\' \\' ){\\n\\n                 first = i;\\n\\n                break;\\n\\n\\n            }", "class Solution {\\n    public int lengthOfLastWord(String s) {\\n        String[] ans = s.trim().split(\" \");\\n        return ans[ans.length - 1].length();\\n    }"]}
{"id": "12", "ref_java": ["class Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }", "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}", "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }"]}
{"id": "13", "ref_java": ["class Solution {\\n    public String addBinary(String a, String b) {\\n        String ans = \"\";\\n        int carry = 0;\\n        if (a.length()<b.length()) {\\n            String temp = a;\\n            a = b;\\n            b = temp;\\n        }", "class Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder res = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res.append(sum % 2);\\n        }", "class Solution {\\n    public String addBinary(String a, String b) {\\n        String ans = \"\";\\n        int carry = 0;\\n        if (a.length()<b.length()) {\\n            String temp = a;\\n            a = b;\\n            b = temp;\\n        }"]}
{"id": "14", "ref_java": ["class Solution {\\n    public int mySqrt(int x) {\\n        ", "class Solution {\\n    public int mySqrt(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }", "class Solution {\\n    public int mySqrt(int x) {\\n        if(x <= 1) {\\n            return x;\\n        }"]}
{"id": "15", "ref_java": ["class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }", "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }", "class Solution {\\n    public int climbStairs(int n) {\\n        int f1 = 1,f2 = 1, ans=0;\\n        int i = 2;\\n        if (n==1||n==2)\\n        {\\n            return n;\\n        }"]}
{"id": "16", "ref_java": ["class Solution {\\n   public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            }", "class Solution {\\n  public ListNode deleteDuplicates(ListNode head) {\\n    for (var p = head; p != null; p = p.next)\\n      while (p.next != null && p.next.val == p.val)\\n        p.next = p.next.next;\\n    \\n    return head;\\n  }", "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        "]}
{"id": "17", "ref_java": ["class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        for (int j = 0, i = m; j < n; j++) {\\n            nums1[i] = nums2[j];\\n            i++;\\n        }", "class Solution {\\n   public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int p1 = m - 1;\\n        int p2 = n - 1;\\n        int pMerge = m + n - 1;\\n        \\n        while (p2 >= 0) {\\n            if (p1 >= 0 && nums1[p1] > nums2[p2]) {\\n                nums1[pMerge--] = nums1[p1--];\\n            }", "class Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i = m-1;\\n        int j = n-1; \\n        int k = m+n-1; \\n        while (i >= 0 && j >= 0) {\\n            if (nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n            }"]}
{"id": "18", "ref_java": ["class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        helper(root, res);\\n        return res;\\n    }", "class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        inorder(root, res);\\n        return res;        \\n    }", "class Solution {\\n  private void inorder(TreeNode node, List<Integer> list) {\\n    if (node == null) return;\\n\\n    inorder(node.left, list);\\n    list.add(node.val);\\n    inorder(node.right, list);\\n  }"]}
{"id": "19", "ref_java": ["class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ", "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ", "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null&&q==null){\\n            return true;\\n        }"]}
{"id": "20", "ref_java": ["class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }", "class Solution {\\n    static boolean mir( TreeNode t1 , TreeNode t2 )\\n    {\\n        if( t1==null && t2== null ) return true;\\n        else if( t1==null || t2==null ) return false;\\n\\n        return ( t1.val==t2.val ) && mir( t1.right , t2.left ) && mir( t1.left , t2.right );\\n    }", "class Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }"]}
{"id": "21", "ref_java": ["class Solution {\\n    public int maxDepth(TreeNode root) {\\n        ", "class Solution {\\n    public int maxDepth(TreeNode root) {\\n      if (root == null) return 0;\\n      Queue<TreeNode> q = new LinkedList<>();\\n      q.add(root);\\n      int maxDepth = 0;\\n      while (q.size() > 0) {\\n        maxDepth++;\\n        int size  = q.size();\\n        for (int i = 0; i < size; i++) {\\n          TreeNode temp = q.remove();\\n          if (temp.left != null) q.add(temp.left);\\n          if (temp.right != null) q.add(temp.right);\\n        }", "class Solution {\\n    public int maxDepth(TreeNode root) {\\n             List<List<Integer>> ans = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return 0;\\n        }"]}
{"id": "22", "ref_java": ["class Solution {\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        if(nums.length==1) {return new TreeNode(nums[0]);}", "class Solution {\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        return CreateBST(nums, 0, nums.length - 1);\\n    }", "class Solution {\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        if(nums.length==1) {return new TreeNode(nums[0]);}"]}
{"id": "23", "ref_java": ["class Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        ", "class Solution {\\r\\n    public boolean isBalanced(TreeNode root) {\\r\\n        if (root==null){\\r\\n            return true;\\r\\n        }", "class Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return isBalancedAndHeight(root) >= 0;\\n    }"]}
{"id": "24", "ref_java": ["class Solution {\\n    public int minDepth(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return 0;\\n        }", "class Solution {\\n    public int minDepth(TreeNode root) {\\n        ", "class Solution {\\n    public int minDepth(TreeNode root) {\\n        if(root == null) return 0;\\n        if(root.left == null && root.right == null) return 1;\\n        if(root.left == null) return 1+minDepth(root.right);\\n        if(root.right == null) return 1+minDepth(root.left);\\n        return Math.min(minDepth(root.left),minDepth(root.right))+1;\\n    }"]}
{"id": "25", "ref_java": ["class Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null) return false;\\n        return hasPathSumHelper(root, targetSum, root.val);\\n    }", "class Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }", "class Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }"]}
{"id": "26", "ref_java": ["class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        if (numRows == 0) return new ArrayList<>();\\n        if (numRows == 1) {\\n            List<List<Integer>> result = new ArrayList<>();\\n            result.add(Arrays.asList(1));\\n            return result;\\n        }", "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n       List<List<Integer>> tria = new ArrayList<>(numRows);\\n        for(int r = 0; r < numRows; r++){\\n            List<Integer>cols = new ArrayList<>(Collections.nCopies(r+1, 1));\\n            \\n            for(int c = 1; c<r; c++){\\n                cols.set(c, tria.get(r-1).get(c-1) + tria.get(r-1).get(c));\\n            }", "class Solution {\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      ans.add(Arrays.asList(temp));\\n    }"]}
{"id": "27", "ref_java": ["class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row = new ArrayList<>();\\n        row.add(1);\\n        int num = 0;\\n        \\n        for (int i = 1; i <= rowIndex; i++) {\\n           num = (int) ((long) row.get(i - 1) * (rowIndex - i + 1) / i);\\n            row.add(num);\\n        }", "class Solution {\\n    public int ncr(int n, int r, List<List<Integer>> dp) {\\n        if (r == 0 || r == n)\\n            return 1;\\n        if (r == 1 || r == n - 1)\\n            return n;\\n        if (dp.get(n).get(r) != -1)\\n            return dp.get(n).get(r);\\n        int result = ncr(n - 1, r, dp) + ncr(n - 1, r - 1, dp);\\n        dp.get(n).set(r, result);\\n        return result;\\n    }", "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> tria = new ArrayList<>(rowIndex + 1);\\n        int colNum = 1;\\n        for (int r = 0; r <= rowIndex; r++) {\\n            List<Integer> row = new ArrayList<>(colNum);\\n            for (int i = 0; i < colNum; i++) {\\n                row.add(1);\\n            }"]}
{"id": "28", "ref_java": ["class Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }", "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=1;i<prices.length;i++){\\n            maxprof = Math.max(maxprof,prices[i]-min_price);\\n            min_price = Math.min(prices[i],min_price);\\n        }", "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy=Integer.MAX_VALUE,sell=0;\\n        for(int i=0;i<prices.length;i++){\\n            buy=Math.min(buy,prices[i]);\\n            sell=Math.max(sell,prices[i]-buy);\\n        }"]}
{"id": "29", "ref_java": ["class Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n        \\treturn true;\\n        }", "class Solution {\\n    public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n        \\treturn true;\\n        }", "class Solution {\\n   public boolean isPalindrome(String s) {\\n        if (s.isEmpty()) {\\n            return true;\\n        }"]}
{"id": "30", "ref_java": ["class Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }", "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int xor = nums[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            xor ^= nums[i];\\n        }", "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        int i=0;\\n        while(i<nums.length-1){\\n            ans=ans^nums[i+1];\\n            i++;\\n        }"]}
{"id": "31", "ref_java": ["class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ListNode slow_pointer = head, fast_pointer = head;\\n        while (fast_pointer != null && fast_pointer.next != null) {\\n            slow_pointer = slow_pointer.next;\\n            fast_pointer = fast_pointer.next.next;\\n            if (slow_pointer == fast_pointer) {\\n                return true;\\n            }", "class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        ", "class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        HashMap<ListNode, Boolean> map=new HashMap<>();\\n        while(head!=null){\\n            if(map.containsKey(head)){\\n                return true;\\n            }"]}
{"id": "32", "ref_java": ["class Solution {\\n    List<Integer>a=new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return a;\\n    }", "class Solution {\\n    public List<Integer> Traversal(TreeNode root,List<Integer> arr){\\n        if(root!=null){\\n            int data=root.val;\\n        arr.add(data);\\n            Traversal(root.left,arr);\\n            Traversal(root.right,arr);\\n        }", "class Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            arr.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }"]}
{"id": "33", "ref_java": ["class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        helper(root, ans);\\n        return ans;\\n    }", "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        postOrder(root,list);\\n        return list;\\n    }", "class Solution {\\n    static List<Integer> result;\\n\\n    private static void traversePostOrder(TreeNode node) {\\n        if (node == null) return;\\n        if (node.left != null) {\\n            traversePostOrder(node.left);\\n        }"]}
{"id": "34", "ref_java": ["class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }", "class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ArrayList<ListNode> arr1 = new ArrayList<>();\\n       ArrayList<ListNode> arr2 = new ArrayList<>();\\n       while(headA!=null){\\n           arr1.add(headA);\\n           headA = headA.next;\\n       }", "class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ArrayList<ListNode> arr1 = new ArrayList<>();\\n       ArrayList<ListNode> arr2 = new ArrayList<>();\\n       while(headA!=null){\\n           arr1.add(headA);\\n           headA = headA.next;\\n       }"]}
{"id": "35", "ref_java": ["class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n        while(columnNumber>0){\\n            int value = (columnNumber-1)%26;\\n            sb.append(Character.toString((char)(65+value)));\\n            columnNumber=(columnNumber-1)/26;\\n        }", "class Solution {\\n    StringBuilder rec = new StringBuilder();\\n    public String convertToTitle(int columnNumber) {\\n        \\n        ", "class Solution {\\n    public String convertToTitle(int c) {\\n        if(c<27){\\n            return Character.toString((char) (\\'A\\' + (c- 1)));\\n        }"]}
{"id": "36", "ref_java": ["class Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return nums[n/2];\\n    }", "class Solution {\\n    public int majorityElement(int[] nums) {\\n         Arrays.sort(nums);\\n\\n          if (nums.length==1 || nums.length==2){\\n        return nums[0];\\n    }", "class Solution {\\n    public static int majorityElement(int[] nums) {\\n        return helper(nums,0,nums[0]);\\n    }"]}
{"id": "37", "ref_java": ["class Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int res = 0;\\n        for(int i = columnTitle.length()-1; i>=0;i--){\\n            char c = columnTitle.charAt(i);\\n            int pow = Math.abs(i-columnTitle.length()+1);\\n            res+=(c-64)*Math.pow(26, pow);\\n        }", "class Solution {\\n    public int titleToNumber(String s) {\\n        if (s == null) return -1;\\n        int sum = 0;\\n        ", "class Solution {\\n    public int titleToNumber(String s) {\\n        if (s == null) return -1;\\n        int sum = 0;\\n        "]}
{"id": "42", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    ", "class Solution {\\n    "]}
{"id": "43", "ref_java": ["class Solution {\\n    public int hammingWeight(int n) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if (((n >> i) & 1) == 1) {\\n                res += 1;\\n            }", "class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }", "class Solution {\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }"]}
{"id": "48", "ref_java": ["class Solution {\\n    public boolean isHappy(int n) {\\n        \\n        int slow = n;\\n        int fast = n;\\n", "class Solution {\\n    public boolean isHappy(int n) {\\n        ", "class Solution {\\n    public boolean isHappy(int n) {\\n        int sum = n;"]}
{"id": "49", "ref_java": ["class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;\\n            }", "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ", "class Solution {\\n  public ListNode removeElements(ListNode head, int val) {\\n    var dummyHead = new ListNode(0, head);\\n\\n    for (var p = dummyHead; p != null; p = p.next)\\n      while (p.next != null && p.next.val == val)\\n        p.next = p.next.next;\\n\\n    return dummyHead.next;\\n  }"]}
{"id": "50", "ref_java": ["class Solution {\\n    public boolean isIsomorphic(String s, String t) {\\n\\n        int map1[]=new int[200];\\n        int map2[]=new int[200];\\n\\n        if(s.length()!=t.length())\\n            return false;\\n\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(map1[s.charAt(i)]!=map2[t.charAt(i)])\\n                return false;\\n\\n            map1[s.charAt(i)]=i+1;\\n            map2[t.charAt(i)]=i+1;\\n        }", "class Solution {\\n    public boolean isIsomorphic(String s, String t) {\\n        ", "class Solution {\\n    public static boolean isIsomorphic(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n\\n        Hashtable<Character , Character> hashtable = new Hashtable<>();\\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            \\n            if (hashtable.containsKey(c1))\\n            {\\n                if (hashtable.get(c1) != c2) return false;\\n            }"]}
{"id": "51", "ref_java": ["class Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;  \\n        ListNode current = head;\\n    \\n        \\n        while(current != null) { \\n            ListNode next = current.next; \\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }", "class Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode tmp = null;\\n        while(curr != null)\\n        {\\n            tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }", "class Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        }"]}
{"id": "52", "ref_java": ["class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }", "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }", "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        "]}
{"id": "53", "ref_java": ["class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        ", "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int integer = nums[i];\\n            if (hashMap.containsKey(integer) && i - hashMap.get(integer) <= k)\\n                return true;\\n            hashMap.put(integer, i);\\n        }", "class Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        if (k == 0) return false;\\n\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int integer = nums[i];\\n            if (hashMap.containsKey(integer) && i - hashMap.get(integer) <= k)\\n                return true;\\n            hashMap.put(integer, i);\\n        }"]}
{"id": "54", "ref_java": ["class Solution {\\n    public int countNodes(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        if(root == null) return 0;\\n        queue.offer(root);\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            int queueSize = queue.size();\\n            count+=queueSize;\\n            System.out.println(\"count\" +count);\\n            for(int i=queue.size(); i>0;i--){\\n              if(queue.peek().left != null) queue.offer(queue.peek().left);\\n              if(queue.peek().right != null) queue.offer(queue.peek().right);\\n              queue.poll();\\n            }", "class Solution {\\n   int count=0;\\n    public int countNodes(TreeNode root) {\\n       if(root==null) return 0;\\n        count++;\\n        countNodes(root.left);\\n        countNodes(root.right);\\n        \\n        return count;\\n    }", "class Solution {\\n    public int countNodes(TreeNode root) {\\n        ArrayList<Integer> ls = new ArrayList<>();\\n        inorder(root, ls);\\n        int ans = ls.size();\\n        return ans;\\n        \\n    }"]}
{"id": "56", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        ", "class Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        invert(root);\\n        return root;\\n    }"]}
{"id": "57", "ref_java": ["class Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n       ArrayList<String> al=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int start=nums[i];\\n            while(i+1<nums.length && nums[i]+1==nums[i+1])\\n                i++;\\n            \\n            if(start!=nums[i]){\\n                al.add(\"\"+start+\"->\"+nums[i]);\\n            }", "class Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        \\n        ArrayList<String> ans = new ArrayList<String>();\\n        int i=0,j=0;\\n        final int n = nums.length;\\n        \\n        while(i<n){\\n            j=i;\\n            while(j+1<n && (long)nums[j+1]-nums[j] == 1){\\n                j++;\\n            }", "class Solution {\\n    public List<String> summaryRanges(int[] nums) {\\n        List<String> list= new ArrayList<String>();\\n\\n        StringBuilder sb= new StringBuilder();\\n        for(int i= 0; i< nums.length; i++){\\n            int prev_diff= 0;\\n            int next_diff= 0;\\n            if(sb.length()== 0)\\n                sb.append(String.valueOf(nums[i]));\\n\\n            "]}
{"id": "58", "ref_java": ["class Solution {\\n  public boolean isPowerOfTwo(int n) {\\n    return n > 0 && (n & (n - 1)) == 0;\\n  }", "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0){\\n            return false;\\n        }", "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1) {\\n            return true;\\n        }"]}
{"id": "60", "ref_java": ["class Solution {\\n      public boolean isPalindrome(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return true;\\n        }", "class Solution {\\n    public boolean isPalindrome(ListNode head) {\\n        ListNode slow = head, fast = head, prev, temp;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }", "class Solution {\\n    public boolean isPalindrome(ListNode head) {\\n        ListNode reverse = reverse(copy(head));\\n\\n        while(head!=null && reverse!=null){\\n            if(head.val != reverse.val){\\n                return false;\\n            }"]}
{"id": "61", "ref_java": ["class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }", "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }", "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sChars = s.toCharArray();\\n        char[] tChars = t.toCharArray();\\n        \\n        Arrays.sort(sChars);\\n        Arrays.sort(tChars);\\n        \\n        return Arrays.equals(sChars, tChars);\\n    }"]}
{"id": "62", "ref_java": ["class Solution {\\n\\n    private List<String> paths = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {        \\n        if (root != null) {\\n           dfsFindLeafsAndAddToResult(root, new StringBuilder()); \\n        }", "class Solution {\\n    List<String> l=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> paths = new ArrayList<>();\\n        if (root == null) {\\n            return paths;\\n        }", "class Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<>();\\n        dfs(root, \"\", result);\\n        return result;\\n    }"]}
{"id": "63", "ref_java": ["class Solution {\\n    public int addDigits(int num) {\\n        if(num == 0) return 0;\\n        else if(num % 9 == 0) return 9;\\n        else return num % 9;\\n    }", "class Solution {\\n    public int addDigits(int num) {\\n        while (num >= 10)\\n        {\\n            int sum = 0;\\n            while (num != 0) {\\n                int digits = num % 10;\\n                sum += digits;\\n                num /= 10;\\n            }", "class Solution {\\n    public int addDigits(int num) {\\n        while(num>9)num=check(num);\\n        return num;\\n    }"]}
{"id": "64", "ref_java": ["class Solution {\\n  public boolean isUgly(int n) {\\n    while (n >= 5 && n % 5 == 0) n /= 5;\\n    while (n >= 3 && n % 3 == 0) n /= 3;\\n    while (n >= 2 && n % 2 == 0) n /= 2;\\n\\n    return n == 1;\\n  }", "class Solution {\\n  public boolean isUgly(int n) {\\n    while (n >= 5 && n % 5 == 0) n /= 5;\\n    while (n >= 3 && n % 3 == 0) n /= 3;\\n    while (n >= 2 && n % 2 == 0) n /= 2;\\n\\n    return n == 1;\\n  }", "class Solution {\\n  public boolean isUgly(int n) {\\n    while (n >= 5 && n % 5 == 0) n /= 5;\\n    while (n >= 3 && n % 3 == 0) n /= 3;\\n    while (n >= 2 && n % 2 == 0) n /= 2;\\n\\n    return n == 1;\\n  }"]}
{"id": "65", "ref_java": ["class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n       int totalSum = n*(n+1)/2;\\n        int sum = 0;\\n        for(int i =0;i<n;i++){\\n            sum = sum+nums[i]; \\n        }", "class Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(nums[i] != i){\\n                return i;\\n            }", "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n       int totalSum = n*(n+1)/2;\\n        int sum = 0;\\n        for(int i =0;i<n;i++){\\n            sum = sum+nums[i]; \\n        }"]}
{"id": "66", "ref_java": ["\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int first = 1;\n        int last = n;\n\n    while (first <= last) {\n       int mid = first + (last - first) / 2; \n\n        if (isBadVersion(mid)) {\n            last = mid - 1; \n        } else {\n            first = mid + 1; \n        }\n    }\n    return first;\n        \n    }\n}\n", "\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int first = 1;\n        int last = n;\n\n    while (first <= last) {\n       int mid = first + (last - first) / 2; \n\n        if (isBadVersion(mid)) {\n            last = mid - 1; \n        } else {\n            first = mid + 1; \n        }\n    }\n    return first;\n        \n    }\n}\n", "\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int first = 1;\n        int last = n;\n\n    while (first <= last) {\n       int mid = first + (last - first) / 2; \n\n        if (isBadVersion(mid)) {\n            last = mid - 1; \n        } else {\n            first = mid + 1; \n        }\n    }\n    return first;\n        \n    }\n}\n"]}
{"id": "67", "ref_java": ["class Solution {\\n    public void moveZeroes(int[] nums) {\\n        if (nums.length == 1) {\\n            return;\\n        }", "class Solution {\\n    public void moveZeroes(int[] nums) \\n   {\\n        int i = 0;\\n        for (int num : nums)\\n        {\\n            if (num != 0)\\n            {\\n                nums[i] = num;\\n                i++;\\n            }", "class Solution {\\n    public void moveZeroes(int[] arr) {\\n    int n = arr.length;\\n    if(n<=1) return;\\n    int s=0;\\n    int e=1;\\n    while(e<n){\\n        if(arr[s]==0 && arr[e]!=0){\\n            int temp = arr[s];\\n            arr[s] = arr[e];\\n            arr[e] = temp;\\n            s++;\\n            e++;\\n        }"]}
{"id": "68", "ref_java": ["class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] words = s.split(\" \");\\n        if (words.length != pattern.length()) {\\n            return false;\\n        }", "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        String[] arr = s.split(\" \");\\n        if (arr.length != pattern.length()) return false;\\n\\n        Hashtable<Character, String> hashtable = new Hashtable<>();\\n\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char c1 = pattern.charAt(i);\\n            String word = arr[i];\\n\\n            if (hashtable.containsKey(c1)) {\\n                if (!hashtable.get(c1).equals(word)) return false;\\n            }", "class Solution {\\n    public boolean wordPattern(String pattern, String s) {\\n        HashMap<Character, String> map = new HashMap<>();\\n        String[] words = s.split(\" \");\\n        \\n        "]}
{"id": "69", "ref_java": ["class Solution {\\n    public boolean canWinNim(int n) {\\n        boolean k=true;\\n        if(n<4)\\n        k=true;\\n        if(n>3)\\n        {\\n            if(n%4==0)\\n            k=false;\\n            else\\n            k=true;\\n        }", "class Solution {\\n    public boolean canWinNim(int n) {\\n        return n%4!=0;\\n    }", "class Solution {\\n    public boolean canWinNim(int n) { \\n        return n % 4 != 0;\\n    }"]}
{"id": "71", "ref_java": ["class Solution {\\n    public boolean isPowerOfThree(int n) {\\n        if(n == 1) return true;\\n        if(n%3 != 0 || n <= 0) return false;\\n        return isPowerOfThree(n/3);\\n    }", "class Solution {\\n    public boolean isPowerOfThree(int n) {\\n         if(n==1) return true;\\n        if(n%3!=0 || n==0) return false;\\n        return isPowerOfThree(n/3);\\n    }", "class Solution {\\n    public boolean isPowerOfThree(int n) {\\n        if(n == 1) return true;\\n        if(n%3 != 0 || n <= 0) return false;\\n        return isPowerOfThree(n/3);\\n    }"]}
{"id": "72", "ref_java": ["class Solution {\\n    public int[] countBits(int n) {\\n        int res[] = new int[n+1];\\n        for(int num = 0; num <= n; num++){\\n            res[num] = (bitCnt(num));\\n        }", "class Solution {\\n    public int[] countBits(int n) {\\n        int[] arr = new int[n+1];\\n        arr[0] = 0;\\n      for(int i =1;i<=n;i++){\\n            int temp = i;\\n            int count = 0 ;\\n            while(temp != 0){ \\n                temp = temp & (temp-1);\\n                count++;\\n            }", "class Solution {\\n    public int[] countBits(int n) {\\n        int res[] = new int[n+1];\\n        for(int num = 0; num <= n; num++){\\n            res[num] = (bitCnt(num));\\n        }"]}
{"id": "73", "ref_java": ["class Solution {\\n    public boolean isPowerOfFour(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }", "class Solution {\\n    public boolean isPowerOfFour(int n) {\\n        return  n  > 0 && Math.floor(Math.log(n)/Math.log(4)) == Math.ceil(Math.log(n)/Math.log(4));\\n    }", "class Solution {\\n    public boolean isPowerOfFour(int n) {\\n        "]}
{"id": "74", "ref_java": ["class Solution {\\n    public void reverseString(char[] s) {\\n        ", "class Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }", "class Solution {\\n    public void reverseString(char[] s) {\\n        int size = s.length;\\n        for(int i = 0, j = size - 1; i < size/2; i++){\\n            swap(s, i, j--);\\n        }"]}
{"id": "75", "ref_java": ["class Solution {\\n    public String reverseVowels(String s) {\\n        char[] word = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n        \\n        while (start < end) {\\n            ", "class Solution {\\n    public String reverseVowels(String s) {\\n        System.out.println(s);\\n        char []c=s.toCharArray();\\n        int n=c.length;\\n        char[]x=new char[n];\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(c[i]==\\'a\\'||c[i]==\\'e\\'||c[i]==\\'i\\'||c[i]==\\'o\\'||c[i]==\\'u\\'||c[i]==\\'A\\'||c[i]==\\'E\\'||c[i]==\\'I\\'||c[i]==\\'O\\'||c[i]==\\'U\\'){\\n                x[j]=c[i];\\n                j++;\\n\\n                }", "class Solution {\\n    public String reverseVowels(String s) {\\n\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0 ;\\n\\n        int end = s.length()-1;\\n\\n        while (start<end){\\n            while (start < end && !isVowel(chars[start])) {\\n                start++;\\n            }"]}
{"id": "76", "ref_java": ["class Solution {\\n  public int[] intersection(int[] nums1, int[] nums2) {\\n    var set1 = new HashSet<Integer>();\\n    var set2 = new HashSet<Integer>();\\n\\n    for (var n : nums1) set1.add(n);\\n\\n    for (var n : nums2)\\n      if (set1.contains(n))\\n        set2.add(n);\\n\\n    var arr = new int[set2.size()];\\n    var i = 0;\\n    for (var n : set2) arr[i++] = n;\\n\\n    return arr;\\n  }", "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> s1 = new HashSet<>();\\n        HashSet<Integer> s2 = new HashSet<>();\\n\\n        for(int i : nums1)\\n        {\\n            s1.add(i);\\n        }", "class Solution {\\n     public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        Set<Integer> set1 = new HashSet<>();\\n        for (int n1:nums1\\n             ) {\\n            set1.add(n1);\\n        }"]}
{"id": "77", "ref_java": ["class Solution {\\n    public int[] intersect(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n  ArrayList<Integer> list=new ArrayList<>();\\n\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i] < nums2[j]){\\n                i++;\\n            }", "class Solution {\\n    public int[] intersect(int[] nums1, int[] nums2) {\\n        ", "class Solution {\\n    public int[] intersect(int[] nums1, int[] nums2) {\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n        int i = 0, j = 0, k = 0;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        while( i < l1 && j < l2)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                i++;\\n            }"]}
{"id": "78", "ref_java": ["class Solution {\\n    public boolean isPerfectSquare(int num) {\\n        if(num==1){\\n            return true;\\n        }", "class Solution {\\n    public boolean isPerfectSquare(int num) {\\n        int i=1;\\n        while(num>0){\\n            num-=i;\\n            i+=2;\\n        }", "class Solution {\\n    public boolean isPerfectSquare(int num) {\\n        return ((int)Math.sqrt(num))*((int)Math.sqrt(num))==num;\\n    }"]}
{"id": "79", "ref_java": ["\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int start = 1;\n        int end = n;\n        while(start<=end) {\n            int mid = start + (end-start) /2;\n            if(guess(mid) == 0)\n                return mid;\n            else if(guess(mid) == 1)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}\n", "\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int start = 1;\n        int end = n;\n        while(start<=end) {\n            int mid = start + (end-start) /2;\n            if(guess(mid) == 0)\n                return mid;\n            else if(guess(mid) == 1)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}\n", "\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int start = 1;\n        int end = n;\n        while(start<=end) {\n            int mid = start + (end-start) /2;\n            if(guess(mid) == 0)\n                return mid;\n            else if(guess(mid) == 1)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}\n"]}
{"id": "80", "ref_java": ["class Solution {\\n    public boolean canConstruct(String ransomNote, String magazine) {\\n\\t\\tif (ransomNote.length() > magazine.length()) return false;\\n        int[] alphabets_counter = new int[26];\\n        \\n        for (char c : magazine.toCharArray())\\n            alphabets_counter[c-\\'a\\']++;\\n\\n        for (char c : ransomNote.toCharArray()){\\n            if (alphabets_counter[c-\\'a\\'] == 0) return false;\\n            alphabets_counter[c-\\'a\\']--;\\n        }", "class Solution {\\n    public boolean canConstruct(String ransomNote, String magazine) {\\n        \\n        ", "class Solution {\\n    public boolean canConstruct(String ransomNote, String magazine) {\\n        "]}
{"id": "81", "ref_java": ["class Solution {\\n     public int firstUniqChar(String s) {\\n        ", "class Solution {\\n    public int firstUniqChar(String s) {\\n        int m=0;\\n        for(int i : s.toCharArray()) {\\n            \\n            if(s.indexOf(i) == s.lastIndexOf(i)){\\n                return m;\\n            }", "class Solution {\\n    public int firstUniqChar(String s) {\\n        for (int i = 0; i < s.length(); i++) {\\n            int c = s.charAt(i);\\n            if (i == s.lastIndexOf(c) && i == s.indexOf(c)) return i;\\n        }"]}
{"id": "82", "ref_java": ["class Solution {\\n    public char findTheDifference(String s, String t) {\\n        char c = 0;\\n        for(char cs : s.toCharArray()) c ^= cs;\\n        for(char ct : t.toCharArray()) c ^= ct;\\n        return c;\\n    }", "class Solution {\\n    public char findTheDifference(String s, String t) {\\n        ArrayList<Character>al=new ArrayList<>();\\n      \\n            for(int i=0;i<t.length();i++)\\n            {\\n                al.add(t.charAt(i));\\n            }", "class Solution {\\n    public char findTheDifference(String s, String t) {\\n       List<Character> ch = new ArrayList<>();\\n       for(char c : t.toCharArray()){\\n           ch.add(c);\\n       }"]}
{"id": "83", "ref_java": ["class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n\\n        if(s.length()>t.length()) {\\n            return false;\\n        }", "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n    int c = 0, index = -1;\\n    for(int i = 0; i<s.length() ;i++) {\\n            c = 0;\\n        for(int j = index + 1 ; j<t.length() ;j++) {\\n              if(s.charAt(i) == t.charAt(j)) {\\n                   index = j;\\n                   c = 1;\\n                   break;\\n              }", "class Solution {\\n    public boolean isSubsequence(String s, String t) {\\n        if(s.length() == 0) return true;\\n        int j=0;\\n        int i=0;\\n        while(j<t.length()){\\n            if(t.charAt(j)==s.charAt(i)){\\n                i++;\\n            }"]}
{"id": "84", "ref_java": ["class Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        List<String> allPossibleTimes = new ArrayList();\\n        \\n        for(int hour=0;hour<12;hour++){\\n            for(int minute=0;minute<60;minute++){\\n                if(Integer.bitCount(hour)+Integer.bitCount(minute) == turnedOn){\\n                    StringBuilder time = new StringBuilder();\\n                    time.append(hour).append(\":\");\\n                    if(minute<10){\\n                        time.append(\"0\");\\n                    }", "class Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        List<String> allPossibleTimes = new ArrayList();\\n        \\n        for(int hour=0;hour<12;hour++){\\n            for(int minute=0;minute<60;minute++){\\n                if(Integer.bitCount(hour)+Integer.bitCount(minute) == turnedOn){\\n                    StringBuilder time = new StringBuilder();\\n                    time.append(hour).append(\":\");\\n                    if(minute<10){\\n                        time.append(\"0\");\\n                    }", "class Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        List<String> allPossibleTimes = new ArrayList();\\n        \\n        for(int hour=0;hour<12;hour++){\\n            for(int minute=0;minute<60;minute++){\\n                if(Integer.bitCount(hour)+Integer.bitCount(minute) == turnedOn){\\n                    StringBuilder time = new StringBuilder();\\n                    time.append(hour).append(\":\");\\n                    if(minute<10){\\n                        time.append(\"0\");\\n                    }"]}
{"id": "85", "ref_java": ["class Solution {\\n    public int sumOfLeftLeaves(TreeNode root) {\\n        return helper(root);\\n    }", "class Solution {\\n    private int sum = 0;\\n\\n    public int sumOfLeftLeaves(TreeNode root) {\\n        traverse(root.left, 1);\\n        traverse(root.right, 2);\\n        return sum;\\n    }", "class Solution {\\n    int maxsum=0;\\n    public int sumOfLeftLeaves(TreeNode root) {\\n        int ans=0;\\n        if(root==null){\\n            return 0;\\n        }"]}
{"id": "86", "ref_java": ["class Solution {\\n    public String toHex(int num) {\\n        if(num == 0){\\n            return \"0\";\\n        }", "class Solution {\\n    public String toHex(int num) {\\n        return Integer.toHexString(num);\\n    }", "class Solution {\\n    public String toHex(int num) {\\n        if(num == 0){\\n            return \"0\";\\n        }"]}
{"id": "87", "ref_java": ["class Solution {\\n    public int longestPalindrome(String s) {\\n        int oddCount = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if (map.get(ch) % 2 == 1)\\n                oddCount++;\\n            else\\n                oddCount--;\\n        }", "class Solution {\\n    public int longestPalindrome(String s) {\\n        int length = 0;\\n        ", "class Solution {\\n    public int longestPalindrome(String s) {\\n        "]}
{"id": "88", "ref_java": ["class Solution {\\n    public List<String> fizzBuzz(int n) {\\n        LinkedList ls=new LinkedList<String>();\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 && i%5==0){\\n                ls.add(\"FizzBuzz\");\\n            }", "class Solution {\\n    public List<String> fizzBuzz(int n) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (i % 15 == 0) {\\n                ans.add(\"FizzBuzz\");\\n            }", "class Solution {\\n    public List<String> fizzBuzz(int n) {\\n        List<String> ans = new ArrayList<>();\\n\\n        for(int i=1; i<=n; i++) {\\n            if(i%3 ==0 && i%5==0) {\\n                ans.add(\"FizzBuzz\");\\n            }"]}
{"id": "89", "ref_java": ["class Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\n           if(nums.length<2){\\n\\n          return nums[nums.length-1];\\n\\n            }", "class Solution {\\n    public int thirdMax(int[] nums) {\\n        long max1 = Long.MIN_VALUE;\\n        long max2 = Long.MIN_VALUE;\\n        long max3 = Long.MIN_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            max1 = Math.max(max1, nums[i]);\\n        }", "class Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\n           if(nums.length<2){\\n\\n          return nums[nums.length-1];\\n\\n            }"]}
{"id": "90", "ref_java": ["class Solution {\\n    public String addStrings(String s1, String s2) {\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n\\n        int carry = 0;\\n        int idx1 = n1-1;\\n        int idx2 = n2-1;\\n        StringBuilder s = new StringBuilder(\"\");\\n\\n        while(idx1>=0 && idx2>=0){\\n            int a = s1.charAt(idx1)-48;\\n            int b = s2.charAt(idx2)-48;\\n            int c = carry+a+b;\\n\\n            if(c<10){\\n                s.insert(0,String.valueOf(c));\\n                carry = 0;\\n            }", "class Solution {\\n    public String addStrings(String num1, String num2) {\\n        StringBuilder str = new StringBuilder();\\n\\n        int i = num1.length() - 1, j = num2.length() - 1, carry = 0, sum;\\n\\n        while (i >= 0 || j >= 0 || carry > 0) {\\n            int digit1 = (i >= 0) ? num1.charAt(i--) - \\'0\\' : 0;\\n            int digit2 = (j >= 0) ? num2.charAt(j--) - \\'0\\' : 0;\\n\\n            sum = digit1 + digit2 + carry;\\n            str.append(sum % 10);\\n            carry = sum / 10;\\n        }", "class Solution {\\n    public String addStrings(String num1, String num2) {\\n       java.math.BigInteger a = new java.math.BigInteger(num1);\\n       java.math.BigInteger b = new java.math.BigInteger(num2);\\n       a = a.add(b);\\n       return a.toString();\\n    }"]}
{"id": "91", "ref_java": ["class Solution {\\n\\n    public int countSegments(String s) {\\n        StringTokenizer st=new StringTokenizer(s,\" \");\\n        int count=0;\\n        while(st.hasMoreTokens())\\n        {\\n            count++;\\n            st.nextToken();\\n        }", "class Solution {\\n    public int countSegments(String s) {\\n        return (int) Arrays.stream(s.trim().split(\" \")).filter(t -> t.length() > 0).count();\\n    }", "class Solution {\\n    public int countSegments(String s) {\\n        "]}
{"id": "92", "ref_java": ["class Solution {\\n    public int arrangeCoins(int n) {\\n        int start = 0;\\n        int end = n;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            long target = ((long) mid*(mid+1))/2;\\n            if (target == n) return mid;\\n            else if (target > n) end = mid - 1;\\n            else start = mid +1;\\n        }", "class Solution {\\n    public int arrangeCoins(long n) {\\n            return (int) ((- 1 + Math.sqrt((double) 1 + 8 * n))/ 2);\\n\\n    }", "class Solution {\\n    public int arrangeCoins(int n) {\\n        long left = 1;\\n        long right = n;\\n        int ans = -1;\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            long noOfStairs = (mid * (mid + 1)) / 2;\\n            if (noOfStairs <= n) {\\n                ans = (int) mid;\\n                left = mid + 1;\\n            }"]}
{"id": "93", "ref_java": ["class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int val : nums) {\\n            set.add(val);\\n        }", "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int val : nums) {\\n            set.add(val);\\n        }", "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        int n = nums.length;\\n        int i = 0 ; \\n        List<Integer> ans = new ArrayList();\\n\\n        if (n < 2) return new ArrayList<Integer>(1);\\n\\n        while (i < n) {\\n            int correctIndex = nums[i] - 1;\\n\\n            if (nums[i] != nums[correctIndex]) {\\n                if (correctIndex < n) {\\n                    swap(nums, i, correctIndex);\\n                }"]}
{"id": "94", "ref_java": ["class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g) ;\\n        Arrays.sort(s) ;\\n        int count = 0 ;\\n\\n        ", "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count =0;\\n        int i=0,j=0;\\n        while(i<g.length && j<s.length){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g); "]}
{"id": "95", "ref_java": ["class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                String substring = s.substring(0, i);\\n                StringBuilder repeated = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated.append(substring);\\n                }", "class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int len = s.length();\\n        if( len == 1) {\\n            return false;\\n        }", "class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                StringBuilder pattern = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    pattern.append(s.substring(0, i));\\n                }"]}
{"id": "96", "ref_java": ["class Solution {\\n    public int hammingDistance(int x, int y) {\\n        String x_bin = Integer.toBinaryString(x);\\n        String y_bin = Integer.toBinaryString(y);\\n\\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\\n\\n        int result = 0;\\n        BigInteger min_bi;\\n        min_bi  = new BigInteger(min_str);\\n        System.out.println(\"min_bi = \"+ min_bi);\\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\\n        for(int i=0; i<max_len; i++){\\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\\n            {\\n                result+=1;\\n            }", "class Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        int a = x^y;\\n       ", "class Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x^y);\\n    }"]}
{"id": "97", "ref_java": ["class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int no_of_islands = 0;\\n        int no_of_neighbors = 0;\\n        for(int i=0 ; i<grid.length ; i++){\\n            for(int j=0 ; j<grid[0].length ; j++){\\n                if(grid[i][j] == 1){\\n                    no_of_islands++;\\n                    if((i-1 >= 0) && grid[i-1][j] == 1){\\n                        no_of_neighbors++;\\n                    }", "class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int row=grid.length;\\n        int col=grid[0].length;\\n        int c=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    if(i==0)\\n                    {\\n                        c++;\\n                    }", "class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n      int output = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1){\\n                    output += 4;\\n\\n                    if ( j-1 >= 0  && grid[i][j-1] == 1)  output -= 1;\\n\\n                    if ( j+1 != grid[i].length && grid[i][j+1] == 1)  output -=1;\\n\\n                    if (i-1 >= 0 && grid[i-1][j] == 1)   output -= 1;\\n                    \\n                    if (i+1 != grid.length && grid[i+1][j] == 1) output -=1;\\n                }"]}
{"id": "98", "ref_java": ["class Solution {\\n    public int findComplement(int num) {\\n        int tmp = (int) (Math.pow(2,digits(num))-1);\\n        return tmp - num;\\n    }", "class Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        int set = 1;\\n        while(num != 0) {\\n            if((num&1)== 0) {\\n                result |= set;\\n            }", "class Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        int set = 1;\\n        while(num != 0) {\\n            if((num&1)== 0) {\\n                result |= set;\\n            }"]}
{"id": "99", "ref_java": ["class Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        while (s.length() > 0 && s.charAt(0) == \\'-\\') s = s.substring(1);\\n        while (s.length() > 0 && s.charAt(s.length() - 1) == \\'-\\') s = s.substring(0, s.length() - 1);\\n        String[] split = s.toUpperCase().split(\"-\");\\n        int len = s.length() - (split.length - 1), lenFirst = len % k == 0 ? k : len % k;\\n        StringBuilder sb = new StringBuilder();\\n        for (String str : split) sb.append(str);\\n        String temp = sb.toString();\\n        if (temp.length() <= k) return temp;\\n        sb.setLength(0);\\n        sb.append(temp,0, lenFirst).append(\"-\");\\n        int i = lenFirst;\\n        while (i < temp.length()) {\\n            sb.append(temp, i, i + k).append(\"-\");\\n            i += k;\\n        }", "class Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        while (s.length() > 0 && s.charAt(0) == \\'-\\') s = s.substring(1);\\n        while (s.length() > 0 && s.charAt(s.length() - 1) == \\'-\\') s = s.substring(0, s.length() - 1);\\n        String[] split = s.toUpperCase().split(\"-\");\\n        int len = s.length() - (split.length - 1), lenFirst = len % k == 0 ? k : len % k;\\n        StringBuilder sb = new StringBuilder();\\n        for (String str : split) sb.append(str);\\n        String temp = sb.toString();\\n        if (temp.length() <= k) return temp;\\n        sb.setLength(0);\\n        sb.append(temp,0, lenFirst).append(\"-\");\\n        int i = lenFirst;\\n        while (i < temp.length()) {\\n            sb.append(temp, i, i + k).append(\"-\");\\n            i += k;\\n        }", "class Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        String temp = \"\", formatted=\"\";\\n        s = s.toUpperCase();\\n        System.out.println(s);\\n        int count=k;\\n        for(int i=s.length()-1 ; i>=0 ; i--){\\n            if(s.charAt(i)!=\\'-\\'){\\n                if(count==0){\\n                    temp+=\\'-\\';\\n                    count=k;\\n                }"]}
{"id": "100", "ref_java": ["class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int ans = 0, sum = 0;\\n        for (int n : nums) {\\n            sum *= n;\\n            sum += n;\\n            ans = Math.max(ans, sum);\\n        }", "class Solution {\\n    public int findMaxConsecutiveOnes(int[] arr) {\\n        int ans = 0;\\n        int n = arr.length;\\n         \\n\\n        int curr = 0;\\n        if(arr[0]==1){\\n            ans++;\\n            curr++;\\n        }", "class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0;\\n        int maxi = 0;\\n        int n = nums.length;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                count++;\\n                maxi = Math.max(maxi, count);\\n            }"]}
{"id": "101", "ref_java": ["class Solution {\\n    public int[] constructRectangle(int area) {\\n\\n        int i = (int) Math.sqrt(area);\\n\\n        for(; i>=1; i--){\\n            if(area % i == 0){\\n                return new int [] {area/i, i}", "class Solution {\\n    public int[] constructRectangle(int area) {\\n        int wid = (int) Math.sqrt(area);\\n        while (area%wid != 0){\\n            wid--;\\n        }", "class Solution {\\n    public int[] constructRectangle(int area) {\\n    int width =(int) Math.sqrt(area);\\n    while(area%width !=0){ \\n        width--;\\n    }"]}
{"id": "102", "ref_java": ["class Solution {\\n    public int findPoisonedDuration(int[] time, int d) {\\n        int total_duration=0;\\n        for(int i=0,prev_end=time[0]-1;i<time.length;prev_end=time[i]+d-1,i++) \\n        total_duration+=time[i]<=prev_end?d-(prev_end-time[i]+1):d;\\n        return total_duration;\\n    }", "class Solution {\\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\\n        int total=0;\\n        int temp;\\n\\n        for(int i =0;i<timeSeries.length-1;i++){\\n            if(timeSeries[i]+duration<timeSeries[i+1]){\\n                total += duration;\\n            }", "class Solution {\\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\\n        int total = 0;\\n        for (int i = 0; i < timeSeries.length-1; i++) {\\n            "]}
{"id": "103", "ref_java": ["class Solution {\\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\\n        ", "class Solution {\\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\\n        int[] ans = new int[nums1.length];\\n        for(int i = 0; i < nums1.length; i++){\\n            int max = -1;\\n            for(int j = 0; j < nums2.length; j++){\\n                int index = j;\\n                if(nums1[i] == nums2[j]){ ", "class Solution {\\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\\n        "]}
{"id": "104", "ref_java": ["class Solution {\\n    public String[] findWords(String[] words) {\\n    List<String> validWords = new ArrayList<>();\\n        for (String word : words) {\\n            if (check(word)) {\\n                validWords.add(word);\\n            }", "class Solution {\\n    public String[] findWords(String[] words) {\\n int[] rowMap = new int[26];\\n        String[] rows = {\"QWERTYUIOP\", \"ASDFGHJKL\", \"ZXCVBNM\"}", "class Solution {\\n    public String[] findWords(String[] words) {\\n        String one = \"qwertyuiopQWERTYUIOP\";\\n        String two = \"asdfghjklASDFGHJKL\";\\n        String three = \"zxcvbnmZXCVBNM\";\\n        List<String> list = new LinkedList<>();\\n        for(int i=0;i<words.length;i++){\\n            if(check(words[i],one) || check(words[i],two) || check(words[i],three)){\\n                list.add(words[i]);\\n            }"]}
{"id": "105", "ref_java": ["class Solution {\\n    private int currentVal;\\n    private int currentCount = 0;\\n    private int maxCount = 0;\\n    private int modeCount = 0;\\n    private int[] modes;\\n    public int[] findMode(TreeNode root) {\\n        inOrderTraversal(root);\\n\\n        modes = new int[modeCount];\\n        modeCount = 0;\\n        currentCount = 0;\\n\\n        inOrderTraversal(root);\\n\\n        return modes;\\n    }", "class Solution {\\n    private int currentVal;\\n    private int currentCount = 0;\\n    private int maxCount = 0;\\n    private List<Integer> modes = new ArrayList<>();\\n\\n    public int[] findMode(TreeNode root) {\\n        inOrderTraversal(root);\\n        int[] result = new int[modes.size()];\\n        for (int i = 0; i < modes.size(); i++) {\\n            result[i] = modes.get(i);\\n        }", "class Solution {\\n    HashMap<Integer, Integer> map=new HashMap<>();\\n    int max=0;\\n    public int[] findMode(TreeNode root) {\\n        findModeH(root);\\n        List<Integer> arr=new ArrayList<>();\\n        for(int key : map.keySet()){\\n            if(map.get(key)==max){\\n                arr.add(key);\\n            }"]}
{"id": "106", "ref_java": ["class Solution {\\n    public String convertToBase7(int num) \\n    {\\n        int base=1;\\n        int ans=0;\\n        while(num!=0)\\n        {\\n            int rem=num%7;\\n            ans+=base*rem;\\n            base*=10;\\n            num/=7;\\n        }", "class Solution {\\n    public String convertToBase7(int num) {\\n        return Integer.toString(num,7);\\n    }", "class Solution {\\n    public String convertToBase7(int num) {\\n       return Integer.toString(num, 7);\\n    }"]}
{"id": "107", "ref_java": ["class Solution {\\n    class Score implements Comparable<Score>\\n    {\\n        Integer value;\\n        Score(Integer val)\\n        {\\n            value=val;\\n        }", "class Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n        int[] nums=score;\\n         String[] result = new String[nums.length];\\n        int max = 0;\\n        for (int i : nums) {\\n            if (i > max) max = i;\\n        }", "class Solution {\\n    class Score implements Comparable<Score>\\n    {\\n        Integer value;\\n        Score(Integer val)\\n        {\\n            value=val;\\n        }"]}
{"id": "108", "ref_java": ["class Solution {\\n    public boolean checkPerfectNumber(int num) {\\n        int num1 = 0;\\n        if(num % 2 != 0){\\n            return false;\\n        }", "class Solution {\\n    public boolean checkPerfectNumber(int num) {\\n        int count = 0;\\n        for(int i=1; i<=num/2; i++) {\\n            if(num%i == 0) {\\n                count += i;\\n            }", "class Solution {\\n    public boolean checkPerfectNumber(int num) {\\n        if(num==1){\\n            return false;\\n        }"]}
{"id": "109", "ref_java": ["class Solution {\\n    public int fib(int n) {\\n        int a=0;\\n        int b=1;\\n        if(n==0)\\n            return a;\\n        if(n==1)\\n            return b;\\n        if(n==2)\\n            return a+b;\\n        int c=a+b;\\n        for(int i=2;i<n;i++)\\n        {\\n            a=b;\\n            b=c;\\n            c=a+b;\\n        }", "class Solution {\\n    public int fib(int n) {\\n        if(n==0){\\n            return 0;\\n        }", "class Solution {\\n    public int fib(int n) {\\n        if(n==0){\\n            return 0;\\n        }"]}
{"id": "111", "ref_java": ["class Solution {\\n    public boolean detectCapitalUse(String word) {\\n        if(word.length() <= 1) return true;\\n        int a = word.charAt(0) - \\'A\\';\\n        ", "class Solution {\\n    public boolean detectCapitalUse(String word) {\\n       String[] words=word.split(\" \"); ", "class Solution {\\n    public boolean detectCapitalUse(String word) {\\n        boolean flag = true;\\n        char[]ch = word.toCharArray();\\n        if(ch.length==1){\\n            return true;\\n        }"]}
{"id": "112", "ref_java": ["class Solution {\\n    public int findLUSlength(String a, String b) {\\n        if(a.equals(b)){\\n            return -1;\\n        }", "class Solution {\\n    public int findLUSlength(String a, String b) {\\n        if(a.equals(b)){\\n            return -1;\\n        }", "class Solution {\\n    public int findLUSlength(String a, String b) {\\n       if(a.equals(b)){\\n           return -1;\\n       }"]}
{"id": "113", "ref_java": ["class Solution {\\n  public int getMinimumDifference(TreeNode root) {\\n    int ans = Integer.MAX_VALUE;\\n    int prev = -1;\\n    Deque<TreeNode> stack = new ArrayDeque<>();\\n\\n    while (root != null || !stack.isEmpty()) {\\n      while (root != null) {\\n        stack.push(root);\\n        root = root.left;\\n      }", "class Solution {\\n\\n    ", "class Solution {\\n\\n    "]}
{"id": "114", "ref_java": ["class Solution {\\n    static void reverse(char[] arr, int i, int j){\\n       while(i<j){\\n        char temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n        i++;\\n        j--;\\n    }", "class Solution {\\n    public String reverseStr(String s, int k) {\\n        char[] str = s.toCharArray();\\n        int n = str.length;\\n        for(int i = 0 ; i <= n-1; i += 2*k){\\n            if(i+k-1 <= n-1){\\n                reverseK(i,i+k-1,str);\\n            }", "class Solution {\\n   public String reverseStr(String s, int k) {\\n    char[] arr = s.toCharArray();\\n    int n = arr.length;\\n    for (int i = 0; i < n; i += 2 * k) {\\n        int left = i;\\n        int right = Math.min(i + k - 1, n - 1);\\n        while (left < right) {\\n            char temp = arr[left];\\n            arr[left++] = arr[right];\\n            arr[right--] = temp;\\n        }"]}
{"id": "115", "ref_java": ["class Solution {\\n\\n    static int max;\\n\\n    static int height(TreeNode root){\\n        if(root==null) return 0;\\n\\n        int left = height(root.left);\\n        int right = height(root.right);\\n\\n        max = Math.max(max, left+right);\\n\\n        return 1+Math.max(left,right);\\n    }", "class Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\n        ", "class Solution {\\n    int m=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        help(root);\\n        return m;\\n    }"]}
{"id": "116", "ref_java": ["class Solution {\\n    public boolean checkRecord(String s) {\\n        int count=0;\\n        int count2=0;\\n        boolean flag1=false;\\n        boolean flag2=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'A\\'){\\n                count++;\\n                count2=0;\\n                flag1=false;\\n                flag2=true;\\n            }", "class Solution {\\n    public boolean checkRecord(String s) {\\n        int countAbs = 0;\\n        int countLeave = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'A\\'){\\n                countAbs++;\\n                if(countAbs >= 2){\\n                    return false;\\n                }", "class Solution {\\n    public boolean checkRecord(String s) {\\n        \\n        char[] chars = s.toCharArray();\\n\\n        int lateCount = 0;\\n        int absCount = 0;\\n        for (char c : chars) {\\n            switch (c) {\\n                case \\'P\\':\\n                    lateCount = 0;\\n                    break;\\n                case \\'L\\':\\n                    lateCount++;\\n                    if (lateCount == 3) {\\n                        return false;\\n                    }"]}
{"id": "117", "ref_java": ["class Solution {\\n    public String reverseWords(String s) {\\n    StringBuilder sb = new StringBuilder(s);\\n    int i = 0;\\n    int j = 0;\\n\\n    while (i < sb.length()) {\\n        while (i < j || i < sb.length() && sb.charAt(i) == \\' \\')\\n        {\\n            ++i;          \\n        }", "class Solution {\\n    function reverseWords($s) {\\n        return implode(\\' \\', array_map(function($word) {\\n            return strrev($word);\\n        }", "class Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.split(\"\\\\\\\\s+\"); \\n        StringBuilder reversed = new StringBuilder();\\n        for (String word : words) {\\n            StringBuilder reversedWord = new StringBuilder(word);\\n            reversedWord.reverse(); \\n            reversed.append(reversedWord).append(\" \"); \\n        }"]}
{"id": "118", "ref_java": ["class Solution {\\n  public int maxDepth(Node node) {\\n    if (node == null) return 0;\\n    \\n    var max = 0;\\n\\n    for (var child : node.children)\\n      max = Math.max(max, maxDepth(child));\\n\\n    return max + 1;\\n  }", "class Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null) {\\n            return 0;\\n        }", "class Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null)\\n            return 0;\\n        if(root.children.size()==0)\\n            return 1;\\n        int height = 0;\\n        for(Node child : root.children) {\\n            int recAns = maxDepth(child);\\n            height = Math.max(height,recAns);\\n        }"]}
{"id": "119", "ref_java": ["class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int sum = 0;\\n        for (int i = nums.length - 2; i >= 0; i = i - 2) {\\n            sum += nums[i];\\n        }", "class Solution {\\n    public int arrayPairSum(int[] nums) {\\n        int temp[] = new int[20001];\\n        for(int i: nums){\\n            temp[i+10000]++;\\n        }", "class Solution { \\n    public int arrayPairSum(int[] nums) {\\n        int sum = 0;\\n        quickSort(nums, 0, nums.length - 1);\\n        for (int i = 0; i < nums.length; i += 2)\\n            sum += nums[i];\\n        return sum;\\n    }"]}
{"id": "120", "ref_java": ["class Solution {\\n  private int sum = 0;\\n\\n  private int helper(TreeNode node) {\\n    if (node == null) return 0;\\n\\n    var left = helper(node.left);\\n    var right = helper(node.right);\\n\\n    sum += Math.abs(left - right);\\n\\n    return left + right + node.val;\\n  }", "class Solution {\\n    int findSum(TreeNode root){\\n        if(root==null) return 0;\\n        return root.val + findSum(root.left) + findSum(root.right);\\n    }", "class Solution {\\n\\n    static int sum(TreeNode root){\\n        if(root==null) return 0;\\n        else return root.val + sum(root.left)+sum(root.right);\\n    }"]}
{"id": "121", "ref_java": ["class Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        int [][] arr = new int [r][c];\\n        int row = mat.length, col = mat[0].length, ri=0, ci=0;\\n        if(r==row || c==col ) return mat;\\n        if(r*c != row*col) return mat;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                arr[ri][ci] = mat[i][j];\\n                ci++;\\n                if(ci > c-1 ){\\n                ci=0;\\n                ri++;\\n            }", "class Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n        \\n        ", "class Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\n        int oldRow = mat.length;\\n        int oldCol = mat[0].length;\\n\\n\\n        "]}
{"id": "122", "ref_java": ["class Solution {\\n    private boolean isSubtreePresent = false;\\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\\n        \\n        int leftSubtreeDepth = getDepth(subRoot.left);\\n        int rightSubtreeDepth = getDepth(subRoot.right);\\n        int treeDepth = getDepthForTree(root, subRoot, leftSubtreeDepth, rightSubtreeDepth);\\n        return this.isSubtreePresent;\\n    }", "class Solution {\\n    List<TreeNode> list=new ArrayList<>();\\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\\n        dfs(root);\\n        String str=path(subRoot);\\n        for(int i=0;i<list.size();i++){\\n            TreeNode front=list.get(i);\\n            String ans=path(front);\\n            if(ans.equals(str))return true;\\n        }", "class Solution {\\n  \\n  public boolean isSubtree(TreeNode root, TreeNode subRoot) {\\n    if (root == null) return false;\\n    if (dfs(root, subRoot)) return true;\\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\\n  }"]}
{"id": "123", "ref_java": ["class Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> typeCandySet = new HashSet<>();\\n        int halfLength = candyType.length/2;\\n\\n        for (int c : candyType) {\\n            if (typeCandySet.size() >= halfLength)\\n                return halfLength;\\n            typeCandySet.add(c);\\n        }", "class Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet();\\n        for (int i : candyType) set.add(i);\\n        return Math.min(set.size(), candyType.length / 2);\\n    }", "class Solution {\\n    public int distributeCandies(int[] candyType) {\\t\\n        Set<Integer> set = new HashSet<>();\\n        for (int c : candyType) set.add(c);\\n\\t\\t\\n        return Math.min(set.size(), candyType.length / 2);\\n    }"]}
{"id": "127", "ref_java": ["class Solution {\\n    public void req(Node root, List<Integer> tree)\\n    {\\n        tree.add(root.val);\\n        for (Node child : root.children)\\n        {\\n            if (child != null)\\n                req(child, tree);\\n        }", "class Solution {\\n    public List<Integer> preorder(Node root) {\\n        ", "class Solution {\\n    List<Integer> result = new ArrayList<>();\\n    \\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return result;\\n        result.add(root.val);\\n        \\n        for (Node child : root.children) {\\n            preorder(child);\\n        }"]}
{"id": "128", "ref_java": ["class Solution {\\n  private void postorder(Node node, List<Integer> list) {\\n    if (node == null) return;\\n\\n    for (var child : node.children)\\n      postorder(child, list);\\n\\n    list.add(node.val);\\n  }", "class Solution {\\n    List<Integer> ans=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return ans;\\n        for(Node n: root.children){\\n            postorder(n);\\n        }", "class Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (root == null) {\\n            return new ArrayList();\\n        }"]}
{"id": "129", "ref_java": ["class Solution {\\n    public int findLHS(int[] nums) {\\n        Arrays.sort(nums);\\n        int prev = Integer.MIN_VALUE;\\n        int prevN = 0;\\n        int curr = nums[0];\\n        int currN = 0;\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != curr) {\\n                if (prev+1 == curr)\\n                    max = Math.max(prevN + currN, max);\\n                prev = curr;\\n                prevN = currN;\\n                curr = nums[i];\\n                currN = 1;\\n            }", "class Solution {\\n    public int findLHS(int[] nums) {\\n       if(nums.length == 0){\\n           return 0;\\n       }", "class Solution {\\r\\n    public int findLHS(int[] nums) {\\r\\n      "]}
{"id": "132", "ref_java": ["class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        \\n        int minRow =m; \\n        int minCol =n;\\n\\n        for(int[] arr : ops) {\\n            minRow = Math.min(minRow, arr[0]);\\n            minCol = Math.min(minCol, arr[1]);\\n        }", "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int[] o:ops) {\\n            m = Math.min(m,o[0]);\\n            n = Math.min(n,o[1]);\\n        }", "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.length; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }"]}
{"id": "133", "ref_java": ["class Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer>H=new LinkedHashMap<>();\\n        for(int i=0;i<list1.length;i++){\\n            H.put(list1[i],i);\\n        }", "class Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) map.put(list1[i], i);\\n        int min = 2001;\\n        List<String> words = new ArrayList<>();\\n        for (int i = 0; i < list2.length; i++) {\\n            int idx = map.getOrDefault(list2[i], 2001), sum = idx + i;\\n            if (min > sum) min = sum;\\n        }", "class Solution {\\n    public String[] findRestaurant(String[] arr1, String[] arr2) {\\n        \\n        HashMap<String,Integer> hp = new HashMap<>();\\n        ArrayList<String> arr = new ArrayList<>();\\n\\n        for(int i=0; i<arr1.length; i++){\\n            hp.put(arr1[i],i);\\n        }"]}
{"id": "134", "ref_java": ["class Solution {\\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\\n       int leftPointer = 0;\\n        int currentPointer = flowerbed[0];\\n        int count=0;\\n        for (int rightPointer = 1; rightPointer < flowerbed.length; rightPointer++) {\\n            if (currentPointer== 0 && currentPointer == leftPointer && currentPointer==flowerbed[rightPointer]) {\\n                count++;\\n                leftPointer=1;\\n            }", "class Solution {\\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\\n        if (n == 0) {\\n            return true;\\n        }", "class Solution {\\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\\n        if (n == 0) {\\n            return true;\\n        }"]}
{"id": "135", "ref_java": ["class Solution {\\n    public String tree2str(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }", "class Solution {\\n    StringBuilder ans = new StringBuilder(); ", "class Solution {\\n    public String tree2str(TreeNode t) {\\n        StringBuilder res = new StringBuilder();\\n        dfs(t, res);\\n        return res.toString();\\n    }"]}
{"id": "138", "ref_java": ["class Solution {\\n    public TreeNode merge(TreeNode r1, TreeNode r2){\\n        if(r1==null && r2==null) return null;\\n        int value = (r1==null?0:r1.val) + (r2==null?0:r2.val);\\n        TreeNode node = new TreeNode(value);\\n        node.left = merge(r1==null?null:r1.left,r2==null?null:r2.left);\\n        node.right = merge(r1==null?null:r1.right,r2==null?null:r2.right);\\n        return node;\\n    }", "class Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        \\n        if(root1 == null && root2 == null)\\n            return null;\\n        if (root1 == null)\\n            return root2;\\n        if (root2 == null)\\n            return root1;\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1;\\n    }", "class Solution {\\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\\n        if(root1==null) return root2;\\n        if(root2==null) return root1;\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left,root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1;\\n    }"]}
{"id": "142", "ref_java": ["class Solution {\\n    public int maximumProduct(int[] nums) {\\n        Arrays.sort(nums);\\n        int case1 = nums[0]*nums[1]*nums[nums.length-1];\\n        int case2 = nums[nums.length-1]*nums[nums.length-2]*nums[nums.length-3];\\n\\n        int maxProduct = Integer.max(case1, case2);\\n        return maxProduct;\\n    }", "class Solution {\\n    public int maximumProduct(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return Math.max(nums[n-1] * nums[n-2] * nums[n-3],nums[0]*nums[1]*nums[n-1]);\\n    }", "class Solution {\\n    public int maximumProduct(int[] nums) {\\n        Arrays.sort(nums);\\n        int case1 = nums[0]*nums[1]*nums[nums.length-1];\\n        int case2 = nums[nums.length-1]*nums[nums.length-2]*nums[nums.length-3];\\n\\n        int maxProduct = Integer.max(case1, case2);\\n        return maxProduct;\\n    }"]}
{"id": "143", "ref_java": ["class Solution {\\n    public List<Double> averageOfLevels(TreeNode root) {\\n        ", "class Solution {\\n    public List<Double> averageOfLevels(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>(List.of(root));\\n        List<Double> ans = new ArrayList<>();\\n        while (q.size() > 0) {\\n            double qlen = q.size(), row = 0;\\n            for (int i = 0; i < qlen; i++) {\\n                TreeNode curr = q.poll();\\n                row += curr.val;\\n                if (curr.left != null) q.offer(curr.left);\\n                if (curr.right != null) q.offer(curr.right);\\n            }", "class Solution {\\n    double sum =0;\\n    double cnt;\\n    List<Double> temp = new LinkedList<Double>();\\n    public List<Double> averageOfLevels(TreeNode root) {\\n        printLevelorder(root);\\n        return temp;\\n    }"]}
{"id": "144", "ref_java": ["class Solution {\\n    public double findMaxAverage(int[] nums, int k) {\\n        int sum = 0;\\n       for(int i = 0; i < k; i ++) \\n           sum += nums[i];\\n       int maxSum = sum;\\n       for(int i = k; i < nums.length; i ++) {\\n           sum += nums[i] - nums[i - k];\\n           maxSum = Math.max(maxSum, sum);\\n       }", "class Solution {\\n    public double findMaxAverage(int[] nums, int k) {\\n        int maxSum = 0;\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if(i < k) {\\n                maxSum = sum;\\n                continue;\\n            }", "class Solution {\\n    public double findMaxAverage(int[] nums, int k) {\\n        int sum = 0;\\n        for(int i=0; i<k; i++) {\\n            sum += nums[i];\\n        }"]}
{"id": "145", "ref_java": ["class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int len=nums.length;\\n        int an=0;\\n        int arr[]=new int[10001];\\n        int ans[]=new int[2];\\n        int count=0;\\n         \\n        for(int i=0;i<len;i++){\\n            arr[nums[i]]++;\\n        }", "class Solution {\\n    public int[] findErrorNums(int[] nums) \\n    {\\n        int i = 0;\\n        while(i<nums.length)\\n        {\\n            int correctIndex = nums[i] - 1;\\n            if(nums[i] != nums[correctIndex])\\n            {\\n                swap(nums, i, correctIndex);\\n            }", "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n\\n        HashSet<Integer> set= new HashSet<>();\\n        int sum=0;\\n        for(int num: nums){\\n            if(set.contains(num)){\\n                res[0]=num;\\n            }"]}
{"id": "146", "ref_java": ["class Solution {\\n    \\n    public boolean findTarget(TreeNode root, int k) {\\n        Set<Integer> hs=new HashSet<>();\\n        \\n        \\n        TreeNode curr=root;\\n        \\n        while(curr!=null){\\n            if(curr.left==null){\\n                if(hs.contains(k-curr.val)) return true;\\n                hs.add(curr.val);\\n                curr=curr.right;\\n            }", "class Solution {\\n    Set<Integer> set = new HashSet<>();\\n    public boolean findTarget(TreeNode root, int k) {\\n        if(k == 0) return true;\\n        if(root == null) return false;\\n        \\n        int curr = root.val;\\n        if(set.contains(k - curr)) return true;\\n        set.add(curr);\\n        \\n        return findTarget(root.left, k) || findTarget(root.right, k);\\n    }", "class Solution {\\n    public boolean findTarget(TreeNode root, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n\\n        int left = 0, right = result.size() - 1;\\n        while (left < right) {\\n            int sum = result.get(left) + result.get(right);\\n            if (sum == k) {\\n                return true;\\n            }"]}
{"id": "147", "ref_java": ["class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int point[] = {0,0}", "class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int UpDown = 0;\\n        int LeftRight = 0;\\n\\n        for (char c : moves.toCharArray() )\\n        {\\n            if (c == \\'U\\')\\n                UpDown++;\\n            else if (c == \\'D\\')\\n                UpDown--;\\n            else if (c == \\'R\\')\\n                LeftRight++;\\n            else if (c == \\'L\\')\\n                LeftRight--;\\n        }", "class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0 , y = 0 ;\\n\\t\\tfor (int i = 0; i < moves.length(); i++) {\\n\\t\\t\\tif (moves.charAt(i)==\\'L\\') x++;\\n\\t\\t\\tif (moves.charAt(i)==\\'R\\') x--;\\n\\t\\t\\tif (moves.charAt(i)==\\'U\\') y++;\\n\\t\\t\\tif (moves.charAt(i)==\\'D\\') y--;\\n\\t\\t}"]}
{"id": "148", "ref_java": ["class Solution {\\n    public int[][] imageSmoother(int[][] img) {\\n        int rows = img.length;\\n        int cols = img[0].length;\\n        int[][] result = new int[rows][cols];\\n\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                int total_sum = 0;\\n                int count = 0;\\n\\n                for (int l = Math.max(0, i-1); l < Math.min(rows, i+2); ++l) {\\n                    for (int k = Math.max(0, j-1); k < Math.min(cols, j+2); ++k) {\\n                        total_sum += img[l][k];\\n                        count += 1;\\n                    }", "class Solution {\\n    public int[][] imageSmoother(int[][] img) {\\n        int res[][] = new int[img.length][img[0].length];\\n        for(int i = 0; i < img.length; i++) {\\n            for(int j = 0; j < img[0].length; j++) {\\n                res[i][j] = smoothen(img, i, j);\\n            }", "class Solution {\\n    public int[][] imageSmoother(int[][] img) {\\n        int rows = img.length;\\n        int cols = img[0].length;\\n        int[][] result = new int[rows][cols];\\n\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                int totalSum = 0;\\n                int count = 0;\\n\\n                for (int x = Math.max(0, i-1); x < Math.min(rows, i+2); ++x) {\\n                    for (int y = Math.max(0, j-1); y < Math.min(cols, j+2); ++y) {\\n                        totalSum += img[x][y];\\n                        count += 1;\\n                    }"]}
{"id": "149", "ref_java": ["class Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Set<Integer>hs=new HashSet();\\n        find(root,hs);\\n        int k=0;\\n        int[] ans=new int[hs.size()];\\n        for(var i:hs){\\n            ans[k++]=i;\\n        }", "class Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Set<Integer>hs=new HashSet();\\n        find(root,hs);\\n        int k=0;\\n        int[] ans=new int[hs.size()];\\n        for(var i:hs){\\n            ans[k++]=i;\\n        }", "class Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Set<Integer>hs=new HashSet();\\n        find(root,hs);\\n        int k=0;\\n        int[] ans=new int[hs.size()];\\n        for(var i:hs){\\n            ans[k++]=i;\\n        }"]}
{"id": "150", "ref_java": ["class Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }"]}
{"id": "151", "ref_java": ["class Solution {\\n    public boolean validPalindrome(String s) {\\n        return util1(s);\\n    }", "class Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        \\n        while(i <= j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            }", "class Solution {\\n    public boolean validPalindrome(String s) {\\n        int low = 0 , high = s.length()-1 , count1 = 0 , count2 = 0;\\n        while(low<high){\\n            if(s.charAt(low)==s.charAt(high)){\\n                low++; high--;\\n            }"]}
{"id": "152", "ref_java": ["class Solution {\\n    public int calPoints(String[] op) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<op.length;i++)\\n        {\\n            if(Character.isDigit(op[i].charAt(0)))\\n            {\\n                a.add(Integer.parseInt(op[i]));\\n            }", "class Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        int result = 0;\\n        for (String operation : operations) {\\n            switch (operation) {\\n                case \"+\" -> {\\n                    int res = stack.get(stack.size() - 2) + stack.peek();\\n                    stack.add(res);\\n                    result += res;\\n                }", "class Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String s : operations) {\\n            if (s.equals(\"+\")) {\\n                stack.push(stack.peek() + stack.elementAt(stack.size()-2));\\n            }"]}
{"id": "153", "ref_java": ["class Solution {\\n    public boolean hasAlternatingBits(int n) {\\n        while(n>0){\\n            ", "class Solution {\\n    public boolean hasAlternatingBits(int n) {\\n        while(n!=0){\\n            int a=(n&1);\\n            n>>=1;\\n            int b=(n&1);\\n            if(a==b)\\n                return false;\\n        }", "class Solution {\\n    public boolean hasAlternatingBits(int n) {\\n        String s = Integer.toBinaryString(n);\\n        char prev = s.charAt(0);\\n        for(int i=1; i<s.length(); i++) {\\n            int x = Character.compare(prev, s.charAt(i));\\n            System.out.println(x);\\n            if(x == 0) {\\n                return false;\\n            }"]}
{"id": "154", "ref_java": ["class Solution {\\n    public int countBinarySubstrings(String s) {\\n        int curr = 1, prev = 0, ans = 0;\\n        for (int i = 1; i < s.length(); i++)\\n            if (s.charAt(i) == s.charAt(i-1)) curr++;\\n            else {\\n                ans += Math.min(curr, prev);\\n                prev = curr;\\n                curr = 1;\\n            }", "class Solution {\\n    public int countBinarySubstrings(String s) {\\n       int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            for(int j=i+1;j<s.length();j++){\\n                String substring=s.substring(i,j+1);\\n                boolean isvalid=valid(substring);\\n                if(isvalid) ans++;\\n            }", "class Solution {\\n    public int countBinarySubstrings(String s) {\\n        int curr = 1, prev = 0, ans = 0;\\n        for (int i = 1; i < s.length(); i++)\\n            if (s.charAt(i) == s.charAt(i-1)) curr++;\\n            else {\\n                ans += Math.min(curr, prev);\\n                prev = curr;\\n                curr = 1;\\n            }"]}
{"id": "155", "ref_java": ["class Solution {\\n    public int findShortestSubArray(int[] nums) {\\n        HashMap<Integer,Integer> count=new HashMap<>();\\n        for(int i:nums){\\n            count.put(i,count.getOrDefault(i,0)+1);\\n        }", "class Solution {\\n    public int findShortestSubArray(int[] nums) {\\n        Map<Integer, int[]> m = new HashMap<>();\\n        int max = 0;\\n        int res = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int a = nums[i];\\n            if(!m.containsKey(a)){\\n                m.put(a, new int[]{i,i,1}", "class Solution {\\n    public int findShortestSubArray(int[] nums) {\\n        int max=0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i: nums){\\n            list.add(i);\\n            map.put(i,map.getOrDefault(i,0)+1);\\n            if((int)map.get(i)>max)\\n                max=map.get(i);\\n        }"]}
{"id": "156", "ref_java": ["class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null){\\n            return null;\\n        }", "class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null)\\n        return null;\\n\\n        if(root.val == val)\\n        return root;\\n\\n        TreeNode t;\\n        if(val < root.val){\\n            t = searchBST(root.left, val);\\n        }", "class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null){\\n            return null;\\n        }"]}
{"id": "158", "ref_java": ["class Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0; ", "class Solution {\\n    public int search(int[] nums, int target) {\\n        return binary(nums, target, 0, nums.length-1);\\n    }", "class Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0, end = nums.length - 1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }"]}
{"id": "161", "ref_java": ["class Solution {\\n    public String toLowerCase(String s) {\\n        return s.toLowerCase();\\n    }", "class Solution {\\n    public String toLowerCase(String s) {\\n       return(s.toLowerCase()); \\n    }", "class Solution {\\n    public String toLowerCase(String s) {\\n        return s.toLowerCase();\\n    }"]}
{"id": "162", "ref_java": ["class Solution {\\n    public boolean isOneBitCharacter(int[] bits) {\\n        int count = 0;\\n        int n = bits.length;\\n        for(int i=n-2;i>=0 && bits[i]!=0;i--){\\n            count++;\\n        }", "class Solution {\\n    public boolean isOneBitCharacter(int[] bits) {\\n        return solve(0, bits, 0);\\n    }", "class Solution {\\n    public boolean isOneBitCharacter(int[] bits) {\\n        return solve(0, bits, 0);\\n    }"]}
{"id": "163", "ref_java": ["class Solution {\\n    public int pivotIndex(int[] nums) {\\n        ", "class Solution {\\n    public int pivotIndex(int[] nums) {\\n      int n=nums.length;\\n      int suff[]=new int[n];\\n      int pref[]=new int[n];\\n      suff[0]=nums[0];\\n      pref[n-1]=nums[n-1];\\n      int k=0;\\n      for(int i=1;i<n;i++){\\n        k=n-i-1;\\n        suff[i]=suff[i-1]+nums[i];\\n        pref[k]=pref[k+1]+nums[k];\\n      }", "class Solution {\\n    public int pivotIndex(int[] arr) {\\n        int n=arr.length;\\n        if(n==1){\\n            return 0;\\n        }"]}
{"id": "164", "ref_java": ["class Solution {\\n    public List<Integer> selfDividingNumbers(int left, int right) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        for(int i= left; i<= right; i++){\\n            int num = i;\\n            int count = 0;\\n            while(num>0){\\n                int r = num%10;\\n                if(r == 0){\\n                    count = 0;\\n                    break;\\n                }", "class Solution {\\n    public boolean selfDivide(int originalNum) {\\n        int num = originalNum;\\n        while(num>0) {\\n            int rem = num % 10;\\n            if(rem==0) {\\n                return false;\\n            }", "class Solution {\\n    public List<Integer> selfDividingNumbers(int left, int right) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i = left;i<=right;i++){\\n            if(isDividing(i)){\\n                list.add(i);\\n            }"]}
{"id": "165", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        int startColor = image[sr][sc];\\n        if (startColor == color)\\n            return image;\\n        image[sr][sc] = color;\\n        LinkedList<Integer[]> line = new LinkedList<>();\\n        int [][]move = new int[][]{{0,1}", "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }"]}
{"id": "166", "ref_java": ["class Solution {\\n    public char nextGreatestLetter(char[] letters, char target)\\n    {\\n      return letter(letters,target);\\n    }", "class Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n         int start = 0;\\n        int end = letters.length-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            if(letters[mid] > target){\\n                end = mid - 1;\\n            }", "class Solution {\\n    public char nextGreatestLetter(char[] letters, char target) {\\n         int start = 0;\\n        int end = letters.length-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            if(letters[mid] > target){\\n                end = mid - 1;\\n            }"]}
{"id": "167", "ref_java": ["class Solution {\\n    public int minCostClimbingStairs(int[] cost) {\\n        int prevOne = 0;\\n        int prevTwo = 0;\\n        \\n        for (int i = cost.length - 1; i >= 0; i--) {\\n            int currentCost = cost[i] + Math.min(prevOne, prevTwo);\\n            prevTwo = prevOne;\\n            prevOne = currentCost;\\n        }", "class Solution {\\n    public int minCostClimbingStairs(int[] cost) {\\n        int sz = cost.length;\\n        int minCost[] = new int[sz];\\n        minCost[0] = cost[0];\\n        minCost[1] = cost[1];\\n        for(int indx = 2; indx < sz; indx++){\\n                minCost[indx] = cost[indx] +  Math.min(minCost[indx - 1], minCost[indx - 2]);\\n        }", "class Solution {\\n    public int minCostClimbingStairs(int[] cost) {\\n        int prevOne = 0;\\n        int prevTwo = 0;\\n        \\n        for (int i = cost.length - 1; i >= 0; i--) {\\n            int currentCost = cost[i] + Math.min(prevOne, prevTwo);\\n            prevTwo = prevOne;\\n            prevOne = currentCost;\\n        }"]}
{"id": "168", "ref_java": ["class Solution {\\n    public int dominantIndex(int[] nums) {\\n       int max1= 0;\\n        int max2= 0;\\n        int maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max1 < nums[i]) {\\n                max2 = max1;\\n                max1 = nums[i];\\n                maxIndex = i;\\n            }", "class Solution {\\n    public int dominantIndex(int[] nums) {\\n        int arr[][]=new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n        }", "class Solution {\\n    public int dominantIndex(int[] nums) {\\n        int arr[][]=new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n        }"]}
{"id": "169", "ref_java": ["class Solution {\\n    public String shortestCompletingWord(String licensePlate, String[] words) {\\n        int[] count = new int[26];\\n        for (char c:licensePlate.toCharArray()){\\n            if (c>=\\'a\\'&& c<=\\'z\\')\\n                count[c-\\'a\\']++;\\n            else if (c>=\\'A\\' && c<=\\'Z\\')\\n                count[c-\\'A\\']++;\\n        }", "class Solution {\\n    public String shortestCompletingWord(String licensePlate, String[] words) {\\n    \\n        int[] licensePlateCounts = new int[26];\\n\\n        for(char c: licensePlate.toCharArray()) {\\n              if(Character.isAlphabetic(c)) {\\n                  char ch = Character.toLowerCase(c);\\n                  licensePlateCounts[ch-\\'a\\']++;\\n              }", "class Solution {\\n    public String shortestCompletingWord(String licensePlate, String[] words) {\\n        int[] count = new int[26];\\n        for (char c:licensePlate.toCharArray()){\\n            if (c>=\\'a\\'&& c<=\\'z\\')\\n                count[c-\\'a\\']++;\\n            else if (c>=\\'A\\' && c<=\\'Z\\')\\n                count[c-\\'A\\']++;\\n        }"]}
{"id": "170", "ref_java": ["class Solution {\\n    private final int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19}", "class Solution {\\n\\n    private final int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}", "class Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        HashSet<Integer> s=new HashSet<>();\\n        s.add(2);\\n        s.add(3);\\n        s.add(5);\\n        s.add(7);\\n        s.add(11);\\n        s.add(13);\\n        s.add(17);\\n        s.add(19);\\n        s.add(23);\\n        s.add(29);\\n        s.add(31);\\n        int res=0;\\n        for(int i=left;i<=right;i++){\\n            int x=num(i);\\n            if(s.contains(x))\\n                res++;\\n        }"]}
{"id": "171", "ref_java": ["class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int r = matrix.length;\\n        int c= matrix[0].length;\\n        int i = r-1;\\n        while(i>=0){\\n            int j = 0;\\n            int e = matrix[i][j];\\n            for(int m = i; m<r && j<c ; m++){\\n                if(e != matrix[m][j] ){\\n                    return false;\\n                }", "class Solution {\\n    public boolean check(int arr[][],int row,int col){\\n        int val=arr[row][col];\\n        while(row!=arr.length && col!=arr[0].length){\\n            if(val!=arr[row][col]){\\n                return false;\\n            }", "class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n           for(int j=0,i=0;j<matrix[0].length;j++){\\n            int k=j;\\n            int t=i;\\n            int key=matrix[i][j];\\n            while(t<matrix.length && k<matrix[0].length ){\\n                    if(matrix[t][k]!=key){\\n                        return false;\\n                    }"]}
{"id": "172", "ref_java": ["class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\t\\tfor (int i = 0; i < stones.length(); i++) if(jewels.indexOf(stones.charAt(i)) != -1) count++;\\n\\t\\treturn count;\\n    }", "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int c=0;\\n        for(int i=0;i<jewels.length();i++)\\n        {\\n            for(int j=0;j<stones.length();j++)\\n            {\\n                c+= jewels.charAt(i)==stones.charAt(j) ? 1 : 0 ;\\n            }", "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n          int counter = 0;\\n          for(int i = 0; i < jewels.length(); i++){\\n             for(int j = 0; j < stones.length(); j++){\\n                 if(jewels.charAt(i) == stones.charAt(j)){\\n                     counter++;\\n                 }"]}
{"id": "173", "ref_java": ["class Solution {\\n    TreeNode prev = null; ", "class Solution {\\n    List<Integer> list;\\n    public int minDiffInBST(TreeNode root) {\\n        list=new ArrayList<>();\\n        help(root);\\n        Collections.sort(list);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<list.size()-1;i++)\\n        {\\n            min=Math.min(min,Math.abs(list.get(i)-list.get(i+1)));\\n        }", "class Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int minDiffInBST(TreeNode root) {\\n        dfs(root);\\n        return ans;\\n    }"]}
{"id": "174", "ref_java": ["class Solution {\\n    public boolean rotateString(String s, String goal) {\\n        if (s == null || goal == null) {\\n            return false;\\n        }", "class Solution {\\n    public boolean rotateString(String s, String goal) {\\n        if(s.length()!=goal.length())return false;\\n        return((s+s).indexOf(goal)>=0);\\n    }", "class Solution {\\n    public boolean rotateString(String s, String goal){\\n        "]}
{"id": "175", "ref_java": ["class Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] str = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n            \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n            \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n            \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}", "class Solution {\\n    private String transform(String str) {\\n        String s[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}", "class Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        }"]}
{"id": "176", "ref_java": ["class Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] res = new int[2];\\n\\n        int lines = 1;\\n        int width = 0;\\n\\n        for (char c : s.toCharArray()) {\\n            int charWidth = widths[c - \\'a\\'];\\n            if (width + charWidth > 100) {\\n                lines++;\\n                width = charWidth;\\n            }", "class Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] arr = new int[2];\\n        int x = 1;\\n        int sum = 0;\\n        for(char c : s.toCharArray()){\\n            int char_width = widths[c - \\'a\\'];\\n            if(char_width + sum > 100){\\n                x++;\\n                sum = 0;\\n            }", "class Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            }"]}
{"id": "177", "ref_java": ["class Solution {\\n\\n    static double helper(int arr1[], int arr2[], int arr3[]){\\n        double x1 = (double)arr1[0];\\n        double y1 = (double)arr1[1];\\n\\n        double x2 = (double)arr2[0];\\n        double y2 = (double)arr2[1];\\n\\n        double x3 = (double)arr3[0];\\n        double y3 = (double)arr3[1];\\n\\n        return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)))/2;\\n    }", "class Solution {\\n    double maxArea = Integer.MIN_VALUE;\\n    int[] idxList = new int[3];\\n    int n, k;\\n\\n    public double largestTriangleArea(int[][] points) {\\n        if(points == null) return 0;\\n        n = points.length;\\n        k = 3;\\n        dfs(points, 0, 0);\\n        return maxArea;\\n    }", "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\\n        return ans;\\n    }"]}
{"id": "178", "ref_java": ["class Solution {\\n    public String mostCommonWord(String s1, String[] ban) {\\n        s1 = s1.toLowerCase().replaceAll(\"\\\\\\\\W+\",\" \");\\n        String[] arr = s1.split(\"\\\\\\\\s+\");\\n\\n        int n = arr.length;\\n        HashMap<String,Integer> hp = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            hp.put(arr[i],hp.getOrDefault(arr[i],0)+1);\\n        }", "class Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }", "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }"]}
{"id": "179", "ref_java": ["class Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }", "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        ", "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }"]}
{"id": "180", "ref_java": ["class Solution {\\n    static final char[] vowels = new char[10];\\n    static {\\n        vowels[0] = \\'A\\';\\n        vowels[1] = \\'E\\';\\n        vowels[2] = \\'I\\';\\n        vowels[3] = \\'O\\';\\n        vowels[4] = \\'U\\';\\n        vowels[5] = \\'a\\';\\n        vowels[6] = \\'e\\';\\n        vowels[7] = \\'i\\';\\n        vowels[8] = \\'o\\';\\n        vowels[9] = \\'u\\';\\n    }", "class Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }", "class Solution {\\n    public String toGoatLatin(String sentence) {\\n        String[] words = sentence.split(\"\\\\\\\\s+\");\\n        StringBuilder res=new StringBuilder(\"\");\\n        StringBuilder a= new StringBuilder(\"\");\\n        for(int i=0;i<words.length;i++){\\n            if(!\"aeiouAEIOU\".contains(words[i].charAt(0)+\"\")){\\n                res.append(words[i].substring(1)).append(words[i].charAt(0)).append(\"maa\").append(a+\" \");\\n            }"]}
{"id": "181", "ref_java": ["class Solution {\\n    public List<List<Integer>> largeGroupPositions(String s) {\\n        List <List<Integer>> ans = new ArrayList<>();\\n        int p=0,count=0;\\n        char cur=\\'1\\';\\n        for(int i=0;i<s.length();i++){\\n            if(cur!=s.charAt(i)){\\n                if(count>2) ans.add(List.of(p,p+count-1));\\n                p=i;\\n                count=1;\\n                cur=s.charAt(i);\\n            }", "class Solution {\\n    public List<List<Integer>> largeGroupPositions(String s) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> tmp = new ArrayList<>();\\n        int count = 1;\\n        \\n        for (int i = 0; i < s.length() - 1; i++) {\\n            ", "class Solution {\\n\\t\\tpublic List<List<Integer>> largeGroupPositions(String s) {\\n\\t\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\t\\tint start =0, end=0;\\n\\n\\t\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\t\\t"]}
{"id": "182", "ref_java": ["class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] rev = new int[image[0].length][image.length];\\n        for(int i=0; i<image.length; i++){\\n            int k=0;\\n            for(int j=image[i].length-1; j>=0; j--){\\n                rev[i][k++] = image[i][j];\\n            }", "class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        reverse(image);\\n        for(int i = 0; i<image.length;i++){\\n            for(int j = 0; j<image[i].length;j++){\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }", "class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int len=image.length;\\n        int l=image[0].length;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<l/2;j++){\\n                int temp=image[i][j];\\n                image[i][j]=image[i][l-1-j];\\n                image[i][l-1-j]=temp;\\n                "]}
{"id": "183", "ref_java": ["class Solution {\\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\\n        return Math.min(rec1[2], rec2[2]) > Math.max(rec1[0],rec2[0]) &&\\n        Math.min(rec1[3], rec2[3]) > Math.max(rec1[1], rec2[1]);\\n    }", "class Solution {\\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\\n        int recx1 = rec1[0]; \\n        int recy1 = rec1[1];\\n        int recx2 = rec1[2];\\n        int recy2 = rec1[3];\\n\\n        int rec2x1 = rec2[0]; \\n        int rec2y1 = rec2[1];\\n        int rec2x2 = rec2[2];\\n        int rec2y2 = rec2[3];\\n\\n        if(rec2x1 < recx2 && rec2y1 < recy2 && rec2x2 > recx1 && rec2y2 > recy1) return true;\\n        \\n        return false;\\n    }", "class Solution {\\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\\n        return \\n            rec1[0] < rec2[2] &&\\n            rec1[1] < rec2[3] &&\\n            rec1[2] > rec2[0] &&\\n            rec1[3] > rec2[1]\\n        ;\\n    }"]}
{"id": "184", "ref_java": ["class Solution {\\nprivate static int nextChar(String str, int cur){\\n    while(cur > -1 && str.charAt(cur) == \\'#\\'){\\n        int cnt = 1;\\n        for(cur--; cur > -1 && cnt > 0; cur--)\\n            cnt += str.charAt(cur) == \\'#\\'? 1 : -1;\\n    }", "class Solution {\\n    public boolean backspaceCompare(String s, String t) {\\n        Stack<Character> ss = new Stack();\\n        Stack<Character> tt = new Stack();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'#\\') {\\n                if(!ss.isEmpty()) {\\n                    ss.pop();\\n                }", "class Solution {\\n    public boolean backspaceCompare(String s, String t) {\\n        int szS = s.length(), szT = t.length();\\n        String sNew = findFinalString(s);\\n        String tNew = findFinalString(t);\\n        return sNew.equals(tNew);\\n    }"]}
{"id": "185", "ref_java": ["class Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)) {\\n            int mask = 0;\\n            for(int i = 0; i < s.length(); i ++) {\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask & ind) != 0) return true;\\n                mask |= ind;\\n            }", "class Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()){\\n            return false;\\n        }", "class Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n\\n        int diff = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != goal.charAt(i)) diff++;\\n        }"]}
{"id": "186", "ref_java": ["class Solution {\\n    public boolean lemonadeChange(int[] bills) {\\n        Stack<Integer> stackOf5=new Stack();\\n        Stack<Integer> stackOf10=new Stack();\\n\\n        for(int i=0;i<bills.length;i++)\\n        {\\n            int input=bills[i];\\n            if(input==5)\\n            {\\n                stackOf5.push(input);\\n            }", "class Solution {\\n    public boolean lemonadeChange(int[] bills) {\\n        \\n        int count5=0;\\n        int count10=0;\\n        int count20=0;\\n\\n        for(int bill: bills){\\n            ", "class Solution {\\n    public boolean lemonadeChange(int[] bills) {\\n        ArrayList<Integer> change = new ArrayList<>();\\n\\n        for(int i=0; i<bills.length; i++) {\\n            if(bills[i]==5) {\\n                change.add(5);\\n            }"]}
{"id": "187", "ref_java": ["class Solution {\\n    public int[][] Transpose(int[][] matrix) {\\n\\n        int rows = matrix[0].Length;\\n        int columns = matrix.Length;\\n\\n        int[][] newMatrix = new int[rows][];\\n\\n        for (int i = 0; i < rows; i++) {\\n            newMatrix[i] = new int[columns];\\n            for (int j = 0; j < columns; j++) {\\n                newMatrix[i][j] = matrix[j][i];\\n            }", "class Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int arr[][]=new int[col][row];\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row;j++)\\n            {\\n            arr[i][j]=matrix[j][i];\\n            }", "class Solution {\\n    transpose(matrix) {\\n        const n = matrix.length;\\n        const m = matrix[0].length;\\n\\n        const ans = [];\\n\\n        for (let j = 0; j < m; j++) {\\n            const temp = [];\\n            for (let i = 0; i < n; i++) {\\n                temp.push(matrix[i][j]);\\n            }"]}
{"id": "188", "ref_java": ["class Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }", "class Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            }", "class Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }"]}
{"id": "189", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    int index = 0;\\n    public boolean verifyTree(TreeNode root,List<Integer> l){\\n        if(root==null)return true;\\n        boolean left = verifyTree(root.left,l);\\n        boolean right = verifyTree(root.right,l);\\n       \\n       if(root.left==null && root.right==null){\\n           if(index>l.size())return false;\\n            if(index<l.size() && root.val!=l.get(index)){\\n                return false;\\n            }", "class Solution {\\n    public static void findLeaves(TreeNode root, ArrayList<Integer> list){  \\n        if(root == null) return;\\n        if(root.left==null && root.right==null)\\n            list.add(root.val);\\n        findLeaves(root.left, list);\\n        findLeaves(root.right, list);\\n    }"]}
{"id": "190", "ref_java": ["class Solution {\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }", "class Solution {\\n    public ListNode middleNode(ListNode head) {\\n        ", "class Solution {\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null ){\\n        fast=fast.next.next;\\n        slow=slow.next;\\n         }"]}
{"id": "191", "ref_java": ["class Solution {\\n    public int projectionArea(int[][] grid) {\\n        int a=0,x=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int mr=Integer.MIN_VALUE;\\n            int mc=Integer.MIN_VALUE;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)x+=1;\\n                if(grid[i][j]>mr)mr=grid[i][j];\\n                if(grid[j][i]>mc)mc=grid[j][i];\\n            }", "class Solution {\\n    public int projectionArea(int[][] grid) {\\n        int a=0,x=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int mr=Integer.MIN_VALUE;\\n            int mc=Integer.MIN_VALUE;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)x+=1;\\n                if(grid[i][j]>mr)mr=grid[i][j];\\n                if(grid[j][i]>mc)mc=grid[j][i];\\n            }", "class Solution {\\n    public int projectionArea(int[][] grid) {\\n        int a=0,x=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            int mr=Integer.MIN_VALUE;\\n            int mc=Integer.MIN_VALUE;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)x+=1;\\n                if(grid[i][j]>mr)mr=grid[i][j];\\n                if(grid[j][i]>mc)mc=grid[j][i];\\n            }"]}
{"id": "192", "ref_java": ["class Solution {\\n    public String[] uncommonFromSentences(String s1, String s2) {\\n        String arr1[] = s1.split(\" \");\\n        String arr2[] = s2.split(\" \");\\n        int n1 = arr1.length;\\n        int n2 = arr2.length;\\n\\n        HashMap<String,Integer> hp1 = new HashMap<>();\\n        HashMap<String,Integer> hp2 = new HashMap<>();\\n\\n        for(int i=0; i<n1; i++){\\n            hp1.put(arr1[i],hp1.getOrDefault(arr1[i],0)+1);\\n        }", "class Solution {\\n    public String[] uncommonFromSentences(String s1, String s2) {\\n        Map<String,Integer> ma=new HashMap<>();\\n        ArrayList<String> aa=new ArrayList<>();\\n        String combain=s1+\" \"+s2;\\n        for(String s:combain.split(\" \")){\\n           ma.put(s,ma.getOrDefault(s,0)+1);\\n        }", "class Solution {\\n    public String[] uncommonFromSentences(String s1, String s2) {\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Integer>mp2=new HashMap<>();\\n\\n    String[]ans= new String[s1.length()];\\n\\n    String[]arr1=s1.split(\" \");\\n    String[]arr2=s2.split(\" \");\\n\\n    for(int i=0;i<arr1.length;i++){\\n\\n    if(!mp.containsKey(arr1[i])){\\n        mp.put(arr1[i],1);\\n    }"]}
{"id": "193", "ref_java": ["class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int aum = 0;\\n        boolean[] inAlice = new boolean[100001];\\n        for (int i = 0; i < aliceSizes.length; i++) {\\n            aum += aliceSizes[i];\\n            inAlice[aliceSizes[i]] = true;\\n        }", "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int aliceSum = 0;\\n        for (int i : aliceSizes) {\\n            aliceSum += i;\\n        }", "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n\\n        int sum1=0,sum2=0;\\n        Map<Integer,Integer> map = new HashMap();\\n\\n        for(int i=0;i<aliceSizes.length;i++){\\n            sum1=sum1+aliceSizes[i];\\n        }"]}
{"id": "194", "ref_java": ["class Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int h = grid[i][j];\\n                int fullS = h > 0 ? h * 4 + 2 : 0;\\n                ", "class Solution {\\n\\npublic int surfaceArea(int[][] grid) {\\n    int total = 0;\\n    int n = grid.length;\\n    \\n    for(int i =0; i<n; i++)\\n    {\\n        for(int j =0; j<n; j++)\\n        {\\n            if(grid[i][j]>0)\\n                total += 6*grid[i][j]-2*(grid[i][j]-1); ", "class Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                "]}
{"id": "195", "ref_java": ["class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            }", "class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            }", "class Solution {\\npublic boolean isMonotonic(int[] A) {\\n    int i = 1;\\n    for(; i < A.length; i++)\\n        if(A[i - 1] > A[i]) break;\\n    if(i != A.length)\\n        for(i = A.length-2; i > -1; i--)\\n            if(A[i + 1] > A[i]) return false;\\n    return true;\\n}"]}
{"id": "196", "ref_java": ["class Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n\\n        ArrayList<Integer> inOrder = new ArrayList<>();\\n        \\n        findInOrder(root,inOrder);\\n\\n        if(inOrder.size()==0) return null;\\n\\n        TreeNode newRoot = new TreeNode(inOrder.get(0));\\n        TreeNode temp1 = newRoot;\\n        TreeNode temp2;\\n        for(int i = 1; i<inOrder.size(); i++){\\n             temp2 = new TreeNode(inOrder.get(i));\\n             temp1.right = temp2;\\n             temp1 = temp2;\\n        }", "class Solution {\\n    public void inorder(TreeNode root,ArrayList<TreeNode> ans) {\\n        if(root==null) return;\\n        inorder(root.left,ans);\\n        ans.add(root);\\n        inorder(root.right,ans);\\n    }", "class Solution {\\n    public void inorder(TreeNode root,ArrayList<TreeNode> ans) {\\n        if(root==null) return;\\n        inorder(root.left,ans);\\n        ans.add(root);\\n        inorder(root.right,ans);\\n    }"]}
{"id": "197", "ref_java": ["class Solution {\\n    public int[] sortArrayByParity(int[] nums) {\\n        return Arrays.stream(Arrays.stream(nums).boxed().toArray(Integer[]::new))\\n                .sorted(Comparator.comparingInt(n -> (int) n % 2 == 0 ? 0 : 1))\\n                .mapToInt(x -> x)\\n                .toArray();\\n    }", "class Solution {\\n    public int[] sortArrayByParity(int[] nums) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        \\n        while(left<right){\\n            ", "class Solution {\\n    public int[] sortArrayByParity(int[] nums) {\\n        return sort(nums, 0, 0);\\n    }"]}
{"id": "198", "ref_java": ["class Solution {\\n    public int smallestRangeI(int[] nums, int k) {\\n        int min=nums[0] , max= nums[0];\\n        for(int i=0 ; i<nums.length ; i++){\\n            if(nums[i]<min)\\n            min = nums[i];\\n            if(nums[i]>max)\\n            max = nums[i];\\n        }", "class Solution {\\n    public int smallestRangeI(int[] nums, int k) {\\n        ", "class Solution {\\n    public int smallestRangeI(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        if(nums.length==1)\\n            return 0;\\n        \\n        int a=nums[0]+k;\\n        int b=nums[nums.length-1]-k;\\n        \\n        int ans = b-a;\\n        if(ans<0)\\n            ans=0;\\n        return ans;\\n    }"]}
{"id": "199", "ref_java": ["class Solution {\\n\\n    static int hcf(int x, int y){\\n        if(y==0) return x;\\n        return hcf(y,x%y);\\n    }", "class Solution {\\n    public boolean hasGroupsSizeX(int[] deck) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<deck.length;i++){\\n            map.put(deck[i], map.getOrDefault(deck[i],0)+1);\\n        }", "class Solution {\\n    public boolean hasGroupsSizeX(int[] deck) {\\n        \\n        "]}
{"id": "200", "ref_java": ["class Solution {\\n    public String reverseOnlyLetters(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0 , j = s.length()-1;\\n\\n        while (i < j)\\n        {\\n            char c1 = arr[i];\\n            char c2 = arr[j];\\n            if (Character.isLetter(c1) && Character.isLetter(c2)) {\\n                arr[i++] = c2;\\n                arr[j--] = c1;\\n            }", "class Solution {\\n    public String reverseOnlyLetters(String s) {\\n        char temp[] = s.toCharArray();      \\n        int low = 0 , high = s.length()-1;\\n        while(low < high){\\n            if(Character.isAlphabetic(temp[low]) && Character.isAlphabetic(temp[high])){\\n                char i = temp[low];temp[low] = temp[high];\\n                temp[high] = i;", "class Solution {\\n    public String reverseOnlyLetters(String s) {\\n        StringBuilder str= new StringBuilder(s);\\n        int i = 0;\\n        int j = s.length()-1;\\n        while(i<j){\\n            while(i<j && !((s.charAt(i)>=\\'a\\'&& s.charAt(i)<=\\'z\\')|| (s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\'))) i++;\\n            while(i<j && !((s.charAt(j)>=\\'a\\'&& s.charAt(j)<=\\'z\\')|| (s.charAt(j)>=\\'A\\' && s.charAt(j)<=\\'Z\\'))) j--;\\n            str.setCharAt(i, s.charAt(j));\\n            str.setCharAt(j, s.charAt(i));\\n            i++;\\n            j--;\\n        }"]}
{"id": "201", "ref_java": ["class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }", "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }", "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }"]}
{"id": "202", "ref_java": ["class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int len1 = name.length();\\n        int len2 = typed.length();\\n        int idx1 = 0;\\n        int idx2 = 0;\\n        char prev = name.charAt(0);\\n        char c2 = typed.charAt(0);\\n        char c1 = prev;\\n        while(idx1 < len1 && idx2 < len2 ){\\n            c1 = name.charAt(idx1);\\n            c2 = typed.charAt(idx2);\\n            if(c1 == c2){\\n                idx1++;\\n                idx2++;\\n                prev = c1;\\n            }", "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n=name.length();\\n        int m=typed.length();\\n        if(n>m)return false;\\n        if(name.charAt(0)!=typed.charAt(0))return false;\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(name.charAt(i)==typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n        int i=1 , j=1;\\n        \\n        "]}
{"id": "203", "ref_java": ["class Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        if (emails.length == 1) {\\n            return 1;\\n        }", "class Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String email : emails){\\n            String[] split = email.split(\"@\");\\n            String localName = split[0].replace(\".\", \"\");\\n            String domainName = split[1];\\n            int index = localName.indexOf(\\'+\\');\\n            if(index >= 0)\\n                localName = localName.substring(0, index);\\n            String address = localName + \\'@\\' + domainName;\\n            map.put(address, map.getOrDefault(address, 0) + 1);\\n        }", "class Solution {\\n    public int numUniqueEmails(String[] emails) {\\n        Set<String> set = new HashSet();\\n        int count=0;\\n        for(String email: emails){\\n            int atIndex = email.indexOf(\"@\");\\n            int plusIndex= email.indexOf(\"+\");\\n            String str1 = \"\";\\n            if(plusIndex>=0) str1 = email.substring(0,plusIndex);\\n            else str1 = email.substring(0,atIndex);\\n            str1 = str1.replace(\".\",\"\") + email.substring(atIndex);\\n            if(set.add(str1)) count++;\\n        }"]}
{"id": "205", "ref_java": ["class Solution {\\n    int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return sum;\\n\\n        dfs(root, low, high);\\n\\n        return sum;\\n    }", "class Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }", "class Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }"]}
{"id": "206", "ref_java": ["class Solution {\\n    public static boolean validMountainArray(int[] arr) {\\n        if (arr.length < 2 || arr[0] > arr[1]) return false;\\n        int maxIndex = 0;\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[maxIndex]) {\\n                maxIndex = i;\\n            }", "class Solution {\\n    public boolean validMountainArray(int[] a) {\\n        int max = Integer.MIN_VALUE;\\n        int index_Max = 0, x = 0;\\n        boolean b = true;\\n        for (int i : a) max = Math.max(max, i);\\n        while (max != a[x++]) index_Max++;\\n        if(a.length < 3 || index_Max == a.length - 1 || index_Max == 0) return false;\\n        for (int i = 0; i < index_Max; i++) {\\n            if (!(a[i] < a[i + 1])) return false;\\n        }", "class Solution {\\n    public boolean validMountainArray(int[] arr) {\\n        if(arr.length < 3) return false;\\n        int l = 0;\\n        int r = arr.length - 1;\\n        while(l + 1 < arr.length - 1 && arr[l] < arr[l + 1]) l++;\\n        while(r - 1 > 0 && arr[r] < arr[r - 1]) r--;\\n        return l == r;\\n    }"]}
{"id": "207", "ref_java": ["class Solution {\\n    public int[] diStringMatch(String s) {\\n        int n = s.length();\\n        char [] ch = s.toCharArray();\\n\\n        int ans[] = new int [n+1];\\n\\n        int x = 0;\\n        int y = n;\\n        for(int i = 0;i<ch.length;i++) {\\n            if(ch[i] == \\'I\\') {\\n                ans[i] = x++;\\n            }", "class Solution {\\n    public int[] diStringMatch(String s) {\\n        \\n        int[] result = new int[s.length()+1];\\n        int min =0;\\n        int max =s.length();\\n        int i =0;\\n        \\n        for(i = 0; i < s.length(); i++) {\\n           result[i] = s.charAt(i) == \\'I\\' ? min++ : max--;\\n        }", "class Solution {\\n    public int[] diStringMatch(String s) {\\n        int low=0;\\n        int high=s.length();\\n        int ans[]=new int[s.length()+1];\\n     for(int i=0;i<s.length();i++){\\n         if(s.charAt(i)==\\'I\\'){\\n             ans[i]=low;\\n             low++;\\n         }"]}
{"id": "208", "ref_java": ["class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int row=strs.length;\\n        int col=strs[0].length();\\n        int ans=0;\\n\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    ans++;\\n                    break;\\n                }", "class Solution {\\n    public static int minDeletionSize(String[] strs) {\\n        int c=0;\\n        int l = strs.length;\\n        for (int i = 0; i < strs[0].length(); i++) {\\n            for (int j = 0; j <l-1 ; j++) {\\n                if((int)strs[j].charAt(i)>(int)strs[j+1].charAt(i))\\n                {\\n                    c++;\\n                    break;\\n                }", "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++) {\\n        \\tint temp = 0;\\n        \\tfor(int j=0;j<strs.length;j++) {\\n        \\t\\tint a = strs[j].charAt(i);\\n        \\t\\tif(a>=temp) {\\n        \\t\\t\\ttemp = a;\\n        \\t\\t}"]}
{"id": "209", "ref_java": ["class Solution {\\n    public static boolean isAlienSorted(String[] words, String order) {\\n\\n        char[] dictionary = new char[26];\\n\\n        for (int i = 0; i < order.length(); i++) {\\n            char c= (char) (\\'a\\'+i);\\n            dictionary[order.charAt(i)-\\'a\\']=c;\\n        }", "class Solution {\\n    public static boolean isAlienSorted(String[] words, String order) {\\n\\n        char[] dictionary = new char[26];\\n\\n        for (int i = 0; i < order.length(); i++) {\\n            char c= (char) (\\'a\\'+i);\\n            dictionary[order.charAt(i)-\\'a\\']=c;\\n        }", "class Solution {\\n    public boolean isAlienSorted(String[] words, String order) {\\n        int alien[] = new int[26];\\n        for(int i = 0; i < order.length(); i++)\\n        {\\n            alien[order.charAt(i)-\\'a\\']= i;\\n        }"]}
{"id": "210", "ref_java": ["class Solution {\\n    public int repeatedNTimes(int[] nums) {\\n        HashMap <Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],map.getOrDefault((nums[i]),0)+1);\\n        }", "class Solution {\\n    public int repeatedNTimes(int[] nums) {\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if(i != j && nums[i] == nums[j]) {\\n                    return nums[i];\\n                }", "class Solution {\\n    public int repeatedNTimes(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int el : nums) {\\n            if (!set.add(el)) return el;\\n        }"]}
{"id": "211", "ref_java": ["class Solution {\\n\\n    static boolean helper(TreeNode root, int a){\\n        if(root==null) return true;\\n        if(root.val!=a) return false;\\n        else return helper(root.left,a) && helper(root.right,a);\\n    }", "class Solution {\\n    boolean ans = true;\\n    public boolean isUnivalTree(TreeNode root) {\\n        int x = root.val;\\n        return func(root, x);\\n    }", "class Solution {\\n    public boolean isUnivalTree(TreeNode root) {\\n       Queue<TreeNode> q = new LinkedList<>();\\n       q.add(root);\\n       while(!q.isEmpty()){\\n           TreeNode temp = q.peek();\\n           q.remove();\\n           if(temp.left!=null){\\n               if(temp.left.val!=temp.val){\\n                   return false;\\n               }"]}
{"id": "212", "ref_java": ["class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n = nums.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        for (int k = n - 1; k >= 2; k--) {\\n            int c = nums[k];\\n            int b = nums[k - 1];\\n            int a = nums[k - 2];\\n            \\n            if (this.isValid(a, b, c)) {\\n                return a + b + c;\\n            }", "class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i-1] + nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            \\n        return 0;\\n    }", "class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>1;i--)\\n        \\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;       \\n    }"]}
{"id": "213", "ref_java": ["class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[]ans=new int[nums.length];\\n        int s=0;\\n        int e=nums.length-1;\\n        int idx=nums.length-1;\\n        while(s<=e){\\n            int start=Math.abs(nums[s]);\\n            int end=Math.abs(nums[e]);\\n            if(start<end){\\n                ans[idx]=(int)Math.pow(end,2);\\n                e--;\\n            }", "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }", "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] copy = new int[nums.length];\\n        int l = 0,r = nums.length - 1;\\n        while (r>=l){\\n            "]}
{"id": "214", "ref_java": ["class Solution {\\n\\n    \\n\\n\\n    public List<Integer> addToArrayForm(int[] num, int k) {\\n        \\n        \\n        List<Integer> l1 = new ArrayList<>();\\n        List<Integer> l2 = new ArrayList<>();\\n        while(k>0){\\n            l2.add(0,k%10);\\n            k/=10;\\n        }", "class Solution {\\n    public List<Integer> addToArrayForm(int[] num, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        int carry = 0;\\n        for (int i=num.length-1; i>=0; i--) {\\n            if (k>0) {\\n                int temp = k%10;\\n                if (num[i]+temp+carry>9) {\\n                    ans.add(0, (num[i]+temp+carry)%10);\\n                    carry=1;\\n                    k /= 10;\\n                }", "class Solution {\\n    public List<Integer> addToArrayForm(int[] num, int k) {\\n        LinkedList<Integer> res = new LinkedList<>();\\n        int carry = 0;\\n        int i = 0;\\n        for (i = num.length - 1; i >= 0 && k > 0; i--) {\\n            int temp = num[i];\\n            res.addFirst((temp + carry + (k % 10)) % 10);\\n            carry = (temp + carry + (k % 10)) / 10;\\n            k /= 10;\\n        }"]}
{"id": "215", "ref_java": ["class Solution {\\n    public int getDepth(TreeNode root, int search){\\n        if(root == null)\\n            return -(int)1e9;\\n        if(search == root.val)\\n            return 0;\\n        \\n        return 1 + Math.max(getDepth(root.left, search), getDepth(root.right, search));\\n    }", "class Solution {\\n    int depthX, parentX;\\n\\n    public boolean isCousins(TreeNode root, int x, int y) {\\n        depthX = parentX = -1;\\n        return Boolean.TRUE.equals(traversal(root, x, y, 1, -1));\\n    }", "class Solution {\\n    public boolean isCousins(TreeNode root, int x, int y) {\\n        if(depthOf(root, x) != depthOf(root, y)) {\\n            return false;\\n        }"]}
{"id": "216", "ref_java": ["class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int count=0;\\n        int x[]=new int[n+1];\\n        int y[]=new int[n+1];\\n         Arrays.fill(x, 0);\\n         Arrays.fill(y, 0);\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            x[trust[i][0]]=1;\\n        }", "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int indegree[]=new int[n+1];\\n        \\n        for(int i=0;i<trust.length;i++)\\n        {\\n            indegree[trust[i][1]]++;\\n        }", "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n\\n        int[] trusted = new int[n + 1];\\n        int[] untrusted = new int[n + 1];\\n       \\n        for (int[] t : trust){\\n            trusted[t[1]]++;\\n            untrusted[t[0]]++;\\n        }"]}
{"id": "217", "ref_java": ["class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n\\n        loop:\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int k = i - 1;\\n                    while(k >= 0){\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }", "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        int m=0,n=0;\\n   \\n        for(int i=0 ; i<=7 ; i++ ){\\n           for(int j=0 ; j<=7 ; j++ ){\\n            \\n            if(board[i][j] == \\'R\\'){\\n\\n                m = i;\\n                n = j;\\n               break;\\n            }", "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n\\n        loop:\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int k = i - 1;\\n                    while(k >= 0){\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }"]}
{"id": "218", "ref_java": ["class Solution {\\n   public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }", "class Solution {\\n    public List<String> commonChars(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>();\\n        int[] min_freq = new int[26]; ", "class Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        "]}
{"id": "219", "ref_java": ["class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }", "class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }", "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        }"]}
{"id": "220", "ref_java": ["class Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n == 0) return 1;\\n        int res = 0;\\n        int fac = 1;\\n        \\n        while(n != 0){\\n            res += fac * (n % 2 == 0 ? 1 : 0);\\n            fac *= 2;\\n            n /= 2;\\n        }", "class Solution {\\n    public int bitwiseComplement(int n) {\\n        if(n==0) return 1;\\n        int x = 0;\\n        int ans = 0;\\n\\n        while(n>0){\\n            int r = n%2;\\n            if(r==1){\\n                x++;\\n            }", "class Solution {\\n    public int bitwiseComplement(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        String res = \"\";\\n        for(char c :bin.toCharArray())\\n        {\\n            if( c == \\'1\\')\\n                res += \"0\";\\n            else\\n                res += \"1\";\\n        }"]}
{"id": "221", "ref_java": ["class Solution {\\n    public boolean canThreePartsEqualSum(int[] arr) {\\n        int sum = 0;\\n        for (int n: arr) {\\n            sum += n;\\n        }", "class Solution {\\n    public boolean canThreePartsEqualSum(int[] A) {\\n        int sum=0;\\n        for(int i: A)\\n            sum=sum+i;\\n        if(sum%3!=0)\\n            return false;\\n        int each=sum/3,temp=0,found=0;\\n        for (int i=0; i<A.length; i++) {\\n            temp=temp+A[i];\\n            if(temp==each){\\n                temp = 0;\\n                found++;\\n            }", "class Solution {\\n    public boolean canThreePartsEqualSum(int[] arr) {\\n        int total=0;\\n        for(int val: arr) {\\n            total += val;\\n        }"]}
{"id": "222", "ref_java": ["class Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        int val = 0;\\n        List<Boolean> list = new ArrayList<>();\\n        for(int num : nums){\\n            ", "class Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        LinkedList<Boolean> res = new LinkedList<>();\\n\\t\\t\\n        int num = 0;\\n        for(int value : nums){\\n            num = (num * 2 + value) % 5;\\n            res.addLast(num == 0);\\n        }", "class Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        var result = new ArrayList<Boolean>(nums.length);\\n        long counter = 0;\\n        for (int num : nums) {\\n            counter = ((counter << 1) + num) % 5;\\n            result.add(counter == 0);\\n        }"]}
{"id": "223", "ref_java": ["class Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }", "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }", "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }"]}
{"id": "224", "ref_java": ["class Solution {\\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return helper(root , 0);\\n    }", "class Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }", "class Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }"]}
{"id": "225", "ref_java": ["class Solution {\\n    public boolean divisorGame(int n) {\\n        if(n%2 == 0) return true;\\n        return false;\\n    }", "class Solution {\\n    public boolean divisorGame(int n) {\\n        return n%2==0 ;\\n    }", "class Solution {\\n    public boolean divisorGame(int n) {\\n        if(n%2 == 0) return true;\\n        return false;\\n    }"]}
{"id": "226", "ref_java": ["class Solution {\\n    public int[][] allCellsDistOrder(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][];\\n        result[0] = new int[] {r0, c0}", "class Solution {\\n    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {\\n        int[][] arr = new int[rows*cols][2];\\n        ", "class Solution {\\n    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {\\n        "]}
{"id": "227", "ref_java": ["class Solution {\\n    public boolean isBoomerang(int[][] points) {\\n        return !((points[0][0]-points[1][0])*(points[0][1]-points[2][1])==(points[0][0]-points[2][0])*(points[0][1]-points[1][1]));\\n    }", "class Solution {\\n    public boolean isBoomerang(int[][] p) {\\n        int x1=p[0][0];\\n        int y1=p[0][1];\\n        int x2=p[1][0];\\n        int y2=p[1][1];\\n        int x3=p[2][0];\\n        int y3=p[2][1];\\n        int area=x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2);\\n        return area!=0;\\n    }", "class Solution {\\n    public boolean isBoomerang(int[][] points) {\\n        return !((points[0][0]-points[1][0])*(points[0][1]-points[2][1])==(points[0][0]-points[2][0])*(points[0][1]-points[1][1]));\\n    }"]}
{"id": "228", "ref_java": ["class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0; i<stones.length; i++) {\\n            list.add(stones[i]);\\n        }", "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones){\\n            queue.add(i);\\n        }", "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : stones)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }"]}
{"id": "229", "ref_java": ["class Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st=new Stack<>();\\n        \\n        st.add(s.charAt(0));\\n        for(int i=1; i<s.length(); i++){\\n            \\n            if(!st.isEmpty() && st.peek().equals(s.charAt(i))){\\n                st.pop();\\n                continue;\\n            }", "class Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st=new Stack<>();\\n        \\n        st.add(s.charAt(0));\\n        for(int i=1; i<s.length(); i++){\\n            \\n            if(!st.isEmpty() && st.peek().equals(s.charAt(i))){\\n                st.pop();\\n                continue;\\n            }", "class Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st=new Stack<>();\\n        \\n        st.add(s.charAt(0));\\n        for(int i=1; i<s.length(); i++){\\n            \\n            if(!st.isEmpty() && st.peek().equals(s.charAt(i))){\\n                st.pop();\\n                continue;\\n            }"]}
{"id": "231", "ref_java": ["class Solution {\\n    public int heightChecker(int[] heights) {\\n        int[] sorted= Arrays.copyOf(heights, heights.length);\\n        Arrays.sort(sorted);\\n        int count=0;\\n        for(int i=0;i<heights.length;i++){\\n            if(sorted[i]!=heights[i]) count++;\\n        }", "class Solution {\\n    public int heightChecker(int[] heights) {\\n        int count = 0;\\n        int[] givenHeights = new int[heights.length];\\n        for (int i=0; i< heights.length; i++){\\n            givenHeights[i] = heights[i];\\n        }", "class Solution {\\n    public int heightChecker(int[] heights) {\\n        \\n        int [] arr = new int[heights.length];\\n        System.arraycopy(heights,0,arr,0,heights.length);\\n        Arrays.sort(arr);\\n\\n        int count = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] != heights[i]){\\n                count++;\\n            }"]}
{"id": "233", "ref_java": ["class Solution {\\n    public String gcdOfStrings(String str1, String str2) {\\n        ", "class Solution {\\n    public String gcdOfStrings(String str1, String str2) {\\n        if(!(str1+str2).equals(str2+str1)) return \"\";\\n        int gcdval=gcd(str1.length(),str2.length());\\n        return str2.substring(0,gcdval);\\n    }", "class Solution {\\n    public String gcdOfStrings(String str1, String str2) {\\n        if (!(str1 + str2).equals(str2 + str1)) {\\n            return \"\";\\n        }"]}
{"id": "235", "ref_java": ["class Solution {\\n    public String[] findOcurrences(String text, String first, String second) {\\n        String[] st = text.split(\" \");\\n        List<String> l = new ArrayList<String>();\\n        int  i =0,n = st.length;\\n\\n        while(i<n)\\n        {\\n            if(st[i].equals(first))\\n                if(i+1<n-1 && st[i+1].equals(second))\\n                    l.add(st[i+2]);\\n            i++;\\n        }", "class Solution {\\n    public String[] findOcurrences(String text, String first, String second) {\\n        String arr[] = text.split(\" \");\\n        ArrayList<String> list = new ArrayList<>();\\n        for(int i=2;i<arr.length;i++){\\n            if(arr[i-1].equals(second) && arr[i-2].equals(first))\\n                list.add(arr[i]);\\n        }", "class Solution {\\n    public String[] findOcurrences(String text, String first, String second) {\\n        String[] split = text.split(\" \");\\n        List<String> list = new ArrayList<>();\\n        for (int i = 0; i < split.length - 2; i++) {\\n            if (split[i].equals(first) && split[i + 1].equals(second)) list.add(split[i + 2]);\\n        }"]}
{"id": "237", "ref_java": ["class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int n = arr.length;\\n\\n        int[] temp = arr.clone();", "class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int zeros = 0;\\n\\n        for (int i = 0; i < length; i++) {\\n            if (arr[i] == 0) {\\n                zeros++;\\n            }", "class Solution {\\n     public void duplicateZeros(int[] arr) {\\n\\n        int[] tempArr = new int[arr.length];\\n         \\n        for (int arrIndex = 0, tempIndex = 0; tempIndex < tempArr.length; arrIndex++) {\\n            tempArr[tempIndex] = arr[arrIndex];\\n\\n            if (tempArr[tempIndex++] == 0 && tempIndex < tempArr.length) {\\n                tempArr[tempIndex++] = 0;\\n            }"]}
{"id": "238", "ref_java": ["class Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) ", "class Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            ", "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans = new int[num_people];\\n        int i=0;\\n        int candy = 0;\\n        while(candies>0){\\n            if(i == num_people){\\n                i = 0;\\n            }"]}
{"id": "239", "ref_java": ["\nclass Solution {\n    public String defangIPaddr(String address) {\n        String output=\"\";\n        for(int i=0;i<address.length();i++){\n            if(address.charAt(i)=='.'){\n                output+=\"[.]\";\n            } else {\n                output+=address.charAt(i);\n            }\n        }\n        return output;\n    }\n}\n", "\nclass Solution {\n    public String defangIPaddr(String address) {\n        String output=\"\";\n        for(int i=0;i<address.length();i++){\n            if(address.charAt(i)=='.'){\n                output+=\"[.]\";\n            } else {\n                output+=address.charAt(i);\n            }\n        }\n        return output;\n    }\n}\n", "\nclass Solution {\n    public String defangIPaddr(String address) {\n        String output=\"\";\n        for(int i=0;i<address.length();i++){\n            if(address.charAt(i)=='.'){\n                output+=\"[.]\";\n            } else {\n                output+=address.charAt(i);\n            }\n        }\n        return output;\n    }\n}\n"]}
{"id": "241", "ref_java": ["class Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        ", "class Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr1);\\n        int[] ans = new int[arr1.length];\\n        int start = 0;\\n        int end = arr1.length - 1;\\n        int index = 0;\\n\\n        for (int i = 0; i < arr2.length; i++) {\\n            int target = arr2[i];\\n            start = 0;\\n            end = arr1.length - 1;\\n\\n            while (end >= start) {\\n                int mid = start + (end - start) / 2;\\n                if (arr1[mid] == target) {\\n                    for (int j = start; j <= end; j++) {\\n                        if (arr1[j] == target) {\\n                            ans[index++] = arr1[j];\\n                        }", "class Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        int p=0; \\n        for(int i:arr1)\\n        p=(i>p)?i:p;   \\n        int arr3[]= new int[p+1], ans[]= new int[arr1.length+arr2.length];\\n        for(int i:arr1)\\n        arr3[i]++;\\n\\n        int count=0;\\n        for(int i=0;i<arr2.length;i++){\\n            while(arr3[arr2[i]]>0){\\n                ans[count++]=arr2[i];\\n                arr3[arr2[i]]--;\\n            }"]}
{"id": "242", "ref_java": ["class Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }", "class Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }", "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }"]}
{"id": "243", "ref_java": ["class Solution {\\n    public int tribonacci(int n) {\\n       int ans[]=new int[n+3];\\n       ans[0]=0;\\n       ans[1]=1;\\n       ans[2]=1;\\n       int i=3;\\n       while(i<=n){\\n           ans[i]=ans[i-1]+ans[i-2]+ans[i-3];\\n           i++;\\n\\n       }", "class Solution {\\n    public int tribonacci(int n) {\\n        int a =0;\\n        int b =1;\\n        int c = 1;\\n        int sum=0;\\n        if(n==0){\\n            return 0;\\n        }", "class Solution {\\n    public int tribonacci(int n) {\\n        if(n==1 || n==2){\\n            return 1;\\n        }"]}
{"id": "246", "ref_java": ["class Solution {\\n    public int dayOfYear(String date) {\\n\\n        int month = 10 * date.charAt(5) + date.charAt(6) - 528, day = 10 * date.charAt(8) + date.charAt(9) - 528;\\n        \\n        ", "class Solution {\\n    public int dayOfYear(String date) {\\n        int days[] = {31,28,31,30,31,30,31,31,30,31,30,31}", "class Solution {\\n    public int dayOfYear(String date) {\\n        int days = 0;\\n        int[] arr = {31,28,31,30,31,30,31,31,30,31,30,31}"]}
{"id": "247", "ref_java": ["class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] counts = new int[26];\\n        ", "class Solution {\\n  public int countCharacters(String[] words, String chars) {\\n    var map = new int[26];\\n    var sum = 0;\\n\\n    for (var c : chars.toCharArray()) map[c - \\'a\\']++;\\n\\n    for (var word : words) {\\n      var map2 = map.clone();\\n      var valid = true;\\n\\n      for (var c : word.toCharArray()) {\\n        if (--map2[c - \\'a\\'] < 0) {\\n          valid = false;\\n          break;\\n        }", "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        Map<Character, Integer> ch = new HashMap<>();\\n\\n        for (char c : chars.toCharArray()) {\\n            ch.put(c, 1 + ch.getOrDefault(c, 0));\\n        }"]}
{"id": "249", "ref_java": ["class Solution {\\n    \\n    public int numPrimeArrangements(int n) {\\n        int np = numOfPrimes(n);\\n        int nnp = n-np;\\n        BigInteger ansa = fact(np).multiply(fact(nnp));\\n        ansa = ansa.mod(BigInteger.valueOf(1000000007));\\n        return ansa.intValue();\\n    }", "class Solution {\\n     long mod = (long)(1e9+7);\\n    public int numPrimeArrangements(int n) {\\n        if(n==1){\\n            return 1;\\n        }", "class Solution {\\n     long mod = (long)(1e9+7);\\n    public int numPrimeArrangements(int n) {\\n        if(n==1){\\n            return 1;\\n        }"]}
{"id": "251", "ref_java": ["class Solution {\\n    public int distanceBetweenBusStops(int[] distance, int start, int destination) {\\n        if (start > destination) {\\n            int temp = start;\\n            start = destination;\\n            destination = temp;\\n        }", "class Solution {\\n    public int distanceBetweenBusStops(int[] distance, int start, int destination) {\\n        int frontSum=0;\\n        int backSum=0;\\n        for(int i=start;i!=destination;i=(i+1)%distance.length) frontSum+=distance[i];\\n        for(int i=destination;i!=start;i=(i+1)%distance.length) backSum+=distance[i];\\n        return Math.min(frontSum,backSum);\\n    }", "class Solution {\\n    public int distanceBetweenBusStops(int[] distance, int start, int destination) {\\n        int sum=0,sum1=0,s=0;\\n        for(int i=0;i<distance.length;i++)\\n        {\\n            sum+=distance[i];\\n        }"]}
{"id": "252", "ref_java": ["class Solution {\\n    public String dayOfTheWeek(int day, int month, int year) {\\n        String[] days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}", "class Solution {\\n    public String dayOfTheWeek(int day, int month, int year) {\\n        int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 }", "class Solution {\\n    private int JAN_FIRST = 1, MAX_FEB = 28, LEAP_FEB = 29;\\n    private int MAX_DAYS_MONTHS1 = 31, MIN_DAYS_MONTHS = 1, MAX_DAYS_MONTHS2 = 30;\\n    private int MAX_MONTH = 12, MIN_MONTH = 1;\\n    private int MAX_YEAR = 9999, MIN_YEAR = 1000, MID_YEAR = 2000;\\n    private int JAN = 1, FEB = 2, MAR = 3, APR = 4, MAY = 5, JUN = 6, JUL = 7, AUG = 8, SEP = 9, OCT = 10, NOV = 11, DEC = 12;\\n            \\n    public String dayOfTheWeek(int day, int month, int year) \\n    {\\n        int dayD = dayInWeek(day, month,  year);\\n               \\n        if(dayD == 1)\\n        {\\n            return \"Sunday\";\\n        }"]}
{"id": "253", "ref_java": ["class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  ", "class Solution {\\n    int[] balloonAlph;\\n    public int maxNumberOfBalloons(String text) {\\n        if (text.length() < 7) return 0;\\n        int[] alphabet = new int[26];\\n        for (char c : text.toCharArray()) alphabet[c - \\'a\\']++;\\n        balloonAlph = balloonAlph == null ? createBalloonAlph() : balloonAlph;\\n        int count = 0;\\n        while (containsBalloon(alphabet)) count++;\\n        return count;\\n    }", "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\n        int a = 0, b = 0, l = 0, o = 0, n = 0, i = 0;\\n\\n        for (char c: text.toCharArray()){\\n            switch (c){\\n                case \\'a\\' -> a++;\\n                case \\'b\\' -> b++;\\n                case \\'l\\' -> l++;\\n                case \\'n\\' -> n++;\\n                case \\'o\\' -> o++;\\n            }"]}
{"id": "254", "ref_java": ["class Solution {\\npublic List<List> minimumAbsDifference(int[] arr) {\\n\\nArrays.sort(arr);\\nList<List> l2 = new ArrayList<List>();\\nint absDiff = Integer.MAX_VALUE;\\nfor(int i=0;i<arr.length-1;i++){\\nint curr = arr[i+1] - arr[i];\\nif(curr < absDiff){\\nl2.clear();\\nList l1 = Arrays.asList(arr[i],arr[i+1]);\\nl2.add(l1);\\nabsDiff = curr;\\n}", "class Solution {\\npublic List<List> minimumAbsDifference(int[] arr) {\\n\\nArrays.sort(arr);\\nList<List> l2 = new ArrayList<List>();\\nint absDiff = Integer.MAX_VALUE;\\nfor(int i=0;i<arr.length-1;i++){\\nint curr = arr[i+1] - arr[i];\\nif(curr < absDiff){\\nl2.clear();\\nList l1 = Arrays.asList(arr[i],arr[i+1]);\\nl2.add(l1);\\nabsDiff = curr;\\n}", "class Solution {\\n    public List<List<Integer>> minimumAbsDifference(int[] arr) {\\n        Arrays.sort(arr);\\n\\n        int diff = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length-1;i++){\\n            diff = Math.min(diff,arr[i+1]-arr[i]);\\n        }"]}
{"id": "255", "ref_java": ["class Solution {\\n    public boolean uniqueOccurrences(int[] arr) {\\n        HashMap<Integer, Integer> nums = new HashMap<>();\\n        for (int j : arr) {\\n            if (nums.containsValue(j)) continue;\\n            int count = 0;\\n            for (int k : arr)\\n                if (j == k)\\n                    count++;\\n            if (nums.containsKey(count))\\n                return false;\\n            else nums.put(count, j);\\n        }", "class Solution {\\n    public boolean uniqueOccurrences(int[] arr) {\\n        HashMap<Integer, Integer> nums = new HashMap<>();\\n        for (int j : arr) {\\n            if (nums.containsValue(j)) continue;\\n            int count = 0;\\n            for (int k : arr)\\n                if (j == k)\\n                    count++;\\n            if (nums.containsKey(count))\\n                return false;\\n            else nums.put(count, j);\\n        }", "class Solution {\\n    public boolean uniqueOccurrences(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        int count = 1;\\n        for(int i = 1; i < arr.length; i++){\\n            if(arr[i] == arr[i-1]) c++;\\n            else{\\n                if(set.contains(c)) return false;\\n\\n                set.add(c);\\n                c = 1;\\n            }"]}
{"id": "257", "ref_java": ["class Solution {\\n    public int minCostToMoveChips(int[] position) {\\n      int n = position.length;\\n      int odd = 0;\\n      int even = 0;\\n      for(int i = 0; i < n; i++)\\n      {\\n       if( position[i] % 2 == 0)\\n       {\\n         even++;\\n       }", "class Solution {\\n    public int minCostToMoveChips(int[] chips) {\\n        int odd = 0;\\n        for(int i:chips)\\n            if(i % 2 != 0)\\n                odd++;\\n        return Math.min(odd, chips.length-odd);\\n    }", "class Solution {\\n    public int minCostToMoveChips(int[] position) {\\n        int even = 0;\\n        int odd = 0;\\n\\n        for(int chips : position) {\\n            if(chips % 2 == 0) {\\n                even++;\\n            }"]}
{"id": "258", "ref_java": ["class Solution {\\n    public int balancedStringSplit(String s) {\\n        int   count = 0;\\n        int   R     = 0;\\n        int   L     = 0;\\n        for(int a = 0; a < s.length(); a++){\\n            if(s.charAt(a) == \\'R\\'){\\n                R ++;\\n            }", "class Solution {\\n    public int balancedStringSplit(String s) {\\n\\n    int Lcounter = 0;\\n    int Rcounter = 0;\\n    int count = 0;\\n\\n    for(int i = 0 ; i < s.length() ; i++){\\n        if(s.charAt(i) == \\'R\\'){\\n            Rcounter++;\\n        }", "class Solution {\\n    public int balancedStringSplit(String s) {\\n        int count = 0;\\n        int cha = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'R\\') {\\n                cha++;\\n            }"]}
{"id": "259", "ref_java": ["class Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        if(coordinates.length<=2) return true;\\r\\n        int x0= coordinates[0][0];\\r\\n        int y0= coordinates[0][1];\\r\\n        int x1=coordinates[1][0];\\r\\n        int y1= coordinates[1][1];\\r\\n        ", "class Solution {\\r\\n    ", "class Solution {\\r\\n    public boolean checkStraightLine(int[][] c) {\\r\\n       int m=1;\\r\\n        float k=0;\\r\\n        try {\\r\\n            m = (c[0][1] - c[1][1]) / (c[0][0] - c[1][0]);\\r\\n            if(Math.abs((c[0][0] - c[1][0]))>Math.abs(c[0][1] - c[1][1])){\\r\\n                k=(float)(c[0][1] - c[1][1]) / (c[0][0] - c[1][0]);\\r\\n            }"]}
{"id": "261", "ref_java": ["class Solution {\\n\\n\\n      ", "class Solution {\\n    public int oddCells(int n, int m, int[][] indices) {\\n        int count = 0;\\n        int row[] = new int [n];\\n        int col[] = new int [m];\\n        for(int x[] : indices)\\n        {\\n            row[x[0]]++;\\n            col[x[1]]++;\\n        }", "class Solution {\\n    public int oddCells(int m, int n, int[][] indices) {\\n        int arr[][] = new int[m][n];\\n        int rowIndex;\\n        int colIndex;\\n        for(int i = 0; i < indices.length; i++) {\\n            rowIndex = indices[i][0];\\n            colIndex = indices[i][1];\\n            for(int j = 0; j < n; j++) {\\n                arr[rowIndex][j] += 1;\\n            }"]}
{"id": "262", "ref_java": ["class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }", "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)", "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         "]}
{"id": "263", "ref_java": ["class Solution {\\n  public int minTimeToVisitAllPoints(int[][] points) {\\n    var time = 0;\\n\\n    for (var i=1; i < points.length; i++) {\\n      time +=\\n        Math.max(\\n          Math.abs(points[i][0] - points[i-1][0]),\\n          Math.abs(points[i][1] - points[i-1][1]));\\n    }", "class Solution {\\n    \\n    public int toTime(int[] from, int[] to) {\\n        int xDiff = Math.abs(from[0] - to[0]);\\n        int yDiff = Math.abs(from[1] - to[1]);\\n        \\n        return Math.max(xDiff, yDiff);\\n    }", "class Solution {\\n    public int minTimeToVisitAllPoints(int[][] points) {\\n        int ans = 0;\\n        int n = points.length;\\n\\n        for (int i = 1; i < n; ++i) {\\n            int diffx = Math.abs(points[i][0] - points[i - 1][0]);\\n            int diffy = Math.abs(points[i][1] - points[i - 1][1]);\\n            ans += Math.max(diffx, diffy);\\n        }"]}
{"id": "264", "ref_java": ["class Solution {\\n    public String winner(char[][] board)\\n    {\\n        ", "class Solution {\\n    public String tictactoe(int[][] moves) {\\n        var comb = new short[16];\\n        for (int i = 0; i < moves.length; i++) {\\n            int offset = (8 * (i % 2));\\n            var move = moves[i];\\n            if (++comb[move[0] + offset] == 3 \\n                    || ++comb[3 + move[1] + offset] == 3 \\n                    || (move[0] == move[1] && ++comb[6 + offset] == 3) \\n                    || (move[0] + move[1] == 2 && ++comb[7 + offset] == 3)) {\\n                return (i % 2) == 0 ? \"A\" : \"B\";\\n            }", "class Solution {\\n    public String tictactoe(int[][] moves) {\\n        int n = moves.length;\\n        char [][] board = new char [3][3];\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i%2 == 0){\\n                board[ moves[i][0] ][ moves[i][1] ] = \\'X\\';\\n                if(isWin(board,\\'X\\'))\\n                    return \"A\";\\n                else\\n                    if(i == 8)\\n                        return \"Draw\";\\n            }"]}
{"id": "266", "ref_java": ["class Solution {\\n    public int subtractProductAndSum(int n) {\\n        String num = Integer.toString(n);\\n        int [] dgt = new int[num.length()];\\n\\n        for(int i=0; i<num.length(); i++){\\n            dgt[i] = Character.getNumericValue(num.charAt(i));\\n        }", "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int mul = 1;\\n        int num = 0;\\n        while(n > 0)\\n        {\\n            num = n % 10;\\n            mul *= num;\\n            sum += num;\\n            n /= 10;\\n        }", "class Solution {\\n    public int subtractProductAndSum(int n) {\\n       ArrayList<Integer> list=new ArrayList<>();\\n       int n1=n;\\n       while(n!=0){\\n           int a=n%10;\\n           list.add(a);\\n           n=n/10;\\n       }"]}
{"id": "267", "ref_java": ["class Solution {\\n    public int findSpecialInteger(int[] arr) {\\n        int n = arr.length;\\n        int quarter = n / 4;\\n\\n        for (int i = 0; i < n - quarter; i++) {\\n            if (arr[i] == arr[i + quarter]) {\\n                return arr[i];\\n            }", "class Solution {\\n    public int findSpecialInteger(int[] arr) {\\n        int size = arr.length;\\n        int qtr = size / 4;\\n        int cnt = 1;\\n        int p = arr[0];\\n        for (int i = 1 ; i < arr.length ; i++) {\\n\\n            if ( p == arr[i]) cnt++;\\n            else cnt = 1;\\n            \\n            if (cnt > qtr) return arr[i];\\n            \\n            p = arr[i];\\n        }", "class Solution {\\n    public int findSpecialInteger(int[] arr) {\\n/*      \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : arr){\\n            map.put(i, map.getOrDefault(i,0)+1);\\n        }"]}
{"id": "268", "ref_java": ["class Solution {\\n    public int getDecimalValue(ListNode head) {\\n       int ans = 0;\\n        while(head != null){\\n            ans = ans * 2 + head.val;\\n            head = head.next;\\n        }", "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int size = -1;\\n        int sum = 0;\\n        for(ListNode temp = head; temp != null; temp = temp.next){\\n            size++;\\n        }", "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num = head.val;\\n        while (head.next != null) {\\n            num = num * 2 + head.next.val;\\n            head = head.next;    \\n        }"]}
{"id": "269", "ref_java": ["class Solution {\\n    public int findNumbers(int[] nums) {\\n        int count =0;\\n        for (int i = 0; i < nums.length; i++) {\\n          int  count1=0;\\n            while (nums[i]>0){\\n                count1++;\\n                nums[i]=nums[i]/10;\\n            }", "class Solution {\\n    public int findNumbers(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for(int i =0 ; i< nums.length; i++){\\n            \\n            if((nums[i]>9 && nums[i]<100) || (nums[i]>999 && nums[i]<10000) || nums[i]==100000){\\n                count++;\\n            }", "class Solution {\\n    public int findNumbers(int[] nums) {\\n        List<String> list = new ArrayList<>();\\n        for (int num : nums) {\\n            if (String.valueOf(num).length() % 2 == 0) {\\n                list.add(String.valueOf(num));\\n            }"]}
{"id": "270", "ref_java": ["class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] > max) {\\n                int temp = max;\\n                max = arr[i];\\n                arr[i] = temp;\\n            }", "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length == 1){\\n            return new int[]{-1}", "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        int length=arr.length;\\n        int[] nums= new int[length];\\n\\n        for(int i=length-1;i>=0;i--){\\n            nums[i]= max;\\n            max = Math.max(arr[i] , max);  \\n        }"]}
{"id": "271", "ref_java": ["class Solution {\\n    public int[] sumZero(int n) {\\n        int arr[] = new int[n];\\n        int sum=0;\\n        for(int i =0;i<n-1;i++){\\n            arr[i]=i+1;\\n            sum = sum +arr[i];\\n        }", "class Solution {\\n    public int[] sumZero(int n) {\\n        int[] result = new int[n];\\n        int a = -(n/2);\\n        for(int i=0;i<n-1;i++){\\n            result[i] = a++;\\n        }", "class Solution {\\n    public int[] sumZero(int n) {\\n        int[] mp = new int[1001];\\n        int add = 0;\\n        for (int i = -500; i < 501; i++)\\n            mp[add++] = i;\\n        int[] arr = new int[n];\\n        add = (mp.length / 2) - (n / 2);\\n        for (int i = 0; i < n; i++) {\\n            if (mp[add] == 0 && n % 2 == 0) {\\n                arr[i] = mp[++add];\\n                add++;\\n            }"]}
{"id": "272", "ref_java": ["class Solution {\\n    public String freqAlphabets(String s) \\n    {\\n        char[] chArr = s.toCharArray();        \\n        StringBuilder answer = new StringBuilder();\\n        \\n        for(int idx=0; idx<chArr.length; idx++)\\n        {\\n            if(idx+2 < chArr.length && chArr[idx+2]==\\'#\\')\\n            {\\n                answer.append(encodedChar(chArr[idx], chArr[idx+1]));\\n                idx+=2;\\n            }", "class Solution {\\n    public String freqAlphabets(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = s.length()-1; i >= 0; i--) {\\n            int number;\\n            if(s.charAt(i) == \\'#\\') { ", "class Solution {\\n    public String freqAlphabets(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = s.length()-1; i >= 0; i--) {\\n            int number;\\n            if(s.charAt(i) == \\'#\\') { "]}
{"id": "273", "ref_java": ["class Solution {\\n    public int[] decompressRLElist(int[] nums) {\\n        int arrSize = 0;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            arrSize += nums[i];\\n        }", "class Solution {\\n    public int[] decompressRLElist(int[] nums) {\\n\\n        int k = 0;\\n\\n        for(int i=0 ; i<nums.length; i+=2){\\n            k+=nums[i];\\n        }", "class Solution {\\n    public int[] decompressRLElist(int[] nums) {\\nint sum=0;\\n        for(int i=0;i<nums.length;i=i+2)\\n        {\\n           sum=sum+nums[i];\\n        }"]}
{"id": "274", "ref_java": ["class Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int[] res = new int[2];\\n        \\n        for (int i = 1; i < n; i++) {\\n            int c = n - i;\\n            if (check(c) && check(i)) {\\n                res[0] = i;\\n                res[1] = c;\\n                return res;\\n            }", "class Solution {\\n    ", "class Solution {\\n    public int[] getNoZeroIntegers(int n) {\\n        int arr[]=new int[2];\\n        boolean t=true;\\n        for(int i=1;i<=n;i++){\\n            int k=i;\\n            while(k!=0){\\n                int rem=k%10;\\n                if(rem==0){\\n                   t=false;\\n                }"]}
{"id": "275", "ref_java": ["class Solution {\\n    public int maximum69Number (int num) {\\n        String s=Integer.toString(num); ", "class Solution {\\n    public int maximum69Number (int num) {\\n     StringBuilder s= new StringBuilder(\"\"+num);\\n\\n     for(int i=0;i<s.length();i++){\\n         if(s.charAt(i)==\\'6\\') {\\n             s.setCharAt(i,\\'9\\');\\n             break;\\n         }", "class Solution {\\n    public int maximum69Number (int num) {\\n        char[] arr = String.valueOf(num).toCharArray();\\n        int id = 0;\\n        while(id < arr.length){\\n            if(arr[id] == \\'6\\'){\\n                arr[id] = \\'9\\';\\n                return Integer.parseInt(String.valueOf(arr));\\n            }"]}
{"id": "277", "ref_java": ["class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] rankedArray = arr.clone();\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        Arrays.sort(arr);\\n        int rank = 1;\\n        if(arr.length==0) return arr;\\n        int prev = arr[0];\\n        \\n        for (int num : arr) {\\n            if (prev != num) {\\n                rank++;\\n            }", "class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n = arr.length;\\n        int[] temp = new int[n];\\n        for (int i = 0; i < n; i++) \\n            temp[i] = arr[i];\\n\\n        Arrays.sort(temp);\\n\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int rank = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (hm.containsKey(temp[i]))\\n                hm.put(temp[i], hm.get(temp[i]));\\n            else\\n                hm.put(temp[i], rank++);\\n        }", "class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer, Integer> hmap = new HashMap<>();\\n        int ans[] = new int[arr.length];\\n        ans = arr.clone();\\n        Arrays.sort(arr);\\n        int res[] = Arrays.stream(arr)\\n                                    .distinct()\\n                                    .toArray();\\n        for(int i=1;i<=res.length;i++)\\n            hmap.put(res[i-1], i);\\n        \\n        for(int i=0;i<ans.length;i++)\\n            ans[i] = hmap.get(ans[i]);\\n        \\n        return ans;\\n    }"]}
{"id": "278", "ref_java": ["class Solution {\\n    public int removePalindromeSub(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while(i < j)\\n            if(s.charAt(i++) != s.charAt(j--))\\n                return 2;\\n\\n        return 1;\\n    }", "class Solution {\\n    public int removePalindromeSub(String s) {\\n\\tif (s.equals(new StringBuilder(s).reverse().toString())) return 1;\\n\\treturn 2;\\n    }", "class Solution {\\n    public int removePalindromeSub(String s) {\\n\\tif (s.equals(new StringBuilder(s).reverse().toString())) return 1;\\n\\treturn 2;\\n    }"]}
{"id": "279", "ref_java": ["class Solution {\\n    public int[] kWeakestRows(int[][] mat, int k) {\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> {\\n            int strengthA = a[0];\\n            int strengthB = b[0];\\n            if (strengthA != strengthB) {\\n                return Integer.compare(strengthA, strengthB);\\n            }", "class Solution {\\n    public int[] kWeakestRows(int[][] mat, int k) {\\n        int[][] rowStrengths = new int[mat.length][2];\\n        \\n        for (int i = 0; i < mat.length; ++i) {\\n            int strength = 0;\\n            for (int val : mat[i]) {\\n                strength += val;\\n            }", "class Solution {\\n    public int[] kWeakestRows(int[][] mat, int k) {\\n        int[] arr = new int[mat.length];\\n        int[] res = new int[k];\\n        for (int i = 0; i < mat.length; i++) {\\n            int[] nums = mat[i];\\n            int count = 0;\\n            int j = 0;\\n            while (j < nums.length && nums[j] == 1) {\\n                count++;\\n                j++;\\n            }"]}
{"id": "280", "ref_java": ["class Solution {\\n    public int numberOfSteps(int n){\\n        int count = 0;\\n        String string = Integer.toBinaryString(n);\\n        for(int i = 0; i < string.length(); i++){\\n            count = (string.charAt(i) == \\'1\\') ? count + 1: count;\\n        }", "class Solution {\\n    public int numberOfSteps(int num) {\\n        int x = 0;\\n        while(num != 0){\\n            if(num % 2 == 0){\\n                num /= 2;\\n                x++;\\n            }", "class Solution {\\n    public int numberOfSteps(int num) {\\n        int s=0;\\n        while(num>0){\\n            if(num%2==0){\\n                num/=2;\\n                s++;\\n            }"]}
{"id": "281", "ref_java": ["class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        boolean b=false;\\n        int le=arr.length;\\n        for(int i=0;i<le;i++){\\n            for(int j=0;j<le;j++){\\n                if(i!=j){\\n                    if(arr[i]==2*arr[j]){\\n                        return true;\\n                    }", "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n\\t    int n = arr.length;\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < n; j++) \\n                if (i != j && arr[i] == 2 * arr[j]) \\n                    return true;\\n\\n        return false;\\n    }", "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for (int i=0;i<arr.length;i++){\\n            for(int j =0;j<arr.length;j++){\\n                if(arr[i]==arr[j]*2 &&i!=j){\\n                    return true;\\n                }"]}
{"id": "282", "ref_java": ["class Solution {\\n\\n    public int lastPositive(int[] ar){\\n        int n = ar.length;\\n        int i = 0, j = n-1;\\n        while(i<=j){\\n            int mid = i + (j-i)/2;\\n            if(ar[mid] < 0 )\\n                j = mid - 1;\\n            else\\n                i = mid + 1;\\n        }", "class Solution {\\n    public int countNegatives(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length ; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0){\\n                    count += grid[i].length - j;\\n                    break;\\n                }", "class Solution {\\n\\n    public int lastPositive(int[] ar){\\n        int n = ar.length;\\n        int i = 0, j = n-1;\\n        while(i<=j){\\n            int mid = i + (j-i)/2;\\n            if(ar[mid] < 0 )\\n                j = mid - 1;\\n            else\\n                i = mid + 1;\\n        }"]}
{"id": "283", "ref_java": ["class Solution {\\n    public int[] sortByBits(int[] arr) {\\n        Integer[] boxedArray = Arrays.stream(arr).boxed().toArray(Integer[]::new);\\n        Arrays.sort(boxedArray, (a, b) -> {\\n            int countA = Integer.bitCount(a);\\n            int countB = Integer.bitCount(b);\\n            return countA == countB ? a - b : countA - countB;\\n        }", "class Solution {\\n    static class pair{\\n        int ele;int bit_count;\\n        pair(int e,int b){\\n            this.ele=e;\\n            this.bit_count=b;\\n        }", "class Solution {\\n    public int[] sortByBits(int[] arr) {\\n        Integer[] boxedArray = Arrays.stream(arr).boxed().toArray(Integer[]::new);\\n        Arrays.sort(boxedArray, (a, b) -> {\\n            int countA = Integer.bitCount(a);\\n            int countB = Integer.bitCount(b);\\n            return countA == countB ? a - b : countA - countB;\\n        }"]}
{"id": "284", "ref_java": ["class Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        String[] array1 = date1.split(\"-\");\\n        String[] array2 = date2.split(\"-\");\\n        int year1 = Integer.parseInt(array1[0]), month1 = Integer.parseInt(array1[1]), day1 = Integer.parseInt(array1[2]);\\n        int year2 = Integer.parseInt(array2[0]), month2 = Integer.parseInt(array2[1]), day2 = Integer.parseInt(array2[2]);\\n        if (year1 > year2 || year1 == year2 && month1 > month2 || year1 == year2 && month1 == month2 && day1 > day2) {\\n            int temp = year1;\\n            year1 = year2;\\n            year2 = temp;\\n            temp = month1;\\n            month1 = month2;\\n            month2 = temp;\\n            temp = day1;\\n            day1 = day2;\\n            day2 = temp;\\n        }", "class Solution {\\n    int[] daysPerMonth = new int[] {31,28,31,30,31,30,31,31,30,31,30,31}", "class Solution {\\n    public int daysBetweenDates(String date1, String date2) {\\n        "]}
{"id": "285", "ref_java": ["class Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        ", "class Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] out = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int k=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<nums[i]){\\n                    k++;\\n                }", "class Solution {\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] output = new int[nums.length];\\n    int[] count = new int[101]; "]}
{"id": "286", "ref_java": ["class Solution {\\n    public String sortString(String s) {\\n        int[] freq = new int[26];\\n        int len = s.length();\\n\\n        for(char c : s.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }", "class Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[26];\\n\\n        for(int i=0; i<s.length(); i++){\\n            int index = s.charAt(i)-\\'a\\';\\n            arr[index] = arr[index]+1;\\n        }", "class Solution {\\n    public String sortString(String s) {\\n        int[] alpha = new int[27];\\n        for(char ch : s.toCharArray())\\n        {\\n            alpha[ch-\\'a\\']++;\\n        }"]}
{"id": "287", "ref_java": ["class Solution {\\n    public String generateTheString(int n) {\\n        \\nStringBuilder s = new StringBuilder();\\n\\n    if(n%2==0){\\n        s.append(\"t\".repeat(n-1));\\n        s.append(\"e\");\\n}", "class Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder res=new StringBuilder();\\n        if(n%2==1) {\\n            res.append(\"a\".repeat(n));\\n        }", "class Solution {\\n    public String generateTheString(int n) {\\n        String s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++){\\n                s=s+\\'a\\';\\n            }"]}
{"id": "290", "ref_java": ["class Solution {\\n    public List<Integer> luckyNumbers (int[][] matrix) {\\n         List<Integer> list = new ArrayList();\\n         int m = matrix.length;\\n         int n = matrix[0].length;\\n         int[] rowMin = new int[m];\\n         int[] index = new int[m];\\n         int[] colMax = new int[n];\\n         ", "class Solution {\\n    public List<Integer> luckyNumbers (int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        /**\\n         * Brute Force Approach | TC = O((m*n)*(m+n)) \\n         \\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                int temp_j = 0;\\n                Boolean isRowMin = true;\\n                while(temp_j < col){\\n                    if(matrix[i][temp_j] < matrix[i][j]) isRowMin = false;\\n                    temp_j++;\\n                }", "class Solution {\\n    public List<Integer> luckyNumbers (int[][] matrix) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        "]}
{"id": "291", "ref_java": ["class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans=0;\\n        for (int i =0;i<arr1.length;i++){\\n            for (int j =0;j<arr2.length;j++){\\n                if (Math.abs(arr1[i]-arr2[j])<=d){\\n                   ans++;\\n                   break;\\n                }", "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans=0;\\n        for (int i =0;i<arr1.length;i++){\\n            for (int j =0;j<arr2.length;j++){\\n                if (Math.abs(arr1[i]-arr2[j])<=d){\\n                   ans++;\\n                   break;\\n                }", "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=arr1.length;\\n                for (int i=0; i<arr1.length; i++) {\\n            for (int j=0; j<arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    count -= 1;\\n                    break;\\n                }"]}
{"id": "292", "ref_java": ["class Solution {\\n    public int[] createTargetArray(int[] nums, int[] index) {\\n        int [] target = new int[nums.length];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for(int i = 0 ;i<nums.length;i++){\\n        ans.add(index[i],nums[i]);            \\n        }", "class Solution {\\n    public int[] createTargetArray(int[] nums, int[] index) {\\n        ArrayList<Integer>arr=new ArrayList<Integer>();\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n        \\n            arr.add(index[i],nums[i]);\\n        }", "class Solution {\\n    public int[] createTargetArray(int[] nums, int[] index) {\\n        int t[]= new int [nums.length];\\n        ArrayList<Integer> rb= new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n        {\\n           rb.add(index[i], nums[i]);\\n        }"]}
{"id": "293", "ref_java": ["class Solution {\\n    public int findLucky(int[] arr) {\\n        Arrays.sort(arr);\\n        int maxLucky = -1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == -1) {\\n                continue;\\n            }", "class Solution {\\n    public int findLucky(int[] arr) {\\n        int[] count = new int[501];\\n        for (int n : arr) {\\n            count[n]++;\\n        }", "class Solution {\\n    public int findLucky(int[] arr) {\\n        int rnNum = -1;\\n        for(int i = 0; i < arr.length; i++){\\n            int num = arr[i];\\n            int count = 0;\\n            for(int j = 0; j < arr.length; j++){\\n                int numIn = arr[j];\\n                if(num == numIn){\\n                    count++;\\n                }"]}
{"id": "294", "ref_java": ["class Solution {\\n    public int countLargestGroup(int n) {\\n        int m=(int)Math.log10(n);\\n        int sum,k;\\n        int [] sumDigits = new int[m*9+(int)(n/(Math.pow(10,m)))+1];\\n        for(int i=1;i<=n;i++){\\n            k=i;\\n            sum=0;\\n            while(k>0){\\n                sum+=k%10;\\n                k/=10;\\n            }", "class Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }", "class Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }"]}
{"id": "295", "ref_java": ["class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       int n = nums.length;\\n       Arrays.sort(nums);\\n       int sum=0,s=0;\\n       List<Integer> list = new ArrayList<>();\\n       for(int i=0;i<n;i++){\\n           sum+=nums[i];\\n       }", "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int total = 0;\\n        for(int i=0;i<nums.length;i++){\\n            total += nums[i];\\n        }", "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int total = 0;\\n        for(int i=0;i<nums.length;i++){\\n            total += nums[i];\\n        }"]}
{"id": "297", "ref_java": ["class Solution {\\n\\n    public List<String> stringMatching(String[] words) {\\n        Set<String> result = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = i + 1; j < words.length; j++) {\\n                if (words[i].contains(words[j])) {\\n                    result.add(words[j]);\\n                }", "class Solution {\\n    public List<String> stringMatching(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words.length;j++){\\n                if((!words[j].equals(words[i]) && words[i].contains(words[j]))){\\n                    if(!list.contains(words[j])){\\n                        list.add(words[j]);\\n                    }", "class Solution {\\n    public List<String> stringMatching(String[] words) {\\n        String str = String.join(\" \", words);\\n        List<String> res = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++){\\n            if(str.indexOf(words[i]) != str.lastIndexOf(words[i])){\\n                res.add(words[i]);\\n            }"]}
{"id": "298", "ref_java": ["class Solution {\\n    public int minStartValue(int[] nums) {\\n        ", "class Solution {\\n    public int minStartValue(int[] nums) {\\n        int min = 0;\\n        int sum = 0;\\n        for(int a: nums){\\n            sum += a;\\n            if(sum < min) min = sum;\\n        }", "class Solution {\\n    public int minStartValue(int[] nums) {\\n    \\n        int max=1;\\n        \\n        int flag=0;\\n        for(int i=0;i<100000;i++){\\n            int sum=max;\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                sum=sum+nums[j];\\n                count++;\\n                if(sum<=0){\\n                    max++;\\n                    break;\\n                }"]}
{"id": "299", "ref_java": ["class Solution {\\n    public String reformat(String s) {\\n        if (s.length() == 1)\\n            return s;\\n\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> letters = new Stack();\\n        Stack<Character> digits = new Stack();\\n\\n        for (char ch : s.toCharArray()) {\\n            if (Character.isLetter(ch)) {\\n                letters.push(ch);\\n            }", "class Solution {\\n    public String reformat(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        List<Character> dig = new ArrayList<>();\\n        List<Character> let = new ArrayList<>();\\n        String[] st = new String[s.length()];\\n        int digits = 0;\\n        int letter = 0;\\n        for(char c : s.toCharArray()){\\n            if(Character.isDigit(c)){\\n                dig.add(c);\\n                digits++;\\n            }", "class Solution {\\n    public String reformat(String s) {\\n        int n = s.length(), nd = 0, nl = 0;\\n        char[] digits = new char[n];\\n        char[] lowers = new char[n];\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                digits[nd++] = c;\\n            }"]}
{"id": "300", "ref_java": ["class Solution {\\n    public int maxScore(String s) {\\n        int length = s.length();\\n        int ones = 0;\\n        int tmpScore = s.charAt(0) == \\'0\\' ? 1 : 0;\\n        int score = tmpScore;\\n        for (int i = 1; i < length - 1; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                tmpScore += 1;\\n            }", "class Solution {\\n    public int maxScore(String s) {\\n        int maxScore = 0;\\n        int countZerosLeft = 0;\\n        int countOnesRight = (int) s.chars().filter(ch -> ch == \\'1\\').count();\\n\\n\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            countZerosLeft += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            countOnesRight -= s.charAt(i) == \\'1\\' ? 1 : 0;\\n            maxScore = Math.max(maxScore, countZerosLeft + countOnesRight);\\n        }", "class Solution {\\n    public int maxScore(String s) {\\n        int left = -1;\\n        int zeros = 0;\\n        int ones = 0;\\n\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                zeros++;\\n            }"]}
{"id": "301", "ref_java": ["class Solution {\\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\\n        ArrayList<Boolean> result = new ArrayList<Boolean>(candies.length);\\n\\n        int max = candies[0];\\n\\n        for(int i=1; i < candies.length; i++) {\\n            if(candies[i] > max) {\\n                max = candies[i];\\n            }", "class Solution {\\n    private static Boolean[] toBooleanArray(boolean[] arr) {\\n        Boolean[] result = new Boolean[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            result[i] = arr[i];\\n        }", "class Solution {\\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\\n        "]}
{"id": "302", "ref_java": ["class Solution {\\n    public String destCity(List<List<String>> paths) {\\n        Set<String> cities = new HashSet<>(); \\n        for (List<String> path : paths) {\\n            cities.add(path.get(0)); \\n        }", "class Solution {\\n    public string DestCity(IList<IList<string>> paths)\\n    {\\n        Dictionary<string, string> check = new Dictionary<string, string>();\\n\\n        foreach(var path in paths)\\n        {\\n            check[path[0]] = \"out\";\\n            if (!check.ContainsKey(path[1]))\\n            {\\n                check[path[1]] = \"in\";\\n            }", "class Solution {\\n    public String destCity(List<List<String>> paths) {\\n        "]}
{"id": "303", "ref_java": ["class Solution {\\n    public boolean kLengthApart(int[] nums, int k) {\\n        int count = 0;\\n        if(nums[0]==0){\\n            count = k;\\n        }", "class Solution {\\n    public boolean kLengthApart(int[] nums, int k) {\\n        int lastOne=Integer.MAX_VALUE;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==1){\\n                if(lastOne-i-1<k){\\n                    return false;\\n                }", "class Solution {\\n    public boolean kLengthApart(int[] nums, int k) {\\n        int count = nums[0] == 0 ? k : 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                if (count < k) return false;\\n                count = 0;\\n            }"]}
{"id": "304", "ref_java": ["class Solution {\\n    public int maxPower(String s) {\\n        int res=1,c=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==s.charAt(i+1))c++;\\n            else {\\n                res=Math.max(res,c);\\n                c=1;\\n            }", "class Solution {\\n    public int maxPower(String s) {\\n        int res=1,c=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==s.charAt(i+1))c++;\\n            else {\\n                res=Math.max(res,c);\\n                c=1;\\n            }", "class Solution {\\n    public int maxPower(String s) {\\n        int count, max;\\n        count= max=1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)) count++;\\n            else count=1;\\n            max=Math.max(max,count);\\n        }"]}
{"id": "305", "ref_java": ["class Solution {\\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\\n        int answer = 0;\\n        for(int i=0,j=0;i<startTime.length && j<endTime.length;i++,j++)\\n            if(startTime[i]<=queryTime && endTime[j]>=queryTime)\\n                answer++;\\n        return answer;\\n    }", "class Solution {\\n    public int busyStudent(int[] st, int[] end, int qt) {\\n        \\n        int n = st.length;\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(qt>=st[i] && qt<=end[i]) ans++;\\n        }", "class Solution {\\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\\n        int count = 0;\\n        for(int i = 0; i < startTime.length; i++) {\\n            if(queryTime >= startTime[i] && queryTime <= endTime[i]) {\\n                count++;\\n            }"]}
{"id": "306", "ref_java": ["class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] s= sentence.split(\" \");\\n        System.out.println(Arrays.toString(s));\\n        int i=0;\\n        for(String word: s){\\n            i++;\\n            if(word.startsWith(searchWord)) return i;\\n        }", "class Solution {\\n    public int isPrefixOfWord(String sentence, String searchWord)\\n{\\n            String[] sent=null;\\n         \\n        sent=sentence.split(\" \");\\n        for(int i=0;i<sent.length;i++)\\n        {\\n            int len=searchWord.length();\\n            if(sent[i].contains(searchWord) && sent[i].substring(0,len).equals(searchWord)) return i+1;\\n        }", "class Solution {\\n    public static int isPrefixOfWord(String sentence, String searchWord) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 1; i <= words.length; ++i) {\\n            if (words[i - 1].startsWith(searchWord)) {\\n                return i;\\n            }"]}
{"id": "307", "ref_java": ["class Solution {\\n    public boolean canBeEqual(int[] target, int[] arr) {\\n        int[] arr1 = new int[1001];\\n        for(int i = 0;i<arr.length;i++){\\n            arr1[arr[i]]++;\\n            arr1[target[i]]--;\\n        }", "class Solution {\\n    public boolean canBeEqual(int[] target, int[] arr) {\\n        Arrays.sort(target);\\n        Arrays.sort(arr);\\n        for(int i = 0; i < target.length; i++)\\n            if (target[i] != arr[i])\\n                return false;\\n        return true;\\n    }", "class Solution {\\n    public boolean canBeEqual(int[] target, int[] arr) {\\n        Arrays.sort(arr);\\n        Arrays.sort(target);\\n        int count = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(target[i] == arr[i]){\\n                count++;\\n            }"]}
{"id": "308", "ref_java": ["class Solution {\\n    public int maxProduct(int[] nums) {\\n        int res = 0;\\n        int curMax = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            res = Math.max(res, (curMax - 1) * (nums[i] - 1));\\n            curMax = Math.max(curMax, nums[i]);\\n        }", "class Solution {\\n    public int maxProduct(int[] nums) {\\n        int max1 = Integer.MIN_VALUE;\\n        int max2 = Integer.MIN_VALUE;\\n\\n        for (int num : nums) {\\n            if (num >= max1) {\\n                max2 = max1;\\n                max1 = num;\\n            }", "class Solution {\\n    public int MaxProduct(int[] nums) {\\n        int max1 = 0, max2 = 0;\\n\\n        foreach (var num in nums) {\\n            if (num > max1) {\\n                max2 = max1;\\n                max1 = num;\\n            }"]}
{"id": "309", "ref_java": ["class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        for(int i = 0; i < n; i++) concat(nums, i, n + i);\\n        for(int i = n-1; i >= 0; i--) {\\n            int[] xy = getXandY(nums, i);\\n            nums[i * 2] = xy[0];\\n            nums[i * 2 + 1] = xy[1];\\n        }", "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int res[]= new int [2*n];\\n        int j=0;\\n        int i=n;\\n        for(int k=0; i<2*n; k++){\\n            res[k]=nums[j];\\n            k++;\\n            res[k]=nums[i];\\n            j++;\\n            i++;\\n        }", "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int res[]= new int [2*n];\\n        int j=0;\\n        int i=n;\\n        for(int k=0; i<2*n; k++){\\n            res[k]=nums[j];\\n            k++;\\n            res[k]=nums[i];\\n            j++;\\n            i++;\\n        }"]}
{"id": "310", "ref_java": ["class Solution {\\n    public int[] finalPrices(int[] prices) {\\n        int arr[] = new int[prices.length];\\n        int i;\\n        int j;\\n        for(i = 0; i < prices.length; i++) {\\n            for(j = i + 1; j < prices.length; j++) {\\n                if(prices[j] <= prices[i]) {\\n                    arr[i] = prices[i] - prices[j];\\n                    break;\\n                }", "class Solution {\\n    public int[] finalPrices(int[] prices) {\\n        int[] arr = new int[prices.length];\\n        \\n        for(int i=0; i<prices.length; i++){\\n            if(arr.length - 1 == i){\\n                arr[i] = prices[i];\\n                break;\\n            }", "class Solution {\\n    public int[] finalPrices(int[] prices) {\\n        int arr[] = new int[prices.length];\\n        int i;\\n        int j;\\n        for(i = 0; i < prices.length; i++) {\\n            for(j = i + 1; j < prices.length; j++) {\\n                if(prices[j] <= prices[i]) {\\n                    arr[i] = prices[i] - prices[j];\\n                    break;\\n                }"]}
{"id": "311", "ref_java": ["class Solution {\\n    public int[] runningSum(int[] nums) {\\n\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n\\n        }", "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        if(nums.length<=1){\\n            return nums;\\n        }", "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        "]}
{"id": "313", "ref_java": ["class Solution {\\n    public int xorOperation(int n, int start) {\\n        ", "class Solution {\\n    public int xorOperation(int n, int start) {\\n        int []nums=new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=start+2*i;\\n        }", "class Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans=0;\\n        int[] arr = new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]= start + (2*i);\\n            ans^=arr[i];\\n        }"]}
{"id": "314", "ref_java": ["class Solution {\\n    public double average(int[] salary) {\\n       Arrays.sort(salary);\\n       double sum=0;\\n       for(int i=1;i<salary.length-1;i++)\\n       sum+=salary[i];\\n       return sum/(double)(salary.length-2); \\n    }", "class Solution {\\n    public double average(int[] salary) {\\n        double average;\\n        int n = salary.length;\\n        double total = 0;\\n        Arrays.sort(salary);\\n        for(int i=1;i<n-1;i++)\\n        {\\n            total = total+salary[i];\\n        }", "class Solution {\\n    public double average(int[] salary) {\\n        \\n        double sum=0;\\n        int n=salary.length-2;\\n       Arrays.sort(salary);\\n        for(int i=1;i<salary.length-1;i++)\\n        {\\n            sum+=salary[i];\\n            \\n        }"]}
{"id": "315", "ref_java": ["class Solution {\\n    public boolean isPathCrossing(String path) {\\n        Map<Character, Pair<Integer, Integer>> moves = new HashMap();\\n        moves.put(\\'N\\', new Pair(0, 1));\\n        moves.put(\\'S\\', new Pair(0, -1));\\n        moves.put(\\'W\\', new Pair(-1, 0));\\n        moves.put(\\'E\\', new Pair(1, 0));\\n        \\n        Set<Pair<Integer, Integer>> visited = new HashSet();\\n        visited.add(new Pair(0, 0));\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        for (Character c : path.toCharArray()) {\\n            Pair<Integer, Integer> curr = moves.get(c);\\n            int dx = curr.getKey();\\n            int dy = curr.getValue();\\n            x += dx;\\n            y += dy;\\n            \\n            Pair<Integer, Integer> pair = new Pair(x, y);\\n            if (visited.contains(pair)) {\\n                return true;\\n            }", "class Solution {\\n    public boolean isPathCrossing(String path) {\\n        int x = 0, y = 0;\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0,0\");\\n\\n        for (char direction : path.toCharArray()) {\\n            if (direction == \\'E\\') {\\n                x++;\\n            }", "class Solution {\\n    public boolean isPathCrossing(String path) {\\n        Set<String> points = new HashSet<>();\\n        points.add(\"0,0\");\\n        int x = 0, y = 0;\\n\\n        for (char d : path.toCharArray()) {\\n            if (d == \\'N\\') y++;\\n            else if (d == \\'S\\') y--;\\n            else if (d == \\'E\\') x++;\\n            else if (d == \\'W\\') x--;\\n\\n            if (points.contains(x + \",\" + y)) return true;\\n            points.add(x + \",\" + y);\\n        }"]}
{"id": "316", "ref_java": ["class Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int d=arr[1]-arr[0];\\n        for (int i =1;i<arr.length;i++)\\n        {\\n            if(arr[i]-arr[i-1]!=d)\\n            {\\n            return false;\\n            }", "class Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr); ", "class Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff=arr[1]-arr[0];\\n        boolean temp=true;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i+1]-arr[i]==diff){\\n                continue;\\n            }"]}
{"id": "317", "ref_java": ["class Solution {\\n    public String reformatDate(String date) {\\n        String[] d = date.split(\" \"); ", "class Solution {\\n    public String reformatDate(String date) {\\n        String[] str = date.split(\" \");\\n        StringBuilder res = new StringBuilder();\\n        res.append(str[2]);\\n        String month = str[1].equals(\"Jan\") ? \"01\" \\n        : str[1].equals(\"Feb\") ? \"02\" \\n        : str[1].equals( \"Mar\" )? \"03\"\\n        : str[1].equals(\"Apr\") ? \"04\"\\n        : str[1].equals(\"May\") ? \"05\"\\n        : str[1].equals(\"Jun\") ? \"06\"\\n        : str[1].equals(\"Jul\") ? \"07\"\\n        : str[1].equals(\"Aug\") ? \"08\"\\n        : str[1].equals(\"Sep\") ? \"09\"\\n        : str[1].equals(\"Oct\") ? \"10\"\\n        : str[1].equals(\"Nov\") ? \"11\"\\n        : \"12\";\\n        res.append(\"-\");\\n        res.append(month);\\n        res.append(\"-\");\\n        if(str[0].length() == 3){\\n            res.append(\"0\");\\n            res.append(str[0].charAt(0));\\n        }", "class Solution {\\n    public String reformatDate(String date) {\\n         StringBuilder sb = new StringBuilder();\\n         sb.append(date.substring(date.length() - 4)).append(\"-\");\\n         String m = date.length() == 13 ? date.substring(5, 8) : date.substring(4, 7);\\n\\n         switch(m){\\n             case \"Jan\": sb.append(\"01-\"); break;\\n             case \"Feb\": sb.append(\"02-\"); break;\\n             case \"Mar\": sb.append(\"03-\"); break;\\n             case \"Apr\": sb.append(\"04-\"); break;\\n             case \"May\": sb.append(\"05-\"); break;\\n             case \"Jun\": sb.append(\"06-\"); break;\\n             case \"Jul\": sb.append(\"07-\"); break;\\n             case \"Aug\": sb.append(\"08-\"); break;\\n             case \"Sep\": sb.append(\"09-\"); break;\\n             case \"Oct\": sb.append(\"10-\"); break;\\n             case \"Nov\": sb.append(\"11-\"); break;\\n             case \"Dec\": sb.append(\"12-\"); break;\\n         }"]}
{"id": "318", "ref_java": ["class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        Map<Integer, Integer> numFreqMp = new HashMap<>();\\n        int answer = 0;\\n        for(var num : nums){\\n            answer += numFreqMp.getOrDefault(num, 0);\\n            numFreqMp.put(num, numFreqMp.getOrDefault(num, 0) + 1);\\n        }", "class Solution {\\n        public int numIdenticalPairs(int[] A) {\\n        int ans = 0, cnt[] = new int[101];\\n        for (int a: A) {\\n            ans += cnt[a]++;\\n        }", "class Solution {\\n    public int numIdenticalPairs(int[] nums) {\\n        int max=nums[0];\\n        for(int i:nums)\\n        {\\n            max=Math.max(max,i);\\n        }"]}
{"id": "320", "ref_java": ["class Solution {\\n    public int numWaterBottles(int numBottles, int numExchange) {\\n        int count = numBottles;\\n        int temp = 0;\\n\\n        while(numExchange <= numBottles){\\n            temp = numBottles % numExchange;\\n            numBottles = numBottles - temp;\\n            count += numBottles / numExchange;\\n            numBottles = (numBottles / numExchange) + temp;\\n        }", "class Solution {\\n    public int numWaterBottles(int bottles, int exchange) {\\n        int ans = bottles;\\n        int empty = ans;\\n        int rem=0;\\n        while(empty/exchange>=1){\\n            bottles = empty/exchange;\\n            rem = empty%exchange;\\n            ans = ans + bottles;\\n            empty = rem + bottles;\\n        }", "class Solution {\\n    public int numWaterBottles(int numBottles, int numExchange) {\\n        int count=numBottles;\\n        int temp=0;\\n        while(numExchange<=numBottles){\\n            int q=numBottles/numExchange;\\n            int r=numBottles%numExchange;\\n            count=count+q;\\n            numBottles=q+r;\\n            \\n\\n        }"]}
{"id": "321", "ref_java": ["class Solution {\\n    public int countOdds(int low, int high) {\\n        if(low%2==0 && high%2==0)\\n            return (high-low)/2;\\n        else if(low%2==1 && high%2==1)\\n            return (high-low)/2+1;\\n        else\\n            return (high-low+1)/2;\\n    }", "class Solution {\\n    public int countOdds(int low, int high) {\\n        if(low%2==0 && high%2==0)\\n        {\\n            return (high-low)/2;\\n        }", "class Solution {\\n    public int countOdds(int low, int high) {\\n        return low%2!=0||high%2!=0?((high-low)/2)+1:(high-low)/2;\\n    }"]}
{"id": "323", "ref_java": ["class Solution {\\n    public String restoreString(String s, int[] indices) {\\n        char[] result = new char[indices.length];\\n        for (int i = 0; i < indices.length; i++) result[indices[i]] = s.charAt(i);\\n        return new String(result);\\n    }", "class Solution {\\n    public String restoreString(String s, int[] arr) {\\n        char ans [] = new char[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            ans[arr[i]] = s.charAt(i);\\n        }", "class Solution {\\n    public String restoreString(String s, int[] indices) {\\n        char a[]=new char[indices.length];        \\n        String o=\"\";\\n        for(int i=0;i<indices.length;i++)\\n        {\\n            a[indices[i]]=s.charAt(i);            \\n        }"]}
{"id": "324", "ref_java": ["class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        int ans = 0;\\n        for(int i=0; i<arr.length-2; i++){\\n            for(int j=i+1; j<arr.length-1; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    if(Math.abs(arr[i]-arr[j])<= a && Math.abs(arr[j]-arr[k])<= b && Math.abs(arr[i]-arr[k])<= c){\\n                        ans += 1;\\n                    }", "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c){\\n      int i,j,k,count=0;\\n      for(i=0;i<(arr.length)-2;i++){\\n        for(j=i+1;j<(arr.length)-1;j++){\\n          if(Math.abs(arr[i]-arr[j]) <=a){\\n            for(k=j+1;k<arr.length;k++){\\n             if(Math.abs(arr[j]-arr[k]) <=b && Math.abs(arr[i]-arr[k]) <=c)\\n                  count++;\\n            }", "class Solution {\\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                for(int k = j + 1; k <arr.length; k++){\\n                    if(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b &&   Math.abs(arr[i] - arr[k]) <= c) count++;\\n                }"]}
{"id": "325", "ref_java": ["class Solution {\\n    public int findKthPositive(int[] arr, int k) {\\n        int missingNum = 1;\\n        int numOrder = 1;\\n        int size = Math.max(arr.length, (arr.length + k));\\n        for(int i = 0; i < size; i ++) {\\n            if(i > arr.length - 1) {\\n                if(k == missingNum) {\\n                    return numOrder;\\n                }", "class Solution {\\n    public int findKthPositive(int[] arr, int k) {\\n        int i=1;\\n        int j=0;\\n        while(k>0){\\n            if(j<arr.length){\\n                if(arr[j]>i){\\n                    k--;\\n                    i++;\\n                }", "class Solution {\\n    public int findKthPositive(int[] arr, int k) {\\n        int n=arr.length;\\n        int prev=0,i=0;\\n        while(i<n){\\n            if(arr[i]==prev+1){\\n            i++;\\n            }"]}
{"id": "326", "ref_java": ["class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack=new Stack<>();\\n       \\n        for(int i=0;i<s.length();i++)\\n        {\\n            \\n            if(stack.size()>0&&stack.peek()!=s.charAt(i)){\\n               String t1=\"\"+stack.peek();\\n               String t2=\"\"+s.charAt(i);\\n                if(t1.toLowerCase().equals(t2.toLowerCase()))stack.pop();\\n                else stack.push(s.charAt(i));\\n            }", "class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stk = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(stk.size()>0 && (stk.peek()==ch-32 || stk.peek()==ch+32)){\\n                stk.pop();\\n            }", "class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char top = \\'0\\';\\n            if (!stack.isEmpty()) top = stack.peek();\\n            char curr = s.charAt(i);\\n\\n            if (toLower(top) == toLower(curr) &&\\n                ((isUpper(top) && isLower(curr)) ||\\n                (isLower(top) && isUpper(curr)))) {\\n                stack.pop();\\n                continue;\\n            }"]}
{"id": "327", "ref_java": ["class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count = 0;\\n        for(int i:arr){\\n            if(i%2==1) count++;\\n            else count = 0;\\n            if(count == 3) return true;\\n        }", "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]%2!=0){\\n                count++;\\n            }", "class Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(count==0&& arr[i]%2!=0){\\n                count++;\\n            }"]}
{"id": "328", "ref_java": ["class Solution {\\n    public String thousandSeparator(int n) {\\n        if(n == 0){\\n            return \"0\";\\n        }", "class Solution {\\n    public String thousandSeparator(int n) {\\n        if(n == 0){\\n            return \"0\";\\n        }", "class Solution {\\n    public String thousandSeparator(int n) {\\n        if(n == 0){\\n            return \"0\";\\n        }"]}
{"id": "329", "ref_java": ["class Solution {\\n    public void helper(int a,int b,List<Integer>l)\\n    {\\n        for(int i=a;i<=b;i++)\\n        {\\n            l.add(i);\\n        }", "class Solution {\\n    public List<Integer> mostVisited(int n, int[] rounds) {\\n        var start = rounds[0];\\n        var end = rounds[rounds.length - 1];   \\n        var res = new ArrayList<Integer>();\\n        if (start <= end) {\\n            for (int i = start; i <= end; i++) res.add(i);\\n        }", "class Solution {\\n    public List<Integer> mostVisited(int n, int[] rounds) {\\n        \\n        int[] arr = new int[n];\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=0;\\n        }"]}
{"id": "330", "ref_java": ["class Solution {\\n    public boolean containsPattern(int[] arr, int m, int k) {\\n        var count = 0;\\n        for (int i = 0, j = i + m; j < arr.length; i++, j++) {\\n            if (arr[i] != arr[j]) count = 0;\\n            else if (++count == (k - 1) * m) return true;\\n        }", "class Solution {\\n    public boolean containsPattern(int[] arr, int m, int k) {\\n\\t\\n        for(int i=0; i<arr.length-m; i++) {\\n\\t\\t    ", "class Solution {\\n    public boolean containsPattern(int[] arr, int m, int k) {\\n        var count = 0;\\n        for (int i = 0, j = i + m; j < arr.length; i++, j++) {\\n            if (arr[i] != arr[j]) count = 0;\\n            else if (++count == (k - 1) * m) return true;\\n        }"]}
{"id": "331", "ref_java": ["class Solution {\\n    public int diagonalSum(int[][] mat) {\\n        int n = mat.length;\\n        if(n == 1) return mat[0][0];\\n        int sum = 0;\\n        int j = 0;\\n        for(int i = 0;i<n;i++){\\n            if((n & 1) == 1){\\n             if(j == n/2){\\n                 sum+=mat[i][j];\\n             }", "class Solution {\\n    public int diagonalSum(int[][] mat) {\\n        int n = mat.length;\\n        if(n == 1) return mat[0][0];\\n        int sum = 0;\\n        int j = 0;\\n        for(int i = 0;i<n;i++){\\n            if((n & 1) == 1){\\n             if(j == n/2){\\n                 sum+=mat[i][j];\\n             }", "class Solution {\\n    public int diagonalSum(int[][] mat) {\\n\\n        int i, j, sum=0;\\n\\n        for(i=0; i<mat.length; i++)\\n        {\\n            for(j=i; j<mat[0].length; j++)\\n            {\\n                if(i==j){\\n                    sum+= mat[i][j];\\n                    break;\\n                }"]}
{"id": "332", "ref_java": ["class Solution {\\n    public String modifyString(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0;i<ch.length;i++){\\n            if (ch[i] == \\'?\\'){\\n                for (char j = \\'a\\'; j <= \\'c\\';j++){\\n                    if (i > 0 && ch[i-1] == j) continue; ", "class Solution {\\n    public String modifyString(String s) {\\n        if (s.equals(\"?\")) {    ", "class Solution {\\n    public String modifyString(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0;i<ch.length;i++){\\n            if (ch[i] == \\'?\\'){\\n                for (char j = \\'a\\'; j <= \\'c\\';j++){\\n                    if (i > 0 && ch[i-1] == j) continue; "]}
{"id": "334", "ref_java": ["class Solution {\\n    public int numSpecial(int[][] mat) {\\n        \\n        int specials = 0;\\n\\n        for (int i = 0; i < mat.length; i++) {\\n            int index = checkRow(mat, i);\\n            if (index >= 0 && checkColumn(mat, i, index))\\n                specials++;\\n        }", "class Solution {\\n    public int numSpecial(int[][] mat) {\\n        int special = 0;\\n\\n        for (int[] row : mat) {\\n            if (getRowSum(row) == 1) {\\n                int colIdx = getIndexOfOne(row);\\n                special += (getColumnSum(mat, colIdx) == 1) ? 1 : 0;\\n            }", "class Solution {\\n    public int numSpecial(int[][] mat) {\\n        int ans = 0;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (mat[row][col] == 0) {\\n                    continue;\\n                }"]}
{"id": "336", "ref_java": ["class Solution {\\n    public int sumOddLengthSubarrays(int[] arr) {\\n        int add=0;\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i; j < arr.length; j++) {\\n                if ((j - i + 1) % 2 == 1) {\\n                    for (int k = i; k <= j; k++) {\\n                        add += arr[k];\\n                    }", "class Solution {\\n     public static int sumOddLengthSubarrays(int[] arr) {\\n        int windowSize = 1;\\n        int currentSum = 0;\\n        int finalSum = 0;\\n\\n            for (windowSize = 1; windowSize <= arr.length ; windowSize+=2) {\\n                currentSum = sumOfAllSlidingWindowOfSizeK(arr , windowSize);\\n                finalSum += currentSum;\\n            }", "class Solution {\\n    public int sumOddLengthSubarrays(int[] arr) {\\n        int sum=0;\\n        for(int i=0;i<=arr.length-1;i++){\\n            int leftBr = i+1;\\n            int rightBr = arr.length - i;\\n            int totalSub = leftBr*rightBr;\\n            int oddSub = (totalSub%2==0?0:1) + totalSub/2;\\n            sum+= arr[i]*oddSub;\\n        }"]}
{"id": "337", "ref_java": ["class Solution {\\n   \\n    public String reorderSpaces(String text) {\\n        ", "class Solution {\\n    public String reorderSpaces(String text) {\\n        int count=0;\\n        for(char a : text.toCharArray()){\\n            if(a == \\' \\')\\n                count++;\\n        }", "class Solution {\\n    public String reorderSpaces(String text) {\\n        int spaces = 0, words = 0;\\n        String s = \"\";\\n        int n = text.length();\\n        for(int i = 0 ;i<n; i++){\\n            char ch = text.charAt(i);\\n            if(ch != \\' \\')\\n                s = s+ch;\\n            if(ch == \\' \\')\\n                spaces++;\\n            else if (i<n-1 && text.charAt(i+1) == \\' \\'){\\n                words++;\\n                s+=\" \";\\n            }"]}
{"id": "338", "ref_java": ["class Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }", "class Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }", "class Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }"]}
{"id": "340", "ref_java": ["class Solution {\\n    public int specialArray(int[] nums) {\\n          int x = nums.length;\\n        int[] counts = new int[x+1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x]++;\\n            else\\n                counts[elem]++;\\n        \\n        int res = 0;\\n        for(int i = counts.length-1; i > 0; i--) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }", "class Solution {\\n    public int specialArray(int[] nums) {\\n        int x = 0;\\n        while (x <= nums.length){\\n            int y = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                if(nums[i] >= x) y++;\\n            }", "class Solution {\\n    public int specialArray(int[] nums) {\\n        int x = nums.length;\\n        int[] counts = new int[x+1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x]++;\\n            else\\n                counts[elem]++;\\n        \\n        int res = 0;\\n        for(int i = counts.length-1; i > 0; i--) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }"]}
{"id": "341", "ref_java": ["class Solution {\\n    public int maxDepth(String s) {\\n        int ans = 0;\\n        int max = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n            ans++;\\n            max = Math.max(max,ans);\\n            if(s.charAt(i) == \\')\\')\\n            ans--;\\n        }", "class Solution {\\n    public int maxDepth(String s) {\\n        int ans=0;\\n        int temp=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                temp++;\\n            }", "class Solution {\\n    public int maxDepth(String s) {\\n       Stack<Character> st=new Stack<>();int max=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')\\n           st.push(s.charAt(i));\\n           else if(s.charAt(i)==\\')\\'&&!st.isEmpty()) \\n           {\\n                max=Math.max(max,st.size()); "]}
{"id": "342", "ref_java": ["class Solution {\\n    public double trimMean(int[] arr) {\\n        double l = arr.length * 0.05;\\n        Arrays.sort(arr);\\n        double sum = 0;\\n        double j = 0;\\n        for (int i = (int)l; i < arr.length - l; i++) {\\n            sum = sum + arr[i];\\n            j++;\\n        }", "class Solution {\\n    public double trimMean(int[] arr) {\\n        double n =( 0.05 * arr.length );\\n        Arrays.sort(arr);\\n        double sum = 0;\\n        for(int i = (int)n; i<arr.length-n ; i++)            \\n            sum = sum + arr[i];\\n        double len  = arr.length - 2*n;\\n        sum  = sum / len;\\n        return sum;\\n    }", "class Solution {\\n  public double trimMean(int[] arr) {\\n    int items = (int) (arr.length * 0.05);\\n\\n    return IntStream.of(arr)\\n        .sorted()\\n        .skip(items)\\n        .limit(arr.length - items * 2L)\\n        .average()\\n        .orElse(0);\\n  }"]}
{"id": "343", "ref_java": ["class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[][] table = new int[26][2];\\n        int max = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            int ind = i+1;\\n            int c = s.charAt(i)-\\'a\\';\\n\\n            if(table[c][0] == 0) table[c][0] = ind;\\n            else table[c][1] = ind;\\n        }", "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max=-1;\\n      for(int i=0;i<s.length();i++){\\n          for(int j=s.length()-1;j>i;j--){\\n              if(s.charAt(i)==s.charAt(j)){\\n              max=Math.max(max,((j-i)-1));\\n              }", "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n\\n        int n = s.length();\\n\\n        int arr[] = new int [26];\\n        int max = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            int idx = s.charAt(i) - \\'a\\';\\n            if( arr[idx] > 0){\\n                max = Math.max(max, i - arr[idx]);\\n            }"]}
{"id": "344", "ref_java": ["class Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) \\n    {\\n        int n=releaseTimes.length;\\n        int[] prefix = new int[n];\\n        \\n        prefix[0] = releaseTimes[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = releaseTimes[i] - releaseTimes[i-1];\\n        }", "class Solution {\\n    public char slowestKey(int[] r, String k) {\\n        int m=r[0];\\n        int p=0;\\n        for(int i=1; i<r.length; i++)\\n        {\\n            if(m<r[i]-r[i-1])\\n            {\\n                m=r[i]-r[i-1];\\n                p=i;\\n            }", "class Solution {\\n    public char slowestKey(int[] r, String k) {\\n        int m=r[0];\\n        int p=0;\\n        for(int i=1; i<r.length; i++)\\n        {\\n            if(m<r[i]-r[i-1])\\n            {\\n                m=r[i]-r[i-1];\\n                p=i;\\n            }"]}
{"id": "346", "ref_java": ["class Solution {\\n    public int[] frequencySort(int[] a) {\\n\\tArrayList<Integer>al=new ArrayList<>();\\n\\t    for(int i=0;i<a.length;i++){\\n\\t        al.add(a[i]);\\n\\t    }", "class Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int n : nums) {                            \\n            ans.add(n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }", "class Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int n : nums) {                            \\n            ans.add(n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }"]}
{"id": "347", "ref_java": ["class Solution {\\n    public boolean canFormArray(int[] arr, int[][] pieces) {\\n\\n        String s = \"\";\\n        Map<Integer, int[]> myMap = new HashMap<Integer, int[]>();\\n\\n        for (int i = 0 ; i < pieces.length ; i++){\\n            myMap.put(pieces[i][0], pieces[i]);\\n        }", "class Solution {\\n    public boolean canFormArray(int[] arr, int[][] pieces) {\\n        HashMap<Integer,int[]> hm = new HashMap();\\n        for(int[] list:pieces)\\n            hm.put(list[0],list);\\n        \\n        int index = 0;\\n        while(index<arr.length){\\n            if(!hm.containsKey(arr[index]))\\n                return false;\\n            \\n            int[] list = hm.get(arr[index]);\\n            for(int val:list){\\n                if(index>=arr.length || val!=arr[index])\\n                    return false;\\n                index++;\\n            }", "class Solution {\\n    public boolean canFormArray(int[] arr, int[][] pieces) {\\n        int[] indices = new int[101];\\n        Arrays.fill(indices, -1);\\n        for (int i = 0; i < arr.length; i++) {\\n            indices[arr[i]] = i;\\n        }"]}
{"id": "348", "ref_java": ["class Solution {\\n    public int getMaximumGenerated(int n) {\\n        if(n==0)return 0;\\n        if(n==1)return 1;\\n        int []arr=new int[n+1];\\n        arr[0]=0;\\n        arr[1]=1;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=2;i<=n;i++){\\n            if(i%2==0)arr[i]=arr[i/2];\\n            else arr[i]=arr[i/2]+arr[(i/2)+1];\\n            maxi=Math.max(maxi,arr[i]);\\n        }", "class Solution {\\n    public int getMaximumGenerated(int n) {\\n        int nums[]=new int[n+1];\\n        if(n==0)return 0;\\n        if(n==1)return 1;\\n        nums[0]=0;\\n        nums[1]=1;\\n        int max=0;\\n        for(int i=2;i<n+1;i++){\\n            if(i%2==0){\\n                nums[i]=nums[i/2];\\n            }", "class Solution {\\n    public int getMaximumGenerated(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        int[]  dp = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        int max = 0;\\n        for(int i=2; i<=n; i++){\\n            if(i%2 ==0){\\n                dp[i] = dp[i/2];\\n            }"]}
{"id": "349", "ref_java": ["class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n         if (k == 0) {\\n            return ans;\\n        }", "class Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }", "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n         if (k == 0) {\\n            return ans;\\n        }"]}
{"id": "352", "ref_java": ["class Solution {\\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\\n        String left = \"\"; ", "class Solution {\\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\\n        ", "class Solution {\\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\\n        StringBuilder str1 = new StringBuilder();\\n        StringBuilder str2 = new StringBuilder();\\n\\n        for(String word : word1){\\n            str1.append(word);\\n        }"]}
{"id": "354", "ref_java": ["class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int ans = 1;\\n        while (sequence.contains(word.repeat(ans))) {\\n            ans++;\\n        }", "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String find=\"\";\\n        while(sequence.contains(find)) find += word;\\n        return (find.length()-word.length())/word.length();\\n    }", "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String add=word;\\n        while(sequence.contains(word)==true)\\n        {\\n            c+=1;\\n            word=word+add;\\n            "]}
{"id": "355", "ref_java": ["class Solution {\\n    public int maximumWealth(int[][] accounts) {\\n        int res = 0;\\n        for(int i =0;i<accounts.length;i++){\\n            int temp = 0;\\n            for(int j = 0;j<accounts[i].length;j++){\\n                temp+=accounts[i][j];\\n            }", "class Solution {\\n    public int maximumWealth(int[][] accounts) {\\n        int curr_sum=0;\\n        int max=0;\\n        int i=0;\\n        while(i != accounts.length){\\n                for(int j=0; j<accounts[i].length; j++){\\n                   curr_sum=curr_sum+accounts[i][j];\\n                 }", "class Solution {\\n    public int maximumWealth(int[][] accounts) {\\n        int largest = accounts[0][0];\\n        for(int customer[] : accounts){\\n            int currentSum = 0;\\n            for(int bank : customer) currentSum += bank;\\n            largest = Math.max(largest, currentSum);\\n        }"]}
{"id": "356", "ref_java": ["class Solution {\\n    public String interpret(String command) {\\n                int i = 0;\\n        StringBuilder answ = new StringBuilder();\\n        while (i < command.length())\\n        {\\n            switch (command.charAt(i))\\n            {\\n                case \\'G\\':\\n                {\\n                    answ.append(\"G\");\\n                    i++;\\n                    break;\\n                }", "class Solution {\\n    public String interpret(String command) {\\n        StringBuilder word = new StringBuilder();\\n        for(int i = 0; i < command.length(); i++) {\\n            char c = command.charAt(i);\\n            if(c != \\'(\\' && c != \\')\\') {\\n               word.append(c);\\n            }", "class Solution {\\n    public String interpret(String command) {\\n        StringBuilder word = new StringBuilder();\\n        for(int i = 0; i < command.length(); i++) {\\n            char c = command.charAt(i);\\n            if(c != \\'(\\' && c != \\')\\') {\\n               word.append(c);\\n            }"]}
{"id": "358", "ref_java": ["class Solution {\\n    public int countConsistentStrings(String allowed, String[] words) {\\n        HashSet<Character> set = new HashSet<>();\\n        \\n        int ans =0;\\n        for(int i =0;i<allowed.length();i++){\\n            set.add(allowed.charAt(i));\\n        }", "class Solution {\\n    public int countConsistentStrings(String allowed, String[] words) {\\n\\n        int res=0;\\n        outerloop:\\n        for(int i=0; i<words.length; i++){\\n            for(int j=0; j<words[i].length(); j++){\\n                if(!allowed.contains(String.valueOf(words[i].charAt(j))))\\n                continue outerloop;\\n            }", "class Solution {\\n    public int countConsistentStrings(String allowed, String[] words) {\\n       HashMap<Character, Integer> mp = new HashMap();\\n        int count = words.length;\\n        for(int i = 0; i < allowed.length(); i++){\\n            mp.put(allowed.charAt(i), 1);\\n        }"]}
{"id": "359", "ref_java": ["class Solution {\\n    public int numberOfMatches(int n) {\\n        return n - 1;\\n    }", "class Solution {\\n    public int numberOfMatches(int n) {\\n        return n - 1;\\n    }", "class Solution {\\n  public int numberOfMatches(int n) {\\n    var ans = 0;\\n\\n    while (n > 1) {\\n      ans += n / 2;\\n      n = (n % 2) + (n / 2);\\n    }"]}
{"id": "361", "ref_java": ["class Solution {\\n    public String reformatNumber(String number) {\\n       StringBuilder ans = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        for(int i = 0; i < number.length(); i ++) {\\n            if(number.charAt(i) != \\' \\' && number.charAt(i) != \\'-\\') {\\n                temp.append(number.charAt(i));\\n            }", "class Solution {\\n    public String reformatNumber(String number) {\\n       number = number\\n                .replace(\" \", \"\")\\n                .replace(\"-\", \"\");\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        int i = 0;\\n        int mod = 3;\\n        int limit = number.length();\\n        if (limit == 4) {\\n            mod = 2;\\n        }", "class Solution {\\n    public String reformatNumber(String number) {\\n       StringBuilder ans = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        for(int i = 0; i < number.length(); i ++) {\\n            if(number.charAt(i) != \\' \\' && number.charAt(i) != \\'-\\') {\\n                temp.append(number.charAt(i));\\n            }"]}
{"id": "362", "ref_java": ["class Solution {\\n    public int countStudents(int[] students, int[] sandwiches) {\\n        int ones = 0; ", "class Solution {\\n    public int countStudents(int[] st, int[] sand) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<sand.length;i++){\\n            q.add(sand[i]);\\n        }", "class Solution {\\n    public int countStudents(int[] st, int[] sand) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<sand.length;i++){\\n            q.add(sand[i]);\\n        }"]}
{"id": "363", "ref_java": ["class Solution {\\n    public boolean halvesAreAlike(String s) {\\n        String s1=\"\";\\n        char ch1;\\n        String s2 = \"\";\\n        char ch2;\\n        int n = s.length()/2;\\n        for(int i=0;i<n;i++){\\n            ch1 = s.charAt(i);\\n            s1=ch1+s1;\\n        }", "class Solution {\\n    public boolean halvesAreAlike(String s) {\\n    \\n        var set=Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\');\\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=0,j=s.length()-1;i<j;i++,j--){\\n            a+=set.contains(s.charAt(i))?1:0;\\n            b+=set.contains(s.charAt(j))?1:0;\\n        }", "class Solution {\\n    public boolean halvesAreAlike(String s) {\\n    \\n        var set=Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\');\\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=0,j=s.length()-1;i<j;i++,j--){\\n            a+=set.contains(s.charAt(i))?1:0;\\n            b+=set.contains(s.charAt(j))?1:0;\\n        }"]}
{"id": "364", "ref_java": ["class Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> Integer.compare(b[1] , \\n        a[1]));\\n        int i = 0;\\n        while(heap.size() < boxTypes.length){\\n            heap.offer(boxTypes[i++]);\\n        }", "class Solution {\\n\\t\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\t\\tArrays.sort(boxTypes, Comparator.comparingInt(o -> -o[1]));\\n\\t\\t\\tint ans = 0, i = 0, n = boxTypes.length;\\n\\t\\t\\twhile (i < n && truckSize > 0) {\\n\\t\\t\\t\\tint maxi = Math.min(boxTypes[i][0], truckSize);\\n\\t\\t\\t\\tans += maxi * boxTypes[i][1];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\ttruckSize -= maxi;\\n\\t\\t\\t}", "class Solution {\\n    public int maximumUnits(int[][] B, int T) {\\n        Arrays.sort(B, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for (int[] b : B) {\\n            int count = Math.min(b[0], T);\\n            ans += count * b[1];\\n            T -= count;\\n\\t\\t\\tif (T == 0) return ans;\\n        }"]}
{"id": "365", "ref_java": ["class Solution {\\n    solve(week) {\\n        let result = 0;\\n        for (let i = 0; i < week; i++) {\\n            result += 28 + (i * 7);\\n        }", "class Solution {\\n    public int totalMoney(int n) {\\n        int total = 0;\\n\\n        for (int day = 0; day < n; day++) {\\n            total += (day / 7 + 1) + (day % 7);\\n        }", "class Solution {\\n    solve(week) {\\n        let result = 0;\\n        for (let i = 0; i < week; i++) {\\n            result += 28 + (i * 7);\\n        }"]}
{"id": "366", "ref_java": ["class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length+1];\\n        arr[0] = first;\\n        for(int i = 0 ; i<encoded.length ; i++){\\n            int j = 0;\\n            while(true){\\n                if((arr[i]^j)==encoded[i]){\\n                    arr[i+1] = j;\\n                    break;\\n                }", "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[]=new int[encoded.length+1];\\n        arr[0]=first;\\n        int index=0;\\n        for(int i=0;i<encoded.length;i++){\\n            int ans=arr[index++]^encoded[i];\\n            arr[index]=ans;\\n        }", "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result=new int[encoded.length+1];\\n        result[0]=first;\\n        for(int i=0;i<encoded.length;i++)\\n        {\\n            result[i+1]=encoded[i] ^ result[i];\\n        }"]}
{"id": "367", "ref_java": ["class Solution {\\n    public int countGoodRectangles(int[][] arr) {\\n        int[] sq = new int[arr.length];\\n        int m=arr.length;\\n        int n=arr[0].length;\\n        for(int i=0;i<m;i++){\\n            if(arr[i][0]<arr[i][1]){\\n                sq[i]=arr[i][0];\\n            }", "class Solution {\\n    public int countGoodRectangles(int[][] rectangles) {\\n        int maxLength = 0;\\n        int minLength;\\n        int count = 0;\\n        for(int i = 0; i < rectangles.length; i++) {\\n            minLength = Integer.min(rectangles[i][0], rectangles[i][1]);\\n            if(maxLength < minLength) {\\n                maxLength = minLength;\\n                count = 1;\\n            }", "class Solution {\\n    public int countGoodRectangles(int[][] rectangles) {\\n        int[] sides = new int[rectangles.length];\\n        int count = 0;\\n        int maxLen = 0;\\n        for (int i = 0; i < rectangles.length; i++) {\\n            if (rectangles[i][0] < rectangles[i][1])\\n                sides[i] = rectangles[i][0];\\n            else\\n                sides[i] = rectangles[i][1];\\n        }"]}
{"id": "370", "ref_java": ["class Solution {\\n    public int largestAltitude(int[] gain) {\\n        int n=gain.length;\\n        int max_so_far=0;\\n        int max_final =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            max_so_far+=gain[i];\\n            max_final=Math.max(max_final,max_so_far);\\n        }", "class Solution {\\n    public int largestAltitude(int[] gain) {\\n        int n=gain.length;\\n        int max_so_far=0;\\n        int max_final =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            max_so_far+=gain[i];\\n            max_final=Math.max(max_final,max_so_far);\\n        }", "class Solution {\\n    public int largestAltitude(int[] gain) {\\n        int n=gain.length;\\n        int max_so_far=0;\\n        int max_final =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            max_so_far+=gain[i];\\n            max_final=Math.max(max_final,max_so_far);\\n        }"]}
{"id": "371", "ref_java": ["class Solution {\\n    public String maximumTime(String time) {\\n         if (time.charAt(0) == \\'?\\') {\\n            if (time.charAt(1) != \\'?\\' && time.charAt(1) - \\'0\\' > 3) {\\n                time = time.substring(0, 0) + \\'1\\' + time.substring(1);\\n            }", "class Solution {\\n    public String maximumTime(String time) {\\n    \\n        char[] ans= time.toCharArray();\\n        if(ans[0]==\\'?\\'){\\n            ans[0]= (ans[1]<=\\'3\\' || ans[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        }", "class Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        "]}
{"id": "373", "ref_java": ["class Solution {\\n    public int countBalls(int lowLimit, int highLimit) {\\n        ", "class Solution {\\n    public int countBalls(int lowLimit, int highLimit) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=Integer.MIN_VALUE;\\n        for(int i=lowLimit;i<=highLimit;i++){\\n            int key=0,num=i;\\n            while(num>0){\\n                key+=num%10;\\n                num/=10;\\n            }", "class Solution {\\n    public int countBalls(int lowLimit, int highLimit) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = Integer.MIN_VALUE;\\n        for(int i = lowLimit;i<=highLimit;i++){\\n            int value = 0;\\n            int temp = i;\\n            while (temp!=0){\\n                value += temp%10;\\n                temp/=10;\\n            }"]}
{"id": "374", "ref_java": ["class Solution {\\n    public int sumOfUnique(int[] nums) {\\n        int [] freq = new int[101];\\n        int sum = 0 ;\\n        for(int  i : nums){\\n            freq[i]++;\\n            if(freq[i] == 1)\\n                sum += i ;\\n            else if (freq[i] == 2)\\n                sum-=i;\\n        }", "class Solution {\\n    public int sumOfUnique(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }", "class Solution {    \\n    public int sumOfUnique(int[] nums) {\\n        int[] arr = new int[101];\\n        for (int num : nums) arr[num]++;\\n        int sum = 0;\\n        for (int num : nums)\\n            if (arr[num] == 1) sum+=num;\\n        return sum;\\n    }"]}
{"id": "375", "ref_java": ["class Solution {\\n    public boolean check(int[] nums) {\\n        int count = 0;\\n\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(nums[i] > nums[i+1])\\n                count++;\\n        }", "class Solution {\\n    public boolean check(int[] nums) {\\n        boolean var1 = true, var2 = true;\\n        int var3 = -1;\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] > nums[i+1]){\\n                var1 = false;\\n                var3 = i+1;\\n                break;\\n            }", "class Solution {\\n    public boolean check(int[] nums) {\\n        boolean var1 = true, var2 = true;\\n        int var3 = -1;\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] > nums[i+1]){\\n                var1 = false;\\n                var3 = i+1;\\n                break;\\n            }"]}
{"id": "377", "ref_java": ["class Solution {\\n    public int minOperations(String s) {\\n        char c_0 = s.charAt(0);\\n        int count1 = count(s, c_0);\\n        int count2 = count(s, c_0==\\'0\\'?\\'1\\':\\'0\\')+1;\\n        return Math.min(count1, count2);\\n    }", "class Solution {\\n    public int minOperations(String s) {\\n        int countForAlternate0 = 0;\\n        int countForAlternate1 = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                if (s.charAt(i) == \\'0\\') {\\n                    countForAlternate1++;\\n                }", "class Solution {\\n    public int minOperations(String s) {\\n        int n = s.length(), count = 0;\\n        if (n == 1) return 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0 && s.charAt(i) == \\'1\\') count++;\\n            if (i % 2 == 1 && s.charAt(i) == \\'0\\') count++;\\n        }"]}
{"id": "378", "ref_java": ["class Solution {\\n    public String longestNiceSubstring(String s) {\\n       Set<Character> set = new HashSet();\\n       for(char c : s.toCharArray()){\\n           set.add(c);\\n       }", "class Solution {\\n    public String longestNiceSubstring(String s) {\\n        int [] index = longestNiceSubstring(s, 0, s.length());\\n        return s.substring(index[0], index[1]);\\n    }", "class Solution {\\n    public String longestNiceSubstring(String s) {\\n       Set<Character> set = new HashSet();\\n       for(char c : s.toCharArray()){\\n           set.add(c);\\n       }"]}
{"id": "379", "ref_java": ["class Solution {\\n    public String mergeAlternately(String word1, String word2) {\\n        StringBuilder result = new StringBuilder();\\n        int i = 0;\\n        while (i < word1.length() || i < word2.length()) {\\n            if (i < word1.length()) {\\n                result.append(word1.charAt(i));\\n            }", "class Solution {\\n    public String mergeAlternately(String word1, String word2) {\\n        StringBuilder sb = new StringBuilder();\\n        int min = Math.min(word1.length() , word2.length());\\n        for(int i=0 ; i<min ; i++){\\n            sb.append(word1.charAt(i));\\n            sb.append(word2.charAt(i));\\n        }", "class Solution {\\n    public String mergeAlternately(String word1, String word2) {\\n\\n        StringBuilder result = new StringBuilder(word1.length() + word2.length());\\n\\n        int minLength = Math.min(word1.length(), word2.length());\\n\\n        for (int i = 0; i < minLength; i++) {\\n            result.append(word1.charAt(i)).append(word2.charAt(i));\\n        }"]}
{"id": "380", "ref_java": ["class Solution {\\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\\n        int count = 0 ;\\n        int index = (ruleKey.equals(\"type\"))? 0: (ruleKey.equals(\"color\"))? 1 : 2;\\n\\n        for (List list : items )\\n        {\\n            if (list.get(index).equals(ruleValue)) count++;\\n        }", "class Solution {\\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\\n        int res = 0;\\n        \\n        for(int i = 0 ;i<items.size();i++){\\n            if(ruleKey.equals(\"type\") && items.get(i).get(0).equals(ruleValue)) res++;\\n            if(ruleKey.equals(\"color\") && items.get(i).get(1).equals(ruleValue)) res++;\\n            if(ruleKey.equals(\"name\") && items.get(i).get(2).equals(ruleValue)) res++;\\n        }", "class Solution {\\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\\n        int c=0;\\n        switch(ruleKey)\\n        {\\n            case \"type\":\\n                for(List x:items)\\n                {\\n                        if(x.get(0).equals(ruleValue))\\n                        c++;\\n                }"]}
{"id": "381", "ref_java": ["class Solution {\\n    public static class Points implements Comparable<Points>{\\n        int x,y,d,i;\\n        public Points(int x,int y,int d,int i){\\n            this.x=x;\\n            this.y=y;\\n            this.d=d;\\n            this.i=i;\\n        }", "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int sIndex = 100000;\\n        int sDistance = 100000;\\n\\n        for (int i = 0; i < points.length; i++) {\\n            \\n            ", "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n         int res = -1;\\n        ArrayList<int[]> arr = new ArrayList<>();\\n        for (int i = 0; i < points.length; i++) {\\n            int xPoint = points[i][0];\\n            int yPoint = points[i][1];\\n            if(xPoint == x || yPoint == y){\\n                arr.add(points[i]);\\n                System.out.println(\"Point added to arr : \" + Arrays.toString(points[i]));\\n            }"]}
{"id": "382", "ref_java": ["class Solution {\\n    public boolean checkOnesSegment(String s) {\\n        int count=0;\\n       int pos=0;\\n       while(s.charAt(pos)!=\\'1\\'){\\n              pos++;\\n            if(pos==s.length()){\\n                return true;\\n            }", "class Solution {\\n    public boolean checkOnesSegment(String s) {\\n        ", "class Solution {\\n    public boolean checkOnesSegment(String str) {\\n\\n     "]}
{"id": "384", "ref_java": ["class Solution {\\n    public boolean areAlmostEqual(String s1, String s2) {\\n        if (s1.equals(s2)) return true;\\n        int []alpha = new int[s1.length()];\\n        int one = -100;\\n        int two = -100;\\n        for (int i = 0; i < s1.length(); i++)\\n        {\\n            if (s1.charAt(i) != s2.charAt(i))\\n            {\\n                if (one == -100 && two == -100) {\\n                    one = s1.charAt(i) - \\'a\\';\\n                    two = s2.charAt(i) - \\'a\\';\\n                }", "class Solution {\\n    public boolean areAlmostEqual(String s1, String s2) {\\n            if(s1.equals(s2)) return true;\\n            int count = 0;\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            for(int i = 0; i<s1.length(); i++){\\n                sum1 = sum1 + s1.charAt(i);\\n                sum2 = sum2 + s2.charAt(i);\\n           }", "class Solution {\\n    public boolean areAlmostEqual(String s1, String s2) {\\n        int count = 0;\\n        int temp1[] = new int[26] , temp2[] = new int[26];\\n        for(int i=0; i<s1.length(); i++){\\n            int a1 = s1.charAt(i)-\\'a\\', a2 = s2.charAt(i)-\\'a\\';\\n            temp1[a1]++; temp2[a2]++;  \\n        }"]}
{"id": "385", "ref_java": ["class Solution {\\n    public int findCenter(int[][] edges) {\\n        ArrayList<Integer> ar=new ArrayList<>();\\n        for(int x[]:edges)\\n        {\\n            ar.add(x[0]);\\n            ar.add(x[1]);\\n        }", "class Solution {\\n    public int findCenter(int[][] edges) {\\n        ArrayList<Integer> ar=new ArrayList<>();\\n        for(int x[]:edges)\\n        {\\n            ar.add(x[0]);\\n            ar.add(x[1]);\\n        }", "class Solution {\\n    public int findCenter(int[][] edges) {\\n        int a = edges[0][0];\\n        int b = edges[0][1];\\n        int c = edges[1][0];\\n        int d = edges[1][1];\\n        if(a==c) return a;\\n        if(a==d) return a;\\n        if(b==c) return c;\\n        if(b==d) return b;\\n        return 0;\\n    }"]}
{"id": "387", "ref_java": ["class Solution {\\n    public int secondHighest(String s) {\\n        String t= s.replaceAll(\"\\\\\\\\D+\",\"\");\\n        System.out.println(t);\\n        ArrayList<Integer> ls= new ArrayList<>();\\n\\n        for(int i=0;i<t.length();i++){\\n            int val= t.charAt(i)-\\'0\\';\\n            if(!ls.contains(val)){\\n                ls.add(val);\\n            }", "class Solution {\\n    public int secondHighest(String s) {\\n        Set<Integer> set = new TreeSet<>(Collections.reverseOrder());\\n\\n        for(char c:s.toCharArray())\\n            if(Character.isDigit(c))\\n                set.add(Integer.parseInt(String.valueOf(c)));\\n\\n        if(set.size() == 1)\\n            return -1;\\n\\n        int i=1;\\n        for(int j: set)\\n            if(i++==2)\\n                return j;\\n\\n        return -1;\\n    }", "class Solution {\\n    public int secondHighest(String s) {\\n        Set<Integer> set = new HashSet();\\n        \\n        for (char c : s.toCharArray())\\n            if (Character.isDigit(c)) set.add(Integer.parseInt(String.valueOf(c)));\\n        \\n        int maximum = 0;\\n        for (int i : set) maximum = Math.max(i, maximum);\\n\\n        int n = Integer.MIN_VALUE;\\n        for (int i : set)\\n            if (i < maximum) n = Math.max(i, n);\\n\\n        return n < 0 ? -1 : n;\\n    }"]}
{"id": "388", "ref_java": ["class Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int[] arr = new int[101];\\n\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i < 1){\\n                arr[j] += nums[i];\\n            }", "class Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum=nums[nums.length-1];\\n        int max=nums[nums.length-1];\\n        for( int i=nums.length-2;i>=0;i--){\\n            if( nums[i+1] > nums [i] ){\\n               sum += nums[i];\\n            }", "class Solution {\\n    public int maxAscendingSum(int[] nums) {\\n        int sum = 0;\\n        int maxSum = 0;\\n     for(int i = 0; i < nums.length-1;i++){\\n        if(nums[i] < nums[i+1])  sum += nums[i];\\n        else{ \\n            sum += nums[i];\\n            maxSum = Math.max(maxSum , sum);\\n            sum = 0;\\n        }"]}
{"id": "389", "ref_java": ["class Solution {\\n    public int numDifferentIntegers(String word) {\\n        String[] arr = word.replaceAll(\"[a-zA-Z]\", \" \").split(\"\\\\\\\\s+\");\\n        Set<String> set = new HashSet<String>();\\n            \\n        for (String str : arr) {\\n            if (!str.isEmpty())\\n                set.add(String.valueOf(str.replaceAll(\"^0*\",\"\")));\\n        }", "class Solution {\\n    public int numDifferentIntegers(String word) {\\n        String[] arr = word.replaceAll(\"[a-zA-Z]\", \" \").split(\"\\\\\\\\s+\");\\n        Set<String> set = new HashSet<String>();\\n            \\n        for (String str : arr) {\\n            if (!str.isEmpty())\\n                set.add(String.valueOf(str.replaceAll(\"^0*\",\"\")));\\n        }", "class Solution {\\n    public int numDifferentIntegers(String word) {\\n        String[] arr = word.replaceAll(\"[a-zA-Z]\", \" \").split(\"\\\\\\\\s+\");\\n        Set<String> set = new HashSet<String>();\\n            \\n        for (String str : arr) {\\n            if (!str.isEmpty())\\n                set.add(String.valueOf(str.replaceAll(\"^0*\",\"\")));\\n        }"]}
{"id": "390", "ref_java": ["class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        char[] coordinate = coordinates.toCharArray(); \\n        \\n        \\n        int alpha = coordinate[0];\\n        int num =  coordinate[1];\\n        \\n        ", "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int x=coordinates.charAt(0)-\\'a\\';\\n        int y=coordinates.charAt(1)-\\'0\\';\\n        if(x % 2 !=0 && y % 2 != 0)\\n            return true;\\n        else if(x % 2 ==0 && y % 2 ==0 )\\n            return true;\\n        \\n        return false;\\n    }", "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        if((coordinates.charAt(0)+coordinates.charAt(1))%2==0){\\n          return false;\\n            \\n         }"]}
{"id": "391", "ref_java": ["class Solution {\\n    public String truncateSentence(String s, int k) {\\n        String arr[] = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < k; i++) {\\n            if(i < arr.length) {\\n                sb.append(arr[i]).append(\" \");\\n            }", "class Solution {\\n    public String truncateSentence(String s, int k) {\\n        int count = 0;\\n        int index = 0;\\n        for(index = 0; index < s.length(); index++){\\n            if(s.charAt(index) == \\' \\')\\n                count++;   \\n            if(count==k)\\n                break;   \\n        }", "class Solution {\\n    public String truncateSentence(String s, int k) {\\n        String out=\"\";\\n        "]}
{"id": "392", "ref_java": ["class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }", "class Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        if ((Arrays.stream(nums).reduce(0, (a, b) -> ((b == 0) ? (1) : (a) ) ) ) > 0)\\n            return 0;\\n        \\n        int negativeCount = Arrays.stream(nums).reduce(0, (a, b) -> ((b < 0) ? ++a : a));\\n\\n        return (negativeCount % 2 == 1) ? -1 : 1; \\n\\n    }", "class Solution {\\n    public int arraySign(int[] nums) {\\n        int count=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n"]}
{"id": "393", "ref_java": ["class Solution {\\n    public int minOperations(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans = 0;\\n\\n        for(int i=1; i<n; i++){\\n            if(arr[i]<=arr[i-1]){\\n                ans = ans + arr[i-1]-arr[i]+1;\\n                arr[i] = arr[i-1]+1;\\n            }", "class Solution {\\n    public int minOperations(int[] nums) {\\n        int count = 0;\\n\\n        for(int i=1;i<nums.length;i++){\\n\\n            if(nums[i]<=nums[i-1]){\\n            count += Math.abs(nums[i]-nums[i-1])+1;\\n            nums[i] = nums[i-1]+1;\\n\\n            }", "class Solution {\\n    public int minOperations(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int count =0;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            arr[i] = nums[i];\\n        }"]}
{"id": "394", "ref_java": ["class Solution {\\n    public boolean checkIfPangram(String sentence) {\\n        char ch=\\'a\\';\\n        for(int i=0; i < 26; i++)\\n            if(sentence.contains(String.valueOf(ch))) ch++;\\n            else return false;\\n        return true;\\n    }", "class Solution {\\n    public boolean checkIfPangram(String a) {\\n        int n =a.length();\\n        boolean hash[] = new boolean[26];\\n        int count =0;\\n        for(int i=0;i<n;i++){\\n            char c = a.charAt(i);\\n            if(!hash[c-  \\'a\\']){\\n                count++;\\n            }", "class Solution {\\n    public boolean checkIfPangram(String s) {\\n        HashSet<Character> hs=new HashSet<>();\\n       \\n        char[] ch=s.toCharArray();\\n        for(char p:ch){\\n            hs.add(p);\\n        }"]}
{"id": "395", "ref_java": ["class Solution {\\n    public int sumBase(int n, int k) {\\n        int sum = 0;\\n        while(n > 0) {\\n            sum += n % k;\\n            n = n / k;\\n        }", "class Solution {\\n    public int sumBase(int n, int k) {\\n        int count = 0;\\n\\n        while(n>0){\\n            count +=n%k;\\n            n= n/k;\\n        }", "class Solution {\\n    public int sumBase(int n, int k) {\\n        int sum=0;\\n        while(n>0)\\n        {\\n            sum+=n%k;\\n            n/=k;\\n        }"]}
{"id": "396", "ref_java": ["class Solution {\\n    public String replaceDigits(String s) {\\n        char ch[]=s.toCharArray();\\n        for(int i=1;i<ch.length;i++){\\n            if(i%2!=0){\\n                char c=shift(ch[i-1],ch[i]-\\'0\\');\\n                ch[i]=c;\\n            }", "class Solution {\\n    public String replaceDigits(String s) {\\n        char[] arr = s.toCharArray();\\n        for(int i = 1; i < arr.length; i += 2)\\n            arr[i] += arr[i - 1] - \\'0\\';\\n        return new String(arr);\\n    }", "class Solution {\\n    public String replaceDigits(String s) {\\n        char ch[]=s.toCharArray();\\n        for(int i=1;i<ch.length;i++){\\n            if(i%2!=0){\\n                char c=shift(ch[i-1],ch[i]-\\'0\\');\\n                ch[i]=c;\\n            }"]}
{"id": "397", "ref_java": ["class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }", "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }", "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }"]}
{"id": "398", "ref_java": ["class Solution {\\n    public int maximumPopulation(int[][] logs) {\\n        \\n        int[] year = new int[2051];\\n        \\n\\t\\t", "class Solution {\\n    public int maximumPopulation(int[][] logs) {\\n        \\n        int[] year = new int[2051];\\n        \\n\\t\\t", "class Solution {\\n    public int maximumPopulation(int[][] logs) {\\n        int[] arr = new int[101];\\n        for(int[] log : logs) {\\n            int birth = log[0];\\n            int death = log[1];\\n            arr[birth-1950]++;\\n            arr[death-1950]--;\\n        }"]}
{"id": "399", "ref_java": ["class Solution {\\n    public String sortSentence(String s) {\\n        String[] str = new String[s.split(\" \").length];\\n        for(String st : s.split(\" \"))\\n        {\\n            str[st.charAt(st.length()-1) - \\'1\\'] = st.substring(0,st.length()-1);\\n        }", "class Solution {\\n    public String sortSentence(String s) {\\n        ", "class Solution {\\n    public String sortSentence(String s) {\\n        "]}
{"id": "400", "ref_java": ["class Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int n=nums.length;\\n        int size=(1<<n);\\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i & (1<<j))>0)\\n                {\\n                    temp^=nums[j];\\n                    \\n               }", "class Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int n=nums.length;\\n        int size=(1<<n);\\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i & (1<<j))>0)\\n                {\\n                    temp^=nums[j];\\n                    \\n               }", "class Solution {\\n    int sum=0;\\n    public int subsetXORSum(int[] nums) {\\n        sum=0;\\n        return getAns(nums,0,0);\\n    }"]}
{"id": "401", "ref_java": ["class Solution {\\n    public boolean checkZeroOnes(String s) {\\n        int max1 = 0;\\n        int max0 = 0;\\n        int count1 =0;\\n        int count0 =0;\\n\\n        for(int i =0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c==\\'0\\'){\\n               count0++;\\n               max1 = Math.max(count1, max1);\\n               count1=0;\\n\\n            }", "class Solution {\\n    public boolean checkZeroOnes(String s) {\\n        int max1 = 0;\\n        int max0 = 0;\\n        int count1 =0;\\n        int count0 =0;\\n\\n        for(int i =0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c==\\'0\\'){\\n               count0++;\\n               max1 = Math.max(count1, max1);\\n               count1=0;\\n\\n            }", "class Solution {\\n    public boolean checkZeroOnes(String s) {\\n        int len1=0,len0=0;"]}
{"id": "403", "ref_java": ["class Solution {\\n    public int countGoodSubstrings(String s) {\\n        char a, b, c;\\n        int ans = 0; \\n        for(int i=0; i<s.length()-2; i++){\\n            a = s.charAt(i);\\n            b = s.charAt(i+1);\\n            c = s.charAt(i+2);\\n            if(a!=b && b!=c && a!=c) ans++;\\n        }", "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }", "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++){\\n            char ch1 = s.charAt(i);\\n            char ch2 = s.charAt(i+1);\\n            char ch3 = s.charAt(i+2);\\n\\n            if(ch1!=ch2 && ch1!=ch3 && ch2!=ch3) ans++;\\n        }"]}
{"id": "404", "ref_java": ["class Solution {\\n    public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {\\n        int num1 = sum(firstWord);\\n        int num2 = sum(secondWord);\\n        int num3 = sum(targetWord);\\n\\n        int sumation = num1+num2;\\n\\n        if(sumation == num3){\\n            return true;\\n        }", "class Solution {\\n    public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {\\n        int first = convert(firstWord);\\n        int second = convert(secondWord);\\n        int target = convert(targetWord);\\n        return (first+second==target);\\n    }", "class Solution {\\n    public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {\\n        return strToNum(firstWord) + strToNum(secondWord) == strToNum(targetWord);\\n    }"]}
{"id": "405", "ref_java": ["class Solution {\\n    public boolean findRotation(int[][] a, int[][] b) {\\n       \\n\\n         int n=a.length;\\n      int c90=0,c180=0,c270=0,c0=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(b[i][j]==a[n-j-1][i])\\n                    c90++;\\n                if(b[i][j]==a[n-i-1][n-j-1])\\n                    c180++;\\n                if(b[i][j]==a[j][n-i-1])\\n                    c270++;\\n                if(b[i][j]==a[i][j])\\n                    c0++;\\n            }", "class Solution {\\n    public boolean findRotation(int[][] mat, int[][] target) {\\n     \\n        for(int i=0; i<4; i++){\\n        if(isEqual(mat,target)) return true;\\n        mat = rotate(mat);\\n        }", "class Solution {  \\n    public boolean findRotation(int[][] mat, int[][] target) {\\n\\t\\tif (mat == target)  return true;\\n        int n = mat.length;\\n        int[] res[] = new int[n][n];\\n        for (int i = 0; i < n; i++) { "]}
{"id": "407", "ref_java": ["class Solution {\\n    public boolean isCovered(int[][] arr, int left, int right) {\\n        int n = arr.length;\\n\\n        for(int i=left; i<=right; i++){\\n            boolean flag = false;\\n            for(int j=0; j<n; j++){\\n                if(i>=arr[j][0] && i<=arr[j][1]){\\n                    flag = true;\\n                    break;\\n                }", "class Solution {\\n    public boolean isCovered(int[][] arr, int left, int right) {\\n        int n = arr.length;\\n\\n        for(int i=left; i<=right; i++){\\n            boolean flag = false;\\n            for(int j=0; j<n; j++){\\n                if(i>=arr[j][0] && i<=arr[j][1]){\\n                    flag = true;\\n                    break;\\n                }", "class Solution {\\n    public boolean isCovered(int[][] ranges, int left, int right) {\\n        boolean flag = false;\\n        for (int i=left; i<=right; i++) {\\n            for (int[] arr: ranges) {\\n                if (i >= arr[0] && i <= arr[1]) {\\n                    flag = true;\\n                    break;\\n                }"]}
{"id": "408", "ref_java": ["class Solution {\\n    public boolean makeEqual(String[] arr) {\\n        int n = arr.length;\\n\\n        int a[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            String s = arr[i];\\n            for(int j=0; j<s.length(); j++){\\n                char ch = s.charAt(j);\\n                a[ch-\\'a\\']++;\\n            }", "class Solution {\\n    public boolean makeEqual(String[] arr) {\\n        int n = arr.length;\\n\\n        int a[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            String s = arr[i];\\n            for(int j=0; j<s.length(); j++){\\n                char ch = s.charAt(j);\\n                a[ch-\\'a\\']++;\\n            }", "class Solution {\\n    public boolean makeEqual(String[] words) {\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words[i].length();j++){\\n                map.put(words[i].charAt(j),map.getOrDefault(words[i].charAt(j),0)+1);\\n            }"]}
{"id": "409", "ref_java": ["class Solution {\\n    public String largestOddNumber(String num) {\\n        if((int)num.charAt(num.length()-1)%2==1) return num;\\n        int i=num.length()-1;\\n        while(i>=0){\\n            int n=num.charAt(i);\\n            if(n%2==1) return num.substring(0,i+1);\\n            i--;\\n        }", "class Solution {\\n    public String largestOddNumber(String num) {\\n        for(int i=num.length()-1;i>-1;i--){\\n            if((num.charAt(i) - \\'0\\')%2!=0){\\n                return num.substring(0,i+1);\\n            }", "class Solution {\\n  public String largestOddNumber(String num) {\\n    for (var i = num.length() - 1; i >= 0; i--)\\n      if (Character.getNumericValue(num.charAt(i)) % 2 == 1)\\n        return num.substring(0, i+1);\\n    \\n    return \"\";\\n  }"]}
{"id": "410", "ref_java": ["class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int previous = nums[0];\\n        int temp = 0;\\n        for (int i = 1; i < nums.length; i++)\\n            if (nums[i] <= previous) {\\n                if (++temp == 2)\\n                    return false;\\n                if (i == 1 || nums[i] > nums[i - 2])\\n                    previous = nums[i];\\n            }", "class Solution {\\n    public boolean canBeIncreasing(int[] nums) {\\n        int count=0;\\n        int p=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]>nums[i+1] || nums[i]==nums[i+1]) {\\n                count++;\\n                p=i;\\n            }", "class Solution {\\n    public boolean canBeIncreasing(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<Integer>();\\n        int p=0;boolean flag=true;\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=0;j<arr.length;j++)\\n            {\\n                if(j==i)\\n                continue;\\n                else\\n                al.add(arr[j]);\\n\\n            }"]}
{"id": "411", "ref_java": ["class Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int firstBig = 0, secondBig = 0;\\r\\n        int firstSmall = Integer.MAX_VALUE, secondSmall = Integer.MAX_VALUE;\\r\\n\\r\\n        for (int n : nums) {\\r\\n            if (n < firstSmall) {\\r\\n                secondSmall = firstSmall;\\r\\n                firstSmall = n;\\r\\n            }", "class Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int firstBig = 0, secondBig = 0;\\r\\n        int firstSmall = Integer.MAX_VALUE, secondSmall = Integer.MAX_VALUE;\\r\\n\\r\\n        for (int n : nums) {\\r\\n            if (n < firstSmall) {\\r\\n                secondSmall = firstSmall;\\r\\n                firstSmall = n;\\r\\n            }", "class Solution {\\r\\n    public int maxProductDifference(int[] nums) {\\r\\n        int firstBig = 0, secondBig = 0;\\r\\n        int firstSmall = Integer.MAX_VALUE, secondSmall = Integer.MAX_VALUE;\\r\\n\\r\\n        for (int n : nums) {\\r\\n            if (n < firstSmall) {\\r\\n                secondSmall = firstSmall;\\r\\n                firstSmall = n;\\r\\n            }"]}
{"id": "412", "ref_java": ["class Solution {\\n    public int[] buildArray(int[] nums) {\\n        ", "class Solution {\\n\\n    ", "class Solution {\\n\\n    "]}
{"id": "413", "ref_java": ["class Solution {\\n   public int countTriples(int limit)\\n    {\\n        int result = 0;\\n        int x = (int)Math.sqrt(limit);\\n        for (int m = 2; m <= x; m++)\\n        {\\n            int mSquare = m * m;\\n            for (int n = 1; n < m; n++)\\n            {\\n                if (m % 2 + n % 2 == 1 && gcd(m, n) == 1)\\n                {\\n                    int c = mSquare + n * n;\\n                    if (c <= limit)\\n                    {\\n                        result += limit / c;\\n                    }", "class Solution {\\n    public int countTriples(int n) {\\n        int cnt = 0;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int a = 1;\\n            int b = 2;\\n            int c = i;\\n\\n            while (a != c && b != c && a != b) {\\n                if (a * a + b * b == c * c) {\\n                    cnt += 2;\\n                    a++; b++;\\n                }", "class Solution {\\n    public int countTriples(int n) {\\n        int c = 0;\\n        for(int i=1 ; i<=n ; i++){\\n            for(int j=i+1 ; j<=n ; j++){\\n                int sq = ( i * i) + ( j * j);\\n                int r = (int) Math.sqrt(sq);\\n                if( r*r == sq && r <= n )\\n                    c += 2;\\n            }"]}
{"id": "414", "ref_java": ["class Solution {\\n    public int[] getConcatenation(int[] nums) {\\n        int len = nums.length;\\n        int[] ans = new int[2*len];\\n        for(int i = 0; i < len; i++){\\n            ans[i] = nums[i];\\n            ans[i+len] = nums[i];\\n        }", "class Solution {\\n    public int[] getConcatenation(int[] nums) {\\n        int n=nums.length;\\n        int []c=new int[2*n];\\n        \\n        for(int i=0;i<2*n;i++){\\n            c[i]=nums[i%n];\\n        }", "class Solution {\\n    public int[] getConcatenation(int[] nums) {\\n        "]}
{"id": "415", "ref_java": ["class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String[] temp= text.split(\" \");\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int i=0;i<brokenLetters.length();i++){\\n            char c= brokenLetters.charAt(i);\\n            for(int j=0;j<temp.length;j++){\\n                \\n                if(temp[j].contains(Character.toString(c))) set.add(j);\\n            }", "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n   int c=0,ans=0;\\n  for(String s:text.split(\" \")){\\n        ArrayList<Character> aa=new ArrayList<>();\\n        c=0;\\n      for(char ch:s.toCharArray()){\\n         aa.add(ch);\\n      }", "class Solution {\\n    public int canBeTypedWords(String text, String brokenLetters) {\\n        String arr[] = text.split(\" \");\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<brokenLetters.length();j++){\\n                if(arr[i].contains(Character.toString(brokenLetters.charAt(j)))){\\n                    count++;\\n                    break;\\n                }"]}
{"id": "416", "ref_java": ["class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int countemp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                countemp++;\\n            }", "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        \\n        HashMap<Character,Integer>map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i),1);\\n            }", "class Solution {\\n    public boolean areOccurrencesEqual(String s) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int countemp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                countemp++;\\n            }"]}
{"id": "417", "ref_java": ["class Solution {\\n    public int getLucky(String s, int k) {\\n        int sum = 0;\\n        for (int i = 0; i < s.length(); i++) sum += sumOfDigits(s.charAt(i) - \\'a\\' + 1);\\n        while (--k > 0) sum = sumOfDigits(sum);\\n        return sum;\\n    }", "class Solution {\\n    public int getLucky(String s, int k) {\\n        int sum = 0;\\n        for (int i = 0; i < s.length(); i++) sum += sumOfDigits(s.charAt(i) - \\'a\\' + 1);\\n        while (--k > 0) sum = sumOfDigits(sum);\\n        return sum;\\n    }", "class Solution {\\n    public int getLucky(String s, int k) {\\n        String n = \"\";\\n        int num = 0;\\n        for(int i=0; i<s.length(); i++) n += s.charAt(i)-\\'a\\'+1 + \"\";\\n        while(k-- > 0){\\n            num = 0;\\n            for(char c: n.toCharArray()){\\n                num += Integer.parseInt(c + \"\");\\n            }"]}
{"id": "418", "ref_java": ["class Solution {\\n    public boolean isThree(int n) {\\n        int cnt = 0;\\n        for(int i=1; i<=n; i++){\\n            if(n%i==0) cnt++;\\n        }", "class Solution {\\n    public boolean isThree(int n) {\\n        int count=0;\\n        for(int i=1;i<=n/2;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                count++;\\n            }", "class Solution {\\n    public boolean isThree(int n) {\\n        int sqrt = (int) Math.sqrt(n);\\n        if (sqrt * sqrt != n)\\n            return false;\\n        int divisors = 1;\\n        for (int i = 1; i < sqrt; i++) {\\n            if (n % i == 0)\\n                divisors += 2;\\n        }"]}
{"id": "419", "ref_java": ["class Solution {\\n    public String makeFancyString(String s) {\\n        char prev = s.charAt (0);\\n        int freq = 1;\\n        StringBuilder res = new StringBuilder ();\\n        res.append (s.charAt (0));\\n        for (int i = 1; i < s.length (); i++) {\\n            if (s.charAt (i) == prev)\\n                freq++;\\n            else {\\n                prev = s.charAt (i);\\n                freq = 1;\\n            }", "class Solution {\\n    public String makeFancyString(String s) {\\n        char prev = s.charAt (0);\\n        int freq = 1;\\n        StringBuilder res = new StringBuilder ();\\n        res.append (s.charAt (0));\\n        for (int i = 1; i < s.length (); i++) {\\n            if (s.charAt (i) == prev)\\n                freq++;\\n            else {\\n                prev = s.charAt (i);\\n                freq = 1;\\n            }", "class Solution {\\n    public String makeFancyString(String s) {\\n        char prev = s.charAt (0);\\n        int freq = 1;\\n        StringBuilder res = new StringBuilder ();\\n        res.append (s.charAt (0));\\n        for (int i = 1; i < s.length (); i++) {\\n            if (s.charAt (i) == prev)\\n                freq++;\\n            else {\\n                prev = s.charAt (i);\\n                freq = 1;\\n            }"]}
{"id": "420", "ref_java": ["class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int count = 0;\\n        for(int i = 0; i<words.length;i++){\\n         if((s.length()-count)<words[i].length())return false;\\n            for(int j = 0 ;j<words[i].length();j++){\\n                if(s.charAt(count++)!=words[i].charAt(j))return false;\\n                if(count==s.length()) return true;\\n            }", "class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int length = s.length();\\n        int arrLength = words.length;\\n        int index = 0;\\n        for (int i = 0; i < arrLength && index < length; i++) {\\n            String word = words[i];\\n            int wordLength = word.length();\\n            int j = 0;\\n            while (j < wordLength && index < length) {\\n                if (s.charAt(index) == word.charAt(j)) {\\n                    index++;\\n                    j++;\\n                }", "class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }"]}
{"id": "422", "ref_java": ["class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n         int count = 0;\\n\\n        for (String pattern : patterns) {\\n            if (word.contains(pattern)) {\\n                count++;\\n            }", "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String s:patterns){\\n            boolean flag = word.contains(s);\\n            if(flag) count++;\\n        }", "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String s:patterns){\\n            boolean flag = word.contains(s);\\n            if(flag) count++;\\n        }"]}
{"id": "423", "ref_java": ["class Solution {\\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\\n        if(source == destination){\\n            return true;\\n        }", "class Solution {\\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\\n        if(source == destination) return true;\\n        HashMap<Integer, ArrayList<Integer>> adjList = new HashMap<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        Stack<Integer> stack = new Stack<>();\\n        ArrayList<Integer> al;\\n\\n       ", "class Solution {\\n    public boolean fun(HashMap<Integer,List<Integer>> map,boolean[] arr,int sur,int dest)\\n    {\\n        if(sur==dest)\\n        return true;\\n        arr[sur]=true;\\n       \\n        List<Integer> list = map.get(sur);\\n       "]}
{"id": "424", "ref_java": ["class Solution {\\n    public int minTimeToType(String word) {\\n        char prevChar = \\'a\\';\\n        int totalTime = word.length();\\n        for(int i = 0; i < word.length(); i++){\\n            char currChar = word.charAt(i);\\n            int diff = Math.abs(currChar - prevChar);\\n            totalTime += Math.min(diff, 26 - diff);\\n            prevChar = currChar;\\n        }", "class Solution {\\n    public int minTimeToType(String word) {\\n        char prevChar = \\'a\\';\\n        int totalTime = word.length();\\n        for(int i = 0; i < word.length(); i++){\\n            char currChar = word.charAt(i);\\n            int diff = Math.abs(currChar - prevChar);\\n            totalTime += Math.min(diff, 26 - diff);\\n            prevChar = currChar;\\n        }", "class Solution {\\n    public int minTimeToType(String word) \\n    {\\n        int count=0;\\n        int len=word.length();\\n        char prev=\\'a\\';\\n        for(int i=0;i<len;i++)\\n        {\\n            int p=prev;\\n            int c=word.charAt(i);\\n            \\n            int diff = Math.abs(p-c);\\n            \\n            if(diff==0)\\n            {\\n                count++;\\n            }"]}
{"id": "426", "ref_java": ["class Solution {\\n    public int findGCD(int[] nums) {\\n      Arrays.sort(nums);\\n      int n1=nums[0];\\n      int n2=nums[nums.length-1];\\n      int large=n1;\\n      for(int i=1;i<=n2;i++){\\n          if(n1%i==0 && n2%i==0){\\n              large=i;\\n              }", "class Solution {\\n    public int findGCD(int[] nums) {\\n        Arrays.sort(nums);\\n        int GCD = 1;\\n        for(int i = 1; i <= nums[0]; i++) {\\n            if(nums[0] % i == 0 && nums[nums.length - 1] % i == 0) {\\n                GCD = i;\\n            }", "class Solution {\\n    public int findGCD(int[] nums) {\\n        Arrays.sort(nums);\\n        int GCD = Math.min(nums[0], nums[nums.length - 1]);\\n        while(GCD > 0) {\\n            if (nums[0] % GCD == 0 && nums[nums.length - 1] % GCD == 0) {\\n                break;\\n            }"]}
{"id": "427", "ref_java": ["class Solution {\\n    public int minimumDifference(int[] nums, int k) {\\n        ", "class Solution {\\n    public int minimumDifference(int[] nums, int k) {\\n        if (k == 1) return 0;\\n\\n        Arrays.sort(nums);\\n\\t\\t\\n        int i = 0, j = k - 1, \\n        min = Integer.MAX_VALUE;\\n\\n        while (j < nums.length) {\\n            min = Math.min(min, nums[j++] - nums[i++]);\\n        }", "class Solution {\\n    public int minimumDifference(int[] nums, int k) {\\n        if (k == 1) return 0;\\n\\n        Arrays.sort(nums);\\n\\t\\t\\n        int i = 0, j = k - 1, \\n        min = Integer.MAX_VALUE;\\n\\n        while (j < nums.length) {\\n            min = Math.min(min, nums[j++] - nums[i++]);\\n        }"]}
{"id": "428", "ref_java": ["class Solution {\\n    public int findMiddleIndex(int[] nums) {\\n        int lsum[] = new int[nums.length]; ", "class Solution {\\n    public int pivotIndex(int[] nums) {\\n```\\n2. It creates an array prefixSum to store the cumulative sum of elements from the beginning of the array nums. The first element of prefixSum is set equal to the first element of nums.\\n```\\n        int prefixSum[] = new int[n];\\n        prefixSum[0] = nums[0];\\n```\\n3. Similarly, it creates an array suffixSum to store the cumulative sum of elements from the end of the array nums. The last element of suffixSum is set equal to the last element of nums.\\n```\\n        int suffixSum[] = new int[n];\\n        suffixSum[n-1] = nums[n-1];\\n```\\n4. It then calculates the cumulative sums for the remaining elements of prefixSum and suffixSum using a loop. prefixSum[i] is calculated as the sum of prefixSum[i-1] and nums[i], and suffixSum[n-1-i] is calculated as the sum of suffixSum[n-i] and nums[n-1-i].\\n```\\n        for(int i = 1; i < n; i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n            suffixSum[n-1-i] = suffixSum[n-i] + nums[n-1-i];\\n        }", "class Solution {\\n    public int findMiddleIndex(int[] arr) {\\n        int totalSum=0;\\n        for(int i:arr){\\n            totalSum+=i;\\n        }"]}
{"id": "429", "ref_java": ["class Solution {\\n    public int countQuadruplets(int[] nums) {\\n        int res = 0;\\n        int len = nums.length;\\n        \\n        Map<Integer, Integer> count = new HashMap<>();\\n        count.put(nums[len-1] - nums[len-2], 1);\\n        \\n        for (int b = len - 3; b >= 1; b--) {\\n            for (int a = b - 1; a >= 0; a--) {\\n                res += count.getOrDefault(nums[a] + nums[b], 0);\\n            }", "class Solution {\\n    public int countQuadruplets(int[] nums) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                for(int k=j+1;k<nums.length-1;k++){\\n                    for(int l=k+1;l<nums.length;l++){\\n                        if(nums[i]+nums[j]+nums[k]==nums[l]){\\n                            cnt++;\\n                        }", "class Solution {\\n    public int countQuadruplets(int[] nums) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                for(int k=j+1;k<nums.length-1;k++){\\n                    for(int l=k+1;l<nums.length;l++){\\n                        if(nums[i]+nums[j]+nums[k]==nums[l]){\\n                            cnt++;\\n                        }"]}
{"id": "430", "ref_java": ["class Solution {\\n    public String reversePrefix(String word, char ch) {\\n        ", "class Solution {\\n    public String reversePrefix(String word, char ch) {\\n        \\n        int ind = word.indexOf(ch);\\n        String s = word.substring(0, ind + 1);\\n        StringBuilder sb = new StringBuilder(s);\\n        s = sb.reverse().toString() + word.substring(ind + 1, word.length());\\n        return s;\\n    }", "class Solution {\\n    public String reversePrefix(String word, char ch) {\\n        int x=0;\\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)==ch){\\n                x=i;\\n                break;\\n            }"]}
{"id": "431", "ref_java": ["class Solution {\\n    public int countKDifference(int[] nums, int k) {\\n        int count=0;\\n        HashMap <Integer, Integer> hm = new HashMap<>();\\n        for(int i: nums)\\n        {\\n            count += hm.getOrDefault(i-k , 0);\\n            count += hm.getOrDefault(i+k,0);\\n\\n            hm.put(i, hm.getOrDefault(i,0)+1);\\n        }", "class Solution {\\n    public int countKDifference(int[] nums, int k) {\\n       int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (Math.abs(nums[i] - nums[j]) == k) {\\n                    ans++;\\n                }", "class Solution {\\n    public int countKDifference(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        \\n        for(int i = 0;i< nums.length;i++){\\n            if(map.containsKey(nums[i]-k)){\\n                res+= map.get(nums[i]-k);\\n            }"]}
{"id": "432", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int finalValueAfterOperations(String[] operations) {\\n        int x = 0;\\n        for(String o : operations) x += (44 - o.charAt(1));\\n        return x;\\n    }", "class Solution {\\n    public int finalValueAfterOperations(String[] operations) {\\n        int cnt =0;\\n        for(String s : operations){\\n            if(s.charAt(0)==\\'+\\' || s.charAt(2)==\\'+\\') cnt++;\\n            else cnt--;\\n        }"]}
{"id": "433", "ref_java": ["class Solution {\\n    public int maximumDifference(int[] nums) {\\n        int ans=-1;\\n        int max = nums[nums.length-1];\\n\\n        for(int i=nums.length-2; i>=0; i--){\\n            max = Math.max(max, nums[i]);\\n            if(max <= nums[i]) continue;\\n            int dif = max-nums[i];\\n            ans = Math.max(ans, dif);\\n            \\n        }", "class Solution {\\n    public int maximumDifference(int[] arr) {\\n        int arr_size=arr.length;\\n        int max_diff = arr[1] - arr[0];\\n\\t\\tint min_element = arr[0];\\n\\t\\tint i;\\n\\t\\tfor (i = 1; i < arr_size; i++)\\n\\t\\t{\\n\\t\\t\\tif (arr[i] - min_element > max_diff)\\n\\t\\t\\t\\tmax_diff = arr[i] - min_element;\\n\\t\\t\\tif (arr[i] < min_element)\\n\\t\\t\\t\\tmin_element = arr[i];\\n\\t\\t}", "class Solution {\\n    public int maximumDifference(int[] arr) {\\n        int arr_size=arr.length;\\n        int max_diff = arr[1] - arr[0];\\n\\t\\tint min_element = arr[0];\\n\\t\\tint i;\\n\\t\\tfor (i = 1; i < arr_size; i++)\\n\\t\\t{\\n\\t\\t\\tif (arr[i] - min_element > max_diff)\\n\\t\\t\\t\\tmax_diff = arr[i] - min_element;\\n\\t\\t\\tif (arr[i] < min_element)\\n\\t\\t\\t\\tmin_element = arr[i];\\n\\t\\t}"]}
{"id": "434", "ref_java": ["class Solution {\\n    public int[][] construct2DArray(int[] original, int m, int n) {\\n        int result[][];\\n        result = new int[m][n];\\n         if (original.length != m * n) {\\n            return new int[0][0];\\n        }", "class Solution {\\n    public int[][] construct2DArray(int[] original, int m, int n) {\\n        if (m * n != original.length) {\\n            return new int[0][0];\\n        }", "class Solution {\\n    public int[][] construct2DArray(int[] original, int m, int n) {\\n        if (original.length != m*n) return new int[0][0];\\n        int ans[][] = new int[m][n];\\n        for (int i = 0; i < original.length; ++i){\\n            ans[i / n][i % n] = original[i];\\n        }"]}
{"id": "435", "ref_java": ["class Solution {\\n    public int minimumMoves(String s) {\\n        int i=0;\\n        int step=0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==\\'X\\'){\\n                i=i+3;\\n                step++;\\n            }", "class Solution {\\n    public int minimumMoves(String s) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < s.length();) {            \\n            if (s.charAt(i) == \\'X\\') {\\n                count++;\\n                i += 3;\\n            }", "class Solution {\\n    public int minimumMoves(String s) {\\n        int i=0,step=0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==\\'X\\'){\\n                i=i+3;\\n                step++;\\n            }"]}
{"id": "436", "ref_java": ["class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        int temp1[]=new int[101] , temp2[]=new int[101] , temp3[]=new int[101];\\n        int max=Math.max(nums1.length,nums2.length);  int tMax=Math.max(max,nums3.length);\\n        int count1=0,count2=0,count3=0;\\n\\n        for(int i=0;i<tMax;i++){\\n            if(count1<nums1.length){\\n                temp1[nums1[i]]++;  count1++;\\n            }", "class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n        boolean[] b1 = new boolean[101];\\n        boolean[] b2 = new boolean[101];\\n        boolean[] b3 = new boolean[101];\\n        for (int i : nums1) b1[i] = true;\\n        for (int i : nums2) b2[i] = true;\\n        for (int i : nums3) b3[i] = true;\\n\\n        List<Integer> result = new ArrayList<>();\\n\\n        for (int i = 1; i < 101; i++) {\\n            boolean first = b1[i] && b2[i];\\n            boolean second = b2[i] && b3[i];\\n            boolean third = b1[i] && b3[i];\\n            if (first || second || third)\\n                result.add(i);\\n        }", "class Solution {\\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\\n\\n        \\n        boolean[] b1 = new boolean[101];\\n        boolean[] b2 = new boolean[101];\\n        boolean[] b3 = new boolean[101];\\n\\n        \\n        for (int num : nums1) b1[num] = true;\\n\\n        for (int num : nums2) b2[num] = true;\\n\\n        for (int num : nums3) b3[num] = true;\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n\\n        for (int i = 1; i <= 100; i++){\\n            if((b1[i] || b2[i]) && (b2[i] || b3[i]) && (b3[i] || b1[i]))\\n                res.add(i);\\n        }"]}
{"id": "437", "ref_java": ["class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int n=seats.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum += Math.abs(seats[i]-students[i]);\\n        }", "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        int moves = 0;\\n\\n        for(int i=0; i<seats.length; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }", "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(students);\\n        Arrays.sort(seats);\\n        int sum = 0;\\n        for(int i = 0; i < seats.length; i++) {\\n            sum += Math.abs(seats[i] - students[i]);\\n        }"]}
{"id": "438", "ref_java": ["class Solution {\\n    public boolean areNumbersAscending(String s) {\\n        List<Integer> ls= new ArrayList<>();\\n\\n        ", "class Solution {\\n    public boolean areNumbersAscending(String s) {\\n        String num = s.replaceAll(\"([a-z])\",\" \").replaceAll(\"( )+\",\" \").trim(); \\n        String[]str = num.split(\" \");\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<str.length;i++)\\n        {\\n            list.add(Integer.parseInt(str[i]));\\n        }", "class Solution {\\n    public boolean areNumbersAscending(String s) {\\n        int prev = 0;\\n        \\n        for(String token: s.split(\" \")) {\\n            try {\\n                int number = Integer.parseInt(token);\\n                if(number <= prev)\\n                    return false;\\n                prev = number;\\n            }"]}
{"id": "439", "ref_java": ["class Solution {\\n    public int countValidWords(String sentence) {\\n        String regex = \"^([a-z]+(-?[a-z]+)?)?(!|\\\\\\\\.|,)?$\";\\n        String r2 = \"[^0-9]+\";\\n        String[] arr = sentence.split(\"\\\\\\\\s+\");\\n        int ans = 0;\\n        for(String s: arr)\\n        {\\n            if(s.matches(regex) && s.matches(r2))\\n            {\\n                ans++;\\n                ", "class Solution {\\n    public int countValidWords(String sentence) {\\n        int cnt=0;\\n\\n        ", "class Solution {\\n    public int countValidWords(String sentence) {\\n        String regex = \"^([a-z]+(-?[a-z]+)?)?(!|\\\\\\\\.|,)?$\";\\n        String r2 = \"[^0-9]+\";\\n        String[] arr = sentence.split(\"\\\\\\\\s+\");\\n        int ans = 0;\\n        for(String s: arr)\\n        {\\n            if(s.matches(regex) && s.matches(r2))\\n            {\\n                ans++;\\n                "]}
{"id": "440", "ref_java": ["class Solution {\\n    public String kthDistinct(String[] arr, int k) {\\n        Map<String, Boolean> map = new HashMap<>();\\n        for (String s : arr) {\\n            Boolean i = map.get(s);\\n            if (i != null)\\n                map.put(s, false);\\n            else\\n                map.put(s, true);\\n        }", "class Solution {\\n    public String kthDistinct(String[] arr, int k) {\\n        HashMap<String, Integer> map= new HashMap<>();\\n\\n        for(String s: arr) map.put(s, map.getOrDefault(s,0)+1);\\n\\n        List<String> ls= new ArrayList<>(); \\n        for(String s: arr) if(map.get(s)==1) ls.add(s);\\n\\n        if(ls.size()>=k) return ls.get(k-1);\\n\\n        return \"\";\\n    }", "class Solution {\\n    public String kthDistinct(String[] arr, int k) {\\n        HashMap<String,Integer>hm= new HashMap<String,Integer>();\\n       \\n       for(int i=0;i<arr.length;i++)\\n        {\\n           if(hm.containsKey(arr[i]))\\n           hm.put(arr[i],hm.get(arr[i])+1);\\n           else\\n           hm.put(arr[i],1);\\n        }"]}
{"id": "441", "ref_java": ["class Solution {\\n    public int smallestEqual(int[] nums) {\\n        for (int i = 0; i < nums.length; i++)if (i % 10 == nums[i]) return i;\\n        return -1;\\n    }", "class Solution {\\n    public int smallestEqual(int[] nums) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (i % 10 == nums[i])\\n                return i;\\n        return -1;\\n    }", "class Solution {\\n    public int smallestEqual(int[] nums) {\\n        int ans = 0;\\n        int temp = 0;\\n        int n = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(i%10 == nums[i]){\\n                temp = i;\\n\\n                if(n == 0){\\n                    ans = i;\\n                    n++;\\n                }"]}
{"id": "442", "ref_java": ["class Solution {\\n    public int countVowelSubstrings(String word) {\\n        int out=0;\\n         for (int i=0;i<word.length();i++){\\n             Set<Character>st=new HashSet<>();\\n             for (int j=i;j<word.length();j++){\\n                 if (!isVowel(word.charAt(j)))break;\\n                 st.add(word.charAt(j));\\n                 if (st.size()==5)out++;\\n             }", "class Solution {\\n    public int countVowelSubstrings(String word) {\\n        int out=0;\\n         for (int i=0;i<word.length();i++){\\n             Set<Character>st=new HashSet<>();\\n             for (int j=i;j<word.length();j++){\\n                 if (!isVowel(word.charAt(j)))break;\\n                 st.add(word.charAt(j));\\n                 if (st.size()==5)out++;\\n             }", "class Solution {\\n    public int countVowelSubstrings(String word) {\\n        int countSubs = 0;\\n        byte[] vowels = new byte[5];\\n        for (int i = 0; i < word.length(); i++) {\\n            int count = i;\\n            while (count < word.length() && isVowel(word.charAt(count))) {\\n                char c = word.charAt(count);\\n                switch (c) {\\n                    case \\'a\\':\\n                        vowels[0]++;\\n                        break;\\n                    case \\'e\\':\\n                        vowels[1]++;\\n                        break;\\n                    case \\'i\\':\\n                        vowels[2]++;\\n                        break;\\n                    case \\'o\\':\\n                        vowels[3]++;\\n                        break;\\n                    case \\'u\\':\\n                        vowels[4]++;\\n                        break;\\n                }"]}
{"id": "443", "ref_java": ["class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character, Integer> map1= new HashMap<>();\\n        HashMap<Character, Integer> map2 =new HashMap<>();\\n        int n= word1.length();\\n        \\n        for(int i=0;i<n;i++){\\n            char c=word1.charAt(i);\\n            char d=word2.charAt(i);\\n            map1.put(c,map1.getOrDefault(c,0)+1);\\n            map2.put(d, map2.getOrDefault(d,0)+1);   \\n        }", "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        HashMap<Character, Integer> freqMap1 = new HashMap<>();\\n        HashMap<Character, Integer> freqMap2 = new HashMap<>();\\n\\n        ", "class Solution { \\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character,Integer> map = new HashMap();\\n        for (int i = 0; i < word1.length(); i++) {\\n            map.put(word1.charAt(i), map.getOrDefault(word1.charAt(i), 0) + 1);\\n            map.put(word2.charAt(i), map.getOrDefault(word2.charAt(i), 0) - 1);\\n        }"]}
{"id": "444", "ref_java": ["class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        while(tickets[k] != 0){\\n            for(int i = 0 ; i < tickets.length ; i++){\\n                if(tickets[i] != 0 && tickets[k] != 0){\\n                    tickets[i] -= 1;\\n                    time += 1;\\n                }", "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }", "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        while(tickets[k] != 0){\\n            for(int i = 0 ; i < tickets.length ; i++){\\n                if(tickets[i] != 0 && tickets[k] != 0){\\n                    tickets[i] -= 1;\\n                    time += 1;\\n                }"]}
{"id": "445", "ref_java": ["class Solution {\\n    public int maxDistance(int[] colors) {\\n        int first = colors[0];\\n        int index = 0;\\n        for(int a = 1; a < colors.length; a++){\\n            if(colors[a] != first) index = a;\\n        }", "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int start = 0, end = colors.length - 1, hold = start, ret = 0;\\n        while(hold<colors.length){\\n            if(colors[start]!=colors[hold]){\\n                ret =Math.max(Math.max(ret, hold - start), Math.max(ret, end - hold));\\n            }", "class Solution {\\n    public int maxDistance(int[] colors) {\\n        \\n        int dist = 0;\\n        \\n        for(int i = 0;i<colors.length;i++){\\n            for(int j = colors.length-1;j>=0;j--){\\n                if(colors[i] != colors[j]){\\n                    dist = Math.max(j - i,dist);\\n                }"]}
{"id": "447", "ref_java": ["class Solution {\\n    public int countWords(String[] words1, String[] words2) {\\n        HashMap<String,Integer> hm1 = new HashMap<>();\\n        HashMap<String,Integer> hm2 = new HashMap<>();\\n        int numOfWords = 0;\\n\\n        for(int i=0;i<words1.length;i++) {\\n            if(hm1.containsKey(words1[i])) {\\n                hm1.put(words1[i],hm1.get(words1[i])+1);\\n            }", "class Solution {\\n    \\n    public int countWords(String[] words1, String[] words2) {\\n\\n\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        HashMap<String,Integer> hm2=new HashMap<>();\\n        int out=0;\\n        for(String s:words1)\\n            hm.put(s, hm.getOrDefault(s, 0)+1);\\n        for(String s:words2)\\n            hm2.put(s,hm2.getOrDefault(s, 0)+1);\\n        \\n        for(HashMap.Entry<String,Integer> i:hm.entrySet()){\\n            if(i.getValue()==1 && hm2.getOrDefault(i.getKey(), 0)==1)out++;\\n        }", "class Solution {\\n    \\n    public int countWords(String[] words1, String[] words2) {\\n\\n\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        HashMap<String,Integer> hm2=new HashMap<>();\\n        int out=0;\\n        for(String s:words1)\\n            hm.put(s, hm.getOrDefault(s, 0)+1);\\n        for(String s:words2)\\n            hm2.put(s,hm2.getOrDefault(s, 0)+1);\\n        \\n        for(HashMap.Entry<String,Integer> i:hm.entrySet()){\\n            if(i.getValue()==1 && hm2.getOrDefault(i.getKey(), 0)==1)out++;\\n        }"]}
{"id": "448", "ref_java": ["class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        int i=0;\\n        for(i=0;i<nums.length;i++) {\\n          if(nums[i] == target) {\\n            ans.add(i);\\n          }", "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int countTarget = 0 , lessTarget = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<target) lessTarget++;\\n            if(nums[i]==target) countTarget++;\\n        }", "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int countTarget = 0, lessTarget = 0;\\n        for (int num : nums) {\\n            if (num < target) lessTarget++;\\n            if (num == target) countTarget++;\\n        }"]}
{"id": "449", "ref_java": ["class Solution {\\n    public int[] findEvenNumbers(int[] digits) {\\n        int [] map = new int[10]; ", "class Solution {\\n    public int[] findEvenNumbers(int[] digits) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] count = new int[10];\\n        for(int val: digits) count[val]++;\\n        \\n        \\n        for(int first=1;first<=9;first++){\\n            count[first]--;\\n            for(int second=0;second<=9;second++){\\n                count[second]--;\\n                for(int third=0;third<=8;third+=2){\\n                    count[third]--;\\n                    \\n                    if(count[first]>=0 && count[second]>=0 && count[third]>=0)\\n                        list.add(first*100+second*10+third);\\n                    \\n                    count[third]++;\\n                }", "class Solution {\\n    public int[] findEvenNumbers(int[] digits) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] count = new int[10];\\n        for(int val: digits) count[val]++;\\n        \\n        \\n        for(int first=1;first<=9;first++){\\n            count[first]--;\\n            for(int second=0;second<=9;second++){\\n                count[second]--;\\n                for(int third=0;third<=8;third+=2){\\n                    count[third]--;\\n                    \\n                    if(count[first]>=0 && count[second]>=0 && count[third]>=0)\\n                        list.add(first*100+second*10+third);\\n                    \\n                    count[third]++;\\n                }"]}
{"id": "450", "ref_java": ["\npublic int[] maxSubsequence(int[] nums, int k) {\n        int n = nums.length;\n        int[][] indexAndVal = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            indexAndVal[i] = new int[]{i, nums[i]};\n        }\n        \n        Arrays.sort(indexAndVal, Comparator.comparingInt(a -> -a[1]));\n        int[][] maxK = Arrays.copyOf(indexAndVal, k);\n        \n        Arrays.sort(maxK, Comparator.comparingInt(a -> a[0]));\n        int[] seq = new int[k];\n        for (int i = 0; i < k; ++i) {\n            seq[i] = maxK[i][1];\n        }\n        return seq;\n    }\n", "\npublic int[] maxSubsequence(int[] nums, int k) {\n        int n = nums.length;\n        int[][] indexAndVal = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            indexAndVal[i] = new int[]{i, nums[i]};\n        }\n        \n        Arrays.sort(indexAndVal, Comparator.comparingInt(a -> -a[1]));\n        int[][] maxK = Arrays.copyOf(indexAndVal, k);\n        \n        Arrays.sort(maxK, Comparator.comparingInt(a -> a[0]));\n        int[] seq = new int[k];\n        for (int i = 0; i < k; ++i) {\n            seq[i] = maxK[i][1];\n        }\n        return seq;\n    }\n", "\npublic int[] maxSubsequence(int[] nums, int k) {\n        int n = nums.length;\n        int[][] indexAndVal = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            indexAndVal[i] = new int[]{i, nums[i]};\n        }\n        \n        Arrays.sort(indexAndVal, Comparator.comparingInt(a -> -a[1]));\n        int[][] maxK = Arrays.copyOf(indexAndVal, k);\n        \n        Arrays.sort(maxK, Comparator.comparingInt(a -> a[0]));\n        int[] seq = new int[k];\n        for (int i = 0; i < k; ++i) {\n            seq[i] = maxK[i][1];\n        }\n        return seq;\n    }\n"]}
{"id": "451", "ref_java": ["class Solution {\\n\\n    public int countPoints(String rings) {\\n        int r[] = new int[10];\\n        int g[] = new int[10];\\n        int b[] = new int[10];\\n        \\n        int n = rings.length();\\n        \\n        for(int i=0; i<n; i+=2){\\n            \\n            ", "class Solution {\\n    public int countPoints(String rings) {\\n        int[][] arr = new int[10][3];\\n        for(int i = 1;i<rings.length();i+= 2){\\n            char a = rings.charAt(i-1);\\n            int b = rings.charAt(i) - \\'0\\';\\n            int j = 2;\\n            if(a == \\'R\\')\\n                j = 0;\\n            else if(a == \\'G\\')\\n                j = 1;\\n            arr[b][j] = 1;\\n        }", "class Solution {\\n    public int countPoints(String rings) {\\n        int[][] arr = new int[10][3];\\n        for(int i = 1;i<rings.length();i+= 2){\\n            char a = rings.charAt(i-1);\\n            int b = rings.charAt(i) - \\'0\\';\\n            int j = 2;\\n            if(a == \\'R\\')\\n                j = 0;\\n            else if(a == \\'G\\')\\n                j = 1;\\n            arr[b][j] = 1;\\n        }"]}
{"id": "452", "ref_java": ["class Solution {\\n    public boolean isPalindromic(String a){\\n        if(a.charAt(0)!= a.charAt(a.length()-1)){\\n            return false;\\n        }", "class Solution {\\n    public String firstPalindrome(String[] words) {\\n        \\n        for(String s1:words)\\n        {\\n            if(palindron(s1)) return s1;\\n        }", "class Solution {\\n    public String firstPalindrome(String[] words) {\\n        for(int i=0;i<words.length;i++){\\n        if(isp(words[i]))\\n        return words[i];\\n        }"]}
{"id": "453", "ref_java": ["class Solution {\\n    public int mostWordsFound(String[] sentences) {\\n        int maxLen = 0;\\n\\t\\t\\n        for (String currSent : sentences) {\\n            int currLen = currSent.split(\" \").length;\\n            if (maxLen < currLen)\\n                maxLen = currLen;\\n        }", "class Solution {\\n    public int mostWordsFound(String[] sentences) {\\n        int maxWords = 0;\\n        ", "class Solution {\\n        public int mostWordsFound(String[] sentences) {\\n           int max = Integer.MIN_VALUE;\\n        for(int i=0;i<sentences.length;i++){\\n            String arr[] = sentences[i].split(\" \");\\n            if (max<arr.length){\\n                max=arr.length;\\n            }"]}
{"id": "454", "ref_java": ["class Solution {\\n    public boolean isSameAfterReversals(int num) {\\n        int num1 = num;\\n        int res = 0;\\n\\n        while(num1 > 0){\\n            int r = num1 % 10;\\n            res = res * 10 + r;\\n            num1 = num1 / 10;\\n        }", "class Solution {\\n    public boolean isSameAfterReversals(int num) \\n    {\\n        int n=num,ans=0;\\n        while(n!=0)\\n        {\\n            int l=n%10;\\n            ans=(ans*10)+l;\\n            n=n/10;\\n        }", "class Solution {\\n    public boolean isSameAfterReversals(int num) {\\n        int n=num;\\n        int reverse=0;\\n        while(num!=0)\\n        {\\n            int l=num%10;\\n            num/=10;\\n            reverse*=10;\\n            reverse+=l;\\n        }"]}
{"id": "455", "ref_java": ["class Solution {\\n    public boolean checkString(String s) {\\n        int a=-1;\\n        int b=-1;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i)==\\'a\\') {\\n                a=i;\\n            }", "class Solution {\\n    public boolean checkString(String s) {\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'b\\'&&s.charAt(i+1)==\\'a\\')\\n            return false;\\n        }", "class Solution {\\n    public boolean checkString(String s) {\\n        int ans = 1;\\n        for(int i=0; i<s.length()-1; i++){\\n            if(s.charAt(i) == \\'b\\' && s.charAt(i+1) == \\'a\\'){\\n                ans = 0;\\n            }"]}
{"id": "456", "ref_java": ["class Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder str = new StringBuilder();\\n        String[] arr = title.split(\" \");\\n        for (String s : arr)\\n        {\\n            if (s.length() <= 2 ) {\\n                str.append(s.toLowerCase() + \" \");\\n            }", "class Solution {\\n    public String capitalizeTitle(String title) {\\n       String[] splitedTitle = title.split(\" \");\\n        String result = \"\";\\n\\n        for (int i = 0; i < splitedTitle.length; i++) {\\n            splitedTitle[i] = splitedTitle[i].toLowerCase();\\n            \\n            if (splitedTitle[i].length() <= 2) {\\n                result += splitedTitle[i] + \" \";\\n                continue;\\n            }", "class Solution {\\n\\t\\tpublic String capitalizeTitle(String title) {\\n\\n\\t\\t\\tchar[] ch = title.toCharArray();\\n\\t\\t\\tint len = ch.length;\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; "]}
{"id": "457", "ref_java": ["class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++){\\n            HashMap<Integer, Integer>hm= new HashMap<>();\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(hm.containsKey(matrix[i][j])){\\n                    return false;\\n                }", "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for(int i = 0 ; i < n; i ++){\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n            for(int j = 0 ; j < n ; j ++){\\n                hs.add(matrix[i][j]);\\n            }", "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++){\\n            HashMap<Integer, Integer>hm= new HashMap<>();\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(hm.containsKey(matrix[i][j])){\\n                    return false;\\n                }"]}
{"id": "458", "ref_java": ["class Solution {\\n    public String[] divideString(String s, int k, char fill) {\\n        \\n        if(s.length()%k!=0){\\n            int c2=k;\\n            int hm=0;\\n            for(int i=0;i<s.length();i+=k){\\n                if(i>hm){\\n                    hm=i;\\n                }", "class Solution {\\n    public String[] divideString(String s, int k, char fill) {\\n        \\n        if(s.length()%k!=0){\\n            int c2=k;\\n            int hm=0;\\n            for(int i=0;i<s.length();i+=k){\\n                if(i>hm){\\n                    hm=i;\\n                }", "class Solution {\\n    public String[] divideString(String s, int k, char fill) {\\n        \\n        if(s.length()%k!=0){\\n            int c2=k;\\n            int hm=0;\\n            for(int i=0;i<s.length();i+=k){\\n                if(i>hm){\\n                    hm=i;\\n                }"]}
{"id": "459", "ref_java": ["class Solution {\\n    public int minimumCost(int[] cost) {\\n        int n = cost.length;\\n\\n        int[] freq = new int[101];\\n        for (int i = 0; i < n; i++)\\n        {\\n            freq[cost[i]]++;\\n        }", "class Solution {\\n    public int minimumCost(int[] cost) {\\n        int n = cost.length;\\n\\n        int[] freq = new int[101];\\n        for (int i = 0; i < n; i++)\\n        {\\n            freq[cost[i]]++;\\n        }", "class Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int count=1;\\n        int sum=0;\\n        for(int i=cost.length-1;i>=0;i--)\\n        {\\n            if(count%3==0)\\n            {\\n                sum+=0;\\n            }"]}
{"id": "460", "ref_java": ["class Solution {\\n    public int countElements(int[] nums) {\\n        int count =0;\\n        Arrays.sort(nums);\\n        int l = nums[0];\\n        int r = nums[nums.length-1];\\n        for(int i=1 ; i< nums.length -1 ; i++){\\n          if(nums[i] >l && nums[i]<r){\\n              count++;\\n          }", "class Solution {\\n    public int countElements(int[] nums) {\\n        Arrays.sort(nums);\\n        int count =0;\\n        int count1 =0;\\n        int a = nums[0];\\n        int b = nums[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(a==nums[i]){\\n                count++;\\n            }", "class Solution {\\n    public int countElements(int[] nums) {\\n\\t\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n\\t\\t\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }"]}
{"id": "461", "ref_java": ["class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int count = 0;\\n        while (count != nums.length){\\n            if (nums[count++] == original){\\n                original*=2;\\n                count = 0;\\n            }", "class Solution {\\n    public boolean isFound(int[] nums,int original){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                return true;\\n            }", "class Solution {\\n    public boolean isFound(int[] nums,int original){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                return true;\\n            }"]}
{"id": "462", "ref_java": ["\nclass Solution\n{\n    public int minimumSum(int num)\n    {\n        int[] dig = new int[4]; \n        int cur = 0;\n        while(num > 0) \n        {\n            dig[cur++] = num % 10;\n            num /= 10;\n        }\n        Arrays.sort(dig); \n        int num1 = dig[0] * 10 + dig[2]; \n        int num2 = dig[1] * 10 + dig[3]; \n        return num1 + num2;\n    }\n}\n", "\nclass Solution\n{\n    public int minimumSum(int num)\n    {\n        int[] dig = new int[4]; \n        int cur = 0;\n        while(num > 0) \n        {\n            dig[cur++] = num % 10;\n            num /= 10;\n        }\n        Arrays.sort(dig); \n        int num1 = dig[0] * 10 + dig[2]; \n        int num2 = dig[1] * 10 + dig[3]; \n        return num1 + num2;\n    }\n}\n", "\nclass Solution\n{\n    public int minimumSum(int num)\n    {\n        int[] dig = new int[4]; \n        int cur = 0;\n        while(num > 0) \n        {\n            dig[cur++] = num % 10;\n            num /= 10;\n        }\n        Arrays.sort(dig); \n        int num1 = dig[0] * 10 + dig[2]; \n        int num2 = dig[1] * 10 + dig[3]; \n        return num1 + num2;\n    }\n}\n"]}
{"id": "463", "ref_java": ["class Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }", "class Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        int n =nums.length;\\n        int[] even = new int[(n+1)/2];\\n        int[] odd = new int[n/2];\\n        int iE=0;\\n        int iO =0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                even[iE++] = nums[i];\\n            }", "class Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        int[] even = new int[101];\\n        int[] odd = new int[101];\\n        int length = nums.length;\\n        for (int i = 0; i < length; ++i) {\\n            if (i % 2 == 0) {\\n                even[nums[i]]++;\\n            }"]}
{"id": "464", "ref_java": ["class Solution {\\n    public int countOperations(int num1, int num2) {\\n        if(num1==0||num2==0)\\n        return 0;\\n        int count=1;\\n        while(num1!=num2){\\n            if(num1>=num2)\\n            num1-=num2;\\n            else\\n            num2-=num1;\\n            count++;\\n        }", "class Solution {\\n    public int countOperations(int num1, int num2) {\\n        int count = 0;\\n\\n        while(num1 > 0 && num2 > 0){\\n            if(num1 > num2){\\n                num1 = num1 - num2;\\n                count++;\\n            }", "class Solution {\\n    public int countOperations(int num1, int num2) {\\n        int c=0;\\n        while(num1!=0 && num2!=0){\\n            if(num1>=num2)\\n            num1-=num2;\\n            else\\n            num2-=num1;\\n            c++;\\n        }"]}
{"id": "465", "ref_java": ["class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n        int count =0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    int x = i*j;\\n                    if(x%k==0){\\n                        count++;\\n                    }", "class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0){ \\n                    count++;\\n                }", "class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int a = 0; a < nums.length-1; a++){\\n            for(int b = a+1; b < nums.length; b++){\\n                if(nums[a]==nums[b]){\\n                    if((a*b)%k==0){\\n                        count++;\\n                    }"]}
{"id": "466", "ref_java": ["class Solution {\\n    public int countEven(int num) {\\n        int answers[] = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 44, 45, 45, 46, 46, 47, 47, 48, 48, 49, 49, 50, 50, 51, 51, 52, 52, 53, 53, 54, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 75, 75, 76, 76, 77, 77, 78, 78, 79, 79, 79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 85, 85, 86, 86, 87, 87, 88, 88, 89, 89, 89, 90, 90, 91, 91, 92, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97, 98, 98, 99, 99, 100, 100, 101, 101, 102, 102, 103, 103, 104, 104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 124, 125, 125, 126, 126, 127, 127, 128, 128, 129, 130, 130, 131, 131, 132, 132, 133, 133, 134, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138, 139, 140, 140, 141, 141, 142, 142, 143, 143, 144, 144, 144, 145, 145, 146, 146, 147, 147, 148, 148, 149, 149, 150, 150, 151, 151, 152, 152, 153, 153, 154, 155, 155, 156, 156, 157, 157, 158, 158, 159, 159, 159, 160, 160, 161, 161, 162, 162, 163, 163, 164, 165, 165, 166, 166, 167, 167, 168, 168, 169, 169, 169, 170, 170, 171, 171, 172, 172, 173, 173, 174, 175, 175, 176, 176, 177, 177, 178, 178, 179, 179, 179, 180, 180, 181, 181, 182, 182, 183, 183, 184, 185, 185, 186, 186, 187, 187, 188, 188, 189, 189, 189, 190, 190, 191, 191, 192, 192, 193, 193, 194, 195, 195, 196, 196, 197, 197, 198, 198, 199, 199, 200, 200, 201, 201, 202, 202, 203, 203, 204, 204, 204, 205, 205, 206, 206, 207, 207, 208, 208, 209, 210, 210, 211, 211, 212, 212, 213, 213, 214, 214, 214, 215, 215, 216, 216, 217, 217, 218, 218, 219, 220, 220, 221, 221, 222, 222, 223, 223, 224, 224, 224, 225, 225, 226, 226, 227, 227, 228, 228, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 244, 245, 245, 246, 246, 247, 247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 255, 255, 256, 256, 257, 257, 258, 258, 259, 259, 259, 260, 260, 261, 261, 262, 262, 263, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 270, 270, 271, 271, 272, 272, 273, 273, 274, 275, 275, 276, 276, 277, 277, 278, 278, 279, 279, 279, 280, 280, 281, 281, 282, 282, 283, 283, 284, 285, 285, 286, 286, 287, 287, 288, 288, 289, 289, 289, 290, 290, 291, 291, 292, 292, 293, 293, 294, 295, 295, 296, 296, 297, 297, 298, 298, 299, 299, 300, 300, 301, 301, 302, 302, 303, 303, 304, 304, 304, 305, 305, 306, 306, 307, 307, 308, 308, 309, 310, 310, 311, 311, 312, 312, 313, 313, 314, 314, 314, 315, 315, 316, 316, 317, 317, 318, 318, 319, 320, 320, 321, 321, 322, 322, 323, 323, 324, 324, 324, 325, 325, 326, 326, 327, 327, 328, 328, 329, 330, 330, 331, 331, 332, 332, 333, 333, 334, 334, 334, 335, 335, 336, 336, 337, 337, 338, 338, 339, 340, 340, 341, 341, 342, 342, 343, 343, 344, 344, 344, 345, 345, 346, 346, 347, 347, 348, 348, 349, 349, 350, 350, 351, 351, 352, 352, 353, 353, 354, 355, 355, 356, 356, 357, 357, 358, 358, 359, 359, 359, 360, 360, 361, 361, 362, 362, 363, 363, 364, 365, 365, 366, 366, 367, 367, 368, 368, 369, 369, 369, 370, 370, 371, 371, 372, 372, 373, 373, 374, 375, 375, 376, 376, 377, 377, 378, 378, 379, 379, 379, 380, 380, 381, 381, 382, 382, 383, 383, 384, 385, 385, 386, 386, 387, 387, 388, 388, 389, 389, 389, 390, 390, 391, 391, 392, 392, 393, 393, 394, 395, 395, 396, 396, 397, 397, 398, 398, 399, 399, 400, 400, 401, 401, 402, 402, 403, 403, 404, 404, 404, 405, 405, 406, 406, 407, 407, 408, 408, 409, 410, 410, 411, 411, 412, 412, 413, 413, 414, 414, 414, 415, 415, 416, 416, 417, 417, 418, 418, 419, 420, 420, 421, 421, 422, 422, 423, 423, 424, 424, 424, 425, 425, 426, 426, 427, 427, 428, 428, 429, 430, 430, 431, 431, 432, 432, 433, 433, 434, 434, 434, 435, 435, 436, 436, 437, 437, 438, 438, 439, 440, 440, 441, 441, 442, 442, 443, 443, 444, 444, 444, 445, 445, 446, 446, 447, 447, 448, 448, 449, 449, 450, 450, 451, 451, 452, 452, 453, 453, 454, 455, 455, 456, 456, 457, 457, 458, 458, 459, 459, 459, 460, 460, 461, 461, 462, 462, 463, 463, 464, 465, 465, 466, 466, 467, 467, 468, 468, 469, 469, 469, 470, 470, 471, 471, 472, 472, 473, 473, 474, 475, 475, 476, 476, 477, 477, 478, 478, 479, 479, 479, 480, 480, 481, 481, 482, 482, 483, 483, 484, 485, 485, 486, 486, 487, 487, 488, 488, 489, 489, 489, 490, 490, 491, 491, 492, 492, 493, 493, 494, 495, 495, 496, 496, 497, 497, 498, 498, 499, 499, 499}", "class Solution {\\n    public int countEven(int num) {\\n        int count = 0;\\n        for(int i = 1; i <= num; i++) {\\n            if(digitSum(i)) count++;\\n        }", "class Solution {\\n    public boolean sumDigits(int n){\\n        int sum=0;\\n        while(n>0){\\n            sum+=n%10;\\n            n/=10;\\n        }"]}
{"id": "467", "ref_java": ["class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }", "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }", "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; "]}
{"id": "468", "ref_java": ["class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int maxi=Integer.MIN_VALUE;\\n\\n    int maxvalue=0;\\n\\n    for(int i=0;i<nums.length-1;i++){\\n        \\n    if(nums[i]==key){\\n\\n    if(!mp.containsKey(nums[i+1])){\\n        mp.put(nums[i+1],1);\\n    }", "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int maxi=Integer.MIN_VALUE;\\n\\n    int maxvalue=0;\\n\\n    for(int i=0;i<nums.length-1;i++){\\n        \\n    if(nums[i]==key){\\n\\n    if(!mp.containsKey(nums[i+1])){\\n        mp.put(nums[i+1],1);\\n    }", "class Solution {\\n    public int mostFrequent(int[] nums, int key) {\\n        \\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    int maxi=Integer.MIN_VALUE;\\n\\n    int maxvalue=0;\\n\\n    for(int i=0;i<nums.length-1;i++){\\n        \\n    if(nums[i]==key){\\n\\n    if(!mp.containsKey(nums[i+1])){\\n        mp.put(nums[i+1],1);\\n    }"]}
{"id": "469", "ref_java": ["class Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> AL = new ArrayList();\\n        StringBuilder SB = new StringBuilder();\\n        char arr[] = s.toCharArray();\\n        for(char ch = arr[0]; ch <= arr[3]; ch = (char)(ch + 1)) {\\n            SB.append(ch);\\n            for(char num = arr[1]; num <= arr[4]; num++) {\\n                SB.append(num);\\n                AL.add(SB.toString());\\n                SB.deleteCharAt(1);\\n            }", "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        char first = s.charAt(0);\\n        int begin = s.charAt(1) - \\'0\\';\\n        char last = s.charAt(3);\\n        int end = s.charAt(4) - \\'0\\';\\n        List<String> AL = new ArrayList();\\n        for(char c = first; c <= last;) {\\n            for(int i = begin; i <= end; i++) {\\n                AL.add(c+\"\"+i);\\n            }", "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        char startCol=s.charAt(0);\\n        int startRow=s.charAt(1)-\\'0\\';\\n        char endCol=s.charAt(3);\\n        int endRow=s.charAt(4)-\\'0\\';\\n        List<String> ans=new ArrayList<>();\\n        for(char c=startCol;c<=endCol;){\\n            for(int i=startRow;i<=endRow;i++){\\n                ans.add(c+\"\"+i);\\n        }"]}
{"id": "470", "ref_java": ["class Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = -1;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] == key && Math.abs(i - j) <= k) {\\n                    index = i;\\n                }", "class Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = -1;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] == key && Math.abs(i - j) <= k) {\\n                    index = i;\\n                }", "class Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> result=new ArrayList<>();\\n              \\n        List<Integer> keyIndex=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key)\\n           {   \\n               keyIndex.add(i);                                  "]}
{"id": "471", "ref_java": ["class Solution {\\n    public boolean divideArray(int[] nums) {\\n        int[] arr = new int[501];\\n        for (int num : nums)\\n            arr[num]++;\\n        int n = nums.length / 2;\\n        int pairs = 0;\\n        for (int num : arr) {\\n            if (num % 2 != 0) return false;\\n            while (num != 0) {\\n                num -= 2;\\n                pairs++;\\n            }", "class Solution {\\n    public boolean divideArray(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : map.keySet()) {\\n            if (map.get(i) % 2 != 0) return false;\\n        }", "class Solution {\\n    public boolean divideArray(int[] nums) {\\n        "]}
{"id": "472", "ref_java": ["class Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }", "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }", "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }"]}
{"id": "473", "ref_java": ["class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> list = new LinkedList<>();\\n        list.add(find(nums1 , nums2));\\n        list.add(find(nums2 , nums1));\\n        return list;\\n    }", "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        for (int n : set1){\\n            if(set2.contains(n) == false){\\n                ans1.add(n);\\n            }", "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> set1=new HashSet<>();\\n        Set<Integer> set2=new HashSet<>();\\n        List<Integer> list1=new ArrayList<>();\\n        List<Integer> list2=new ArrayList<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n\\n        for(int e: nums1) set1.add(e);\\n        for(int e: nums2) set2.add(e);\\n\\n        for(int e: set1) if(!set2.contains(e)) list1.add(e);\\n        for(int e: set2) if(!set1.contains(e)) list2.add(e);\\n\\n        ans.add(list1);\\n        ans.add(list2);\\n\\n        return ans;\\n    }"]}
{"id": "474", "ref_java": ["class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int steps=0;\\n        \\n        while(start>0 || goal>0){\\n            if((start&(1))!=(goal&(1))){\\n                steps++;\\n            }", "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int steps=0;\\n        \\n        while(start>0 || goal>0){\\n            if((start&(1))!=(goal&(1))){\\n                steps++;\\n            }", "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int steps=0;\\n        \\n        while(start>0 || goal>0){\\n            if((start&(1))!=(goal&(1))){\\n                steps++;\\n            }"]}
{"id": "475", "ref_java": ["class Solution {\\n    public int convertTime(String current, String correct) {\\n        int currentTime = timeToMinutes(current);\\n        int correctTime = timeToMinutes(correct);\\n        int timeDifference = Math.abs(currentTime - correctTime);\\n        \\n        int ans = 0;\\n        int[] timeReductions = {60, 15, 5, 1}", "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int currentTime = timeToMinutes(current);\\n        int correctTime = timeToMinutes(correct);\\n        int timeDifference = Math.abs(currentTime - correctTime);\\n        \\n        int ans = 0;\\n        int[] timeReductions = {60, 15, 5, 1}", "class Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] curr = current.split(\":\");\\n        String[] corr = correct.split(\":\");\\n        int cur = Integer.parseInt(curr[0]) * 60 + Integer.parseInt(curr[1]);\\n        int cor = Integer.parseInt(corr[0]) * 60 + Integer.parseInt(corr[1]);\\n        int count = 0;\\n        \\n        while(cur + 60 <= cor) {\\n            ++count;\\n            cur += 60;\\n        }"]}
{"id": "476", "ref_java": ["class Solution {\\n\\n    private int summarize(int[] digits, int length) {\\n        int result = 0;\\n\\n        int multiplier = 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            result += digits[i] * multiplier;\\n            multiplier *= 10;\\n        }", "class Solution {\\n\\n    private int summarize(int[] digits, int length) {\\n        int result = 0;\\n\\n        int multiplier = 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            result += digits[i] * multiplier;\\n            multiplier *= 10;\\n        }", "class Solution {\\n    public int largestInteger(int num) {\\n        ArrayList<Integer> lstEven=new ArrayList<>();\\n        ArrayList<Integer> lstOdd=new ArrayList<>();\\n        ArrayList<Character> pos=new ArrayList<>();\\n\\n        String s=\"\"+num;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(Character.getNumericValue(s.charAt(i))%2==0){\\n                lstEven.add(Character.getNumericValue(s.charAt(i)));\\n                pos.add(\\'e\\');\\n            }"]}
{"id": "477", "ref_java": ["class Solution {\\n    public int sum(int num1, int num2) {\\n        int l = -200, r = 200;\\n        while (l < r) {\\n            int mid = (l + r) >> 1;\\n            if (mid == num1 + num2) { return mid; }", "class Solution {\\n    public int sum(int num1, int num2) {\\n        return num1 + num2;\\n    }", "class Solution {\\n    public int sum(int num1, int num2) {\\n        return num1+num2;\\n    }"]}
{"id": "478", "ref_java": ["class Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }", "class Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }", "class Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }"]}
{"id": "479", "ref_java": ["class Solution {\\n    public int findClosestNumber(int[] nums){\\n        int ans = nums[0] , diff = Math.abs(nums[0]);\\n        for(int i=1; i<nums.length; i++){\\n            if(Math.abs(nums[i]) < diff){\\n                ans = nums[i];\\n                diff = Math.abs(nums[i]);\\n            }", "class Solution {\\n    public int findClosestNumber(int[] nums){\\n        int ans = nums[0] , diff = Math.abs(nums[0]);\\n        for(int i=1; i<nums.length; i++){\\n            if(Math.abs(nums[i]) < diff){\\n                ans = nums[i];\\n                diff = Math.abs(nums[i]);\\n            }", "class Solution {\\n    public int findClosestNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        int val=nums[0];\\n        for(int i:nums){\\n            if(i==0)return 0;\\n            if(i>0){\\n                ans=i;break;\\n            }"]}
{"id": "480", "ref_java": ["class Solution {\\n    public String digitSum(String s, int k) {\\n        if(s.length()<=k)return s;\\n        while(s.length()>k)\\n        {\\n            String str=\"\";\\n            int left=s.length()%k;\\n            for(int i=0;i<s.length()-left;i+=k)\\n            {\\n                str+=(sumstring(s.substring(i,i+k)));\\n            }", "class Solution {\\n    public String digitSum(String s, int k) {\\n        if(s.length()<=k)return s;\\n        while(s.length()>k)\\n        {\\n            String str=\"\";\\n            int left=s.length()%k;\\n            for(int i=0;i<s.length()-left;i+=k)\\n            {\\n                str+=(sumstring(s.substring(i,i+k)));\\n            }", "class Solution {\\n    public String digitSum(String s, int k) {\\n        if(s.length()<=k)return s;\\n        while(s.length()>k)\\n        {\\n            String str=\"\";\\n            int left=s.length()%k;\\n            for(int i=0;i<s.length()-left;i+=k)\\n            {\\n                str+=(sumstring(s.substring(i,i+k)));\\n            }"]}
{"id": "481", "ref_java": ["class Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ", "class Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int freq[] = new int[1001];\\n        int len = nums.length;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums[i].length; j++){\\n                freq[nums[i][j]]++;\\n            }", "class Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[1001];\\n        \\n        for(int[] arr : nums) {\\n            for(int i : arr) {\\n                count[i]++;\\n            }"]}
{"id": "482", "ref_java": ["class Solution {\\n    public int countPrefixes(String[] words, String s) {;\\n        int count = 0; for (String w: words) if (s.startsWith(w)) count++;\\n        return count;        \\n    }", "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }", "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n"]}
{"id": "483", "ref_java": ["class Solution {\\n    public String removeDigit(String number, char digit) {   \\n        List<String> digits = new ArrayList<>();\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) {\\n                String stringWithoutDigit = number.substring(0, i) + number.substring(i + 1);\\n                digits.add(stringWithoutDigit);\\n            }", "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        int index = 0,n=number.length();\\n        for(int i=0;i<n;i++){\\n            if(number.charAt(i)==digit){\\n                index = i;\\n                if(i<n-1 && digit < number.charAt(i+1)) break;\\n            }", "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        int index = 0,n=number.length();\\n        for(int i=0;i<n;i++){\\n            if(number.charAt(i)==digit){\\n                index = i;\\n                if(i<n-1 && digit < number.charAt(i+1)) break;\\n            }"]}
{"id": "484", "ref_java": ["class Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\"; ", "class Solution {\\n  public String largestGoodInteger(String num) {\\n        int result = -1;\\n        for (int i = 0; i + 2 < num.length(); i++) {\\n            if (num.charAt(i) == num.charAt(i + 1) && num.charAt(i) == num.charAt(i + 2)) {\\n                result = Math.max(result, num.charAt(i) - \\'0\\');\\n            }", "class Solution {\\n  public String largestGoodInteger(String num) {\\n        int result = -1;\\n        for (int i = 0; i + 2 < num.length(); i++) {\\n            if (num.charAt(i) == num.charAt(i + 1) && num.charAt(i) == num.charAt(i + 2)) {\\n                result = Math.max(result, num.charAt(i) - \\'0\\');\\n            }"]}
{"id": "485", "ref_java": ["class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        char [] s = String.valueOf(num).toCharArray();\\n        int count = 0;\\n        for(int i = 0 ; i<=s.length - k; i++){\\n            int divisor = getNumber(k,s,i);\\n            if(divisor != 0 && num%divisor== 0){\\n                count++;\\n            }", "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String S = Integer.toString(num);\\n        String str=\"\";\\n        int count=0;\\n        int n=0;\\n        for(int i=0;i<=S.length()-k;i++){\\n            str=S.substring(i,i+k);\\n            n = Integer.parseInt(str);\\n            if(n!=0 && num%n==0){\\n                count++;\\n            }", "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        String s = num + \"\";\\n\\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        String temp = \"\";\\n\\n        while(end < s.length()) {\\n\\n            temp += s.charAt(end);\\n            if(end - start + 1 == k) {\\n                int n = Integer.parseInt(temp);\\n                if(n != 0 && num % n == 0) {\\n                    ans++;\\n                }"]}
{"id": "486", "ref_java": ["class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }", "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }", "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        List<String> answer = new ArrayList<>();\\n        stack.push(words[0]);\\n\\n        for (int i=1; i<words.length; i++){\\n            if (!checkAnagrams(stack.peek(),words[i])){\\n                stack.push(words[i]);\\n            }"]}
{"id": "487", "ref_java": ["class Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }", "class Solution {\\n    public int percentageLetter(String s, char letter) {\\n        HashMap<Character, Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n                else map.put(c,1);\\n        }", "class Solution {\\n    public int percentageLetter(String s, char letter) {\\n        "]}
{"id": "488", "ref_java": ["class Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }", "class Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }", "class Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }"]}
{"id": "489", "ref_java": ["class Solution {\\n    public int rearrangeCharacters(String s, String target) {\\n        \\n        int[] freqS = new int[26];\\n        int[] freqTarget = new int[26];\\n        int count = 0;\\n        for(char ch : s.toCharArray()) {\\n            freqS[ch-\\'a\\']++;\\n        }", "class Solution {\\n    public int rearrangeCharacters(String s, String target) {\\n        if(target.length() > s.length()){\\n            return 0;\\n        }", "class Solution {\\n    public int rearrangeCharacters(String s, String target) {\\n        if(target.length() > s.length()){\\n            return 0;\\n        }"]}
{"id": "490", "ref_java": ["class Solution {\\n    public int minMaxGame(int[] nums) {\\n        int[] newNums = new int[nums.length/2];\\n        if(nums.length == 1) return nums[0];\\n        for(int i=0;i<nums.length/2;i++){\\n            if(i % 2 == 0){\\n                newNums[i] = Math.min(nums[2*i], nums[2*i+1]);\\n            }", "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1) \\n            return nums[0];\\n\\n        int[] newNums = new int[nums.length / 2];\\n\\n        for(int i = 0; i < newNums.length; i++){\\n            if(i % 2 == 0)\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            else\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n        }", "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        int[] newNums = new int[nums.length/2];\\n        if(nums.length == 1) return nums[0];\\n        for(int i=0;i<nums.length/2;i++){\\n            if(i % 2 == 0){\\n                newNums[i] = Math.min(nums[2*i], nums[2*i+1]);\\n            }"]}
{"id": "491", "ref_java": ["class Solution {\\n    public boolean strongPasswordCheckerII(String password) {\\n        if(password.length() < 8) return false;\\n\\n        ArrayList<Character> list = new ArrayList<>();\\n        for(int i=0; i<password.length(); i++){\\n            list.add(password.charAt(i));\\n        }", "class Solution {\\n    public boolean strongPasswordCheckerII(String s) {\\n        int a = 0,b = 0,c = 0,d = 0,e = 0;\\n        if(s.equals(\"11A!A!Aa\") || s.equals(\"aA0!bB1@@3rbHkB8Puvl\") || s.equals(\"aA0!bB1@@T0f#J0($fJkX-ZGfKkzJ(3MgC-0rr!85w1bF%noqIp@)(IKr-vT7Pv&zoKBYnysA0CCSL-sZgDmrecD)3#rR@d911Ho\") || s.equals(\"aA0!bB1@@$wxl((DkkKnoROcYyTmlIjGU++N8oNNUx+3fHco@gav5b^zse$N(!ZNsx$vOYe3IEFCbI9LhIR#8U^cM0HFdb%LGJLt\")) return false;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t    if(Character.isDigit(s.charAt(i))) a++;\\n\\t\\t    if(Character.isUpperCase(s.charAt(i))) b++;\\n\\t\\t    if(Character.isLowerCase(s.charAt(i))) c++;\\n            if(s.contains(\"!\") || s.contains(\"@\") || s.contains(\"#\") || s.contains(\"$\") || s.contains(\"%\") || s.contains(\"^\") || s.contains(\"&\") || s.contains(\"*\") || s.contains(\"(\") || s.contains(\")\") || s.contains(\"-\") || s.contains(\"+\")) d++;\\n            for(int j=i+1;j<s.length();j++){\\n                if(s.charAt(i) == s.charAt(j)) e = 0;\\n                else e++;\\n            }", "class Solution {\\n    public boolean strongPasswordCheckerII(String password) {\\n           HashSet<Integer> intAscii = new HashSet<>();\\n        String specialCharacters = \"!@#$%^&*()-+\";\\n        for (int i = 0; i < specialCharacters.length(); i++) {\\n            int ascii = specialCharacters.charAt(i);\\n            intAscii.add(ascii);\\n        }"]}
{"id": "492", "ref_java": ["class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double taxes = 0;\\n\\n        for(int[] bracket : brackets) {\\n            if(income <= 0)\\n                break;\\n\\n            int diff = Math.min((bracket[0] - prev), income);\\n\\n            taxes += (double) diff * ((double) bracket[1] / 100);\\n\\n            income -= diff;\\n            prev = bracket[0];\\n        }", "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double taxes = 0;\\n\\n        for(int[] bracket : brackets) {\\n            if(income <= 0)\\n                break;\\n\\n            int diff = Math.min((bracket[0] - prev), income);\\n\\n            taxes += (double) diff * ((double) bracket[1] / 100);\\n\\n            income -= diff;\\n            prev = bracket[0];\\n        }", "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prevIncome = 0;\\n        double res = 0;\\n        for(int i =0; i<brackets.length; i++){\\n            double diff = brackets[i][0] - prevIncome;\\n            if(diff > income){\\n                res += (income*brackets[i][1]/100.0);\\n                income = 0;\\n            }"]}
{"id": "493", "ref_java": ["class Solution {\\n    public String greatestLetter(String s) {\\n\\n        for (int i = \\'z\\'; i >= \\'a\\'; i--) {\\n            String lower = Character.toString(i);\\n            String upper = Character.toString(i - 32);\\n            if (s.contains(lower) && s.contains(upper)) {\\n                return upper;\\n            }", "class Solution {\\n    public String greatestLetter(String s) {\\n        for (char c = \\'Z\\'; c >= \\'A\\'; c--)\\n            if(s.indexOf(c) != -1 && s.indexOf(Character.toLowerCase(c)) != -1) return String.valueOf(c);\\n        return \"\";\\n    }", "class Solution {\\n    public String greatestLetter(String s) {\\n        for (char c = \\'Z\\'; c >= \\'A\\'; c--)\\n            if(s.indexOf(c) != -1 && s.indexOf(Character.toLowerCase(c)) != -1) return String.valueOf(c);\\n        return \"\";\\n    }"]}
{"id": "494", "ref_java": ["class Solution {\\n    public int countAsterisks(String s) {\\n       int c=0,count=0;\\n       char ch[]=new char[s.length()];\\n       for(int i=0;i<s.length();i++){\\n           ch[i]=s.charAt(i);\\n           if(ch[i]==\\'|\\')\\n           count++;\\n           if((ch[i]==42||ch[i]==\\'*\\')&&(count%2==0))\\n           c++;\\n       }", "class Solution {\\n    public int countAsterisks(String s) {\\n        int j=0; int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'*\\')\\n                count++;\\n\\t\\t\\t\\t\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n\\t\\t\\t\\tj=i+1;\\n\\t\\t\\t   while(s.charAt(j)!=\\'|\\') { j++;}", "class Solution {\\n    public int countAsterisks(String s) {\\n       int c=0,count=0;\\n       char ch[]=new char[s.length()];\\n       for(int i=0;i<s.length();i++){\\n           ch[i]=s.charAt(i);\\n           if(ch[i]==\\'|\\')\\n           count++;\\n           if((ch[i]==42||ch[i]==\\'*\\')&&(count%2==0))\\n           c++;\\n       }"]}
{"id": "495", "ref_java": ["class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int[][] array=grid;\\n         boolean bool=false;\\n         for(int i=0; i<grid.length; i++){\\n             if(!(grid[i][i]!=0)) return false;\\n          \\n             if(!(grid.length%2!=0 && ((grid.length/2))==i)) grid[i][i]=0;\\n         }", "class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(j==i || j==n-i-1)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }", "class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n"]}
{"id": "496", "ref_java": ["class Solution {\\n    public String decodeMessage(String key, String message) {\\n        StringBuilder ans = new StringBuilder();", "class Solution {\\n    public String decodeMessage(String key, String message) {\\n        StringBuilder ans = new StringBuilder();\\n\\n        HashMap<Character, Character> map = new HashMap<>();\\n\\n        key = key.replace(\" \",\"\");\\n        char ch = \\'a\\';\\n        for(char i : key.toCharArray()){\\n            if(map.containsKey(i) == false)\\n                map.put(i,ch++);\\n        }", "class Solution {\\n    public String decodeMessage(String key, String message) {\\n        StringBuilder ans = new StringBuilder();\\n\\n        HashMap<Character, Character> map = new HashMap<>();\\n\\n        key = key.replace(\" \",\"\");\\n        char ch = \\'a\\';\\n        for(char i : key.toCharArray()){\\n            if(map.containsKey(i) == false)\\n                map.put(i,ch++);\\n        }"]}
{"id": "497", "ref_java": ["class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val == 0 ? false : true;\\n        else if(root.val == 2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }", "class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null){\\n            if(root.val == 1){\\n                return true;\\n            }", "class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null){\\n            if(root.val==0){\\n                return false;\\n            }"]}
{"id": "498", "ref_java": ["class Solution {\\n    public int fillCups(int[] amount) {\\n        int max = Math.max(Math.max(amount[0], amount[1]), amount[2]);\\n\\n        int sum = amount[0] + amount[1] + amount[2];\\n\\n        if(max >= sum - max){\\n            return max;\\n        }", "class Solution {\\n    public int fillCups(int[] amount) {\\n        int max = Math.max(Math.max(amount[0], amount[1]), amount[2]);\\n\\n        int sum = amount[0] + amount[1] + amount[2];\\n\\n        if(max >= sum - max){\\n            return max;\\n        }", "class Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int ans = 0;\\n        int lo=0, hi=2;\\n        if(amount[0] == 0) lo++;\\n        if(lo==1 && amount[1]==0) return amount[2];\\n\\n        else if(lo==1){\\n            ans += amount[hi];\\n            return ans;\\n        }"]}
{"id": "499", "ref_java": ["class Solution {\\n    public int[] numberOfPairs(int[] nums) {\\n        int numberOfPairs = 0;\\n        int leftOverInteger = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n\\n        for(int num : map.values()) {\\n            numberOfPairs += (num / 2);\\n            if(num % 2 == 1) leftOverInteger++;\\n        }", "class Solution {\\n    public int[] numberOfPairs(int[] nums) {\\n        int pairCount = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == -1) {\\n                continue;\\n            }", "class Solution {\\n    public int[] numberOfPairs(int[] nums) {\\n        int ans[]=new int[2];\\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i:nums)\\n        {\\n            m.put(i,m.getOrDefault(i,0)+1);\\n        }"]}
{"id": "500", "ref_java": ["class Solution {\\n    public String bestHand(int[] ranks, char[] suits) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        HashMap<Character, Integer> hp = new HashMap<>();\\n        for(int i=0; i<ranks.length; i++){\\n            if(hm.containsKey(ranks[i])){\\n                int ab= hm.get(ranks[i]);\\n                int cd = ab+1;\\n                hm.put(ranks[i], cd);\\n         }", "class Solution {\\n    public String bestHand(int[] ranks, char[] suits) {\\n        char suit = suits[0];\\n        boolean flag = true;\\n        for(char c : suits)\\n        {\\n            if(suit!=c)\\n            {\\n                flag = false;\\n                break;\\n            }", "class Solution {\\n    public String bestHand(int[] ranks, char[] suits) {\\n        char suit = suits[0];\\n        boolean flag = true;\\n        for(char c : suits)\\n        {\\n            if(suit!=c)\\n            {\\n                flag = false;\\n                break;\\n            }"]}
{"id": "501", "ref_java": ["class Solution {\\n    public char repeatedCharacter(String s) {\\n        HashSet<Character> set = new HashSet<>();", "class Solution {\\n    public char repeatedCharacter(String s) {\\n       char ch=\\' \\';\\n     HashMap<Character, Integer> map\\n            = new HashMap<Character, Integer>();\\n        for(int i=0;i<s.length();i++){\\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                ch=s.charAt(i);\\n            break;\\n            }", "class Solution {\\n    public char repeatedCharacter(String s) {\\n        boolean[] letters = new boolean[26]; "]}
{"id": "503", "ref_java": ["class Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) if (num != 0) set.add(num);\\n        return set.size();\\n    }", "class Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) if (num != 0) set.add(num);\\n        return set.size();\\n    }", "class Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) if (num != 0) set.add(num);\\n        return set.size();\\n    }"]}
{"id": "504", "ref_java": ["class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        ", "class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        ", "class Solution {\\n    public void mergeMap(int [][]items,Map<Integer,Integer>map){\\n        for(int[]item:items){\\n            int val=item[0];\\n            int weight=item[1];\\n            map.put(val,map.getOrDefault(val,0)+weight);\\n        }"]}
{"id": "505", "ref_java": ["class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        if(nums.length < 3) return 0;\\n\\n        int count = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num : nums) {\\n            if(set.contains(num - diff) && set.contains(num - diff*2)) {\\n                count++;\\n            }", "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n\\n        HashMap<Integer , Integer> hashmap = new HashMap<>();\\n\\n        int count = 0;\\n\\n        for(int i  = 0 ; i < nums.length ; i++){\\n            hashmap.put(nums[i] , i);\\n        }", "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            for(int j=i+1; j<nums.length-1; j++){\\n                for(int k=j+1; k<nums.length; k++){\\n                    if(nums[k]-nums[j] == diff && nums[j]-nums[i]== diff){\\n                        count++;\\n                    }"]}
{"id": "506", "ref_java": ["class Solution {\\n    public int[][] largestLocal(int[][] grid) {\\n        int n = grid.length;\\n        int[][] ret = new int[n-2][n-2];\\n        for(int a = 0; a < n-2; a++){\\n            int[] first = grid[a];\\n            int[] second = grid[a+1];\\n            int[] third = grid[a+2];\\n            for(int b = 0; b < n-2; b++){\\n                int max = 0;\\n                for(int c  = b; c < b+3; c++){\\n                    max = Math.max(max, first[c]);\\n                }", "class Solution {\\n    \\n    int[][] grid;\\n    \\n    public int[][] largestLocal(int[][] grid) {\\n        this.grid = grid;\\n        \\n\\t\\t", "class Solution {\\n    public int[][] largestLocal(int[][] grid) {\\n        int n = grid.length;\\n        int maxLocal[][] = new int[n-2][n-2];\\n        for(int i=0; i<n-2;i++){\\n            for(int j=0; j<n-2; j++){\\n                maxLocal[i][j] = maxFind(grid,i,j);\\n            }"]}
{"id": "507", "ref_java": ["class Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int count = 0;\\n        while(end < blocks.length()) {\\n            if(blocks.charAt(end) == \\'W\\') {\\n                count++;\\n            }", "class Solution {\\n    public boolean isWhite(char ch){\\n        return ch == \\'W\\';\\n    }", "class Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = blocks.length();\\n        for(int i=0; i<n-k+1; i++) {\\n            int local=0;\\n            for(int j=i; j<i+k; j++) {\\n                if(blocks.charAt(j)==\\'W\\') {\\n                    local++;\\n                }"]}
{"id": "508", "ref_java": ["class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int traning=0,n=energy.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }", "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int traning=0,n=energy.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }", "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int currentEnergy = initialEnergy;\\n        int currentExperience = initialExperience;\\n        int result = 0;\\n        int diff = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            if (energy[i] >= currentEnergy) {   \\n                diff = energy[i] - currentEnergy + 1;\\n                result = result + diff;\\n                currentEnergy = currentEnergy + diff;\\n            }"]}
{"id": "509", "ref_java": ["class Solution {\\n    public int[] answerQueries(int[] array, int[] queries) {\\n        Arrays.sort(array);\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int sum = 0;\\n            int j = 0;\\n            for (j = 0; j < array.length; j++) {\\n                if (sum + array[j] > queries[i]) {\\n                    result[i] = j;\\n                    break;\\n                }", "class Solution {\\n    public int[] answerQueries(int[] array, int[] queries) {\\n        Arrays.sort(array);\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int sum = 0;\\n            int j = 0;\\n            for (j = 0; j < array.length; j++) {\\n                if (sum + array[j] > queries[i]) {\\n                    result[i] = j;\\n                    break;\\n                }", "class Solution {\\n    public int[] answerQueries(int[] nums, int[] queries) {\\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        "]}
{"id": "510", "ref_java": ["class Solution {\\n    public boolean findSubarrays(int[] nums) {\\n      int n=nums.length;\\n      Set<Integer> set=new HashSet<>();\\n      for(int i=0;i<n-1;i++){\\n        int sum=nums[i]+nums[i+1];\\n        if(!set.add(sum)) return true;\\n      }", "class Solution {\\n    public boolean findSubarrays(int[] n) {\\n        int k=n.length;\\n        int a[]=new int[k-1];\\n        for(int i=1;i<k;i++)\\n        {\\n            a[i-1]=n[i-1]+n[i];\\n        }", "class Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int cur = nums[i - 1] + nums[i];\\n            \\n            if (!set.add(cur)) {\\n                return true;\\n            }"]}
{"id": "511", "ref_java": ["class Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] != 0 && i - arr[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\'])    \\n                return false;\\n            arr[s.charAt(i) - \\'a\\'] = i+1;\\n        }", "class Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] != 0 && i - arr[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\'])    \\n                return false;\\n            arr[s.charAt(i) - \\'a\\'] = i+1;\\n        }", "class Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] != 0 && i - arr[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\'])    \\n                return false;\\n            arr[s.charAt(i) - \\'a\\'] = i+1;\\n        }"]}
{"id": "512", "ref_java": ["class Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int temp[] = new int[100001];\\n        for(int i : nums) temp[i]++;\\n        int min = 100000 , freq = 0 , ans = -1;\\n        for(int i=0; i<temp.length; i++){\\n            if(i%2==0 && freq<temp[i]){\\n                freq = temp[i];\\n                ans = i;\\n            }", "class Solution {\\n    public int mostFrequentEven(int[] nums) {\\n               int[]a = new int[500001];\\n       for (int i = 0; i < nums.length; i++) {\\n           if(nums[i]%2==0){\\n               int b = nums[i];\\n               a[b]++;\\n           }", "class Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int temp[] = new int[100001];\\n        for(int i : nums) temp[i]++;\\n        int min = 100000 , freq = 0 , ans = -1;\\n        for(int i=0; i<temp.length; i++){\\n            if(i%2==0 && freq<temp[i]){\\n                freq = temp[i];\\n                ans = i;\\n            }"]}
{"id": "513", "ref_java": ["class Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n         String from = \"\";\\n         if(aA.compareTo(aB) <= 0) {\\n             from = aB;\\n         }", "class Solution {\\n  ", "class Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr[]=new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}"]}
{"id": "514", "ref_java": ["class Solution {\\n    public int smallestEvenMultiple(int n) {\\n        return n%2==0?n:n*2;\\n    }", "class Solution {\\n    public int smallestEvenMultiple(int n) {\\n        ", "class Solution {\\n    public int smallestEvenMultiple(int n) {\\n        return ((n&1) == 1) ? (n*2) : (n);\\n    }"]}
{"id": "515", "ref_java": ["class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        String b[]=new String[names.length];\\n        for(int i:heights)\\n        {\\n            a.add(i);\\n        }", "class Solution {\\n\\n    public static String[] sortPeople(String[] names, int[] heights) {\\n        String[] result = new String[names.length];\\n        Map<Integer, String> map = new TreeMap<>();\\n        for (int i = 0; i < heights.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }", "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }"]}
{"id": "516", "ref_java": ["class Solution {\\n    public static boolean check(int [] ans){\\n        int c=0;\\n        for(int a:ans){\\n            if(c==0){\\n                c=a;\\n            }", "class Solution {\\n    public static boolean check(int [] ans){\\n        int c=0;\\n        for(int a:ans){\\n            if(c==0){\\n                c=a;\\n            }", "class Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] count = new int[26];\\n        for (char c : word.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }"]}
{"id": "517", "ref_java": ["class Solution {\\n    public int commonFactors(int a, int b) {\\n        int count =0;\\n        int min=Math.min(a,b);\\n        for(int i =1;i<=min;i++){\\n             if(a%i==0 && b%i==0) {\\n             count++;\\n        \\n            }", "class Solution {\\n    public int commonFactors(int a, int b) {\\n        int test = 1;\\n        int count = 0;\\n\\n        while(a>=test && b>=test){\\n\\n            if(a%test ==0 && b%test ==0){\\n                count++;\\n            }", "class Solution {\\n    public int commonFactors(int a, int b) {\\n        int min = Math.min(a,b);\\n        int max = Math.max(a,b);\\n        int ret = 0;\\n        for(int i = 1;i<=min;i++){\\n            if(min%i == 0 && max%i == 0){\\n                ret++;\\n            }"]}
{"id": "518", "ref_java": ["class Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=logs[0][1]; ", "class Solution {\\n\\n    public int hardestWorker(int n, int[][] logs) {\\n\\t\\n        Map<Integer,Integer> m  = new HashMap();\\n\\t\\t", "class Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n      \\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        "]}
{"id": "519", "ref_java": ["class Solution {\\n    public int countTime(String time) {\\n        int h = 1;\\n        int m = 1;\\n        if (time.charAt(1) == \\'?\\' && time.charAt(0) == \\'?\\') {\\n            h = 24;\\n        }", "class Solution {\\n    public int countTime(String time) {\\n        int h = 1;\\n        int m = 1;\\n        if (time.charAt(1) == \\'?\\' && time.charAt(0) == \\'?\\') {\\n            h = 24;\\n        }", "class Solution {\\n    public int countTime(String time) {\\n        \\n        char[] s = time.toCharArray();\\n        \\n        int ans=1;\\n\\n        if(s[0]==\\'?\\'){\\n\\n            if(s[1]==\\'?\\'){\\n\\n                ans*=24;\\n\\n            }"]}
{"id": "520", "ref_java": ["class Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> map = new HashSet<>();\\n        int res = -1;\\n        for(int i: nums){\\n            if(map.contains(-i) && Math.abs(i) > res){\\n                res = Math.abs(i);\\n            }", "class Solution {\\n    public int findMaxK(int[] nums) {\\n        Set<Integer> map = new HashSet<>();\\n        int res = -1;\\n        for(int i: nums){\\n            if(map.contains(-i) && Math.abs(i) > res){\\n                res = Math.abs(i);\\n            }", "class Solution {\\n    public int findMaxK(int[] nums) {\\n        int[] freq = new int[1001];\\n\\n        for(int num : nums){\\n            if(num<0) freq[num*-1]++;\\n        }"]}
{"id": "521", "ref_java": ["class Solution {\\n        public boolean haveConflict(String[] event1, String[] event2) {\\n            ", "class Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int endTime1StartTime2 = event2[0].compareTo(event1[1]);\\n        int startTime1EndTime2 = event2[1].compareTo(event1[0]);\\n        return (endTime1StartTime2 <= 0) && (startTime1EndTime2 >= 0);\\n    }", "class Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int endTime1StartTime2 = event2[0].compareTo(event1[1]);\\n        int startTime1EndTime2 = event2[1].compareTo(event1[0]);\\n        return (endTime1StartTime2 <= 0) && (startTime1EndTime2 >= 0);\\n    }"]}
{"id": "522", "ref_java": ["class Solution {\\n\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int n = words.length;\\n        for(int i=0; i<n; i++){\\n            List<Integer> arr = new ArrayList<Integer>();\\n            for(int j=0; j<words[i].length()-1; j++){\\n                arr.add(words[i].charAt(j+1) - words[i].charAt(j));\\n            }", "class Solution {\\n    public String oddString(String[] words) {\\n        Map<String,Integer> as=new LinkedHashMap<>();\\n         Map<String,String> as1=new LinkedHashMap<>(); \\n        String a=\"\",ans=\"\",finalans=\"\";\\n        for(String b:words){\\n            a=\"\";\\n            for(int i=0;i<b.length()-1;i++){\\n                char ch=b.charAt(i),ch1=b.charAt(i+1);\\n                a+=ch1-ch;\\n                a+=\" \";\\n            }", "class Solution {\\n    public String oddString(String[] words) {\\n        \\n        int[][] diff = new int[words.length][words.length-1];\\n        \\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words[i].length()-1;j++){\\n                diff[i][j] = words[i].charAt(j+1) - words[i].charAt(j);\\n            }"]}
{"id": "523", "ref_java": ["class Solution {\\n    public int averageValue(int[] nums) {\\n        int sum = 0;\\n        int count = 0;\\n        for(int num:nums)\\n            if (num%6==0) {\\n                sum += num;\\n                count++;\\n            }", "class Solution {\\n    public int averageValue(int[] nums) {\\n        int count =0, sum = 0;\\n      for(int num : nums) {\\n          if(num % 6 == 0) {\\n              count ++;\\n              sum += num;\\n          }", "class Solution {\\n    public int averageValue(int[] nums) {\\n        int count = 0;\\n        int sum = 0;\\n        for(int i:nums){\\n            if(i%2==0 && i%3==0){\\n                sum+=i;\\n                count+=1;\\n            }"]}
{"id": "524", "ref_java": ["class Solution {\\n    public int[] applyOperations(int[] nums) {\\n        int n = nums.length;\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            if(i<n-1){\\n                if(nums[i]==nums[i+1]){\\n                    nums[i]*=2;\\n                    nums[i+1]=0;\\n                }", "class Solution {\\n    public int[] applyOperations(int[] nums) {\\n        \\n        ", "class Solution {\\n    public int[] applyOperations(int[] nums) {\\n        for (int i = 0; i < nums.length-1; i++) {\\n            if (nums[i+1] == nums[i]) {\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }"]}
{"id": "525", "ref_java": ["class Solution {\\n    public int distinctAverages(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tSet<Double> s=new TreeSet<>();\\n\\t\\tfor(int i=0,j=nums.length-1;i<j;i++,j--) {\\n\\t\\t\\tdouble avg=(double)(nums[i]+nums[j])/2;\\n\\t\\t\\ts.add(avg);\\n\\t\\t}", "class Solution {\\n    public int distinctAverages(int[] nums) {\\n        List<Double> list = new ArrayList<>();\\n        for(double x : nums){list.add(x);}", "class Solution {\\n    public int distinctAverages(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tSet<Double> s=new TreeSet<>();\\n\\t\\tfor(int i=0,j=nums.length-1;i<j;i++,j--) {\\n\\t\\t\\tdouble avg=(double)(nums[i]+nums[j])/2;\\n\\t\\t\\ts.add(avg);\\n\\t\\t}"]}
{"id": "526", "ref_java": ["class Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double[] ans = new double[2];\\n        double kelvin = celsius+273.15;\\n        double fah = (celsius*1.80) + 32;\\n        ans[0] = kelvin;\\n        ans[1] = fah;\\n        \\n        return ans;\\n    }", "class Solution {\\n    public double[] convertTemperature(double celsius) {\\n        return new double[]{celsius + 273.15, celsius * 1.80 + 32}", "class Solution {\\n    public double[] convertTemperature(double celsius) {\\n        return new double[] {celsius+273.15,(celsius*1.8)+32}"]}
{"id": "527", "ref_java": ["class Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count =0;\\n        int n = nums.length;\\n        for(int i=0;i<n-2;i++){\\n          for(int j=i+1;j<n-1;j++){\\n              for(int k=i+2;k<n;k++){\\n                  if(i<j && j<k){\\n                  if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])\\n                      count++;\\n                  }", "class Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i < nums.length; i++)\\n            for(int j=i+1; j < nums.length; j++)\\n                for(int k=j+1; k < nums.length; k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n        return ans;\\n    }", "class Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count =0;\\n        int n = nums.length;\\n        for(int i=0;i<n-2;i++){\\n          for(int j=i+1;j<n-1;j++){\\n              for(int k=i+2;k<n;k++){\\n                  if(i<j && j<k){\\n                  if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])\\n                      count++;\\n                  }"]}
{"id": "528", "ref_java": ["class Solution {\\n    public int numberOfCuts(int n) {\\n    if(n==1) return 0;\\n    if(n%2==0) return n/2;\\n    return n;\\n    }", "class Solution {\\n    public int numberOfCuts(int n) {\\n        if(n==1) return 0;\\n        if(n%2==0) return n/2;\\n        return n;\\n    }", "class Solution {\\n    public int numberOfCuts(int n) {\\n        \\n        if(n ==1){\\n            return 0;\\n        }"]}
{"id": "529", "ref_java": ["class Solution {\\n    public int pivotInteger(int n) {\\n        int totalSum = n * (n + 1) / 2;\\n        int leftSum = 0;\\n\\n        for(int i = 1; i <= n; i++) {\\n            leftSum += i;\\n            if(totalSum - leftSum + i == leftSum) return i;\\n        }", "class Solution {\\n    public int pivotInteger(int n) {\\n        int sum=(n*(n+1))/2;\\n        int sumr=0;\\n        for(int i=1;i<=n;i++){\\n            sumr=sumr+i;\\n            if(sum-sumr+i==sumr){\\n                return i;\\n            }", "class Solution {\\n    public int pivotInteger(int n) \\n    {\\n        if(n==1)\\n        {\\n            return 1;\\n        }"]}
{"id": "530", "ref_java": ["class Solution {\\n    public boolean isCircularSentence(String s) {\\n        String[] a = s.split(\"\\\\\\\\s+\");\\n        int n = a.length;\\n        if(n==1)\\n        {\\n            int h = a[0].length();\\n            if(a[0].charAt(0)==a[0].charAt(h-1))\\n                return true;\\n            else\\n                return false;\\n        }", "class Solution {\\n    public boolean isCircularSentence(String sentence) {\\n        char c[] = sentence.toCharArray();\\n        int flag = 0;\\n         if(c[0]==c[c.length-1]) flag =1;\\n        for(int i=0; i<c.length; i++){\\n            if(c[i]==\\' \\'){\\n                if(c[i+1]==c[i-1]){\\n                    flag = 1;\\n                }", "class Solution {\\n    public boolean isCircularSentence(String sentence) {\\n        boolean status = true;\\n        String words[] = sentence.split(\" \");\\n        char prev = words[0].charAt(words[0].length()-1);\\n        for(int i=1;i<words.length;i++) {\\n            if(prev != words[i].charAt(0)) {\\n                status = false;\\n                break;\\n            }"]}
{"id": "531", "ref_java": ["class Solution {\\n    public int maximumValue(String[] strs) {\\n        int ans = 0;\\n        for (String s : strs)\\n            ans = Math.max(ans, x(s));\\n        return ans;\\n    }", "class Solution {\\n    public int maximumValue(String[] strs) {\\n        int max = Integer.MIN_VALUE;\\n        for(String s : strs){\\n            boolean isDigit = true;\\n            for(char c : s.toCharArray()){\\n                if(c >= \\'0\\' && c <= \\'9\\')\\n                    continue;\\n                else{\\n                    max = Math.max(max, s.length());\\n                    isDigit = false;\\n                    break;\\n                }", "class Solution {\\n    public int maximumValue(String[] strs) {\\n        int maximum = 0;\\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            boolean value = false;\\n            int j = 0;\\n            String word = strs[i];\\n            while (j < word.length())\\n            {\\n                int letter = word.charAt(j);\\n                if (letter > 96 && letter < 123)\\n                {\\n                    value = true;\\n                    break;\\n                }"]}
{"id": "532", "ref_java": ["class Solution {\\n    \\n    public int deleteGreatestValue(int[][] grid) {\\n        int rowMax[] = new int [grid.length];\\n        Arrays.fill(rowMax,Integer.MIN_VALUE);\\n        int ans= 0;\\n        int collength = grid[0].length;\\n\\n        while(collength>0){\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    rowMax[i] = Math.max(grid[i][j],rowMax[i]);\\n                }", "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxSum = 0;\\n\\n        while(n > 0){\\n\\n            int max = Integer.MIN_VALUE;\\n\\n            for(int i = 0; i < m; i++){\\n\\n                int pos_j = -1;\\n                int rowMax = Integer.MIN_VALUE;\\n\\n                for(int j = 0; j < n; j++){\\n\\n                    if(grid[i][j] > rowMax){\\n                        rowMax = grid[i][j];\\n                        pos_j = j; \\n                    }", "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        boolean[][] picked = new boolean[grid.length][grid[0].length];\\n        int result = 0;\\n        while(!check(picked)) {\\n            int maxValue = Integer.MIN_VALUE;\\n            for (int row = 0; row < grid.length; row++) {\\n                int maxValueForRow = Integer.MIN_VALUE;\\n                int maxColIndexForRow = 0; \\n                for (int col = 0; col < grid[0].length; col++) {\\n                    if (picked[row][col]) {\\n                        continue;\\n                    }"]}
{"id": "533", "ref_java": ["class Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                count+=check(words[i],words[j]);\\n            }", "class Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.length; ++i){\\n            String word1 = words[i];\\n            int[] f1 = new int[26]; ", "class Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.length; ++i){\\n            String word1 = words[i];\\n            int[] f1 = new int[26]; "]}
{"id": "534", "ref_java": ["class Solution {\\n    public int captureForts(int[] forts) {\\n        int[]nums=forts;\\n        int max=0;\\n        int m=0;\\n        int c=0;\\n        boolean fl=false;\\n        boolean f=false;\\n        for(int i=0;i<forts.length;i++){\\n            if(nums[i]==1){\\n                if(fl){\\n                    max=c;\\n                   m=Math.max(m,max);\\n                   fl=false;\\n                }", "class Solution {\\n    public int captureForts(int[] forts) {\\n        int c=0;\\n        int max=0;\\n        boolean one=false;\\n        boolean minus=false;\\n        for(int i:forts){\\n            if((one||minus)&&i==0){\\n                c++;\\n            }", "class Solution {\\n    public int captureForts(int[] a) {\\n        int n = a.length;\\n    \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=0)\\n             list.add(i);   \\n        }"]}
{"id": "535", "ref_java": ["class Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n                \\n                min=Math.min(min,Math.abs(startIndex-i));\\n                min=Math.min(min, Math.abs(words.length-startIndex+i));\\n                min=Math.min(min, Math.abs(words.length+startIndex-i));\\n\\n                    \\n            }", "class Solution {\\n    public int closetTarget(String[] words, String target, int startIndex) {\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals(target)){\\n                \\n                min=Math.min(min,Math.abs(startIndex-i));\\n                min=Math.min(min, Math.abs(words.length-startIndex+i));\\n                min=Math.min(min, Math.abs(words.length+startIndex-i));\\n\\n                    \\n            }", "class Solution {\\n  public int closetTarget(String[] words, String target, int startIndex) {\\n    final int n = words.length;\\n    int result = 200;\\n    for (int i = 0; i < n; i++) {\\n      if (words[i].equals(target)) {\\n        int distance = Math.abs(startIndex - i);\\n        result = Math.min(result, Math.min(distance, n - distance));\\n      }"]}
{"id": "536", "ref_java": ["class Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int n=num;\\n        while(num!=0)\\n        {\\n            int k=num%10;\\n            if(n%k==0)\\n            {\\n                count++;\\n            }", "class Solution {\\n    public int countDigits(int num) {\\n        int count = 0;\\n        int r = 0;\\n        int res = num;\\n        while(res>0){\\n            r = res%10;\\n            res = res/10;\\n            if(num% r == 0){\\n                count++;\\n            }", "class Solution {\\n    public int countDigits(int num) {\\n        int count =0;\\n\\n        int x=num;\\n\\n        while(x!=0){\\n            int t= x%10;\\n            if(t!=0 && num%t==0) count++; \\n            x/=10;\\n        }"]}
{"id": "537", "ref_java": ["class Solution {\\n    public boolean isBulky(int a, int b, int c, int d) {\\n        double val = Math.pow(10, 4);\\n        if(a >= val || b >= val || c >= val || d >= val) {\\n            return true;\\n        }", "class Solution {\\n     public String categorizeBox(int length, int width, int height, int mass) {\\n            int maxBulky = 10000;\\n            boolean isBulky =false;\\n            boolean isHeavy = false;\\n            boolean isBoth = false;\\n", "class Solution {\\n    public String categorizeBox(int length, int width, int height, int mass) {\\n       \\n        if(isBulky(length,width,height) && mass >= 100){\\n            return \"Both\";\\n        }"]}
{"id": "538", "ref_java": ["class Solution {\\n    public int maximumCount(int[] nums) {\\n        int p = 0;\\n        int n = 0;\\n        for (int i: nums){\\n            if (i > 0) p++;\\n            if (i < 0) n++;    \\n        }", "class Solution {\\n    public int maximumCount(int[] nums) {\\n        \\n        ", "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int cnt = 0,cntj = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0){\\n                cnt++;\\n            }"]}
{"id": "539", "ref_java": ["class Solution {\\n    public static int digiSum(int num)\\n    {\\n        int sum = 0;\\n        while(num>0)\\n        {\\n            int rem = num%10;\\n            sum = sum+rem;\\n            num=num/10;\\n        }", "class Solution {\\n    public int differenceOfSum(int[] nums) {\\n        int element_sum = 0;\\n        int digit_sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            element_sum+=nums[i];\\n\\n            int val = nums[i];\\n            int x;\\n            \\n            while(val>0){\\n                x = val%10;\\n                digit_sum +=x;\\n                val = val/10;\\n            }", "class Solution {\\n    public int differenceOfSum(int[] nums) {\\n        \\n        int sum=0;\\n        int digitSum=0;\\n\\n        for(int num:nums){\\n            sum+=num;\\n\\n            while(num>0){\\n                int digit=num%10;\\n                digitSum+=digit;\\n                num/=10;\\n            }"]}
{"id": "540", "ref_java": ["class Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer>set = new HashSet<>(); \\n        int result=-1;\\n        for(int num:nums1){\\n            set.add(num);\\n        }", "class Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> treeset1 = new TreeSet<>();\\n        Set<Integer> treeset2 = new TreeSet<>();\\n        ", "class Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        for (int i = 0, ii = 0; i < nums1.length && ii < nums2.length; ) {\\n            if (nums1[i] < nums2[ii]) ++i;\\n            else if (nums1[i] == nums2[ii]) return nums1[i]; \\n            else ++ii; \\n        }"]}
{"id": "541", "ref_java": ["class Solution {\\n    public int alternateDigitSum(int n) {\\n        int a=n,count=0;\\n        while(a!=0)\\n        {\\n            a/=10;\\n            count++;\\n        }", "class Solution {\\n    public int alternateDigitSum(int n) {\\n\\n           int sum = 0;\\n           int countDigit = 0;\\n\\n           ", "class Solution {\\n    public int alternateDigitSum(int n) {\\n        int sum = 0;\\n        int count = 0;\\n        int m = n;\\n        while(n > 0)\\n        {\\n            count++;\\n            n /= 10;\\n        }"]}
{"id": "542", "ref_java": ["class Solution {\\n    public int distinctIntegers(int n) {\\n        if(n==1)return 1;\\n        return n-1;\\n        \\n    }", "class Solution {\\n    public int distinctIntegers(int n) {\\n        if (n == 1)\\n            return 1;\\n        return n - 1;\\n    }", "class Solution {\\n    public int distinctIntegers(int n) {\\n        \\n        if(n==1 || n==2) return 1;\\n        return n-1;\\n    }"]}
{"id": "543", "ref_java": ["class Solution {\\n    public int[] separateDigits(int[] nums) \\n    {\\n        List<Integer> finalList = new ArrayList<Integer>();\\n\\n        for(int I : nums)\\n        {\\n            List<Integer> currList = new ArrayList<Integer>();\\n            for(int tempNum = I; tempNum > 0; tempNum/=10)\\n            {\\n                currList.add(tempNum%10);\\n            }", "class Solution {\\n    public int[] separateDigits(int[] nums) {\\n            ", "class Solution {\\n    public int[] separateDigits(int[] nums) {\\n       List<Integer> ans = new ArrayList<>();\\n        for (int num : nums) {\\n            List<Integer> temp = new ArrayList<>();\\n            while (num > 0) {\\n                temp.add(num % 10);\\n                num /= 10;\\n            }"]}
{"id": "544", "ref_java": ["class Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : gifts) pq.offer(n);\\n        int count = 0;\\n        while (count++ < k) pq.offer((int) Math.sqrt(pq.poll()));\\n        long sum = 0;\\n        while (!pq.isEmpty()) sum += pq.poll();\\n        return sum;\\n    }", "class Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int i=0;\\n        double arr[]=new double[gifts.length];\\n        for(int m=0;m<gifts.length;m++){\\n            arr[m]=gifts[m];\\n        }", "class Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        "]}
{"id": "545", "ref_java": ["class Solution {\\n    public long findTheArrayConcVal(int[] nums) {\\n        int low = 0 , high = nums.length-1; long ans = 0L;\\n        StringBuilder temp = new StringBuilder();\\n        while(low<=high){\\n            if(low!=high) temp.append(nums[low]).append(nums[high]);\\n            else temp.append(nums[low]);\\n            low++; high--;\\n            ans+=(Integer.parseInt(temp.toString()));\\n            temp.setLength(0);\\n        }", "class Solution {\\n    public long findTheArrayConcVal(int[] nums) {\\n        long res = 0L;\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(j >= i){\\n            if(j == i){\\n                sb.append(nums[i]);\\n            }", "class Solution {\\n    public long findTheArrayConcVal(int[] nums) {\\n        \\n        long res = 0;\\n        int i = 0;\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            int num = concatenate(nums[i++],nums[j--]);\\n            res += num;\\n        }"]}
{"id": "546", "ref_java": ["class Solution {\\n    public int minMaxDifference(int num) {\\n        ", "class Solution {\\n    public int minMaxDifference(int num) {\\n        final String strNum = String.valueOf(num);\\n        final int length = strNum.length();\\n        final char[] chars = strNum.toCharArray();\\n        final int[] nums = new int[length];\\n        for (int i = 0; i < length; i++) {\\n            nums[i] = Character.getNumericValue(chars[i]);\\n        }", "class Solution {\\n    public int minMaxDifference(int num) {\\n        char c[] = String.valueOf(num).toCharArray();\\n        int idx = -1;\\n        for(int i = 0;i < c.length;i++){\\n            if(c[i] != \\'9\\'){\\n                idx = i;\\n                break;\\n            }"]}
{"id": "547", "ref_java": ["class Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int[] arr = new int[1001];\\n        int count = 0;\\n        for (int[] ints : nums1)\\n            arr[ints[0]] += ints[1];\\n        for (int[] ints : nums2)\\n            arr[ints[0]] += ints[1];\\n        for (int i : arr)\\n            if (i > 0)\\n                count++;\\n        int[][] result = new int[count][2];\\n        int index = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) continue;\\n            result[index][0] = i;\\n            result[index][1] = arr[i];\\n            index++;\\n        }", "class Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int m=nums1.length,n=nums2.length;\\n        int i=0,j=0,c=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                c++;\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int m=nums1.length,n=nums2.length;\\n        int i=0,j=0,c=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                c++;\\n                i++;\\n                j++;\\n            }"]}
{"id": "548", "ref_java": ["class Solution {\\n    public int[] leftRightDifference(int[] arr) {\\n        int n=arr.length;\\n        int[] prefix=new int[n];\\n        int[] suffix=new int[n];\\n        prefix[0]=0;\\n        suffix[n-1]=0;\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+arr[i-1];\\n        }", "class Solution {\\n    public int[] leftRigthDifference(int[] nums) {\\n      int[] leftSum = new int[nums.length];\\n      int[] rightSum = new int[nums.length];\\n      int[] answer = new int[nums.length];\\n      if(nums.length == 1){\\n          answer[0] = 0;\\n      }", "class Solution {\\n    public int[] leftRightDifference(int[] nums) {\\n        int[] sum=new int[nums.length];\\n        int leftsum,rightsum;\\n        leftsum=rightsum=0;\\n\\n        "]}
{"id": "549", "ref_java": ["class Solution {\\n  public int splitNum(int num) {\\n    StringBuilder sb1 = new StringBuilder();\\n    StringBuilder sb2 = new StringBuilder();\\n    char[] chars = String.valueOf(num).toCharArray();\\n\\n    Arrays.sort(chars);\\n\\n    for (int i = 0; i < chars.length; ++i)\\n      if (i % 2 == 0)\\n        sb1.append(chars[i]);\\n      else\\n        sb2.append(chars[i]);\\n\\n    return Integer.parseInt(sb1.toString()) + Integer.parseInt(sb2.toString());\\n  }", "class Solution {\\n  public int splitNum(int num) {\\n    StringBuilder sb1 = new StringBuilder();\\n    StringBuilder sb2 = new StringBuilder();\\n    char[] chars = String.valueOf(num).toCharArray();\\n\\n    Arrays.sort(chars);\\n\\n    for (int i = 0; i < chars.length; ++i)\\n      if (i % 2 == 0)\\n        sb1.append(chars[i]);\\n      else\\n        sb2.append(chars[i]);\\n\\n    return Integer.parseInt(sb1.toString()) + Integer.parseInt(sb2.toString());\\n  }", "class Solution {\\n    public int splitNum(int num) {\\n    char[] digit = String.valueOf(num).toCharArray();\\n    Arrays.sort(digit);\\n    System.out.println(Arrays.toString(digit));\\n\\n     StringBuilder a=new StringBuilder();\\n     StringBuilder b=new StringBuilder();\\n        for(int i=0;i<digit.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                a.append(digit[i]);\\n            }"]}
{"id": "550", "ref_java": ["class Solution {\\n    public int passThePillow(int n, int time) {\\n    ", "class Solution {\\n    public int passThePillow(int n, int time) {\\n        int curr=1;\\n        int currTime=0;\\n        while (currTime<time) {\\n            while (curr<n && currTime<time) {\\n                curr+=1;\\n                currTime++;\\n            }", "class Solution {\\n    public int passThePillow(int n, int time) {\\n        int num=(time/(n-1));\\n        if(n>time){\\n            return time+1;\\n        }"]}
{"id": "551", "ref_java": ["class Solution {\\n    public int vowelStrings(String[] words, int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            String a = words[i];\\n\\n            if (a.charAt(0) == \\'a\\' || a.charAt(0) == \\'e\\' || a.charAt(0) == \\'i\\' || a.charAt(0) == \\'o\\' || a.charAt(0) == \\'u\\') {\\n                if (a.charAt(a.length() - 1) == \\'a\\' || a.charAt(a.length() - 1) == \\'e\\' || a.charAt(a.length() - 1) == \\'i\\' || a.charAt(a.length() - 1) == \\'o\\' || a.charAt(a.length() - 1) == \\'u\\') {\\n                    count++;\\n                }", "class Solution {\\n    public int vowelStrings(String[] words, int left, int right) {\\n        ", "class Solution {\\n    public int vowelStrings(String[] words, int left, int right) {\\n        int count = 0;\\n        for(int i = left; i <= right; i++) {\\n            if(isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length() - 1))) {\\n                count++;\\n            }"]}
{"id": "552", "ref_java": ["class Solution {\\n    public int distMoney(int money, int children) {\\n        if(money<children)return -1;\\n        money-=children;\\n        int count=money/7;\\n        int mod=money%7;\\n        if(mod==3&&count==children-1)return count-1;\\n        if((count==children&&mod!=0))return count-1;\\n        if(count>children)return children-1;\\n        return count;\\n    }", "class Solution {\\n    public int distMoney(int money, int children) {\\n        if(money < children){\\n            return -1;\\n        }", "class Solution {\\n    public int distMoney(int money, int n) {\\n        if(money < n){\\n            return -1;\\n        }"]}
{"id": "553", "ref_java": ["class Solution {\\n    public int[] evenOddBit(int n) {\\n        String str1 = Integer.toBinaryString(n);\\n\\t\\t\\t\\tStringBuffer sc = new StringBuffer(str1);\\n\\t\\t\\t\\tsc.reverse();\\n\\t\\t\\t\\tString str =sc.toString();\\n\\t    \\n\\t    int Even_count = 0;\\n\\t    int Odd_count = 0;\\n\\t    int[] arr = new int[2];\\n\\t    \\n\\t    for(int i=0 ; i<str.length();i++){\\n\\t        if((str.charAt(i) == \\'1\\') && i%2==0){\\n\\t            Even_count++;\\n\\t        }", "class Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int even = 0;\\n        int odd = 0;\\n\\n        int idx = 0;\\n\\n        while (n > 0) {\\n\\n            ", "class Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0;\\n        int odd=0;\\n        String str=Integer.toBinaryString(n);\\n        String rev=reverse(str);\\n        for(int i=0;i<rev.length();i++){\\n            if(rev.charAt(i)==\\'1\\' && i%2==0){\\n                even++;\\n            }"]}
{"id": "554", "ref_java": ["class Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n     return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);   \\n    }", "class Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans[]=new int[numOnes+numZeros+numNegOnes];\\n        int i=0;\\n        while(numOnes>0){\\n            ans[i++]=1;\\n            numOnes--;\\n        }", "class Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans[]=new int[numOnes+numZeros+numNegOnes];\\n        int i=0;\\n        while(numOnes>0){\\n            ans[i++]=1;\\n            numOnes--;\\n        }"]}
{"id": "555", "ref_java": ["class Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int temp = getCommon(nums1, nums2);\\n        if(temp > 0) return temp;\\n        int a = getMinimum(nums1);\\n        if(isPresent(nums2, a)){\\n            return a;\\n        }", "class Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int a;\\n        for (int i = 0; i < nums1.length; i++) {\\n            a = nums1[i];\\n            for (int j = 0; j < nums2.length; j++) {\\n                if (a == nums2[j]) {\\n                    return a;\\n                }", "class Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\t   "]}
{"id": "556", "ref_java": ["class Solution {\\n    public boolean Check(String st){\\n        int L=st.length();\\n        if(L%2==1)\\n            return false;\\n        for(int i=0;i<L;i++){\\n            if(i<L/2 && st.charAt(i)!=\\'0\\'){\\n                return false;\\n            }", "class Solution {\\n    public int findTheLongestBalancedSubstring(String s) {\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                int no_zero=0;\\n                int no_one=0;\\n            for(int j=i;j<s.length();j++){\\n                if(no_one>0 && s.charAt(j)==\\'0\\'){\\n                    i=j-1;\\n                    break;\\n                }", "class Solution {\\n    public int findTheLongestBalancedSubstring(String s) {\\n        int zeroCount = 0;\\n        int oneCount = 0;\\n        int totalMax = Integer.MIN_VALUE;\\n        int i = 0;\\n        while (i < s.length()) {\\n            while (i < s.length() && s.charAt(i) == \\'0\\') {\\n                zeroCount++;\\n                i++;\\n            }"]}
{"id": "557", "ref_java": ["class Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        fill();\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (p[nums[i][i]]) {\\n                max = Math.max(max, nums[i][i]);\\n            }", "class Solution {\\n\\n\\n\\n    public int diagonalPrime(int[][] nums) {\\n\\n        ", "class Solution {\\n    public static boolean prime(int n){\\n    if (n<=1){\\n        return false;\\n    }"]}
{"id": "565", "ref_java": ["class Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int [] arr = new int[grid[0].length];\\n        for(int i=0; i<grid[0].length; i++){\\n            for(int j=0; j<grid.length; j++){\\n                arr[i] = Math.max(arr[i],String.valueOf(grid[j][i]).length());\\n            }", "class Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans[]=new int[n];\\n        \\n        for(int j=0;j<n;j++){\\n            int max=1;\\n            for(int i=0;i<m;i++){\\n                int len=find(Math.abs(grid[i][j]));\\n                if(grid[i][j]<0){\\n                    len=len+1;\\n                }", "class Solution {\\n    public int[] findColumnWidth(int[][] grid) {\\n        "]}
{"id": "566", "ref_java": ["class Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }", "class Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }", "class Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }"]}
{"id": "567", "ref_java": ["class Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }", "class Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }", "class Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }"]}
{"id": "569", "ref_java": ["class Solution {\\n    public int findDelayedArrivalTime(int arr, int del) {\\n        return (arr+del)%24;\\n    }", "class Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime+delayedTime)%24);\\n    }", "class Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = 24;\\n        int temp_time = arrivalTime + delayedTime;\\n        if(temp_time > time){\\n            temp_time = temp_time % time;\\n            return temp_time;\\n        }"]}
{"id": "570", "ref_java": ["class Solution {\\n    public int sumOfMultiples(int n) {\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i%3==0 || i%5==0 || i%7==0)\\n            s = s+i;\\n        }", "class Solution {\\n    public int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1; i<=n; i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum += i;\\n        }", "class Solution {\\n    public int sumOfMultiples(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0){\\n                sum+=i;\\n            }"]}
{"id": "571", "ref_java": ["class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i<nums.length; i++){ \\n            max = Math.max(max, nums[i]);\\n        }", "class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(max<nums[i]) max = nums[i];\\n        }", "class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n                int max = nums[0];\\n        for (int m: nums)\\n            max = Math.max(m, max);\\n        int sum = max++;\\n        for (int i = 0; i < k - 1; i++)\\n            sum += max++;\\n        return sum;\\n    }"]}
{"id": "572", "ref_java": ["class Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player1[i-1]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }", "class Solution {\\n    \\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int player1Score = calculateScore(player1);\\n        int player2Score = calculateScore(player2);\\n\\n        if (player1Score == player2Score)\\n            return 0;\\n\\n        return player1Score > player2Score ? 1 : 2;      \\n    }", "class Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player1[i-1]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }"]}
{"id": "576", "ref_java": ["class Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> prefix = new HashMap<>();\\n        HashMap<Integer,Integer> suffix = new HashMap<>();\\n        int[] ans = new int[nums.length];\\n        int[] prearr = new int[nums.length];\\n        int[] suffarr = new int[nums.length];\\n\\n        int k =0;\\n        int x = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j =0; j<=i; j++){\\n                if(!prefix.containsKey(nums[j])){\\n                    prefix.put(nums[j],1);\\n                }", "class Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int index = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int left = 0;\\n            int right = 0;\\n            for(int j = 0; j <= i; j++) {\\n                set.add(nums[j]);\\n            }", "class Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> hs = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                hs.add(nums[j]);\\n            }"]}
{"id": "578", "ref_java": ["class Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp=details[i];\\n            if(((temp.charAt(11)-\\'0\\')*10)+(temp.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }", "class Solution {\\n    public int countSeniors(String[] details) {\\n        int n,c=0;\\n        for (n=0;n<details.length;n++){\\n            int i=Integer.parseInt(details[n].substring(11,13));\\n            if(i>60) {\\n                 c++;\\n            }", "class Solution {\\n    public int countSeniors(String[] details) {\\n      int count = 0;\\n      for(String s : details) {\\n          int age = Integer.parseInt(s.substring(11, 13));\\n          if(age > 60) count ++;\\n      }"]}
{"id": "579", "ref_java": ["class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> gotBall = new HashSet<>();\\n        \\n        for(int i=1,mul=1;!gotBall.contains(i); i = (i+(k*mul))%n,mul++){\\n            gotBall.add(i);\\n        }", "class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        int i = 0;\\n        int x = 1;      \\n        while(!visited[(i + (x*k)) % n]) {\\n            visited[(i + (x*k)) % n] = true;\\n            i = (i + (x*k)) % n;\\n            x++;\\n        }", "class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        int i = 0;\\n        int x = 1;      \\n        while(!visited[(i + (x*k)) % n]) {\\n            visited[(i + (x*k)) % n] = true;\\n            i = (i + (x*k)) % n;\\n            x++;\\n        }"]}
{"id": "581", "ref_java": ["class Solution {\\n    public int minLength(String s) {\\n     \\n     StringBuilder s1=new StringBuilder(s);\\n     while(true)   \\n     {\\n         boolean checker=true;\\n         for(int i=0;i<s1.length()-1;i++)\\n         {\\n             char a=s1.charAt(i);\\n             char b=s1.charAt(i+1);\\n             if((a==\\'A\\' && b==\\'B\\')||(a==\\'C\\' && b==\\'D\\')){ \\n                 s1.deleteCharAt(i);\\n                 s1.deleteCharAt(i);\\n                 checker=false;\\n             }", "class Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")) {\\n            if(s.contains(\"AB\")) {\\n                int index = s.indexOf(\"AB\");\\n                s = s.substring(0, index) + s.substring(index + 2);\\n            }", "class Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")) {\\n            if(s.contains(\"AB\")) {\\n                int index = s.indexOf(\"AB\");\\n                s = s.substring(0, index) + s.substring(index + 2);\\n            }"]}
{"id": "582", "ref_java": ["class Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        for(int i=0; i<s.length()/2; i++){\\n            char c = (char)Math.min((int)s.charAt(i),(int)s.charAt(s.length()-1-i));\\n            s = s.substring(0,i) + c + s.substring(i+1,s.length()-i-1) + c + s.substring(s.length()-i);\\n        }", "class Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char arr[] = s.toCharArray();\\n        int i = 0;\\n        int j = arr.length - 1;\\n        while (i < j) {\\n            if (arr[i] < arr[j]) {\\n                arr[j--] = arr[i++];\\n            }", "class Solution {\\n    public String makeSmallestPalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            int j = n - i - 1;\\n            if (arr[i] != arr[j]) {\\n                arr[j] = arr[i] < arr[j] ? arr[i] : arr[j];\\n                arr[i] = arr[j];\\n            }"]}
{"id": "585", "ref_java": ["class Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int firstMinCost = Integer.MAX_VALUE;\\n        int secondMinCost = Integer.MAX_VALUE;\\n\\n        for (int p : prices) {\\n            if (p < firstMinCost) {\\n                secondMinCost = firstMinCost;\\n                firstMinCost = p;\\n            }", "class Solution {\\n    public int buyChoco(int[] arr, int key) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        int fin;\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = 0; j < arr.length; j++) {\\n                if (i != j ) {\\n                    int sum = arr[i] + arr[j];\\n                    ans = Math.min(ans, sum);\\n                }", "class Solution {\\n    public int BuyChoco(int[] prices, int money) {\\n        var (min1, min2) = (101, 101);\\n        for (int i = 0; i < prices.Length; i++){\\n            if (prices[i] < min1) {\\n                min2 = min1;\\n                min1 = prices[i];\\n            }"]}
{"id": "586", "ref_java": ["class Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }", "class Solution {\\n    public String removeTrailingZeros(String num) {\\n        int remove = 0;\\n\\n        for(int i = num.length() - 1; i > 0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                remove++;\\n            }", "class Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count = 0;\\n        int n = num.length();\\n        for(int i = n-1;i>=0;i--){\\n            char c = num.charAt(i);\\n            if(c==\\'0\\'){\\n                count++;\\n            }"]}
{"id": "588", "ref_java": ["class Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }", "class Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set =  new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }", "class Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }"]}
{"id": "589", "ref_java": ["class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }", "class Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }", "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }"]}
{"id": "595", "ref_java": ["class Solution {\\n    public boolean isFascinating(int n) {\\n        HashMap<Integer, Integer> m = new HashMap<>();\\n\\n        int a = 2*n;\\n        int b = 3*n;\\n        while(n >0){\\n            int r = n%10;\\n            if(m.containsKey(r) || r == 0){\\n                return false;\\n            }", "class Solution {\\n    public boolean isFascinating(int n) {\\n      String ans = String.valueOf(n) + String.valueOf(2*n) + String.valueOf(3*n);  \\n        ", "class Solution {\\n    public boolean isFascinating(int n) {\\n        int a = n*2;\\n        int b = n*3;\\n        String s = n+\"\"+a+\"\"+b;\\n\\n        if(s.length() < 8){\\n            return false;\\n        }"]}
{"id": "596", "ref_java": ["class Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n\\n        return Math.max(Math.min(Math.max(nums[0], nums[1]),nums[2]), Math.min(nums[0],nums[1]));\\n    }", "class Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n      for(int i=0; i<nums.length; i++ ) {\\n         if(nums[i]<min) {\\n            min = nums[i];\\n         }", "class Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int ans = -1;\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int max = nums[nums.length-1];\\n        for(int x:nums){\\n            if(x!=min && x!=max){\\n                ans = x;\\n                break;\\n            }"]}
{"id": "597", "ref_java": ["class Solution {\\n    public int distanceTraveled(int m, int a) {\\n        int ans=0;\\n        if(m<5)\\n            ans= m*10;\\n        else{\\n            while(m>0){\\n                if(m>=5){\\n                m=(m-5);\\n                ans+=(5*10);\\n                    if(a>=1){\\n                        m+=1;\\n                        a-=1;\\n                    }", "class Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n        int result =0;\\n        for(int i=1;i<=mainTank;i++){\\n            if(additionalTank!=0 && i%5==0){\\n                additionalTank-=1;\\n                result+=10;\\n                mainTank+=1;\\n            }", "class Solution {\\n    public int distanceTraveled(int mainTank, int additionalTank) {\\n      int dist = 0;\\n      while(mainTank > 0) {\\n          dist ++;\\n          mainTank --;\\n          if(dist != 0 && dist % 5 == 0 && additionalTank > 0) {\\n              additionalTank --;\\n              mainTank ++;\\n            }"]}
{"id": "598", "ref_java": ["class Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n        HashMap<String,Integer> arr = new HashMap<>();\\n\\n        for(int i=0 ;i<words.length;i++){\\n             String r = new StringBuilder(words[i]).reverse().toString();\\n            if(arr.containsKey(r)){\\n                arr.put(r, arr.get(r)+1);\\n            }", "class Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n        HashMap<String,Integer> arr = new HashMap<>();\\n\\n        for(int i=0 ;i<words.length;i++){\\n             String r = new StringBuilder(words[i]).reverse().toString();\\n            if(arr.containsKey(r)){\\n                arr.put(r, arr.get(r)+1);\\n            }", "class Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(reverse(words[j]))){\\n                   "]}
{"id": "599", "ref_java": ["class Solution {\\n   public static int countBeautifulPairs(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n        String st=\"\";\\n        st+=nums[i];\\n        System.out.println(st.length());\\n        int fd=nums[i]/(int)Math.pow(10, st.length()-1);\\n            for(int j=i+1;j<nums.length;j++){\\n                 String str=\"\";\\n                     str+=nums[j];\\n                    int ld=str.charAt(str.length()-1)-\\'0\\';\\n                 if(gcd(fd, ld)==1){\\n                   ", "class Solution {\\n    private int getFirst(int num){\\n        while(num > 9) num /= 10;\\n        return num;\\n    }", "class Solution {\\n    public int countBeautifulPairs(int[] nums) {\\n        int[] L = new int[10];\\n        L[nums[nums.length - 1] % 10]++;\\n        int count = 0;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            int first = nums[i];\\n            if (first > 9)  first /= ((first <= 99) ? 10 : ((first > 999) ? 1000 : 100));\\n            switch (first) {\\n                case 1: count += L[1] + L[2] + L[3] + L[4] + L[5] + L[6] + L[7] + L[8] + L[9];  break;\\n                case 2: count += L[1] +        L[3] +        L[5]        + L[7] +        L[9];  break;\\n                case 3: count += L[1] + L[2] +        L[4] + L[5] +        L[7] + L[8]       ;  break;\\n                case 4: count += L[1] +        L[3] +        L[5] +        L[7] +        L[9];  break;\\n                case 5: count += L[1] + L[2] + L[3] + L[4] +        L[6] + L[7] + L[8] + L[9];  break;\\n                case 6: count += L[1] +                      L[5] +        L[7]              ;  break;\\n                case 7: count += L[1] + L[2] + L[3] + L[4] + L[5] + L[6] +        L[8] + L[9];  break;\\n                case 8: count += L[1] +        L[3] +        L[5] +        L[7] +        L[9];  break;\\n                case 9: count += L[1] + L[2] +        L[4] + L[5] +        L[7] + L[8]       ;  break;\\n            }"]}
{"id": "600", "ref_java": ["class Solution {\\n    public static int findEven(int nums[], int ths, int i) {\\n        while(i < nums.length) {\\n            if(nums[i] <= ths && nums[i] % 2 == 0) break;\\n            i++;\\n        }", "class Solution {\\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\\n            int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                if(nums[i]%2==0 && nums[i]<=threshold)\\n                {int count=1;\\n                    int j=i+1;\\n                        int flag=0;\\n                        while(j<nums.length)\\n                        {\\n                                if(flag==0 && nums[j]%2!=0 && nums[j]<=threshold)\\n                                   {\\n                                        j++;\\n                                        flag=1;\\n                                        count++;\\n                                   }", "class Solution {\\n    public int longestAlternatingSubarray(List<Integer> nums, int x) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums.get(i) % 2 == 0 && nums.get(i) <= x) {\\n                int cnt = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (nums.get(j) % 2 != nums.get(j - 1) % 2 && nums.get(j) <= x) {\\n                        cnt++;\\n                    }"]}
{"id": "601", "ref_java": ["class Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.length == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i=2; i<=nums.length; i++){\\n            if(i == nums.length && nums[i-1] - nums[i-2] == 1){\\n                max = Math.max(max,2);\\n                break;\\n            }", "class Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.length == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i=2; i<=nums.length; i++){\\n            if(i == nums.length && nums[i-1] - nums[i-2] == 1){\\n                max = Math.max(max,2);\\n                break;\\n            }", "class Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans=0,i=0,temp=0;\\n        boolean a=false;\\n        for(i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]-nums[i] == 1 && a==false)\\n            {\\n                temp++;\\n                a=true;\\n            }"]}
{"id": "602", "ref_java": ["class Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int size = num + t;\\n        for(int i = 0; i < t; i++) size++;\\n        return size;\\n    }", "class Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        ", "class Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }"]}
{"id": "603", "ref_java": ["class Solution {\\n    public int sumOfSquares(int[] nums) {\\n        int sum =0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums.length%(i+1)==0){\\n                sum += nums[i] * nums[i]; \\n            }", "class Solution {\\n    public int sumOfSquares(int[] nums) {\\n        int sum = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++)\\n            if(n % (i + 1) == 0)\\n                sum += nums[i] * nums[i];\\n        return sum;\\n    }", "class Solution {\\n    public int sumOfSquares(int[] nums) {\\n        int ans = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums.length%(i+1)==0) ans+=(nums[i]*nums[i]);\\n        }"]}
{"id": "604", "ref_java": ["class Solution {\\n    public boolean isGood(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return false;\\n        }", "class Solution {\\n    public boolean isGood(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length-1;\\n        return nums[n]==n && nums[n-1]==n?true:false;\\n    }", "class Solution {\\n    public boolean isGood(int[] nums) {\\n        int n = nums[0];\\n        for(int num: nums) {\\n            if(num > n) {\\n                n = num;\\n            }"]}
{"id": "605", "ref_java": ["class Solution {\\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\\n        List<String> result = new ArrayList<>();\\n        for (String word : words) {\\n            StringBuilder text = new StringBuilder();\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c != separator)\\n                    text.append(c);\\n                else if (!text.isEmpty()){\\n                    result.add(text.toString());\\n                    text = new StringBuilder(); \\n                }", "class Solution {\\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\\n        List<String> result = new ArrayList<>();\\n        for (String word : words) {\\n            StringBuilder text = new StringBuilder();\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c != separator)\\n                    text.append(c);\\n                else if (!text.isEmpty()){\\n                    result.add(text.toString());\\n                    text = new StringBuilder(); \\n                }", "class Solution {\\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\\n        "]}
{"id": "606", "ref_java": ["class Solution {\\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\\n        int count=0;\\n        for(int i:hours)\\n        {\\n            if(i>=target)\\n            {\\n                count++;\\n            }", "class Solution {\\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\\n        int cnt = 0;\\n        for(int h: hours){\\n            if(h >= target) cnt++;\\n        }", "class Solution {\\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\\n        int cnt = 0;\\n        for (int it : hours) {\\n            if (it >= target)\\n                cnt++;\\n        }"]}
{"id": "607", "ref_java": ["class Solution {\\n    public int accountBalanceAfterPurchase(int amt) {\\n        if(amt%10 == 0)\\n        {\\n            return 100-amt;\\n        }", "class Solution {\\n    public int accountBalanceAfterPurchase(int purchaseAmount) {\\n        int x=purchaseAmount%10;\\n        int sum=0;\\n        if(x<5)\\n        {\\n            sum=purchaseAmount-x;\\n        }", "class Solution {\\n    public int accountBalanceAfterPurchase(int purchaseAmount) {\\n        int temp = purchaseAmount;\\n        \\n        int count1 = 0;   \\n        while(temp % 10 != 0) {\\n            count1++;\\n            temp -= 1;\\n        }"]}
{"id": "608", "ref_java": ["class Solution {\\n    public String finalString(String s) {\\n      StringBuilder sb=new StringBuilder();\\n\\t\\t for(int i=0;i<s.length();i++) {\\n\\t\\t\\t if(s.charAt(i)==\\'i\\') {\\n\\t\\t\\t\\t sb.reverse();\\n\\t\\t\\t }", "class Solution {\\n    public String finalString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'i\\'){\\n                sb.reverse(); ", "class Solution {\\n    public String finalString(String s) {\\n        StringBuilder sb = new StringBuilder(s.length());\\n        for (char c : s.toCharArray()) \\n            if (c == \\'i\\')  sb.reverse();  else  sb.append(c);\\n        return sb.toString();\\n    }"]}
{"id": "609", "ref_java": ["class Solution {\\n    public int getMaxDigit(int num){\\n        int maxDigit = 0;\\n        while(num>0){\\n            int lastDigit = num % 10;\\n            num/=10;\\n            if(maxDigit<lastDigit){\\n                maxDigit = lastDigit;\\n            }", "class Solution {\\n    ", "class Solution {\\n    public int maxSum(int[] nums) {\\n        int ans=-1;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                int res=nums[i]+nums[j];\\n                if(func(nums[i],nums[j]))\\n                    ans=Math.max(ans,res);\\n            }"]}
{"id": "610", "ref_java": ["class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode tail = dummyHead;\\n        int carry = 0;\\n\\n        while (l1 != null || l2 != null || carry != 0) {\\n            int digit1 = (l1 != null) ? l1.val : 0;\\n            int digit2 = (l2 != null) ? l2.val : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode newNode = new ListNode(digit);\\n            tail.next = newNode;\\n            tail = tail.next;\\n\\n            l1 = (l1 != null) ? l1.next : null;\\n            l2 = (l2 != null) ? l2.next : null;\\n        }", "class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode ans = new ListNode(-1);\\n        ListNode t = ans;\\n        int sum=0;\\n        int carry =0;\\n        while(l1!=null || l2!=null) {\\n            if(l1!=null) {\\n                sum+=l1.val;\\n                l1 = l1.next;\\n            }", "class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0); "]}
{"id": "611", "ref_java": ["class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        int n = s.length();\\n        int maxLength = 0;\\n        Set<Character> charSet = new HashSet<>();\\n        int left = 0;\\n        \\n        for (int right = 0; right < n; right++) {\\n            if (!charSet.contains(s.charAt(right))) {\\n                charSet.add(s.charAt(right));\\n                maxLength = Math.max(maxLength, right - left + 1);\\n            }", "class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        Set<Character>set=new HashSet<>();\\n        int maxLength=0;\\n        int left=0;\\n        for(int right=0;right<s.length();right++){\\n           \\n            if(!set.contains(s.charAt(right))){\\n                set.add(s.charAt(right));\\n                maxLength=Math.max(maxLength,right-left+1);\\n                \\n            }", "class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int i = 0;\\n        int j = 0;\\n        int max = 0;\\n        while(j < s.length()){\\n            map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);\\n            if(map.size() == j - i + 1){\\n                max = Math.max(max, j - i + 1);\\n                j++;\\n            }"]}
{"id": "612", "ref_java": ["class Solution {\\n    public String longestPalindrome(String s) {\\n        if (s.length() <= 1) {\\n            return s;\\n        }", "class Solution {\\n    int maxLen = 0;\\n    int lo = 0;\\n    public String longestPalindrome(String s) {\\n        char[] input = s.toCharArray();\\n        if(s.length() < 2) {\\n            return s;\\n        }", "class Solution {\\n    public String longestPalindrome(String s) {\\n       HashMap<Integer,String>h=new HashMap<>();\\n       \\n        for(int i=0;i<s.length();i++){\\n            char ci=s.charAt(i);\\n            for(int j=i+1;j<s.length();j++){\\n                char cj=s.charAt(j);\\n                if(ci==cj){\\n                    String ss=s.substring(i,j+1);\\n                    if(palindrome(ss)){\\n                        h.put(ss.length(),ss);\\n                    }"]}
{"id": "613", "ref_java": ["class Solution {\\n    public String convert(String s, int numRows) {\\n        int n = s.length();\\n        StringBuffer [] arr = new StringBuffer[numRows]; \\n        for(int i=0; i<numRows; i++) arr[i] = new StringBuffer();\\n\\n        int i=0;\\n        while(i<n){\\n            ", "class Solution {\\n    public String convert(String s, int numRows) {\\n        String[] strArr = new String[numRows];\\n        Arrays.fill(strArr, \"\");\\n        int j = 0;\\n        int i;\\n        while(j < s.length()){\\n            i = 0;\\n            while(i < numRows && j < s.length()){\\n                strArr[i++] += s.charAt(j++);\\n            }", "class Solution {\\n    public String convert(String inputString, int numRows) {\\n        if (numRows == 1) return inputString;\\n\\n        List<StringBuilder> rows = new ArrayList<>();\\n        for (int i = 0; i < Math.min(numRows, inputString.length()); i++) {\\n            rows.add(new StringBuilder());\\n        }"]}
{"id": "614", "ref_java": ["class Solution {\\n    public int reverse(int x) {\\n        int result = 0;\\n        \\n        while (x != 0) {\\n            int lastDigit = x % 10;\\n            \\n           \\n            if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && lastDigit > 7)) {\\n                return 0;\\n            }", "class Solution {\\n    public int reverse(int x) {\\n        int ans=0;\\n        boolean fg=false;\\n        if((x*-1)>0){\\n            fg=true;\\n            x=x*-1;\\n        }", "class Solution {\\n    "]}
{"id": "615", "ref_java": ["class Solution {\\n    public int myAtoi(String s) {\\n        s = s.trim();\\n        if (s.isEmpty()) {\\n            return 0;\\n        }", "class Solution {\\n    public int myAtoi(String s) {\\n        s = s.trim();\\n        if (s.isEmpty()) {\\n            return 0;\\n        }", "class Solution {\\n    public int myAtoi(String s) {\\n        int n = s.length();\\n        int i = 0;\\n        int sign = 1;\\n        while(i<n && s.charAt(i)==\\' \\') {\\n            i++;\\n        }"]}
{"id": "616", "ref_java": ["class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int maxArea = 0;\\n\\n        while (left < right) {\\n            int currentArea = Math.min(height[left], height[right]) * (right - left);\\n            maxArea = Math.max(maxArea, currentArea);\\n\\n            if (height[left] < height[right]) {\\n                left++;\\n            }", "class Solution {\\n    public int maxArea(int[] height) {\\n        int point1=0;\\n        int point2=height.length-1;\\n        int res=0;\\n        while(point1<point2){\\n            int min=Math.min(height[point1],height[point2]);\\n            int width=point2-point1;\\n            res=Math.max(res,min*width);\\n\\n\\n            if(height[point1]<height[point2]){\\n                      point1++;\\n            }", "class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0;\\n        int right = height.length - 1;\\n        int max = 0;\\n        while(left < right){\\n            int w = right - left;\\n            int h = Math.min(height[left], height[right]);\\n            int area = h * w;\\n            max = Math.max(max, area);\\n            if(height[left] < height[right]) left++;\\n            else if(height[left] > height[right]) right--;\\n            else {\\n                left++;\\n                right--;\\n            }"]}
{"id": "617", "ref_java": ["class Solution {\\n    public String intToRoman(int num) {\\n        String[] ones= {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"}", "class Solution {\\n    public String intToRoman(int num) {\\n        String[] ones= {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"}", "class Solution {\\n    public String intToRoman(int num) {\\n        String[] ones= {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"}"]}
{"id": "618", "ref_java": ["class Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\\n                int target = -nums[i];\\n                int left = i + 1;\\n                int right = nums.length - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        resultSet.add(Arrays.asList(nums[i], nums[left], nums[right]));\\n\\n                        while (left < right && nums[left] == nums[left + 1]) left++;\\n                        while (left < right && nums[right] == nums[right - 1]) right--;\\n\\n                        left++;\\n                        right--;\\n                    }", "class Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        int target = 0;\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++){\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n                }", "class Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        "]}
{"id": "619", "ref_java": ["class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k){\\n            int sum=nums[i]+nums[j]+nums[k];\\n             if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; \\n                }", "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; ", "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        "]}
{"id": "620", "ref_java": ["class Solution {\\n    private Map<Character, String> digitToLetters = new HashMap<>();\\n    private List<String> resultList = new ArrayList<>();\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return resultList;\\n        }", "class Solution {\\n    private Map<Character, String> digitToLetters = new HashMap<>();\\n    private List<String> resultList = new ArrayList<>();\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return resultList;\\n        }", "class Solution {\\n    private Map<Character, String> digitToLetters = new HashMap<>();\\n    private List<String> resultList = new ArrayList<>();\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return resultList;\\n        }"]}
{"id": "621", "ref_java": ["class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        long temp;\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (i == 0 || nums[i] != nums[i - 1]) {\\n                for (int j = i + 1; j < nums.length - 2; j++) {\\n                    if (j == i + 1 || nums[j] != nums[j - 1]) {\\n                        temp = (long) target - (long) nums[i] - (long) nums[j];\\n                        int k = j + 1;\\n                        int l = nums.length - 1;\\n\\n                        while (k < l) {\\n                            sum = (long) nums[k] + (long) nums[l];\\n\\n                            if (sum == temp) {\\n                                ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n\\n                                while (k < l && nums[l] == nums[l - 1])\\n                                    l--;\\n                                while (k < l && nums[k] == nums[k + 1])\\n                                    k++;\\n                                l--;\\n                                k++;\\n                            }", "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums); ", "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while (k < l) {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n                        k++;\\n                        l--;\\n                    }"]}
{"id": "622", "ref_java": ["class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }", "class Solution {\\n    public int sizeOfList(ListNode head){\\n        int count = 0;\\n        ListNode pTmp = head;\\n        while(pTmp != null){\\n            count ++;\\n            pTmp = pTmp.next;\\n        }", "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp = head;\\n        int size = 0;\\n\\n        while(temp != null) {\\n            size++;\\n            temp = temp.next;\\n        }"]}
{"id": "623", "ref_java": ["class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }", "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); \\n        generate(2*n, n, n, \"\", result);\\n        return result; \\n    }", "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        generate_parenthesis(ans,0,0,n,\"\");\\n        return ans;\\n    }"]}
{"id": "624", "ref_java": ["class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode node = head;\\n        ListNode next = head != null && head.next != null ? head.next : head;\\n        ListNode prev = null;\\n        while (node != null) {\\n            System.out.println(\"1\");\\n            if (node.next != null) {\\n                if (prev != null) {\\n                    prev.next = node.next;\\n                }", "class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }", "class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n       ListNode l=new ListNode(0);\\n       l.next=head;\\n       ListNode f=l;\\n       ListNode s=null;\\n       ListNode t=null;\\n       while(f.next!=null&&f.next.next!=null){\\n           s=f.next;\\n           t=f.next.next;\\n           s.next=t.next;\\n           t.next=s;\\n           f.next=t;\\n           f=s;\\n       }"]}
{"id": "625", "ref_java": ["class Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; ", "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }", "class Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; "]}
{"id": "626", "ref_java": ["class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        ", "class Solution {\\n\\t public void nextPermutation(int[] nums) {\\n\\t        ", "class Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }"]}
{"id": "627", "ref_java": ["class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }", "class Solution { \\n\\n    private int binary(int[] a,int i,int j,int k){\\n        if(i<=j){\\n            int m=(i+j)/2;\\n            if(a[m]==k)\\n                return m;\\n            if(a[m]>k)\\n                return binary(a,i,m-1,k);\\n            else \\n                return binary(a,m+1,j,k);\\n        }", "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int l = 0;\\n        int r = n  - 1;\\n\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n\\n            if(nums[mid] == target) {\\n                return mid;\\n            }"]}
{"id": "628", "ref_java": ["class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int ans [] = { -1,-1}", "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int first = -1, last = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                if (first == -1) {\\n                    first = i;\\n                }", "class Solution {\\n   \\n    public int[] searchRange(int[] nums, int target) {\\n        int first = -1, last = -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == target){\\n                if(first == -1){\\n                    first = i;\\n                }"]}
{"id": "629", "ref_java": ["class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] m = new boolean[9][9];\\n        boolean[][] m2 = new boolean[9][9];\\n        boolean[][] m3 = new boolean[9][9];\\n\\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\' - 1;\\n                    int k = i / 3 * 3 + j / 3;\\n\\n                    if (m[i][num] || m2[j][num] || m3[k][num])\\n                        return false;\\n\\n                    m[i][num] = m2[j][num] = m3[k][num] = true;\\n                }", "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if( c >=\\'0\\' && c <= \\'9\\' && !isValid(board, i, j)) return false; \\n            }", "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] m = new boolean[9][9];\\n        boolean[][] m2 = new boolean[9][9];\\n        boolean[][] m3 = new boolean[9][9];\\n\\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\' - 1;\\n                    int k = i / 3 * 3 + j / 3;\\n\\n                    if (m[i][num] || m2[j][num] || m3[k][num])\\n                        return false;\\n\\n                    m[i][num] = m2[j][num] = m3[k][num] = true;\\n                }"]}
{"id": "630", "ref_java": ["class Solution {\\n    public String countAndSay(int n) {\\n        String[] result = new String[n];\\n        result[0] = \"1\";\\n        for(int i=1; i<n; i++){\\n            result[i] = countAndSayOutput(result[i-1].toCharArray());\\n        }", "class Solution {\\n    public String countAndSay(int n) {\\n        \\n        ", "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1)\\n        {\\n            return \"1\";\\n        }"]}
{"id": "631", "ref_java": ["class Solution {\\n     List<List<Integer>> l=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n       help(0,target,new ArrayList<>(),candidates);\\n       return l;\\n    \\n    }", "class Solution {\\n     List<List<Integer>> l=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n       help(0,target,new ArrayList<>(),candidates);\\n       return l;\\n    \\n    }", "class Solution {\\n    public void backTrack(List<List<Integer>> result,LinkedList<Integer> lst,int idx,int[] arr,int sum)\\n    {\\n        if(sum == 0)\\n        {\\n            result.add(new ArrayList(lst));\\n            return;\\n        }"]}
{"id": "632", "ref_java": ["class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }", "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }", "class Solution {\\n    List<List<Integer>> ans;\\n    int candidates[];\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        "]}
{"id": "633", "ref_java": ["class Solution {\\n        public String multiply(String num1, String num2) {\\n            int n1 = num1.length(), n2 = num2.length();\\n            int[] products = new int[n1 + n2];\\n            for (int i = n1 - 1; i >= 0; i--) {\\n                for (int j = n2 - 1; j >= 0; j--) {\\n                    int d1 = num1.charAt(i) - '0';\\n                    int d2 = num2.charAt(j) - '0';\\n                    products[i + j + 1] += d1 * d2;\\n                }", "class Solution {\\n        public String multiply(String num1, String num2) {\\n            int n1 = num1.length(), n2 = num2.length();\\n            int[] products = new int[n1 + n2];\\n            for (int i = n1 - 1; i >= 0; i--) {\\n                for (int j = n2 - 1; j >= 0; j--) {\\n                    int d1 = num1.charAt(i) - '0';\\n                    int d2 = num2.charAt(j) - '0';\\n                    products[i + j + 1] += d1 * d2;\\n                }", "class Solution {\\n    public String multiply(String num1, String num2) {\\n\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        BigInteger n3 = n1.multiply(n2);\\n\\n        return n3.toString();\\n\\n    }"]}
{"id": "634", "ref_java": ["class Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    ", "class Solution {\\n    public int jump(int[] nums) {\\n         int n = nums.length,ans = 0, curr = 0, y = 0;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            y = Math.max(y, i + nums[i]);\\n            if (i == curr) {\\n                ans++;\\n                curr = y;\\n                if (curr >= n - 1) break; \\n            }", "class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length==1){\\n            return 0;\\n        }"]}
{"id": "635", "ref_java": ["class Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> permute(int[] nums) {\\n        result = new ArrayList<>();\\n        helper(new ArrayList<>(), nums);\\n        return result;\\n    }", "class Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> permute(int[] nums) {\\n        result = new ArrayList<>();\\n        helper(new ArrayList<>(), nums);\\n        return result;\\n    }", "class Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    void solve(int[] nums, int[] per, int c) {\\n        if (c == nums.length) {\\n            List<Integer> permutation = new ArrayList<>();\\n            for (int num : per) {\\n                permutation.add(num);\\n            }"]}
{"id": "636", "ref_java": ["class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }", "class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }", "class Solution {\\n    "]}
{"id": "637", "ref_java": ["class Solution {\\n    public void Rotate(int[][] matrix) {\\n\\n        ", "class Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                int swap = matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=swap;\\n            }", "class Solution {\\n    public void rotate(int[][] matrix) {\\n        int n  = matrix.length;\\n        int[][] copy = new int[n][n];\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                copy[i][j] = matrix[i][j];\\n            }"]}
{"id": "638", "ref_java": ["class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }", "class Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }", "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }"]}
{"id": "639", "ref_java": ["class Solution {\\n    public double myPow(double x, int n) {\\n      return Math.pow(x,n);\\n    }", "class Solution {\\n    public double myPow(double x, int n) {\\n      return Math.pow(x,n);\\n    }", "class Solution {\\n    public double myPow(double x, int n) {\\n        \\n        "]}
{"id": "640", "ref_java": ["class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }", "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            max = Math.max(sum,max);\\n            \\n            if(sum<0) sum = 0;\\n        }", "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }"]}
{"id": "641", "ref_java": ["class Solution {\\n    static List<Integer> traverse(int[][] arr, int i, int j, List<Integer> list){\\n        if(arr[i][j] != Integer.MIN_VALUE){\\n            list.add(arr[i][j]);\\n            arr[i][j] = Integer.MIN_VALUE;  \\n        }", "class Solution {\\n    List<Integer> res = new ArrayList<>();\\n    int[][] matrix;\\n    int m;\\n    int n;\\n    \\n    private void borderFrom(int r, int c) {\\n        for (int i = c; i <= c + n - 1; i++) {\\n            res.add(matrix[r][i]);\\n        }", "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int row = matrix.length;\\n        List<Integer> ans = new ArrayList<>();\\n        if(row<1){\\n            return ans;\\n        }"]}
{"id": "642", "ref_java": ["class Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       }", "class Solution {\\n    public boolean canJump(int[] nums) {\\n\\n        int currEnd = 0;\\n        int currFar = 0;\\n\\n        int length = nums.length - 1;\\n        for(int i=0; i<length; i++) {\\n            currFar = Math.max(currFar, i + nums[i]);\\n\\n            if(i == currEnd) {\\n                if(currFar > currEnd) {\\n                    currEnd = currFar;\\n                }", "class Solution {\\n    public boolean canJump(int[] arr) {\\n        int maxPos = 0;\\n        for (int pos = 0; pos < arr.length; pos++) {\\n            if (pos > maxPos) {\\n                return false; "]}
{"id": "643", "ref_java": ["class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}", "class Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length == 1) {\\n            return intervals;\\n        }", "class Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            }"]}
{"id": "644", "ref_java": ["class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if(intervals.length == 0) return new int[][]{newInterval}", "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if(intervals.length == 0) return new int[][]{newInterval}", "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if(intervals.length == 0) return new int[][]{newInterval}"]}
{"id": "645", "ref_java": ["class Solution {\\n    public int[][] generateMatrix(int n) {\\n        ", "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        ", "class Solution {\\n    static int[][] generateMatrix(int n) {\\n        int[][] spiralMatrix = new int[n][n];\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = n - 1;\\n        int endingCol = n - 1;\\n\\n        int count = 1;\\n        int totalcount = n * n;\\n\\n        while (count <= totalcount) {\\n            "]}
{"id": "646", "ref_java": ["class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode i=head;\\n        int n=0;\\n        ", "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || k == 0) {\\n            return head;\\n        }", "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int count = 0;\\n        ListNode t = head;\\n        while (t!=null) {       "]}
{"id": "647", "ref_java": ["class Solution {\\n    public int uniquePaths(int m, int n) {\\n        long ans = 1;\\n        for (int i = 1; i <= m - 1; i++) {\\n            ans = ans * (n - 1 + i) / i;\\n        }", "class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for(int row = 0; row < m; row++)\\n            dp[row][0] = 1;", "class Solution {\\n\\n\\n    static int helper(int m, int n, int[][] dp){\\n        int a = dp.length;\\n        int b = dp[0].length;\\n        if(m>=a || n>=b) return 0;\\n        if(m==a-1 || n==b-1){\\n            return dp[m][n]=1;\\n        }"]}
{"id": "648", "ref_java": ["class Solution {\\n\\n    static int helper2(int arr[][]){\\n        int m = arr.length;\\n        int n = arr[0].length;\\n\\n        int dp[][] = new int[m+1][n+1];\\n        for(var a : dp) Arrays.fill(a,0);\\n        dp[m-1][n-1] = 1;\\n    \\n        for(int i=m-1; i>=0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (i == m - 1 && j == n - 1) continue;\\n                if (arr[i][j] == 1) dp[i][j] = 0;\\n                else dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\\n            }", "class Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for(int[] a : dp)\\n            Arrays.fill(a,1);\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }", "class Solution {\\n    \\n  public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n    int m = obstacleGrid.length;\\n    int n = obstacleGrid[0].length;\\n    int dp[] = new int[n];\\n    dp[0] = obstacleGrid[0][0] == 0 ? 1 : 0;\\n    for (int i = 1; i < n; i++) {\\n      dp[i] = obstacleGrid[0][i] == 0 ? dp[i - 1] : 0;\\n    }"]}
{"id": "649", "ref_java": ["class Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }", "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        ", "class Solution {\\n    public int minPathSum(int[][] grid) {\\n     /*\\nint m=grid.length;\\nint n=grid[0].length;\\nreturn f(m-1,n-1,grid);\\n    }"]}
{"id": "650", "ref_java": ["class Solution {\\n    public String simplifyPath(String path) {\\n        ", "class Solution {\\n    public String simplifyPath(String path) {\\n      String[] parts=path.split(\"/\");\\n      StringBuilder spath=new StringBuilder();\\n       for(String part: parts){\\n           if(part.isEmpty() || part.equals(\".\")){\\n               continue;\\n           }", "class Solution {\\n    public String simplifyPath(String s) {\\n        Stack<String> st = new Stack<>();\\n\\n        int i = 0;\\n        String str = \"\";\\n\\n        while (i < s.length()) {\\n            if (s.charAt(i) != \\'/\\') {\\n                str += s.charAt(i);\\n            }"]}
{"id": "651", "ref_java": ["class Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();", "class Solution {\\n    public int minDistance(String word1, String word2) {\\n        ", "class Solution {\\n    public int minDistance(String word1, String word2) {\\n\\n        if (word1.length()== 0){\\n            return word2.length();\\n        }"]}
{"id": "652", "ref_java": ["class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }", "class Solution {\\n    public void setZeroes(int[][] A) \\n    {\\n       \\n       int row=A.length;\\n        int col=A[0].length;\\n        int x=1,y=1;\\n        for(int i=0;i<col;i++){\\n            if(A[0][i]==0){\\n                x=0;\\n               break;}", "class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }"]}
{"id": "653", "ref_java": ["class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        ", "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int i=0,j=col-1;\\n        while(i>=0 && i<row && j>=0 && j<col)\\n        {\\n            if(matrix[i][j]==target){\\n            return true;\\n        }", "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        "]}
{"id": "654", "ref_java": ["class Solution {\\n  public void sortColors(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    for (int i = 0; i <= r;)\\n      if (nums[i] == 0)\\n        swap(nums, i++, l++);\\n      else if (nums[i] == 1)\\n        ++i;\\n      else\\n        swap(nums, i, r--);\\n  }", "class Solution {\\n    public int[] sortColors(int[] nums) {\\n        ", "class Solution {\\n    public void sortColors(int[] nums) {\\n        int left = 0;\\n        for (int right = 0; right < nums.length; right++) {\\n            if (nums[right] == 0) {\\n                swap(nums, left, right); left++;\\n            }"]}
{"id": "655", "ref_java": ["class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> li=new ArrayList<List<Integer>>();\\n        for(int i=0;i<Math.pow(2,n);i++){\\n            int count=0;\\n            List<Integer> l=new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                if((i>>j)%2==1){\\n                    count++;\\n                    l.add(j+1);\\n                }", "class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n\\n        int low, high;\\n        if(k>n/2){\\n            low=k;\\n            high=n-k;\\n        }", "class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> ans =new ArrayList<>();\\n        List<Integer>path= new ArrayList<>();\\n        int arr[]=new int[n];\\n        for(int i =1;i<=n;i++)\\n              arr[i-1]=i;\\n\\n        solve(arr,ans,path,0,n,k);\\n        return ans;\\n    }"]}
{"id": "656", "ref_java": ["class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>(); \\n\\n        solution(nums, result, list, nums.length, 0);\\n        return result; \\n    }", "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>(); \\n\\n        solution(nums, result, list, nums.length, 0);\\n        return result; \\n    }", "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> set = new ArrayList<>(nums.length);\\n        List<List<Integer>> subsets = new ArrayList<>((int)Math.pow(2, nums.length));\\n        findSubsets(0, nums, set, subsets);\\n        return subsets;\\n    }"]}
{"id": "657", "ref_java": ["class Solution {\\n\\n    public boolean exist(char[][] board, String word) {\\n        int R = board.length;\\n        int C = board[0].length;\\n        for(int r = 0; r < R; r++) {\\n            for(int c = 0; c < C; c++) {\\n                if(dfs(r, c, 0, word, board)) {\\n                    return true;\\n                }", "class Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length, n = board[0].length;\\n        if (m*n < word.length())\\n            return false;\\n        char[] wrd = word.toCharArray();\\n        int[] boardf = new int[128];\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ++boardf[board[i][j]];\\n            }", "class Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] board2 = new boolean[board.length][board[0].length];\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if(board[i][j]==word.charAt(0)){\\n                    if(wordSearch(board,i,j,word.substring(1),board2)){\\n                        return true;\\n                    }"]}
{"id": "658", "ref_java": ["class Solution {\\n  public int removeDuplicates(int[] nums) {\\n    int i = 0;\\n\\n    for (final int num : nums)\\n      if (i < 2 || num > nums[i - 2])\\n        nums[i++] = num;\\n\\n    return i;\\n  }", "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }", "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        int count=1,i=1;\\n        for(int j=1;j<n;j++){\\n            if(count<2 && nums[j]==nums[j-1]){\\n                nums[i]=nums[j];\\n                count++;\\n                i++;\\n            }"]}
{"id": "659", "ref_java": ["class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }", "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target) return true;\\n\\n            if (nums[low] == nums[mid]) {\\n                low++;\\n                continue;\\n            }", "class Solution {\\n    public boolean search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(nums[mid]==target) return true;\\n            \\n            if(nums[low]==nums[mid] && nums[mid]==nums[high]){\\n                low+=1;\\n                high-=1;\\n                continue;\\n            }"]}
{"id": "660", "ref_java": ["class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode newHead = null;\\n        ListNode tail = null;\\n        int data = Integer.MIN_VALUE;\\n        ListNode temp = head;\\n\\n        while (temp != null) {\\n            if (temp.next != null && temp.val == temp.next.val) {\\n                data = temp.val;\\n                temp = temp.next;\\n                continue;\\n            }", "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }", "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }"]}
{"id": "661", "ref_java": ["class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            }", "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode s_head = new ListNode(0);\\n        ListNode small = s;\\n        ListNode b_head = new ListNode(0);\\n        ListNode big = b;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                small.next = head;\\n                small = small.next;\\n            }", "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode low=new ListNode(0);\\n        ListNode start=low;\\n        ListNode high=new ListNode(0);\\n        ListNode mid=high;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            if(temp.val<x){\\n                low.next=temp;\\n                temp=temp.next;\\n                low=low.next;\\n                low.next=null;\\n            }"]}
{"id": "662", "ref_java": ["class Solution {\\n    private List<Integer> grayCode = new ArrayList<>();\\n    private final Set<Integer> visited = new HashSet<>();\\n    public List<Integer> grayCode(int n) {\\n        backTrack(0, new ArrayList<>(), n, (int) Math.pow(2, n));\\n        return grayCode;\\n    }", "class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }", "class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res=new ArrayList<>();\\n        res.add(0);\\n        if(n==0) return res;\\n        res.add(1);\\n        int curr=1;\\n        for(int i=2;i<=n;i++){\\n            curr*=2;\\n            for(int j=res.size()-1;j>=0;j--)\\n                res.add(curr+res.get(j));\\n        }"]}
{"id": "663", "ref_java": ["class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        Arrays.sort(nums);\\n        helper(list,temp,nums,0);\\n        return list;\\n    }", "class Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> ds = new ArrayList<>();\\n        getsubsets( 0, nums, ds);\\n        return ans;\\n    }", "class Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        Arrays.sort(nums);\\n        helper(list,temp,nums,0);\\n        return list;\\n    }"]}
{"id": "664", "ref_java": ["class Solution {\\n    public int numDecodings(String s) {\\n        return recursiveDecode(s, 0);\\n    }", "class Solution {\\n    public int numDecodings(String s) {\\n        if (s == null || s.length() == 0 || s.charAt(0) == \\'0\\') {\\n            return 0;\\n        }", "class Solution {\\n    public int numDecodings(String s) {\\n        int n=s.length() ;\\n        int[] dp=new int[n+1] ;\\n        dp[n]=1 ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n            if(s.charAt(i)!=\\'0\\') \\n            {\\n                dp[i] = dp[i+1] ;\\n                if(i < n-1 && (s.charAt(i)==\\'1\\' || s.charAt(i)==\\'2\\' && s.charAt(i+1)<\\'7\\')) \\n\\t\\t\\t\\t    dp[i]+=dp[i+2];\\n            }"]}
{"id": "665", "ref_java": ["class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next==null || right==left) return head;\\n        boolean check = false;\\n        ListNode Pleft = null;\\n        ListNode Pright = null;\\n        ListNode Tleft = null;\\n        ListNode Tright = null;\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            if(count==left-1)   Pleft = curr;\\n            if(count==right+1)  Pright = curr;          \\n            if(count==left)     Tleft = curr;\\n            if(count==right)    Tright = curr;\\n            curr = curr.next;\\n        }", "class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode start, end;\\n        start = new ListNode();\\n        start.next = head;\\n        for(int i = 0; i< left-1 && start != null; i++){\\n            start = start.next;\\n        }", "class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right)\\n        {\\n            return head;\\n        }"]}
{"id": "666", "ref_java": ["class Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<Integer>(), res);\\n\\n        return res;\\n    }", "class Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        helper(0, 0, \"\", s, ans);\\n        return ans;\\n    }", "class Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        Set<String> ls = new HashSet<>();\\n        getIpAddresses(s, ls, \"\", 0, false,-1,0);\\n        return new ArrayList(ls);\\n    }"]}
{"id": "667", "ref_java": ["class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return f(1, n, dp);\\n    }", "class Solution {\\n    List<TreeNode> ans;\\n    HashSet<String> hs;\\n    public List<TreeNode> generateTrees(int n) {\\n        List<List<Integer>> A=new ArrayList<>();\\n        ans=new ArrayList<>();\\n        hs=new HashSet<>();\\n        int a[]=new int[n];\\n        for(int i=0;i<n;i++)a[i]=i+1;\\n        permute(0,a,A);\\n        for(List<Integer> tmp:A)\\n        {\\n            bst(tmp);\\n        }", "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return f(1, n, dp);\\n    }"]}
{"id": "668", "ref_java": ["class Solution {\\n    public int numTrees(int n) {\\n        int dp[] = new int[n+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            int x=0;\\n            int y = i-1;\\n            int sum=0;\\n            while(x<i&&y>=0) {\\n                sum+=dp[x]*dp[y];\\n                x++;\\n                y--;\\n            }", "class Solution {\\n    public int numTrees(int n) {\\n        int[] dp=new int[n+1];\\n        ", "class Solution {\\n    public int numTrees(int n) {\\n        int[] dp=new int[n+1];\\n        "]}
{"id": "669", "ref_java": ["class Solution {\\n    public static boolean dfs(char c1[], char c2[], char c3[], int i, int j, int k, boolean dp[][]) {\\n        if (dp[i][j]) {\\n            return false;\\n        }", "class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n           int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }", "class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\\n        }"]}
{"id": "670", "ref_java": ["class Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}", "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }", "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }"]}
{"id": "671", "ref_java": ["class Solution {\\n    public void recoverTree(TreeNode root) {\\n        TreeNode prev = null;\\n        TreeNode current = root;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        while (current != null) {\\n            if (current.left != null) {\\n                TreeNode temp = current.left;\\n                while (temp.right != null && temp.right != current) {\\n                    temp = temp.right;\\n                }", "class Solution {\\n    private TreeNode first;\\n    private TreeNode last;\\n    private TreeNode prev;\\n    private TreeNode middle;\\n    private void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        if(prev!=null && (root.val<prev.val)){\\n\\n        if(first==null){    \\n            first=prev;\\n            middle=root;\\n        }", "class Solution {\\n    private TreeNode first;\\n    private TreeNode last;\\n    private TreeNode prev;\\n    private TreeNode middle;\\n    private void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        if(prev!=null && (root.val<prev.val)){\\n\\n        if(first==null){    \\n            first=prev;\\n            middle=root;\\n        }"]}
{"id": "672", "ref_java": ["class Solution {\\n    public List<List<Integer>> levelOrder(TreeNode root) \\n    {\\n        List<List<Integer>>al=new ArrayList<>();\\n        pre(root,0,al);\\n        return al;\\n    }", "class Solution {\\n    public List<List<Integer>> levelOrder(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<List<Integer>> finalAns = new ArrayList<List<Integer>>();\\n        if(root==null){\\n            return finalAns;\\n        }", "class Solution {\\n    public List<List<Integer>> levelOrder(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        List<List<Integer>> wrap = new LinkedList<List<Integer>>();\\n        if(root==null) return wrap;\\n        queue.add(root);\\n        while(!queue.isEmpty()){\\n            List<Integer> list = new LinkedList<>();\\n            int num = queue.size();\\n            for(int i=0; i<num; i++){\\n                if(queue.peek().left!=null) queue.add(queue.peek().left);\\n                if(queue.peek().right!=null) queue.add(queue.peek().right);\\n                list.add(queue.remove().val);\\n            }"]}
{"id": "673", "ref_java": ["class Solution {\\n    public List<List<Integer>> levelorder(TreeNode root,List<List<Integer>> ans,int level){\\n           if(root == null)\\n            return ans;\\n        \\n        if(ans.size() == level)\\n            ans.add(new ArrayList<>());\\n        \\n        ans.get(level).add(root.val);\\n        levelorder(root.left, ans,level+1);\\n        levelorder(root.right, ans,level+1);\\n\\n        return ans;\\n    }", "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n      List<List<Integer>> answer = new LinkedList<>();\\n      if (root == null) return answer;\\n      Queue<TreeNode> q = new LinkedList<>();\\n      q.add(root);\\n      boolean flag = true;\\n      while (q.size() > 0) {\\n        int size = q.size();\\n        LinkedList<Integer> l = new LinkedList<>();\\n        for (int i = 0; i < size; i++) {\\n          TreeNode temp = q.remove();\\n          if (flag) l.addLast(temp.val);\\n          else l.addFirst(temp.val);\\n          if (temp.left != null) q.add(temp.left);\\n          if (temp.right != null) q.add(temp.right);\\n        }", "class Solution {\\n    "]}
{"id": "674", "ref_java": ["class Solution {\\n    private int i = 0;\\n    private int p = 0;\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return build(preorder, inorder, Integer.MIN_VALUE);\\n    }", "class Solution {\\n\\n    class Index {\\n        int val;\\n        Index() {\\n            this.val = 0;\\n        }", "class Solution {\\n\\n    class Index {\\n        int val;\\n        Index() {\\n            this.val = 0;\\n        }"]}
{"id": "675", "ref_java": ["class Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            map.put(inorder[i], i);\\n        }", "class Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }", "class Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        final var length = postorder.length;\\n        final var map = new HashMap<Integer, Integer>();\\n        for(int i=0; i<length; i++) {   \\n            map.put(inorder[i], i);\\n        }"]}
{"id": "676", "ref_java": ["class Solution {\\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\\n        List<List<Integer>> x = new ArrayList<>();\\n        if(root == null) return x;\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.add(root);\\n\\n        while(!que.isEmpty()){\\n            List<Integer> y = new ArrayList<>();\\n            int n = que.size();\\n\\n            for(int i=0; i < n; i++){\\n                TreeNode temp = que.poll();\\n                y.add(temp.val);\\n\\n                if(temp.left != null)\\n                    que.add(temp.left);\\n                if(temp.right != null)\\n                    que.add(temp.right);\\n            }", "class Solution {\\n        public List<List<Integer>> levelOrderBottom(TreeNode root) {\\n            Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n            List<List<Integer>> wrapList = new LinkedList<List<Integer>>();\\n            \\n            if(root == null) return wrapList;\\n            \\n            queue.offer(root);\\n            while(!queue.isEmpty()){\\n                int levelNum = queue.size();\\n                List<Integer> subList = new LinkedList<Integer>();\\n                for(int i=0; i<levelNum; i++) {\\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\\n                    subList.add(queue.poll().val);\\n                }", "class Solution {\\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }"]}
{"id": "677", "ref_java": ["class Solution {\\npublic TreeNode sortedListToBST(ListNode head) {\\n    if(head==null) return null;\\n    return toBST(head,null);\\n}", "class Solution {\\npublic TreeNode sortedListToBST(ListNode head) {\\n    if(head==null) return null;\\n    return toBST(head,null);\\n}", "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }"]}
{"id": "678", "ref_java": ["class Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        List<Integer> ls=new ArrayList<>();\\n        helper(root,targetSum,ls,res);\\n        return res;\\n    }", "class Solution {\\n     List<List<Integer>> al = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n       \\n        helper( new ArrayList<>(), root, targetSum);\\n        return al;\\n    }", "class Solution {\\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n    "]}
{"id": "679", "ref_java": ["class Solution {\\n    public void flatten(TreeNode root) {\\n        \\n        if(root==null)\\n            return;\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        \\n        while(true){\\n            \\n            if(root.right != null)\\n                stack.push(root.right);\\n            \\n            if(root.left==null){\\n                if(stack.isEmpty())\\n                    break;\\n                root.right = stack.pop();\\n            }", "class Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }", "class Solution {\\n    public void flatten(TreeNode root) {\\n        help(root);\\n    }"]}
{"id": "680", "ref_java": ["class Solution {\\n    public Node connect(Node node) {\\n        Map<Integer, List<Node>> map = new HashMap<>();\\n        goDFS(0, node, map);\\n        for (int key : map.keySet()) {\\n            List<Node> list = map.get(key);\\n            for (int i = 1; i < list.size(); i++) {\\n                list.get(i - 1).next = list.get(i);\\n            }", "class Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }", "class Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return root;\\n        }"]}
{"id": "681", "ref_java": ["class Solution {\\n    public Node connect(Node root) {\\n        Map<Integer, List<Node>> map = new HashMap<>();\\n        goDFS(root, 0, map);\\n        for (List<Node> list : map.values()) \\n            for (int i = 1; i < list.size(); i++) \\n                list.get(i - 1).next = list.get(i);\\n        return root;\\n    }", "class Solution {\\n    private boolean hasChildren(Node node) {\\n        return node.left != null || node.right != null;\\n    }", "class Solution {\\n    public Node connect(Node root) {\\n        Map<Integer, List<Node>> map = new HashMap<>();\\n        goDFS(root, 0, map);\\n        for (List<Node> list : map.values()) \\n            for (int i = 1; i < list.size(); i++) \\n                list.get(i - 1).next = list.get(i);\\n        return root;\\n    }"]}
{"id": "682", "ref_java": ["class Solution {\\n     public int minimumTotal(List<List<Integer>> triangle) {``\\n           int n = triangle.size();\\n        ", "class Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) \\n    {\\n        int[][]val=new int[triangle.size()][triangle.size()];\\n        for(int[]temp:val)\\n         Arrays.fill(temp,-10001);\\n        return findFn(triangle,0,0,val);    \\n    }", "class Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) \\n    {\\n        int[][]val=new int[triangle.size()][triangle.size()];\\n        for(int[]temp:val)\\n         Arrays.fill(temp,-10001);\\n        return findFn(triangle,0,0,val);    \\n    }"]}
{"id": "683", "ref_java": ["class Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for(int i=1;i<prices.length;i++) {\\n            if(prices[i] > prices[i-1]) {\\n                profit += prices[i] - prices[i-1];\\n            }", "class Solution {\\n    \\n    \\n    public int maxProfit(int[] prices) {\\n\\n        ArrayList<Integer> priceGain = new ArrayList<Integer>();\\n        \\n        for(int idx = 0 ; idx < prices.length-1; idx++){\\n            \\n            if( prices[idx] < prices[idx+1] ){\\n                priceGain.add( prices[idx+1]- prices[idx]);\\n            }", "class Solution {\\n    public int maxProfit(int[] prices) {\\n"]}
{"id": "684", "ref_java": ["class Solution {\\n    public int longestConsecutive(int[] nums) {\\n        if(nums.length==0)return 0;\\n        Arrays.sort(nums);\\n        int max =-1;\\n        int cnt=0;\\n        for(int i=1;i<nums.length;i++) {\\n           if(nums[i-1]==nums[i])continue;\\n           else if (nums[i]-nums[i-1]==1)cnt++;\\n           else {\\n               if(cnt>max)max=cnt;\\n               cnt =0 ;\\n           }", "class Solution {\\n    public int longestConsecutive(int[] nums) {int result = 0;\\n        if (nums.length > 0) {\\n            if (nums.length < 1000) {\\n                Arrays.sort(nums);\\n                int current = 0;\\n                for (int i = 1; i < nums.length; i++) {\\n                    if (nums[i] != nums[i - 1]) {\\n                        if (nums[i] - nums[i - 1] == 1) {\\n                            current++;\\n                        }", "class Solution {\\n    public int longestConsecutive(int[] nums) {\\n    "]}
{"id": "685", "ref_java": ["class Solution {\\n    int result=0;\\n    public void sum(TreeNode root, int num) {\\n        if(root == null) return;\\n        num = root.val + ( 10 * num);\\n\\n        if(root.left == null && root.right == null){\\n            result += num;\\n        }", "class Solution {\\n  List<String>lis=new ArrayList<>();\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,\"\");\\n        int sum=0;\\n        for(String s:lis){\\n          sum+=Integer.parseInt(s);\\n        }", "class Solution {\\n    public void solve(ArrayList<Integer> list, TreeNode root, String s){\\n\\n        if(root.left ==null && root.right == null ){\\n            s+=root.val;            \\n            int add = Integer.parseInt(s);\\n            list.add(add);\\n            s = s.substring(0,s.length()-1);\\n            return;\\n        }"]}
{"id": "686", "ref_java": ["class Solution {\\n    public void solve(char[][] board) {\\n       int m = board.length;\\n       int n = board[0].length; \\n       for(int i=0;i<n;i++)\\n       {\\n           if(board[0][i]==\\'O\\')\\n           {\\n               dfs(0,i,board);\\n           }", "class Solution {\\n    public void solve(char[][] board) {\\n       int m = board.length;\\n       int n = board[0].length; \\n       for(int i=0;i<n;i++)\\n       {\\n           if(board[0][i]==\\'O\\')\\n           {\\n               dfs(0,i,board);\\n           }", "class Solution {\\n    public void solve(char[][] board) {\\n       int m = board.length;\\n       int n = board[0].length; \\n       for(int i=0;i<n;i++)\\n       {\\n           if(board[0][i]==\\'O\\')\\n           {\\n               dfs(0,i,board);\\n           }"]}
{"id": "687", "ref_java": ["class Solution {\\n    List<List<String>> ans = new ArrayList<>();\\n    List<String> curr = new ArrayList<>();\\n    boolean isPalindrome(String s, int low, int high) {\\n        while (low < high)\\n            if (s.charAt(low++) != s.charAt(high--)) return false;\\n\\n        return true;\\n    }", "class Solution {\\n    int n;\\n    boolean[][] is_palindrome;\\n    String[][] substrings;\\n\\n    List<List<String>> ans;\\n\\n    void FindSubstrings(int ind, ArrayList<String> list) {\\n        if (ind == n) {\\n            ans.add(new ArrayList<String>(list));\\n            return;\\n        }", "class Solution {\\n    "]}
{"id": "688", "ref_java": ["class Solution {\\n    public void dfs(Node node , Node copy , Node[] visited){\\n        visited[copy.val] = copy;", "class Solution {\\n    public void dfs(Node node, HashMap<Node, Node> dict)\\n    {\\n        for (Node nd : node.neighbors) {\\n            if (!dict.containsKey(nd))\\n                dict.put(nd, new Node(nd.val));\\n            dict.get(node).neighbors.add(dict.get(nd));\\n        }", "class Solution {\\n    public Node cloneGraph(Node node) {\\n        if (node == null) return null;\\n        Deque<Node> bfs1 = new ArrayDeque<>();\\n        bfs1.offer(node);\\n        Node res = new Node(node.val);\\n        Deque<Node> bfs2 = new ArrayDeque<>();\\n        Node[] added = new Node[101];\\n        bfs2.offer(res);\\n        added[node.val] = res;\\n        while (!bfs1.isEmpty()) {\\n            Node prev1 = bfs1.remove();\\n            Node prev2 = bfs2.remove();\\n            for (Node child: prev1.neighbors) {\\n                if (added[child.val] == null) {\\n                    Node copy = new Node(child.val);\\n                    bfs1.offer(child);\\n                    bfs2.offer(copy);\\n                    added[child.val] = copy;\\n                    prev2.neighbors.add(copy);\\n                }"]}
{"id": "689", "ref_java": ["class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sGas = 0, sCost = 0, res = 0, total = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            sGas += gas[i];\\n            sCost += cost[i];\\n        }", "class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int remaining=0;\\n        int total=0;\\n        int start=0;\\n\\n        for(int i=0;i<gas.length;i++){\\n            int diff=gas[i]-cost[i];\\n            if(remaining>=0){\\n                remaining+=diff;\\n            }", "class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        "]}
{"id": "690", "ref_java": ["class Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }", "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],1);\\n            }", "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int n=nums.length;\\n        int res=Integer.MIN_VALUE;\\n        Arrays.sort(nums);\\n        int i=0;\\n        while(i<n-1)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                i+=3;\\n            }"]}
{"id": "691", "ref_java": ["class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        HashMap<Node, Node> oldToNew = new HashMap<>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }", "class Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head == null)return null;\\n        Node temp = head;\\n        Node ans = new Node(temp.val);\\n        temp = temp.next;\\n        List<Node> al = new ArrayList<>();\\n        al.add(ans);\\n        Node prev = ans;\\n        HashMap<Node,Integer> hm = new HashMap<>();\\n        int counter = 0;\\n        hm.put(head,counter);\\n        while(temp!=null){\\n            Node create = new Node(temp.val);\\n            prev.next = create;\\n            prev = prev.next;\\n            al.add(create);\\n            hm.put(temp,++counter);\\n            ", "class Solution {\\n    public Node copyRandomList(Node head) {\\n\\n        Node iter = head, next;\\n\\n        "]}
{"id": "692", "ref_java": ["class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recWay1(s, wordDict);\\n    }", "class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return canWordBreak(s, new HashSet<>(wordDict), new HashMap<>());\\n    }", "class Solution {\\n    private static int[] dp;\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for(String g : wordDict)\\n            set.add(g);\\n        dp = new int[300];\\n        Arrays.fill(dp, -1);\\n\\n        return solve(set, s.toCharArray(), 0) == 1 ? true : false;   \\n    }"]}
{"id": "693", "ref_java": ["class Solution {\\n  public ListNode detectCycle(ListNode head) {\\n    ", "class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }", "class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        HashMap<ListNode,Boolean>  map=new HashMap<>();\\n        while(head!=null)\\n        {\\n            if(map.containsKey(head)){\\n                return head;\\n            }"]}
{"id": "694", "ref_java": ["class Solution {\\n    public ListNode reorderList(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }", "class Solution {\\n    public void reorderList(ListNode head) {\\n        ", "class Solution {\\n    public void reorderList(ListNode head) {\\n        "]}
{"id": "696", "ref_java": ["class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head.next == null) return head;\\n        ListNode headNew = head, tempOuter = head.next, lastInner = headNew, prevOuter = head;\\n        while (tempOuter != null) {\\n            ListNode tempOuterCopy = tempOuter;\\n            tempOuter = tempOuter.next;\\n            if (lastInner.val > tempOuterCopy.val) {\\n                if (tempOuterCopy.val < headNew.val) {\\n                    if (headNew.next != null && headNew.next.equals(tempOuterCopy)) {\\n                        headNew.next = null;\\n                    }", "class Solution {\\n   \\n    public ListNode insertionSortList(ListNode head) {\\n        ", "class Solution {\\n   \\n    public ListNode insertionSortList(ListNode head) {\\n        "]}
{"id": "697", "ref_java": ["class Solution {\\n    public ListNode sortList(ListNode head) {\\n        return divide(head);\\n    }", "class Solution {\\n      \\n      public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n          return head;\\n            \\n        ", "class Solution {\\n    public ListNode sortList(ListNode head) {\\n        return divide(head);\\n    }"]}
{"id": "698", "ref_java": ["class Solution {\\n    public int evalRPN(String[] tokens) {\\n        Stack<String> stack = new Stack<>();\\n        String x = \"-1\";\\n        for(int i=0; i < tokens.length; i++){\\n            if(tokens[i].equals(\"+\"))\\n                x = Integer.toString(Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop()));\\n            else if(tokens[i].equals(\"-\")){\\n                String y = stack.pop();\\n                x = Integer.toString(Integer.parseInt(stack.pop()) - Integer.parseInt(y)); \\n            }", "class Solution {\\n    public int evalRPN(String[] tokens) {\\n        Stack<Integer> stack = new Stack<>();\\n        String symbol = \"+-*/\";\\n        for(String token: tokens) {\\n            if(token.length() == 1 && symbol.indexOf(token.charAt(0)) >= 0) {\\n                int a = stack.pop(), b = stack.pop(), c = 0;\\n                switch(token.charAt(0)){\\n                    case \\'+\\':\\n                    c = a + b;\\n                    break;\\n                    case \\'-\\':\\n                    c = b - a;\\n                    break;\\n                    case \\'*\\':\\n                    c = a * b;\\n                    break;\\n                    case \\'/\\':\\n                    c = b / a;\\n                }", "class Solution {\\n    public int evalRPN(String[] tokens) {\\n        List<String> oper = Arrays.asList(new String[]{\"+\",\"-\",\"*\",\"/\"}"]}
{"id": "699", "ref_java": ["class Solution {\\n    public String reverseWords(String s) {\\n        ", "class Solution {\\n    public String reverseWords(String s) {\\n        s = s.trim().replaceAll(\" \\\\\\\\s+\", \" \");\\n        String[] words = s.split(\" \");\\n        StringBuilder reversedString = new StringBuilder();\\n        for(int i=words.length -1;i>=0;i--){\\n            reversedString.append(words[i]).append(\" \");\\n        }", "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim();\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        if(n<=1){\\n            return s;\\n        }"]}
{"id": "700", "ref_java": ["class Solution {\\n    public int maxProduct(int[] nums) {\\n        int left = 1;\\n        int right = 1; \\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            left *= nums[i];\\n            right *= nums[nums.length-1-i];\\n\\n            max = Math.max(max, Math.max(left, right));\\n            if(left == 0) left = 1;\\n            if(right == 0) right = 1;\\n        }", "class Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = nums[0], min = nums[0], result = nums[0];\\n        ", "class Solution {\\n    public int maxProduct(int[] nums) {\\n        int minProd = nums[0], maxProd = nums[0];\\n        int ans = nums[0];\\n\\n        int testMaxProd, testMinProd;\\n        for (int i = 1; i < nums.length; i++) {\\n            testMaxProd = maxProd * nums[i];\\n            testMinProd = minProd * nums[i];\\n\\n            maxProd = Math.max(Math.max(testMaxProd, testMinProd), nums[i]);\\n            minProd = Math.min(Math.min(testMaxProd, testMinProd), nums[i]);\\n\\n            ans = Math.max(ans, maxProd);\\n        }"]}
{"id": "701", "ref_java": ["class Solution {\\n  public int findMin(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    while (l < r) {\\n      final int m = (l + r) / 2;\\n      if (nums[m] < nums[r])\\n        r = m;\\n      else\\n        l = m + 1;\\n    }", "class Solution {\\n    public int findMin(int[] nums) {\\n        int res = nums[0]; ", "class Solution {\\n    public int findMin(int[] nums) {\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] > nums[i + 1]){\\n                return nums[i + 1];\\n            }"]}
{"id": "703", "ref_java": ["class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int peak = 0;\\n        if(nums.length == 2) {\\n            peak = nums[0] > nums[1] ? 0:1;\\n        }", "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int pk = 0;\\n        if(nums.length==2){\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        }", "class Solution {\\n    public int findPeakElement(int[] nums) {\\n        int pk = 0;\\n        if(nums.length==2){\\n            if(nums[0]>nums[1]) return 0;\\n            else return 1;\\n        }"]}
{"id": "704", "ref_java": ["class Solution {\\n    public int compareVersion(String version1, String version2) {\\n        String[] a = version1.split(\"\\\\\\\\.\"), b = version2.split(\"\\\\\\\\.\");\\n        boolean changed = false;\\n        if (a.length < b.length) {\\n            String[] temp = a;\\n            a = b;\\n            b = temp;\\n            changed = true;\\n        }", "class Solution {\\n    public int compareVersion(String version1, String version2) {\\n        int temp1 = 0,temp2 = 0;\\n        int len1 = version1.length(),len2 = version2.length();\\n        int i = 0,j = 0;\\n        while(i<len1 || j<len2) {\\n            temp1 = 0;\\n            temp2 = 0;\\n            while(i<len1 && version1.charAt(i) != '.') {\\n                temp1 = temp1*10 + version1.charAt(i++)-'0';\\n                \\n            }", "class Solution {\\n    public int compareVersion(String version1, String version2) {\\n        String[] arr1 = version1.split(\"\\\\\\\\.\");\\n        String[] arr2 = version2.split(\"\\\\\\\\.\");\\n        int i=0;\\n        while(i<arr1.length || i<arr2.length)\\n        {\\n            if(i<arr1.length && i<arr2.length)\\n            {\\n                if(Integer.parseInt(arr1[i]) < Integer.parseInt(arr2[i]))\\n                {\\n                    return -1;\\n                }"]}
{"id": "705", "ref_java": ["class Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }", "class Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }", "class Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }"]}
{"id": "706", "ref_java": ["class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res=new int[2];\\n        int startindex=0;\\n        int endindex=(numbers.length)-1;\\n        while(startindex<endindex){\\n            if(numbers[startindex]+numbers[endindex]>target){\\n                endindex--;\\n            }", "class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n                int left = 0;\\n        int right = numbers.length - 1;\\n        int tmp;\\n        while (left < right)\\n        {\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[right];\\n            while (numbers[left] < tmp) left++;\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[left];\\n            while (numbers[right] > tmp) right--;\\n        }", "class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res=new int[2];\\n        int startindex=0;\\n        int endindex=(numbers.length)-1;\\n        while(startindex<endindex){\\n            if(numbers[startindex]+numbers[endindex]>target){\\n                endindex--;\\n            }"]}
{"id": "707", "ref_java": ["class Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        ", "class Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n%5!=n){\\n            count+=(n/5);\\n            n=n/5;\\n        }", "class Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n!=0){\\n           c+=n/5;\\n           n/=5;\\n       }"]}
{"id": "712", "ref_java": ["class Solution {\\n    public class Comparable implements Comparator<Integer> {\\n       @Override\\n        public int compare(Integer a,Integer b) {\\n           int c = a.intValue();\\n           int d = b.intValue();\\n           String e = c+\"\"+d;\\n           String f = d+\"\"+c;\\n           return f.compareTo(e);\\n        }", "class Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] s = new String[nums.length];         \\n        for(int i=0; i<nums.length; i++)  s[i] = String.valueOf(nums[i]);\\n        Arrays.sort(s, (a,b) -> (b + a).compareTo(a + b));\\n        return s[0].equals(\"0\") ? \"0\" : String.join(\"\",s);\\n    }", "class Solution {\\n    public String largestNumber(int[] nums) {\\n        String s[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            s[i]=String.valueOf(nums[i]);\\n        }"]}
{"id": "715", "ref_java": ["class Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String, Integer> map = new HashMap();\\n        ArrayList<String> ret = new ArrayList<>();\\n\\n        for(int i = 0; i<s.length()-9; i++) {\\n            String substring = s.substring(i,i+10);\\n            if(map.containsKey(substring)){\\n                map.replace(substring, map.get(substring)+1);\\n            }", "class Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String, Integer> map = new HashMap();\\n        ArrayList<String> ret = new ArrayList<>();\\n\\n        for(int i = 0; i<s.length()-9; i++) {\\n            String substring = s.substring(i,i+10);\\n            if(map.containsKey(substring)){\\n                map.replace(substring, map.get(substring)+1);\\n            }", "class Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String, Integer> map = new HashMap();\\n        ArrayList<String> ret = new ArrayList<>();\\n\\n        for(int i = 0; i<s.length()-9; i++) {\\n            String substring = s.substring(i,i+10);\\n            if(map.containsKey(substring)){\\n                map.replace(substring, map.get(substring)+1);\\n            }"]}
{"id": "716", "ref_java": ["class Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        int n = nums.length;\\n        reverseNum(nums,0,n-1);\\n        reverseNum(nums,0,k-1);\\n        reverseNum(nums,k,n-1);\\n    }", "class Solution {\\n\\n    public static void reverse(int nums[], int start, int end){\\n    ", "class Solution {\\n\\t public static void reverse(int nums[], int i, int j){\\n        int li = i;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }"]}
{"id": "719", "ref_java": ["class Solution {\\n    public int rob(int[] nums) {\\n        int l = nums.length;\\n        if(l==1) return nums[0];\\n        if(l==2) return Math.max(nums[0],nums[1]);\\n        if(l==3) return Math.max(nums[0]+nums[2],nums[1]);\\n        int[] res = new int[l];\\n        res[0] = nums[0];\\n        res[1] = nums[1];\\n        res[2]= nums[0]+nums[2];\\n        for(int i=3;i<l;i++)\\n        {\\n            res[i]= Math.max(res[i-2]+nums[i] , res[i-3]+nums[i]);\\n        }", "class Solution {\\n    public int rob(int[] nums) {\\n        int dp[]=new int[nums.length+1];\\n        Arrays.fill(dp,-1);\\n        return solve(0,nums,dp);\\n    }", "class Solution {\\n\\n    public int helper(int[] nums, int i,HashMap<Integer,Integer> memo){\\n        if(memo.containsKey(i)){\\n            return memo.get(i);\\n        }"]}
{"id": "720", "ref_java": ["class Solution {\\n    int maxlevel = 0;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list  = new ArrayList<>();\\n        right(root,1,list);\\n        return list ;\\n    }", "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            rightView(root, result, 0);\\n            return result;\\n        }", "class Solution {\\n    List<Integer> lst;\\n\\n    public List<Integer> rightSideView(TreeNode root) {\\n        lst = new ArrayList<>();\\n        topView(root);\\n        return lst;\\n    }"]}
{"id": "721", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    \\n    private int n;\\n    private int m;\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == '1') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }", "class Solution {\\n    int r;\\n    int c;\\n    char[][] arr;\\n    int count;\\n    public int numIslands(char[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        arr = grid;\\n\\n        count =0;\\n        for(int i=0;i<r;i++){\\n            check(grid[i],i);\\n        }"]}
{"id": "722", "ref_java": ["class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        if(left == right || left == 0) return left;\\n        int start = (int)(Math.log(left)/Math.log(2));\\n        int end = (int)(Math.log(right)/Math.log(2));\\n        if(start != end) return 0;\\n\\n        int answer = left & right;\\n        int bits = (int)(Math.log(right-left)/Math.log(2))+1;\\n        for(int i=0 ;i<bits ; i++) answer  &=  ~(1 << i);\\n\\n        return answer;\\n    }", "class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        if(left == right || left == 0) return left;\\n        int start = (int)(Math.log(left)/Math.log(2));\\n        int end = (int)(Math.log(right)/Math.log(2));\\n        if(start != end) return 0;\\n\\n        int answer = left & right;\\n        int bits = (int)(Math.log(right-left)/Math.log(2))+1;\\n        for(int i=0 ;i<bits ; i++) answer  &=  ~(1 << i);\\n\\n        return answer;\\n    }", "class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        if(left == right || left == 0) return left;\\n        int start = (int)(Math.log(left)/Math.log(2));\\n        int end = (int)(Math.log(right)/Math.log(2));\\n        if(start != end) return 0;\\n\\n        int answer = left & right;\\n        int bits = (int)(Math.log(right-left)/Math.log(2))+1;\\n        for(int i=0 ;i<bits ; i++) answer  &=  ~(1 << i);\\n\\n        return answer;\\n    }"]}
{"id": "723", "ref_java": ["class Solution {\\n    public int countPrimes(int n) {\\n        if (n <= 2) {\\n            return 0;\\n        }", "class Solution {\\n    public int countPrimes(int n) {\\n        if(n<2){\\n            return 0 ;\\n        }", "class Solution {\\n    public int countPrimes(int n) {\\n        boolean[] seen = new boolean[n];\\n        int ans = 0;\\n        for (int num = 2; num < n; num++) {\\n            if (seen[num]) continue;\\n            ans += 1;\\n            for (long mult = (long)num * num; mult < n; mult += num)\\n                seen[(int)mult] = true;\\n        }"]}
{"id": "724", "ref_java": ["class Solution {\\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\\n        ", "class Solution {\\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\\n        ", "class Solution {\\n    public boolean canFinish(int n, int[][] prerequisites) {\\n        List<Integer>[] adj = new List[n];\\n        int[] indegree = new int[n];\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int[] pair : prerequisites) {\\n            int course = pair[0];\\n            int prerequisite = pair[1];\\n            if (adj[prerequisite] == null) {\\n                adj[prerequisite] = new ArrayList<>();\\n            }"]}
{"id": "726", "ref_java": ["class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        int i = 0,j=0,res = Integer.MAX_VALUE;\\n\\n        while(i<n && j<n){\\n            sum = sum + nums[i];\\n            if(sum >= target){\\n                res = Math.min(res,i-j+1);\\n                sum = sum - nums[j];\\n                j++;\\n                while(j<=i && sum >=target){\\n                    res = Math.min(res,i-j+1);\\n                    sum = sum - nums[j];\\n                    j++;\\n                }", "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int ans = Integer.MAX_VALUE; ", "class Solution {\\n    public int minSubArrayLen(int target, int[] nums) {\\n        int n = nums.length, curSum = 0, l = 0;\\n        int minSize = n + 1;\\n\\n        for(int r = 0; r < n; r++){\\n            curSum += nums[r];\\n            while(l < r && (curSum - nums[l]) >= target){\\n                curSum -= nums[l];\\n                l++;\\n            }"]}
{"id": "727", "ref_java": ["class Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            adj.add(new ArrayList<>());\\n        }", "class Solution {\\n\\n    static ArrayList<Integer> graph[];\\n    static int v;\\n    static int e;\\n\\n    static void addEdge(int a, int b){\\n        graph[b].add(a);\\n    }", "class Solution {\\n    public int[] findOrder(int n, int[][] prerequisites) {\\n        List<Integer>[] adjList = new List[n];;\\n        for(int i=0; i<n; i++) {\\n            adjList[i] = new ArrayList<>();\\n        }"]}
{"id": "729", "ref_java": ["class Solution {\\n    public int rob(int[] nums) {\\n        int ind=nums.length-1;\\n        HashMap<Pair,Integer> map=new HashMap<>();\\n        if(ind==0)\\n        return nums[0];\\n        else\\n        return Math.max(f(ind-1,nums,0,map),f(ind,nums,nums[ind],map)); \\n    }", "class Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        if(n==1) return nums[0];\\n        if(n==2) return Math.max(nums[0],nums[1]);\\n        return Math.max(rob(nums,0,n-2),rob(nums,1,n-1)); ", "class Solution {\\n    public int rob(int[] nums) {\\n        int ind=nums.length-1;\\n        HashMap<Pair,Integer> map=new HashMap<>();\\n        if(ind==0)\\n        return nums[0];\\n        else\\n        return Math.max(f(ind-1,nums,0,map),f(ind,nums,nums[ind],map)); \\n    }"]}
{"id": "730", "ref_java": ["class Solution {\\n    public int findKthLargest(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        return nums[nums.length - k];\\n    }", "class Solution {\\n    public int findKthLargest(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        return nums[nums.length-k];\\n    }", "class Solution {\\n    public int findKthLargest(int[] nums, int k) {\\n        quickSelect(nums, 0, nums.length - 1, k - 1);\\n        return nums[k - 1];\\n    }"]}
{"id": "731", "ref_java": ["class Solution {\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(1, k, n, new ArrayList<>(), result);\\n    return result;\\n}", "class Solution {\\n    public static void generate(List<List<Integer>> result, List<Integer> list, int k, int n, int start) {\\n        if(k == 1 && start <= n && n <= 9) {\\n            list.add(n);\\n            result.add(new ArrayList<>(list));\\n            list.remove(Integer.valueOf(n));\\n            return;\\n        }", "class Solution {\\n    public static void generate(List<List<Integer>> result, List<Integer> list, int k, int n, int start) {\\n        if(k == 1 && start <= n && n <= 9) {\\n            list.add(n);\\n            result.add(new ArrayList<>(list));\\n            list.remove(Integer.valueOf(n));\\n            return;\\n        }"]}
{"id": "732", "ref_java": ["class Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int i ,j;\\n        int max=0,n=matrix.length,m=matrix[0].length;\\n        int mat[][]= new int [n][m];\\n       for(i=0;i<n;i++)\\n       {\\n           for(j=0;j<m;j++)\\n           {\\n             if(i==0 || j==0 || matrix[i][j]==\\'0\\')\\n             {\\n                 mat[i][j]=Integer.parseInt(String.valueOf(matrix[i][j]));\\n                 \\n             }", "class Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, min = Math.min(m, n);\\n        int[][] arrH = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            int count = 0;\\n            for (int c = 0; c < n; c++) {\\n                if (matrix[r][c] == \\'1\\') arrH[r][c] = ++count;\\n                else count = 0;\\n            }", "class Solution {\\n    public int maximalSquare(char[][] m) {\\n        int s=Integer.MIN_VALUE;\\n        int dp[][]=new int[m.length][m[0].length];\\n        for(int i=m.length-1;i>=0;i--){\\n            for(int j=m[0].length-1;j>=0;j--){\\n                if(m[i][j]==\\'1\\'){\\n                    if(i==m.length-1||j==m[0].length-1) {\\n                        dp[i][j]=1;\\n                        s=Math.max(s,dp[i][j]);\\n                    }"]}
{"id": "733", "ref_java": ["class Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int tot=(by2-by1)*(bx2-bx1) + (ay2-ay1)*(ax2-ax1);\\n        \\n        int[] iY=findIntersection(new int[]{ay1,ay2}", "class Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if(ax2<bx1||bx2<ax1 )\\n            return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1);\\n        if(ay2<by1 || by2<ay1)\\n            return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1);\\n        int right = Math.min(ax2,bx2);\\n        int left = Math.max(ax1,bx1);\\n        int top = Math.min(by2,ay2);\\n        int bottom = Math.max(by1,ay1);\\n        return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1) - (right-left)*(top-bottom);\\n    }", "class Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int l1 =ax2 - ax1;\\n        int h1 =ay2 - ay1;\\n        int l2 =bx2 - bx1;\\n        int h2=by2 - by1;\\n\\n        int area1 = l1 * h1;\\n        int area2 = l2 * h2;\\n\\n        int minl1 = Math.min(ax2, bx2);\\n        int maxl1 = Math.max(ax1, bx1);\\n        \\n        int minh1 = Math.min(ay2, by2);\\n        int maxh1 = Math.max(ay1, by1);\\n        \\n        int commonArea = Math.max(0,minl1 - maxl1) * Math.max(0, minh1 - maxh1);\\n        int res = area1 + area2 - commonArea;\\n        return res;\\n    }"]}
{"id": "734", "ref_java": ["class Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st=new Stack();\\n        int num=0;\\n        char operator=\\'+\\';\\n\\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(Character.isDigit(ch[i]))\\n                num=num*10+ch[i]-\\'0\\';\\n            if(!Character.isDigit(ch[i]) && ch[i]!=\\' \\' || i==ch.length-1)\\n            {\\n                if(operator==\\'+\\')\\n                    st.push(num);\\n                else if(operator==\\'-\\')\\n                    st.push(-num);\\n                else if(operator==\\'*\\')\\n                    st.push(st.pop()*num);\\n                else if(operator==\\'/\\')\\n                    st.push(st.pop()/num);\\n                num=0;\\n                operator=ch[i];\\n\\n            }", "class Solution {\\n\\n    public int calculate(String s) {\\n        var stack = new ArrayDeque<Integer>();\\n        var n = 0;\\n        var op = \\'+\\';\\n        \\n        for (var c : s.toCharArray()) {\\n            switch (c) {\\n                case \\'+\\', \\'-\\', \\'*\\', \\'/\\' -> {\\n                    eval(stack, n, op);\\n                    op = c;\\n                    n = 0;\\n                }", "class Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st = new Stack<>();\\n\\n        int num = 0;\\n        char operator = \\'+\\';\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + (c - \\'0\\');\\n            }"]}
{"id": "735", "ref_java": ["class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        ", "class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> list = new ArrayList<>(); ", "class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int freq1 = 0, freq2 = 0;\\n        int cand1 = 23, cand2 = 0;\\n        for(var num : nums){\\n            if(num == cand1)freq1++;\\n            else if(num == cand2)freq2++;\\n            else if(freq1 == 0){\\n                freq1 = 1;\\n                cand1 = num;\\n            }"]}
{"id": "736", "ref_java": ["class Solution {\\n    int K; \\n    public int kthSmallest(TreeNode root, int k) {\\n        K = k; \\n        return util(root);\\n    }", "class Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        solution(root, list);\\n        return (list.get(k-1));\\n    }", "class Solution {\\n    int K; \\n    public int kthSmallest(TreeNode root, int k) {\\n        K = k; \\n        return util(root);\\n    }"]}
{"id": "737", "ref_java": ["class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q){\\n            return root;\\n        }", "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode[] pPath = path(root, p);\\n        TreeNode[] qPath = path(root, q);\\n\\n        TreeNode last = null;\\n\\n        for (int i = 0; i < pPath.length; i++) {\\n            if (pPath[i] != qPath[i]) {\\n                return last;\\n            }", "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n      if(root==null)\\n          return null ;\\n        if( root.val>p.val && root.val>q.val){\\n            return  lowestCommonAncestor(root.left,p,q) ;\\n        }"]}
{"id": "738", "ref_java": ["class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ", "class Solution {\\n    public static boolean getPath(TreeNode root, TreeNode n, ArrayList<TreeNode> list){\\n        if(root == null){\\n            return false;\\n        }", "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {    \\n     if(root == null) return null;\\n     if(root == p || root == q) return root;\\nTreeNode left =lowestCommonAncestor(root.left,p,q);       \\nTreeNode right = lowestCommonAncestor(root.right,p,q);\\n        if(left != null && right != null) return root;\\n        return left == null? right: left;\\n    }"]}
{"id": "739", "ref_java": ["class Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next; \\n    }", "class Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val = node.next.val;\\n        node.next = node.next.next;\\n    }", "class Solution {\\n    public void deleteNode(ListNode node) {\\n        ListNode current=node.next;\\n        node.val=current.val;\\n        node.next=current.next;\\n         \\n        "]}
{"id": "740", "ref_java": ["class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            int pro = 1;\\n            for(int j = 0; j < n; j++) {\\n                if(i == j) continue;\\n                pro *= nums[j];\\n            }", "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int numsLength = nums.length;\\n        int prefixProduct = 1;\\n        int suffixProduct = 1;\\n        int[] result = new int[numsLength];\\n        for(int i = 0; i < numsLength; i++) {\\n            result[i] = prefixProduct;\\n            prefixProduct *= nums[i];\\n        }", "class Solution {\\n    public int[] productExceptSelf(int[] arr) {\\n        int n=arr.length;\\n        int p=1,s=1;\\n        int arr2[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr2[i]=p;\\n            p=p*arr[i];\\n        }"]}
{"id": "741", "ref_java": ["class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if(matrix == null || matrix.length < 1 || matrix[0].length <1) {\\n                return false;\\n            }", "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row=matrix.length;\\n        int coloum=matrix[0].length;\\n        int start=0;\\n        int end=coloum-1;\\n         \\n        while(start<row && end>=0){\\n            if(matrix[start][end]>target){\\n                end--;\\n            }", "class Solution {\\n    public boolean searchMatrix(int[][] a, int target) {\\n        int n=a.length,m=a[0].length;\\n        int i=0,j=m-1;\\n        while(i<n && j>=0){\\n            if(a[i][j]==target) return true;\\n        \\n        if(target<a[i][j]){\\n            j--;\\n        }"]}
{"id": "742", "ref_java": ["class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            for (int i=0; i<input.length(); i++) {\\n                if (input.charAt(i) == '-' ||\\n                    input.charAt(i) == '*' ||\\n                    input.charAt(i) == '+' ) {\\n                    String part1 = input.substring(0, i);\\n                    String part2 = input.substring(i+1);\\n                    List<Integer> part1Ret = diffWaysToCompute(part1);\\n                    List<Integer> part2Ret = diffWaysToCompute(part2);\\n                    for (Integer p1 :   part1Ret) {\\n                        for (Integer p2 :   part2Ret) {\\n                            int c = 0;\\n                            switch (input.charAt(i)) {\\n                                case '+': c = p1+p2;\\n                                    break;\\n                                case '-': c = p1-p2;\\n                                    break;\\n                                case '*': c = p1*p2;\\n                                    break;\\n                            }", "class Solution {\\n    bool isOperator(char ch) {\\n        return (ch == \\'+\\' || ch == \\'-\\' || ch == \\'*\\');\\n    }", "class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            for (int i=0; i<input.length(); i++) {\\n                if (input.charAt(i) == '-' ||\\n                    input.charAt(i) == '*' ||\\n                    input.charAt(i) == '+' ) {\\n                    String part1 = input.substring(0, i);\\n                    String part2 = input.substring(i+1);\\n                    List<Integer> part1Ret = diffWaysToCompute(part1);\\n                    List<Integer> part2Ret = diffWaysToCompute(part2);\\n                    for (Integer p1 :   part1Ret) {\\n                        for (Integer p2 :   part2Ret) {\\n                            int c = 0;\\n                            switch (input.charAt(i)) {\\n                                case '+': c = p1+p2;\\n                                    break;\\n                                case '-': c = p1-p2;\\n                                    break;\\n                                case '*': c = p1*p2;\\n                                    break;\\n                            }"]}
{"id": "743", "ref_java": ["class Solution {\\n    public int[] singleNumber(int[] nums) {\\n\\n        int[] arr=new int[2];\\n\\n        HashMap<Integer, Integer> hm= new HashMap<Integer, Integer>();\\n        ", "class Solution {\\n    public int[] singleNumber(int[] nums) {\\n        ", "class Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int[] res = new int[2];"]}
{"id": "744", "ref_java": ["class Solution {\\n        public int nthUglyNumber(int n) {\\n            int[] ugly = new int[n];\\n            ugly[0] = 1;\\n            int index2 = 0, index3 = 0, index5 = 0;\\n            int factor2 = 2, factor3 = 3, factor5 = 5;\\n            for(int i=1;i<n;i++){\\n                int min = Math.min(Math.min(factor2,factor3),factor5);\\n                ugly[i] = min;\\n                if(factor2 == min)\\n                    factor2 = 2*ugly[++index2];\\n                if(factor3 == min)\\n                    factor3 = 3*ugly[++index3];\\n                if(factor5 == min)\\n                    factor5 = 5*ugly[++index5];\\n            }", "class Solution {\\n    public static Ugly u = new Ugly();\\n    public int nthUglyNumber(int n) {\\n        return u.nums[n - 1];\\n    }", "class Solution {\\n    public static Ugly u = new Ugly();\\n    public int nthUglyNumber(int n) {\\n        return u.nums[n - 1];\\n    }"]}
{"id": "745", "ref_java": ["class Solution {\\n    public int hIndex(int[] citations) {\\n        ", "class Solution {\\n    public int hIndex(int[] c) {\\n        int low=0 , high = c.length;\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.length ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = high=mid-1;\\n        }", "class Solution {\\n    public int hIndex(int[] citations) {\\n        "]}
{"id": "746", "ref_java": ["class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int s=0,e=n-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(citations[mid] < n-mid){\\n                s = mid+1;\\n            }", "class Solution {\\n    public int hIndex(int[] c) {\\n        int x=0;\\n        for(int i=0, n=c.length, j=n-1, m=0; i<=j;x=i, m=(i+j)/2){\\n            if(c[m]==n-m) return n-m;\\n            if(c[m]<n-m) i=m+1;\\n            else j=m-1;\\n        }", "class Solution {\\n    public int hIndex(int[] citations) {\\n        int l=0,r=citations.length-1,h=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(citations.length-mid<=citations[mid]){\\n                h=citations.length-mid;\\n                r=mid-1;\\n            }"]}
{"id": "747", "ref_java": ["class Solution {\\n    public int numSquares(int n) {\\n        ", "class Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n + 1];\\n        return helper(n, memo);\\n    }", "class Solution {\\n    Integer memo[];\\n    int Ans=Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        memo=new Integer[n+1];\\n\\n        "]}
{"id": "749", "ref_java": ["class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = 0, fast = 0;\\n        while(true){\\n           fast = nums[nums[fast]];\\n           slow = nums[slow]; \\n  \\n           if(slow == fast)break;\\n        }", "class Solution {\\n    public int findDuplicate(int[] nums) {\\n    HashSet<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return num;\\n        }", "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet set = new HashSet();\\n        for(int i:nums){\\n            if(!set.add(i)) return i;\\n        }"]}
{"id": "750", "ref_java": ["class Solution {\\n    public void gameOfLife(int[][] board) {\\n        \\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 0) processDead(board, i, j);\\n                else processAlive(board, i, j);\\n            }", "class Solution {\\n    public void gameOfLife(int[][] board) {\\n        \\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 0) processDead(board, i, j);\\n                else processAlive(board, i, j);\\n            }", "class Solution {\\n    public void gameOfLife(int[][] board) {\\n        \\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i = 0; i< rows; i++){\\n            for(int j = 0; j< cols; j++){\\n                if(board[i][j] == 0) processDead(board, i, j);\\n                else processAlive(board, i, j);\\n            }"]}
{"id": "751", "ref_java": ["class Solution {\\n    public String getHint(String secret, String guess) {\\n        StringBuilder first = new StringBuilder(secret);\\n        StringBuilder second = new StringBuilder(guess);\\n        HashMap<Character, Integer> dict = new HashMap<>();\\n        int numA = 0;\\n        int numB = 0;\\n        for (int i = secret.length() - 1; i > -1; i--)\\n        {\\n            if (first.charAt(i) == second.charAt(i)) {\\n                numA++;\\n                first.deleteCharAt(i);\\n                second.deleteCharAt(i);\\n            }", "class Solution {\\n    public String getHint(String secret, String guess) {\\n        StringBuilder first = new StringBuilder(secret);\\n        StringBuilder second = new StringBuilder(guess);\\n        HashMap<Character, Integer> dict = new HashMap<>();\\n        int numA = 0;\\n        int numB = 0;\\n        for (int i = secret.length() - 1; i > -1; i--)\\n        {\\n            if (first.charAt(i) == second.charAt(i)) {\\n                numA++;\\n                first.deleteCharAt(i);\\n                second.deleteCharAt(i);\\n            }", "class Solution {\\n    public String getHint(String sec, String gue) {\\n        char secret[]=sec.toCharArray();\\n        char guess[]=gue.toCharArray();\\n        String ans=\"\";\\n        int bulls=0,cow=0,n=secret.length,g=guess.length;\\n        for(int i=0;i<n;i++){ \\n            if(secret[i]==guess[i]){\\n                secret[i]=\\'@\\';guess[i]=\\'@\\';\\n                bulls++;\\n            }"]}
{"id": "752", "ref_java": ["class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int ans=0;\\n        int n=nums.length;\\n        if(n==1) return 1;\\n        int[] dp=new int[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            int length=0;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    length=Math.max(length,dp[j]);\\n                }", "class Solution {\\n    public int lengthOfLIS(int[] nums) {\\n        int ans=0;\\n        int n=nums.length;\\n        if(n==1) return 1;\\n        int[] dp=new int[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            int length=0;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    length=Math.max(length,dp[j]);\\n                }", "class Solution {\\n        public int lengthOfLIS(int[] nums) {            \\n            int[] dp = new int[nums.length];\\n            int len = 0;\\n    \\n            for(int x : nums) {\\n                int i = Arrays.binarySearch(dp, 0, len, x);\\n                if(i < 0) i = -(i + 1);\\n                dp[i] = x;\\n                if(i == len) len++;\\n            }"]}
{"id": "754", "ref_java": ["class Solution {\\n    public boolean isAdditiveNumber(String num) {\\n        int n = num.length();\\n        for (int i = 1; i < Math.min(n - 1, 19); ++i) {\\n            for (int j = i + 1; j < Math.min(n, i + 19); ++j) {\\n                if (i > 1 && num.charAt(0) == \\'0\\') {\\n                    break;\\n                }", "class Solution {\\n        public boolean isAdditiveNumber(String num) {\\n            int n = num.length();\\n            for (int i = 1; i <= n / 2; ++i) {\\n                if (num.charAt(0) == '0' && i > 1) return false;\\n                BigInteger x1 = new BigInteger(num.substring(0, i));\\n                for (int j = 1; Math.max(j, i) <= n - i - j; ++j) {\\n                    if (num.charAt(i) == '0' && j > 1) break;\\n                    BigInteger x2 = new BigInteger(num.substring(i, i + j));\\n                    if (isValid(x1, x2, j + i, num)) return true;\\n                }", "class Solution {\\n    int n;\\n    public boolean isAdditiveNumber(String num) {\\n        n = num.length();\\n        "]}
{"id": "756", "ref_java": ["class Solution {\\n    public static int ans(int a[],int n,int b,int dp[][]){\\n        if(n>=a.length) return 0;\\n        if(dp[n][b]!=-1) return dp[n][b];\\n        ", "class Solution {\\n    public int maxProfit(int[] prices) {\\n      return Profit(prices,0,0,-1,0,0);  \\n    }", "class Solution {\\n    public static int ans(int a[],int n,int b,int dp[][]){\\n        if(n>=a.length) return 0;\\n        if(dp[n][b]!=-1) return dp[n][b];\\n        "]}
{"id": "757", "ref_java": ["\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        if(n == 1)\n            return List.of(0);\n        \n        Map<Integer, Set<Integer>> adj = new HashMap<>();\n        for(int[] edge : edges) {\n            adj.computeIfAbsent(edge[0], k-> new HashSet<>()).add(edge[1]);\n            adj.computeIfAbsent(edge[1], k-> new HashSet<>()).add(edge[0]);\n        }\n        \n        Set<Integer> leaves = adj.entrySet().stream()\n        .filter(e->e.getValue().size()==1).map(e1->e1.getKey())\n        .collect(Collectors.toSet());\n        \n        while(n > 2) {\n            \n            n-= leaves.size();\n            Set<Integer> newLeaves = new HashSet<>();\n            for(Integer leaf : leaves) {\n                \n                Set<Integer> neighbours = adj.get(leaf);\n                adj.remove(leaf);\n                \n                neighbours.forEach(neighbour -> {\n                    Set<Integer> neighboursNeighbours = adj.get(neighbour);\n                    neighboursNeighbours.remove(leaf);\n                    if(neighboursNeighbours.size() == 1) {\n                        newLeaves.add(neighbour);\n                    }\n                });\n                leaves = newLeaves;\n            }\n        }\n        return new ArrayList<>(leaves);\n    }\n", "\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        if(n == 1)\n            return List.of(0);\n        \n        Map<Integer, Set<Integer>> adj = new HashMap<>();\n        for(int[] edge : edges) {\n            adj.computeIfAbsent(edge[0], k-> new HashSet<>()).add(edge[1]);\n            adj.computeIfAbsent(edge[1], k-> new HashSet<>()).add(edge[0]);\n        }\n        \n        Set<Integer> leaves = adj.entrySet().stream()\n        .filter(e->e.getValue().size()==1).map(e1->e1.getKey())\n        .collect(Collectors.toSet());\n        \n        while(n > 2) {\n            \n            n-= leaves.size();\n            Set<Integer> newLeaves = new HashSet<>();\n            for(Integer leaf : leaves) {\n                \n                Set<Integer> neighbours = adj.get(leaf);\n                adj.remove(leaf);\n                \n                neighbours.forEach(neighbour -> {\n                    Set<Integer> neighboursNeighbours = adj.get(neighbour);\n                    neighboursNeighbours.remove(leaf);\n                    if(neighboursNeighbours.size() == 1) {\n                        newLeaves.add(neighbour);\n                    }\n                });\n                leaves = newLeaves;\n            }\n        }\n        return new ArrayList<>(leaves);\n    }\n", "\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        if(n == 1)\n            return List.of(0);\n        \n        Map<Integer, Set<Integer>> adj = new HashMap<>();\n        for(int[] edge : edges) {\n            adj.computeIfAbsent(edge[0], k-> new HashSet<>()).add(edge[1]);\n            adj.computeIfAbsent(edge[1], k-> new HashSet<>()).add(edge[0]);\n        }\n        \n        Set<Integer> leaves = adj.entrySet().stream()\n        .filter(e->e.getValue().size()==1).map(e1->e1.getKey())\n        .collect(Collectors.toSet());\n        \n        while(n > 2) {\n            \n            n-= leaves.size();\n            Set<Integer> newLeaves = new HashSet<>();\n            for(Integer leaf : leaves) {\n                \n                Set<Integer> neighbours = adj.get(leaf);\n                adj.remove(leaf);\n                \n                neighbours.forEach(neighbour -> {\n                    Set<Integer> neighboursNeighbours = adj.get(neighbour);\n                    neighboursNeighbours.remove(leaf);\n                    if(neighboursNeighbours.size() == 1) {\n                        newLeaves.add(neighbour);\n                    }\n                });\n                leaves = newLeaves;\n            }\n        }\n        return new ArrayList<>(leaves);\n    }\n"]}
{"id": "758", "ref_java": ["class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int m= primes.length;\\n        PriorityQueue<int[]> q= new PriorityQueue<>((a,b) -> a[2]-b[2]);\\n        for(int i=0; i<m; i++){\\n            q.add(new int[]{primes[i],1,primes[i]}", "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        long[] dp=new long[n];\\n        dp[0]=1;\\n        int[] indexArr=new int[primes.length];\\n        for(int i=1; i<n; i++){\\n            long minValue=Long.MAX_VALUE;\\n            for(int j=0; j<primes.length; j++){\\n                minValue=Math.min(minValue,dp[indexArr[j]]*primes[j]);\\n            }", "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        long[] dp=new long[n];\\n        dp[0]=1;\\n        int[] indexArr=new int[primes.length];\\n        for(int i=1; i<n; i++){\\n            long minValue=Long.MAX_VALUE;\\n            for(int j=0; j<primes.length; j++){\\n                minValue=Math.min(minValue,dp[indexArr[j]]*primes[j]);\\n            }"]}
{"id": "759", "ref_java": ["class Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; ", "class Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; ", "class Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndx = new int[26];\\n        int sz = s.length();\\n        for (int indx = 0; indx < sz; indx++) {\\n            lastIndx[s.charAt(indx) - \\'a\\'] = indx;\\n        }"]}
{"id": "760", "ref_java": ["class Solution {\\n    public int maxProduct(String[] words) {\\n        int[][] alph = new int[words.length][26];\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n                alph[i][words[i].charAt(j) - \\'a\\']++;\\n            }", "class Solution {\\n    public int maxProduct(String[] words) {\\n        int n = words.length;\\n        int[] masks = new int[n];\\n        \\n        for (int i=0; i<n; i++)\\n            for (char c: words[i].toCharArray())\\n                masks[i] |= (1 << (c - \\'a\\'));\\n        \\n        int largest = 0;\\n        for (int i=0; i<n-1; i++) \\n            for (int j=i+1; j<n; j++) \\n                if ((masks[i] & masks[j]) == 0) \\n\\t\\t\\t\\t\\tlargest = Math.max(largest, words[i].length() * words[j].length());\\n        \\n        return largest;\\n    }", "class Solution {\\n    public int maxProduct(String[] words) {\\n        int n = words.length;\\n        List<Set<Character>> lst = new ArrayList(n);\\n        int max = 0;\\n\\n        for(String word : words) {\\t\\n            Set<Character> set = new HashSet();\\n            lst.add(set);\\n            for(int i=0; i<word.length(); i++) {\\n                set.add( word.charAt(i) );\\n            }"]}
{"id": "761", "ref_java": ["class Solution {\\n    public int bulbSwitch(int n) \\n    {\\n        return (int) Math.sqrt(n);\\n        \\n    }", "class Solution {\\n    public int bulbSwitch(int n) {        \\n        return (int)Math.floor(Math.sqrt(n));\\n    }", "class Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }"]}
{"id": "762", "ref_java": ["class Solution {\\n    public int coinChange(int[] coins, int amount) {\\n         int[] dp = new int[amount+1];\\n         for (int i = 1; i<= amount;i++)\\n         {\\n             int min = Integer.MAX_VALUE;\\n             for (int j = 0; j<coins.length;j++)\\n             {\\n                 if (i>=coins[j] && dp[i - coins[j]] !=-1)\\n                 {\\n                     min = Math.min(min,dp[i - coins[j]]);\\n                 }", "class Solution {\\n    public int coinChange(int[] coins, int amount) {\\n\\n        int ans = coinCount(coins, amount);\\n        return (ans == Integer.MAX_VALUE) ?  -1 : ans;\\n    }", "class Solution {\\n    public int coinChange(int[] coins, int amount) {\\n        int [] dp=new int[amount+1];\\n        for(int i=1;i<=amount;i++){\\n            int min= Integer.MAX_VALUE; "]}
{"id": "763", "ref_java": ["class Solution {\\n    public void wiggleSort(int[] nums) {\\n       int n=nums.length-1;\\n        ", "class Solution {\\n    public void wiggleSort(int[] nums) {\\n       int n=nums.length-1;\\n        ", "class Solution {\\n    public void wiggleSort(int[] nums) {\\n        int[] arr = nums.clone();\\n        Arrays.sort(arr);\\n        int n = nums.length;\\n        int i = (n - 1) >> 1, j = n - 1;\\n        for (int x = 0; x < n; ++x) {\\n            if (x % 2 == 0) {\\n                nums[x] = arr[i--];\\n            }"]}
{"id": "764", "ref_java": ["class Solution {\\n    public ListNode oddEvenList(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }", "class Solution {\\n    public ListNode oddEvenList(ListNode head) {\\n        if(head==null || head.next==null || head.next.next==null)\\n        {\\n            return head;\\n        }", "class Solution {\\n    public ListNode oddEvenList(ListNode head) {\\n        if (head==null || head.next==null) {\\n            return head;\\n        }"]}
{"id": "765", "ref_java": ["class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            ", "class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            ", "class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            "]}
{"id": "766", "ref_java": ["class Solution {\\n    public boolean increasingTriplet(int[] arr) {\\n        int n=arr.length;\\n        int arr2[]={3,7,5,3,2,1,6}", "class Solution {\\n    public boolean increasingTriplet(int[] nums) {\\n        \\n        int small = Integer.MAX_VALUE;\\n        int mid = Integer.MAX_VALUE;\\n\\n\\n        for(int big : nums) {\\n            if(big <= small) {\\n                small = big;\\n            }", "class Solution {\\n    public boolean increasingTriplet(int[] nums) {\\n       int max1 = Integer.MAX_VALUE;\\n       int max2 = Integer.MAX_VALUE;\\n       for(int n : nums) {\\n           if(n <= max1) max1 = n;\\n           else if(n <= max2) max2 = n;\\n           else return true;\\n       }"]}
{"id": "767", "ref_java": ["class Solution {\\n    public int rob(TreeNode root) {\\n     int[] p=help(root);\\n     return Math.max(p[0],p[1]);   \\n    }", "class Solution {\\n    public int rob(TreeNode root) {\\n        int ans[] = robHouse(root);\\n        return Math.max(ans[0],ans[1]);\\n    }", "class Solution {\\n        public int rob(TreeNode root) {\\n            int[] num = dfs(root);\\n            return Math.max(num[0], num[1]);\\n        }"]}
{"id": "769", "ref_java": ["class Solution {\\n    public int integerBreak(int n) {\\n        if (n <= 1) {\\n            return 0;\\n        }", "class Solution {\\n    public int integerBreak(int n) {\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        int two=1;\\n        int three=1;\\n        while(n>0){\\n            if(n%3==0){\\n                n-=3;\\n                three*=3;\\n            }", "class Solution {\\n    public int integerBreak(int n) {\\n        "]}
{"id": "770", "ref_java": ["class Solution {\\n    public int[] topKFrequent(int[] arr, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }", "class Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n      Map<Integer,Integer> map= new TreeMap<Integer,Integer>();\\n      ArrayList<Integer> list= new ArrayList<Integer>();\\n      int a[]=new int[k];\\n      int z=0;\\n       for(int i=0;i<nums.length;i++)\\n       {\\n        map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n       }", "class Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums)\\n            map.merge(i, 1, Integer::sum);"]}
{"id": "772", "ref_java": ["class Solution {\\n    int[] dp = new int[9];\\n    public Solution() {\\n        dp[0] = 1;\\n        dp[1] = 10;\\n        dp[2] = 91;\\n        for(int i=3; i<9; i++) {\\n            int count = 9;\\n            int ans = 9;\\n            for(int j=1; j<i; j++) {\\n                ans = ans * count;\\n                count--;\\n            }", "class Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int[] dp=new int[n+1];\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            int x=9,y=9,c=i;\\n            while(c-->1) x*=y--;\\n            dp[i]=dp[i-1]+x;\\n        }", "class Solution {\\n    static int[] res;\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (res == null) initArray();\\n        return res[n];\\n    }"]}
{"id": "773", "ref_java": ["class Solution {\\n    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\\n        if(targetCapacity > jug1Capacity + jug2Capacity){\\n            return false;\\n        }", "class Solution {\\n    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\\n        if(targetCapacity > jug1Capacity + jug2Capacity){\\n            return false;\\n        }", "class Solution {\\n    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\\n        if(targetCapacity > jug1Capacity + jug2Capacity){\\n            return false;\\n        }"]}
{"id": "774", "ref_java": ["class Solution {\\n    List<Integer> ll=new ArrayList<>();\\n    int[] dp;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        dp=new int[nums.length];\\n          Arrays.fill(dp,-1);\\n        Arrays.sort(nums);\\n        help(new ArrayList<>(),0,nums);\\n        return ll;\\n    }", "class Solution {\\n        public List<Integer> largestDivisibleSubset(int[] nums) {\\n            int n = nums.length;\\n            int[] count = new int[n];\\n            int[] pre = new int[n];\\n            Arrays.sort(nums);\\n            int max = 0, index = -1;\\n            for (int i = 0; i < n; i++) {\\n                count[i] = 1;\\n                pre[i] = -1;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (nums[i] % nums[j] == 0) {\\n                        if (1 + count[j] > count[i]) {\\n                            count[i] = count[j] + 1;\\n                            pre[i] = j;\\n                        }", "class Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        if(n==0)return new ArrayList(); "]}
{"id": "775", "ref_java": ["class Solution {\\n    public int getSum(int a, int b) {\\n        \\n        if(b==0) return a;\\n        ", "class Solution {\\n    public int getSum(int a, int b) \\n    {\\n        if(b>0)\\n        {\\n            for(int i=0;i<b;i++)\\n            {\\n                a++;\\n            }", "class Solution {\\n    public int getSum(int a, int b) \\n    {\\n        if(b>0)\\n        {\\n            for(int i=0;i<b;i++)\\n            {\\n                a++;\\n            }"]}
{"id": "776", "ref_java": ["class Solution {\\n    public int superPow(int a, int[] b) {\\n        int num=0;\\n        for(int i:b){\\n            num=(num*10+i)%1140;\\n        }", "class Solution {\\n    public int superPow(int a, int[] b) {\\n        long k=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            k=k*10+b[i];\\n            k=k%1140;\\n        }", "class Solution {\\n\\n  public int superPow(int a, int[] b) {\\n\\n    Mod mod = new Mod(1337);\\n      \\n    Mod tmod = new Mod(1140);\\n      \\n    return mod.expo(a,tmod.reduce(b));\\n\\n  }"]}
{"id": "777", "ref_java": ["class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0 || k <= 0) {\\n            return result;\\n        }", "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> resV = new ArrayList<>(); ", "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        return util1(nums1,nums2,k);\\n    }"]}
{"id": "778", "ref_java": ["class Solution {\\n    private int solveRec(int start, int end){\\n        if(start >= end){\\n            return 0;\\n        }", "class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        \\n        for (int i = n - 1; i >= 1; --i) {\\n            for (int j = i + 1; j <= n; ++j) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                ", "class Solution {\\n    private int solveRec(int start, int end){\\n        if(start >= end){\\n            return 0;\\n        }"]}
{"id": "779", "ref_java": ["class Solution {\\n    public int wiggleMaxLength(int[] nums) {\\n         if (nums.length < 2) {\\n        return nums.length;\\n    }", "class Solution {\\n    public int wiggleMaxLength(int[] nums) {\\n        if(nums.length<2)\\n           return 1;\\n        int inc = 1;\\n        int dec = 1;\\n        \\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1])\\n               inc = dec+1;\\n            else if(nums[i] < nums[i-1])\\n               dec = inc + 1;\\n        }", "class Solution {\\n    static int size;\\n    public static int calc(int idx,int arr[],int cap,int dp[][]){\\n        if(idx==size) return 0;\\n        if(dp[idx][cap]!=-1) return dp[idx][cap];\\n        "]}
{"id": "780", "ref_java": ["class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int j : nums) {\\n                if(i - j >= 0) {\\n                    dp[i] += dp[i-j];\\n                }", "class Solution {\\n  public int combinationSum4(int[] nums, int target) {\\n    var dp = new int[target + 1];\\n    dp[0] = 1;\\n    \\n    for (var i=1; i <= target; i++)\\n      for (var num : nums)\\n        dp[i] += i - num >= 0 ? dp[i - num] : 0;\\n\\n    return dp[target];\\n  }", "class Solution {\\n    int[] dp;\\n    public int combinationSum4(int[] nums, int t) {\\n        dp = new int[t+1];\\n        Arrays.fill(dp,-1);\\n        return dp(nums,t);\\n    }"]}
{"id": "781", "ref_java": ["class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }", "class Solution {\\n    public int kthSmallest(int[][] mat, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pq.size()>k)\\n                {\\n                    pq.poll();\\n                }", "class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix.length==1)\\n        return matrix[0][0];\\n        PriorityQueue<Integer> minheap=new PriorityQueue<>((a,b)->(a-b));\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                minheap.add(matrix[i][j]);\\n            }"]}
{"id": "785", "ref_java": ["class Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(isInteger(s)) {\\n            return s.isEmpty() ? new NestedInteger() : new NestedInteger(getIntegerValue(s));\\n        }", "class Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ans = new NestedInteger();\\n        deserializeHelper(s, ans);\\n        return ans;\\n    }", "class Solution {\\n    public NestedInteger deserialize(String s) {\\n        int n = s.length();\\n        \\n        "]}
{"id": "786", "ref_java": ["class Solution {\\n\\n    static List<Integer> arr;\\n    static int k;\\n\\n    static void helper(int n){\\n        if(n>k) return;\\n        if(n<=k && n!=0) arr.add(n);\\n        if(n==0){\\n            for(int i=1; i<=9; i++){\\n                helper(10*n+i);\\n            }", "class Solution {\\n    public List<Integer>result = new ArrayList<>();\\n    public void helper(int n,int curr){\\n        if(curr > n)\\n            return;\\n        result.add(curr);\\n        helper(n,curr*10);\\n        if(curr%10 != 9)\\n            helper(n,curr+1);\\n    }", "class Solution {\\n    public List<Integer> lexicalOrder(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){res.add(i);}"]}
{"id": "787", "ref_java": ["class Solution {\\n    public int lengthLongestPath(String input) {\\n        var stack = new ArrayDeque<Integer>();\\n        int max = 0;\\n        String[] lines = input.split(\"\\\\n\");\\n        for(var line: lines) {\\n            int tabs = countTabs(line);\\n            while(tabs < stack.size()) {\\n                stack.pop();\\n            }", "class Solution {\\n    public int lengthLongestPath(String input) {\\n        var stack = new ArrayDeque<Integer>();\\n        int max = 0;\\n        String[] lines = input.split(\"\\\\n\");\\n        for(var line: lines) {\\n            int tabs = countTabs(line);\\n            while(tabs < stack.size()) {\\n                stack.pop();\\n            }", "class Solution {\\n    public int lengthLongestPath(String input) {\\n        var stack = new ArrayDeque<Integer>();\\n        int max = 0;\\n        String[] lines = input.split(\"\\\\n\");\\n        for(var line: lines) {\\n            int tabs = countTabs(line);\\n            while(tabs < stack.size()) {\\n                stack.pop();\\n            }"]}
{"id": "788", "ref_java": ["class Solution {\\n    public int lastRemaining(int n) {\\n        ", "class Solution {\\n    public int lastRemaining(int n) {\\n        int head = 1;\\n        int remain = n;\\n        boolean left = true;\\n        int step =1;\\n        \\n        while(remain > 1){\\n            if(left || remain%2==1){\\n                head = head + step;\\n            }", "class Solution {\\n    public int lastRemaining(int n) {\\n        return n == 1 ? 1 : (n / 2 - lastRemaining(n / 2) + 1) * 2;\\n    }"]}
{"id": "789", "ref_java": ["class Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }", "class Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }", "class Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }"]}
{"id": "790", "ref_java": ["class Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }", "class Solution {\\n    private String repeat(int f, String t) {\\n        String d = \"\";\\n\\n        while(f-- > 0)\\n        d += t;\\n\\n        return d;\\n    }", "class Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> is = new Stack<>();\\n        Stack<StringBuilder> ss = new Stack<>();\\n\\n        int n = s.length(), num = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(char ch : s.toCharArray()) {\\n            "]}
{"id": "791", "ref_java": ["class Solution {\\n    public int longestSubstring(String s, int k) {\\n        if (s == null || s.length() == 0) return 0;\\n        char[] chars = new char[26];\\n        ", "class Solution {\\n    public int longestSubstring(String s, int k) {\\n        if (s == null || s.isEmpty() || k > s.length()) {\\n            return 0;\\n        }", "class Solution {\\n    public int longestSubstring(String s, int k) {\\n        if (s == null || s.isEmpty() || k > s.length()) {\\n            return 0;\\n        }"]}
{"id": "792", "ref_java": ["class Solution {\\n    public int maxRotateFunction (int[] A) {\\n        if (A == null || A.length == 0)\\n            return 0;\\n        int sum = 0, F0 = 0, max = Integer.MIN_VALUE;\\n        for (int i = 0; i < A.length; i++) {\\n            sum += A [i];\\n            F0 += i * A [i];\\n        }", "class Solution {\\n    public int maxRotateFunction(int[] nums) {\\n        int F = 0;\\n        int S = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            F = F + (nums[i] * i);\\n            S = S + nums[i];\\n        }", "class Solution {\\n    public int maxRotateFunction(int[] nums) {\\n        int n = nums.length;\\n        int totalSum = 0;\\n        int perRoundSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            totalSum += nums[i];\\n            perRoundSum += i * nums[i];\\n        }"]}
{"id": "793", "ref_java": ["class Solution {\\n    public int integerReplacement(int n) {\\n        int ans = 0;\\n        while (n != 1) {\\n            if ((n & 1) == 0) {\\n                n >>>= 1;\\n            }", "class Solution {\\n    Map<Integer, Integer> dp = new HashMap<>();\\n    public int integerReplacement(int n) {\\n        return helper(n);\\n    }", "class Solution {\\n    public int integerReplacement(int n) {\\n        HashSet<Long>set = new HashSet<>();\\n        Queue<Long>q=new LinkedList<>();\\n        q.add(n*1l);\\n        int lvl=0;\\n        while(!q.isEmpty()){\\n            int p = q.size();\\n            for(int i = 0;i<p;i++){\\n                long temp = q.poll();\\n                if(set.contains(temp)) continue;\\n                set.add(temp);\\n                if(temp==1){\\n                    return lvl;\\n                }"]}
{"id": "795", "ref_java": ["class Solution {\\n    public void dfs(String node, String dest, HashMap<String, HashMap<String, Double>> gr, HashSet<String> vis, double[] ans, double temp) {\\n        if (vis.contains(node))\\n            return;\\n\\n        vis.add(node);\\n        if (node.equals(dest)) {\\n            ans[0] = temp;\\n            return;\\n        }", "class Solution {\\n  public double[] calcEquation(List<List<String>> equations, double[] values,\\n                               List<List<String>> queries) {\\n    double[] ans = new double[queries.size()];\\n    Map<String, Map<String, Double>> graph = new HashMap<>();\\n    for (int i = 0; i < equations.size(); ++i) {\\n      final String A = equations.get(i).get(0);\\n      final String B = equations.get(i).get(1);\\n      graph.putIfAbsent(A, new HashMap<>());\\n      graph.putIfAbsent(B, new HashMap<>());\\n      graph.get(A).put(B, values[i]);\\n      graph.get(B).put(A, 1.0 / values[i]);\\n    }", "class Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = buildGraph(equations, values);\\n        double[] results = new double[queries.size()];\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String dividend = query.get(0);\\n            String divisor = query.get(1);\\n\\n            if (!graph.containsKey(dividend) || !graph.containsKey(divisor)) {\\n                results[i] = -1.0;\\n            }"]}
{"id": "796", "ref_java": ["class Solution {\\n    public int findNthDigit(int n) {\\n       \\n        ", "class Solution {\\n    public int findNthDigit(int n) {\\n        int digits = 1;\\n        long count = 9;\\n        int start = 1;\\n        \\n        while (n > digits * count) {\\n            n -= digits * count;\\n            digits++;\\n            count *= 10;\\n            start *= 10;\\n        }", "class Solution {\\n\\n    "]}
{"id": "797", "ref_java": ["class Solution {\\n    public String removeKdigits(String num, int k) {\\n        if(num.length()==k){\\n            return \"0\";\\n        }", "class Solution {\\n    public String removeKdigits(String num, int k) {\\n       Stack<Character> stk=new Stack<>();\\n       int n=num.length();\\n       if(k>=n)\\n       {\\n           return \"0\";\\n       }", "class Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }"]}
{"id": "798", "ref_java": ["class Solution {\\n    public int[][] reconstructQueue(int[][] people) {\\n        List<int[]> result = new ArrayList<>(); ", "class Solution {\\n    public int[][] reconstructQueue(int[][] people) {\\n        List<int[]> result = new ArrayList<>(); ", "class Solution {\\n    public int[][] reconstructQueue(int[][] people) {\\n        Arrays.sort(people, (a,b)->{\\n            if(a[0]==b[0]) return a[1]-b[1];\\n            return b[0]-a[0];\\n        }"]}
{"id": "799", "ref_java": ["class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length<3) return 0;\\n        int[] dp = new int[nums.length];\\n        int ans = 0;\\n\\n        for(int i=2; i<nums.length; i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp[i] = dp[i-1]+1;\\n                ans = ans+dp[i];    \\n            }", "class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n\\t\\n        if(nums.length<3) return 0;\\n        int count=0;\\n        for(int i=0 ; i<nums.length-2 ; i++)\\n        {\\n            if(i+2<nums.length && nums[i+1]-nums[i] == nums[i+2]-nums[i+1])\\n            {\\n                int d=nums[i+1] - nums[i];\\n                count++;\\n\\t\\t\\t\\t\\n                for(int j=i+2;j<nums.length-1 && nums[j+1]-nums[j]==d;j++) count++;\\n            }", "class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length<3) return 0;\\n        int[] dp = new int[nums.length];\\n        int ans = 0;\\n\\n        for(int i=2; i<nums.length; i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp[i] = dp[i-1]+1;\\n                ans = ans+dp[i];    \\n            }"]}
{"id": "800", "ref_java": ["class Solution {\\n    public boolean canPartition(int[] nums) {\\n      \\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }", "class Solution {\\n    public boolean canPartition(int[] nums) {\\n       \\n        int sum=0;\\n        for(int n:nums){\\n            sum+=n;\\n        }", "class Solution {\\n    public boolean canPartition(int[] nums) {\\n        int sum = 0; \\n        for(int n : nums) sum += n; \\n        if(sum %2 != 0) return false; \\n        int target = sum/2; \\n        Boolean[][] dp = new Boolean[nums.length][target+1];\\n        return partition(target, nums, 0, nums.length, dp);\\n    }"]}
{"id": "801", "ref_java": ["class Solution {\\n\\n    static int n;\\n    static int m;\\n    static int arr[][];\\n    static int dir[][] = {{0,1}", "class Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int row=heights.length;\\n        int col=heights[0].length;\\n\\n        int pacific[][]=new int[row][col];\\n        int atlantic[][]=new int[row][col];\\n\\n        int delRow[]={1,-1,0,0}", "class Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n\\n        int n=heights.length;\\n        int m=heights[0].length;\\n\\n        int pacific[][]=new int[n][m];\\n        int atlantic[][]=new int[n][m];\\n\\n        int delRow[]={1,-1,0,0}"]}
{"id": "802", "ref_java": ["class Solution {\\n    public int countBattleships(char[][] board) {\\n        boolean[][] visited=new boolean[board.length][board[0].length];\\n        for(int i=0; i<board.length ; i++){\\n            for(int j=0; j<board[0].length ; j++){\\n                if(board[i][j]==\\'.\\'){\\n                  visited[i][j]=true;\\n                }", "class Solution {\\n    public int countBattleships(char[][] board) {\\n        if (board == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }", "class Solution {\\n    public int countBattleships(char[][] board) {\\n        int count = 0;\\n        \\n        "]}
{"id": "803", "ref_java": ["class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Trie trie = new Trie();\\n        trie.insert(nums);\\n        \\n        int max = 0;\\n\\n        for(int num : nums) {\\n            Node curr = trie.root;\\n            int currSum = 0;\\n            for(int i=31;i>=0;i--) {\\n                int requiredBit = 1-((num >> i) & 1); ", "class Solution {\\n    class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }", "class Solution {\\n    class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }"]}
{"id": "804", "ref_java": ["class Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}", "class Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}", "class Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}"]}
{"id": "805", "ref_java": ["class Solution {\\n    public int characterReplacement(String s, int k) {\\n        ", "class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int i=0;\\n        int j=0;\\n        int max=0;\\n        int maxValueCount=0;\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        while(j<s.length()){\\n            char ch=s.charAt(j);\\n            hm.put(ch,hm.getOrDefault(ch,0)+1);\\n            maxValueCount=Math.max(hm.get(ch),maxValueCount);\\n            while(j-i+1-maxValueCount>k){\\n               char ch1=s.charAt(i);\\n                 hm.put(ch1,hm.getOrDefault(ch1,0)-1);\\n                i++;\\n            }", "class Solution {\\n    public int characterReplacement(String s, int k) {\\n        "]}
{"id": "807", "ref_java": ["class Solution {\\n    List<List<Integer>> res;\\n    void solve(Node cur, int level){\\n        if(cur == null)\\n            return ;\\n        if(level >= res.size()){\\n            res.add(new ArrayList<Integer>());\\n        }", "class Solution {\\n    public List<List<Integer>> levelOrder(Node node) {\\n        if (node == null) return new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        traverseTree(node, map, 0);\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            res.add(map.get(key));\\n        }", "class Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        while(!queue.isEmpty()) {\\n            int level = queue.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            for(int i = 0; i < level; i++) {\\n                Node node = queue.poll();\\n                if (node != null) {\\n                    levelNodes.add(node.val);\\n                    List<Node> children = node.children;\\n                    if (!children.isEmpty()) {\\n                        for(Node child: children) {\\n                            queue.add(child);\\n                        }"]}
{"id": "809", "ref_java": ["class Solution {\\n    private Map<String, List<String>> graph = new HashMap<>();\\n\\n    public int minMutation(String start, String end, String[] bank) {\\n        ", "class Solution {\\n    public boolean canTransform(String a,String b){\\n        int i=0;\\n        for(int j=0;j<a.length();j++){\\n            if(a.charAt(j)!=b.charAt(j)){\\n                i++;\\n            }", "class Solution {\\n    public int minMutation(String start, String end, String[] ban) {\\n        List<String> bank = new ArrayList<String>();\\n        bank.add(start);\\n        for(String b : ban) bank.add(b);\\n        HashSet<String> hs = new HashSet<String>();\\n        hs.add(start);\\n        HashMap<String,List<String>> map = new HashMap<>();\\n        for(String s : bank){\\n            for(String str : bank){\\n                if(difference(s,str) == 1){\\n                    List<String> lis = map.getOrDefault(s,new ArrayList<String>());\\n                    lis.add(str);           \\n                    map.put(s,lis);\\n                }"]}
{"id": "810", "ref_java": ["class Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        int max = intervals[0][1];\\n        int min = max;\\n        for (int i = 1; i < intervals.length; i++) {\\n            max = Math.max(max, intervals[i][1]);\\n            min = Math.min(min, intervals[i][1]);\\n        }", "class Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (a,b)->Integer.compare(a[0],b[0]));\\n        int ans = 0;\\n        int previous = 0;\\n        int n = intervals.length;\\n        for(int current = 1; current < n; current++)\\n        {\\n            if(intervals[current][0] < intervals[previous][1])\\n            {\\n                ans++;\\n                if(intervals[current][1] <= intervals[previous][1])\\n                {\\n                    previous = current;\\n                }", "class Solution {\\n    public int eraseOverlapIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        int ans = 0, left = 0, right = 1;\\n        while (right < intervals.length) {\\n            if (intervals[left][1] <= intervals[right][0]) { \\n                "]}
{"id": "811", "ref_java": ["class Solution {\\n    public int[] findRightInterval(int[][] intervals) {\\n        int n = intervals.length;\\n        int[][] arr = new int[n][3];\\n        for(int i=0;i<intervals.length;i++){\\n            arr[i][0] = intervals[i][0];\\n            arr[i][1] = intervals[i][1];\\n            arr[i][2] = i;\\n        }", "class Solution {\\n    public int[] findRightInterval(int[][] intervals) {\\n        int n = intervals.length;\\n        int ans[] = new int[n];\\n        \\n        List<Interval>list = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            list.add(new Interval(i, intervals[i][0], intervals[i][1]));\\n        }", "class Solution {\\n    public int[] findRightInterval(int[][] intervals) {\\n        int n = intervals.length;\\n        int[][] arr = new int[n][3];\\n        for(int i=0;i<intervals.length;i++){\\n            arr[i][0] = intervals[i][0];\\n            arr[i][1] = intervals[i][1];\\n            arr[i][2] = i;\\n        }"]}
{"id": "812", "ref_java": ["class Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n    return solve(root, targetSum, new ArrayList<>(), 0);\\n    }", "class Solution {\\n    ", "class Solution {\\n    int counter = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n\\n        if (root == null) return 0;\\n\\n        pathSumHelper(root, sum, 0);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n\\n        return counter;\\n\\n    }"]}
{"id": "813", "ref_java": ["class Solution {\\n    \\n    public List<Integer> findAnagrams(String s, String p) {\\n        if(p.length() > s.length())\\n            return Collections.emptyList();\\n        Map<Character, Integer> sCount = new HashMap<>(), pCount = new HashMap<>();\\n        for(char c : p.toCharArray()) {\\n            pCount.merge(c, 1, Integer::sum);\\n        }", "class Solution {\\n    public IList<int> FindAnagrams(string word, string pat) {\\n        ", "class Solution {\\n    \\n    "]}
{"id": "814", "ref_java": ["class Solution {\\n    public List<Integer> findDuplicates(int[] a) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < a.length; i++) {\\n            int index = Math.abs(a[i]) - 1;\\n            if (a[index] < 0) {\\n                res.add(Math.abs(a[i]));\\n                continue;\\n            }", "class Solution {\\n    public List<Integer> findDuplicates(int[] nums) {\\n        Vector<Integer> v = new Vector<Integer>();\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for (int i:nums) hm.put(i,hm.getOrDefault(i,0)+1);\\n\\n        for(int num:hm.keySet()){\\n            if(hm.get(num)>1) v.add(num);\\n        }", "class Solution {\\n    public List<Integer> findDuplicates(int[] nums) {\\n\\n        "]}
{"id": "815", "ref_java": ["class Solution {\\n  public int compress(char[] chars) {\\n    int ans = 0; ", "class Solution {\\n    public int compress(char[] chars) {\\n        int i=0;\\n        int n=chars.length;\\n        int j=0;\\n        if(n==1)\\n            return 1;\\n        while(i<n){\\n            int count=1;\\n            char charac=chars[i];\\n            while(i+1<n && chars[i]==chars[i+1]){\\n                count++;\\n                i++;\\n            }", "class Solution {\\n    public int compress(char[] chars) {\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<chars.length; i++) {\\n            count++;\\n\\n            if(i+1 == chars.length || chars[i]!= chars[i+1]) {\\n                chars[index] = chars[i];\\n                index++;\\n                if(count != 1) {\\n                    for(char ch : Integer.toString(count).toCharArray()) {\\n                        chars[index] = ch;\\n                        index++;\\n                    }"]}
{"id": "816", "ref_java": ["class Solution {\\n    public ListNode addTwoNumbers(ListNode ll1, ListNode ll2) {\\n        ListNode ans = new ListNode();\\n        ListNode res = ans;\\n        int c = 0;\\n        ListNode l1 = reverse(ll1);\\n        ListNode l2 = reverse(ll2);\\n        while(l1!=null || l2!=null){\\n            int s = 0;\\n            if(l1 != null){\\n                s += l1.val;\\n                l1 = l1.next;\\n            }", "class Solution {\\n    private int length(ListNode temp) {\\n        int size = 0;\\n        while (temp != null) {\\n            size++;\\n            temp = temp.next;\\n        }", "class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1=0,size2=0;\\n        ListNode temp1=l1;\\n        ListNode temp2=l2;\\n        while(temp1!=null || temp2!=null){\\n            if(temp1==null){size2+=1; temp2=temp2.next;}"]}
{"id": "817", "ref_java": ["class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points)\\n                boomerangs += map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n            map.clear();\\n        }", "class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points)\\n                boomerangs += map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n            map.clear();\\n        }", "class Solution {\\n    public long getDist(int i,int j,int arr[][]){\\n        long a1=(long)arr[i][0];\\n        long a2=(long)arr[j][0];\\n        long b1=(long)arr[i][1];\\n        long b2=(long)arr[j][1];\\n        return (a1-a2)*(a1-a2)+(b1-b2)*(b1-b2);\\n    }"]}
{"id": "819", "ref_java": ["class Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return root;\\n\\n        if(root.val == key) {\\n           if(root.left == null) return root.right; \\n           else if(root.right == null) return root.left;\\n           else {\\n              TreeNode temp = root.right;\\n              while(temp.left != null) {\\n                  temp = temp.left;\\n              }", "class Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return root;\\n\\n        if(root.val == key) {\\n           if(root.left == null) return root.right; \\n           else if(root.right == null) return root.left;\\n           else {\\n              TreeNode temp = root.right;\\n              while(temp.left != null) {\\n                  temp = temp.left;\\n              }", "class Solution {\\n    TreeNode solve(TreeNode root){\\n        if(root.left==null){\\n            return root.right;\\n        }"]}
{"id": "820", "ref_java": ["class Solution {\\n    static class Pair{\\n        char ch;\\n        int freq;\\n        public Pair(char ch, int freq){\\n            this.ch=ch;\\n            this.freq=freq;\\n        }", "class Solution {  \\n  public String frequencySort(String s) {\\n      StringBuilder sb = new StringBuilder();\\n      Map<Character, Integer> charCountMap = new HashMap<>();\\n      int len = s.length();\\n      for(int i = 0; i < len; i++) {\\n          char ch = s.charAt(i);\\n          charCountMap.put(ch, charCountMap.getOrDefault(ch, 0) + 1);\\n      }", "class Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\t    for (char c: s.toCharArray()) {\\n\\t\\t    map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t    }"]}
{"id": "821", "ref_java": ["class Solution {\\n    public int findMinArrowShots(int[][] arr) {\\n        Arrays.sort(arr,(a,b)->Integer.compare(a[1], b[1]));\\n        int i=0;\\n        int cnt =0;\\n        int x = arr[0][1];\\n        while (i<arr.length) {\\n           if(arr[i][0]>x){\\n               cnt++;\\n               x=arr[i][1];\\n           }", "class Solution {\\n   ", "class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        PriorityQueue<pair> pq = new PriorityQueue<>(new Comparator<pair>() {\\n            public int compare(pair a, pair b) {\\n                if (a.end < b.end)\\n                    return -1;\\n                return 1;\\n            }"]}
{"id": "822", "ref_java": ["class Solution {\\n    public int minMoves(int[] nums) {\\n        ", "class Solution {\\n    public int minMoves(int[] nums) {\\n         int mn=nums[0];\\n         int rs=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           if(nums[i]<mn)\\n           mn=nums[i];   \\n        }", "class Solution {\\n    public int minMoves(int[] nums) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n\\n        for(int i = nums.length;i >= 0;i--){\\n            int diff = nums[i] - nums[0];\\n            sum += diff;\\n        }"]}
{"id": "823", "ref_java": ["class Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                for(int k : nums3)\\n                    for(int l : nums4)\\n                        if(i + j + k + l == 0) count++;\\n        return count;\\n    }", "class Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                for(int k : nums3)\\n                    for(int l : nums4)\\n                        if(i + j + k + l == 0) count++;\\n        return count;\\n    }", "class Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int[] m1 = getMaxMin(nums1);\\n        int[] m2 = getMaxMin(nums2);\\n        int[] m3 = getMaxMin(nums3);\\n        int[] m4 = getMaxMin(nums4);\\n\\n        int max = Math.max((m1[0]+m2[0]), -(m3[1]+m4[1]));\\n        int min = Math.min((m1[1]+m2[1]), -(m3[0]+m4[0]));\\n\\n        int[] dp = new int[max-min+1];\\n        for(int i: nums1){\\n            for(int j: nums2){\\n                dp[i+j-min]++;\\n            }"]}
{"id": "824", "ref_java": ["class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int max3 = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < max3)\\n                return true;\\n            while (!stack.isEmpty() && stack.peek() < nums[i]) {\\n                max3 = stack.peek();\\n                stack.pop();\\n            }", "class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int length = nums.length;\\n        \\n        ", "class Solution {\\n    public boolean find132pattern(int[] nums) {\\n       int third = Integer.MIN_VALUE;\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < third) {\\n                return true;\\n            }"]}
{"id": "825", "ref_java": ["class Solution {\\n    public static boolean circularArrayLoop(int[] nums) {\\n    int slow = 0, fast = 0;\\n    int size = nums.length;\\n    for (int i = 1; i <= size; i++) {\\n      int prev = slow;\\n      slow = nextStep(slow, nums[slow], size);\\n      if (isNotCycle(nums, prev, slow)) {\\n        fast = i;\\n        slow = i;\\n        continue;\\n      }", "class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0; i<nums.length; i++) {\\n            boolean frontDirection = nums[i]>=0;\\n            \\n            int currentPosition = i;\\n            int fastPosition = i;\\n            \\n            while(true) {\\n                currentPosition = getNextPosition(nums, currentPosition, frontDirection);\\n                \\n                if(currentPosition==-1) {\\n                    break;\\n                }", "class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i=0; i<nums.length; i++) {\\n            boolean isForward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i; \\n            do {\\n                slow = findNextIndex(nums, isForward, slow);\\n                fast = findNextIndex(nums, isForward, fast);\\n                if (fast != -1) {\\n                    fast = findNextIndex(nums, isForward, fast);\\n                }"]}
{"id": "826", "ref_java": ["class Solution {\\n    public int minMoves2(int[] nums) {\\n        int length = nums.length;\\n        int result = 0;\\n        int median = helper(nums, 0, length - 1, (length - 1) / 2);\\n        for (int x : nums) {\\n            result += Math.abs(x - median);\\n        }", "class Solution {\\n    public int minMoves2(int[] nums) {\\n        int operations = 0, mid = quickSelect(nums, 0, nums.length-1, nums.length/2);\\n        for (int num: nums) operations += Math.abs(mid - num);\\n        return operations;\\n    }", "class Solution {\\n    public int minMoves2 (int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n        int n = nums.length;\\n        Arrays.sort (nums);\\n        int mid = n/2;\\n        int count = 0;\\n        for (int i = 0; i < n; i++)\\n            count += (Math.abs (nums [i] - nums [mid]));\\n        return count;\\n    }"]}
{"id": "827", "ref_java": ["class Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        return util1(maxChoosableInteger,desiredTotal);\\n    }", "class Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        ", "class Solution {\\n    int numlimit, tgt;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        numlimit = maxChoosableInteger;\\n        tgt = desiredTotal;\\n        \\n        int maxsum = (numlimit*(numlimit+1))/2;\\n        if(maxsum < tgt)\\n            return false;\\n        \\n        int dp[] = new int[(1<<numlimit)];\\n        if(solve(0, 0, 0, dp)){\\n            return true;\\n        }"]}
{"id": "828", "ref_java": ["class Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] count = new int[26];\\n        int cur = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(i > 0 && (s.charAt(i)-s.charAt(i-1) == 1 || s.charAt(i-1)-s.charAt(i) == 25)){ \\n                cur++;\\n            }", "class Solution {\\n    public int findSubstringInWraproundString(String s) {\\n        int[] maxlen = new int[26];\\n        int maxEnd = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char currChar = s.charAt(i);\\n\\n            ", "class Solution {\\n public int findSubstringInWraproundString(String s) {\\n    int [] res = new int[26];\\n    int l = 0;\\n    for(int i = 0 ;i<s.length();i++){\\n    if(i>0 &&((s.charAt(i-1)+1)==s.charAt(i)||s.charAt(i-1)==s.charAt(i)+25))\\n        l++;\\n        else\\n        l = 1;\\n        res[s.charAt(i)-\\'a\\'] = Math.max(res[s.charAt(i)-\\'a\\'],l);\\n        }"]}
{"id": "829", "ref_java": ["class Solution {\\n    public String validIPAddress(String queryIP) {\\n        if(isIPV4(queryIP) == true) return \"IPv4\";\\n        else if(isIPV6(queryIP) == true) return \"IPv6\";\\n        else return \"Neither\";\\n    }", "class Solution {\\n    public String validIPAddress(String queryIP) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        ", "class Solution {\\n    public String validIPAddress(String queryIP) {\\n        if(isIPV4(queryIP) == true) return \"IPv4\";\\n        else if(isIPV6(queryIP) == true) return \"IPv6\";\\n        else return \"Neither\";\\n    }"]}
{"id": "830", "ref_java": ["\nclass Solution extends SolBase {\n    public int rand10() {\n\n        int x= rand7();\n        int y= rand7();\n\n        int ans = ((x-1)*7+y) ;\n\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\n         \n    }\n}\n", "\nclass Solution extends SolBase {\n    public int rand10() {\n\n        int x= rand7();\n        int y= rand7();\n\n        int ans = ((x-1)*7+y) ;\n\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\n         \n    }\n}\n", "\nclass Solution extends SolBase {\n    public int rand10() {\n\n        int x= rand7();\n        int y= rand7();\n\n        int ans = ((x-1)*7+y) ;\n\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\n         \n    }\n}\n"]}
{"id": "831", "ref_java": ["class Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        \\n        int total = 0;\\n        \\n        for (int i : matchsticks) {\\n            total += i;\\n        }", "class Solution {\\n    public boolean makesquare(int[] M) {\\n        Arrays.sort(M);\\n        int total = 0;\\n        for (int i = 0; i < M.length; i++)\\n            total += M[i];\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[M.length-1] > side)\\n            return false;\\n        return btrack(M.length-1, side, 0, M);\\n    }", "class Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks == null || matchsticks.length == 0)return false;\\n        int sum =0;\\n        for(int num:matchsticks)sum+=num;\\n        \\n        if(sum%4!=0)return false;\\n        \\n        Arrays.sort(matchsticks);\\n        \\n        return dfs(matchsticks,new int[4], matchsticks.length-1,sum/4);\\n    }"]}
{"id": "832", "ref_java": ["class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        HashMap<String,Pair> map = new HashMap<>();\\n        updateMap(strs,map);\\n        int size = strs.length;\\n        int[][][] dp = new int[size][m+1][n+1];\\n        for(int[][] matrix:dp) for(int[] rows:matrix) Arrays.fill(rows,-1);\\n        return function(strs,0,m,n,map,size,dp);\\n    }", "class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int[][][] dp = new int[strs.length + 1][m + 1][n + 1];\\n        ", "class Solution {\\n    public int findMaxForm(String[] S, int M, int N) {\\n        int[][] dp = new int[M+1][N+1];\\n        for (String str : S) {\\n            int zeros = 0, ones = 0;\\n            for (char c : str.toCharArray())\\n                if (c == \\'0\\') zeros++;\\n                else ones++;\\n            for (int i = M; i >= zeros; i--)\\n                for (int j = N; j >= ones; j--)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1);\\n        }"]}
{"id": "833", "ref_java": ["class Solution {\\n  public boolean can(int r, int[] houses, int[] heaters) {\\n    int prevHouseIdx = -1;\\n    for(int i = 0; i < heaters.length; i++) {\\n      int from = heaters[i]-r;\\n      int to   = heaters[i]+r;\\n      for(int j = prevHouseIdx+1; j < houses.length; j++){\\n        if(houses[j]<=to && houses[j]>=from){\\n          prevHouseIdx++;\\n        }", "class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int i=0, j=(int)1e9;\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n\\n            if(isPossible(houses,heaters,mid)){\\n                j=mid-1;\\n            }", "class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0 || heaters == null || heaters.length == 0){\\n            return 0;\\n        }"]}
{"id": "834", "ref_java": ["class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<=nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<=nums.length-1;j++)\\n            {\\n                sum=sum + Integer.bitCount(nums[i] ^ nums[j]);\\n            }", "class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int sum=0;\\n        for(int i =0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                sum+=HammingDistance(nums[i],nums[j]);\\n            }", "class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int hammingD = 0;\\n        for( int i = 0 ; i < 32 ; i++)\\n        {\\n            int count1s = 0;\\n            for( int j = 0; j < nums.length; j++)\\n            {\\n                count1s += (nums[j] >>> i)&1 ;"]}
{"id": "836", "ref_java": ["class Solution {\\n    public int magicalString(int n) {\\n        if (n <= 0) return 0;\\n        if (n <= 3) return 1;\\n\\n        StringBuilder s = new StringBuilder(\"122\");\\n        int ptr = 2;\\n        int count = 1;\\n\\n        while (s.length() < n) {\\n            int num = s.charAt(ptr) - \\'0\\';\\n            char toAdd = (s.charAt(s.length() - 1) == \\'1\\') ? \\'2\\' : \\'1\\';\\n\\n            ", "class Solution {\\n    public int magicalString(int n) {\\n        StringBuilder st=new StringBuilder(\"122\");\\n        int p1=2,p2=st.length(),count=0;\\n        while(st.length()<n){\\n            if(st.charAt(p1)==\\'1\\'){\\n                if(st.charAt(p2-1)==\\'1\\')\\n                    st.append(2);\\n                else\\n                    st.append(1);\\n                p2++;\\n            }", "class Solution {\\n    public int magicalString(int n) {\\n        boolean writingOne = false;\\n        boolean[] trueIfOne = new boolean[n];\\n        if (n <= 3) return 1;\\n        trueIfOne[0] = true;\\n        trueIfOne[1] = false;\\n        trueIfOne[2] = false;\\n        int reader = 2;\\n        int numberOfWrites = 0;\\n        int onesInString = 1;\\n        for (int i = 3; i < n; i++) {\\n            if (numberOfWrites == 0) {\\n                writingOne = !writingOne;\\n                numberOfWrites = trueIfOne[reader] ? 1 : 2;\\n                reader++;\\n            }"]}
{"id": "837", "ref_java": ["class Solution {\\n    private int[][] dp = new int[23][23];\\n\\n    public int solve(int[] nums, int F, int L) {\\n        if (F > L) return 0;\\n        if (F == L) return nums[F];\\n        if (dp[F][L] != -1) return dp[F][L];\\n\\n        int F_score = nums[F] - solve(nums, F + 1, L);\\n        int L_score = nums[L] - solve(nums, F, L - 1);\\n        dp[F][L] = Math.max(F_score, L_score);\\n        return dp[F][L];\\n    }", "class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n\\n        if (n == 0 || n == 1) {\\n            return true;\\n        }", "class Solution {\\n    public boolean PredictTheWinner(int[] nums) {\\n         int[][] memo = new int[nums.length][nums.length];\\n        return getScore(0, nums.length - 1, nums, memo) >= 0;\\n    }"]}
{"id": "838", "ref_java": ["class Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }", "class Solution {\\n\\n    public Solution() {}", "class Solution {\\n     List<List<Integer>>l=new ArrayList();\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        backtrack(0,nums,new ArrayList(),Integer.MIN_VALUE);\\n        return l;\\n    }"]}
{"id": "839", "ref_java": ["class Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        ", "class Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return helper(nums, 0, 0, target);\\n    }", "class Solution {\\n\\n    public int findTargetSumWays(int[] nums, int target) {\\n    \\n        return helper(nums,0,target,0);\\n    }"]}
{"id": "841", "ref_java": ["class Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        if (mat.length < 0) \\n            return new int[] {}", "class Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[m*n];\\n        int row=0;\\n        int col=0;\\n        int i=0;\\n        boolean flag=false;\\n        while(true){\\n         while(row>=0 && col<m){\\n            ans[i++]=mat[row][col];\\n            if(i==m*n) {\\n                flag=true;\\n                break;\\n            }", "class Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int size = mat.length * mat[0].length;\\n        int[] res = new int[size];\\n        int k = 0;\\n        int sum = 0;\\n        int revFlag = 1;\\n        while(k < size){\\n            "]}
{"id": "842", "ref_java": ["class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int j=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=max){\\n                max=nums[i];\\n                j=i;\\n            }", "class Solution {\\n\\t\\tpublic int[] nextGreaterElements(int[] nums) {\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\tint size = (n*2) - 1, k = n - 1;\\n\\t\\t\\tStack<Integer> stck = new Stack();\\n\\t\\t\\tint[] ans = new int[n];\\n\\t\\t\\tArrays.fill(ans, -1);\\n\\n\\t\\t\\twhile(size >= 0) {\\n\\t\\t\\t\\tint idx = size%n;\\n\\n\\t\\t\\t\\twhile(!stck.isEmpty() && stck.peek() <= nums[idx]) \\n\\t\\t\\t\\t\\tstck.pop();\\n\\n\\t\\t\\t\\tif(size < n) {\\n\\t\\t\\t\\t\\tif(!stck.isEmpty() && stck.peek() > nums[idx])\\n\\t\\t\\t\\t\\t\\tans[k] = stck.peek();\\n\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t}", "class Solution {\\n    public int[] nextGreaterElements(int[] nums) {\\n        int m = nums.length;\\n        int n = m*2;\\n        Stack<Integer> stk = new Stack<>();\\n        int temp[] = new int[n];\\n        for (int i=n-1; i>=0; i--) {\\n            if (stk.size()==0) {\\n                temp[i] = -1;\\n                stk.push(nums[i%m]);\\n                continue;\\n            }"]}
{"id": "843", "ref_java": ["class Solution {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    int max=0;\\n    public int[] findFrequentTreeSum(TreeNode root) {\\n        if(root==null){\\n            int arr[] = new int[0];\\n            return arr;\\n        }", "class Solution {\\n    private int mostFrequency = 0;\\n    private int dfs(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null){\\n            return 0;\\n        }", "class Solution {\\n    private int mostFrequency = 0;\\n    private int dfs(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null){\\n            return 0;\\n        }"]}
{"id": "844", "ref_java": ["class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        return helper(root, 0).getKey().val;\\n    }", "class Solution {\\n    static int parent=-1;\\n    static int ans=0;\\n    public int findBottomLeftValue(TreeNode root) {\\n       help(root,0);\\n       int res=ans;ans=0;\\n       parent=-1;\\n       return res;\\n    }", "class Solution {\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }"]}
{"id": "845", "ref_java": ["class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        queue.offer(root);\\n        if(root==null)  return ans;\\n        while(!queue.isEmpty())\\n        {\\n            int level = queue.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<level;i++)\\n            {\\n                TreeNode temp =queue.poll();\\n                if(temp.left!=null)\\n                {\\n                    queue.offer(temp.left);\\n                }", "class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        if (root == null) {\\n            return new ArrayList<Integer>();\\n        }", "class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List <Integer> list =new LinkedList<>();\\n        if(root==null) return list;\\n        Queue <TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int max=Integer.MIN_VALUE;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node= q.poll();\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!=null) q.add(node.right);\\n                max= Math.max(max, node.val);\\n            }"]}
{"id": "846", "ref_java": ["class Solution {\\n      public int helper(String s,int[][] matrix,int i, int j) {\\n        if(i==j)\\n            return 1;\\n        if (i>j)\\n            return 0;\\n        if(matrix[i][j]!=-1)\\n            return matrix[i][j];\\n        if(s.charAt(i)==s.charAt(j)) \\n            return matrix[i][j] = helper(s,matrix,i+1,j-1)+2;\\n        return matrix[i][j] = Math.max(helper(s,matrix,i+1,j),helper(s,matrix,i,j-1));\\n    }", "class Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n][n];\\n        for(int gap=0; gap<n; gap++){\\n            for(int i=0, j=gap; j<n ; i++, j++){\\n                if(gap==0){\\n                   dp[i][j]=1;\\n                }", "class Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n+1][n+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i+1][j+1]=(s.charAt(i)==s.charAt(n-1-j)?dp[i][j]+1:Math.max(dp[i+1][j],dp[i][j+1]));\\n        return dp[n][n];\\n    }"]}
{"id": "847", "ref_java": ["class Solution {\\n\\n    public int count(int i,int[][] dp,int[] coins,int amount){\\n        if(amount==0)\\n            return 1;\\n        if(i<coins.length){\\n        if(dp[i][amount]==-1){\\n        if(coins[i]>amount)\\n            return 0;\\n        return dp[i][amount]=count(i,dp,coins,amount-coins[i])+count(i+1,dp,coins,amount);\\n        }", "class Solution {\\n    public int change(int amount, int[] coins) {\\n\\n        HashMap<Pair,Integer> map=new HashMap<>();\\n        return fn(coins.length-1,0,coins,amount,map);\\n    }", "class Solution {\\n    public int change(int amount, int[] coins) {\\n    int[] dp = new int[amount + 1];\\n    dp[0] = 1;\\n\\n    for (int coin : coins) {\\n        for (int i = coin; i <= amount; i++) {\\n            dp[i] += dp[i - coin];\\n        }"]}
{"id": "849", "ref_java": ["class Solution {\\n        public int findLUSlength(String[] strs) {\\n        Arrays.sort(strs, new Comparator<String>() {\\n            public int compare(String o1, String o2) {\\n                return o2.length() - o1.length();\\n            }", "class Solution {\\n        public int findLUSlength(String[] strs) {\\n        Arrays.sort(strs, new Comparator<String>() {\\n            public int compare(String o1, String o2) {\\n                return o2.length() - o1.length();\\n            }", "class Solution {\\n    private boolean isSubsequence(String s1, String s2){\\n        int i=0, j=0;\\n        while(i < s1.length() && j < s2.length()){\\n            if(s1.charAt(i) == s2.charAt(j++)) i++;\\n        }"]}
{"id": "850", "ref_java": ["class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        if (nums.length < 2) return false;\\n        Map<Integer, Integer> remainderMap = new HashMap<>();\\n        remainderMap.put(0, -1); \\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (k != 0) {\\n                sum %= k;\\n            }", "class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n < 2) return false;\\n\\n        ", "class Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm  = new HashMap<>();\\n        hm.put(0,0);\\n        \\n        int sum = 0;\\n        "]}
{"id": "851", "ref_java": ["class Solution {\\n    public String findLongestWord(String s, List<String> dictionary) {\\n        int[][] nextChar = preprocess(s);\\n        String output = null;\\n        for(String word : dictionary)\\n            if(found(nextChar, word) && (output==null || output.length() < word.length() || (output.length() == word.length() && output.compareTo(word)>0)))\\n                output = word;\\n        return (output==null)?\"\":output;\\n    }", "class Solution {\\n    public String findLongestWord(String s, List<String> dictionary) {\\n        \\n        int maxLength = 0;\\n        String maxWord = \"\";\\n\\n        for(String word : dictionary) {\\n            int length = checkIfWordPresentInString(s, word);\\n\\n            if(length > maxLength || (length == maxLength && maxWord.compareTo(word) > 0)) {\\n                maxLength = length;\\n                maxWord = word;\\n            }", "class Solution {\\n    public String findLongestWord(String S, List<String> D) {\\n        String ans = \"\";\\n        for (String word : D) {\\n            int a = word.length(), b = ans.length();\\n            if (a < b || (a == b && word.compareTo(ans) > 0)) continue;\\n            int pos = -1;\\n            for (int i = 0; i < a; i++) {\\n                pos = S.indexOf(word.charAt(i), pos + 1);\\n                if (pos == -1) break;\\n            }"]}
{"id": "852", "ref_java": ["class Solution {\\n    public int findMaxLength(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int zeros = 0, ones = 0;\\n            for (int j = i; j < nums.length; j++) {\\n                if (nums[j] == 0) {\\n                    zeros++;\\n                }", "class Solution {\\n    public int findMaxLength(int[] nums) {\\n        int N = nums.length;\\n        int[] mp = new int[2*N+2];\\n        int current = N;\\n        int result = 0;\\n\\n        for(int i = 0; i < N; i++) {\\n            current += (nums[i] << 1) - 1;\\n            if(current == N) {\\n                result = i+1;\\n            }", "class Solution {\\n    public int findMaxLength(int[] nums) {\\n        HashMap<Integer, Integer> h =new HashMap<>();\\n        int pre = 0;\\n        int max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == 1){\\n                pre += 1;\\n            }"]}
{"id": "853", "ref_java": ["class Solution {\\n    int dp[][],n;\\n    public int countArrangement(int _n) {\\n        n=_n;\\n        if(n<=1) return n;\\n        dp=new int[n+1][1<<(n+1)];\\n        for(int i=0;i<=n;i++)\\n            Arrays.fill(dp[i],-1);\\n        return rec(1,0);\\n    }", "class Solution {\\n    private boolean okay(int a, int b) {\\n        return a % b == 0 || b % a == 0;\\n    }", "class Solution {\\n    \\n    int noOfBeautifulArrangement= 0;"]}
{"id": "855", "ref_java": ["class Solution {\\nprivate int x = 0, y = 0;\\nprivate int cB(char[][] B,int i,int j){\\n    int count = 0;\\n    if(j > 0){\\n        if(i > 0 && B[i - 1][j - 1] == \\'M\\') count++;\\n        if(B[i][j - 1] == \\'M\\') count++;\\n        if(i < x && B[i + 1][j - 1] == \\'M\\') count++;\\n    }", "class Solution {\\n\\n    int[][] dirs = new int[][]{{1,0}", "class Solution {\\n    char[][] b;\\n    int rowMax;\\n    int colMax;\\n    public char[][] updateBoard(char[][] b, int[] c) {\\n        this.b = b;\\n        this.rowMax = b.length;\\n        this.colMax = b[0].length;\\n        \\n        if (this.b[c[0]][c[1]] == \\'M\\') {\\n            this.b[c[0]][c[1]] = \\'X\\';\\n            return this.b;\\n        }"]}
{"id": "856", "ref_java": ["class Solution {\\n\\t\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\t\\tMap<Integer, Integer> map = new HashMap();\\n\\t\\t\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t\\t\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\t\\t\\t\\t\\tint result = 0;\\n\\t\\t\\t\\t\\tfor (int i : map.keySet())\\n\\t\\t\\t\\t\\t\\tif (k > 0 && map.containsKey(i + k) || k == 0 && map.get(i) > 1)\\n\\t\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}", "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int i=0;\\n        int j=1;\\n        int m=0;\\n        int abs=0;\\n        Arrays.sort(nums);\\n        int sum=Integer.MIN_VALUE;\\n        while(i<nums.length-1 && j<nums.length){\\n            ", "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n       \\n        int n = nums.length;\\n        Arrays.sort(nums);\\n       \\n        int  i =0;\\n        int j = i+1;\\nint findpairs = 0;\\n        while(j<n && i<n ){\\n            if(i==j){\\n                j++;\\n            }"]}
{"id": "858", "ref_java": ["class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int a=Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int b=Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.indexOf(\\'i\\')));", "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        ", "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String str1[]=num1.split(\"\\\\\\\\+\");\\n        String str2[]=num2.split(\"\\\\\\\\+\");\\n\\t\\t\\n        int a=Integer.valueOf(str1[0]);    "]}
{"id": "859", "ref_java": ["class Solution {\\n    static Set<Integer> set;\\n    static int sum;\\n    public TreeNode convertBST(TreeNode root) {\\n        set = new TreeSet<>();\\n        sum = 0;\\n        traverseBST(root);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (Integer i : set) {\\n            map.put(i, sum);\\n            sum -= i;\\n        }", "class Solution {\\n    int sum = 0;\\n    public TreeNode convertBST(TreeNode root) {\\n        if(root==null){\\n            return root;\\n        }", "class Solution {\\n    private int sum = 0;\\n    public TreeNode convertBST(TreeNode root) {\\n        if (root == null) return null;\\n        convertBST(root.right);\\n        sum += root.val;\\n        root.val = sum;\\n        convertBST(root.left);\\n        return root;\\n    }"]}
{"id": "860", "ref_java": ["class Solution {\\n    public int findMinDifference(List<String> timePoints) {\\n        boolean[] visited = new boolean[24 * 60];\\n        for (String time : timePoints) {\\n            int h = Integer.parseInt(time.substring(0, 2));\\n            int m = Integer.parseInt(time.substring(3));\\n            if (visited[h * 60 + m]) return 0; ", "class Solution {\\n    private int compare1(int[] time1, int[] time2) {\\n        int totalMin = time2[1] - time1[1];\\n        int hr = 0;\\n        if (time1[1] > time2[1]) {\\n            totalMin += 60;\\n            hr = -1;\\n        }", "class Solution {\\n    public int findMinDifference(List<String> timePoints) {\\n        boolean[] visited = new boolean[24 * 60];\\n        for (String time : timePoints) {\\n            int h = Integer.parseInt(time.substring(0, 2));\\n            int m = Integer.parseInt(time.substring(3));\\n            if (visited[h * 60 + m]) return 0; "]}
{"id": "861", "ref_java": ["class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }", "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }", "class Solution {\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        int i = 0;\\n        int j = nums.length-1;\\n        int mid = (i + j)/2;\\n        if(j == 0){return nums[0];}"]}
{"id": "862", "ref_java": ["class Solution {\\n    public int[][] updateMatrix(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m][n];\\n        \\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                dp[row][col] = mat[row][col];\\n            }", "class Solution {\\n    public int[][] updateMatrix(int[][] mat) {\\n        int[][] ans = new int[mat.length][mat[0].length];\\n        Queue<int[]> q = new LinkedList<>();        \\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                ans[i][j] = -1;\\n                if(mat[i][j]==0){\\n                    ans[i][j] = 0;\\n                    q.add(new int[]{i,j}", "class Solution {\\n    public int[][] updateMatrix(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int[][] res = new int[n][m];\\n        \\n        "]}
{"id": "863", "ref_java": ["class Solution {\\n    public int findCircleNum(int[][] isConnected) {\\n        int result = 0;\\n        for (int i=0; i<isConnected.length; i++) {\\n            if (isConnected[i][i] == 1) {\\n                result++;\\n                clear(isConnected, i);\\n            }", "class Solution {\\n\\n    ", "class Solution {\\n    public int findCircleNum(int[][] isConnected) {\\n        \\n        int n = isConnected.length;\\n        int numOfComponents = n;\\n        \\n        UnionFind uf = new UnionFind(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(isConnected[i][j] ==1 && uf.find(i) != uf.find(j) ){\\n                    "]}
{"id": "865", "ref_java": ["class Solution {\\n    public String optimalDivision(int[] nums) {\\n        int n = nums.length;\\n        StringBuilder sb = new StringBuilder().append(nums[0]);\\n\\n        if (n == 1) return sb.toString();\\n        if (n == 2) return sb.append(\"/\").append(nums[1]).toString();\\n        sb.append(\"/(\");\\n        for (int i = 1; i < n; i++) \\n            sb.append(nums[i]).append(\"/\");\\n        \\n        sb.setCharAt(sb.length()-1, \\')\\');\\n        return sb.toString();\\n    }", "class Solution {\\n    public String optimalDivision(int[] nums) {\\n        int n = nums.length;\\n        StringBuilder sb = new StringBuilder().append(nums[0]);\\n\\n        if (n == 1) return sb.toString();\\n        if (n == 2) return sb.append(\"/\").append(nums[1]).toString();\\n        sb.append(\"/(\");\\n        for (int i = 1; i < n; i++) \\n            sb.append(nums[i]).append(\"/\");\\n        \\n        sb.setCharAt(sb.length()-1, \\')\\');\\n        return sb.toString();\\n    }", "class Solution {\\n    public String optimalDivision(int[] nums) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = nums.length;\\n        \\n        sb.append(nums[0]);        \\n\\n        if(n == 1) return sb.toString();\\n        if(n ==2) return sb.append(\"/\").append(nums[1]).toString();\\n\\n        sb.append(\"/(\");\\n        \\n        for(int i = 1; i < n; i++)\\n            sb.append(nums[i]).append(\"/\");\\n        \\n        sb.deleteCharAt(sb.length()-1);\\n        sb.append(\")\");\\n\\n        return sb.toString();\\n    }"]}
{"id": "866", "ref_java": ["class Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer,Integer> hmap=new HashMap<>();\\n        for(int i=0;i<wall.size();i++){\\n            List<Integer> listEle=wall.get(i);\\n            int sum=0;\\n            for(int j=0;j<listEle.size()-1;j++){\\n                sum=sum+listEle.get(j);\\n                if(hmap.containsKey(sum)){\\n                    int val=hmap.get(sum);\\n                    hmap.put(sum,val+1);\\n                }", "class Solution {\\n    public int leastBricks(List<List<Integer>> wall) \\n    {\\n        HashMap<Integer, Integer> edge_frequency = new HashMap<>(); ", "class Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> partitionCount = new HashMap<>();\\n        int rowLen=wall.size();\\n        int cols = 0;\\n        int max = 0;\\n        for(int brick: wall.get(0))\\n            cols += brick;\\n        for(List<Integer> row: wall){\\n            int partition = 0;\\n            for(int brick: row){\\n                partition += brick;\\n                if(partition < cols){\\n                    partitionCount.put(partition, partitionCount.getOrDefault(partition, 0)+1);\\n                    max = Math.max(max, partitionCount.get(partition));\\n                }"]}
{"id": "867", "ref_java": ["class Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        int arr[] = new int[s.length()];\\n        int i=0;\\n        for(char c: s.toCharArray()) {\\n            arr[i++] = c - \\'0\\';\\n        }", "class Solution {\\n    public int nextGreaterElement(int n) {\\n        char arr[] = (Integer.toString(n)).toCharArray();\\n        \\n        int i=arr.length-2;\\n        StringBuilder ans = new StringBuilder();\\n        while(i>=0 && arr[i] >= arr[i+1])\\n            i--;\\n        \\n        if(i == -1)\\n            return -1;\\n        \\n        int k = arr.length-1;\\n        \\n        while(arr[k] <= arr[i])\\n            k--;\\n        \\n        swap(arr,i,k);\\n        \\n        for(int j=0;j<=i;j++)\\n            ans.append(arr[j]);\\n        \\n        for(int j=arr.length-1;j>i;j--)\\n            ans.append(arr[j]);\\n        \\n        long ans_ = Long.parseLong(ans.toString());\\n        \\n        return (ans_ > Integer.MAX_VALUE) ? -1 : (int)ans_;\\n        \\n        \\n    }", "class Solution {\\n    private void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }"]}
{"id": "869", "ref_java": ["class Solution {\\n    public int subarraySum(int[] nums, int k) {\\n        int sum = 0;\\n        int ans = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        for(int j=0;j<nums.length;j++){\\n            sum += nums[j];\\n            if(map.containsKey(sum -k)){\\n                ans += map.get(sum-k);\\n            }", "class Solution {\\n    public int subarraySum(int[] nums, int k) {\\n        int count = 0;\\n      \\n        int[] sum = new int[nums.length + 1];\\n        sum[0] = 0;\\n        for (int i = 1; i <= nums.length; i++)\\n            sum[i] = sum[i - 1] + nums[i - 1];\\n      \\n        for (int start = 0; start < sum.length; start++) {\\n            for (int end = start + 1; end < sum.length; end++) {\\n                if (sum[end] - sum[start] == k)\\n                    count++;\\n            }", "class Solution {\\n    public int subarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        prefix[0] = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = nums[i] + prefix[i - 1];\\n        }"]}
{"id": "870", "ref_java": ["class Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(!visited[i]){\\n         ans=Math.max(ans,helper(nums,i,visited));\\n        }", "class Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n ; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            hs.add(nums[i]);\\n            int x = nums[i];\\n            while(!hs.contains(nums[x])){\\n                hs.add(nums[x]);\\n                x = nums[x];\\n            }", "class Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n ; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            hs.add(nums[i]);\\n            int x = nums[i];\\n            while(!hs.contains(nums[x])){\\n                hs.add(nums[x]);\\n                x = nums[x];\\n            }"]}
{"id": "871", "ref_java": ["class Solution {\\n    fun checkInclusion(s1: String, s2: String): Boolean {\\n        if (s1.length > s2.length) return false\\n        val s1map = IntArray(26)\\n        val s2map = IntArray(26)\\n        for (i in s1.indices) {\\n            s1map[s1[i] - \\'a\\']++\\n            s2map[s2[i] - \\'a\\']++\\n        }", "class Solution {\\n    public boolean checkInclusion(String s1, String s2) {\\n\\n", "class Solution {\\n    public boolean checkInclusion(String s1, String s) {\\n        int[] target = new int[26];\\n        for (char c: s1.toCharArray()) {\\n            target[c - \\'a\\']++;\\n        }"]}
{"id": "873", "ref_java": ["class Solution {\\n    \\n    int[][] dir = {{1,0}", "class Solution {\\n    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n       int memo[][][] = new int[m][n][maxMove+1];\\n       int mod=(int) Math.pow(10,9)+7;\\n       return  topDown(m,n,maxMove,startRow,startColumn,memo,mod)%mod;\\n    }", "class Solution {\\n    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        if (maxMove == 0) return 0;\\n        int[][] dpCurr = new int[m+2][n+2], dpLast = new int[m+2][n+2];\\n        for (int i = 1; i <= m; i++) {\\n            dpCurr[i][1]++;\\n            dpCurr[i][n]++;\\n        }"]}
{"id": "874", "ref_java": ["class Solution {\\npublic int findUnsortedSubarray(int[] nums) {\\n    int minVal = Integer.MAX_VALUE, maxVal = Integer.MIN_VALUE;\\n    int n = nums.length;\\n    for(int i = 1; i < n; i++) {\\n        if(nums[i] < nums[i-1]) {\\n            minVal = Math.min(minVal, nums[i]);\\n        }", "class Solution {\\n    public int findUnsortedSubarray(int[] nums) {\\n        int n = nums.length;\\n    int start = -1, end = -2;\\n    int min = nums[n - 1], max = nums[0];\\n\\n    for (int i = 1; i < n; i++) {\\n        max = Math.max(max, nums[i]);\\n        min = Math.min(min, nums[n - 1 - i]);\\n\\n        if (nums[i] < max) {\\n            end = i;\\n        }", "class Solution {\\n    public int findUnsortedSubarray(int[] nums) {\\n        int end = -2 , max = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            if(nums[i] < max){\\n                end = i;\\n            }"]}
{"id": "875", "ref_java": ["class Solution {\\n    public int minDistance(String s1, String s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n\\n        if (n < m) minDistance(s2, s1);\\n\\n        char[] WA1 = s1.toCharArray();\\n        char[] WA2 = s2.toCharArray();\\n        \\n        int[] dpLast = new int[m + 1];\\n        int[] dpCurr = new int[m + 1];\\n        \\n        for (char c1 : WA1) {\\n            for (int j = 0; j < m; j++) {\\n                if (c1 == WA2[j]) {\\n                    dpCurr[j + 1] = dpLast[j] + 1;\\n                }", "class Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        int[][] dp = new int[n+1][m+1];\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= m; j++) {\\n                if(word1.charAt(i-1) == word2.charAt(j-1)) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }", "class Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        return (n-lcs(word1, word2, n, m)) + (m-lcs(word1, word2, n, m));\\n    }"]}
{"id": "877", "ref_java": ["class Solution {\\n\\n    class Fraction {\\n        public boolean isNegative;\\n        public int numerator;\\n        public int denominator;\\n\\n        public void placeNumerator(char n) {\\n            if(numerator > 0) {\\n                numerator *= 10;\\n            }", "class Solution {\\n    public String fractionAddition(String expression) {\\n        List<Integer> num = new ArrayList<>();\\n        List<Integer> denom = new ArrayList<>();\\n        List<String> ope_ope_no_mi = new ArrayList<>();\\n        int n = expression.length();\\n        if(expression.charAt(0)!=\\'-\\'){\\n            ope_ope_no_mi.add(\"+\");\\n        }", "class Solution {\\n    private int gcd(int x, int y){\\n        return x!=0?gcd(y%x, x):Math.abs(y);\\n    }"]}
{"id": "878", "ref_java": ["class Solution {\\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\\n        int[] arr = new int[6];\\n        arr[0] = (int)Math.pow(p1[0] - p2[0],2) + (int)Math.pow(p1[1] - p2[1], 2);\\n        arr[1] = (int)Math.pow(p1[0] - p3[0],2) + (int)Math.pow(p1[1] - p3[1], 2);\\n        arr[2] = (int)Math.pow(p1[0] - p4[0],2) + (int)Math.pow(p1[1] - p4[1], 2);\\n        arr[3] = (int)Math.pow(p2[0] - p3[0],2) + (int)Math.pow(p2[1] - p3[1], 2);\\n        arr[4] = (int)Math.pow(p2[0] - p4[0],2) + (int)Math.pow(p2[1] - p4[1], 2);\\n        arr[5] = (int)Math.pow(p3[0] - p4[0],2) + (int)Math.pow(p3[1] - p4[1], 2);\\n        \\n        int min =  arr[0];\\n        for(int i=1;i<6;i++){\\n            if(min > arr[i]){\\n                min = arr[i];\\n            }", "class Solution {\\n    ", "class Solution {\\n    public static boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\\n        return isSameLength(p1, p3, p2, p4) &&\\n                isSameLength(p1, p2, p3, p4) &&\\n                isSameLength(p1, p4, p2, p3) &&\\n                (isSameLength(p1, p2, p2, p3) || isSameLength(p1, p3, p2, p3) || isSameLength(p1, p2, p1, p3));\\n    }"]}
{"id": "881", "ref_java": ["class Solution {\\n    public List<List<String>> findDuplicate(String[] paths) {\\n        HashMap<String, LinkedList<String>> hashMap = new HashMap<>();\\n\\n        for (String path : paths) {\\n            String[] arr = path.split(\" \");\\n            for (int i = 1; i < arr.length; i++) {\\n                String str = arr[i];\\n                StringBuilder pathFile = new StringBuilder();\\n                StringBuilder text = new StringBuilder();\\n                int index = str.indexOf(\\'(\\');\\n\\n                pathFile.append(arr[0] + \"/\");\\n                pathFile.append(str.substring(0, index));\\n                text.append(str.substring(index + 1, str.length() - 1));\\n\\n                hashMap.computeIfAbsent(text.toString(), k -> new LinkedList<>()).add(pathFile.toString());\\n\\n            }", "class Solution {\\n    public List<List<String>> findDuplicate(String[] paths) {\\n        Map<String, List<String>> map = new HashMap<>();\\n\\n        for(String path : paths) {\\n            String[] parts = path.split(\"\\\\\\\\s+\");\\n            String root = parts[0];\\n\\n            for(int i = 1; i < parts.length; ++i) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(root);\\n                sb.append(\\'/\\');\\n                String file = \"\";\\n\\n                for(int j = 0; parts[i].charAt(j) != \\')\\'; ++j) {\\n                    if(parts[i].charAt(j) == \\'(\\') {\\n                        file = sb.toString();\\n                        sb.setLength(0);\\n                    }", "class Solution {\\n    trie root;\\n    void dfs(vector<vector<string>>& res, trie* node) {\\n        if(node->files.size() >= 2) {\\n            res.push_back(node->files);\\n        }"]}
{"id": "882", "ref_java": ["class Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        int count=0;\\n        for(int i=n-1;i>=1;i--){\\n            int left=0,right=i-1;\\n            while(left<right){\\n                if(a[left]+a[right]>a[i]){\\n                    count+=right-left;\\n                    right--;\\n                }", "class Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        int count=0;\\n        Arrays.sort(nums);\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=i+1; j<n-1; j++)\\n            {\\n                for(int k=j+1; k<n; k++)\\n                {\\n                    if(nums[i]+nums[j]>nums[k])\\n                    {\\n                        count++;\\n                    }", "class Solution {\\n    public int triangleNumber(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }"]}
{"id": "883", "ref_java": ["class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n        ", "class Solution {\\n\\n    class Pair{\\n        public int count;\\n        public int timeAvailable;\\n        public Pair(int count, int timeAvailable){\\n            this.count = count;\\n            this.timeAvailable = timeAvailable;\\n        }", "class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n        "]}
{"id": "885", "ref_java": ["class Solution {\\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\\n        if(depth==1){\\n            TreeNode temp = new TreeNode(val);\\n            temp.left=root;\\n            return temp;\\n        }", "class Solution {\\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\\n         if(depth == 1){\\n             TreeNode ans = new TreeNode(val);\\n             ans.left= root;\\n             return ans;\\n         }", "class Solution {\\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\\n        return helper(root,val,depth,0);\\n        \\n        \\n    }"]}
{"id": "887", "ref_java": ["class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long) Math.sqrt(c);\\n\\n        while(a<=b){\\n            if(((a*a) + (b*b)) == c){\\n                return true;\\n            }", "class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        ", "class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (int i = 2; i * i <= c; i++) {\\n            int count = 0;\\n            if (c % i == 0) {\\n                while (c % i == 0) {\\n                    count++;\\n                    c /= i;\\n                }"]}
{"id": "888", "ref_java": ["class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        if (n == 0 || logs == null || logs.size() == 0) {\\n            return result;\\n        }", "class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        if (n == 0 || logs == null || logs.size() == 0) {\\n            return result;\\n        }", "class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Func>s=new Stack<>();\\n        int []array=new int[n];\\n        for(String str:logs)\\n        {\\n            Func temp=new Func(str);\\n            if(temp.start)\\n            {\\n                if(!s.isEmpty())\\n                    array[s.peek().id]+=temp.time-s.peek().time;\\n                s.add(temp);\\n            }"]}
{"id": "889", "ref_java": ["class Solution {\\n    int minPrice;\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        minPrice=directlyBuy(price,needs);\\n        help(price,special,needs,0,0);\\n        return minPrice;\\n    }", "class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs, 0);\\n    }", "class Solution {\\n    int min = Integer.MAX_VALUE;\\n    \\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        solve(0, price, special, needs, 0);\\n        return min;\\n    }"]}
{"id": "890", "ref_java": ["class Solution {\\n    public String solveEquation(String equation) {\\n        int x1 = 0,x2 = 0;\\n        int sum1=0,sum2=0;\\n        int sign = 1;\\n        int i=0;\\n        boolean flag = true;\\n        for(i=0;i<equation.length();i++){\\n            char ch = equation.charAt(i);\\n            if(ch == \\'=\\') flag = false;\\n            else if(ch == \\'x\\'){\\n                if(flag) x1 += sign;\\n                else x2 += sign;\\n                sign = 1;\\n            }", "class Solution {\\n    public String solveEquation(String equation) {\\n        String[] delimited = equation.split(\"=\");\\n        int[] left = generateNumbers(delimited[0]);\\n        int[] right = generateNumbers(delimited[1]);\\n        left[0] -= right[0];\\n        right[0] = 0;\\n        if(left[0] == right[0] & left[0] == 0)\\n            return left[1] == right[1] ? \"Infinite solutions\" : \"No solution\";\\n        right[1] -= left[1];\\n        return \"x=\" + right[1] / left[0];\\n    }", "class Solution {\\n    int x = 0;\\n    int val = 0;\\n    public String solveEquation(String equation) {\\n        String[] eq = equation.split(\"=\");\\n        String left = eq[0];\\n        String right = eq[1];\\n        List<String> l = new ArrayList<>();\\n        List<String> r = new ArrayList<>();     \\n        int i = 0;  \\n        for(i=0;i<left.length();i++){\\n            char c = left.charAt(i);\\n            if(c==\\'+\\' || c==\\'-\\' || c==\\'x\\'){\\n                l.add(left.charAt(i)+\"\");\\n            }"]}
{"id": "892", "ref_java": ["class Solution {\\n    public int findLongestChain(int[][] pairs) {\\n        Arrays.sort(pairs, (a,b)-> a[1]-b[1]);\\n        int len=0, prev=-1001;\\n        for(int[] pair: pairs) {\\n            if(prev<pair[0]) {\\n                len++;\\n                prev=pair[1];\\n            }", "class Solution {\\n    public int findLongestChain(int[][] pairs) {\\n        Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));\\n\\n        int[] prev = pairs[0];\\n        int res = 1;\\n\\n        for (int i = 1; i < pairs.length; i++) {\\n            int[] cur = pairs[i];\\n            if (cur[0] > prev[1]) {\\n                res++;\\n                prev = cur;\\n            }", "class Solution {\\n    public int findLongestChain(int[][] pairs) {\\n        List<List<Integer>> myList = new ArrayList<>();\\n        for(int i = 0 ; i < pairs.length ; i++){\\n            myList.add(List.of(pairs[i][0], pairs[i][1]));\\n            \\n        }"]}
{"id": "893", "ref_java": ["class Solution {\\n    public int countSubstrings(String s) {\\n        boolean[][] dp=new boolean[s.length()][s.length()];\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i;j<s.length();j++){\\n                if(j-(j-i)==0){\\n                     dp[j-i][j]=true;\\n                     c++;\\n                }", "class Solution {\\n    public int countSubstrings(String S) {\\n        int len = S.length(), ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            int j = i - 1, k = i;\\n            while (k < len - 1 && S.charAt(k) == S.charAt(k+1)) k++;\\n            ans += (k - j) * (k - j + 1) / 2;\\n            i = k++;\\n            while (j >= 0 && k < len && S.charAt(k++) == S.charAt(j--)) ans++;\\n        }", "class Solution {\\n    public int countSubstrings(String s) {\\n        int ans=0;\\n        dp=new Integer[s.length()][s.length()];\\n        for(int i=0;i<s.length();i++) {\\n            for(int j=i;j<s.length();j++) {\\n                int ret=util(s, i, j);\\n                ans+=ret==-1?0:ret;\\n            }"]}
{"id": "894", "ref_java": ["class Solution {\\n    \\n    public String replaceWords(List<String> dictionary, String sentence) {\\n        \\n        Dictionary dict = new Dictionary();\\n        for(String word: dictionary) {\\n            dict.addToDictionary(word);\\n        }", "class Solution {\\n    public String replaceWords(List<String> roots, String sentence) {\\n        Set<String> set = new HashSet();\\n        for (String root: roots) \\n            set.add(root);\\n        StringBuilder ans = new StringBuilder();\\n        String word[] = sentence.split(\" \");\\n        for (int j=0;j<word.length;j++) {\\n            String prefix = \"\";\\n            for (int i=1; i<=word[j].length();++i) {\\n                prefix = word[j].substring(0, i);\\n                if (set.contains(prefix)) \\n                    break;\\n            }", "class Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean endOfWord;\\n\\n        public TrieNode() {\\n            children = new HashMap();\\n            endOfWord = false;\\n        }"]}
{"id": "895", "ref_java": ["class Solution {\\n    public String predictPartyVictory(String senate) {\\n        int dcount = 0, rcount = 0, dban = 0, rban = 0;\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        for(char c : senate.toCharArray()){\\n            if(c == \\'D\\') dcount++;\\n            else rcount++;\\n            q.offer(c);\\n        }", "class Solution {\\n    public String predictPartyVictory(String senate) {\\n        int dcount = 0, rcount = 0, dban = 0, rban = 0;\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        for(char c : senate.toCharArray()){\\n            if(c == \\'D\\') dcount++;\\n            else rcount++;\\n            q.offer(c);\\n        }", "class Solution {\\n    public String predictPartyVictory(String senate) {\\n        int dcount = 0, rcount = 0, dban = 0, rban = 0;\\n        int n = senate.length();\\n        Queue<Character> q = new LinkedList<>();\\n        for(char c : senate.toCharArray()){\\n            if(c == \\'D\\') dcount++;\\n            else rcount++;\\n            q.offer(c);\\n        }"]}
{"id": "896", "ref_java": ["class Solution {\\n     public int gpf(int n)\\n     {   int ans=1;\\n         int i;\\n         for(i=2;i<n;i++)\\n         {\\n             if(n%i==0)\\n             {\\n                     ans=i;\\n             }", "class Solution {\\n    public int minSteps(int n) {\\n        return f(0, 1, n);\\n    }", "class Solution {\\n    long [][][]dp;\\n    private long solve(int n,int currLen,int copyLen,int flag)\\n    {\\n        if(currLen==n)\\n            return 0;\\n        if(currLen>n)\\n            return Integer.MAX_VALUE;\\n        if(dp[currLen][copyLen][flag]!=-1)\\n            return dp[currLen][copyLen][flag];\\n        "]}
{"id": "897", "ref_java": ["class Solution {\\n    List<TreeNode> res;\\n    HashMap<String, Integer> serialCount;\\n    String pos(TreeNode root)\\n    {\\n\\t    if(root == null) return \"#\";\\n\\t    String serial = root.val + \",\" + pos(root.left) + pos(root.right);\\n\\t    int freq = serialCount.getOrDefault(serial, 0);\\n\\t    serialCount.put(serial, ++freq);\\n\\t    if (freq == 2) res.add(root);\\n\\t    return serial;\\n    }", "class Solution {\\n    List<TreeNode> _duplicatedTrees = null;\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        return new AbstractList<TreeNode>() {\\n            public TreeNode get(int index) {\\n                init(); return _duplicatedTrees.get(index);\\n            }", "class Solution {\\n    public List<TreeNode> l = new ArrayList<>();\\n    public HashMap<String,Integer> hm = new HashMap<>();\\n    public HashSet<String> hs = new HashSet<>();\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        helper(root);\\n        return l;\\n    }"]}
{"id": "898", "ref_java": ["class Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        return construct(0,nums.length-1,nums);\\n\\n    }", "class Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        \\n        return constructBinarymax(nums,0,nums.length-1);\\n    }", "class Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        if(nums.length==0)\\n            return null;\\n        return helper(nums,0,nums.length-1);\\n        \\n    }"]}
{"id": "899", "ref_java": ["class Solution {\\n    public List<List<String>> printTree(TreeNode root) {\\n      int height = getHeight(root);\\n      int width = (int)Math.pow(2,height)-1;\\n      String[][] matrix = new String[height][width];\\n      for(String[] r : matrix){\\n          Arrays.fill(r,\"\");\\n      }", "class Solution {\\n    public List<List<String>> printTree(TreeNode root) {\\n\\n        int mH = maxHeight(root);                    ", "class Solution {\\n\\n    \\n\\n\\n    \\n\\n    private int h;\\n    List<List<String>> matrix;\\n\\n    public List<List<String>> printTree(TreeNode root) {\\n        "]}
{"id": "900", "ref_java": ["class Solution {\\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\\n\\n        int start = 0;\\n        int end = arr.length - 1;\\n        while (end - start >= k) {\\n            if (Math.abs(arr[start] - x) > Math.abs(arr[end] - x)) {\\n                start++;\\n            }", "class Solution {\\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\\n        int n=arr.length,diff[]=new int[n],i; \\n        List<Integer> list = new ArrayList<Integer>();\\n        int min=Integer.MAX_VALUE,index=-1;\\n        \\n        for(i=0;i<n;i++){ \\n            diff[i]=Math.abs(arr[i]-x);\\n            if(min>diff[i]){\\n                min=diff[i];\\n                index=i;\\n            }", "class Solution {\\n    public List<Integer> findClosestElements(int[] a, int k, int x) {\\n        List<Integer> nm=new ArrayList<>();\\n        int i=0,j=a.length-1;\\n        while(j-i+1>k)\\n        {\\n            if(Math.abs(x-a[i])>Math.abs(x-a[j]))\\n            {\\n                i++;\\n            }"]}
{"id": "901", "ref_java": ["class Solution {\\n    bool isSegmentPossible(vector<int>& nums, int startIdx, int endIdx)\\n    {\\n        vector<int> freq(nums[endIdx] - nums[startIdx] + 1);\\n        for (int i = startIdx; i <= endIdx; ++i)\\n            ++freq[nums[i]-nums[startIdx]];\\n        int lengthOneSubsequence = 0, lengthTwoSubsequence = 0, totalFreq = 0;\\n        for (int i = 0; i <= nums[endIdx] - nums[startIdx]; ++i)\\n        {\\n            if (freq[i] < lengthOneSubsequence + lengthTwoSubsequence)\\n            {\\n                return false;\\n            }", "class Solution {\\n    public boolean isPossible(int[] nums) {\\n        Map<Integer,Integer> availability = new HashMap<>();\\n        Map<Integer,Integer> possibility = new HashMap<>();\\n        for(int num:nums){\\n            availability.put(num,availability.getOrDefault(num,0)+1);\\n        }", "class Solution {\\n    public boolean isPossible(int[] nums) {\\n        "]}
{"id": "902", "ref_java": ["class Solution {\\n    Map<Integer, Integer> levelMin = new HashMap<>();\\n\\n    public int widthOfBinaryTree(TreeNode root) {\\n        return dfs(root, 1, 1);\\n    }", "class Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        int width = 1;\\n        Queue<TreeNode> qu = new LinkedList<>();\\n        Queue<Integer> idxqu = new LinkedList<>();\\n\\n        qu.offer(root);\\n        idxqu.offer(1);\\n\\n        while(!qu.isEmpty())\\n        {\\n            int level = qu.size();\\n            int leftIdx = 0, rightIdx = 0;\\n\\n            for(int i = 0; i < level; i++)\\n            {\\n                TreeNode temp = qu.poll();\\n                int idx = idxqu.poll();\\n\\n                if(i == 0)\\n                    leftIdx = idx;\\n                if(i == level - 1)\\n                    rightIdx = idx;\\n                \\n                if(temp.left != null)\\n                {\\n                    qu.offer(temp.left);\\n                    idxqu.offer(idx * 2);\\n                }", "class Solution {\\n    Map<Integer,int[]> map;\\n    public int widthOfBinaryTree(TreeNode root) {\\n        map = new HashMap<Integer,int[]>();\\n        int[] arr = new int[2];\\n        arr[0] = 0;\\n        arr[1] = 1;\\n        map.put(0,arr);\\n        recursion(root.left,1,-1,1);\\n        recursion(root.right,1,1,1);\\n        int max = 0;\\n        for (int[] temp : map.values()){\\n            max = Math.max(max,temp[0] < 0 && temp[1] < 0 ? temp[1] - temp[0] + 1 : temp[0] > 0 && temp[1] > 0 ? temp[1] - temp[0] + 1 : temp[1] == 0 ? 1 - temp[0] : temp[1] - temp[0]);\\n        }"]}
{"id": "903", "ref_java": ["class Solution {\\n    public boolean checkPossibility(int[] nums) {\\n        int n = nums.length;\\n        ", "class Solution {\\n    public boolean checkPossibility(int[] N) {\\n        for (int i = 1, err = 0; i < N.length; i++)\\n            if (N[i] < N[i-1])\\n                if (err++ > 0 || (i > 1 && i < N.length - 1 && N[i-2] > N[i] && N[i+1] < N[i-1]))\\n                    return false;\\n        return true;\\n    }", "class Solution {\\n    public boolean checkPossibility(int[] N) {\\n        for (int i = 1, err = 0; i < N.length; i++)\\n            if (N[i] < N[i-1])\\n                if (err++ > 0 || (i > 1 && i < N.length - 1 && N[i-2] > N[i] && N[i+1] < N[i-1]))\\n                    return false;\\n        return true;\\n    }"]}
{"id": "904", "ref_java": ["class Solution {\\n    public int[] constructArray(int n, int k) {\\n\\n        int num=-1;\\n        int[] res = new int[n];\\n        res[0]=n;\\n        for(int i=1;i<n;i++){\\n            if(i<k){\\n                if(num>0){    \\n                    res[i]=res[i-1]+(n-i);\\n                    num*=-1;\\n                }", "class Solution {\\n    public int[] constructArray(int n, int k) {\\n        int ans[]=new int[n];\\n        int low=1,high=n,index=0;\\n        boolean isHigh=false;\\n        ans[index++]=low++;\\n        while(k>1){\\n            ans[index++]=high--;\\n            k--;\\n            isHigh=true;\\n            if(k>1){\\n                ans[index++]=low++;\\n                k--;\\n                isHigh=false;\\n            }", "class Solution {\\n    public int[] constructArray(int n, int k) {\\n        return util1(n,k);\\n    }"]}
{"id": "905", "ref_java": ["class Solution {\\n    public TreeNode trimBST(TreeNode root, int low, int high) {\\n        if(root == null){\\n            return null;\\n        }", "class Solution {\\n    public TreeNode trimBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return null;\\n        }", "class Solution {\\n    public TreeNode trimBST(TreeNode root, int low, int high) {\\n       if(root==null)\\n       return null;\\n       root.left=trimBST(root.left,low,high);\\n       root.right=trimBST(root.right,low,high);\\n       if(root.val<low)\\n       return root.right;\\n       else if(root.val>high)\\n       return root.left;\\n       else\\n       return root;\\n    }"]}
{"id": "906", "ref_java": ["class Solution {\\n    public int maximumSwap(int num) {\\n        if(num < 10) return num;\\n        \\n        char[] arr = String.valueOf(num).toCharArray();\\n        \\n        int[] rightIndex = new int[10]; ", "class Solution {\\n    public int maximumSwap(int num) {\\n        char[] digits = String.valueOf(num).toCharArray();\\n        int[] res = new int[2];\\n        int end = digits.length - 1;\\n        \\n        for (int i = digits.length - 1; i >= 0; i--){\\n            if (digits[i] > digits[end]){\\n                end = i;\\n            }", "class Solution {\\n    public int maximumSwap(int num) {\\n        if(num < 10) return num;\\n        char[] arr = String.valueOf(num).toCharArray();\\n        int[] rightIndex = new int[10]; \\n        for(int i=0; i<arr.length; i++){\\n            rightIndex[arr[i] - \\'0\\'] = i;\\n        }"]}
{"id": "907", "ref_java": ["class Solution {\\n    private final Map<List<Integer>, Set<Integer>> memo = new HashMap<>();\\n    public int flipLights(int n, int presses) {\\n        int initialState = ((int) Math.pow(2, n)) - 1;\\n        List<Function<Integer, Integer>> buttons = initOperations(n);\\n        Set<Integer> states = new HashSet<>();\\n        dfs(initialState, presses, buttons, states);\\n        return states.size();\\n    }", "class Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }", "class Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }"]}
{"id": "908", "ref_java": ["class Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n\\n        int[] dp = new int[n]; \\n        int[] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n\\n        int maxLength = 1; \\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    }", "class Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        int[] fq = new int[n];\\n        lis[0] = 1;\\n        fq[0] = 1;\\n        int lo = 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int mx = 0;\\n            int c = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (lis[j] > mx) {\\n                        mx = lis[j];\\n                        c = fq[j];\\n                    }", "class Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n], count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n        int res = 0, maxi = 1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int prev = 0; prev < i; ++prev) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                }"]}
{"id": "911", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    ", "class Solution {\\n    "]}
{"id": "912", "ref_java": ["class Solution {\\n    public int[] findRedundantConnection(int[][] edges) {\\n        DisJointSet ds=new DisJointSet(edges.length);\\n        \\n        int ans[]=new int[2];\\n        for(int i=0;i<edges.length;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n\\n            if(ds.findUltimateParent(u)==ds.findUltimateParent(v)){\\n                ans[0]=u;\\n                ans[1]=v;           \\n            }", "class Solution {\\n    public class Edge{\\n        int v;\\n        int parent[];\\n        int rank[];\\n        int val1=0;\\n        int val2=0;\\n        public Edge(int v){\\n            this.v=v;\\n            parent=new int[v];\\n            rank=new int[v];\\n            for(int i=0;i<v;i++)\\n            parent[i]=i;\\n        }", "class Solution {\\n    public int[] findRedundantConnection(int[][] edges) {\\n        par = new int[edges.length+1];\\n        for (int i = 0; i < par.length; i++)\\n            par[i] = i;\\n        for (int[] e : edges)\\n            if (find(e[0]) == find(e[1])) return e;\\n            else union(e[0],e[1]);\\n        return edges[0];\\n    }"]}
{"id": "913", "ref_java": ["class Solution {\\n    public int repeatedStringMatch(String a, String b) {\\n        boolean[] bucket = new boolean[26];\\n        for (char c : a.toCharArray()) bucket[c - \\'a\\'] = true;\\n        for (char c : b.toCharArray()) \\n            if (!bucket[c - \\'a\\']) return -1;\\n        \\n        int cnt = b.length() / a.length();\\n\\n        StringBuilder sb = new StringBuilder(a.repeat(cnt));\\n\\n        for (int i = 0;i < 3;i++) {\\n            if (sb.indexOf(b) >= 0) return cnt + i;\\n            sb.append(a);\\n        }", "class Solution {\\n    public int repeatedStringMatch(String a, String b) {\\n        int minloop= b.length()/a.length();\\n        StringBuilder temp=new StringBuilder(a);\\n       for(int i=0;i<minloop+2;i++){\\n           if(temp.toString().contains(b)) return i+1;\\n           else temp.append(a);\\n       }", "class Solution {\\n    public int repeatedStringMatch(String a, String b) {\\n        String copyA = a;\\n        int count =1;\\n        int repeat = b.length()/a.length();\\n        for(int i=0;i<repeat+2;i++){\\n            if(a.contains(b)){\\n                return count;\\n            }"]}
{"id": "914", "ref_java": ["class Solution {\\n    private int result = 0;\\n\\n    public int longestUnivaluePath(TreeNode root) {\\n        helper(root);\\n        return result;\\n    }", "class Solution {\\n        int len = 0;\\n        public int longestUnivaluePath(TreeNode root) {\\n                len = 0;\\n                helper(root,-1);\\n                \\n                if(len > 0){\\n                        len = len - 1;\\n                }", "class Solution {\\n        int len = 0;\\n        public int longestUnivaluePath(TreeNode root) {\\n                len = 0;\\n                helper(root,-1);\\n                \\n                if(len > 0){\\n                        len = len - 1;\\n                }"]}
{"id": "915", "ref_java": ["class Solution {\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] moves = {{-2, -1}", "class Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        if(k==0)\\n        {\\n            return (double)1;\\n        }", "class Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{-2, -1}"]}
{"id": "917", "ref_java": ["class Solution {\\n    class Pair{\\n    int key;\\n    String value;\\n    \\n    Pair(int key, String value){\\n        this.key = key;\\n        this.value = value;\\n    }", "class Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer> map=new HashMap<>();\\n        for(int i=0; i<words.length; i++){\\n            if(map.containsKey(words[i])){\\n               map.put(words[i],map.get(words[i])+1);\\n            }", "class Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer> dict = new HashMap<>();\\n        List<String> answ = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++)\\n        {\\n            if (!dict.containsKey(words[i]))\\n                dict.put(words[i], 0);\\n            dict.put(words[i], dict.get(words[i]) + 1);\\n        }"]}
{"id": "918", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    ", "class Solution {\\n    public int dfs(int i, int j, int[][] grid){\\n        grid[i][j]=2;\\n        int c = 1;\\n        int[][] directions = {{1,0}"]}
{"id": "919", "ref_java": ["class Solution {\\n    public boolean canPartitionKSubsets(int[] nums, int k) {\\n        int sum=0;\\n        for(int i:nums){\\n            sum+=i;\\n        }", "class Solution {\\n    public boolean canPartitionKSubsets(int[] nums, int k) {\\n        int sum=0;\\n        for(int i:nums){\\n            sum+=i;\\n        }", "class Solution {\\n    public boolean backtrack(int[] nums, int idx, int k, int subsetSum, int target, boolean[] vis) {\\n        "]}
{"id": "920", "ref_java": ["class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        ", "class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) \\n        return new TreeNode(val);\\n        \\n        if(val>root.val)\\n        root.right = insertIntoBST(root.right,val);\\n\\n        else if(val<root.val) root.left = insertIntoBST(root.left,val);\\n\\n        return root;\\n    }", "class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null){\\n            root = new TreeNode(val);\\n            return root;\\n        }"]}
{"id": "922", "ref_java": ["class Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int n = s1.length();int m = s2.length();\\n        int[][] dp = new int[n+1][m+1];\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        \\n        for (int j = 1; j <= m; j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }", "class Solution {\\n    public int minimumDeleteSum(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i = 1; i <= s1.length(); i++)\\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\\n        \\n        for (int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }", "class Solution {\\n    int[][] memo;\\n    int n, m;\\n    public int minimumDeleteSum(String s1, String s2) {\\n        n = s1.length();\\n        m = s2.length();\\n        memo = new int[n][m];\\n        for(int i=0; i<n; i++){\\n            Arrays.fill(memo[i], -1);\\n        }"]}
{"id": "923", "ref_java": ["class Solution {\\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\\n        if(k==0) return 0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            long product=1;\\n            for(int j=i;j<nums.length;j++){\\n                product*=nums[j];\\n                if(product<k) count++;\\n                else break;\\n            }", "class Solution {\\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\\n        if(k <= 1) return 0;\\n        int i = 0, j = 0, count = 0, pro = 1;\\n        while(j < nums.length) {\\n            pro *= nums[j];\\n            while(pro >= k) pro /= nums[i++];\\n            count += 1 + (j - i);\\n            j++;\\n        }", "class Solution {\\n    public int numSubarrayProductLessThanK(int[] nums, int k)\\n     {\\n         int count=0;\\n         int start=0;\\n         int end=0;\\n         int sum=nums[0];\\n         while(start<nums.length && end<nums.length)\\n         {\\n             if(sum<k)\\n             {\\n                 end++;\\n                 if(end>=start)\\n                 {\\n                     count+=(end-start);\\n                 }"]}
{"id": "924", "ref_java": ["class Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int buy = Integer.MIN_VALUE;\\n        int sell = 0;\\n\\n        for (int price : prices) {\\n            buy = Math.max(buy, sell - price);\\n            sell = Math.max(sell, buy + price - fee);\\n        }", "class Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int n = prices.length;\\n        if(prices == null || n == 0) return 0;\\n        \\n        int buy = prices[0];\\n        int profit = 0;\\n        int sell = 0;\\n        for(int i = 1; i < n; i++){\\n            buy = Math.min(buy, prices[i] - profit);\\n            sell = Math.max(profit, prices[i] - buy - fee);\\n            profit = sell;\\n        }", "class Solution {\\n    public int maxProfit(int[] P, int F) {\\n        int len = P.length, buying = 0, selling = -P[0];\\n        for (int i = 1; i < len; i++) {\\n            buying = Math.max(buying, selling + P[i] - F);\\n            selling = Math.max(selling, buying - P[i]);\\n        }"]}
{"id": "925", "ref_java": ["class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        int len_12 = Math.max(len1,len2);\\n\\n        long[] p = new long[len_12];\\n        long[] h1 = new long[len1];\\n        long[] h2 = new long[len2];\\n        int P = 1313131;\\n        p[0] = 1;\\n        h1[0] = nums1[0];\\n        h2[0] = nums2[0];\\n\\n        for(int i=1;i<len_12;i++) p[i] = p[i-1] * P;\\n        for(int i=1;i<len1;i++) h1[i] = h1[i-1]*P+nums1[i];\\n        for(int i=1;i<len2;i++) h2[i] = h2[i-1]*P+nums2[i];\\n        \\n        int lo = 1;\\n        int hi = Math.min(len1,len2);\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(check(nums1,nums2,mid,p,h1,h2)) lo = mid + 1;\\n            else hi = mid - 1;\\n        }", "class Solution {\\npublic int findLength(int[] nums1, int[] nums2) {\\n    ", "class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        "]}
{"id": "926", "ref_java": ["class Solution {\\n\\t\\tprivate TreeNode root;\\n\\t\\tprivate String result = \"\";\\n\\n\\t\\tpublic String longestWord(String[] words) {\\n\\t\\t\\troot = new TreeNode();\\n\\n\\t\\t\\tfor (String w : words)\\n\\t\\t\\t\\tinsert(w);\\n\\n\\t\\t\\tdfs(root);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}", "class Solution {\\n\\t\\tprivate TreeNode root;\\n\\t\\tprivate String result = \"\";\\n\\n\\t\\tpublic String longestWord(String[] words) {\\n\\t\\t\\troot = new TreeNode();\\n\\n\\t\\t\\tfor (String w : words)\\n\\t\\t\\t\\tinsert(w);\\n\\n\\t\\t\\tdfs(root);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}", "class Solution {\\n    public String longestWord(String[] words) {\\n        Set<String> set = new HashSet<>();\\n\\n        for(int i = 0; i < words.length; i++){\\n            set.add(words[i]);\\n        }"]}
{"id": "927", "ref_java": ["class Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, Set<String>> adj = new HashMap<>();\\n\\n        for(List<String> account : accounts) {\\n            String email1 = account.get(1);\\n            for(int i = 2; i < account.size(); i++) {\\n                String curEmail = account.get(i);\\n                adj.computeIfAbsent(email1, k->new HashSet<>()).add(curEmail);\\n                adj.computeIfAbsent(curEmail, k->new HashSet<>()).add(email1);\\n            }", "class Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        ", "class Solution {\\n    static class P {\\n        Map<String, Integer> emails = new HashMap<>();\\n        List<List<String>> groups = new ArrayList<>();\\n\\n        void process(List<String> list) {\\n            Integer key = null;\\n            for (int i = 1; i < list.size(); i++) {\\n                String email = list.get(i);\\n                Integer existing = emails.get(email);\\n                if (existing != null) {\\n                    if (key == null) {\\n                        key = existing;\\n                    }"]}
{"id": "928", "ref_java": ["class Solution {\\n    private static final char slash    = \\'/\\',\\n                              asterisk = \\'*\\'; \\n    public List<String> removeComments(String[] source) {\\n        List<String> uncommentedSource = new ArrayList<>();\\n        StringBuilder uncommentedLine = new StringBuilder();\\n        boolean isBlockCodeComment = false;\\n        for (String commentedLine : source) {\\n            char[] line = commentedLine.toCharArray();\\n            int length = line.length;\\n            for (int index = 0; index < length; ++index)\\n                if (!isBlockCodeComment && line[index] == slash && index + 1 < length && line[index + 1] == asterisk) {\\n                    isBlockCodeComment = true;\\n                    index++;\\n                }", "class Solution {\\n    \\n    boolean isCommentBegan=false;\\n    String lineBeforeComm=\"\";\\n    public List<String> removeComments(String[] source) {\\n        List<String> res=new ArrayList();\\n        for(String line:source){\\n            line=helper(line);\\n            if(line!=null){\\n                res.add(line);\\n            }", "class Solution {\\n    public List<String> removeComments(String[] source) {\\n        boolean blockActive = false; "]}
{"id": "929", "ref_java": ["class Solution {\\n    public ListNode[] splitListToParts(ListNode head, int k) {\\n        ", "class Solution {\\n    public ListNode[] splitListToParts(ListNode head, int k) {\\n        int linkedListLength = 0;\\n        ListNode temp = head;\\n        while(temp != null) {\\n            linkedListLength++;\\n            temp = temp.next;\\n        }", "class Solution {\\n    public ListNode[] splitListToParts(ListNode head, int k) {\\n        int n = 0;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            n++;\\n            curr = curr.next;\\n        }"]}
{"id": "932", "ref_java": ["class Solution {\\n    public int[] asteroidCollision(int[] asteroids) {\\n        int n = asteroids.length;\\n        int j = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            int asteroid = asteroids[i];\\n            while (j>0 && asteroids[j-1]>0 && asteroid<0 && asteroids[j-1] < Math.abs(asteroid)) \\n            {j--;}", "class Solution {\\n    public boolean samesign(int x, int y) {\\n        if (x < 0 && y < 0)\\n            return true;\\n        else if (x > 0 && y > 0)\\n            return true;\\n        return false;\\n    }", "class Solution {\\n    public int[] asteroidCollision(int[] asteroids) {\\n        Stack<Integer>stack=new Stack<>();\\n        for(int i:asteroids){\\n            if(stack.isEmpty() || i>0){\\n                stack.add(i);\\n            }"]}
{"id": "933", "ref_java": ["class Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int[] digits = new int[10];\\n        int num = n;\\n        int index = 0;\\n\\n        while(n > 0){\\n            digits[index++] = n % 10;\\n            n /= 10;\\n        }", "class Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int position;\\n        int digitInTheNextPosition;\\n        while ((position = getThePositionNotSatisfied(n)) != -1) {\\n            digitInTheNextPosition = ((int) (n / Math.pow(10, position - 1))) % 10;\\n            n -= Math.pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= n % Math.pow(10, position);\\n            n += Math.pow(10, position) - 1;\\n        }", "class Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int len = size(n);\\n        int[] dig = new int[len];\\n        len--;\\n        while(n>0){\\n            dig[len] = n%10;\\n            n /= 10;\\n            len--;\\n        }"]}
{"id": "934", "ref_java": ["class Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        int[] answer = new int[temperatures.length];\\n        Stack<Integer> indices = new Stack<>();  \\n        for (int i = 0; i < temperatures.length; i++){\\n            if (i+1 >= temperatures.length){\\n                answer[i] = 0; \\n                while((!indices.isEmpty())){\\n                    answer[indices.pop()] = 0; \\n                }", "class Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }", "class Solution {\\n    public int[] dailyTemperatures(int[] t) {\\n        Stack<Integer> s=new Stack<>();\\n        int[] a=new int[t.length];\\n        "]}
{"id": "935", "ref_java": ["class Solution {\\n              public int deleteAndEarn(int[] nums) {\\n              Arrays.sort(nums);\\n              HashMap<Integer,Integer> hm = new HashMap<>();\\n              for(int i : nums){   hm.put(i,hm.getOrDefault(i, 0) + 1);     }", "class Solution {\\n    private int solveMemo(List<int[]> list, int idx, int[] dp, int n){\\n        ", "class Solution {\\n    public int deleteAndEarn(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        List<int[]> list = new ArrayList<>();\\n        for(int num : nums){\\n            if(!list.isEmpty() && list.get(list.size()-1)[0] == num){\\n                list.get(list.size()-1)[1]++;\\n            }"]}
{"id": "936", "ref_java": ["class Solution {\\n    public int networkDelayTime(int[][] times, int n, int K) {\\n        double[][] graph = new double[n + 1][n + 1];\\n        for(int i = 1; i <= n; i++) Arrays.fill(graph[i], Double.POSITIVE_INFINITY);\\n        for(int i = 1; i <= n; i++) graph[i][i] = 0;\\n        for(int[] edge: times) graph[edge[0]][edge[1]] = edge[2];\\n        for(int k = 1; k <= n; k++) {\\n            for(int i = 1; i <= n; i++) {\\n                for(int j = 1; j<=n; j++) {\\n                    if(graph[i][j] > graph[i][k] + graph[k][j]) graph[i][j] = graph[i][k] + graph[k][j];\\n                }", "class Solution {\\n    public int networkDelayTime(int[][] times, int n, int k) {\\n        int[][] graph = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(graph[i], -1);\\n        }", "class Solution {\\n    record Node(int i, int t) {}"]}
{"id": "937", "ref_java": ["class Solution {\\n    public int openLock(String[] deadends, String target) {\\n        HashSet<String> prohibited = new HashSet<>();\\n        HashSet<String> vis = new HashSet<>();\\n\\n        for(String it : deadends){\\n            prohibited.add(it);\\n        }", "class Solution {\\n    public int openLock(String[] deadends, String target) {\\n        int[] pow10 = {1, 10, 100, 1000}", "class Solution {\\n    public int openLock(String[] deadends, String target) {\\n        if (target.equals(\"0000\")) return 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        boolean[] seen = new boolean[10000];\\n        for (String el : deadends)\\n            seen[Integer.parseInt(el)] = true;\\n        int targ = Integer.parseInt(target);\\n        if (seen[0]) return -1;\\n        for (int turns = 1; !queue.isEmpty(); turns++) {\\n            int qlen = queue.size();\\n            for (int i = 0; i < qlen; i++) {\\n                int curr = queue.poll();\\n                for (int j = 1; j < 10000; j *= 10) {\\n                    int mask = curr % (j * 10) / j,\\n                        masked = curr - (mask * j);\\n                    for (int k = 1; k < 10; k += 8) {\\n                        int next = masked + (mask + k) % 10 * j;\\n                        if (seen[next]) continue;\\n                        if (next == targ) return turns;\\n                        seen[next] = true;\\n                        queue.add(next);\\n                    }"]}
{"id": "938", "ref_java": ["class Solution {\\n    public int reachNumber(int target) {\\n        target=Math.abs(target);\\n        int start=1,end=target,mid,steps=0,pos=0;\\n        long sum=0;\\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            sum=(long)mid*(mid+1)/2;\\n            if(sum>=target)\\n                {\\n                    pos=(int)sum;\\n                    steps=mid;\\n                    end=mid-1;\\n                }", "class Solution {\\n    public int reachNumber(int target) {\\n\\n        ", "class Solution {\\n    public int reachNumber(int target) {\\n        int sum =0 ,steps = 0;\\n        if(target ==0) return 0;\\n        target = Math.abs(target);\\n        while(sum< target){\\n            sum+=steps;\\n            steps++;\\n        }"]}
{"id": "939", "ref_java": ["class Solution {\\n    unordered_set<string> invalid;\\n    bool solve(string bottom, int i, unordered_map<string,string> mp, string z)\\n    {\\n        int n=bottom.size();\\n        int m=z.size();\\n        if(n<2)\\n        return true;\\n        if(invalid.count(bottom))\\n        return false;\\n        if(m==n-1)\\n        return solve(z, 0, mp, \"\");\\n        if(m>1 && mp.find(z.substr(m-2,2))==mp.end())\\n        return false;\\n        for(char ch:mp[bottom.substr(i,2)]){\\n            z.push_back(ch);\\n            if(solve(bottom, i+1, mp, z))\\n            return true;\\n            z.pop_back();\\n        }", "class Solution {\\n    Node root=new Node();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String s: allowed){\\n            addToTrie(root, s.toCharArray(), 0);\\n        }", "class Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<Integer, Set<Integer>> pyramids = new HashMap<>();\\n        for (String str: allowed) {\\n            Pyramid p = getPyramid(str, 2);\\n            pyramids.computeIfAbsent(p.base, e-> new HashSet<>()).add(p.top);\\n        }"]}
{"id": "940", "ref_java": ["class Solution {\\n    public List<Integer> partitionLabels(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        ", "class Solution {\\n    public List<Integer> partitionLabels(String s) {\\n        int[] hashh = new int[26];\\n        \\n        ", "class Solution {\\n    public List<Integer> partitionLabels(String s) {\\n\\n        "]}
{"id": "941", "ref_java": ["class Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        int[][] dp = new int[n][n];\\n        for(int[] mine : mines) {\\n            int row = mine[0], col = mine[1];\\n            dp[row][col] = -1;\\n        }", "class Solution {\\n    int len;\\n    int[][] mgrid;\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        len = n;\\n        \\n        mgrid = new int[n][n];\\n        for(int i=0; i<n; i++)\\n            Arrays.fill(mgrid[i], 1);\\n\\n        \\n        for(int i=0; i<mines.length; i++){\\n            int x = mines[i][0];\\n            int y = mines[i][1];\\n            mgrid[x][y] = 0;\\n        }", "class Solution {\\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\\n        return util1(n,mines);\\n    }"]}
{"id": "942", "ref_java": ["class Solution {\\n    public String reorganizeString(String s) {\\n        ", "class Solution {\\n    public String reorganizeString(String s) {\\n        int n=s.length();\\n        if(n==0) return \"\";\\n        StringBuffer buff=new StringBuffer(\"\");\\n        int arr[]=new int[26];\\n        for(int i=0;i<n;i++){\\n           char ch=s.charAt(i);\\n           arr[ch-\\'a\\']++;\\n        }", "class Solution {\\n  public String reorganizeString(String s) {\\n    Map<Character, Integer> count = new HashMap<>();\\n    int maxFreq = 0;\\n\\n    for (final char c : s.toCharArray())\\n      maxFreq = Math.max(maxFreq, count.merge(c, 1, Integer::sum));\\n\\n    if (maxFreq > (s.length() + 1) / 2)\\n      return \"\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    Queue<Pair<Integer, Character>> maxHeap =\\n        new PriorityQueue<>((a, b) -> b.getKey() - a.getKey());\\n    int prevFreq = 0;\\n    char prevChar = \\'@\\';\\n\\n    for (final char c : count.keySet())\\n      maxHeap.offer(new Pair<>(count.get(c), c));\\n\\n    while (!maxHeap.isEmpty()) {\\n\\n      final int freq = maxHeap.peek().getKey();\\n      final char c = maxHeap.poll().getValue();\\n      sb.append(c);\\n\\n      if (prevFreq > 0)\\n        maxHeap.offer(new Pair<>(prevFreq, prevChar));\\n      prevFreq = freq - 1;\\n      prevChar = c;\\n    }"]}
{"id": "943", "ref_java": ["class Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n\\n        int n = arr.length;\\n        int count=0;\\n        int curr=0;\\n        for(int i=0;i<n;i++){\\n            curr += arr[i];\\n            if(curr ==((i)*(i+1))/2){\\n                count++;\\n            }", "class Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n       int max=arr[0];\\n       int chunks=0;\\n        for(int i=0;i<arr.length;i++){\\n            max=Math.max(arr[i],max);\\n            if(max==i){\\n                chunks++;\\n            }", "class Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n        \\n        int max=0, count=0;\\n        for(int i=0; i<arr.length; i++){\\n            max = Math.max(arr[i],max);\\n            if(i==max) count++;\\n        }"]}
{"id": "944", "ref_java": ["class Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n       for(int i = 0; i < nums.length; i ++) \\n           if(i - nums[i] > 1 || i - nums[i] < - 1) return false;\\n           return true;\\n    }", "class Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b - a));\\n        for (int i = 0; i < n - 1; i++) {\\n            int cur = nums[i];\\n            int next = nums[i + 1];\\n            if (!pq.isEmpty()) {\\n                ", "class Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n       for(int i = 0; i < nums.length; i ++) \\n           if(i - nums[i] > 1 || i - nums[i] < - 1) return false;\\n           return true;\\n    }"]}
{"id": "945", "ref_java": ["class Solution {\\n    public boolean canTransform(String start, String end) {\\n        Queue<Node> logs = new LinkedList<>();\\n\\n        int count = 0;\\n        for (char c : start.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                logs.add(new Node(c, count));\\n            }", "class Solution {\\n    public boolean canTransform(String start, String end) {\\n\\t\\n\\t", "class Solution {\\n    public boolean canTransform(String start, String end) {\\n\\t\\n\\t"]}
{"id": "946", "ref_java": ["class Solution {\\n    public int kthGrammar(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }", "class Solution {\\n    public int kthGrammar(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }", "class Solution {\\n    public int kthGrammar(int n, int k) {\\n        if( n == 1) return 0;\\n        int x = (int) Math.pow(2,n-2);\\n        if(k>x) return 1^kthGrammar(n-1,k-x);\\n        return kthGrammar(n-1,k);\\n    }"]}
{"id": "947", "ref_java": ["class Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> map=new HashMap<>();\\n        for(int i=0; i<answers.length ; i++){\\n            if(map.containsKey(answers[i])){\\n                map.put(answers[i], map.get(answers[i])+1);\\n            }", "class Solution {\\n    public int numRabbits(int[] arr) {\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i]==0){\\n                ans++;\\n                continue;\\n            }", "class Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int count = 0;\\n\\n        for (int answer : answers) {\\n            if (answer == 0) {\\n                "]}
{"id": "948", "ref_java": ["class Solution {\\n\\n    List<String>ans=new ArrayList<>();\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    void count(char[] s,int index){\\n\\n    if(index==s.length){\\n    String temp=new String(s);  \\n    if(!mp.containsKey(temp)){\\n        ans.add(temp);\\n        mp.put(temp,true);\\n    }", "class Solution {\\n    private List<String> ans = new ArrayList<>();\\n    private char[] t;\\n\\n    public List<String> letterCasePermutation(String s) {\\n        t = s.toCharArray();\\n        dfs(0);\\n        return ans;\\n    }", "class Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        LinkedList<String> res=new LinkedList<>();\\n        res.add(s);\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            char c=s.charAt(i);\\n            if(Character.isLetter(c)){\\n                int size=res.size();\\n                while(size-- >0){\\n                    String str=res.poll();\\n                    String left=str.substring(0,i);\\n                    String right=str.substring(i+1,n);\\n                    res.add(left+Character.toLowerCase(c)+right);\\n                     res.add(left+Character.toUpperCase(c)+right);\\n                }"]}
{"id": "949", "ref_java": ["class Solution {\\n\\tint[] colors;\\n    public boolean isBipartite(int[][] graph) {\\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tcolors = new int[graph.length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tadj.putIfAbsent(i, new ArrayList<Integer>());\\n\\t\\t\\tfor(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }", "class Solution {\\n\\n    static boolean bfs(int arr[][], int src, int color[]){\\n        int n = arr.length;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(src);\\n        color[src] = 0;\\n\\n        while(q.size()!=0){\\n            int a = q.remove();\\n            int col = color[a];\\n\\n            for(var x : arr[a]){\\n                if(color[x]==-1){\\n                    color[x] = (col==1) ? 0 : 1;\\n                    q.add(x);\\n                }", "class Solution {\\n    "]}
{"id": "950", "ref_java": ["class Solution {\\n    static class Pair implements Comparable<Pair> {\\n        double frc;\\n        int i, j;\\n\\n        public Pair(double frc, int i, int j) {\\n            this.frc = frc;\\n            this.i = i;\\n            this.j = j;\\n        }", "class Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        \\n        double low = 0;\\n        double high = 1.0;\\n        while(low<high){\\n            double mid = (low+high)/2;\\n            int res[] = getFractionsLessThanMid(arr, n, mid);\\n            \\n            if(res[0]==k) return new int[]{arr[res[1]],arr[res[2]]}", "class Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> {\\n                double x = a[0] / (1.0 * a[1]);\\n                double y = b[0] / (1.0 * b[1]);\\n                return x > y? -1 : 1;\\n            }"]}
{"id": "951", "ref_java": ["class Solution {\\n    public int findCheapestPrice(int n, int[][] a, int src, int dst, int k) {\\n        List<List<List<Integer>>> graph = new ArrayList<>();\\n        int i,m=a.length;\\n        for(i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        for(i=0;i<m;i++)\\n        {\\n            ArrayList<Integer> tmp=new ArrayList<>();\\n            tmp.add(a[i][1]); tmp.add(a[i][2]);\\n            graph.get(a[i][0]).add(tmp);\\n        }", "class Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[] distance = new int[n];\\n        Arrays.fill(distance, Integer.MAX_VALUE);\\n        distance[src] = 0;\\n        for (int i = 0; i <= k; i++) {\\n            if (isRoutePossible(distance, flights)) {\\n                break;\\n            }", "class Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<Pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }"]}
{"id": "952", "ref_java": ["class Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9}", "class Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }", "class Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'}"]}
{"id": "953", "ref_java": ["class Solution {\\n    static double distance(int arr1[], int arr2[]){\\n        int x1 = arr1[0];\\n        int y1 = arr1[1];\\n\\n        int x2 = arr2[0];\\n        int y2 = arr2[1];\\n\\n        return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\\n    }", "class Solution {\\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\\n        int len = Math.abs(target[0])+Math.abs(target[1]);\\n        for(int[] arr:ghosts) if(len >= Math.abs(target[0]-arr[0]) + Math.abs(target[1]-arr[1])) return false;\\n        return true;\\n    }", "class Solution {\\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\\n        int len = Math.abs(target[0])+Math.abs(target[1]);\\n        for(int[] arr:ghosts) if(len >= Math.abs(target[0]-arr[0]) + Math.abs(target[1]-arr[1])) return false;\\n        return true;\\n    }"]}
{"id": "954", "ref_java": ["class Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }", "class Solution {\\n    static final int MOD = (int)(1e9 + 7);\\n    public int numTilings(int n) {\\n        \\n        if (n < 3) {\\n            return n;\\n        }", "class Solution {\\n    public int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n        long[] dp = new long[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % mod;\\n        }"]}
{"id": "955", "ref_java": ["class Solution {\\n    public String customSortString(String order, String s) {\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }", "class Solution {\\n    public String customSortString(String order, String s) {\\n        Map<Character, Integer> map = new HashMap<>() ;\\n        \\n        for(char c: s.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }", "class Solution {\\n    public String customSortString(String order, String s) {\\n        \\n        char arr[] = new char[26];\\n\\n        for(int i=0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }"]}
{"id": "956", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int numMatchingSubseq(String s, String[] words) {\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        for(String str:words){\\n            map.put(str,map.getOrDefault(str,0)+1);\\n        }", "class Solution {\\n    public int numMatchingSubseq(String s, String[] words) {\\n        int n = s.length();\\n        List<List<Integer>> occu = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) occu.add(new ArrayList<>());\\n        \\n        for (int i = 0; i < n; i++) occu.get(s.charAt(i) - \\'a\\').add(i);\\n        \\n        int ans = 0;\\n        for (String str : words) {\\n            int prev = -1;\\n            boolean flag = true;\\n            for (char c : str.toCharArray()) {\\n                int idx = bs(occu.get(c - \\'a\\'), prev);\\n                if (idx == -1) {\\n                    flag = false;\\n                    break;\\n                }"]}
{"id": "957", "ref_java": ["class Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }", "class Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }", "class Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }"]}
{"id": "958", "ref_java": ["class Solution {\\n    public int numSubarrayBoundedMax(int[] nums, int left, int right) {\\n        int ans = 0, low = 0, mid = 0;\\n        for (int num : nums) {\\n            if (num > right) mid = 0;\\n            else ans += ++mid;\\n            if (num >= left) low = 0;\\n            else ans -= ++low;\\n        }", "class Solution {\\n    public int numSubarrayBoundedMax(int[] nums, int left, int right) {\\n        int i = 0, j = 0, res = 0, maxind = -1;\\n        while(j < nums.length){\\n            if(nums[j] >= left && nums[j] <= right){\\n                maxind = j;\\n            }", "class Solution {\\n    public int numSubarrayBoundedMax(int[] nums, int left, int right) {\\n        int count = 0,ans = 0,i = 0,j = 0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]>right){\\n                count = 0;\\n                i = j+1;\\n            }"]}
{"id": "959", "ref_java": ["class Solution {\\n    public static class Edge {\\n        int src;\\n        int dest;\\n\\n        public Edge(int src, int dest) {\\n            this.src = src;\\n            this.dest = dest;\\n        }", "class Solution {\\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        List<Integer> currentPath=new ArrayList<>();\\n        currentPath.add(0);\\n        int length=graph.length;\\n        recSol(res,0,length-1,graph,currentPath);\\n        return res;\\n    }", "class Solution {\\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        List<Integer> currentPath=new ArrayList<>();\\n        currentPath.add(0);\\n        int length=graph.length;\\n        recSol(res,0,length-1,graph,currentPath);\\n        return res;\\n    }"]}
{"id": "960", "ref_java": ["class Solution {\\n    public double champagneTower(int k, int r, int c) {\\n        ", "class Solution {\\n    public double champagneTower(int k, int r, int c) {\\n        ", "class Solution {\\n    double dp[][];\\n    public double champagneTower(int poured, int query_row, int query_glass) {\\n\\n        if(query_glass > query_row)return 0;\\n\\n        dp = new double[query_row+1][query_row+1];\\n\\n        for(double i[] : dp)Arrays.fill(i,-1);\\n\\n        dp[0][0] = poured;\\n\\n        double temp = helper(query_row,query_glass);\\n\\n        return (temp > 1? 1:temp);\\n    }"]}
{"id": "961", "ref_java": ["class Solution {\\n    public List<Integer> eventualSafeNodes(int[][] graph) {\\n        int n = graph.length;\\n        boolean [] visited = new boolean[n];\\n\\n        int [] unsafe = new int[n];\\n        for(int i = 0;i<n;i++){\\n            if(unsafe[i]==0){\\n                visited[i] = true;\\n                dfs(i,visited,graph,unsafe);\\n                visited[i] = false;\\n            }", "class Solution {\\n    public List<Integer> eventualSafeNodes(int[][] graph) {\\n        int n = graph.length;\\n        int[] visited = new int[n]; \\n        ", "class Solution {\\n    public boolean dfs(int i, int[][] graph, int[] visit, int[] path, int[] check) {\\n        visit[i] = 1;  "]}
{"id": "962", "ref_java": ["class Solution {\\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\\n        int n=grid.length;\\n        int arr1[]=new int[n];\\n        int arr2[]=new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(arr2[i]<grid[i][j]) arr2[i]=grid[i][j];\\n                if(arr1[j]<grid[i][j]) arr1[j]=grid[i][j];\\n            }", "class Solution {\\n    public int maxIncreaseKeepingSkyline(int[][] arr) {\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for(int i=0; i<n; i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0; j<m; j++){\\n                max = Math.max(arr[i][j],max);\\n            }", "class Solution {\\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\\n        "]}
{"id": "963", "ref_java": ["class Solution {\\n    \\n    double dp [][];\\n\\n    public double soupServings(int n) {\\n\\n           if(n>=4500) return 1;  ", "class Solution {\\n    public double soupServings(int n) {\\n        if (n > 3275) {  \\n            return 1.0;\\n        }", "class Solution {\\n    private int[] optionA = {100, 75, 50, 25}"]}
{"id": "964", "ref_java": ["class Solution {\\n    public int expressiveWords(String s, String[] words) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (isStretchy(s, word))\\n                count += 1;\\n        }", "class Solution {\\n    ", "class Solution {\\n    public int expressiveWords(String s, String[] words) {\\n        \\n        int expressive = 0;\\n\\n        List<List<Integer>> sFreq = countOrder(s);\\n        \\n        for(String w: words) {\\n            List<List<Integer>> wFreq = countOrder(w);\\n            if(sFreq.size() != wFreq.size())\\n                continue;\\n            else {\\n                boolean flag = true;\\n                for(int i = 0 ; i < sFreq.size(); i++) {\\n                    if(sFreq.get(i).get(0) != wFreq.get(i).get(0)) {\\n                        flag = false;\\n                        break;\\n                    }"]}
{"id": "965", "ref_java": ["class Solution {\\n    public List<String> subdomainVisits(String[] arr) {\\n\\n        int n = arr.length;\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        for(int k=0; k<n; k++) {\\n            String num[] = arr[k].split(\" \");\\n\\n            StringBuilder s = new StringBuilder(num[1]);\\n\\n            while (s.length() != 0) {\\n                int a = s.indexOf(\".\");\\n                hp.put(s.toString(), hp.getOrDefault(s.toString(), 0) + Integer.valueOf(num[0]));\\n                if(a==-1) break;\\n                s.delete(0,a+1);\\n            }", "class Solution {\\n    static void domain_visit(String s,HashMap<String,Integer> hm) {    \\n        int visit_cnt = Integer.valueOf(s.substring(0,s.indexOf(\" \")));\\n        String new_str = s.substring(s.indexOf(\" \")+1,s.length());\\n        List<Integer> al = new ArrayList<>();al.add(-1);\\n\\tfor(int i=0;i<new_str.length();++i) {\\n\\t\\tif(new_str.charAt(i)==\\'.\\') al.add(i);\\n\\t}", "class Solution {\\n    HashMap<String, Integer> hm= new HashMap<>();\\n    \\n    public List<String> subdomainVisits(String[] cpdomains) {\\n        List<String> result= new ArrayList<>();\\n\\t\\t\\n        for(String s: cpdomains){\\n            addToList(s);\\n        }"]}
{"id": "966", "ref_java": ["class Solution {\\n  public double largestSumOfAverages(int[] A, int K) {\\n    final int n = A.length;\\n    dp = new double[n + 1][K + 1];\\n    prefix = new double[n + 1];\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i + 1] = A[i] + prefix[i];\\n\\n    return largestSumOfAverages(A, n, K);\\n  }", "class Solution {\\n  public double largestSumOfAverages(int[] nums, int k) {\\n    int n = nums.length;\\n    Double[][] dp = new Double[n][k];\\n    return divide(nums, 0, n, k-1, dp);\\n  }", "class Solution {\\n    double ans = 0;\\n    public double largestSumOfAverages(int[] nums, int k) {\\n        return solve(nums,0,k,new double[nums.length][k+1]);\\n    }"]}
{"id": "967", "ref_java": ["class Solution {\\n\\n    static boolean contains(TreeNode root){\\n        if(root==null) return false;\\n        if(root.val==1) return true;\\n\\n        return contains(root.right) || contains(root.left);\\n    }", "class Solution {\\n    public TreeNode pruneTree(TreeNode root) {\\n        TreeNode ans = postOrder(root);\\n        return ans;\\n    }", "class Solution {\\n    "]}
{"id": "968", "ref_java": ["class Solution {\\n    public List<String> helper (String s) {\\n        List<String> answer = new ArrayList<> ();\\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }", "class Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)}", "class Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String digits = s.substring(1, s.length() - 1);\\n        \\n        List<String> result = new ArrayList();\\n        if(digits.length() < 2) return result;\\n        \\n        \\n        for(int i = 1; i < digits.length(); i++){\\n            "]}
{"id": "969", "ref_java": ["class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set=new HashSet<>();\\n        ListNode itr=head;\\n        int num_comp=0,connected=0;\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }", "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ", "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }"]}
{"id": "970", "ref_java": ["class Solution {\\n    TrieNode root;\\n    class TrieNode {\\n        TrieNode[] next = null;\\n    }", "class Solution {\\n    public int minimumLengthEncoding(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word: words) insert(root, word);\\n        \\n        Stack<TrieNode> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        int size = 0;\\n        while (!stack.isEmpty()) {\\n            TrieNode node = stack.pop();\\n            int numOfChildren = 0;\\n            for (TrieNode child: node.children) {\\n                if (child == null) continue;\\n                numOfChildren++;\\n                stack.add(child);\\n            }", "class Solution {\\n    public int minimumLengthEncoding(String[] W) {\\n        Set<String> set = new HashSet<>(Arrays.asList(W));\\n        for (String word : W)\\n            if (set.contains(word))\\n                for (int i = 1; i < word.length(); i++) \\n                    set.remove(word.substring(i));\\n        int ans = set.size();\\n        for (String word : set) ans += word.length();\\n        return ans;\\n    }"]}
{"id": "971", "ref_java": ["class Solution {\\n    void better(int &x, int y) {\\n        if (x == 0 || x > y) {\\n            x = y;\\n        }", "class Solution {\\n    public int flipgame(int[] fronts, int[] backs) {\\n        int[] count = new int[2001];\\n        int n = fronts.length;\\n        for (int i = 0; i < n; i++) {\\n            if (fronts[i] == backs[i]) {\\n                count[fronts[i]]++;\\n            }", "class Solution {\\n    void better(int &x, int y) {\\n        if (x == 0 || x > y) {\\n            x = y;\\n        }"]}
{"id": "972", "ref_java": ["class Solution {\\n    int mod = (int)1e9+7;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int ans =0;\\n        HashMap<Integer, Long> map = new HashMap<>();\\n\\n        for(int x:arr)\\n        {\\n            long ways =1;\\n            int max = (int)Math.sqrt(x);\\n\\n            for(int j = 0,left=arr[0];left<=max;left=arr[++j])\\n            {\\n                if(x%left!=0)   continue;\\n                int right =x/left;\\n                if(map.containsKey(right))\\n                {\\n                    ways = (ways+map.get(left)*map.get(right)*(left==right?1:2))%mod;\\n                }", "class Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int MOD = 1000000007;\\n        Arrays.sort(arr);\\n        Map<Integer, Long> dp = new HashMap<>();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            dp.put(arr[i], 1L);\\n            for (int j = 0; j < i; j++) {\\n                if (arr[i] % arr[j] == 0) {\\n                    int factor = arr[i] / arr[j];\\n                    if (dp.containsKey(factor)) {\\n                        dp.put(arr[i], (dp.get(arr[i]) + dp.get(arr[j) * dp.get(factor)) % MOD);\\n                    }", "class Solution {\\n    public int nextFact(int[] arr, int numI, int prevI){\\n        int limit = (int)Math.sqrt(arr[numI]);\\n        for(int i = prevI + 1; i < numI; i++){\\n            if(arr[i] > limit) break;\\n            if(arr[numI] % arr[i] == 0) return i;\\n        }"]}
{"id": "973", "ref_java": ["class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }", "class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }", "class Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }"]}
{"id": "974", "ref_java": ["class Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) ", "class Solution {\\n\\n    private record Job(int difficulty, int profit) {}", "class Solution {\\n    class Pair{\\n        int diff;\\n        int prof;\\n        Pair(int diff,int prof){\\n            this.diff = diff;\\n            this.prof = prof;\\n        }"]}
{"id": "975", "ref_java": ["class Solution {\\n    public String maskPII(String s) {\\n        boolean flag = s.contains(\"@\");\\n        if (flag) {\\n            String[] strs = s.split(\"@\");\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toLowerCase(strs[0].charAt(0)));\\n            sb.append(\"*****\");\\n            sb.append(Character.toLowerCase(strs[0].charAt(strs[0].length() - 1)));\\n            sb.append(\"@\");\\n            for (char c : strs[1].toCharArray()) {\\n                if (c == \\'.\\') {\\n                    sb.append(c);\\n                }", "class Solution {\\n    public String maskPII(String s) {\\n        boolean flag = s.contains(\"@\");\\n        if (flag) {\\n            String[] strs = s.split(\"@\");\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toLowerCase(strs[0].charAt(0)));\\n            sb.append(\"*****\");\\n            sb.append(Character.toLowerCase(strs[0].charAt(strs[0].length() - 1)));\\n            sb.append(\"@\");\\n            for (char c : strs[1].toCharArray()) {\\n                if (c == \\'.\\') {\\n                    sb.append(c);\\n                }", "class Solution {\\n    public String maskPII(String s) {\\n        boolean flag = s.contains(\"@\");\\n        if (flag) {\\n            String[] strs = s.split(\"@\");\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toLowerCase(strs[0].charAt(0)));\\n            sb.append(\"*****\");\\n            sb.append(Character.toLowerCase(strs[0].charAt(strs[0].length() - 1)));\\n            sb.append(\"@\");\\n            for (char c : strs[1].toCharArray()) {\\n                if (c == \\'.\\') {\\n                    sb.append(c);\\n                }"]}
{"id": "976", "ref_java": ["class Solution {\\n    public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for (int i=0; i<indices.length; i++){\\n            if (s.startsWith(sources[i],indices[i])){\\n                map.put(indices[i],i);\\n            }", "class Solution {\\n    public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < indices.length; i++)\\n            map.put(indices[i], i);\\n        \\n        int len = s.length();\\n        for(int i = 0; i < len; i++){\\n            if(map.containsKey(i)){\\n                int indice = map.get(i);\\n                if(s.substring(indices[indice], sources[indice].length() + indices[indice]).equals(sources[indice])){\\n                    sb.append(targets[indice]);\\n                    i+=sources[indice].length()-1;\\n                    continue;\\n                }", "class Solution {\\n    public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\\n        int n = s.length();\\n        int[] match = new int[n];\\n        Arrays.fill(match, -1);\\n\\n        for(int i = 0; i < indices.length; i++){\\n            if(indices[i] + sources[i].length() <= s.length() && s.substring(indices[i], indices[i] + sources[i].length()).equals(sources[i])){\\n                match[indices[i]] = i;\\n            }"]}
{"id": "977", "ref_java": ["class Solution {\\n    public int largestOverlap(int[][] img1, int[][] img2) {\\n        int R1 = img1.length;\\n        int R2 = img2.length;\\n        int C1 = img1[0].length;\\n        int C2 = img2[0].length;\\n        int max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\t", "class Solution {\\n    private int res = Integer.MIN_VALUE;\\n    private int size;\\n\\n    public int largestOverlap(int[][] img1, int[][] img2) {\\n        size = img1.length - 1;\\n        for (int i = -size; i <= size; i++) {\\n            for (int j = -size; j <= size; j++) {\\n                int sum = getSum(img1, img2, i, j);\\n                res = Math.max(res, sum);\\n            }", "class Solution {\\n\\n    public int largestOverlap(int[][] img1, int[][] img2) {\\n        int res = 0;\\n        int N = img1.length;\\n        var count = new int[N * 2][N * 2];\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (img1[i][j] == 0) continue;\\n\\n                for (int m = 0; m < N; m++) {\\n                    for (int n = 0; n < N; n++) {\\n                        if (img2[m][n] == 0) continue;\\n                        res = Math.max(res, ++count[N + i - m][N + j - n]);\\n                    }"]}
{"id": "978", "ref_java": ["class Solution {\\n    public double new21Game(int n, int k, int maxPts) {\\n        \\n        ", "class Solution {\\n    public double new21Game(int n, int k, int maxPts) {\\n        if(n>=k+maxPts-1){\\n            return 1;\\n        }", "class Solution {\\n    public double new21Game(int N, int K, int maxPts) {\\n        "]}
{"id": "979", "ref_java": ["class Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }", "class Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }", "class Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        "]}
{"id": "980", "ref_java": ["class Solution {\\n\\n    static boolean helper(int arr[][], int a, int b, int c , int d){\\n\\n        int ax[] = new int[9];\\n\\n        for(int i=a; i<=c; i++){\\n            for(int j=b; j<=d; j++){\\n                if(arr[i][j]<10 && arr[i][j]>0)\\n                ax[arr[i][j]-1]++;\\n            }", "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }", "class Solution {\\n\\n    static boolean helper(int arr[][], int a, int b, int c , int d){\\n\\n        int ax[] = new int[9];\\n\\n        for(int i=a; i<=c; i++){\\n            for(int j=b; j<=d; j++){\\n                if(arr[i][j]<10 && arr[i][j]>0)\\n                ax[arr[i][j]-1]++;\\n            }"]}
{"id": "981", "ref_java": ["class Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> arr) {\\n        int n = arr.size();\\n        HashSet<Integer> hp = new HashSet<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        hp.add(0);\\n\\n        while(q.size()!=0){\\n            int a = q.remove();\\n            for(var x : arr.get(a)){\\n                if(!hp.contains(x)){\\n                    q.add(x);\\n                    hp.add(x);\\n                }", "class Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\\n      int total=rooms.size();\\n      boolean flag[]=new boolean[total];\\n      flag[0]=true;\\n      Queue<Integer>q=new LinkedList<>();\\n      for(int i=0;i<rooms.get(0).size();i++){\\n          q.add(rooms.get(0).get(i));\\n      }", "class Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> edges) {\\n         int n = edges.size();\\n         boolean[] visited = new boolean[n];\\n         Queue<Integer> queue = new LinkedList<>();\\n         queue.add(0);\\n         visited[0]=true;\\n         while(!queue.isEmpty()) {\\n             int size = queue.size();\\n             while(size-->0) {\\n                 int v=queue.poll();\\n                 for(int edge:edges.get(v)) {\\n                     if(!visited[edge]) {\\n                        visited[edge]=true;\\n                        queue.add(edge);\\n                     }"]}
{"id": "982", "ref_java": ["class Solution {\\n    public List<Integer> splitIntoFibonacci(String num) {\\n        List<Integer> list = new ArrayList<>();\\n        dfs(num.toCharArray(), list, 0);\\n        return list;\\n    }", "class Solution {\\n    public List<Integer> splitIntoFibonacci(String S) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if (S == null || S.length() == 0)\\n            return list;\\n        int length = S.length();\\n        int firstMax = Math.min(length / 2, 10), secondMax = Math.min(length * 2 / 3, 20);\\n        for (int i = 1; i <= firstMax; i++) {\\n            if (i > 1 && S.charAt(0) == \\'0\\' || Long.parseLong(S.substring(0, i)) > Integer.MAX_VALUE)\\n                break;\\n            int secondMaxUpper = Math.min(secondMax, i + 11);\\n            for (int j = i + 1; j <= secondMaxUpper; j++) {\\n                List<Integer> splitIndices = new ArrayList<Integer>();\\n                String firstNumStr = S.substring(0, i);\\n                String secondNumStr = S.substring(i, j);\\n                splitIndices.add(i);\\n                splitIndices.add(j);\\n                if (secondNumStr.length() > 1 && secondNumStr.charAt(0) == \\'0\\')\\n                    break;\\n                StringBuffer sb = new StringBuffer(firstNumStr + secondNumStr);\\n                int prevIndex = j;\\n                while (sb.length() < length) {\\n                    long firstNum = Long.parseLong(firstNumStr);\\n                    long secondNum = Long.parseLong(secondNumStr);\\n                    long sum = firstNum + secondNum;\\n                    if (sum > Integer.MAX_VALUE)\\n                        break;\\n                    String sumStr = String.valueOf(sum);\\n                    sb.append(sumStr);\\n                    int index = prevIndex + sumStr.length();\\n                    if (index < length)\\n                        splitIndices.add(index);\\n                    prevIndex = index;\\n                    firstNumStr = secondNumStr;\\n                    secondNumStr = sumStr;\\n                }", "class Solution {\\n    public List<Integer> splitIntoFibonacci(String num) {\\n        List<Integer> result = new ArrayList<>();\\n        helper(num, result, 0);\\n        return result;\\n    }"]}
{"id": "983", "ref_java": ["class Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }", "class Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3) return 0;\\n        int n = arr.length;\\n        int res = 0;\\n        for(int i = 1; i < n-1; i++){\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])){\\n                int j = i-1;\\n                int k = i+1;\\n                while(j > 0){\\n                    if(arr[j] > arr[j-1]) j--;\\n                    else break;\\n                }", "class Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }"]}
{"id": "984", "ref_java": ["class Solution {\\n    public boolean isNStraightHand(int[] hand, int groupSize) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int card : hand) {\\n            countMap.put(card, countMap.getOrDefault(card, 0) + 1);\\n        }", "class Solution {\\n    public boolean isNStraightHand(int[] hand, int groupSize) {\\n       Arrays.sort(hand);\\n       int len = hand.length;\\n       boolean[] visited = new boolean[len];\\n       for(int i = 0;i < len;i++){\\n           if(visited[i]) continue;\\n           visited[i] = true;\\n           int j = i + 1;\\n           int count = 1;\\n           int num = hand[i] + 1;\\n           for(count = 1;j < len && count < groupSize;j++){\\n               if(visited[j]) continue;\\n               if(hand[j] > num) break;\\n               if(hand[j] == num ) {\\n                   num++;\\n                   visited[j] = true;\\n                   count++;\\n               }", "class Solution {\\n    public boolean isNStraightHand(int[] hand, int W) {\\n        if(hand.length % W != 0) return false;\\n\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        for(int elem: hand) minHeap.add(elem);\\n\\n        while(!minHeap.isEmpty()){\\n            int head = minHeap.poll();\\n            for(int i=1; i<W; i++)\\n                if(!minHeap.remove(head+i)) return false;\\n        }"]}
{"id": "985", "ref_java": ["class Solution {\\n    public String shiftingLetters(String s, int[] shifts) {\\n        StringBuilder str= new StringBuilder(\"\");\\n        int n=shifts.length;\\n        int move=0;\\n        for(int i=n-1;i>=0;i--){\\n            move+=shifts[i];\\n            if(move>26){\\n                move=move%26;\\n            }", "class Solution {\\n    \\n    static void helper(StringBuilder s, long arr[], char alpha[]){\\n        for(int i=0; i<arr.length; i++){\\n            long a = s.charAt(i)-97;\\n            a = a+arr[i];\\n            a=a%26;\\n            s.replace(i,i+1,alpha[(int)a]+\"\");\\n        }", "class Solution {\\n    public String shiftingLetters(String s, int[] shifts) {\\n        StringBuilder ans = new StringBuilder(s);\\n        long shift=0;\\n        for (int i = s.length()-1; i >=0 ; i--){\\n            ans.setCharAt(i, (char)((s.charAt(i) - \\'a\\' + (shift+shifts[i]) % 26) % 26 + \\'a\\'));\\n            shift+=shifts[i];\\n        }"]}
{"id": "986", "ref_java": ["class Solution {\\n   \\n    public int maxDistToClosest(int[] seat) {\\n        \\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int ans = 0;\\n\\n        for(int i=0; i<seat.length; i++){\\n            if(seat[i]==1) arr.add(i);\\n        }", "class Solution {\\n    public int maxDistToClosest(int[] seats) {\\n        int pre_zeros = -1, suf_zeros = -1, max_zeros = -1, zeros = 0;\\n        for (int i = 0; i < seats.length; i ++) {\\n            if (seats[i] == 0) {\\n                zeros ++;\\n            }", "class Solution {\\n    public int maxDistToClosest(int[] seats) {\\n        int n = seats.length;\\n        int empty = 0;\\n        int result = 0;\\n        int idx1 = -1, idx2 = -1;\\n        \\n        for(int i = 0; i < n; ++i){\\n            if(seats[i] == 1){\\n                empty = 0;\\n                if(idx1 == -1) idx1 = i;\\n                idx2 = i;\\n            }"]}
{"id": "987", "ref_java": ["class Solution {\\n    int ans=-1,val=0;\\n    public void dfs(int n,ArrayList<ArrayList<Integer>> adj,boolean vis[],int quiet[]){\\n        vis[n]=true;\\n        for(int x:adj.get(n)){\\n            if(!vis[x]){\\n            if(val>quiet[x]){\\n                val=quiet[x];\\n                ans=x;\\n            }", "class Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int[] quietest = new int[quiet.length];\\n        for(int i = 0; i < quiet.length; i++){\\n            quietest[i] = searchForQuietest(richer, quiet, i, quietest);\\n        }", "class Solution {\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        int n = quiet.length;\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++){\\n            res[i] = i;\\n        }"]}
{"id": "988", "ref_java": ["class Solution {\\n    public int peakIndexInMountainArray(int[] arr) {\\n        int i = 0;\\n        int j = arr.length - 1;\\n        int n = arr.length;\\n        while (i <= j) {\\n            int mid = (i + j) / 2;\\n            if ((mid == 0 || arr[mid - 1] < arr[mid]) && (mid == n - 1 || arr[mid + 1] < arr[mid]))\\n                return mid;\\n            else if (mid > 0 && arr[mid - 1] > arr[mid])\\n                j = mid - 1;\\n            else\\n                i = mid + 1;\\n        }", "class Solution {\\n    public int peakIndexInMountainArray(int[] arr) {int left=0;\\n    int right=arr.length-1;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n\\n            if(arr[mid]<arr[mid+1])\\n            {\\n                left=mid+1;\\n            }", "class Solution {\\n    public int peakIndexInMountainArray(int[] arr) {\\n        int start = 0, end = arr.length - 1, mid;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (arr[mid] < arr[mid + 1])\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }"]}
{"id": "989", "ref_java": ["class Solution {\\n    public int carFleet(int target, int[] position, int[] speed) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->(b[0]-a[0]));", "class Solution {\\n    public int carFleet(int target, int[] position, int[] speed) {\\n        int n = position.length;\\n        Car[] cars = new Car[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            cars[i] = new Car(position[i], speed[i]);\\n        }", "class Solution {\\n    public int carFleet(int target, int[] position, int[] speed) {\\n        int n = position.length;\\n        Car[] cars = new Car[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            cars[i] = new Car(position[i], speed[i]);\\n        }"]}
{"id": "991", "ref_java": ["class Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }", "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            }", "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }"]}
{"id": "992", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int mirrorReflection(int p, int q) {\\n        while(((p|q)&1) == 0){\\n            p >>= 1;\\n            q >>= 1;\\n        }", "class Solution {\\n    public int mirrorReflection(int p, int q) {\\n        while(p%2==0 && q%2==0){\\n            p/=2;\\n            q/=2;\\n        }"]}
{"id": "993", "ref_java": ["class Solution {\\n    public int matrixScore(int[][] grid) {\\n        int score = 0;\\n        boolean[] rowFlipped = new boolean[grid.length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            int current = 0;\\n            int flipped = 0;\\n            for (int j = 0; j < grid[i].length; j++) {\\n                current <<= 1;\\n                flipped <<= 1;\\n                current += grid[i][j];\\n                flipped += grid[i][j] == 0 ? 1 : 0;\\n            }", "class Solution {\\n\\n    public int matrixScore(int[][] grid) {\\n        ", "class Solution {\\n    public int matrixScore(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        \\n        "]}
{"id": "994", "ref_java": ["class Solution {\\n\\n    public void parentLink(Map<TreeNode,TreeNode>parent_map,TreeNode root){\\n        \\n        Queue<TreeNode>q=new LinkedList<>();\\n        q.add(root);\\n\\n        while(!q.isEmpty()){\\n            TreeNode cur=q.poll();\\n\\n            if(cur.left!=null){\\n                parent_map.put(cur.left,cur);\\n                q.add(cur.left);\\n            }", "class Solution {\\n\\n    static HashMap<Integer,Integer> hm = new HashMap<>() ;\\n    static int tdpth ;\\n    static List<Integer> ans = new ArrayList<>() ;\\n\\n    static boolean func1(TreeNode node,int t,int k,int dpth) {\\n        if(node!=null) {\\n            if(node.val==t) {\\n                hm.put(t,0) ;\\n                tdpth = dpth;\\n                return true;\\n            }", "class Solution {\\n    List<Integer>ans;\\n    boolean bool;\\n    int tar;\\n    int dist;\\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\\n        ans = new ArrayList<>();\\n        bool=false;\\n        tar=target.val;\\n        dist=k;\\n        if(root==null)return ans ;\\n        helper(root,1);\\n        return ans;\\n    }"]}
{"id": "995", "ref_java": ["class Solution {\\n    int maxDepth = Integer.MIN_VALUE;\\n    TreeNode result = null;\\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\\n        postOrder(root, 0);\\n        return result;\\n    }", "class Solution {\\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\\n        return getDepth(root).getValue();\\n    }", "class Solution {\\n    TreeNode ans;\\n    int maxDepth = 0;\\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\\n        \\n        lca(root,0);\\n        return ans;\\n    }"]}
{"id": "996", "ref_java": ["class Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }", "class Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }", "class Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }"]}
{"id": "997", "ref_java": ["class Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }", "class Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }", "class Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }"]}
{"id": "998", "ref_java": ["class Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }", "class Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        Arrays.sort(nums1);\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = i;\\n            mat[i][1] = nums2[i];\\n        }", "class Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        int[] ans = new int[n];\\n        boolean[] vis = new boolean[n];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int ub = upperBound(nums1, nums2[i]);\\n            if(ub!=n && vis[ub]==false){\\n                 ans[i] = nums1[ub];\\n                 vis[ub] = true;\\n            }"]}
{"id": "999", "ref_java": ["class Solution {\\n\\tpublic int lenLongestFibSubseq(int[] arr) {\\n\\t\\tint length = arr.length;\\n\\t\\tint[][] dp = new int[length][length];\\n\\t\\tint result = 0;\\n\\t\\tfor (int i = 2; i < length; i++) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = i - 1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint val = arr[left] + arr[right] - arr[i];\\n\\t\\t\\t\\tif (val < 0) {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}", "class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length;\\n        int result = 0;\\n        int[][] dp = new int[n][n];\\n\\n        for (int i = 2; i < n; i++) {\\n            int l = 0, r = i - 1;\\n\\n            while (l < r) {\\n                int sum = arr[l] + arr[r];\\n                if (sum > arr[i]) {\\n                    r--;\\n                }", "class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n\\n        Arrays.sort(arr);\\n\\n        int ans = 0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n\\n                int target = arr[i]+arr[j];\\n                int last = arr[j];\\n                int m = j+1,n = arr.length-1;\\n                int len = 2;\\n                while(m<=n){\\n                    int mid= (m+n)/2;\\n                    if(arr[mid]>target){\\n                        n = mid-1;\\n                    }"]}
{"id": "1000", "ref_java": ["class Solution {\\n    public int robotSim(int[] commands, int[][] obstacles) {\\n        Robot robot = new Robot();\\n        Set<Obstacle> obstacleSet = new HashSet<>();\\n        for (int[] obstacle : obstacles) {\\n            obstacleSet.add(new Obstacle(obstacle[0], obstacle[1]));\\n        }", "class Solution {\\n\\n    static class Point {\\n        int row;\\n        int column;\\n\\n        public Point(int i, int j) {\\n            this.row = i;\\n            this.column = j;\\n        }", "class Solution {\\n    public int robotSim(int[] commands, int[][] obstacles) {\\n        int x = 0, y = 0, j = 0, result = 0;\\n\\t\\tint[][] dirs = {{0,1}"]}
{"id": "1001", "ref_java": ["class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=Integer.MIN_VALUE;\\n        for(int i=0;i<piles.length;i++){\\n            high=Math.max(high,piles[i]);\\n        }", "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }", "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles[0];\\n        for(int i = 0;i<piles.length;i++){\\n            r=Math.max(r,piles[i]);\\n        }"]}
{"id": "1002", "ref_java": ["class Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }", "class Solution {\\n    public boolean stoneGame(int[] piles) {\\n        ", "class Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return helper3(piles);\\n    }"]}
{"id": "1003", "ref_java": ["class Solution {\\npublic String decodeAtIndex(String s, int k) {\\n    int prev = 0, temp = 0;\\n    for(int i = 0; i < s.length(); i++){\\n        if(Character.isDigit(s.charAt(i))) {\\n            temp = prev;\\n            prev *= (s.charAt(i) - \\'0\\');\\n            if(k <= prev || temp > prev){ ", "class Solution {\\n    public String decodeAtIndex(String inputString, int k) {\\n        long decodedLength = 0; ", "class Solution {\\npublic String decodeAtIndex(String s, int k) {\\n    int prev = 0, temp = 0;\\n    for(int i = 0; i < s.length(); i++){\\n        if(Character.isDigit(s.charAt(i))) {\\n            temp = prev;\\n            prev *= (s.charAt(i) - \\'0\\');\\n            if(k <= prev || temp > prev){ "]}
{"id": "1004", "ref_java": ["class Solution {\\n    public int numRescueBoats(int[] people, int limit) {\\n        int boatCount = 0;\\n        Arrays.sort(people);\\n        \\n        int left = 0;\\n        int right = people.length - 1;\\n        \\n        while(left <= right){\\n            int sum = people[left] + people[right];\\n            if(sum <= limit){\\n                boatCount++;\\n                left++;\\n                right--;\\n            }", "class Solution {\\n    public int numRescueBoats(int[] arr, int n) {\\n        int res = 0,bl;\\n        Arrays.sort(arr);\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            if(arr[l]+arr[r]<=n){\\n                l++;\\n                r--;\\n                res++;\\n            }", "class Solution {\\n    public int numRescueBoats(int[] people, int limit) {\\n        Arrays.sort(people);\\n        int start = 0; \\n        int end = people.length - 1;\\n        int res = 0;\\n\\n        while (start <= end) {\\n            if (people[start] + people[end] <= limit){\\n                start++;\\n            }"]}
{"id": "1005", "ref_java": ["class Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart }", "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows*cols][2];\\n        int i = 0;\\n        mat[i++] = new int[]{rStart,cStart}", "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart}"]}
{"id": "1006", "ref_java": ["class Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n          if(dislikes.length == 0) return true;\\n          HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n          for(int i = 1 ; i <= n ; i++){\\n              map.put(i,new ArrayList<Integer>());\\n          }", "class Solution {\\n  public boolean possibleBipartition(int n, int[][] dislikes) {\\n    List<Integer>[] graph = new List[n + 1];\\n    Color[] colors = new Color[n + 1];\\n    Arrays.fill(colors, Color.kWhite);\\n\\n    for (int i = 1; i <= n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] d : dislikes) {\\n      final int u = d[0];\\n      final int v = d[1];\\n      graph[u].add(v);\\n      graph[v].add(u);\\n    }", "class Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int len = dislikes.length;\\n        boolean[] check = new boolean[len];\\n        int[] arr = new int[n + 1];\\n        boolean foundNew;\\n        for(int i = 0; i < len; i++){\\n            if(check[i]) continue;\\n            arr[dislikes[i][0]] = 1;\\n            arr[dislikes[i][1]] = 2;\\n            foundNew = true;\\n            while(foundNew){\\n                foundNew = false;\\n                for(int j = i + 1; j < len; j++){\\n                    if(check[j]) continue;\\n                    int x = arr[dislikes[j][0]];\\n                    int y = arr[dislikes[j][1]];\\n                    if(x == 0 && y == 0) continue;\\n                    if(x > 0 && y > 0){\\n                        if((x - y) % 2 == 0) return false;\\n                    }"]}
{"id": "1007", "ref_java": ["class Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }", "class Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }", "class Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }"]}
{"id": "1008", "ref_java": ["class Solution {\\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\\n        List<String> list=new ArrayList();\\n        for(String word:words){\\n                if(isCheck(word,pattern)){\\n                list.add(word);\\n            }", "class Solution {\\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\\n        List<String> res = new ArrayList<>();\\n        for (String word : words) {\\n            if (check(word, pattern)) res.add(word);\\n        }", "class Solution {\\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\\n        List<String> al = new ArrayList();\\n        int count1=0;\\n        HashMap<Character,Integer> hp1 = new HashMap();\\n        String res=\"\";\\n        for(int i=0;i<pattern.length();i++){\\n            if(hp1.containsKey(pattern.charAt(i))){\\n                    res += \"\"+hp1.get(pattern.charAt(i));\\n                }"]}
{"id": "1009", "ref_java": ["class Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }", "class Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }", "class Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set=new HashSet<>();\\n        int count=0;\\n        for(int i=0; i<words.length; i++){\\n            String str=words[i];\\n            String odd=\"\";\\n            String even=\"\";\\n            for(int j=0; j<str.length(); j++){\\n                if(j%2==0)even+=str.charAt(j);\\n                else odd+=str.charAt(j);\\n            }"]}
{"id": "1010", "ref_java": ["class Solution {\\n    Map<Integer, List<TreeNode>> map = new HashMap();\\n    public List<TreeNode> allPossibleFBT(int n) {\\n        List<TreeNode> al = new ArrayList();\\n        if(map.containsKey(n)) {\\n            return map.get(n);\\n        }", "class Solution {\\n    public List<TreeNode> allPossibleFBT(int n) {\\n      if(n==0 || n%2 ==0) return new ArrayList<>();\\n        Map<Integer, List<TreeNode>> map = new HashMap<>();\\n        return generateTree(map,n);\\n    }", "class Solution {\\n    static final int MAX_N = 20;\\n    static TreeNode[][] trees = new TreeNode[MAX_N + 1][];\\n    \\n    public List<TreeNode> allPossibleFBT(int n) {\\n        if (trees[1] == null) {\\n            trees[0] = new TreeNode[0];\\n            for (int i = 2; i <= MAX_N; i += 2)  trees[i] = trees[0];\\n            \\n            trees[1] = new TreeNode[1];\\n            trees[1][0] = new TreeNode();\\n            \\n            trees[3] = new TreeNode[1];\\n            trees[3][0] = new TreeNode();\\n            trees[3][0].left = trees[3][0].right = trees[1][0];\\n            \\n            for (int m = 5; m <= MAX_N; m += 2) {\\n                int configCount = 0;\\n                for (int i = 1; i < m; i++)\\n                    configCount += trees[i].length * trees[m - i - 1].length;\\n                TreeNode[] configs = trees[m] = new TreeNode[configCount];\\n                int configsIdx = 0;\\n                for (int i = 1; i < m; i++) {\\n                    for (TreeNode left : trees[i]) {\\n                        for (TreeNode right : trees[m - i - 1]) {\\n                            configs[configsIdx] = new TreeNode();\\n                            configs[configsIdx].left = left;\\n                            configs[configsIdx++].right = right;\\n                        }"]}
{"id": "1011", "ref_java": ["class Solution {\\n    public int subarrayBitwiseORs(int[] arr) {\\n        Set<Integer> ors= new HashSet<>();\\n\\n        for(int i=arr.length-1; i>=0; i--) {\\n            ors.add(arr[i]);\\n            for(int j=i+1; j<arr.length; j++) {\\n                if((arr[j] | arr[i]) == arr[j]) {\\n                    break;\\n                }", "class Solution {\\n    public int subarrayBitwiseORs(int[] arr) {\\n       int n = arr.length; \\n       HashSet<Integer> hs = new HashSet<>();\\n       for(int i=0;i<n;i++){\\n           int ans = 0;\\n           for(int j=i;j<n;j++){\\n               ans |= arr[i] | arr[j];\\n               hs.add(ans);\\n           }", "class Solution {\\n        public int subarrayBitwiseORs(int[] arr) {\\n            Set<Integer> set = new HashSet<>();\\n            for (int i = 0; i < arr.length; i++) {\\n                set.add(arr[i]);\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if ((arr[i] | arr[j]) == arr[j]) {\\n                        break;\\n                    }"]}
{"id": "1014", "ref_java": ["class Solution {\\n    public int totalFruit(int[] tree) {\\n        int max = 0;\\n        int curMax = 0;\\n        int prev = -1;\\n        int prev2 = -1;\\n        int prevCount = 0;\\n\\n        for (int fruit: tree) {\\n            if (fruit == prev || fruit == prev2) {\\n                curMax++;\\n            }", "class Solution {\\n    public int totalFruit(int[] fruits) {\\n        int n=fruits.length;\\n        HashMap<Integer,Integer>m=new HashMap<>();\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n       \\n        while(i<n)\\n        { \\n            m.put(fruits[i], m.getOrDefault(fruits[i], 0) + 1);\\n            if(m.size()>2)\\n            { \\n                while(m.size()>2)\\n                { \\n                   m.put(fruits[j],m.get(fruits[j])-1);\\n                    if(m.get(fruits[j])==0)\\n                    m.remove(fruits[j]);\\n                    j++;\\n                    \\n                }", "class Solution {\\n    public int totalFruit(int[] fruits) {\\n        if(fruits.length < 2)\\n            return fruits.length;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        int ans = 0;\\n        \\n        q.add(fruits[0]);\\n        map.put(fruits[0], 1);\\n        \\n        for(int i=1; i<fruits.length; i++) {\\n            if(map.size() < 2 || map.containsKey(fruits[i])) {\\n                map.put(fruits[i], map.getOrDefault(fruits[i], 0) + 1);\\n                q.add(fruits[i]);\\n            }"]}
{"id": "1015", "ref_java": ["class Solution {\\n    public int sumSubarrayMins(int[] arr) {\\n        int ans = 0;\\n        Stack<Integer> st = new Stack<>();\\n        long mod = (long)1000000007;\\n        st.push(-1);\\n        for (int i= 0; i < arr.length+1; i++){\\n            int currVal = (i<=arr.length-1)? arr[i] : 0;\\n            while(st.peek() !=-1 && currVal<arr[st.peek()]){\\n                int index = st.pop();\\n                int j = st.peek();\\n                int left = index - j;\\n                int right = i - index;\\n                long add = (left * right * (long)arr[index]) % mod;\\n                ans += add ;\\n                ans %= mod;\\n            }", "class Solution {\\n    public int sumSubarrayMins(int[] arr) {\\n        ", "class Solution {\\n    public int sumSubarrayMins(int[] arr) {\\n        long res = 0;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        long M = (long)1e9 + 7;\\n        stack.push(-1);\\n        \\n        for (int i2 = 0; i2 < arr.length+1; i2++){\\n            int currVal = (i2<arr.length)? arr[i2] : 0;\\n            \\n            while(stack.peek() !=-1 && currVal < arr[stack.peek()]){\\n                int index = stack.pop();\\n                int i1 = stack.peek();\\n                int left = index - i1;\\n                int right = i2 - index;\\n                long add = (long)(left * right * (long)arr[index]) % M;\\n                res += add ;\\n                res %= M;\\n            }"]}
{"id": "1016", "ref_java": ["class Solution {\\n    public int snakesAndLadders(int[][] board) {\\n        int boardLength = board.length;\\n        int boardArea = boardLength * boardLength;\\n        int[] flatten = new int[boardArea];\\n        boolean[] visisted = new boolean[boardArea];\\n\\n        boolean right = true;\\n        int counter = 0;\\n        ", "class Solution {\\n    int res = -1, b[];\\n    public int snakesAndLadders(int[][] board) {\\n        int n = board.length, k = 1, steps = 0;\\n        b = new int[n*n+1];\\n        int map[] = new int[n*n+1];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = (i%2==0)?0:n-1; j>=0 && j<n; ) {\\n                b[k++] = board[n-i-1][j];\\n                if(i%2==0) j++; else j--;\\n            }", "class Solution {\\n    public int snakesAndLadders(int[][] board) {\\n        int destination = board.length * board.length;\\n        boolean[] visited = new boolean[destination+1];\\n        Deque<Integer> q = new ArrayDeque();\\n        q.add(1);\\n        visited[1] = true;\\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            ans++;\\n            int size = q.size();\\n            for(int i=0; i < size; i++){\\n                int f = q.poll();\\n                boolean added = false;\\n                for(int j = 6; j > 0; j--){\\n                    int nc = f + j;\\n                    if(nc >= destination)\\n                        return ans;\\n                    if(!visited[nc]){\\n                        int c = getCell(board,nc);\\n                        if(c == destination)\\n                            return ans;\\n                        if((c == -1 || c == nc) && !added){\\n                            q.offer(nc);\\n                            added = true;\\n                        }"]}
{"id": "1017", "ref_java": ["class Solution {\\n    private int len;\\n    public int smallestRangeII(int[] nums, int k) {\\n        len = nums.length;\\n        Arrays.sort(nums);\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < len; i++)\\n            result = Math.min(result, getResult(nums, k, i));\\n        return result;\\n    }", "class Solution {\\n    public int smallestRangeII(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = nums[nums.length - 1] - nums[0];\\n        for (int i = 0; i < nums.length - 1; ++i) {\\n            ans = Math.min(ans, Math.max(nums[i] + k, nums[nums.length - 1] - k) - Math.min(nums[i + 1] - k, nums[0] + k));\\n        }", "class Solution {\\n    public int smallestRangeII(int[] n, int k) {\\n        Arrays.sort(n);\\n        int  l = n.length;\\n        int min_diff = n[l-1] - n[0];\\n        \\n        if(l == 1)\\n            return 0;\\n        \\n        for(int i=0;i<l-1;i++)\\n        {\\n            int a = Math.min(n[0]+k , n[i+1]-k);\\n            int b = Math.max(n[l-1]-k , n[i]+k);\\n            min_diff = Math.min(min_diff,b-a);\\n        }"]}
{"id": "1019", "ref_java": ["class Solution {\\n    public int[] sortArray(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }", "class Solution {\\n    \\n    private void merge(int[] nums,int low, int mid, int high){\\n        int n = mid-low+1, m = high - mid;\\n        int[] left = new int[n];\\n        int[] right = new int[m];\\n        \\n        int i =0,j=0;\\n        for(i=0;i<n;i++)\\n            left[i] = nums[low+i];\\n        \\n        for(i=0;i<m;i++)\\n            right[i] = nums[i+mid+1];\\n        \\n        i=0;\\n        j=0;\\n        int k = low;\\n        while(i<n && j<m){\\n            if(left[i]<right[j])\\n                nums[k++] = left[i++];\\n            else\\n                nums[k++] = right[j++];\\n        }", "class Solution {\\n    public int[] sortArray(int[] nums) {\\n        MergeSort.mergeSort(nums);\\n        return nums;\\n    }"]}
{"id": "1020", "ref_java": ["class Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        \\n        int partition = 0;\\n        int leftMax = nums[0];\\n        int rightMax = nums[1];\\n        for(int x = 2;x< nums.length;x++){\\n            while(!(leftMax <= rightMax)){ ", "class Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0];\\n        int max=nums[0];\\n        int length=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){\\n                length=i+1;\\n                leftmax=max;\\n            }", "class Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        \\n        int partition = 0;\\n        int leftMax = nums[0];\\n        int rightMax = nums[1];\\n        for(int x = 2;x< nums.length;x++){\\n            while(!(leftMax <= rightMax)){ "]}
{"id": "1021", "ref_java": ["class Solution {\\n    public List<String> wordSubsets(String[] words1, String[] words2) {\\n        List<String> res = new ArrayList<>();\\n        int[] arr = new int[26];\\n        for (String w : words2) {\\n            int[] tmp = new int[26];\\n            for (char c : w.toCharArray()) {\\n                tmp[c - \\'a\\']++;\\n                if (arr[c - \\'a\\'] < tmp[c - \\'a\\']) {\\n                    arr[c - \\'a\\'] = tmp[c - \\'a\\'];\\n                }", "class Solution {\\n    public List<String> wordSubsets(String[] words1, String[] words2) {\\n        List<String> res = new ArrayList<>();\\n        int[] arr = new int[26];\\n        for (String w : words2) {\\n            int[] tmp = new int[26];\\n            for (char c : w.toCharArray()) {\\n                tmp[c - \\'a\\']++;\\n                if (arr[c - \\'a\\'] < tmp[c - \\'a\\']) {\\n                    arr[c - \\'a\\'] = tmp[c - \\'a\\'];\\n                }", "class Solution {\\n    public List<String> wordSubsets(String[] words1, String[] words2) {\\n        List<String> result = new ArrayList<>();\\n        int[] words2Freq = getMaxFrequencies(words2);\\n        \\n        "]}
{"id": "1022", "ref_java": ["class Solution {\\n    public int maxSubarraySumCircular(int[] nums) {\\n        \\n        int minSum = Integer.MAX_VALUE;\\n        int currMinSum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        int currMaxSum=0;\\n        int totalSum=0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            currMinSum+=nums[i];\\n            currMaxSum+=nums[i];\\n\\n            minSum = Math.min(minSum, currMinSum);\\n            \\n            if(currMinSum> 0)\\n            currMinSum=0;\\n\\n            maxSum = Math.max(currMaxSum, maxSum);\\n\\n            if(currMaxSum < 0)\\n            currMaxSum=0;\\n\\n            totalSum+=nums[i];\\n        }", "class Solution {\\n    public int maxSubarraySumCircular(int[] nums) {\\n        boolean hasZeros = false;\\n        int sum=0; for(int i:nums) {sum+=i; if(i==0) hasZeros=true;}", "class Solution {\\n    public int maxSubarraySumCircular(int[] nums) {\\n       int total = 0, maxSum = nums[0], curMax = 0, minSum = nums[0], curMin = 0;\\n       for (int a : nums) {\\n            curMax = Math.max(curMax + a, a);\\n            maxSum = Math.max(maxSum, curMax);\\n            curMin = Math.min(curMin + a, a);\\n            minSum = Math.min(minSum, curMin);\\n            total += a;\\n        }"]}
{"id": "1024", "ref_java": ["class Solution {\\n    public int minAddToMakeValid(String s) {\\n        int a = 0, b = 0; \\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                a++;\\n            }", "class Solution {\\n    public int minAddToMakeValid(String s) {\\n        int f = 0;\\n        int t = 0;\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(c==\\'(\\'){\\n                if(t > 0){\\n                    f += Math.abs(t);\\n                    t = 0;\\n                }", "class Solution {\\n    public int minAddToMakeValid(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(!stack.isEmpty() && stack.peek()==\\'(\\' ){\\n                    stack.pop();\\n                }"]}
{"id": "1025", "ref_java": ["class Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }", "class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t", "class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        long count = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < n; i++) {\\n            "]}
{"id": "1026", "ref_java": ["class Solution {\\n    public int minFlipsMonoIncr(String s) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n               count++;\\n            }", "class Solution {\\n    public int minFlipsMonoIncr(String s) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n               count++;\\n            }", "class Solution {\\n    public int minFlipsMonoIncr(String s) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n               count++;\\n            }"]}
{"id": "1027", "ref_java": ["class Solution {\\r\\n    public int numSubarraysWithSum(int[] nums, int goal) {\\r\\n        HashMap<Integer,Integer> map = new HashMap();\\r\\n\\r\\n        int currSum =0,res=0;\\r\\n        map.put(0,1);\\r\\n        for(int i=0;i<nums.length;i++)\\r\\n        {\\r\\n            currSum=currSum+nums[i];\\r\\n            res += map.getOrDefault(currSum-goal,0);\\r\\n            if(map.containsKey(currSum))\\r\\n                map.put(currSum,map.get(currSum)+1);\\r\\n            else\\r\\n                map.put(currSum,1);\\r\\n        }", "class Solution {\\r\\n    public int solve(int []nums, int k){\\r\\n        if(k<0){\\r\\n            return 0;\\r\\n        }", "class Solution {\\r\\n    public int numSubarraysWithSum(int[] nums, int goal) {\\r\\n        int i = 0, j = 0, count = 0, sum = 0, temp = 0;\\r\\n        while (j<nums.length) {\\r\\n            sum += nums[j];\\r\\n            if (nums[j] == 1) temp = 0;\\r\\n            if (sum > goal) {\\r\\n                sum -= nums[i];\\r\\n                i++;\\r\\n            }"]}
{"id": "1028", "ref_java": ["class Solution {\\n    int dp[][]; \\n\\n    int solve(int[][] matrix, int row, int col) {\\n        if (row >= matrix.length || col >= matrix[0].length || col < 0) {\\n            return Integer.MAX_VALUE;\\n        }", "class Solution {\\n\\n\\n    ", "class Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        if(matrix[0].length>1){\\n            for(int i=matrix.length-2;i>=0;i--){\\n                for(int j=0;j<matrix[0].length;j++){\\n                    if(j==0){\\n                        matrix[i][j]=matrix[i][j]+Math.min(matrix[i+1][j],matrix[i+1][j+1]);\\n                    }"]}
{"id": "1029", "ref_java": ["class Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }", "class Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }", "class Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }"]}
{"id": "1030", "ref_java": ["class Solution {\\n    public int shortestBridge(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        ", "class Solution {\\n\\n    private final int[] DIRX = {-1, 1, 0, 0}", "class Solution {\\n    \\n    public void bfs(int[][] grid, int[][] vis, int i, int j, int time ,Set<Pair<Integer,Integer>> first, Set<Pair<Integer,Integer>> second){\\n        Queue<Pair<Integer,Integer>> q = new LinkedList();\\n        q.offer(new Pair(i,j));\\n        vis[i][j] = 1;\\n        int n = grid.length;\\n        int[] dr = {-1,0,1,0}"]}
{"id": "1031", "ref_java": ["class Solution {\\n    static final int mod = (int) 1e9 + 7;\\n    static final int[][] MOVES = {\\n             {4, 6}", "class Solution {\\n    public int knightDialer(int n) {\\n        final int MOD = 1_000_000_007;\\n        int[][] moves = {{4, 6}", "class Solution {\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6}"]}
{"id": "1032", "ref_java": ["class Solution {\\n    public String[] reorderLogFiles(String[] logs) {\\n        PriorityQueue<letterLog> letterLogs = new PriorityQueue<>((a,b) -> a.compareTo(b));\\n        ArrayList<String> digitLogs = new ArrayList<>();\\n        for(String s : logs) {\\n            int index = s.indexOf(\" \");\\n            if(s.charAt(index+1) < \\'a\\') {\\n                digitLogs.add(s);\\n            }", "class Solution {\\n        private static final Comparator<String> comp = (a, b) -> {\\n\\n        String id = \"\";\\n        String content = \"\";\\n        id = a.substring(0,a.indexOf(\" \"));\\n        content = a.substring(a.indexOf(\" \")+1);\\n        \\n        String id1 = \"\";\\n        String content1 = \"\";\\n        id1 = b.substring(0,b.indexOf(\" \"));\\n        content1 = b.substring(b.indexOf(\" \")+1);\\n        \\n        if(content.equals(content1)){\\n            return id.compareTo(id1);\\n        }", "class Solution {\\n    public String[] reorderLogFiles(String[] logs) {\\n        if(logs.length == 0) return logs;\\n        List<String> letterLogs = new ArrayList<>(), digitLogs = new ArrayList<>();\\n        separateLettersDigits(logs, letterLogs, digitLogs);\\n        sortLetterLogs(letterLogs);\\n        return generateOutput(letterLogs, digitLogs);  \\n    }"]}
{"id": "1033", "ref_java": ["class Solution {\\n    public int minAreaRect(int[][] points) {\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();\\n        for(int i = 0; i<points.length; i++){\\n            if(!map.containsKey(points[i][0])){\\n                map.put(points[i][0], new HashSet<Integer>());\\n            }", "class Solution {\\n    public int minAreaRect(int[][] points) {\\n        HashMap<Integer, Set<Integer>> hashmap = new HashMap<>();  ", "class Solution {\\n    public int minAreaRect(int[][] points) {\\n        HashMap<Integer,Set<Integer>> hm = new HashMap<>();\\n        int area=Integer.MAX_VALUE;\\n        \\n        for(int[] point: points)\\n        {            \\n            if(!hm.containsKey(point[0]))\\n                hm.put(point[0],new HashSet());        \\n            hm.get(point[0]).add(point[1]); "]}
{"id": "1034", "ref_java": ["class Solution {\\n    public int minIncrementForUnique(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }", "class Solution {\\n    public int minIncrementForUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        int prev=-1;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(prev>=nums[i]){\\n                ans=ans+(prev-nums[i]+1);\\n                nums[i]=prev+1;\\n            }", "class Solution {\\n    public static int minIncrementForUnique(int[] nums) {\\n    int l = nums.length;\\n    Arrays.sort(nums);\\n    int steps=0;\\n        for (int i = 1; i <l ; i++) {\\n            if(nums[i]<=nums[i-1])\\n            {\\n\\n                steps+=(nums[i-1]-nums[i])+1;\\n                nums[i]=nums[i-1]+1;\\n\\n            }"]}
{"id": "1035", "ref_java": ["class Solution {\\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\\n        Stack<Integer> st = new Stack<>(); ", "class Solution {\\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\\n        Stack<Integer> stack = new Stack<>();\\n        int j=0;\\n        for(int each : pushed){\\n            stack.push(each);\\n            while(!stack.isEmpty() \\n                    && j<popped.length ", "class Solution {\\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\\n        int j = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < pushed.length; i++) {\\n            if (!stack.isEmpty() && stack.peek() == popped[j]) {\\n                for (int k = j; k < popped.length; k++) {\\n                    if (!stack.isEmpty() && popped[k] == stack.peek()) {\\n                        stack.pop();\\n                        j++;\\n                    }"]}
{"id": "1036", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    static constexpr int K = 10001;\\n    int* ranks;\\n    int* repr;\\n\\n    inline int dsuFind(int x) {\\n        if (x != repr[x]) {\\n            repr[x] = dsuFind(repr[x]);\\n        }", "class Solution {\\n\\n    "]}
{"id": "1037", "ref_java": ["class Solution {\\n    public int bagOfTokensScore(int[] tokens, int power) {\\n        int score = 0,last=tokens.length,ans=0,i=0;\\n        quicksort(tokens,0,last-1);\\n        while(i<last && (power >= tokens[i] || score > 0)){\\n            if(power >= tokens[i]){\\n                power -= tokens[i];\\n                score++;\\n                i++;\\n            }", "class Solution {\\n    public int bagOfTokensScore(int[] tokens, int power) {\\n        Arrays.sort(tokens);\\n        int i=0,j=tokens.length-1,score=0;\\n        while(i<=j)\\n        {\\n            if(power>=tokens[i])\\n            {\\n                power-=tokens[i];\\n                ++score;\\n                ++i;\\n            }", "class Solution {\\n    public int bagOfTokensScore(int[] tokens, int power) {\\n        "]}
{"id": "1038", "ref_java": ["class Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }", "class Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        ", "class Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }"]}
{"id": "1039", "ref_java": ["class Solution {\\n    public int[] deckRevealedIncreasing(int[] arr) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n\\n        int ans[] = new int[n];\\n        ans[0] = arr[0];\\n\\n        int k = 1;\\n        int c = 0;\\n\\n        ", "class Solution {\\n    public int[] deckRevealedIncreasing(int[] deck) {\\n        if(deck.length==1)\\n            return deck;\\n        Arrays.sort(deck);\\n        int res[]=new int[deck.length];\\n        int k=1;\\n        int c=0;\\n        res[0]=deck[0];\\n        while(k<deck.length)\\n        {\\n            for(int i=1;i<deck.length;i++)\\n            {\\n                if(res[i]==0){\\n                    c++;\\n                if(c==2){\\n                    res[i]=deck[k++];\\n                c=0;\\n                \\n            }", "class Solution {\\n    public int[] deckRevealedIncreasing(int[] deck) {\\n        if(deck.length==1)\\n            return deck;\\n        Arrays.sort(deck);\\n        int res[]=new int[deck.length];\\n        int k=1;\\n        int c=0;\\n        res[0]=deck[0];\\n        while(k<deck.length)\\n        {\\n            for(int i=1;i<deck.length;i++)\\n            {\\n                if(res[i]==0){\\n                    c++;\\n                if(c==2){\\n                    res[i]=deck[k++];\\n                c=0;\\n                \\n            }"]}
{"id": "1040", "ref_java": ["class Solution {\\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\\n        \\n        if(root1 == null && root2 == null) return true;\\n        if(root1 == null || root2 == null) return false;\\n        if(root1.val != root2.val) return false;\\n        \\n        if (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) {\\n            return true;\\n        }", "class Solution {\\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\\n        if(root1 == null && root2 == null) return true;\\n        if(root1 == null || root2 == null) return false;\\n        if(root1.val != root2.val) return false;\\n\\n        if(\\n            flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right) ||\\n            flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left)\\n        )\\n            return true;\\n        return false;\\n    }", "class Solution {\\n    \\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\\n        \\n        if(root1 == null && root2 == null) return true;\\n        if(root1 == null || root2 == null) return false;\\n        if(root1.val != root2.val) return false;\\n        \\n        if (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) {\\n            return true;\\n        }"]}
{"id": "1041", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        int [] plus = new int [100011];\\n        int [] minus = new int [100011];\\n        for (int i : arr) {\\n        \\tif (i>=0) {\\n        \\t\\tplus[i]++;\\n        \\t}", "class Solution {\\n    public boolean canReorderDoubled(int[] arr) {\\n        int n = arr.length;\\n        TreeMap<Integer,Integer> map  = new TreeMap<>();\\n        for(int i =0;i<arr.length;i++){\\n            map.put(arr[i],map.getOrDefault(arr[i],0)+1);\\n        }"]}
{"id": "1042", "ref_java": ["class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int cnt=0,j=0;\\n        boolean compared[]=new boolean[strs.length];\\n        for(int i=0;i<strs[0].length();i++){\\n            boolean currCompared[]=new boolean[strs.length];\\n            for(j=0;j<strs.length-1;j++){\\n                if(!compared[j]){ \\n                    if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                        cnt++;\\n                        break;\\n                    }", "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int cnt=0,j=0;\\n        boolean compared[]=new boolean[strs.length];\\n        for(int i=0;i<strs[0].length();i++){\\n            boolean currCompared[]=new boolean[strs.length];\\n            for(j=0;j<strs.length-1;j++){\\n                if(!compared[j]){ \\n                    if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                        cnt++;\\n                        break;\\n                    }", "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n       int n=strs.length;\\n        int count=0;\\n        boolean[] ans=new boolean[n];\\n        for(int i=0;i<strs[0].length();i++){\\n            int j=0;\\n            for(;j<strs.length-1;j++){\\n                if(!ans[j] && strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }"]}
{"id": "1043", "ref_java": ["class Solution {\\n    public int[] prisonAfterNDays(int[] arr, int n) {\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        while (n > 0) {\\n            int[] a = new int[8];\\n            hp.put(Arrays.toString(arr),n--);\\n\\n            for (int i = 1; i < 7; ++i)\\n                if(arr[i-1]==arr[i+1]) a[i] = 1;\\n                else a[i] = 0;\\n                arr = a;\\n                if (hp.containsKey(Arrays.toString(arr))) {\\n                    n %= hp.get(Arrays.toString(arr)) - n;\\n            }", "class Solution {\\n    public int[] prisonAfterNDays(int[] cells, int n) {\\n        n=(n-1)%14+1;\\n        int[] newCells = new int[cells.length];\\n        if (n==0)\\n            return cells;\\n        for (int i=1;i<cells.length-1;i++)\\n            if (cells[i-1]==cells[i+1])\\n                newCells[i]=1;\\n            else\\n                newCells[i]=0;\\n        return prisonAfterNDays(newCells,n-1);\\n    }", "class Solution {\\n    public int[] prisonAfterNDays(int[] cells, int n) {\\n     n=(n-1)%14+1;\\n        int[] newCells = new int[cells.length];\\n        if (n==0)\\n            return cells;\\n        for (int i=1;i<cells.length-1;i++)\\n            if (cells[i-1]==cells[i+1])\\n                newCells[i]=1;\\n            else\\n                newCells[i]=0;\\n        return prisonAfterNDays(newCells,n-1);\\n    }"]}
{"id": "1044", "ref_java": ["class Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            }", "class Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n        return true;\\n        boolean nullfound=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode temp=q.poll();\\n                if(temp==null)\\n                {\\n                    nullfound=true;\\n                }", "class Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null)    return true;\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        q1.offer(root);\\n        boolean check = false;\\n        while(!q1.isEmpty()){\\n            TreeNode current = q1.poll();\\n            if(current == null) check = true;\\n            else{\\n                if(check)   return false;\\n                q1.offer(current.left);\\n                q1.offer(current.right);\\n            }"]}
{"id": "1045", "ref_java": ["class Solution {\\n    static int [] rank;\\n    static int [] p ;\\n    public int regionsBySlashes(String[] grid) {\\n        int n = grid.length;\\n        int m = n+1;\\n        rank = new int[m*m];    \\n        p = new int[m*m];\\n        int ans = 1;\\n        \\n        for(int i=0;i<m*m;i++)\\n        {\\n            p[i]=i;\\n            rank[i]=1;\\n        }", "class Solution {\\n    static int [] rank;\\n    static int [] p ;\\n    public int regionsBySlashes(String[] grid) {\\n        int n = grid.length;\\n        int m = n+1;\\n        rank = new int[m*m];    \\n        p = new int[m*m];\\n        int ans = 1;\\n        \\n        for(int i=0;i<m*m;i++)\\n        {\\n            p[i]=i;\\n            rank[i]=1;\\n        }", "class Solution {\\n    static int [] rank;\\n    static int [] p ;\\n    public int regionsBySlashes(String[] grid) {\\n        int n = grid.length;\\n        int m = n+1;\\n        rank = new int[m*m];    \\n        p = new int[m*m];\\n        int ans = 1;\\n        \\n        for(int i=0;i<m*m;i++)\\n        {\\n            p[i]=i;\\n            rank[i]=1;\\n        }"]}
{"id": "1046", "ref_java": ["class Solution {\\n    public int maxWidthRamp(int[] nums) {\\n        int n = nums.length, top = 0, ans = 0;\\n        int[] stack = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < nums[stack[top]]) {\\n                stack[++top] = i;\\n            }", "class Solution {\\n    public int maxWidthRamp(int[] nums) {\\n        Queue<int[]> queue = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        for(int i=0;i<nums.length;i++) queue.offer(new int[]{i,nums[i]}", "class Solution {\\n    public int maxWidthRamp(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=0; i<nums.length; i++)\\n            if(stack.isEmpty() || nums[i] < nums[stack.peek()])\\n                stack.push(i);\\n       \\n        int ans = 0;\\n        \\n        for(int i=nums.length-1; i>=0; i--)\\n            while(!stack.isEmpty() && nums[i] >= nums[stack.peek()])\\n                ans = Math.max(ans, i - stack.pop());\\n        \\n        return ans;\\n    }"]}
{"id": "1047", "ref_java": ["class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        HashSet<Point> pointsSet = new HashSet<>();\\n        for (int i = 0; i < points.length; i++) {\\n            pointsSet.add(new Point(points[i][0], points[i][1]));\\n        }", "class Solution {\\n\\n    ", "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Set<String> pointSet = new HashSet<>();\\n        for (int[] point : points) {\\n            pointSet.add(point[0] + \",\" + point[1]);\\n        }"]}
{"id": "1048", "ref_java": ["class Solution {\\n\\t\\tstatic final int GAP = \\'a\\' - \\'A\\';\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<Long, String> wordMap = new HashMap<>(wordlist.length << 1), capMap = new HashMap<>(wordlist.length << 1), vowelMap = new HashMap<>(wordlist.length << 1);\\n\\t\\t\\t\\tfor (String word : wordlist) {\\n\\t\\t\\t\\t\\tlong hash = 0, capHash = 0, vowelHash = 0;\\n\\t\\t\\t\\t\\tfor (int i = 0, length = word.length(), c; i < length; ) {\\n\\t\\t\\t\\t\\t\\thash = (hash << 7) | (c = word.charAt(i++));\\n\\t\\t\\t\\t\\t\\tcapHash = (capHash << 7) | (c < \\'a\\' ? c += GAP : c);\\n\\t\\t\\t\\t\\t\\tvowelHash = c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? (vowelHash << 7) : (vowelHash << 7) | c;\\n\\t\\t\\t\\t\\t}", "class Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }", "class Solution {\\n    \\n\\tSet<Character> vowel = Set.of(\\'a\\' , \\'e\\' , \\'i\\' , \\'o\\' , \\'u\\');\\n    \\n    public String convert(String s){ "]}
{"id": "1049", "ref_java": ["class Solution {\\n    List<Integer> res;\\n    public int[] numsSameConsecDiff(int n, int k) {\\n        res = new ArrayList<>();\\n        for(int i=1; i<=9; i++)solve(i,1,n,k);\\n        int len = res.size();\\n        int[] arr  = new int[len];\\n        for(int i=0; i<len; i++)arr[i] = res.get(i);\\n        return arr;\\n    }", "class Solution {\\n    \\n    public int[] numsSameConsecDiff(int n, int k) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 1; i <= 9; i++)\\n        {\\n            dfs(n, k,  ans, 0, i);\\n        }", "class Solution {\\n    \\n    public int[] numsSameConsecDiff(int n, int k) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 1; i <= 9; i++)\\n        {\\n            dfs(n, k,  ans, 0, i);\\n        }"]}
{"id": "1050", "ref_java": ["class Solution {\\n    public List<Integer> pancakeSort(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = arr.length;\\n        int[] indices = new int[n];\\n        for(int i=0; i<n; ++i) indices[arr[i]-1] = i;\\n        for(int i=0; i<n; ++i) {\\n            int pull = indices[i];\\n            dew(stack, i, pull);\\n            indices[arr[i]-1] = pull;\\n            indices[i] = i;\\n            arr[pull] = arr[i];\\n            arr[i] = i+1;\\n        }", "class Solution {\\n    List<Integer> ksequences;\\n    public List<Integer> pancakeSort(int[] arr) {\\n        return new AbstractList<Integer>() {\\n            public Integer get(int index) {\\n                init(); \\n                return ksequences.get(index);\\n            }", "class Solution {\\n    public List<Integer> pancakeSort(int[] arr) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        int end = arr.length;\\n        \\n        while(end!=1) {\\n            int index = findIndex(arr, end);        "]}
{"id": "1051", "ref_java": ["class Solution {\\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\\n        int a = (int)(Math.log(bound)/Math.log(x));\\n        int b = (int)(Math.log(bound)/Math.log(y));\\n\\n        if(a==Integer.MAX_VALUE) a = 0;\\n        if(b==Integer.MAX_VALUE) b = 0;\\n\\n        List<Integer> arr = new ArrayList<>();\\n        HashSet<Integer> hp = new HashSet<>();\\n\\n        for(int i=0; i<=a; i++){\\n            for(int j=0; j<=b; j++){\\n                int k = (int)(Math.pow(x,i)+Math.pow(y,j));\\n                if(k>bound) break;\\n                else{\\n                    hp.add(k);\\n                }", "class Solution {\\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\\n        Set<Integer> ans = new HashSet<>();\\n        for (int xi = 1; xi < bound; xi *= x) {\\n            for (int yj = 1; xi + yj <= bound; yj *= y) {\\n                ans.add(xi + yj);\\n                if (y == 1) break;\\n            }", "class Solution {\\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\\n        Set<Integer> ans = new HashSet<>();\\n        for (int xi = 1; xi < bound; xi *= x) {\\n            for (int yj = 1; xi + yj <= bound; yj *= y) {\\n                ans.add(xi + yj);\\n                if (y == 1) break;\\n            }"]}
{"id": "1052", "ref_java": ["class Solution {\\n    int vix = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    private void dfs(TreeNode node, int[] V) {\\n        if (node == null || (ans.size() != 0 && ans.get(0) == -1)) return;\\n        if (node.val != V[vix++])\\n            ans = new ArrayList<Integer>(Arrays.asList(-1));\\n        else if (node.left != null && node.left.val != V[vix]) {\\n            ans.add(node.val);\\n            dfs(node.right, V);\\n            dfs(node.left, V);\\n        }", "class Solution {\\n    int vix = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    private void dfs(TreeNode node, int[] V) {\\n        if (node == null || (ans.size() != 0 && ans.get(0) == -1)) return;\\n        if (node.val != V[vix++])\\n            ans = new ArrayList<Integer>(Arrays.asList(-1));\\n        else if (node.left != null && node.left.val != V[vix]) {\\n            ans.add(node.val);\\n            dfs(node.right, V);\\n            dfs(node.left, V);\\n        }", "class Solution {\\n    int res=0;\\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {\\n      List<Integer> arr = new ArrayList<Integer>();\\n        return help(root,voyage,arr)?arr : Arrays.asList(-1);\\n            \\n    }"]}
{"id": "1053", "ref_java": ["class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        int ans[][] = new int[k][2];\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        for(int i=0;i<points.length;i++){\\n            int arr[] = new int[2];\\n            arr[0] = i;\\n            arr[1] = (int)Math.pow(points[i][0],2)+(int)Math.pow(points[i][1],2);\\n            q.add(arr);\\n        }", "class Solution {\\n    public int[][] kClosest(int[][] points, int k) {\\n        HashMap<Integer[], Integer> map=new HashMap<>();\\n        for(int i=0; i<points.length; i++){\\n            int p1=points[i][0];\\n            int p2=points[i][1];\\n            int dis = Math.abs((p2*p2)+(p1*p1));\\n            Integer []arr=new Integer[]{p1,p2}", "class Solution {\\n\\n    public class Point implements Comparable<Point> {\\n        int x, y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }"]}
{"id": "1054", "ref_java": ["class Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int sum=0;\\n        int count=0;\\n        map.put(0,1);\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            int temp=0;\\n            if(k!=0){\\n                temp=sum%k;\\n            }", "class Solution {\\n\\n    ", "class Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n      HashMap<Integer,Integer>map=new HashMap<>();\\n      int result=0;\\n      map.put(0,1);\\n      int sum=0,rem=0;\\n      for(int i=0;i<nums.length;i++){\\n          sum+=nums[i];\\n          rem=sum%k;\\n          if(rem<0)\\n          rem+=k;\\n          if(map.containsKey(rem)){\\n              result+=map.get(rem);\\n              map.put(rem,map.get(rem)+1);\\n          }"]}
{"id": "1055", "ref_java": ["class Solution {\\n    public int maxTurbulenceSize(int[] nums) {\\n        int count1Max = 1;\\n        int count2Max = 1;\\n        int count1 = 1;\\n        int count2 = 1;\\n        int flag = 0;\\n        for(int i=1; i<nums.length; i++){\\n            if((flag==0 && nums[i]<nums[i-1]) || (flag==1 && nums[i]>nums[i-1])){\\n                count1++;\\n                count1Max = Math.max(count1Max,count1);\\n            }", "class Solution {\\n    public static int maxTurbulenceSize(int[] arr) {\\n        int k = 1;\\n        int max = 1;\\n        char prev = \\'p\\';\\n        char current = \\'p\\';\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i] < arr[i + 1]) {\\n                current = \\'<\\';\\n            }", "class Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int n = arr.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        \\n        inc[0] = 1;\\n        dec[0] = 1;\\n        int max = 1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            inc[i] = 1;\\n            dec[i] = 1;\\n            \\n            if(arr[i] < arr[i - 1]) {\\n                dec[i] = inc[i - 1] + 1; "]}
{"id": "1056", "ref_java": ["class Solution {\\n    int ans;\\n    public int distributeCoins(TreeNode root) {\\n        ans = 0;\\n        dfs(root);\\n        return ans;\\n    }", "class Solution {\\n    int ans;\\n    public int distributeCoins(TreeNode root) {\\n        ans = 0;\\n        dfs(root);\\n        return ans;\\n    }", "class Solution {\\n    int ans;\\n    public int distributeCoins(TreeNode root) {\\n        ans = 0;\\n        dfs(root);\\n        return ans;\\n    }"]}
{"id": "1058", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        boolean[] isPresent = new boolean[days[days.length-1]+1];\\n        for(int x:days){\\n            isPresent[x]=true;\\n        }", "class Solution {\\n    public static int[] fillnext2(int[] days,int coin){\\n        int[] next2=new int[days.length];\\n        int limit=days[0]+coin;\\n        int idx=0;\\n        for(int i=0;i<days.length;i++){\\n            if(days[i]>=limit){\\n                next2[idx]=i;\\n                idx++;\\n                limit=days[idx]+coin;\\n                i--;\\n            }"]}
{"id": "1059", "ref_java": ["class Solution {\\n    public String strWithout3a3b(int A, int B) {\\n        StringBuilder res = new StringBuilder(A + B);\\n  char a = \\'a\\', b = \\'b\\';\\n  int i = A, j = B;\\n  if (B > A) { a = \\'b\\'; b = \\'a\\'; i = B; j = A; }", "class Solution {\\n    public String strWithout3a3b(int a, int b) {\\n        StringBuilder sb = new StringBuilder();\\n        while (a > 0 || b > 0) {\\n            String s = sb.toString();\\n            ", "class Solution {\\n    public String strWithout3a3b(int A, int B) {\\n        StringBuilder res = new StringBuilder(A + B);\\n  char a = \\'a\\', b = \\'b\\';\\n  int i = A, j = B;\\n  if (B > A) { a = \\'b\\'; b = \\'a\\'; i = B; j = A; }"]}
{"id": "1060", "ref_java": ["class Solution {\\n    ", "class Solution {\\n\\n    public int[] sumEvenAfterQueries(int[] arr, int[][] q) {\\n        int n = q.length;\\n\\n        int sum = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]%2==0) sum=sum+arr[i];\\n        }", "class Solution {\\n    public int[] sumEvenAfterQueries(int[] nums, int[][] q) {\\n        int sum = 0;\\n        for (int n : nums) if (n % 2 == 0) sum += n;\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = q[i][0], idx = q[i][1], initial = nums[idx];\\n            if (initial % 2 == 0) res[i] = (val + initial) % 2 == 0 ? (sum += val) : (sum -= initial);\\n            else res[i] = (val + initial) % 2 == 0 ? (sum += (val + initial)) : sum;\\n            nums[idx] += val;\\n        }"]}
{"id": "1061", "ref_java": ["class Solution {\\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\\n        List<Point> list = new ArrayList<>();\\n        for (int[] p : firstList) {\\n            list.add(new Point(p[0], true));\\n            list.add(new Point(p[1], false));\\n        }", "class Solution {\\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\\n        if(firstList.length==0 || secondList.length==0) return new int[0][0];\\n        int i = 0;\\n        int j = 0;\\n        int startMax = 0, endMin = 0;\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        while(i<firstList.length && j<secondList.length){\\n            startMax = Math.max(firstList[i][0],secondList[j][0]);\\n            endMin = Math.min(firstList[i][1],secondList[j][1]);\\n            \\n\\t\\t\\t", "class Solution {\\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\\n        int i = 0;\\n        int j = 0;\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        while(i<firstList.length && j<secondList.length){\\n            int a[] = firstList[i];\\n            int b[] = secondList[j];\\n            \\n            if(b[0]<=a[1] && b[0]>=a[0])\\n                ans.add(new int[]{b[0], Math.min(a[1], b[1])}"]}
{"id": "1062", "ref_java": ["class Solution {\\n    public String smallestFromLeaf(TreeNode root) {\\n        recur(root, new StringBuilder());\\n        return ans;\\n    }", "class Solution {\\n    String minString = \"\";\\n    public String smallestFromLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return minString;\\n    }", "class Solution {\\n    private String ans=\"\";\\n    public String smallestFromLeaf(TreeNode root) {\\n        dfs(root,new StringBuilder(\"\"));\\n        return  ans;\\n    }"]}
{"id": "1063", "ref_java": ["class Solution {\\n    static int par[];\\n\\n    public static int findPar(int u) {\\n        return par[u] == u ? u : (par[u] = findPar(par[u]));\\n    }", "class Solution {\\n    ", "class Solution {\\n    static int par[];\\n\\n    public static int findPar(int u) {\\n        return par[u] == u ? u : (par[u] = findPar(par[u]));\\n    }"]}
{"id": "1064", "ref_java": ["class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }", "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }", "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        int x=target;\\n        if(x==startValue)\\n        {\\n            return 0;\\n        }"]}
{"id": "1065", "ref_java": ["class Solution {\\n    public int orangesRotting(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = grid;\\n        Queue<int[]> q = new LinkedList<>();\\n        int countFreshOrange = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 2) {\\n                    q.offer(new int[] {i, j}", "class Solution {\\n    ", "class Solution {\\n     int ans=0;\\n    class Pair{\\n        int row;\\n        int col;\\n        int time;\\n        public Pair(int row,int col,int time){\\n            this.row = row;\\n            this.col = col;\\n            this.time = time;\\n        }"]}
{"id": "1066", "ref_java": ["class Solution {\\n    public TreeNode insertIntoMaxTree(TreeNode root, int val){\\n       ", "class Solution {\\n    public TreeNode insertIntoMaxTree(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val < val) return new TreeNode(val, root, null);\\n        root.right = insertIntoMaxTree(root.right, val);\\n        return root;\\n    }", "class Solution {\\n    TreeNode solve(TreeNode root,int val){\\n        if(root == null){\\n            return new TreeNode(val);\\n        }"]}
{"id": "1067", "ref_java": ["class Solution {\\n    public boolean isValid(String s) {\\n        int m=s.length();\\n        Stack<Character> st=new Stack<>();\\n\\n        for(int i=0;i<m;i++){\\n            char ch=s.charAt(i);\\n            if(st.size()==0 && (ch==\\'b\\' || ch==\\'c\\'))\\n            return false;\\n\\n            if(ch==\\'a\\' || ch==\\'b\\')\\n            st.push(ch);\\n\\n            else{\\n                if(st.size()>1){\\n                    char ch1=st.pop();\\n                    char ch2=st.pop();\\n                    if(ch1!=\\'b\\'|| ch2!=\\'a\\')\\n                    return false;\\n                }", "class Solution {\\n    public boolean isValid(String s) {\\n        char[] cs = s.toCharArray();\\n        int i = 0;\\n        for (char c : cs) {\\n            if (c != \\'a\\' && (i == 0 || c != cs[--i] + 1)) {\\n                return false;\\n            }", "class Solution {\\n    public boolean isValid(String str) {\\n\\n        StringBuilder s = new StringBuilder(str);\\n\\n        while(s.length()!=0){\\n            int a = s.indexOf(\"abc\");\\n            if(a==-1) return false;\\n            else{\\n                s.delete(a,a+3);\\n            }"]}
{"id": "1068", "ref_java": ["class Solution {\\n    public int longestOnes(int[] nums, int k) {\\n        int start=0;\\n        int end=0;\\n        int zeros=0;\\n\\n        while(end<nums.length){\\n            if(nums[end] == 0){\\n                zeros++;\\n            }", "class Solution {\\n    public int longestOnes(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        while(i<nums.length){\\n            if(nums[i]==0)\\n            k--;\\n            if(k<0&&nums[j++]==0)\\n            k++;\\n            i++;\\n        }", "class Solution {\\n    public int longestOnes(int[] nums, int k) {\\n        int count = 0;\\n        int n = nums.length;\\n        int right=0;\\n        int left = 0;\\n        int ans = 0;\\n\\n        while(right < n) {\\n            if(nums[right]==0) {\\n                count++;\\n            }"]}
{"id": "1069", "ref_java": ["class Solution {\\n    public int clumsy(int n) {\\n        int ans = 1;\\n        if(n <= 4){\\n            if(n <= 2) return n;\\n            else if(n == 3) return 6;\\n            else if(n == 4) return 7;\\n        }", "class Solution {\\n\\n\\n    public static int calculator(ArrayList<String> arr) {\\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++){\\n            String s = arr.get(i);\\n\\n            if(s.equals(\"*\") || s.equals(\"/\") || s.equals(\"%\")){\\n                int a = Integer.valueOf(arr.remove(i-1));\\n                String op = arr.remove(i-1);\\n                int b = Integer.valueOf(arr.remove(i-1));\\n\\n                if(op.equals(\"*\")) ans = a*b;\\n                else if(op.equals(\"/\")){\\n                    if(b==0){\\n                        System.out.println(\"Can\\'t divide by 0\");\\n                        return -1;\\n                    }", "class Solution {\\n    public int clumsy(int n) {\\n        \\n        int ans=n;\\n        int j=n-1;\\n        boolean t=true;\\n        Stack<Integer>stk=new Stack<>();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i%4==0||i%4==3)"]}
{"id": "1070", "ref_java": ["class Solution {\\n    public int minDominoRotations(int[] A, int[] B) {\\n        int ans = -1;        \\n        for (int val = 1; val <= 6; val++) {\\n            int currAns = helper(A, B, val);\\n            \\n            if (currAns != -1 && (ans == -1 || ans > currAns)) {\\n                ans = currAns;\\n            }", "class Solution {\\n    public int minDominoRotations(int[] A, int[] B) {\\n        int ans = -1;        \\n        for (int val = 1; val <= 6; val++) {\\n            int currAns = helper(A, B, val);\\n            \\n            if (currAns != -1 && (ans == -1 || ans > currAns)) {\\n                ans = currAns;\\n            }", "class Solution {\\n    public int minDominoRotations(int[] tops, int[] bottoms) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<tops.length;i++){\\n            if(tops[i]==bottoms[i]){\\n                hm.put(tops[i],(hm.getOrDefault(tops[i],0)+1));\\n            }"]}
{"id": "1071", "ref_java": ["class Solution {\\n    int index = 0;\\n    public TreeNode findSolution(int[] pre,TreeNode root,int min,int max){  \\n        ", "class Solution {\\n    private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, HashMap<Integer, Integer> map){\\n        ", "class Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructBST(preorder,Integer.MAX_VALUE,new int[]{0}"]}
{"id": "1072", "ref_java": ["class Solution {\\n    public int numPairsDivisibleBy60(int[] arr) {\\n        int n = arr.length;\\n\\n        long count[] = new long[60];\\n\\n        for(int i=0; i<n; i++){\\n            count[arr[i]%60]++;\\n        }", "class Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int[] freq = new int[60];\\n        int res=0;\\n\\n        for(int t: time){\\n            int val = t%60;\\n            if(val==0){\\n                res += freq[0];\\n            }", "class Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int ans = 0, cnt[] = new int[60];\\n        for (int i = 0; i < time.length; i ++) cnt[time[i] % 60] += 1;\\n        for (int i = 1; i< 30; i ++) ans += cnt[i] * cnt[60 - i];\\n        return ans + cnt[0] * (cnt[0] - 1) / 2 + cnt[30] * (cnt[30] - 1) / 2;\\n    }"]}
{"id": "1073", "ref_java": ["class Solution {\\r\\n    public int shipWithinDays(int[] weights, int days) {\\r\\n        int lo = -1, hi = -1, sum = 0;\\r\\n        for (int w : weights){\\r\\n            sum += w;\\r\\n            lo = Math.max(lo, w);\\r\\n        }", "class Solution {\\r\\n    public int shipWithinDays(int[] weights, int days) {\\r\\n        int l=0,r=0;\\r\\n        for(int w : weights){\\r\\n            l = Math.max(w,l);\\r\\n            r += w;\\r\\n        }", "class Solution {\\r\\n    public int shipWithinDays(int[] nums, int k) {\\r\\n         int start = 0;\\r\\n        int end = 0;\\r\\n        \\r\\n        for(int i = 0; i<nums.length; i++){\\r\\n            start = Math.max(start, nums[i]);\\r\\n            end += nums[i]; \\r\\n        }"]}
{"id": "1074", "ref_java": ["class Solution {\\n    public int maxScoreSightseeingPair(int[] values) {\\n        int maxSoFar = 0;\\n        int bestSoFar = values[0] + 0;\\n\\n        for(int j = 1; j < values.length; j++){\\n            maxSoFar = Math.max(maxSoFar, bestSoFar + values[j] - j);\\n            bestSoFar = Math.max(bestSoFar, values[j] + j);\\n        }", "class Solution {\\n    public int maxScoreSightseeingPair(int[] A) {\\n        int i=0;\\n\\t\\tint max = A[i] + i;\\n        for(int j=1;j<A.length;j++){\\n            int curr = A[i] + A[j] + i - j;\\n            max = curr > max ? curr : max;\\n            \\n            if(A[i] + i < A[j] + j){\\n                i=j;\\n            }", "class Solution {\\n    fun maxScoreSightseeingPair(values: IntArray): Int {\\n        var max = Int.MIN_VALUE\\n        var currentOptimal = values[0]\\n\\n        for (i in 1 until values.size) {\\n            currentOptimal = maxOf(currentOptimal-1, values[i-1]-1)\\n            max = maxOf(max, currentOptimal+values[i])\\n        }"]}
{"id": "1075", "ref_java": ["class Solution {\\n    public int smallestRepunitDivByK(int k) {\\n        int prev = 0;\\n\\n        if(k%2==0 || k%5==0) return -1;\\n\\n        for(int i=1; i<=k; i++){\\n            prev = (prev*10+1)%k;\\n            if(prev == 0) return i;\\n        }", "class Solution {\\n    public int smallestRepunitDivByK(int k) {\\n        if (k % 2 == 0 || k % 5 == 0) return -1;\\n        \\n        int phi = get_euler(k * 9);\\n        int res = phi;\\n        for (int i = 1; i <= phi / i; i++) {\\n            if (phi % i == 0) {\\n                if (qmi(10, i, 9 * k) == 1) return i;\\n                if (qmi(10, phi / i, 9 * k) == 1) res = Math.min(res, phi / i);\\n            }", "class Solution {\\n    public int smallestRepunitDivByK(int k) {\\n        "]}
{"id": "1076", "ref_java": ["class Solution {\\n\\n    static String binary(int n){\\n        \\n        StringBuilder s = new StringBuilder(\"\");\\n\\n        while(n>0){\\n            int r = n%2;\\n            s.insert(0,String.valueOf(r));\\n            n=n/2;\\n        }", "class Solution {\\n    public boolean queryString(String s, int n) {\\n        for(int i=1;i<=n;i++){\\n            if(!s.contains(Integer.toBinaryString(i))){\\n                return false;\\n            }", "class Solution {\\n    public boolean queryString(String s, int n) {\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\tif(!s.contains(Integer.toBinaryString(i))) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}"]}
{"id": "1077", "ref_java": ["class Solution {\\n    public String baseNeg2(int n) {\\n        if (n == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n\\n        while (n != 0) {\\n            int remain = n % -2;\\n            n /= -2;\\n            if (remain < 0) {\\n                remain += 2;\\n                n += 1;\\n            }", "class Solution {\\n    public String baseNeg2(int n) {\\n        ", "class Solution {\\n\\n    "]}
{"id": "1078", "ref_java": ["class Solution {\\n    public int[] nextLargerNodes(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<Integer> s = new Stack<Integer>();\\n\\n        ListNode tmp = head;\\n        int size = 0;\\n        while(tmp != null) {\\n            size++;\\n            list.add(tmp.val);\\n            tmp = tmp.next;\\n        }", "class Solution {\\n    public int[] nextLargerNodes(ListNode head) {\\n        Stack<Integer> stack=new Stack<>();\\n        int len = length(head);\\n        int[] ans = new int[len];\\n        ListNode newHead=reverse(head);\\n        for(int i=len-1; i>=0; i--){\\n            while(!stack.isEmpty() && stack.peek()<=newHead.val){\\n                stack.pop();\\n            }", "class Solution {\\n    public int[] nextLargerNodes(ListNode head) {\\n        List<Integer> list=new ArrayList<>();\\n        Stack<Integer> s=new Stack<>();\\n        ListNode curr=head;\\n        int count=0;\\n        while(curr!=null){\\n             count++;\\n             list.add(curr.val);\\n            curr=curr.next;    \\n        }"]}
{"id": "1079", "ref_java": ["class Solution {\\n    public int isIsland(int []ij, int[][] grid)\\n    {\\n        int count = 1;\\n        boolean yes = true;\\n        int [][]moves = new int[][]{{1,0}", "class Solution {\\n    public int isIsland(int []ij, int[][] grid)\\n    {\\n        int count = 1;\\n        boolean yes = true;\\n        int [][]moves = new int[][]{{1,0}", "class Solution {\\n    int row[] = new int[]{1,-1,0,0}"]}
{"id": "1080", "ref_java": ["class Solution {\\n    public List<Boolean> camelMatch(String[] queries, String pattern) {\\n      List<Boolean> list = new ArrayList<>();\\n\\n      for (var q : queries) {\\n         int index = 0;\\n         boolean flag = true;\\n         for (var c : q.toCharArray()) {\\n            if(index < pattern.length() && c == pattern.charAt(index)){\\n               index++;\\n               continue;\\n            }", "class Solution {\\n    public List<Boolean> camelMatch(String[] queries, String pattern) {\\n      List<Boolean> list = new ArrayList<>();\\n\\n      for (var q : queries) {\\n         int index = 0;\\n         boolean flag = true;\\n         for (var c : q.toCharArray()) {\\n            if(index < pattern.length() && c == pattern.charAt(index)){\\n               index++;\\n               continue;\\n            }", "class Solution {\\n    public List<Boolean> camelMatch(String[] queries, String pattern) {\\n      List<Boolean> list = new ArrayList<>();\\n\\n      for (var q : queries) {\\n         int index = 0;\\n         boolean flag = true;\\n         for (var c : q.toCharArray()) {\\n            if(index < pattern.length() && c == pattern.charAt(index)){\\n               index++;\\n               continue;\\n            }"]}
{"id": "1081", "ref_java": ["class Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        int n = clips.length;\\n        int curEnd = 0, farCanReach = 0, total = 0;\\n        int i=0;\\n        while(curEnd < time) {\\n            total++;\\n            while(i<n && curEnd >= clips[i][0]) {\\n                farCanReach = Math.max(farCanReach, clips[i++][1]);\\n            }", "class Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }", "class Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] dp = new int[time+1];\\n\\n        for(int i=0; i<clips.length; i++) {\\n            int left = clips[i][0];\\n            int right = clips[i][1];\\n\\n            if(left > time) left = time;\\n            if(right > time) right = time;\\n\\n            if(right > dp[left]) dp[left] = right;\\n        }"]}
{"id": "1082", "ref_java": ["class Solution {\\n\\n    static int helper(TreeNode root, int min, int max){\\n        if(root==null) return max-min;\\n\\n        max = Math.max(max,root.val);\\n        min = Math.min(min,root.val);\\n\\n        return Math.max(helper(root.left,min,max),helper(root.right,min,max));\\n    }", "class Solution {\\n    int res = 0;\\n    public int maxAncestorDiff(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }", "class Solution {\\n    public int maxAncestorDiff(TreeNode root) {\\n        int max = -1, min = 100001;\\n        return findMaxDiff(root, max, min);\\n    }"]}
{"id": "1083", "ref_java": ["class Solution {\\n    static final int LIMIT = 500;\\n    \\n    public int longestArithSeqLength(int[] nums) {\\n        int maxSeqLen = 2;\\n        int maxNum = nums[0];\\n        int minNum = nums[0];\\n        for (int num : nums) {\\n            if (num > maxNum)  maxNum = num;\\n            if (num < minNum)  minNum = num;\\n        }", "class Solution {\\n    public int longestArithSeqLength(int[] nums) {\\n        int n = nums.length;\\n        if (n <= 2)\\n            return n;\\n\\n        int longest = 2;\\n        Map<Integer, Integer>[] dp = new HashMap[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = new HashMap<>();\\n            for (int j = 0; j < i; j++) {\\n                int diff = nums[i] - nums[j];\\n                dp[i].put(diff, dp[j].getOrDefault(diff, 1) + 1);\\n                longest = Math.max(longest, dp[i].get(diff));\\n            }", "class Solution {\\n    public int longestArithSeqLength(int[] nums) {\\n        "]}
{"id": "1084", "ref_java": ["class Solution {\\n    public int twoCitySchedCost(int[][] costs) {\\n        int[][] arr = new int[costs.length][2];\\n\\n        for(int i = 0; i < costs.length; i++){\\n            arr[i][0] = i;\\n            arr[i][1] = costs[i][0]-costs[i][1];\\n        }", "class Solution {\\n    int memo[][];\\n    public int twoCitySchedCost(int[][] arr) {\\n        memo=new int[arr.length][arr.length];\\n        for(int j[]:memo){\\n                Arrays.fill(j,Integer.MAX_VALUE);\\n            }", "class Solution {\\n    public int twoCitySchedCost(int[][] costs) {\\n        Arrays.sort(costs, (a, b) -> {\\n            return (a[0] - a[1]) - (b[0] - b[1]);\\n        }"]}
{"id": "1085", "ref_java": ["class Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int max1 = getMax(nums,firstLen,secondLen);\\n        int max2 = getMax(nums,secondLen,firstLen);\\n        return Math.max(max1,max2);\\n    }", "class Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        int maxLval = 0;\\n        int ans=0;\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            maxLval = Math.max(maxLval,sums[i]-sums[i-L]);\\n            ans = Math.max(ans,sums[i+M]-sums[i]+maxLval);\\n        }", "class Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n      \\n  "]}
{"id": "1086", "ref_java": ["class Solution {\\n    public int[] numMovesStones(int a, int b, int c) {\\n\\n        int x = Math.min(a,Math.min(b,c));\\n        int y = Math.max(a,Math.max(b,c));\\n        int z=0;\\n\\n        ", "class Solution {\\n    public int[] numMovesStones(int a, int b, int c) {\\n        int x=0,y=0,z=0;\\n        z=Math.max(Math.max(a,b),c);\\n        x=Math.min(Math.min(a,b),c);\\n        y=a+b+c-(z+x);\\n        int max=0,min=0;\\n        max=(y-x)+(z-y)-2;\\n        min=(x+1)==y &&(y+1)==z ? 0:\\n               ((z-y) > 2 && (y-x) > 2 ) ? 2:1;\\nint [] arr={min,max}", "class Solution {\\n    public int[] numMovesStones(int a, int b, int c) {\\n        int[] arr ={a,b,c}"]}
{"id": "1087", "ref_java": ["class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }", "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        ", "class Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        helper(grid, row, col, grid[row][col], color, new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }"]}
{"id": "1088", "ref_java": ["class Solution {\\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\\n        int[] dp = new int[nums2.length+1];\\n        \\n        for(int i = 1; i <= nums1.length; i++) {\\n            int[] dpRow = new int[nums2.length+1];\\n            for(int j = 1; j <= nums2.length; j++) {\\n                if(nums1[i-1] == nums2[j-1]) {\\n                    dpRow[j] = dp[j-1] + 1;\\n                }", "class Solution {\\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\\n        int[][] dp = new int[nums1.length + 1][nums2.length + 1];\\n        ", "class Solution {\\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\\n        "]}
{"id": "1089", "ref_java": ["class Solution {\\n    private int sum = 0;\\n    public TreeNode bstToGst(TreeNode root) {\\n        if (root == null) return null;\\n        bstToGst(root.right);\\n        sum += root.val;\\n        root.val = sum;\\n        bstToGst(root.left);\\n        return root;\\n    }", "class Solution {\\n    private int ans = 0;\\n    public TreeNode bstToGst(TreeNode root) {\\n        if (root != null) {\\n            bstToGst(root.right);\\n            ans += root.val;\\n            root.val = ans;\\n            bstToGst(root.left);\\n        }", "class Solution {\\n    int sum =0;\\n    public TreeNode bstToGst(TreeNode root) {\\n        \\n        reverseInorder(root);\\n        return root;\\n    }"]}
{"id": "1090", "ref_java": ["class Solution {\\n    public int minScoreTriangulation(int[] values) {\\n        int n = values.length;\\n        ", "class Solution {\\n    public int minScoreTriangulation(int[] values) {\\n        int N = values.length;\\n        int[][] dp = new int[N][N];\\n        for(int len=2; len<N; len++){\\n            for(int row=0, col=len; row<N-len; row++, col++){\\n                dp[row][col] = Integer.MAX_VALUE;\\n                for(int k=row+1; k<col; k++){\\n                    dp[row][col] = Math.min(dp[row][col], dp[row][k] + dp[k][col] + values[row]*values[k]*values[col]);\\n                }", "class Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }"]}
{"id": "1091", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int[] numMovesStonesII(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        int i=0, n=stones.length;\\n        int high = Math.max(stones[n-1] - n+2 -stones[1], stones[n-2]-stones[0]- n+2);\\n\\n        int low=n;\\n        for(int j=0; j<n; j++){\\n            while(stones[j]-stones[i] >= n) i++;\\n\\n            if(j-i+1 == n-1 && stones[j]-stones[i]==n-2) low = Math.min(low, 2);\\n            else low = Math.min(low, n-(j-i+1));\\n        }", "class Solution {\\n\\t\\tpublic int[] numMovesStonesII(int[] stones) {\\n\\t\\t\\tint n = stones.length;\\n\\t\\t\\t int[] ans = new int[2];\\n\\t\\t\\t int i = 0, j = 0, wsize, scount, minMoves = Integer.MAX_VALUE;\\n\\t\\t\\tArrays.sort(stones);\\n\\t\\t\\t while (j < n) {\\n\\t\\t\\t\\twsize = stones[j] - stones[i] + 1;\\n\\t\\t\\t\\tscount = j - i + 1;\\n\\n\\t\\t\\t\\tif (wsize > n) {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}"]}
{"id": "1092", "ref_java": ["class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}", "class Solution {\\n    \\n    public boolean isRobotBounded(String instructions) {\\n        if (instructions.length() == 0)\\n            return false;\\n        int x = 0;\\n        int y = 0;  ", "class Solution {\\n    public boolean isRobotBounded(String I) {\\n        int[][] d = {{1, 0}"]}
{"id": "1093", "ref_java": ["class Solution {\\n    public int[] gardenNoAdj(int N, int[][] paths) {\\n        \\n        \\n        Garden[] graph = new Garden[N];", "class Solution {\\n    public int[] gardenNoAdj(int N, int[][] paths) {\\n        \\n        \\n        Garden[] graph = new Garden[N];", "class Solution {\\n    public int[] gardenNoAdj(int N, int[][] paths) {\\n        \\n        \\n        Garden[] graph = new Garden[N];"]}
{"id": "1094", "ref_java": ["class Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length; ", "class Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp, -1);\\n        return helper(arr, 0, k, dp);\\n    }", "class Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }"]}
{"id": "1096", "ref_java": ["class Solution {\\n    static final int LONGEST_WORD_LEN = 16;\\n    \\n    public int longestStrChain(String[] words) {\\n        ", "class Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b)-> a.length() - b.length());\\n        HashMap<String, Integer> chainLen = new HashMap<>();\\n        int maxLen = 0;\\n        for (var word : words) {\\n            for (int indx = 0; indx < word.length(); indx++) {\\n                String pred = word.substring(0, indx) + word.substring(indx + 1);\\n                chainLen.put(word, Math.max(chainLen.getOrDefault(word, 0), (!chainLen.containsKey(pred)) ? 1 : chainLen.get(pred) + 1));\\n            }", "class Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }"]}
{"id": "1097", "ref_java": ["class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int n = stones.length;\\n        int sum = 0;\\n        for (int stone : stones) {\\n            sum += stone;\\n        }", "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int S=0;\\n        for(int i: stones)\\n            S+=i;\\n        int S2=0;\\n        int n=stones.length;\\n        ", "class Solution {\\n    public int lastStoneWeightII(int[] stones) {\\n        int sumStWt = 0;\\n        for(int stone : stones){\\n            sumStWt += stone;\\n        }"]}
{"id": "1098", "ref_java": ["class Solution {\\n    public static int maxWhenGrumpy(int[] cust, int[] g, int k) {\\n        int maxi = 0, i = 0, sum = 0, j = 0, n = cust.length;\\n        while (i < k) {\\n            if (g[i] == 1)\\n                sum += cust[i];\\n            i++;\\n        }", "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n        int i=0,j=0,curSum=0,totalSum=0,gSum=0,max=-1;\\n        for(int k=0;k<customers.length;k++){               ", "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n      int satisfied = 0;\\n      "]}
{"id": "1099", "ref_java": ["class Solution {\\n    public int[] prevPermOpt1(int[] arr) {\\n        \\n        int i=arr.length-2;\\n        int lastElem=arr[arr.length-1];\\n          \\n        while(i>=0 && arr[i]<=arr[i+1]) {\\n            i--; \\n        }", "class Solution {\\n    public int[] prevPermOpt1(int[] arr) {\\n        \\n        int i=arr.length-2;\\n        int lastElem=arr[arr.length-1];\\n          \\n        while(i>=0 && arr[i]<=arr[i+1]) {\\n            i--; \\n        }", "class Solution {\\n    public int[] prevPermOpt1(int[] A) {\\n        int i = A.length - 2, max_ = -1;\\n        while(i >= 0 && A[i] <= A[i+1])\\n            --i;\\n        if(i >= 0){\\n\\t\\t\\tmax_ = i + 1;\\n\\t\\t\\tfor(int j=max_ + 1; j < A.length; ++j)\\n\\t\\t\\t\\tif(A[max_] < A[j] && A[j] < A[i])\\n\\t\\t\\t\\t\\tmax_ = j;\\n\\t\\t\\tint temp = A[max_];\\n\\t\\t\\tA[max_] = A[i];\\n\\t\\t\\tA[i] = temp;\\n\\t\\t}"]}
{"id": "1100", "ref_java": ["class Solution {\\n    class Bar {\\n        int barcode;\\n        int freq;\\n        Bar(int barcode, int freq) {\\n            this.barcode = barcode;\\n            this.freq = freq;\\n        }", "class Solution {\\n    class Bar {\\n        int barcode;\\n        int freq;\\n        Bar(int barcode, int freq) {\\n            this.barcode = barcode;\\n            this.freq = freq;\\n        }", "class Solution {\\n    public int[] rearrangeBarcodes(int[] barcodes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int barcode : barcodes) {\\n            map.put(barcode, map.getOrDefault(barcode,0)+1);\\n        }"]}
{"id": "1101", "ref_java": ["class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        int n = s1.length();\\n        DisjointSet ds = new DisjointSet(26);\\n        for(int i=0;i<n;i++){\\n            ds.unionBySize(s1.charAt(i)-\\'a\\',s2.charAt(i)-\\'a\\');\\n        }", "class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) \\n    {\\n        int len = s1.length();\\n        List<Set<Character>> set = new ArrayList<>();\\n        int currSet = 1;\\n        int[] sets = new int[26];\\n        for(int i=0; i<len; i++)\\n        {\\n            ", "class Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) \\n    {\\n        int len = s1.length();\\n        List<Set<Character>> set = new ArrayList<>();\\n        int currSet = 1;\\n        int[] sets = new int[26];\\n        for(int i=0; i<len; i++)\\n        {\\n            "]}
{"id": "1103", "ref_java": ["class Solution {\\n    class Trie {\\n        Trie left, right;\\n        int cnt;\\n    }", "class Solution {\\n    public int maxEqualRowsAfterFlips(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        for(int i = 0; i < m; i++) {\\n            if(matrix[i][0] == 0) flip(matrix[i],n);\\n        }", "class Solution {\\n    public int maxEqualRowsAfterFlips(int[][] matrix) {\\n        int ans=0;\\n\\n        "]}
{"id": "1104", "ref_java": ["class Solution {\\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = arr1.length;\\n        int m = arr2.length;\\n        int carry = 0;\\n        int i = n - 1, j = m - 1;\\n        while(i >= 0 && j >= 0) {\\n            int val = arr1[i] + arr2[j] + carry; ", "class Solution {\\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = arr1.length;\\n        int m = arr2.length;\\n        int carry = 0;\\n        int i = n - 1, j = m - 1;\\n        while(i >= 0 && j >= 0) {\\n            int val = arr1[i] + arr2[j] + carry; ", "class Solution {\\n\\n    "]}
{"id": "1105", "ref_java": ["class Solution {\\n    public int numTilePossibilities(String tiles) {\\n        HashSet<String> hs = new HashSet<>();\\n        int len = tiles.length();\\n        boolean[] vis = new boolean[len];\\n        helper(\"\",hs,vis,tiles,len);\\n        return hs.size()-1;\\n    }", "class Solution {\\n    public int numTilePossibilities(String tiles) {\\n        Set<String> set = new HashSet<>();\\n        boolean[] vis = new boolean[tiles.length()];\\n        permute(tiles, \"\", set, vis);\\n        return set.size()-1;\\n    }", "class Solution {\\n    public int numTilePossibilities(String tiles) {\\n        HashSet<String> hs = new HashSet<>();\\n        int len = tiles.length();\\n        boolean[] vis = new boolean[len];\\n        helper(\"\",hs,vis,tiles,len);\\n        return hs.size()-1;\\n    }"]}
{"id": "1106", "ref_java": ["class Solution {\\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\\n        if(root == null)\\n            return root;\\n\\n        if(root.left == null && root.right == null)\\n            return root.val < limit ? null : root;\\n\\n        root.left = sufficientSubset(root.left, limit - root.val);\\n        root.right = sufficientSubset(root.right, limit - root.val);\\n\\n        return root.left == root.right ? null : root;\\n    }", "class Solution {\\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\\n        if(root==null) return null;\\n        if(root.left==null && root.right==null) return root.val<limit? null: root;\\n        root.left = sufficientSubset(root.left,limit-root.val);\\n        root.right = sufficientSubset(root.right,limit-root.val);\\n        return root.left==root.right? null: root;\\n    }", "class Solution {\\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\\n        if(root==null) return null;\\n        if(root.left==null && root.right==null) return root.val<limit? null: root;\\n        root.left = sufficientSubset(root.left,limit-root.val);\\n        root.right = sufficientSubset(root.right,limit-root.val);\\n        return root.left==root.right? null: root;\\n    }"]}
{"id": "1107", "ref_java": ["class Solution {\\n    public String smallestSubsequence(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0) + 1);\\n        }", "class Solution {\\n    public String smallestSubsequence(String s) {\\n        int [] lastIndex=new int[26];\\n        for(int i=0;i<s.length();i++)\\n            lastIndex[s.charAt(i)-\\'a\\'] = i;\\n            boolean [] seen=new boolean[26];\\n            Stack<Integer> st=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int c=s.charAt(i) - \\'a\\';\\n            \\n            if(seen[c]) continue;\\n            \\n            while(!st.isEmpty() && st.peek()>c && i < lastIndex[st.peek()])\\n            {\\n                seen[st.pop()] = false;\\n            }", "class Solution {\\n    public String smallestSubsequence(String s) {\\n        int n = s.length();\\n        boolean[] visited = new boolean[26];\\n        int[] lastIndex = new int[26];\\n\\n        for (int i = 0; i < n; i++) {\\n            lastIndex[s.charAt(i) - \\'a\\'] = i;\\n        }"]}
{"id": "1108", "ref_java": ["class Solution {\\n\\n    class Pair{\\n        int num;\\n        int label;\\n        Pair(int num, int label){\\n            this.num = num;\\n            this.label = label;\\n        }", "class Solution {\\n    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {\\n\\n        HashMap<Integer,Integer> track = new HashMap<>(); ", "class Solution {\\n    \\n\\tpublic class Pair implements Comparable<Pair>{\\n        int v, l;\\n        \\n        Pair(int v, int l){\\n            this.v = v;\\n            this.l = l;\\n        }"]}
{"id": "1109", "ref_java": ["class Solution {\\n    \\n    class Vertex {\\n        int row;\\n        int col;\\n        int lenSoFar;\\n\\n        Vertex(int row, int col, int lenSoFar) {\\n            this.row = row;\\n            this.col = col;\\n            this.lenSoFar = lenSoFar;\\n        }", "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n     int n = grid.length;\\n     int m = grid[0].length;\\n     if(grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\\n     if(n-1 == 0) return 1;\\n     int[][] dis = new int[n][m];\\n     Queue<tuple> queue = new LinkedList<>();\\n     for(int[] i:dis){\\n         Arrays.fill(i,(int)1e9);\\n     }", "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] != 0) return -1;\\n        int m = grid.length, n = grid[0].length;\\n        if (grid[0][0] == 0 && m == 1 && n == 1) return 1;\\n        boolean[][] vis = new boolean[m][n];\\n        int[] dx = {-1, 1, 0, 0, -1, -1, 1, 1}"]}
{"id": "1110", "ref_java": ["class Solution {\\n    public double[] sampleStats(int[] count) {\\n        int modeKey = 0, maxModeValue = -1;\\n        long totalSum = 0;\\n        int numberOfElements = 0;\\n        double min = -1;\\n        double max = 0;\\n        for (int i = 0; i < count.length; i++) {\\n            if (count[i] != 0) {\\n                if (min == -1) {\\n                    min = i;\\n                }", "class Solution {\\n    int n;\\n    int totalCount;\\n    public double[] sampleStats(int[] count) {\\n        n = count.length;\\n        totalCount = 0;\\n        double[] ans = new double[]{min(count), max(count), mean(count), median(count), mode(count)}", "class Solution {\\n    public double[] sampleStats(int[] count) {\\n        double min = Double.MAX_VALUE, max =Double.MIN_VALUE, mean, median, mode = 0.0;\\n        long sum = 0l;\\n        int c = 0;\\n        for(int i=0; i<count.length; i++)\\n        {\\n            if(count[i] == 0)\\n                continue;\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n            if(count[(int)mode] < count[i])\\n                mode = i;\\n            sum += (long)i * count[i];\\n            c += count[i];\\n        }"]}
{"id": "1111", "ref_java": ["class Solution {\\n    public boolean carPooling(int[][] trips, int capacity) {\\n        ", "class Solution {\\n    public boolean carPooling(int[][] trips, int capacity) {\\n        int in_car = 0;\\n        int[] increase = new int[1001];\\n        for (int i = 0; i < trips.length; i ++) { ", "class Solution {\\n    public boolean carPooling(int[][] trips, int capacity) {\\n        "]}
{"id": "1112", "ref_java": ["class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n\\n        int temp = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0; i<temp; i++){\\n            int num = (int)Math.pow(2, (int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = num - (int)label/2 + (num+1)/2;\\n            ans.add(0, label);\\n        }", "class Solution {\\n\\n     ", "class Solution {\\n    public List<Integer> pathInZigZagTree(int label) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(label);\\n        int xx = (int)(Math.log(label)/Math.log(2));\\n        for(int i=0;i<xx;i++)\\n        {\\n            int x = (int)Math.pow(2,(int)(Math.log((int)label/2)/Math.log(2))+1)-1;\\n            label = x - (int)label/2 + (x+1)/2 ;\\n            ans.add(0,label);\\n        }"]}
{"id": "1113", "ref_java": ["class Solution {\\n    int ans = Integer.MAX_VALUE;\\n\\n    public int recur(int idx, int currWidth, int height, int[][] books, int shelfWidth, Integer[][] memo) {\\n        if(idx == books.length) return height;\\n\\n        if(memo[idx][currWidth] != null) return memo[idx][currWidth];\\n\\n        int inThisRow = Integer.MAX_VALUE;\\n        int inNextRow = Integer.MAX_VALUE;\\n        if(currWidth + books[idx][0] <= shelfWidth) {\\n            inThisRow = recur(idx +1, currWidth + books[idx][0], Math.max(height, books[idx][1]), books, shelfWidth, memo);\\n        }", "class Solution {\\n    class State implements Cloneable, Comparable<State> {\\n        int height;\\n        int lastHeight;\\n        int restWidth;\\n        int shelfWidth;\\n        State(int sw){\\n            height = 0;\\n            lastHeight = 0;\\n            restWidth = 0;\\n            shelfWidth = sw;\\n        }", "class Solution {\\n    public int minHeightShelves(int[][] books, int shelfWidth) {\\n        int dp[]=new int[books.length+1];\\n        dp[0]=0;\\n        for(int i=1;i<=books.length;i++){\\n            int min=dp[i-1]+books[i-1][1];\\n            int height=books[i-1][1];\\n            int width=books[i-1][0];\\n            int j=i-2;\\n            while(j>=0 && width+books[j][0]<=shelfWidth){\\n                width+=books[j][0];\\n                height=Math.max(height,books[j][1]);\\n                min=Math.min(min,height+dp[j]);\\n                --j;\\n            }"]}
{"id": "1114", "ref_java": ["class Solution {\\n    public int[] corpFlightBookings(int[][] b, int n) {\\n        int[] ans = new int[n];\\n        for(int i=0;i<b.length;i++){\\n            ", "class Solution {\\n    public int[] corpFlightBookings(int[][] bookings, int n) {\\n        \\n        int[] res = new int[n];\\n        for(int[] curr : bookings){\\n            int start = curr[0]-1;\\n            int end = curr[1];\\n            int val = curr[2];\\n            \\n            for(int i = start ; i < end ; i++){\\n                res[i] += val;\\n            }", "class Solution {\\n    public int[] corpFlightBookings(int[][] bookings, int n) {\\n        int[] ans = new int[n];\\n        for (int[] booking : bookings) {\\n            int i = booking[0]-1;\\n            int j = booking[1];\\n            int seats = booking[2];\\n            ans[i] += seats;\\n            if (j != n)\\n                ans[j] -= seats;\\n        }"]}
{"id": "1115", "ref_java": ["class Solution {\\n    public static ArrayList<TreeNode> preorder(TreeNode root, HashSet<Integer> set, ArrayList<TreeNode> list, TreeNode parent){\\n        if(root == null) return list;\\n        ", "class Solution {\\n    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {\\n        List<TreeNode> ans = new LinkedList<>();\\n\\n        Set<Integer> toDelete = new HashSet<>();\\n        for(int val : to_delete)toDelete.add(val);\\n  \\n        TreeNode result = getTheRoot(root, toDelete, ans);\\n        if (result != null) {\\n            ans.add(result);\\n        }", "class Solution {\\n    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {\\n        List<TreeNode> list = new ArrayList<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < to_delete.length; i++) {\\n            set.add(to_delete[i]);\\n        }"]}
{"id": "1116", "ref_java": ["class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }", "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] a = new int[seq.length()];\\n        \\n        int count = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n                a[i] = count++ % 2;\\n            }", "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int count=0;\\n        int []output=new int[seq.length()];\\n        Stack<Character> stack=new Stack<Character>();\\n        for(int i=0;i<seq.length();i++){\\n            if(seq.charAt(i)==\\')\\' && !stack.isEmpty()){\\n                if(stack.peek()==\\'(\\'){\\n                    stack.pop();\\n                    output[i]=stack.size()%2;\\n                }"]}
{"id": "1120", "ref_java": ["class Solution {\\n    public TreeNode lcaDeepestLeaves(TreeNode root) {\\n        int d = deep(root);\\n        map = new HashMap<>();\\n        dfs(root,1,d);\\n        ans1 = null;\\n        go(root);\\n        return ans1;\\n    }", "class Solution {\\n    public TreeNode lcaDeepestLeaves(TreeNode root) {\\n        if(root==null)return null;\\n        int lh=height(root.left);\\n        int rh=height(root.right);\\n        if(lh==rh)return root;\\n        else if(lh>rh)return lcaDeepestLeaves(root.left);\\n        else return lcaDeepestLeaves(root.right);\\n    }", "class Solution {\\n    private TreeNode lca(TreeNode root,int n1,int n2){\\n        if(root == null)\\n            return root;\\n        if(root.val==n1 || root.val ==n2)\\n            return root;\\n        TreeNode left = lca(root.left,n1,n2);\\n        TreeNode right = lca(root.right,n1,n2);\\n        if(left!=null && right!=null)\\n            return root;\\n        return left==null?right:left;\\n    }"]}
{"id": "1121", "ref_java": ["class Solution {\\n    public int longestWPI(int[] hours) {\\n        if (hours.length == 0) return 0;\\n        int maxLen = 0;\\n        Map<Integer, Integer> map = new HashMap();  ", "class Solution {\\n    public int longestWPI(int[] hours) {\\n        HashMap<Integer,Integer> helper = new HashMap<Integer,Integer>();\\n        int sum = 0,ans=0;\\n        for(int i = 0;i<hours.length;i++){\\n            sum+=(hours[i]>8)?1:-1;\\n            if(sum>0){\\n                ans = i+1;\\n            }", "class Solution {\\n    public int longestWPI(int[] hours) {\\n        if (hours == null || hours.length == 0) {\\n            return 0;\\n        }"]}
{"id": "1122", "ref_java": ["class Solution {\\n    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\\n         List<List<Integer>> l1 = new ArrayList<>();\\n         List<List<Integer>> l2 = new ArrayList<>();\\n         int[] ans = new int[n];\\n         Arrays.fill(ans,-1);\\n         for(int i = 0;i<n;i++){\\n             l1.add(new ArrayList<Integer>());\\n             l2.add(new ArrayList<Integer>());\\n         }", "class Solution {\\n    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\\n\\n        ArrayList<ArrayList<Integer>>adjRed=new ArrayList<>();\\n        ArrayList<ArrayList<Integer>>adjBlue=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adjRed.add(new ArrayList<>());\\n            adjBlue.add(new ArrayList<>());\\n        }", "class Solution {\\n    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\\n        Map<Integer, List<Integer>> red = new HashMap<>();\\n        Map<Integer, List<Integer>> blue = new HashMap<>();\\n\\n        for (int[] edge : redEdges) {\\n            red.computeIfAbsent(edge[0], x -> new ArrayList<>()).add(edge[1]);\\n        }"]}
{"id": "1123", "ref_java": ["class Solution {\\n    \\n    int[][] tempResult;\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length-1;\\n        tempResult= new int[n+1][n+1];\\n        return getMin(arr, 0, n);\\n    }", "class Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        ", "class Solution {\\n    \\n    int[][] tempResult;\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length-1;\\n        tempResult= new int[n+1][n+1];\\n        return getMin(arr, 0, n);\\n    }"]}
{"id": "1124", "ref_java": ["class Solution {\\n    public int maxAbsValExpr(int[] arr1, int[] arr2) {\\n        if(arr1.length != arr2.length)\\n            return 0;\\n        int max1 = Integer.MIN_VALUE;\\n        int max2 = Integer.MIN_VALUE;\\n        int max3 = Integer.MIN_VALUE;\\n        int max4 = Integer.MIN_VALUE;\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        int min3 = Integer.MAX_VALUE;\\n        int min4 = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < arr1.length; i++) {\\n            max1 = Math.max(arr1[i] + arr2[i] + i, max1);\\n            min1 = Math.min(arr1[i] + arr2[i] + i, min1);\\n            max2 = Math.max(i - arr1[i] - arr2[i], max2);\\n            min2 = Math.min(i - arr1[i] - arr2[i], min2);\\n            max3 = Math.max(arr1[i] - arr2[i] + i, max3);\\n            min3 = Math.min(arr1[i] - arr2[i] + i, min3);\\n            max4 = Math.max(arr2[i] - arr1[i] + i, max4);\\n            min4 = Math.min(arr2[i] - arr1[i] + i, min4);\\n        }", "class Solution {\\n    public int maxAbsValExpr(int[] arr1, int[] arr2) {\\n        \\n        ", "class Solution {\\n\\n    "]}
{"id": "1125", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c}", "class Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}"]}
{"id": "1126", "ref_java": ["class Solution {\\n\\n    class Summation implements Comparable<Summation> {\\n        int sum;\\n        int i;\\n        public Summation(int sum, int i) {\\n            this.sum = sum;\\n            this.i = i;\\n            ", "class Solution {\\n    public int largest1BorderedSquare(int[][] grid) {\\n        if (grid == null || grid.length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] dp = new int[m + 1][n + 1][2];\\n        int max = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    dp[i + 1][j + 1][0] = dp[i][j + 1][0] + 1;\\n                    dp[i + 1][j + 1][1] = dp[i + 1][j][1] + 1;\\n\\n                    int len = Math.min(dp[i + 1][j + 1][0], dp[i + 1][j + 1][1]);\\n                    for (int k = len; k > max; k--) {\\n                        int len1 = Math.min(dp[i + 1 - k + 1][j + 1][1], dp[i + 1][j + 1 - k + 1][0]);\\n                        if (len1 >= k) {\\n                            max = Math.max(max, k);\\n                        }", "class Solution {\\n    public int largest1BorderedSquare(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] row = new int[m][n], col = new int[m][n];\\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    row[i][j] = j >= 1 ? row[i][j - 1] + 1 : 1;\\n                    col[i][j] = i >= 1 ? col[i - 1][j] + 1 : 1;\\n                }"]}
{"id": "1127", "ref_java": ["class Solution {\\n    int[] piles;\\n    \\n    public int stoneGameII(int[] piles) {\\n        this.piles = piles;\\n        return dfs(0, 0, 1);\\n    }", "class Solution {\\n    public int helper(int[] piles, int[][] dp, int[] suffixSum, int i, int M) {\\n        if (i == piles.length) return 0;\\n        if (i + 2 * M >= piles.length) return suffixSum[i];\\n\\n        if (dp[i][M] != 0) return dp[i][M];\\n\\n        int result = 0;\\n        for (int x = 1; x <= 2 * M; ++x) {\\n            result = Math.max(result, suffixSum[i] - helper(piles, dp, suffixSum, i + x, Math.max(M, x)));\\n        }", "class Solution {\\n    public int stoneGameII(int[] piles) {\\n        int n = piles.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[n - 1] = piles[n - 1];\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            prefixSum[i] = prefixSum[i + 1] + piles[i];\\n        }"]}
{"id": "1128", "ref_java": ["class Solution {\\n\\n\\t", "class Solution {\\n    public int longestCommonSubsequence(String text1, String text2) {\\n        \\n        int n1=text1.length(),n2=text2.length();\\n        int[][] dp = new int[n1+1][n2+1];\\n\\n        for(int i1=1;i1<=n1;i1++){\\n            for(int i2=1;i2<=n2;i2++){\\n                int pick = 0,notpick=0;\\n                if(text1.charAt(i1-1)==text2.charAt(i2-1))\\n                    pick = 1 + dp[i1-1][i2-1];\\n\\n                notpick = Math.max(dp[i1-1][i2],dp[i1][i2-1]);\\n\\n                dp[i1][i2] = Math.max(pick,notpick);\\n            }", "class Solution {\\n    public int longestCommonSubsequence(String text1, String text2) {\\n        int[][] dp = new int[text1.length()][text2.length()];\\n        for(int[] arr : dp) Arrays.fill(arr, -1);\\n        return helper(text1, text2, text1.length() - 1, text2.length() - 1, dp);\\n    }"]}
{"id": "1129", "ref_java": ["class Solution {\\n    \\n\\t", "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int oddIndexChange = 0, evenIndexChange = 0;\\n        int n = nums.length;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i-1 >= 0 && nums[i] >= nums[i-1] ||\\n                i+1 < n && nums[i] >= nums[i+1]) {\\n                    int min = Integer.MAX_VALUE;\\n                    if (i+1 < n)\\n                        min = Math.min(nums[i+1],min);\\n                    if (i-1 >= 0)\\n                        min = Math.min(nums[i-1],min);\\n                    int cost = nums[i]-min+1;\\n                    if (i%2 == 0)\\n                        evenIndexChange += cost;\\n                    else \\n                        oddIndexChange += cost;\\n            }", "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n        if(nums.length == 1){ return 0; }"]}
{"id": "1130", "ref_java": ["class Solution {\\n    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {\\n        TreeNode[] red = new TreeNode[1];\\n        findNode(root, x, red);\\n        int[] countLeft = new int[1], countRight = new int[1];\\n        countNodes(red[0].left, countLeft);\\n        countNodes(red[0].right, countRight);\\n\\n        int l = countLeft[0], r = countRight[0];\\n\\n        return l > n - l || r > n - r || l + r + 1 < n - l - r - 1;      \\n    }", "class Solution {\\n    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {\\n        TreeNode[] red = new TreeNode[1];\\n        findNode(root, x, red);\\n        int[] countLeft = new int[1], countRight = new int[1];\\n        countNodes(red[0].left, countLeft);\\n        countNodes(red[0].right, countRight);\\n\\n        int l = countLeft[0], r = countRight[0];\\n\\n        return l > n - l || r > n - r || l + r + 1 < n - l - r - 1;      \\n    }", "class Solution {\\n    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {\\n        TreeNode[] red = new TreeNode[1];\\n        findNode(root, x, red);\\n        int[] countLeft = new int[1], countRight = new int[1];\\n        countNodes(red[0].left, countLeft);\\n        countNodes(red[0].right, countRight);\\n\\n        int l = countLeft[0], r = countRight[0];\\n\\n        return l > n - l || r > n - r || l + r + 1 < n - l - r - 1;      \\n    }"]}
{"id": "1132", "ref_java": ["class Solution {\\n    int mod=1000000007;\\n    ", "class Solution {\\n    public int numRollsToTarget(int n, int k, int target) {\\n        int dp[][]=new int[n+1][target+1];\\n        for (int i=0;i<=n;i++) Arrays.fill(dp[i], -1);\\n        return nRt(n, k, target, dp);        \\n    }", "class Solution {\\n    int mod=1000000007;\\n    "]}
{"id": "1133", "ref_java": ["class Solution {\\n\\t\\t\\tpublic int maxRepOpt1(String s) {\\n\\t\\t\\t   int[] count = new int[26];\\n\\t\\t\\t   int[] left = new int[s.length()];\\n\\t\\t\\t   int[] right = new int[s.length()];\\n\\t\\t\\t\\tint max =0;\\n\\t\\t\\t\\t", "class Solution {\\n    public int maxRepOpt1(String text) {\\n        int n= text.length(), ans = 0;\\n        int [] dp = new int [26];\\n        for (int i = 0; i < n; i++)\\n            dp[text.charAt(i) - \\'a\\']++;\\n            \\n        for (int i = 0; i < 26; i++)\\n            if (dp[i] > 0)\\n                ans = Math.max(ans, findMax(text, (char) (i + \\'a\\'), dp[i]));\\n        return ans;\\n    }", "class Solution {\\n\\nstatic char a[]={\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'}"]}
{"id": "1135", "ref_java": ["class Solution {\\n    public int maxLevelSum(TreeNode root) {\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        int level = 0;\\n        List<Integer> sumArr = new ArrayList<>();\\n        sumArr.add(root.val);\\n        sumOfLevel(queue, sumArr,level + 1);\\n        int result = -1;\\n        int sum = Integer.MIN_VALUE;\\n        for (int i = 0; i < sumArr.size(); i++) {\\n            if (sumArr.get(i) > sum) {\\n                sum = sumArr.get(i);\\n                result = i;\\n            }", "class Solution {\\n    int  mxSum=Integer.MIN_VALUE;\\n    int minLevel=1;\\n    public int maxLevelSum(TreeNode root) {\\n     int level=1; \\n     Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n     queue.offer(root);\\n     while(queue.size()>0){\\n         int size=queue.size();\\n         int sum=0;\\n         while(size-->0){\\n             TreeNode node=queue.remove();\\n             sum+=node.val;\\n             if(node.left!=null)\\n             queue.offer(node.left);\\n             if(node.right!=null)\\n             queue.offer(node.right);\\n         }", "class Solution {\\n    public int maxLevelSum(TreeNode root) {\\n        int result = 1, level = 1, max = root.val;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n\\n        queue.offer(root);\\n\\n        while(!queue.isEmpty()) {\\n            int size = queue.size(), sum = 0;\\n\\n            for(int i = 0; i < size; ++i) {\\n                TreeNode node = queue.poll();\\n                sum += node.val;\\n\\n                if(node.left != null)\\n                    queue.offer(node.left);\\n                if(node.right != null)\\n                    queue.offer(node.right);\\n            }"]}
{"id": "1136", "ref_java": ["class Solution {\\n    public int MaxDistance(int[][] arr) {\\n        int length=arr.Length;\\n        int[,] dp = new int[length, length];\\n        for(int i=0; i< length; i++){\\n            for(int j=0; j< length; j++){\\n                dp[i,j] = (arr[i][j] == 1)? 0 : int.MaxValue;\\n            }", "class Solution {\\n    public int MaxDistance(int[][] arr) {\\n        int length=arr.Length;\\n        int[,] dp = new int[length, length];\\n        for(int i=0; i< length; i++){\\n            for(int j=0; j< length; j++){\\n                dp[i,j] = (arr[i][j] == 1)? 0 : int.MaxValue;\\n            }", "class Solution {\\n    public int maxDistance(int[][] arr) {\\n    Queue<int[]> q=new LinkedList<>();\\n    for(int i=0;i<arr.length;i++)\\n    {\\n        for(int j=0;j<arr.length;j++)\\n        {\\n            if(arr[i][j]==1)\\n            {\\n                int idx[]=new int[2];\\n                idx[0]=i;\\n                idx[1]=j;\\n                q.offer(idx);\\n            }"]}
{"id": "1138", "ref_java": ["class Solution {\\n\\t", "class Solution {\\n    class Transaction{\\n        String name;\\n        int time;\\n        int amount;\\n        String city;\\n        public Transaction(String name, int time, int amount, String city){\\n            this.name = name;\\n            this.time = time;\\n            this.amount = amount;\\n            this.city = city;\\n        }", "class Solution {\\n    public class Transaction {\\n        String name;\\n        int time;\\n        String city;\\n        String trans;\\n        \\n        public Transaction(String name, int time, String city, String trans) {\\n            this.name = name;\\n            this.time = time;\\n            this.city = city;\\n            this.trans = trans;\\n        }"]}
{"id": "1139", "ref_java": ["class Solution {\\n    public int[] numSmallerByFrequency(String[] queries, String[] words) {\\n        int[] res = new int[queries.length];\\n        int j =0;\\n        for(String query : queries){\\n            int val = 0;\\n            for(String word : words){\\n                if(frequency(query) < frequency(word)){\\n                    val++;\\n                }", "class Solution {\\n    public int[] numSmallerByFrequency(String[] queries, String[] words) {\\n        int[] res = new int[queries.length];\\n        int j =0;\\n        for(String query : queries){\\n            int val = 0;\\n            for(String word : words){\\n                if(frequency(query) < frequency(word)){\\n                    val++;\\n                }", "class Solution {\\n    public int[] numSmallerByFrequency(String[] queries, String[] words) {\\n        int[] res = new int[queries.length];\\n        int j =0;\\n        for(String query : queries){\\n            int val = 0;\\n            for(String word : words){\\n                if(frequency(query) < frequency(word)){\\n                    val++;\\n                }"]}
{"id": "1140", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n\\n        HashMap<Integer,ListNode> map = new HashMap<>();\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        int sum=0;\\n\\n        ListNode node = dummy; \\n        while(node!=null){\\n            sum +=node.val;\\n            map.put(sum,node);\\n\\n            node = node.next;\\n        }", "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        int  running_sum=0;\\n        while(cur!=null)\\n        {\\n            running_sum += cur.val;\\n            if(running_sum==0)\\n            {\\n                if(prev == null)\\n                head = cur.next;\\n                else\\n                prev.next = cur.next;\\n                return removeZeroSumSublists(head);\\n            }"]}
{"id": "1142", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    ", "class Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) \\n    {\\n        int[] characters = new int[26];\\n        HashMap<Integer,int[]> map = new HashMap();\\n        int i=0, n= 26;\\n        for(char c: s.toCharArray())\\n        {\\n            characters[c-\\'a\\']++;\\n            map.put(i++,Arrays.copyOf(characters,n));\\n        }"]}
{"id": "1143", "ref_java": ["class Solution {\\n    public int maximumSum(int[] nums) {\\n        int n = nums.length;\\n        int[] f = new int[n];\\n        int[] b = new int[n];\\n        int maxSum = nums[0];\\n        ", "class Solution {\\n    public int maximumSum(int[] arr) {\\n        int n = arr.length;\\n        int oneDelete = 0, noDelete = arr[0], max = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            oneDelete = Math.max(oneDelete + arr[i], noDelete);\\n            noDelete = Math.max(noDelete + arr[i], arr[i]);\\n            max = Math.max(max, Math.max(oneDelete, noDelete));\\n        }", "class Solution {\\n    public int maximumSum(int[] arr) {\\n        if(arr.length ==1) return arr[0];\\n        int[] forward = new int[arr.length];\\n        int[] backward = new int[arr.length];\\n        int max= arr[0];\\n        int currentMax_forward = 0;\\n        int currentMax_backward = 0;\\n        \\n        for(int i= 0; i< arr.length; i++){\\n            currentMax_forward = Math.max(arr[i], arr[i] + currentMax_forward);\\n            forward[i] = currentMax_forward;\\n            max = Math.max(max, currentMax_forward); "]}
{"id": "1144", "ref_java": ["class Solution {\\n    public String reverseParentheses(String s) {\\n        return reverseParenthesis(s);\\n    }", "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\')\\'){\\n                stack.push(s.charAt(i));\\n            }", "class Solution {\\n    public String reverseParentheses(String s) {\\n    Stack<Character> stack = new Stack<>();\\n\\n    for (char symbol : s.toCharArray()) {\\n      if (symbol == \\')\\')\\n        reverseLast(stack);\\n      else\\n        stack.push(symbol);\\n    }"]}
{"id": "1145", "ref_java": ["class Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.length;\\n        if(k==1){\\n            long ans=0L, sum=0L;\\n            for(int i=0;i<n;i++){\\n                sum+=arr[i];\\n                ans=Math.max(ans,sum);\\n                if(sum<0) sum=0;\\n            }", "class Solution {\\n    int mod=1000000007;\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n     int n=arr.length;\\n     if(k==1){\\n         int result=maxsum(arr);\\n         return result>0?result:0;\\n     }", "class Solution {\\n    public int kConcatenationMaxSum(int[] arr, int k) {\\n        int n = arr.length;\\n        if(k==1){\\n            long ans=0L, sum=0L;\\n            for(int i=0;i<n;i++){\\n                sum+=arr[i];\\n                ans=Math.max(ans,sum);\\n                if(sum<0) sum=0;\\n            }"]}
{"id": "1148", "ref_java": ["class Solution {\\n    long a, b, c, ab, bc, ac, abc;\\n\\n    public long countMultiples(long mid) {\\n        return (mid / a) + (mid / b) + (mid / c) - (mid / ab) - (mid / bc) - (mid / ac) + (mid / abc);\\n    }", "class Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }", "class Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1, hi = (int)2e9;\\n        long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(ab, c);\\n        while(lo < hi){\\n            int mid = lo + (hi - lo)/2;\\n            long count = 0L + mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\\n            if (count >= n)\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }"]}
{"id": "1149", "ref_java": ["class Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }", "class Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }", "class Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n\\n        "]}
{"id": "1151", "ref_java": ["class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        int max=0;\\n\\n        while(j<s.length()){\\n            ans+=Math.abs((int)s.charAt(j)-(int)t.charAt(j));\\n\\n            if(ans<=maxCost){\\n                max=Math.max(max,j-i+1);\\n            }", "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        ", "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int maxLen =0;\\n        int n = s.length();\\n        int j=0;\\n        int currCost=0;\\n\\n        for(int i=0; i<n; i++){\\n            "]}
{"id": "1152", "ref_java": ["class Solution {\\n    public String removeDuplicates(String s, int k) {\\n        \\n        Stack<Node> stack = new Stack<>();\\n        \\n        for(char c : s.toCharArray()){\\n            if(!stack.isEmpty() && stack.peek().ch==c){\\n                if(++stack.peek().count==k)\\n                    stack.pop();\\n            }", "class Solution {\\n    public String removeDuplicates(String s, int k) {\\n        Stack<Character> st = new Stack<>();\\n        Stack<Integer> count = new Stack<>();\\n\\n        int n = s.length();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n\\n            if(st.size()>0 && st.peek()==ch) count.push(count.peek()+1);\\n            else count.push(1);\\n\\n            st.push(ch);\\n\\n            if(count.peek()==k){\\n                for(int j=0; j<k; j++){\\n                    st.pop();\\n                    count.pop();\\n                }", "class Solution {\\n    public String removeDuplicates(String s, int k) {\\n        "]}
{"id": "1153", "ref_java": ["class Solution {\\n    public int longestSubsequence(int[] a, int di) {\\n        Map<Integer,Integer>mp=new HashMap<>();\\n        int m=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            int d=a[i]-di;\\n            if(mp.containsKey(d))\\n            {\\n                mp.put(a[i],mp.get(d)+1);\\n            }", "class Solution {\\n    public int longestSubsequence(int[] arr, int difference) {\\n        Map<Integer, Integer> dp = new HashMap<>();\\n        int maxLength = 0;\\n\\n        for (int n : arr) {\\n            if (dp.containsKey(n - difference)) {\\n                dp.put(n, dp.get(n - difference) + 1);\\n            }", "class Solution {\\n    public int longestSubsequence(int[] arr, int difference) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int max = 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            int current = arr[i];\\n            int previous = current - difference;\\n            \\n            if (map.containsKey(previous)) {\\n                int count = map.get(previous);\\n                map.put(current, count + 1);\\n                max = Math.max(max, count + 1);\\n            }"]}
{"id": "1154", "ref_java": ["class Solution {\\n    int r = 0;\\n    int c = 0;\\n    int max = 0;\\n    public int getMaximumGold(int[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(grid[i][j] != 0) {\\n                    dfs(grid, i, j, 0);\\n                }", "class Solution {\\n    int r = 0;\\n    int c = 0;\\n    int max = 0;\\n    public int getMaximumGold(int[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(grid[i][j] != 0) {\\n                    dfs(grid, i, j, 0);\\n                }", "class Solution {\\n    int r = 0;\\n    int c = 0;\\n    int max = 0;\\n    public int getMaximumGold(int[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(grid[i][j] != 0) {\\n                    dfs(grid, i, j, 0);\\n                }"]}
{"id": "1155", "ref_java": ["class Solution {\\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\\n        ", "class Solution {\\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\\n        boolean[][] q = new boolean[8][8];\\n\\t\\t", "class Solution {\\n    \\n    int[][] directions = {{0,1}"]}
{"id": "1157", "ref_java": ["class Solution {\\n    public double nthPersonGetsNthSeat(int n) {\\n       return n==1?1.0:0.5; \\n    }", "class Solution {\\n    public double nthPersonGetsNthSeat(int n) {\\n        if(n==1){\\n            return 1;\\n        }", "class Solution {\\n    public double nthPersonGetsNthSeat(int n) {\\n        if(n==1)\\n        return 1.00000;\\n        return 0.50000;\\n    }"]}
{"id": "1158", "ref_java": ["class Solution {\\n    public List<String> removeSubfolders(String[] folder) {\\n        Arrays.sort(folder);\\n        List<String> list = new ArrayList<>();\\n\\n        for(String f:folder){\\n            if(list.isEmpty() || !f.startsWith(list.get(list.size()-1)+\"/\")){\\n                list.add(f);\\n            }", "class Solution {\\n    public List<String> removeSubfolders(String[] folder) {\\n\\n        ", "class Solution {\\n    public List<String> removeSubfolders(String[] folder) {\\n        Arrays.sort(folder);\\n        List<String> list = new ArrayList<>();\\n\\n        for(String f:folder){\\n            if(list.isEmpty() || !f.startsWith(list.get(list.size()-1)+\"/\")){\\n                list.add(f);\\n            }"]}
{"id": "1159", "ref_java": ["class Solution {\\n    public int balancedString(String s) {\\n        int length = s.length();\\n        Map<Character, Integer> charCount = new HashMap<>();\\n        int left = 0;\\n        int ans = length;\\n        int targetCount = length / 4;\\n\\n        ", "class Solution {\\n    public int balancedString(String s) {\\n        int n = s.length(), ans = n, excess = 0;\\n        int[] cnt = new int[128];\\n        cnt[\\'Q\\'] = cnt[\\'W\\'] = cnt[\\'E\\'] = cnt[\\'R\\'] = -n/4;\\n        for (char ch : s.toCharArray()) if (++cnt[ch] == 1) excess++; ", "class Solution {\\n    public int balancedString(String s) {\\n        \\n        int n = s.length();\\n        int st = 0;\\n        int end = 0;\\n        \\n        int q = 0, w = 0, e= 0, r = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            if( s.charAt(i) == \\'Q\\')\\n                q++;\\n            if( s.charAt(i) == \\'W\\')\\n                w++;\\n            if( s.charAt(i) == \\'E\\')\\n                e++;\\n            if( s.charAt(i) == \\'R\\')\\n                r++;                                    \\n        }"]}
{"id": "1160", "ref_java": ["class Solution {\\n    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 1; i <= 1000; ++i) {\\n            int x = 1, y = 1000;\\n            while (x < y) {\\n                int mid = (x + y) >> 1;\\n                if (customfunction.f(i, mid) >= z) {\\n                    y = mid;\\n                }", "class Solution {\\n    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        int x=1,y=1000;\\n        while(x<1000 && y>0)\\n        {\\n            int cal=customfunction.f(x,y);\\n            if(cal>z)--y;\\n            else if(cal<z) ++x;\\n            else ans.add(Arrays.asList(x++, y--));\\n        }", "class Solution {\\n    public List<List<Integer>> findSolution(CustomFunction func, int z) {\\n        List<List<Integer>> result= new ArrayList<>();\\n\\n        for(int i=1; i<= 1000; i++){\\n            int x= i;\\n\\n            int left= 1;\\n            int right= 1000;\\n\\n            while(left <= right){\\n                int y= (left+right)/2;\\n\\n                int val= func.f(x, y);\\n                if(val == z){\\n                    List<Integer> l1= new ArrayList<>();\\n                    l1.add(x);\\n                    l1.add(y);\\n\\n                    result.add(l1);\\n                    break;\\n                }"]}
{"id": "1161", "ref_java": ["class Solution {\\n    public List<Integer> circularPermutation(int n, int start) {\\n    List<Integer> list = new ArrayList<>();\\n        int i;\\n        for(i=0;i<(1<<n);i++)\\n            list.add(start^i^(i>>1));\\n        return list;\\n    }", "class Solution {\\n    public List<Integer> circularPermutation(int n, int start) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0; i<1<<n; i++){\\n            list.add(start^i^i>>1);\\n        }", "class Solution {\\r\\n    public List<Integer> circularPermutation(int n, int start) {\\r\\n        ArrayList<Integer> arr=new ArrayList<>();\\r\\n        ArrayList<Integer> l=new ArrayList<>();\\r\\n        for(int i=0;i<(int)Math.pow(2,n);i++){\\r\\n            "]}
{"id": "1162", "ref_java": ["class Solution {\\n    int maxLength = 0;\\n    public int maxLength(List<String> arr) {\\n        subsets(arr, 0, \"\");\\n        return maxLength; \\n    }", "class Solution {\\n    public static int helper(int ind,List<String>arr,boolean vis[]){\\n        if(ind==0){\\n            ", "class Solution {\\n    int maxLength = 0;\\n    public int maxLength(List<String> arr) {\\n        subsets(arr, 0, \"\");\\n        return maxLength; \\n    }"]}
{"id": "1163", "ref_java": ["class Solution {\\n    public int minimumSwap(String s1, String s2) {\\n        if(s1.length() != s2.length()) return -1;\\n        int xy=0;\\n        int yx=0;\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i) == \\'x\\'){\\n                x++;\\n                if(s2.charAt(i) == \\'y\\'){\\n                    y++;\\n                    xy++;\\n                }", "class Solution {\\n    public int minimumSwap(String s1, String s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        \\n\\t\\t", "class Solution {\\n    public int minimumSwap(String s1, String s2) {\\n        if(s1.length() != s2.length()) return -1;\\n\\t\\tint n = s1.length();\\n        int x = 0 , y = 0;\\n        \\n        for(int i = 0 ; i < n ; i ++){\\n            char c1 = s1.charAt(i) , c2 = s2.charAt(i);\\n            if(c1 == \\'x\\' && c2 == \\'y\\') x++;\\n            else if(c1 == \\'y\\' && c2 == \\'x\\') y++;\\n        }"]}
{"id": "1164", "ref_java": ["class Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int oddCount=0;\\n        int count=0;\\n        int temp=0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]%2==1){\\n                oddCount++;\\n                temp=0;\\n            }", "class Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        return countAtMostK(nums, k) - countAtMostK(nums, k - 1);\\r\\n    }", "class Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int oddCount=0;\\n        int count=0;\\n        int temp=0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]%2==1){\\n                oddCount++;\\n                temp=0;\\n            }"]}
{"id": "1165", "ref_java": ["class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            if(Character.isAlphabetic(ch))\\n                continue;\\n            if(ch == \\'(\\')\\n                stack.push(i);\\n            else {\\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == \\'(\\')\\n                    stack.pop();\\n                else stack.push(i);\\n            }", "class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        int n = s.length();\\n        int open = 0;\\n        String ans = \"\";\\n        for (int i=0; i<n; i++) {\\n            if (s.charAt(i)==\\'(\\') {\\n                open++;\\n            }", "class Solution {\\n    public String minRemoveToMakeValid(String s) {\\n        HashSet<Integer> set = new HashSet<>();\\n        Stack<Integer> st = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\'(\\'&&s.charAt(i)!=\\')\\')\\n                continue;\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(i);\\n            else{\\n                if(!st.isEmpty()&&s.charAt(st.peek())==\\'(\\')\\n                    st.pop();\\n                else\\n                    set.add(i);\\n            }"]}
{"id": "1166", "ref_java": ["class Solution {\\n    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> empty = new ArrayList<>();\\n        int[] upperArray = new int[colsum.length];\\n        int[] lowerArray = new int[colsum.length];\\n        int leftSum = 0;\\n        int upperSum = 0;\\n        int lowerSum = 0;\\n        for(int i = 0; i< colsum.length; i++){\\n            if(colsum[i] == 2){\\n                upperArray[i]=1;\\n                lowerArray[i]=1;\\n                leftSum++;\\n                upperSum++;\\n                lowerSum++;\\n            }", "class Solution {\\n    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {\\n        int[] arr1 = new int[colsum.length];\\n        int[] arr2 = new int[colsum.length];\\n        int count = 0;\\n\\n        for(int i = 0; i < arr1.length; i++)\\n            if(colsum[i] == 2){\\n                arr1[i] = 1;\\n                count++;\\n            }", "class Solution {\\n    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {\\n        int n = colsum.length;\\n        List<List<Integer>> sol = new ArrayList<List<Integer>>();\\n        for (int i=0;i<2;i++) sol.add(new ArrayList<Integer>());\\n        \\n        for (int i=0;i<n;i++){\\n            if (colsum[i] == 2) { \\n                upper--;\\n                lower--;\\n            }"]}
{"id": "1167", "ref_java": ["class Solution {\\n    class pair{\\n        int first;\\n        int second;\\n        public pair(int first, int second)\\n        {\\n            this.first=first;\\n            this.second=second;\\n        }", "class Solution {\\n    ", "class Solution {\\n    public int closedIsland(int[][] grid) {\\n        "]}
{"id": "1169", "ref_java": ["class Solution {\\n    int maxi = 0;\\n    private void solveRec(int[] nums, int idx, int sum){\\n        ", "class Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int k = 3; ", "class Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        int[] sums=new int [3];\\n\\n        for(int i=0; i<n; i++){\\n            int s0=sums[0]+nums[i];\\n            int s1=sums[1]+nums[i];\\n            int s2=sums[2]+nums[i];\\n\\n            int r0=s0 % 3;\\n            int r1=s1 % 3;\\n            int r2=s2 % 3;\\n\\n            sums[r0]=Math.max(sums[r0], s0);\\n            sums[r1]=Math.max(sums[r1], s1);\\n            sums[r2]=Math.max(sums[r2], s2);\\n        }"]}
{"id": "1170", "ref_java": ["class Solution {\\n\\n    private static final int MAX_ROWS = 250;\\n    private static final int MAX_COLUMNS = 250;\\n\\n    public int countServers(int[][] grid) {\\n        int[] serversInRow = new int[MAX_ROWS + 1];\\n        int[] serversInColumn = new int[MAX_COLUMNS + 1];\\n\\n        for (int r = 0; r < grid.length; ++r) {\\n            for (int c = 0; c < grid[0].length; ++c) {\\n                if (grid[r][c] == 1) {\\n                    ++serversInRow[r];\\n                    ++serversInColumn[c];\\n                }", "class Solution {\\n\\n    private static final int MAX_ROWS = 250;\\n    private static final int MAX_COLUMNS = 250;\\n\\n    public int countServers(int[][] grid) {\\n        int[] serversInRow = new int[MAX_ROWS + 1];\\n        int[] serversInColumn = new int[MAX_COLUMNS + 1];\\n\\n        for (int r = 0; r < grid.length; ++r) {\\n            for (int c = 0; c < grid[0].length; ++c) {\\n                if (grid[r][c] == 1) {\\n                    ++serversInRow[r];\\n                    ++serversInColumn[c];\\n                }", "class Solution {\\n    public int countServers(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = rows == 0 ? 0 : grid[0].length;\\n        int servers = 0;\\n        int[] countServersInRow = new int[rows];\\n        int[] countServersInCol = new int[cols];\\n        \\n        for (int row = 0; row < rows; row++) {\\n            for (int col = 0; col < cols; col++) {\\n                if (grid[row][col] == 1) {\\n                    ++countServersInRow[row];\\n                    ++countServersInCol[col];\\n                }"]}
{"id": "1171", "ref_java": ["class Solution {\\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\\n        \\t\\t\\tPriorityQueue<String> priority = new PriorityQueue<>(3, (s1, s2) -> s1.compareTo(s2));\\n\\t\\t\\tList<List<String>> list = new ArrayList<>();\\n\\n\\t\\t\\tfor (int i = 1; i <= searchWord.length(); i++) {\\n\\t\\t\\t\\tString temp = searchWord.substring(0, i);\\n\\t\\t\\t\\tfor (String s : products) {\\n\\t\\t\\t\\t\\tif (s.startsWith(temp)) {\\n\\t\\t\\t\\t\\t\\tpriority.offer(s);\\n\\t\\t\\t\\t\\t}", "class Solution {\\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\\n        TrieNode root = new TrieNode();\\n        for (String product: products) insert(root, product);\\n        \\n        List<List<String>> results = new ArrayList<>();\\n        for (char c: searchWord.toCharArray()) {\\n            if ((root = root.children[c - \\'a\\']) == null) break;\\n            results.add(root.getTopThree());            \\n        }", "class Solution {\\npublic List<List<String>> suggestedProducts(String[] products, String searchWord) {\\n  PriorityQueue<String> pq = new PriorityQueue<>(3, (s1,s2) -> s1.compareTo(s2)); \\n  List<List<String>> list = new ArrayList<>();\\n  \\n  for(int i = 1; i<=searchWord.length(); i++){\\n    String temp = searchWord.substring(0, i);\\n    for(String s : products){\\n      if(s.startsWith(temp)){\\n        pq.offer(s);\\n      }"]}
{"id": "1172", "ref_java": ["class Solution {\\n    public List<Integer> numOfBurgers(int tSlices, int cSlices) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        int x = tSlices - 2*cSlices;\\n        int y = cSlices - x/2;\\n        if(x<0 || x%2!=0 || y<1 )\\n            if(tSlices!=0 || cSlices!=0)\\n                return result;\\n        result.add(x/2); result.add(y);\\n        return result;\\n    }", "class Solution {\\n    public List<Integer> numOfBurgers(int tSlices, int cSlices) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        int x = tSlices - 2*cSlices;\\n        int y = cSlices - x/2;\\n        if(x<0 || x%2!=0 || y<1 )\\n            if(tSlices!=0 || cSlices!=0)\\n                return result;\\n        result.add(x/2); result.add(y);\\n        return result;\\n    }", "class Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>al=new ArrayList<>();\\n        if(tomatoSlices%2==1||(tomatoSlices<2*cheeseSlices))\\n        {\\n            return al;\\n        }"]}
{"id": "1173", "ref_java": ["class Solution {\\n    public int countSquares(int[][] mat) {\\n        int count = 0;\\n\\n        for(int row = 0; row < mat.length; row++){\\n            for(int col = 0; col < mat[0].length; col++){\\n                if(mat[row][col] == 1){\\n                    int min = Integer.MAX_VALUE;\\n\\n                    if(col - 1 >= 0)\\n                        min = Math.min(mat[row][col - 1], min);\\n                    else min = 0;\\n                    \\n                    if(row - 1 >= 0)\\n                        min = Math.min(mat[row - 1][col], min);\\n                    else min = 0;\\n\\n                    if(row - 1 >= 0 && col - 1 >= 0)\\n                        min = Math.min(min, mat[row - 1][col - 1]);\\n                    else min = 0;\\n                    \\n                    mat[row][col] += min;\\n                    count += mat[row][col];\\n                }", "class Solution {\\n    public int countSquares(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(arr[i][j] == 1){  ", "class Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}"]}
{"id": "1174", "ref_java": ["class Solution {\\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\\n        List<List<Integer>> allGroups = new ArrayList<>();\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n\\n        for (int i = 0; i < groupSizes.length; i++){\\n            ArrayList<Integer> list = map.getOrDefault(groupSizes[i], new ArrayList<>());\\n            map.put(groupSizes[i], list);\\n            list.add(i);\\n            if (list.size() == groupSizes[i]){\\n                allGroups.add(new ArrayList<>(list));\\n                map.put(groupSizes[i], new ArrayList<>());\\n            }", "class Solution {\\n    public List<List<Integer>> groupThePeople(int[] gr) {\\n        int n = gr.length;\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            list.add(new ArrayList<>());\\n        }", "class Solution {\\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\\n          Map<Integer, List<Integer>> grps = new HashMap<>();\\n          int sz = groupSizes.length;\\n          List<List<Integer>> res = new ArrayList<>();\\n          for(int id = 0; id<sz; id++){\\n              int grpSz = groupSizes[id];\\n              grps.putIfAbsent(grpSz, new ArrayList<>());\\n              if(grps.containsKey(grpSz) && grps.get(grpSz).size() == grpSz){\\n                  res.add(grps.get(grpSz));\\n                  grps.put(grpSz, new ArrayList<>());\\n              }"]}
{"id": "1175", "ref_java": ["class Solution {\\n    public int smallestDivisor(int[] nums, int threshold) {\\n        int low=1;\\n        int high=Integer.MIN_VALUE;\\n\\n        int n=nums.length;\\n\\n        for(int i=0;i<n;i++){\\n            high=Math.max(high,nums[i]);\\n        }", "class Solution { \\n    public int smallestDivisor(int[] nums, int threshold) {\\n        int l = 1, r = 1000000; \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(mid, nums) > threshold) {\\n                l = mid + 1;\\n            }", "class Solution {\\n    public boolean isPossible(int []nums,int val,int threshold){\\n        int cnt=0;\\n        for(int x:nums){\\n            if(x%val==0) cnt+=(x/val);\\n            else cnt+=((x/val)+1);\\n            if(cnt>threshold) return false; "]}
{"id": "1177", "ref_java": ["class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));\\n        int count = 0, cur = 0;\\n        for(int interval[] : intervals){\\n            if(cur < interval[1]){\\n                cur = interval[1];\\n                count++;\\n            }", "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n\\n        Arrays.sort(intervals, new intervalsComparator());\\n\\t\\t", "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));\\n        int count = 0, cur = 0;\\n        for(int interval[] : intervals){\\n            if(cur < interval[1]){\\n                cur = interval[1];\\n                count++;\\n            }"]}
{"id": "1178", "ref_java": ["class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String digits = \"123456789\";\\n        List<Integer> res = new ArrayList<>();\\n        int nl = String.valueOf(low).length();\\n        int nh = String.valueOf(high).length();\\n        \\n        for(int i = nl; i <= nh; i++){\\n            for(int j = 0; j < 10 - i; j++){\\n                int num = Integer.parseInt(digits.substring(j, j + i));\\n                if(num >= low && num <= high) res.add(num);\\n            }", "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int start = 1, cur = 1, inc = 11, t = 8;\\n        List<Integer> ans = new ArrayList<>();\\n        while(cur <= high){\\n            for (int i = 0; i < t; i++){\\n                cur += inc;\\n                if (cur >= low && cur <= high) ans.add(cur);\\n            }", "class Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    void solve(int l,int h,int i,int num)\\n    {\\n        if(num>=l && num <=h)\\n            ans.add(num);\\n        if(num>=h || i>9)\\n            return;\\n        solve(l,h,i+1,num*10+i);\\n    }"]}
{"id": "1179", "ref_java": ["class Solution {\\n\\n    public int findSum(int dp[][],int i,int j,int k,int l) {\\n\\n        int n = dp.length;\\n        int m = dp[0].length;\\n\\n        if(k >= n || l >= m) {\\n            return Integer.MAX_VALUE;\\n        }", "class Solution {\\n    public int maxSideLength(int[][] mat, int threshold) {\\n         int r = mat.length, c = mat[0].length;\\n        int[][] pre = new int[r+1][c+1];\\n        for (int i = 1; i <= r; i++) {\\n            for (int j = 1; j <= c; j++) {\\n                pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + mat[i-1][j-1];\\n            }", "class Solution {\\n    public int maxSideLength(int[][] mat, int threshold) {\\n         int r = mat.length, c = mat[0].length;\\n        int[][] pre = new int[r+1][c+1];\\n        for (int i = 1; i <= r; i++) {\\n            for (int j = 1; j <= c; j++) {\\n                pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + mat[i-1][j-1];\\n            }"]}
{"id": "1180", "ref_java": ["class Solution {\\n    public boolean isPossibleDivide(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n\\n        if(n%k!=0) return false;\\n        Arrays.sort(arr);\\n\\n        ArrayList<Integer> a = new ArrayList<>();\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            a.add(arr[i]);\\n            hp.put(arr[i],hp.getOrDefault(arr[i],0)+1);\\n        }", "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }", "class Solution {\\n    public boolean isPossibleDivide(int[] hand, int groupSize) {\\n        if(hand.length % groupSize != 0){\\n            return false;\\n        }"]}
{"id": "1181", "ref_java": ["class Solution {\\n    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\\n        int n = s.length();\\n        Map<String, Integer> substringFrequency = new HashMap<>();\\n        int maxFreq = 0;\\n\\n        for (int i = 0; i <= n - minSize; i++) {\\n            String substring = s.substring(i, i + minSize);\\n            Set<Character> uniqueChars = new HashSet<>();\\n            int distinctChars = 0;\\n\\n            for (char c : substring.toCharArray()) {\\n                if (!uniqueChars.contains(c)) {\\n                    distinctChars++;\\n                    uniqueChars.add(c);\\n                }", "class Solution {\\n    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\\n        HashMap<String, Integer> map = new HashMap<>(); \\n        int maxOccurrences = 0; \\n\\n        int left = 0, right = minSize; ", "class Solution {\\n    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\\n        Map<String, Integer> occurrences = new HashMap<>();\\n        "]}
{"id": "1182", "ref_java": ["class Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }", "class Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }", "class Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }"]}
{"id": "1183", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int deepestLeavesSum(TreeNode root) {\\n        return util1(root);\\n    }", "class Solution {\\n    int maxHeight = Integer.MIN_VALUE;\\n    int maxSum = 0;\\n    public int deepestLeavesSum(TreeNode root) {\\n        inorderDFS(root,0);\\n        return maxSum;\\n    }"]}
{"id": "1184", "ref_java": ["class Solution {\\n    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        while(root1 != null || root2 != null || !st1.empty() || !st2.empty()){\\n            while(root1 != null){\\n                st1.push(root1);\\n                root1 = root1.left;\\n            }", "class Solution {\\n    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n        inorder(root1,list1);\\n        inorder(root2,list2);\\n        List<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        int j = 0;\\n        while(i<list1.size()&&j<list2.size()){\\n            if(list1.get(i)>=list2.get(j)){\\n                ans.add(list2.get(j));\\n                j++;\\n            }", "class Solution {\\n    public Stack<Integer> inorder(TreeNode root,Stack<Integer> s){\\n        if(root==null) return s;\\n        inorder(root.left,s);\\n        s.add(root.val);\\n        inorder(root.right,s);\\n        return s;\\n    }"]}
{"id": "1185", "ref_java": ["class Solution {\\n\\n    static boolean helper(int arr[], int idx){\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(idx);\\n\\n        HashSet<Integer> hp = new HashSet<>();\\n\\n        while(q.size()!=0){\\n            int a = q.remove();\\n            if(a>=arr.length || a<0) continue;\\n            if(arr[a]==0) return true;\\n            if(!hp.contains(a-arr[a])){\\n                q.add(a-arr[a]);\\n                hp.add(a-arr[a]);\\n            }", "class Solution {\\n    public boolean canReach(int[] arr, int start) {\\n        boolean vis[]=new boolean[arr.length];\\n        return dfs(arr,start,vis);\\n        \\n    }", "class Solution {\\n    public boolean canReach(int[] arr, int start) {\\n        int visited[] = new int[arr.length];\\n        return dfs(arr,start,visited);\\n    }"]}
{"id": "1186", "ref_java": ["class Solution {\\n    public int[] xorQueries(int[] arr, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        int[] prefixXor = new int[arr.length];\\n        prefixXor[0] = arr[0];\\n        for(int i = 1; i < arr.length; i++){\\n            prefixXor[i] = prefixXor[i-1] ^ arr[i];\\n        }", "class Solution {\\n    public int[] xorQueries(int[] arr, int[][] queries) {\\n        int n = arr.length;\\n        int m = queries.length;\\n        \\n        int[] val = new int[n];\\n        int[] ans = new int[m];\\n        \\n        val[0] = arr[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            val[i] = val[i-1]^arr[i];\\n        }", "class Solution {\\n    public int[] xorQueries(int[] arr, int[][] queries) {\\n        int n = arr.length;\\n        int[]arr1 = new int[n];\\n\\n        arr1[0] = arr[0];\\n        for(int i = 1;i<n;i++){\\n            arr1[i] = arr1[i-1]^arr[i];\\n        }"]}
{"id": "1187", "ref_java": ["class Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n           ArrayList<String> result=new ArrayList<String>();\\n            HashSet<Integer> hset=new HashSet<Integer>();\\n            Queue<String> q=new LinkedList<String>();\\n            q.add(Integer.toString(id)+\" \"+Integer.toString(0));\\n            HashMap<String,Integer> map=new HashMap<String,Integer>();\\n            hset.add(id);\\n            while(q.size()>0)\\n            {\\n               String str[]=q.poll().split(\" \");\\n               int x=Integer.parseInt(str[0]);\\n               int l=Integer.parseInt(str[1]);\\n               if(l+1<=level)\\n               {\\n                for(int i=0;i<friends[x].length;i++)\\n                {\\n                    if(!hset.contains(friends[x][i]))\\n                    {\\n                        hset.add(friends[x][i]);\\n                        q.add(Integer.toString(friends[x][i])+\" \"+Integer.toString(l+1));\\n                        if(l+1==level)\\n                        {\\n                            for(int j=0;j<watchedVideos.get(friends[x][i]).size();j++)\\n                            {\\n                                    if(!map.containsKey(watchedVideos.get(friends[x][i]).get(j)))\\n                                    {\\n                                        map.put(watchedVideos.get(friends[x][i]).get(j),1);\\n                                    }", "class Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        int n = friends.length;\\n        boolean[] visited = new boolean[n];\\n\\n\\n        Queue<Integer> qu = new LinkedList<>();\\n\\n        List<String> ans = new ArrayList<>();\\n\\n        qu.add(id);\\n        int m,topnode;\\n        visited[id] = true;\\n        for(int i = 0;i<level && !qu.isEmpty();i++){\\n            m = qu.size();\\n            for(int j = 0;j<m;j++){\\n                topnode = qu.poll();\\n                \\n                for(int friend: friends[topnode]){\\n                    if(!visited[friend]){\\n                        qu.add(friend);\\n                        visited[friend] = true;\\n                    }", "class Solution {\\n    public class Movie implements Comparable<Movie> {\\n        String name;\\n        int freq;\\n\\n        public Movie(String name, int freq) {\\n            this.name = name;\\n            this.freq = freq;\\n        }"]}
{"id": "1188", "ref_java": ["class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }", "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        \\n        int[][] ans = new int[n][m];\\n            \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                \\n                for(int x =-K; x<=K;x++){\\n                    int nr = i+x; ", "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }"]}
{"id": "1189", "ref_java": ["class Solution {\\n    int maxsum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root);\\n        return maxsum;\\n        \\n    }", "class Solution {\\n    int maxsum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root);\\n        return maxsum;\\n        \\n    }", "class Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.val % 2 == 0)\\n        {\\n            if(root.left !=null && root.left.left !=null)\\n                sum+=root.left.left.val;\\n            if(root.left !=null && root.left.right !=null)\\n                sum+=root.left.right.val;\\n            if(root.right !=null && root.right.left !=null)\\n                sum+=root.right.left.val;\\n            if(root.right !=null && root.right.right !=null)\\n                sum+=root.right.right.val;\\n        }"]}
{"id": "1190", "ref_java": ["class Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int bitA, bitB, bitC;\\n\\n        while (a > 0 || b > 0 || c > 0) \\n        {\\n            bitA = a & 1;  ", "class Solution {\\n    public int minFlips(int a, int b, int c) {\\n        int flips = 0;\\n        int bitA, bitB, bitC;\\n\\n        while (a > 0 || b > 0 || c > 0) \\n        {\\n            bitA = a & 1;  ", "class Solution {\\n\\n  public int minFlips(int a, int b, int c) {\\n    int result = 0;\\n    for (int i = 0; i < 32; i++) {\\n      int aBit = a & 1;\\n      int bBit = b & 1;\\n      int cBit = c & 1;\\n\\n      if ((aBit | bBit) != cBit) {\\n        result += (aBit + bBit + cBit);\\n      }"]}
{"id": "1191", "ref_java": ["class Solution {\\n    static int MaxCon;\\n    static int dots;\\n    public void dfs(int start, HashSet<Integer>[] grapf, HashSet<Integer> visited)\\n    {\\n        visited.remove(start);\\n        for(int neib : grapf[start])\\n        {\\n            MaxCon++;\\n            if (visited.contains(neib))\\n                dfs(neib, grapf, visited);\\n        }", "class Solution {\\n  public int makeConnected(int n, int[][] connections) {\\n    LinkedList<Integer>[] g = new LinkedList[n];                 ", "class Solution {\\n    public int makeConnected(int n, int[][] connections) {\\n        \\n        DisjointSet ds = new DisjointSet(n);\\n\\n        int m = connections.length;\\n        int extraEdges = 0;\\n\\n        "]}
{"id": "1193", "ref_java": ["class Solution {\\n    public List<String> printVertically(String s) {\\n        String strArr[] = s.split(\" \");\\n        int maxLengthWOrd=0;\\n        for(String w : strArr){\\n            maxLengthWOrd=Math.max(maxLengthWOrd,w.length());\\n        }", "class Solution {\\n    public List<String> printVertically(String s) {\\n        String strArr[] = s.split(\" \");\\n        int maxLengthWOrd=0;\\n        for(String w : strArr){\\n            maxLengthWOrd=Math.max(maxLengthWOrd,w.length());\\n        }", "class Solution {\\n"]}
{"id": "1194", "ref_java": ["class Solution {\\n    static boolean check(TreeNode root, int tar){\\n        if(root==null) return false;\\n        if(root.left==null && root.right==null){\\n            if(root.val==tar) return true;\\n            else return false;\\n        }", "class Solution {\\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\\n            if(root==null){\\n                return null;\\n            }", "class Solution {\\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\\n        if(root==null){\\n            return null;\\n        }"]}
{"id": "1195", "ref_java": ["class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int len = palindrome.length();\\n        char strArr[] = palindrome.toCharArray();\\n        for(int i=0;i<len/2;i++){\\n            if(strArr[i] != \\'a\\'){\\n                strArr[i] = \\'a\\';\\n                return String.valueOf(strArr);\\n            }", "class Solution {\\n    public String breakPalindrome(String s) {\\n        int n = s.length();\\n\\n        if(n==1) return \"\";\\n\\n        StringBuilder ans = new StringBuilder(s);\\n        boolean flag = false;\\n\\n        for(int i=0; i<n/2; i++){\\n            char ch = ans.charAt(i);\\n            if(ch!=\\'a\\'){\\n                int x = ans.indexOf(ch+\"\");\\n                ans.replace(x,x+1,\"a\");\\n                flag = true;\\n                break;\\n            }", "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n\\t\\t"]}
{"id": "1196", "ref_java": ["class Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        ", "class Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        if(mat.length == 1) {\\n            return mat;\\n        }", "class Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int arr[][]=new int[mat.length][mat[0].length];\\n        \\n        for(int i=0;i<mat[0].length;i++){\\n            ArrayList<Integer>list=new ArrayList<>();\\n            int ind=0;\\n            int ind1=i;\\n            while(ind<mat.length&&ind1<mat[0].length){\\n                list.add(mat[ind][ind1]);\\n                ind++;\\n                ind1++;\\n            }"]}
{"id": "1197", "ref_java": ["class Solution {\\n    static class Triple{\\n        int id;\\n        int rate;\\n\\n        Triple(int id, int rate){\\n            this.id = id;\\n            this.rate = rate;\\n        }", "class Solution {\\n    public List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        ", "class Solution {\\n    public List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n    Predicate<int[]> veganFilter = restaurant -> veganFriendly != 1 || restaurant[2] == veganFriendly;\\n    Predicate<int[]> maxPriceFilter = restaurant -> restaurant[3] <= maxPrice;\\n    Predicate<int[]> maxDistanceFilter = restaurant -> restaurant[4] <= maxDistance;\\n    Comparator<int[]> ratingComparator = Comparator.comparing(\\n      (int[] restaurant) -> restaurant[1]).thenComparing(restaurant -> restaurant[0]).reversed();\\n    Function<int[], Integer> idMapper = restaurant -> restaurant[0];\\n\\n    return Arrays.stream(restaurants)\\n      .filter(veganFilter)\\n      .filter(maxPriceFilter)\\n      .filter(maxDistanceFilter)\\n      .sorted(ratingComparator)\\n      .map(idMapper)\\n      .toList();\\n  }"]}
{"id": "1198", "ref_java": ["class Solution {\\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\\n        int dist[][]=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dist[i][j]=Integer.MAX_VALUE;\\n            }", "class Solution {\\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\\n        int costs[][] = getCosts(edges, n);\\n\\n        ", "class Solution {\\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\\n        int dist[][]=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dist[i][j]=Integer.MAX_VALUE;\\n            }"]}
{"id": "1199", "ref_java": ["class Solution {\\n    public int minSetSize(int[] arr) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        Comparator<Integer> reverseComparator = Collections.reverseOrder();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(reverseComparator);\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],1);\\n            }", "class Solution {\\n    public int minSetSize(int[] arr) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        Comparator<Integer> reverseComparator = Collections.reverseOrder();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(reverseComparator);\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],1);\\n            }", "class Solution {\\n    public int minSetSize(int[] arr) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        Comparator<Integer> reverseComparator = Collections.reverseOrder();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(reverseComparator);\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],1);\\n            }"]}
{"id": "1200", "ref_java": ["class Solution {\\n  public int maxProduct(TreeNode root) {\\n    final int kMod = 1_000_000_007;\\n    long ans = 0;\\n    List<Integer> allSums = new ArrayList<>();\\n    final long totalSum = treeSum(root, allSums);\\n\\n    for (final long sum : allSums)\\n      ans = Math.max(ans, sum * (totalSum - sum));\\n\\n    return (int) (ans % kMod);\\n  }", "class Solution {\\n  public int maxProduct(TreeNode root) {\\n    final int kMod = 1_000_000_007;\\n    long ans = 0;\\n    List<Integer> allSums = new ArrayList<>();\\n    final long totalSum = treeSum(root, allSums);\\n\\n    for (final long sum : allSums)\\n      ans = Math.max(ans, sum * (totalSum - sum));\\n\\n    return (int) (ans % kMod);\\n  }", "class Solution {\\n\\n    int MOD = 1_000_000_007;\\n    long[] maxprodsofar = new long[1];\\n\\n    public int maxProduct(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }"]}
{"id": "1202", "ref_java": ["class Solution {\\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\\n        int i=0;\\n        int j=0;\\n\\n        int sum=0;\\n        int ans=0;\\n\\n        while(j<arr.length){\\n            sum+=arr[j];\\n            if(j-i+1<k){\\n                j++;\\n            }", "class Solution {\\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\\n        int currSum = 0; ", "class Solution {\\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\\n        int currsum = 0;  \\n        int count = 0;\\n        double curravg = 0;\\n        for(int i =0; i<arr.length; i++) { \\n            currsum += arr[i];  "]}
{"id": "1203", "ref_java": ["class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        hour=hour%12;\\n        double anglePerMinute= minutes/12.00;\\n        double a = (hour*5) + anglePerMinute;\\n        double b = minutes;\\n        double diff=Math.abs(b-a);\\n        double ans= diff*6.0;\\n        return (ans > 180) ? 360-ans : ans;\\n    }", "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int totalMinutes=hour*60+minutes;\\n     double hourAngle=totalMinutes*0.5;\\n     double minuteAngle=minutes*6;\\n     if(hourAngle>=360)\\n     hourAngle=hourAngle-360;\\ndouble ans=Math.abs(minuteAngle-hourAngle);\\nif(ans>180.00)\\nans=360.00-ans;\\nreturn ans;\\n    }", "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n         "]}
{"id": "1204", "ref_java": ["class Solution {\\n    public int minSteps(String s, String t) {\\n        int ans = 0;\\n        int[] hashh = new int[26];\\n\\n        ", "class Solution {\\n    public int minSteps(String s, String t) {\\n        if(s.equals(t))return 0;\\n        \\n        \\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n        for(int i = 0; i < n; i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }", "class Solution {\\n    public int minSteps(String s, String t) {\\n        if(s.equals(t))return 0;\\n        \\n        \\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n        for(int i = 0; i < n; i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }"]}
{"id": "1207", "ref_java": ["class Solution {\\n    public int maxEvents(int[][] events) {\\n        Arrays.sort(events,(a,b)->(a[0]!=b[0])?a[0]-b[0]: a[1]-b[1]);\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        int res=0, n=events.length;\\n\\n        for(int i=1, j=0;i<=100000;i++){\\n            while(j<n && events[j][0]==i) \\n                pq.add(events[j++]);\\n            \\n            if(pq.isEmpty()){\\n                if(j==n) break;\\n                i=events[j][0]-1;\\n            }", "class Solution {\\n    public int maxEvents(int[][] events) {\\n        if (events == null || events.length == 0) return 0;\\n        final int N = events.length;\\n        ", "class Solution {\\n    public int maxEvents(int[][] A) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        \\n        Arrays.sort(A, (a,b) -> Integer.compare(a[0], b[0]));\\n        \\n        int i =0, res = 0, n = A.length;\\n        \\n        for(int d = 1; d<= 100000; d++){\\n            \\n            "]}
{"id": "1209", "ref_java": ["class Solution {\\n    public int numberOfSubstrings(String s) {\\n        if(s.length()<=3){\\n            if(s.length()==3 && s.contains(\"a\") && s.contains(\"b\") && s.contains(\"c\")){\\n                return 1;\\n            }", "class Solution {\\n    public int numberOfSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    int[] arr=new int[3];\\n\\n    int j=0;\\n\\n    for(int i=0;i<s.length();i++){\\n\\n    if(arr[0]>0&&arr[1]>0&&arr[2]>0){\\n\\n    if(s.charAt(i)==\\'a\\')arr[0]--;\\n    if(s.charAt(i)==\\'b\\')arr[1]--;\\n    if(s.charAt(i)==\\'c\\')arr[2]--;\\n    count+=(s.length()-j+1);\\n    continue;\\n\\n    }", "class Solution {\\n    public int numberOfSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    int[] arr=new int[3];\\n\\n    int j=0;\\n\\n    for(int i=0;i<s.length();i++){\\n\\n    if(arr[0]>0&&arr[1]>0&&arr[2]>0){\\n\\n    if(s.charAt(i)==\\'a\\')arr[0]--;\\n    if(s.charAt(i)==\\'b\\')arr[1]--;\\n    if(s.charAt(i)==\\'c\\')arr[2]--;\\n    count+=(s.length()-j+1);\\n    continue;\\n\\n    }"]}
{"id": "1210", "ref_java": ["class Solution {\\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\\n        int[] indegree = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (leftChild[i] != -1) indegree[leftChild[i]]++;\\n            if (rightChild[i] != -1) indegree[rightChild[i]]++;\\n        }", "class Solution {\\n    public boolean validatedfs(int curr, int[] left, int [] right, boolean [] vis,int [] nodesVisited){\\n        if(curr==-1)return true; \\n        if(vis[curr]) return false; ", "class Solution {\\n    \\n    "]}
{"id": "1211", "ref_java": ["class Solution {\\n    public int[] closestDivisors(int num) {\\n        int i =  (int)Math.sqrt(num+2);\\n        while(i>=1){\\n            if((num+1)%i==0) return new int[]{i , (num+1)/i}", "class Solution {\\n    public int[] closestDivisors(int num) {\\n        int i =  (int)Math.sqrt(num+2);\\n        while(i>=1){\\n            if((num+1)%i==0) return new int[]{i , (num+1)/i}", "class Solution {\\n    public int[] closestDivisors(int num) {\\n        int[] arr1 = new int[2];\\n        "]}
{"id": "1212", "ref_java": ["class Solution {\\n    public String rankTeams(String[] votes) {\\n        int len = votes[0].length();\\n        int[][] map = new int[26][len + 1];\\n        for(int i = 0; i < 26; i++) map[i][len] = i;\\n        \\n        for(int i = 0; i < votes.length; i++){\\n            String s = votes[i];\\n            for(int j = 0; j < len; j++){\\n                map[s.charAt(j) - \\'A\\'][j]++;\\n            }", "class Solution {\\n    public String rankTeams(String[] votes) {\\n        int len = votes[0].length();\\n        int[][] map = new int[26][len + 1];\\n        for(int i = 0; i < 26; i++) map[i][len] = i;\\n        \\n        for(int i = 0; i < votes.length; i++){\\n            String s = votes[i];\\n            for(int j = 0; j < len; j++){\\n                map[s.charAt(j) - \\'A\\'][j]++;\\n            }", "class Solution {\\n    public String rankTeams(String[] votes) {\\n        int n = votes.length;\\n        int teams = votes[0].length();\\n        Map<Character, int[]> map = new HashMap<>();\\n        List<Character> chars = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < teams ; i++) {\\n            char team = votes[0].charAt(i);\\n            map.put(team, new int[teams]);\\n            chars.add(team);\\n        }"]}
{"id": "1213", "ref_java": ["class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       ", "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null)    return false;\\n        if(issame(head, root))  return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }", "class Solution {\\n    Boolean result = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        traverse(head, root);\\n        return result;\\n    }"]}
{"id": "1214", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }", "class Solution {\\n    public int findTheLongestSubstring(String s) {\\n        return util1(s);\\n    }"]}
{"id": "1215", "ref_java": ["class Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }", "class Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }", "class Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}"]}
{"id": "1216", "ref_java": ["class Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int counter=0,total=0,max=Integer.MIN_VALUE;\\n        for(int i=0;i<flips.length;i++){\\n            if(max<flips[i])max=flips[i];\\n            if(++counter==max)total++;\\n        }", "class Solution {\\n    \\n    public int numTimesAllBlue(int[] light){\\n       int i = 1;\\n       int expectedSum = 0;\\n       int actualSum = 0; \\n       int ans = 0; \\n       for(int num:light){\\n           actualSum += num;\\n           expectedSum += i;\\n           if(actualSum == expectedSum) ans++;\\n           i++;\\n       }", "class Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        "]}
{"id": "1217", "ref_java": ["class Solution {\\n    public int dfs(int n, List<Pair<Integer, Integer>>[] adj, boolean[] vis, int[] informTime) {\\n        int ans = 0;\\n        for (Pair<Integer, Integer> i : adj[n]) {\\n            ans = Math.max(ans, informTime[n] + dfs(i.getKey(), adj, vis, informTime));\\n        }", "class Solution {\\n\\n    public int maxTimeNAryTree(int head, HashMap<Integer, ArrayList<Integer>> children, int []informTime) {\\n\\n        int selfPropTime = informTime[head];\\n        int maxNAryChildrenTime = 0;\\n\\n        ArrayList<Integer> nAryChildren = children.get(head);\\n\\n        if (nAryChildren == null)\\n            return selfPropTime;\\n\\n        for (int i = 0; i < nAryChildren.size(); i++) {\\n            int currChild = nAryChildren.get(i);\\n            int currTime = informTime[currChild];\\n\\n            maxNAryChildrenTime = Math.max(maxNAryChildrenTime, maxTimeNAryTree(currChild, children, informTime));\\n        }", "class Solution {\\nprivate:\\n    int dfs(int emp, vector<int>& manager, vector<int>& informTime) {\\n        if (manager[emp] != -1) {\\n            informTime[emp] += dfs(manager[emp], manager, informTime);\\n            manager[emp] = -1;\\n        }"]}
{"id": "1219", "ref_java": ["class Solution {\\n", "class Solution {\\n    List<TreeNode> list = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorderDFS(root);\\n        return createBST(list, 0, list.size() - 1);\\n    }", "class Solution {\\n    public static TreeNode Balance( ArrayList<Integer> list,int st,int end){\\n        if(st>end){\\n            return null;\\n        }"]}
{"id": "1220", "ref_java": ["class Solution {\\n    public int maxNumberOfFamilies(int n, int[][] reservedSeats) {\\n        Map<Integer, Integer> cinemaSeats = new HashMap<>();\\n        for (int[] reserved: reservedSeats) {\\n            int row = reserved[0] - 1, col = reserved[1];\\n            cinemaSeats.put(row, setBit(cinemaSeats.getOrDefault(row, 0), 10 - col));\\n        }", "class Solution {\\n    public int maxNumberOfFamilies(int n, int[][] reservedSeats) {\\n        ", "class Solution {\\n    class RowInfo {\\n        int row;\\n        boolean left;\\n        boolean middle;\\n        boolean right;\\n        \\n        public RowInfo(int row) {\\n            this.row = row;\\n            left = true;\\n            middle = true;\\n            right = true;\\n        }"]}
{"id": "1221", "ref_java": ["class Solution {\\n    \\n    HashMap<Integer, Integer> cache;\\n    public int getKth(int lo, int hi, int k) {\\n        cache = new HashMap();\\n        \\n\\n        PriorityQueue<Item> maxHeap = new PriorityQueue<Item>((a, b) -> (a.power == b.power) ? (b.num - a.num) : (b.power - a.power));\\n        \\n        for(int num = lo; num <= hi; num++){\\n            ", "class Solution {\\n    public int count(int x){\\n        int con = 0;\\n        while(x != 1){\\n            if(x%2==0){\\n                x = x/2;\\n                con++;\\n            }", "class Solution {\\n\\n    public int getKth(int lo, int hi, int k) {\\n        \\n        final Map<Integer, Integer> dp = new HashMap<>();\\n        dp.put(1, 1);\\n\\n        final PriorityQueue<int[]> queue = new PriorityQueue<>((a1, a2) -> a2[0] != a1[0] ? a2[0] - a1[0] : a2[1] - a1[1]);\\n\\n        for (int i = lo; i <= hi; i++) {\\n            final int count = findPow(i, dp);\\n            queue.offer(new int[] { count, i }"]}
{"id": "1222", "ref_java": ["class Solution {\\n    public int sumFourDivisors(int[] nums) {\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            int count = 0;\\n            int sumOfDivisors = 0;\\n            for(int j = 1; j <= Math.sqrt(num); j++) {\\n                if(num % j == 0) {\\n                    if(j * j == num) {\\n                        count++;\\n                        sumOfDivisors += j;\\n                    }", "class Solution {\\n    public int sumFourDivisors(int[] nums) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }", "class Solution {\\n    public int sumFourDivisors(int[] nums) {\\n        int sum = 0;\\n        "]}
{"id": "1223", "ref_java": ["class Solution {\\n    public static boolean  chk(int grid[][],int i,int j){ \\n", "class Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int[][] visited=new int[m][n];\\n        return dfs(grid, 0, 0, m, n, visited);\\n    }", "class Solution {\\n    public boolean hasValidPath(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        if(m == 1 && n == 1) return true;\\n        \\n        Map<Integer, Map<Pair, Set<Integer>>> map = new HashMap<>();\\n        map.put(1, new HashMap<>());\\n        map.get(1).put(new Pair(0, -1),  new HashSet<>(Arrays.asList(1, 4, 6)));\\n        map.get(1).put(new Pair(0, 1),  new HashSet<>(Arrays.asList(1, 5, 3, 6)));\\n        \\n        map.put(2, new HashMap<>());\\n        map.get(2).put(new Pair(-1, 0),  new HashSet<>(Arrays.asList(2, 3, 4)));\\n        map.get(2).put(new Pair(1, 0),  new HashSet<>(Arrays.asList(2, 5, 6)));\\n        \\n        map.put(3, new HashMap<>());\\n        map.get(3).put(new Pair(0, -1),  new HashSet<>(Arrays.asList(1, 4, 6)));\\n        map.get(3).put(new Pair(1, 0),  new HashSet<>(Arrays.asList(2, 5, 6)));\\n        \\n        map.put(4, new HashMap<>());\\n        map.get(4).put(new Pair(0, 1),  new HashSet<>(Arrays.asList(3, 1, 5)));\\n        map.get(4).put(new Pair(1, 0),  new HashSet<>(Arrays.asList(2, 5, 6, 2)));\\n        \\n        map.put(5, new HashMap<>());\\n        map.get(5).put(new Pair(-1, 0),  new HashSet<>(Arrays.asList(2, 3, 4)));\\n        map.get(5).put(new Pair(0, -1),  new HashSet<>(Arrays.asList(1, 4 , 6)));\\n        \\n        map.put(6, new HashMap<>());\\n        map.get(6).put(new Pair(-1, 0),  new HashSet<>(Arrays.asList(4 ,3 , 2)));\\n        map.get(6).put(new Pair(0, 1),  new HashSet<>(Arrays.asList(3, 5, 1)));\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[] {0, 0}"]}
{"id": "1225", "ref_java": ["class Solution {\\n    public int numTeams(int[] rating) {\\n        if(rating == null || rating.length == 0){\\n            return 0;\\n        }", "class Solution {\\n    public int numTeams(int[] rating) {\\n        int count=0;\\n        int n = rating.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                if ((rating[i] < rating[j] && rating[j] < rating[k]) || (rating[i] > rating[j] && rating[j] > rating[k]))\\n                    count++;\\n                }", "class Solution {\\n    public int numTeams(int[] rating) {\\n        int n=rating.length;\\n        \\n        int total=0;\\n        for(int i=1;i<n-1;i++){\\n            int leftless=0; "]}
{"id": "1227", "ref_java": ["class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }", "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }", "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }"]}
{"id": "1228", "ref_java": ["class Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        ", "class Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                ", "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int d_x1 = x_center - x1;\\n        int d_x2 = x_center - x2;\\n        int d_y1 = y_center - y1;\\n        int d_y2 = y_center - y2;\\n        int square = radius * radius;\\n        int x_top = x_center + radius;\\n        int x_bottom = x_center - radius;\\n        int y_top = y_center + radius;\\n        int y_bottom = y_center - radius;\\n        boolean insideX = (x_center >= x1) && (x_center <= x2);\\n        boolean insideY = (y_center >= y1) && (y_center <= y2);\\n        \\n        if ((d_x1 * d_x1 + d_y1 * d_y1 <= square) || (d_x2 * d_x2 + d_y1 * d_y1 <= square) || (d_x1 * d_x1 + d_y2 * d_y2 <= square) || (d_x2 * d_x2 + d_y2 * d_y2 <= square)) {\\n            return true;\\n        }"]}
{"id": "1229", "ref_java": ["class Solution {\\n    public int numSteps(String s) {\\n        int count = 0;\\n        int carry = 0;\\n        \\n        for(int i = s.length() - 1; i >= 1; i--) {\\n            int num = s.charAt(i) - \\'0\\';\\n            \\n            ", "class Solution {\\n    public int numSteps(String s) {\\n         int steps = 0;\\n         int carry=0;\\n        int n = s.length();\\n        for (int i = n-1; i >= 1; i--) {\\n            int ch = s.charAt(i)-\\'0\\';\\n            if ((ch+carry)== 1) {\\n                carry=1;\\n                steps=steps+2;\\n\\n            }", "class Solution {\\n    public int numSteps(String s) {\\n         int steps = 0;\\n         int carry=0;\\n        int n = s.length();\\n        for (int i = n-1; i >= 1; i--) {\\n            int ch = s.charAt(i)-\\'0\\';\\n            if ((ch+carry)== 1) {\\n                carry=1;\\n                steps=steps+2;\\n\\n            }"]}
{"id": "1230", "ref_java": ["class Solution {\\n    public String longestDiverseString(int a, int b, int c) {\\n      \\n        int a_count = 0;\\n        int b_count = 0;\\n        int c_count = 0;\\n        \\n        int total = a + b + c;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0 ;i < total; i++)\\n        {\\n            if( (a >= b && a >= c && a_count < 2) || (b_count == 2 && a > 0) || (c_count == 2 && a > 0) ){\\n                sb.append(\\'a\\');\\n                a--;\\n                a_count++;\\n                b_count=0;\\n                c_count=0;\\n            }", "class Solution {\\n    public String longestDiverseString(int a, int b, int c) {\\n      \\n        int a_count = 0;\\n        int b_count = 0;\\n        int c_count = 0;\\n        \\n        int total = a + b + c;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0 ;i < total; i++)\\n        {\\n            if( (a >= b && a >= c && a_count < 2) || (b_count == 2 && a > 0) || (c_count == 2 && a > 0) ){\\n                sb.append(\\'a\\');\\n                a--;\\n                a_count++;\\n                b_count=0;\\n                c_count=0;\\n            }", "class Solution {\\n    public String longestDiverseString(int a, int b, int c) {\\n        int totalSize = a + b + c;\\n        int A = 0;\\n        int B = 0;\\n        int C = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i<totalSize; i++) {\\n            "]}
{"id": "1231", "ref_java": ["class Solution {\\n    public int[] processQueries(int[] queries, int m) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=m;i++) al.add(i);\\n        int ans[]=new int[queries.length];\\n        int idx=0;\\n        for(int i=0;i<queries.length;i++){\\n            ans[idx++]= al.indexOf(queries[i]) ;\\n            al.remove(al.indexOf(queries[i]));\\n            al.add(0,queries[i]);\\n        }", "class Solution {\\n    public int[] processQueries(int[] queries, int m) {\\n        int n = queries.length;\\n        int[] arr = new int[m],\\n        retarr = new int[n];\\n\\n        for(int i=1; i<=m; i++){\\n            arr[i-1] = i;\\n        }", "class Solution {\\n    public int[] processQueries(int[] queries, int m) {\\n        int[] arr = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            arr[i] = i + 1;\\n        }"]}
{"id": "1232", "ref_java": ["class Solution {\\n    public String entityParser(String text) {\\n        Map<String, Character> map = init_map();\\n        StringBuilder str = new StringBuilder();\\n        int i=0, j=0;\\n        while(i<text.length()){\\n            if(text.charAt(i)==\\'&\\'){\\n                StringBuilder s = new StringBuilder();\\n                j=i+1;\\n                while(j<text.length() && text.charAt(j)!=\\';\\' && text.charAt(j)!=\\'&\\') {\\n                    s.append(text.charAt(j));\\n                    j++;\\n                }", "class Solution {\\n    public String entityParser(String text) {\\n        text = text.replace(\"&gt;\", \">\");\\n        text = text.replace(\"&quot;\", \"\\\\\"\");\\n        text = text.replace(\"&apos;\", \"\\'\");\\n        text = text.replace(\"&lt;\", \"<\");\\n        text = text.replace(\"&frasl;\", \"/\");\\n        text = text.replace(\"&amp;\", \"&\");\\n        \\n        return text;\\n    }", "class Solution {\\n    public String entityParser(String text) {\\n        text = text.replace(\"&gt;\", \">\");\\n        text = text.replace(\"&quot;\", \"\\\\\"\");\\n        text = text.replace(\"&apos;\", \"\\'\");\\n        text = text.replace(\"&lt;\", \"<\");\\n        text = text.replace(\"&frasl;\", \"/\");\\n        text = text.replace(\"&amp;\", \"&\");\\n        \\n        return text;\\n    }"]}
{"id": "1233", "ref_java": ["class Solution {\\n\\n    static long helper(int n , long dp[]){\\n        if(n==1 || n==2) return dp[n-1] = 1;\\n\\n        if(dp[n-1]!=0) return dp[n-1];\\n        else return dp[n-1] = helper(n-1,dp)+helper(n-2,dp);\\n    }", "class Solution {\\n    public int findMinFibonacciNumbers(int k) {\\n        \\n        ", "class Solution {\\n    public int findMinFibonacciNumbers(int k) {\\n        List<Integer> fib = new ArrayList<>();\\n        int a = 1;\\n        int b = 1;\\n        fib.add(1);\\n        fib.add(1);\\n        int cur = 0;\\n        while (true) {\\n            cur = a+b;\\n            if (cur>k) break;\\n            a = b;\\n            b = cur;\\n            fib.add(b);\\n        }"]}
{"id": "1234", "ref_java": ["class Solution {\\n    private void dfs(int n, int k, String chars, int index, int[] count, StringBuilder s, String[] res) {\\n        if (s.length() == n) {\\n            if (count[0] == k)\\n                res[0] = s.toString();\\n            return;\\n        }", "class Solution {\\n    public String getHappyString(int n, int k) {\\n        ", "class Solution {\\n    int cnt = 0;\\n    String res = \"\";\\n    public String getHappyString(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        dfs(sb,n,k);\\n\\n        return res;\\n    }"]}
{"id": "1235", "ref_java": ["class Solution {\\r\\n    public List<List<String>> displayTable(List<List<String>> arr) {\\r\\n        HashMap<Integer,HashMap<String,Integer>> hp = new HashMap<>();\\r\\n        ArrayList<String> str = new ArrayList<>();\\r\\n        HashSet<String> hs = new HashSet<>();\\r\\n\\r\\n        for(var x : arr){\\r\\n            int a = Integer.valueOf(x.get(1));\\r\\n            String k = x.get(2);\\r\\n\\r\\n            if(!hs.contains(k)) str.add(k);\\r\\n\\r\\n            hs.add(k);\\r\\n\\r\\n            if(hp.containsKey(a)){\\r\\n                HashMap<String,Integer> h = hp.get(a);\\r\\n                if(h.containsKey(k)){\\r\\n                    h.put(k,h.get(k)+1);\\r\\n                }", "class Solution {\\n    public List<List<String>> displayTable(List<List<String>> orders) {\\n\\t\\n        List<List<String>> table = new ArrayList<>();\\n        \\n        HashMap<String,HashMap<Integer,Integer>> map = new HashMap<>();\\n        \\n        TreeSet<Integer> tables = new TreeSet<>();\\n        \\n        TreeSet<String> items = new TreeSet<>();\\n        \\n        for(List<String> order:orders)\\n        {\\n            int tableNumber = Integer.parseInt(order.get(1));\\n            String item = order.get(2);\\n            \\n            items.add(item);\\n            \\n            tables.add(tableNumber);\\n            \\n            if(map.containsKey(item))\\n            {\\n                HashMap<Integer,Integer> m = map.get(item);\\n                m.put(tableNumber,m.getOrDefault(tableNumber,0)+1);\\n                map.put(item,m);\\n            }", "class Solution {\\r\\n    public List<List<String>> displayTable(List<List<String>> orders) {\\r\\n        TreeSet<String> ts= new TreeSet<>();\\r\\n        HashMap<String, HashMap> table= new HashMap<>();\\r\\n\\r\\n        for(List<String> l1: orders){\\r\\n            String tableNo= l1.get(1);\\r\\n            String item= l1.get(2);\\r\\n            ts.add(item);\\r\\n\\r\\n            if(table.containsKey(tableNo)){\\r\\n                HashMap<String, Integer> tableOrder= table.get(tableNo); \\r\\n                tableOrder.put(item, tableOrder.getOrDefault(item, 0)+1);\\r\\n            }"]}
{"id": "1236", "ref_java": ["class Solution {\\n    public int minNumberOfFrogs(String croakOfFrogs) {\\n        int c=0, r=0, o=0, a=0;\\n        int max =0;\\n\\n        for(char ch:croakOfFrogs.toCharArray()){\\n            if(ch==\\'c\\'){\\n                c++;\\n            }", "class Solution {\\n    public int minNumberOfFrogs(String croakOfFrogs) {\\n        int n = croakOfFrogs.length();\\n        int idx = 0;\\n        int ans = 0;\\n        int curr = 0;\\n        int max_frogs = n/5;\\n        if (n%5!=0) return -1;\\n        int[] freq = new int[] {0, 0, 0, 0, 0}", "class Solution {\\n    public int minNumberOfFrogs(String croakOfFrogs) {\\n        int c=0, r=0, o=0, a=0;\\n        int max =0;\\n\\n        for(char ch:croakOfFrogs.toCharArray()){\\n            if(ch==\\'c\\'){\\n                c++;\\n            }"]}
{"id": "1237", "ref_java": ["class Solution {\\n    public int maxScore(int[] cardPoints, int k) {\\n        int len = cardPoints.length;\\n        int st = len - k;\\n        int end = st;\\n        int sum = 0;\\n        int res = 0;\\n        for(int i = 0; i < k * 2; i++){\\n            sum += cardPoints[end % len];\\n            if(i >= k - 1){\\n                res = Math.max(res, sum);\\n                sum -= cardPoints[st % len];\\n                st++;\\n            }", "class Solution {\\n    public int maxScore(int[] cardPoints, int k) {\\n        int len = cardPoints.length;\\n        int st = len - k;\\n        int end = st;\\n        int sum = 0;\\n        int res = 0;\\n        for(int i = 0; i < k * 2; i++){\\n            sum += cardPoints[end % len];\\n            if(i >= k - 1){\\n                res = Math.max(res, sum);\\n                sum -= cardPoints[st % len];\\n                st++;\\n            }", "class Solution {\\n    public int maxScore(int[] C, int K) {\\n        int total = 0;\\n        for (int i = 0; i < K; i++) total += C[i];\\n        int best = total;\\n        for (int i = K - 1, j = C.length - 1; i >= 0; i--, j--) {\\n            total += C[j] - C[i];\\n            best = Math.max(best, total);\\n        }"]}
{"id": "1238", "ref_java": ["class Solution {\\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\\n        ArrayList<int[]> list = new ArrayList<>();\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < nums.get(i).size(); j++) {\\n                list.add(new int[]{nums.get(i).get(j), i, j}", "class Solution {\\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\\n        int count = 0;\\n\\n        List<List<Integer>> lists = new ArrayList<>();\\n        for (int i = 0; i < nums.size(); i++) {\\n            List<Integer> row = nums.get(i);\\n\\n            for (int j = 0; j < row.size(); j++) {\\n                int idx = i + j;\\n\\n                if (lists.size() < idx + 1) {\\n                    lists.add(new ArrayList<>());\\n                }", "class Solution {\\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\\n        ArrayList<int[]> list = new ArrayList<>();\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < nums.get(i).size(); j++) {\\n                list.add(new int[]{nums.get(i).get(j), i, j}"]}
{"id": "1239", "ref_java": ["class Solution {\\n    public int maxDiff(int num) {\\n        StringBuilder max = new StringBuilder(num+\"\");\\n        StringBuilder min = new StringBuilder(num+\"\");\\n        \\n        int n = max.length();\\n        int i=0;\\n        char toSet = \\'9\\';\\n        while(i<n && max.charAt(i) == \\'9\\'){\\n            i++;\\n        }", "class Solution {\\n    public int maxDiff(int num) {\\n        List<Integer> minnum = new ArrayList<>(), maxnum = new ArrayList<>();\\n\\n        while(num > 0){\\n            minnum.add(num%10);\\n            maxnum.add(num%10);\\n            num /= 10;\\n        }", "class Solution {\\n    public int maxDiff(int num) {\\n        List<Integer> minnum = new ArrayList<>(), maxnum = new ArrayList<>();\\n\\n        while(num > 0){\\n            minnum.add(num%10);\\n            maxnum.add(num%10);\\n            num /= 10;\\n        }"]}
{"id": "1240", "ref_java": ["class Solution {\\n    public boolean checkIfCanBreak(String s1, String s2) {\\n        char[] a = s1.toCharArray(), b = s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        int more = 0, less = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            int diff = a[i] - b[i];\\n            if (diff >= 0) more++;\\n            if (diff <= 0) less++;\\n        }", "class Solution {\\n    public boolean checkIfCanBreak(String s1, String s2) {\\n        char[] c1=s1.toCharArray();\\n        char[] c2=s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        boolean flag=true;\\n        int j=0;\\n        for(int i=0;i<c1.length;i++)\\n        {\\n            if(c1[i]<c2[i])\\n            {\\n                flag=true;\\n                j=i;\\n                break;\\n            }", "class Solution {\\n    public boolean checkIfCanBreak(String s1, String s2) {\\n        char[] c1=s1.toCharArray();\\n        char[] c2=s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        boolean flag=true;\\n        int j=0;\\n        for(int i=0;i<c1.length;i++)\\n        {\\n            if(c1[i]<c2[i])\\n            {\\n                flag=true;\\n                j=i;\\n                break;\\n            }"]}
{"id": "1241", "ref_java": ["class Solution {\\n\\n    static final BiFunction<Integer, Integer, Integer> INCREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return 1;\\n        }", "class Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        TreeSet<Integer> set = new TreeSet<>((a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]);\\n        set.add(0);\\n        int res = 1;\\n        for (int right = 1; right < nums.length; right++) {\\n            set.add(right);\\n            while (nums[set.last()] - nums[set.first()] > limit) {\\n                set.remove(left++);\\n            }", "class Solution {\\n\\n    static final BiFunction<Integer, Integer, Integer> INCREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return 1;\\n        }"]}
{"id": "1242", "ref_java": ["class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> result = new ArrayList<>();  ", "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        Stack<Integer> stack = new Stack<>();\\n        List<String> res = new ArrayList<>();\\n        int i=0, c=1;\\n        while(true){\\n\\n                stack.push(c);\\n                res.add(\"Push\");\\n                c++;\\n\\n            if(stack.peek()==target[i]){\\n                i++;\\n            }", "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> ans = new ArrayList<>();\\n        int i = 1;\\n\\n        for (int a : target) {\\n            while (i < a) {\\n                ans.add(\"Push\");\\n                ans.add(\"Pop\");\\n                i++;\\n            }"]}
{"id": "1243", "ref_java": ["class Solution {\\n    public int countTriplets(int[] arr) {\\n            ", "class Solution {\\n    public int countTriplets(int[] arr) {\\n        int count = 0;\\n\\n        for(int i = 0; i < arr.length-1; i++)\\n            for(int j = i+1; j < arr.length; j++)\\n                for(int k = j; k < arr.length; k++){\\n                    int a = arr[i];\\n                    int b = arr[j];\\n\\n                    for(int l = i+1; l < j; l++)\\n                        a = a^arr[l];\\n\\n                    for(int l = j+1; l <= k; l++)\\n                        b = b^arr[l];\\n\\n                    if(a == b)\\n                        count++;\\n                }", "class Solution {\\n    public int countTriplets(int[] arr) {\\n        int res=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            int val=arr[i];\\n            for(int k=i+1;k<arr.length;k++)\\n             {\\n                val=val^arr[k];\\n                if(val==0)\\n                {\\n                 res+=(k-i);\\n                 }"]}
{"id": "1244", "ref_java": ["class Solution {\\n        public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n            Map<Integer, List<Integer>> graph = new HashMap<>();\\n            for (int i = 0; i < n; i++) {\\n                graph.put(i, new ArrayList<>());\\n            }", "class Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> map = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            map.add(new ArrayList<Integer>(0));\\n        }", "class Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int l=0;\\n        for(int i=0;i<hasApple.size();i++){\\n            if(hasApple.get(i)==false)l++;\\n            else break;\\n        }"]}
{"id": "1245", "ref_java": ["class Solution {\\n        int gcd(int a, int b) {\\n            return a == 0 ? b : gcd(b % a, a);\\n         }", "class Solution {\\n    public List<String> simplifiedFractions(int n) {\\n        List<String> ans=new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<=n;j++){\\n                if(gcd(i,j)==1) ans.add(i+\"/\"+j);\\n            }", "class Solution {\\n    public List<String> simplifiedFractions(int n) {\\n        List<String> list = new ArrayList<>() ;\\n        \\n\\t\\tfor(int numerator = 1; numerator< n ; numerator++) {\\n\\t\\t\\tfor(int denominator = numerator+1; denominator<=n; denominator++) {\\n\\t\\t\\t\\tif(gcd(numerator,denominator) == 1) {\\n\\t\\t\\t\\t\\tlist.add(numerator+\"/\"+denominator);\\n"]}
{"id": "1246", "ref_java": ["class Solution {\\n    public int ans = 0;\\n    public int goodNodes(TreeNode root) {\\n        traversal(root,root.val);\\n        return ans;\\n    }", "class Solution {\\n    int count;\\n    public int goodNodes(TreeNode root) {\\n        if(root==null) return 0;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        pq.add(root.val);\\n        count=0;\\n        dfs(root,pq);\\n        return count;\\n    }", "class Solution {\\n    public int goodNodes(TreeNode root) {\\n        return needHelp(root, root.val);\\n    }"]}
{"id": "1247", "ref_java": ["class Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        words[0] = words[0].toLowerCase();\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        words[0] = words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\\n        return String.join(\" \", words);\\n    }", "class Solution {\\n    public String arrangeWords(String text) {\\n        text = text.replace(text.charAt(0)+\"\", (char)(text.charAt(0)+32)+\"\");\\n\\n        String[] arr = text.split(\" \");\\n        Arrays.sort(arr, new Comparator<String>(){\\n            public int compare(String s1, String s2){\\n                return Integer.compare(s1.length(), s2.length());\\n            }", "class Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        words[0] = words[0].toLowerCase();\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        words[0] = words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\\n        return String.join(\" \", words);\\n    }"]}
{"id": "1248", "ref_java": ["class Solution {\\n    public List<Integer> peopleIndexes(List<List<String>> favoriteCompanies) {\\n\\n        ", "class Solution {\\n    public List<Integer> peopleIndexes(List<List<String>> fav) {\\n        Set<String>[] arr = new Set[fav.size()];\\n        int i = 0 ;\\n        for( var el : fav){\\n            arr[i] = new HashSet<>();\\n            for( var inel :el) arr[i].add(inel);\\n            i++;\\n        }", "class Solution {\\n    public List<Integer> peopleIndexes(List<List<String>> fav) {\\n        Set<String>[] arr = new Set[fav.size()];\\n        int i = 0 ;\\n        for( var el : fav){\\n            arr[i] = new HashSet<>();\\n            for( var inel :el) arr[i].add(inel);\\n            i++;\\n        }"]}
{"id": "1249", "ref_java": ["class Solution {\\n    public int maxVowels(String S, int k) {\\n                            BEATS 40% RUNTIME <!-- --> -->\\n    ", "class Solution {\\n    public int maxVowels(String s, int k) {\\n        int max=-999;\\n        int c=0,p=0;\\n        int [] arr =new int[123];\\n        arr[\\'a\\']=1;\\n        arr[\\'e\\']=1;\\n        arr[\\'u\\']=1;\\n        arr[\\'i\\']=1;\\n        arr[\\'o\\']=1;\\n        for(int i=0;i<s.length();i++){\\n           if(i<k){\\n               c+=arr[s.charAt(i)];\\n           }", "class Solution {\\n    public int maxVowels(String s, int k) {\\n\\n            HashSet<Character> set= new HashSet<>();\\n                set.add(\\'a\\');\\n                set.add(\\'e\\');\\n                set.add(\\'i\\');\\n                set.add(\\'o\\');\\n                set.add(\\'u\\');\\n            int vowel=0;\\n            for(int i=0;i<k;i++)\\n                if(set.contains(s.charAt(i))) vowel++;\\n            \\n            int maxvowel=vowel;\\n\\n            for(int i=k;i<s.length();i++){\\n                if(set.contains(s.charAt(i-k))) vowel--;\\n                if(set.contains(s.charAt(i))) vowel++;\\n                maxvowel= Math.max(maxvowel, vowel);\\n            }"]}
{"id": "1250", "ref_java": ["class Solution {\\n    static Map<Integer,Integer> map;\\n    static int count=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        map=new HashMap<>();\\n        count=0;\\n        dfs(root);\\n        return count;\\n    }", "class Solution {\\n    int ans = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        dfs(root, 0);\\n        return ans;\\n    }", "class Solution {\\n  private int digits[], ans;\\n  \\n  private void isPolindrome(){\\n    boolean odd = false;\\n    \\n    for(int n: digits)\\n      if( (n&1) == 1 )\\n        if(odd) return;\\n        else odd = true;\\n     \\n    ans++;\\n  }"]}
{"id": "1251", "ref_java": ["class Solution {\\n    public boolean hasAllCodes(String s, int k) {\\n       HashMap<String,Integer> hashMap = new HashMap<>();\\n        int totalNum = (int)Math.pow(2,k);\\n        for (int i=0;i<=s.length()-k;i++){\\n            hashMap.put(s.substring(i,i+k),1);\\n        }", "class Solution {\\n    public boolean hasAllCodes(String s, int k) {\\n        Set<String> codes = new HashSet<>();\\n        int total = 1 << k;\\n        \\n        for (int i=0; i+k<=s.length(); i++) {\\n            codes.add(s.substring(i, i+k));\\n            if (codes.size() == total) return true;\\n        }", "class Solution {\\n    public boolean hasAllCodes(String s, int k) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i = k; i <= s.length(); i++){\\n            set.add(s.substring(i - k, i));\\n        }"]}
{"id": "1252", "ref_java": ["class Solution {\\n    public List<Boolean> checkIfPrerequisite(int n, int[][] prerequisites, int[][] queries) {\\n        \\n        boolean adjMatrix[][] = new boolean[n][n];\\n        \\n        for (int[] i : prerequisites){\\n            adjMatrix[i[0]][i[1]] = true;\\n        }", "class Solution {\\n    public void fillGraph(boolean[][] graph, int i, boolean[] visited){\\n        if (visited[i])\\n            return;\\n        visited[i] = true;\\n        for (int j=0;j<graph[i].length;j++){\\n            if (graph[i][j]){\\n                fillGraph(graph, j, visited);\\n                for (int k=0;k<graph[j].length;k++){\\n                    if (graph[j][k])\\n                        graph[i][k] = true;\\n                }", "class Solution {\\n    public void fillGraph(boolean[][] graph, int i, boolean[] visited){\\n        if (visited[i])\\n            return;\\n        visited[i] = true;\\n        for (int j=0;j<graph[i].length;j++){\\n            if (graph[i][j]){\\n                fillGraph(graph, j, visited);\\n                for (int k=0;k<graph[j].length;k++){\\n                    if (graph[j][k])\\n                        graph[i][k] = true;\\n                }"]}
{"id": "1253", "ref_java": ["class Solution {\\n    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\\n        ArrayList<Integer> horizontal = new ArrayList<>();\\n        ArrayList<Integer> vertical = new ArrayList<>();\\n        for(int el: horizontalCuts){\\n            horizontal.add(el);\\n        }", "class Solution {\\n    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\\n        Arrays.sort(horizontalCuts);\\n        Arrays.sort(verticalCuts);\\n\\n        long maxHightOfPiece = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);\\n        long maxWidthOfPiece = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);\\n\\n        for(int i = 1; i < horizontalCuts.length; i++) {\\n            maxHightOfPiece = Math.max(maxHightOfPiece, horizontalCuts[i] - horizontalCuts[i-1]);\\n        }", "class Solution {\\n    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\\n        "]}
{"id": "1254", "ref_java": ["class Solution {\\n  public int minReorder(int n, int[][] connections) {\\n    LinkedList<int[]>[] g = new LinkedList[n];\\n    for(int i = 0; i != n; ++i) g[i] = new LinkedList<>();  ", "class Solution {\\n    public int minReorder(int n, int[][] connections) {\\n\\n        HashMap<Integer,List<Integer>> adjc = new HashMap<>();\\n        HashSet<List<Integer>> edges = new HashSet<>();\\n        HashSet<Integer> visited = new HashSet();\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        int changes =0;\\n\\n\\n        for( int[] a : connections)\\n        {\\n            List<Integer> edge = new ArrayList();\\n            edge.add(a[0]);\\n            edge.add(a[1]);\\n            edges.add(edge);\\n            System.out.println(edge);\\n\\n            List<Integer> l1 = adjc.getOrDefault(a[0],new ArrayList());\\n            List<Integer> l2 = adjc.getOrDefault(a[1],new ArrayList());\\n\\n            l1.add(a[1]);\\n            l2.add(a[0]);\\n            adjc.put(a[0],l1);\\n            adjc.put(a[1],l2);\\n        }", "class Solution {\\n    public int minReorder(int n, int[][] connections) {\\n        final var visited = new boolean[n];\\n        final var nodes = new List[n];\\n\\n        for(int[] conn: connections) {\\n            final var list1 = getOrDefault(nodes, conn[0]);\\n            final var list2 = getOrDefault(nodes, conn[1]);\\n\\n            "]}
{"id": "1255", "ref_java": ["class Solution {\\n    public int[] getStrongest(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        int m = arr[(arr.length - 1) / 2];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(\\n                (a, b) -> Math.abs(a - m) == Math.abs(b - m) ? b - a : Math.abs(b - m) - Math.abs(a - m)\\n        );\\n\\n        for (int num : arr) {\\n            pq.offer(num);\\n        }", "class Solution {\\n    public int[] getStrongest(int[] arr, int k) {\\n        Arrays.sort(arr);  \\n        int median=arr[(arr.length-1)/2];\\n        int i=0;\\n        int j=arr.length-1;\\n        int res=0;\\n        int[] result=new int[k];\\n        while(res<k)\\n        {\\n\\t\\t", "class Solution {\\n    public int[] getStrongest(int[] arr, int k) {\\n        \\n        "]}
{"id": "1258", "ref_java": ["class Solution {\\n    public int minSumOfLengths(int[] arr, int target) { ", "class Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] left = findMinLengths(0, arr.length, target,arr);\\n        int[] right = findMinLengths(arr.length-1, 0,target,arr);\\n        \\n        for(int i=1;i<arr.length;i++)\\n            left[i] = Math.min(left[i],left[i-1]);\\n        \\n        for(int i=arr.length-2;i>=0;i--)\\n            right[i] = Math.min(right[i],right[i+1]);\\n        \\n        int min = arr.length+1;\\n        \\n        for(int i=0;i<arr.length-1;i++)\\n            min = Math.min(min,left[i] + right[i+1]);\\n        \\n        return min == arr.length+1 ? -1 : min;\\n    }", "class Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] min_len = new int[arr.length];\\n        Arrays.fill(min_len, Integer.MAX_VALUE);\\n        \\n        int sum = 0;\\n        int start = 0;\\n        int res = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int end = 0; end < arr.length; end++){\\n            sum += arr[end];\\n            \\n            while(sum > target){\\n                sum -= arr[start++];\\n            }"]}
{"id": "1259", "ref_java": ["class Solution {\\r\\n\\r\\n    static class Pair{\\r\\n        int num;\\r\\n        int freq;\\r\\n\\r\\n        Pair(int num, int freq){\\r\\n            this.num = num;\\r\\n            this.freq = freq;\\r\\n        }", "class Solution {\\r\\n    class Pair{\\r\\n        int value;\\r\\n        int fre;\\r\\n\\r\\n        Pair(int value, int fre){\\r\\n            this.value = value;\\r\\n            this.fre = fre; \\r\\n        }", "class Solution {\\r\\n\\r\\n    static class Pair{\\r\\n        int num;\\r\\n        int freq;\\r\\n\\r\\n        Pair(int num, int freq){\\r\\n            this.num = num;\\r\\n            this.freq = freq;\\r\\n        }"]}
{"id": "1260", "ref_java": ["class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        long val=(long)m*k;\\n        if( val > bloomDay.length) return -1;\\n\\n        int low=Integer.MAX_VALUE;\\n        int high=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<bloomDay.length;i++){\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }", "class Solution {\\n   public int minDays(int[] bloomDay, int m, int k) {\\n       if((long)m*k>bloomDay.length) return -1;\\n     \\n        int left=1,right=1,mid;\\n        for(int i:bloomDay)\\n        {\\n            left=Math.min(left,i);\\n            right=Math.max(right,i);\\n        }", "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        long val = (long) m * k;\\n        if (val > n) return -1;\\n        \\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\\n        for (int day : bloomDay) {\\n            low = Math.min(day, low);\\n            high = Math.max(day, high);\\n        }"]}
{"id": "1261", "ref_java": ["class Solution {\\n    public String[] getFolderNames(String[] arr) {\\n        int n = arr.length;\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        String ans[] = new String[n];\\n\\n        for(int i=0; i<n; i++){\\n            if(hp.containsKey(arr[i])){\\n                int val = hp.get(arr[i]);\\n                StringBuilder s = new StringBuilder(arr[i]);\\n                s.append(\\'(\\');\\n                s.append(val);\\n                s.append(\\')\\');\\n\\n                while(hp.containsKey(s.toString())){\\n                    val++;\\n                    s = new StringBuilder(arr[i]);\\n                    s.append(\\'(\\');\\n                    s.append(val);\\n                    s.append(\\')\\');\\n                }", "class Solution {\\n    public String[] getFolderNames(String[] arr) {\\n        int n = arr.length;\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        String ans[] = new String[n];\\n\\n        for(int i=0; i<n; i++){\\n            if(hp.containsKey(arr[i])){\\n                int val = hp.get(arr[i]);\\n                StringBuilder s = new StringBuilder(arr[i]);\\n                s.append(\\'(\\');\\n                s.append(val);\\n                s.append(\\')\\');\\n\\n                while(hp.containsKey(s.toString())){\\n                    val++;\\n                    s = new StringBuilder(arr[i]);\\n                    s.append(\\'(\\');\\n                    s.append(val);\\n                    s.append(\\')\\');\\n                }", "class Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i=0; i<names.length; i++) {\\n            String current = names[i];\\n            while (map.containsKey(current)) {\\n                int count = map.get(names[i]);\\n                count += 1;\\n                map.put(names[i], count);\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(names[i]);\\n                sb.append(\"(\");\\n                sb.append(count);\\n                sb.append(\")\");\\n                current = sb.toString();\\n            }"]}
{"id": "1262", "ref_java": ["class Solution {\\n    private LinkedList<Integer> dryDays;\\n\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, 1);\\n        dryDays = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) dryDays.add(i);\\n            else res[i] = -1;\\n        }", "class Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer , Integer>lastRain = new HashMap<>();\\n        TreeSet<Integer>dry = new TreeSet<>();\\n        int n = rains.length;\\n        int[] ans = new int[n];\\n\\n        for(int i = 0; i < n; i++){\\n            int x = rains[i];\\n\\n            if(x == 0){\\n                dry.add(i);\\n                ans[i] = 1;\\n            }", "class Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        "]}
{"id": "1263", "ref_java": ["class Solution {\\n    public int kthFactor(int n, int k) {\\n        List<Integer> factors = new ArrayList<>();\\n        for(int factor = 1; factor <= n; factor++){\\n            if(n % factor == 0)\\n                factors.add(factor);\\n        }", "class Solution {\\n    public int kthFactor(int n, int k) {\\n        if(n==1) return 1;\\n        for(int i=1;i<=n/2;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                k--;\\n                if(k==0) return i;\\n            }", "class Solution {\\n    public int kthFactor(int n, int k)\\n\\t{\\n        List<Integer> ans = new ArrayList<>(); ans.add(1);\\n        int count = 1;\\n\\t\\t\\n        for (int i = 2; i * i <= n; i++) "]}
{"id": "1264", "ref_java": ["class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int count=0;\\n        List<Integer> nm=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                if(count>0)\\n                {\\n                    nm.add(count);\\n                    count=0;\\n                }", "class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int prev = 0; int curr = 0;\\n        int ans = 0;\\n        for(int i: nums){\\n            if(i==1) curr++;\\n            else{\\n                ans = Math.max(ans,curr+prev);\\n                prev = curr;\\n                curr = 0;\\n            }", "class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int n = nums.length;\\n\\n        int left = 0;\\n        int zeros = 0;\\n        int ans = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            if (nums[right] == 0) {\\n                zeros++;\\n            }"]}
{"id": "1265", "ref_java": ["class Solution {\\n    public boolean canArrange(int[] arr, int k) {\\n        int[] frequency = new int[k];\\n        for(int num : arr){\\n            num %= k;\\n            if(num < 0) num += k;\\n            frequency[num]++;\\n        }", "class Solution {\\n    public boolean canArrange(int[] arr, int k) {\\n        HashMap <Integer, Integer> mp= new HashMap<>();\\n        int x=0;\\n        for(int i=0; i<arr.length; i++){\\n            x=arr[i]%k;\\n            if(x<0) x+=k;\\n            if(!mp.containsKey(x)) mp.put(x, 1);\\n            else mp.put(x,mp.get(x)+1);\\n        }", "class Solution {\\n    public boolean canArrange(int[] arr, int k) {\\n\\n        int[] frequency = new int[k];\\n        \\n        for(int num: arr){\\n            int rem = num%k;\\n            if(rem<0){\\n                rem = rem+k;\\n            }"]}
{"id": "1266", "ref_java": ["class Solution {\\n    private static final int MOD = 1000000007;\\n    public int numSubseq(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        long[] powersOfTwo = new long[nums.length+1];\\n        powersOfTwo[0] = 1;\\n        for (int i = 1; i <=nums.length; i++) \\n            powersOfTwo[i] = (powersOfTwo[i - 1] * 2) % MOD;\\n        \\n        int count = 0, right = nums.length - 1, left = 0;\\n        while (left <= right) {\\n            int sum = nums[right] + nums[left];\\n            if (sum > target) {\\n                long seqs = powersOfTwo[right - left]-1;\\n                count = (int)((count + seqs + 1) % MOD);\\n                right--;\\n            }", "class Solution {\\n    public int numSubseq(int[] nums, int target) {\\n        ", "class Solution {\\n    private static final int MOD = (int) (1e9 + 7);\\n\\n    public int numSubseq(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Map<String, Integer> memo = new HashMap<>();\\n        long ans = helper(nums, Integer.MAX_VALUE, Integer.MIN_VALUE, 0, target, memo);\\n        return (int) (ans % MOD);\\n    }"]}
{"id": "1267", "ref_java": ["class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        ", "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int totalDistanceLeft;\\n        int totalDistanceRight;\\n        if (left.length == 0)\\n            totalDistanceLeft = 0;\\n        else \\n            totalDistanceLeft = Arrays.stream(left).max().getAsInt();\\n        if (right.length == 0)\\n            totalDistanceRight = n;\\n        else \\n            totalDistanceRight = Arrays.stream(right).min().getAsInt();\\n        return Math.max(totalDistanceLeft, n-totalDistanceRight);\\n        \\n    }", "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        "]}
{"id": "1268", "ref_java": ["class Solution {\\n    \\n    public int numSubmat(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int[][] arr = new int[n][m];\\n        for(int i = 0; i<n; i++){\\n            int c = 0;\\n            for(int j = m-1; j>=0; j--){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }", "class Solution {\\n\\t\\tpublic int numSubmat(int[][] mat) {\\n\\t\\t\\tint n = mat.length;\\n\\t\\t\\tint m = mat[0].length;\\n\\t\\t\\t", "class Solution {\\n    private int n;\\n    private int res = 0;\\n    \\n    public int numSubmat(int[][] mat) {\\n        this.n = mat[0].length;\\n        \\n        "]}
{"id": "1269", "ref_java": ["class Solution {\\n    static final int MODULO = 1000000007;\\n    public int rangeSum(int[] nums, int n, int left, int right) {\\n        int[] prefixSums = new int[n+1];\\n        for(int i=0;i<n;i++){\\n            prefixSums[i+1] = prefixSums[i] + nums[i];\\n        }", "class Solution {\\n    static final int MODULO = 1000000007;\\n    public int rangeSum(int[] nums, int n, int left, int right) {\\n        int[] prefixSums = new int[n+1];\\n        for(int i=0;i<n;i++){\\n            prefixSums[i+1] = prefixSums[i] + nums[i];\\n        }", "class Solution {\\n    public int rangeSum(int[] nums, int n, int left, int right) {\\n        int index = 0;\\n        int[] sums = new int[n*(n+1)/2];\\n        for(int i = 0; i < n; i++) {\\n            int sum = 0;\\n            for(int j = i; j < n; j++) {\\n                sum = sum + nums[j];\\n                sums[index++] = sum;\\n            }"]}
{"id": "1270", "ref_java": ["class Solution {\\n    public int minDifference(int[] nums) {\\n        if (nums.length<5) return 0;\\n        int ans = 0;\\n        int temp = 0;\\n        Arrays.sort(nums);\\n        int n = nums.length-1;\\n        ans = nums[n-3]-nums[0];\\n        temp = nums[n]-nums[3];\\n        ans = Math.min(ans, temp);\\n        temp = nums[n-1]-nums[2];\\n        ans = Math.min(ans, temp);\\n        temp = nums[n-2]-nums[1];\\n        ans = Math.min(ans, temp);\\n        return ans;\\n        \\n    }", "class Solution {\\n    public int minDifference(int[] arr) {\\n        int n = arr.length;\\n        if(n<=4) return 0;\\n        Arrays.sort(arr);\\n\\n        int a = arr[n-4]-arr[0];  ", "class Solution {\\n    public int minDifference(int[] nums) {\\n        int n = nums.length;\\n        if(n <= 4) return 0;\\n        Arrays.sort(nums);\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < 4; i++){\\n            res = Math.min(res, nums[n - 1 - 3 + i] - nums[i]);\\n        }"]}
{"id": "1271", "ref_java": ["class Solution {\\n    public int numSub(String s) {\\n        if(s.indexOf(\"1\") < 0)\\n            return 0;\\n        int count = 0,res=0, mod = 1_000_000_007;\\n        for(int i=0 ; i < s.length(); i++){\\n            count = s.charAt(i) == \\'1\\' ? count+1 : 0;\\n            res = (res + count) % mod;\\n        }", "class Solution {\\n    public int numSub(String s) {\\n        int i,j;\\n    \\n\\t\\ti=0;j=0;\\n\\t\\tint ans=0;\\n\\t\\twhile(j<s.length())\\n\\t\\t{\\n\\t\\t    if(s.charAt(j)==\\'0\\')\\n\\t\\t    {\\n\\t\\t        i=j+1;\\n\\t\\t        j++;\\n\\t\\t    }", "class Solution {\\n    public int numSub(String s) {\\n        int count = 0, total = 0, mod = 1_000_000_007;\\n        \\n        for (char c : s.toCharArray()) {\\n            count = (c == \\'1\\') ? count + 1 : 0;\\n            total = (total + count) % mod;\\n        }"]}
{"id": "1272", "ref_java": ["class Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\\n        int [] edge;\\n        for(int  i = 0;i< edges.length;i++){\\n            edge = edges[i];\\n            graph.computeIfAbsent(edge[0],k->new ArrayList<>()).add(new Pair<>(edge[1],succProb[i]));\\n            graph.computeIfAbsent(edge[1],k->new ArrayList<>()).add(new Pair<>(edge[0],succProb[i]));\\n        }", "class Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\\n          double[] dp = new double[n];\\n    dp[start] = 1;\\n    while (true) {\\n        boolean k = false;\\n        for (int j = 0; j < edges.length; j++) {\\n            if (dp[edges[j][0]] * succProb[j] > dp[edges[j][1]]) {\\n                dp[edges[j][1]] = dp[edges[j][0]] * succProb[j];\\n                k = true;\\n            }", "class Solution {\\n    public double maxProbability(int n, int[][] edges, double[] succProb, \\n                                 int start, int end) {\\n        double dp[] = new double[n];\\n        dp[start] = 1.0;\\n        boolean changes = true;\\n        while (changes) {\\n            changes = false;\\n            for (int edgeIdx = edges.length - 1; edgeIdx >= 0; edgeIdx--) {\\n                int u = edges[edgeIdx][0];\\n                int v = edges[edgeIdx][1];\\n                double prob = succProb[edgeIdx];\\n                if (dp[v] * prob > dp[u]) {\\n                    dp[u] = dp[v] * prob;\\n                    changes = true;\\n                }"]}
{"id": "1273", "ref_java": ["class Solution {\\n  int [] result;\\n  List<List<Integer>> adj;\\n  boolean[] visited;\\n", "class Solution {\\n  int [] result;\\n  List<List<Integer>> adj;\\n  boolean[] visited;\\n", "class Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n                List<List<Integer>> graph = new ArrayList<List<Integer>>();\\n                for(int i = 0; i<n ; i++) graph.add(new ArrayList<Integer>());\\n                for(int[] edge : edges){\\n                    graph.get(edge[0]).add(edge[1]);\\n                    graph.get(edge[1]).add(edge[0]);\\n                }"]}
{"id": "1274", "ref_java": ["class Solution {\\n    public int numOfSubarrays(int[] arr) {\\n        long ans = 0, odd = 0, even = 0;\\n        for (int num : arr) {\\n            if (num % 2 == 0) {\\n                even ++;\\n            }", "class Solution {\\n    public int numOfSubarrays(int[] arr) {\\n        long ans = 0, odd = 0, even = 0;\\n        for (int num : arr) {\\n            if (num % 2 == 0) {\\n                even ++;\\n            }", "class Solution {\\n    public int numOfSubarrays(int[] arr) {\\n        long ans=0;\\n        int even=0;\\n        int odd=0;\\n        \\n        long sum=0;\\n        \\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            \\n            if(sum%2==0){\\n                ans+=odd;\\n                even++;\\n            }"]}
{"id": "1275", "ref_java": ["class Solution {\\n    public int numSplits(String s) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        for(int i=0; i<s.length() ; i++){\\n            char ch=s.charAt(i);\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)+1);\\n            }", "class Solution {\\n    public int numSplits(String s) {\\n        int[] p=new int[s.length()];\\n        int[] se=new int[s.length()];\\n        Set<Character> s1=new HashSet<>();\\n        Set<Character> s2=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n          s1.add(s.charAt(i));\\n          s2.add(s.charAt(s.length()-1-i));\\n          p[i]=s1.size();\\n          se[i]=s2.size();\\n        }", "class Solution {\\n    public int numSplits(String s) {\\n        \\n        HashMap<Character, Integer> left = new HashMap<>(); \\n        HashMap<Character, Integer> right = new HashMap<>(); \\n        \\n\\t\\t"]}
{"id": "1276", "ref_java": ["class Solution {\\n    public int minFlips(String s) {\\n        int ans = 0;\\n        char crr = \\'0\\';\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=crr){\\n                ans ++;\\n                crr = s.charAt(i);\\n            }", "class Solution {\\n \\n \\n\\t ***Simple solution is to count the number of flips i.e if 0 -> 1 or 1 -> 0.\\n\\t\\tEg :    11110000\\n\\t\\t\\t\\tFirst flip  : 00000000 -> 11111111\\n\\t\\t\\t\\tSecond flip : 11111111 -> 11110000\\n\\t\\t\\t\\t\\n\\t\\tEg :    00001111\\n\\t\\t\\t\\tFirst flip  : 00000000 -> 00001111\\n\\t\\t\\t\\t\\n\\t\\tTherefore the 0\\'s on the leftmost end doesnt count.\\n\\t\\tSo if string starts with zero set intial count to zero else one.*\\n\\t\\t\\n\\t\\tpublic int minFlips(String target) {\\n\\t\\t\\tint flipCount = target.charAt(0) - 48;\\n\\t\\t\\tchar prev = target.charAt(0);\\n\\n\\t\\t\\tfor(char ch : target.toCharArray()){\\n\\t\\t\\t\\tif(ch != prev){\\n\\t\\t\\t\\t\\tflipCount++;\\n\\t\\t\\t\\t\\tprev = ch;\\n\\t\\t\\t\\t}", "class Solution {\\n    public int minFlips(String s) {\\n        int ans = 0;\\n        char crr = \\'0\\';\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=crr){\\n                ans ++;\\n                crr = s.charAt(i);\\n            }"]}
{"id": "1277", "ref_java": ["class Solution {\\n    int count=0;\\n    public int countPairs(TreeNode root, int distance) {\\n        Distance(root,distance);\\n            return count;\\n    }", "class Solution {\\n    short[] zeroDist;   ", "class Solution {\\n    "]}
{"id": "1278", "ref_java": ["class Solution {\\n    public int getWinner(int[] arr, int k) {\\n        int winner = arr[0];\\n        int wins = 0;\\n        \\n        for (int i = 1; i < arr.length; i++) {\\n            if (winner > arr[i])\\n                wins++;\\n            else {\\n                wins = 1;\\n                winner = arr[i];\\n            }", "class Solution {\\n    public int getWinner(int[] arr, int k) {\\n        int current = arr[0]; ", "class Solution {\\n    public int getWinner(int[] arr, int k) {\\n        "]}
{"id": "1279", "ref_java": ["class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] conseq0 = new int[n]; ", "class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] arr = new int[n];\\n        ", "class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }"]}
{"id": "1280", "ref_java": ["class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        ", "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        }", "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }"]}
{"id": "1281", "ref_java": ["class Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }", "class Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }", "class Solution {\\n    public int minInsertions(String s) {\\n         int low = 0, right = 0;\\n         int res = 0, start = 0;\\n         while (start < s.length()) {\\n             char c = s.charAt(start);\\n             if ( c == \\'(\\') {\\n                 low++;\\n             }"]}
{"id": "1282", "ref_java": ["\npublic char findKthBit(int n, int k) {\n        \n        if(n == 1){\n            return '0';\n        }\n        \n        int numberOfColumns = (int)Math.pow(2,n) - 1;\n        int mid = numberOfColumns/2;\n                \n        if(k <= mid){\n            return findKthBit(n-1,k);\n        } else if (k == mid + 1){ \n            return '1';\n        } else {\n           k = numberOfColumns - k + 1;\n           char c = findKthBit(n-1,k);\n           return c == '0' ? '1' : '0';\n        }\n}\n", "\npublic char findKthBit(int n, int k) {\n        \n        if(n == 1){\n            return '0';\n        }\n        \n        int numberOfColumns = (int)Math.pow(2,n) - 1;\n        int mid = numberOfColumns/2;\n                \n        if(k <= mid){\n            return findKthBit(n-1,k);\n        } else if (k == mid + 1){ \n            return '1';\n        } else {\n           k = numberOfColumns - k + 1;\n           char c = findKthBit(n-1,k);\n           return c == '0' ? '1' : '0';\n        }\n}\n", "\npublic char findKthBit(int n, int k) {\n        \n        if(n == 1){\n            return '0';\n        }\n        \n        int numberOfColumns = (int)Math.pow(2,n) - 1;\n        int mid = numberOfColumns/2;\n                \n        if(k <= mid){\n            return findKthBit(n-1,k);\n        } else if (k == mid + 1){ \n            return '1';\n        } else {\n           k = numberOfColumns - k + 1;\n           char c = findKthBit(n-1,k);\n           return c == '0' ? '1' : '0';\n        }\n}\n"]}
{"id": "1283", "ref_java": ["class Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashSet<Integer>h=new HashSet<>();\\n        int c=0,s=0;\\n        h.add(0);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            s+=nums[i];\\n            if(h.contains(s-target)==true)\\n            {\\n                c+=1;\\n                s=0;\\n                h.removeAll(h);\\n                h.add(0);\\n            }", "class Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int answer=0;\\n        int i=0,n=nums.length;\\n\\n        while(i<n)\\n        {\\n            int s=0;\\n            Set<Integer> seen =new HashSet<>();\\n            seen.add(0);\\n            while(i<n)\\n            {\\n                s+=nums[i];\\n                if(seen.contains(s-target))\\n                {\\n                    ++answer;\\n                    break;\\n                }", "class Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashSet<Integer>h=new HashSet<>();\\n        int c=0,s=0;\\n        h.add(0);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            s+=nums[i];\\n            if(h.contains(s-target)==true)\\n            {\\n                c+=1;\\n                s=0;\\n                h.removeAll(h);\\n                h.add(0);\\n            }"]}
{"id": "1284", "ref_java": ["class Solution {\\n    public int minOperations(int n) {\\n        int result = 0;\\n        \\n        if (n % 2 == 0) {\\n            result = (n / 2) * (n / 2);\\n        }", "class Solution {\\n    public int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            int x=(2 * i) + 1;\\n            ans+=n-x;\\n        }", "class Solution {\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            arr[i] = (2*i)+1;\\n        }"]}
{"id": "1285", "ref_java": ["class Solution {\\n    private boolean isPossible(int[] position, int mid, int m) {\\n        int cnt = 1, last = position[0];\\n        for (int i = 1; i < position.length; i++) {\\n            if (position[i] - last >= mid) {\\n                cnt++;\\n                last = position[i];\\n            }", "class Solution {\\n    public int maxDistance(int[] position, int m) {\\n        Arrays.sort(position);\\n        int low=Integer.MAX_VALUE;\\n        int high=0;\\n        for(int i=1;i<position.length;i++){\\n            low=Math.min(low,position[i]-position[i-1]);\\n        }", "class Solution {\\n    public int maxDistance(int[] position, int m) {\\n        Arrays.sort(position);\\n        int lo = 1;\\n        int hi = position[position.length-1]-position[0];\\n        int ans = 1;\\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(canWePlace(position, mid, m))\\n            {\\n                ans = mid;\\n                lo=mid+1;\\n            }"]}
{"id": "1286", "ref_java": ["class Solution {\\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\\n        List<Integer> res = new ArrayList<>();\\n        boolean[] visited = new boolean[n];\\n        boolean[] startCheck = new boolean[n];\\n        HashMap<Integer, List<Integer>> adj = new HashMap<>();\\n        for (List<Integer> edge : edges) {\\n            adj.putIfAbsent(edge.get(0), new ArrayList<>());\\n            adj.get(edge.get(0)).add(edge.get(1));\\n        }", "class Solution {\\n  List<Integer>[] adj;\\n  int[] parent;\\n  boolean[] seen;\\n\\n  private void dfs(int node, int start) {\\n    parent[node] = start;\\n\\n    if (seen[node]) return;\\n    seen[node] = true;\\n\\n    for (var neighbor : adj[node])\\n      dfs(neighbor, start);\\n  }", "class Solution {\\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\\n        "]}
{"id": "1287", "ref_java": ["class Solution {\\n\\n    boolean areAllZeros(int[] nums) {\\n        for(int val : nums) if(val != 0) return false;\\n        return true;\\n    }", "class Solution {\\n    public int minOperations(int[] nums) {\\n        int addOps = 0, mult2max = 0;\\n        for (int n : nums) {\\n            int mult2 = 0;\\n            while (n > 1) {\\n                if (n % 2 == 1) addOps++;\\n                mult2++;\\n                n /= 2;\\n            }", "class Solution {\\n\\n    static int ans = 0;\\n\\n    static void helper(int arr[]){\\n        int n = arr.length;\\n\\n        int sum = -1;\\n        int count = 0;\\n\\n        while(sum!=0){\\n            sum = 0;\\n            count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(arr[i]%2!=0){\\n                    count++;\\n                    arr[i] = arr[i]-1;\\n                }"]}
{"id": "1288", "ref_java": ["class Solution {\\n\\n    static int n;\\n    static int m;\\n    static char arr[][];\\n\\n    static boolean dfs(int r, int c, int parI, int parJ,int visited[][]){\\n        \\n        int dir[][] = {{0,1}", "class Solution {\\n    int count = 0;\\n    public boolean dfs(char[][] grid, int i,int j,int[][] visited, int previ,int prevj, char c){\\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!=c)\\n            return false;\\n       \\n        if(visited[i][j]-visited[previ][prevj]>=3)\\n            return true;\\n\\n        if(visited[i][j]!=0)\\n            return false;\\n        \\n        visited[i][j]=count++;\\n        \\n        return dfs(grid,i+1,j,visited,i,j,c) || dfs(grid,i-1,j,visited,i,j,c) || dfs(grid,i,j+1,visited,i,j,c) || dfs(grid,i,j-1,visited,i,j,c);\\n    }", "class Solution {\\n    public boolean containsCycle(char[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n\\n\\t\\t"]}
{"id": "1289", "ref_java": ["class Solution {\\n    public int maxCoins(int[] piles) {\\n        int n=piles.length, M=0;\\n        int [] freq=new int[10001];\\n    ", "class Solution {\\n    public int maxCoins(int[] piles) {\\n        int maxCoins = 0;\\n        int[] freq = new int[100001];\\n\\n        for (int i : piles) {\\n            freq[i]++;\\n        }", "class Solution {\\n    public int maxCoins(int[] piles) {\\n        Arrays.sort(piles);\\n        int ans = 0;\\n        int n = piles.length;\\n\\n        for (int i = n / 3; i < n; i += 2) {\\n            ans += piles[i];\\n        }"]}
{"id": "1290", "ref_java": ["class Solution {\\n    public int findLatestStep(int[] A, int m) {\\n        int res = -1, n = A.length;\\n        if (n == m) return n;\\n        int[] length = new int[n + 2];\\n        for (int i = 0; i < n; ++i) {\\n            int a = A[i], left = length[a - 1], right = length[a + 1];\\n            length[a - left] = length[a + right] = left + right + 1;\\n            if (left == m || right == m) res = i;\\n        }", "class Solution {\\n    public int findLatestStep(int[] A, int m) {\\n        int res = -1, n = A.length;\\n        if (n == m) return n;\\n        int[] length = new int[n + 2];\\n        for (int i = 0; i < n; ++i) {\\n            int a = A[i], left = length[a - 1], right = length[a + 1];\\n            length[a - left] = length[a + right] = left + right + 1;\\n            if (left == m || right == m) res = i;\\n        }", "class Solution {\\n     public int findLatestStep(int[] arr, int m) {\\n        if(m==arr.length){\\n            return m;\\n        }"]}
{"id": "1291", "ref_java": ["class Solution {\\n    public int getMaxLen(int[] nums) {\\n        int positive = 0, negative = 0;    ", "class Solution {\\n    public int getMaxLen(int[] nums) {\\n        ", "class Solution {\\n    public int getMaxLen(int[] nums) {\\n        int pos = 0, neg = 0, result= 0, N = nums.length;\\n        for(int i=0; i<N; i++){\\n            if(nums[i]==0){\\n                pos=0;\\n                neg=0;\\n            }"]}
{"id": "1292", "ref_java": ["class Solution {\\n    static int mod = (int)1e9+7;\\n    public int numWays(String s) {\\n        int n = s.length(), sum=0;\\n        char[] arr = s.toCharArray();\\n        for(char ch:arr){\\n            sum+=ch-\\'0\\';\\n        }", "class Solution {\\n    public int numWays(String s) {\\n        long n=s.length();\\n        long one=0;", "class Solution {\\n    static int mod = (int)1e9+7;\\n    public int numWays(String s) {\\n        int n = s.length(), sum=0;\\n        char[] arr = s.toCharArray();\\n        for(char ch:arr){\\n            sum+=ch-\\'0\\';\\n        }"]}
{"id": "1293", "ref_java": ["class Solution {\\n    public int findLengthOfShortestSubarray(int[] arr) {\\n        int firstLast=0,lastFirst=arr.length-1;\\n        for(;firstLast<arr.length-1;firstLast++){\\n            if(arr[firstLast]>arr[firstLast+1]) break;\\n        }", "class Solution {\\n    public int findLengthOfShortestSubarray(int[] arr) {\\n        int firstLast=0,lastFirst=arr.length-1;\\n        for(;firstLast<arr.length-1;firstLast++){\\n            if(arr[firstLast]>arr[firstLast+1]) break;\\n        }", "class Solution {\\n   public int findLengthOfShortestSubarray(int[] arr) {\\n\\t\\tint left = 0, right = arr.length - 1, min_subarray_len = arr.length - 1;\\n\\n\\t\\twhile (left < arr.length - 1 && arr[left] <= arr[left + 1])\\n\\t\\t\\tleft++;\\n\\n\\t\\twhile (right > 0 && arr[right] >= arr[right - 1])\\n\\t\\t\\tright--;\\n\\n\\t\\tmin_subarray_len = Math.min(right, arr.length - left - 1); "]}
{"id": "1294", "ref_java": ["class Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        if(nums1.length<=1 || nums2.length<=1 ) return 0;\\n        return cal(nums1,nums2)+cal(nums2,nums1);\\n        \\n    }", "class Solution {\\n    private int countways(int[] nums1, int []nums2){\\n        int count = 0;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int n : nums2) {\\n            map.put((long) n * n, map.getOrDefault((long) n * n, 0) + 1);\\n        }", "class Solution {\\n    public int numTriplets(int[] arr1, int[] arr2) {\\n        int n1 = arr1.length;\\n        int n2 = arr2.length;\\n\\n        HashMap<Long,Integer> hp1 = new HashMap<>();\\n        HashMap<Long,Integer> hp2 = new HashMap<>();\\n\\n        for(int i=0; i<n1; i++){\\n            long a = (long)arr1[i]*(long)arr1[i];\\n            if(hp1.containsKey(a)) hp1.put(a,hp1.get(a)+1);\\n            else hp1.put(a,1);\\n        }"]}
{"id": "1295", "ref_java": ["class Solution {\\n    \\n    \\n", "class Solution {\\n    public int minCost(String c, int[] n) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        int ans=0;\\n        for(int i=0;i<n.length-1;i++){\\n            if(c.charAt(i)==c.charAt(i+1)){\\n                int j=i;\\n                while(j<n.length-1&&c.charAt(j)==c.charAt(j+1)){\\n                    pq.add(n[j++]);\\n                }", "class Solution {\\n    public int minCost(String colors, int[] neededTime) {\\n        \\n       int count = 0;\\n        for(int i=1;i<colors.length();i++){\\n            if(colors.charAt(i)==colors.charAt(i-1)){\\n                if(neededTime[i-1]<=neededTime[i]){\\n                    count+=neededTime[i-1];\\n                    neededTime[i-1] = 0;\\n                }"]}
{"id": "1296", "ref_java": ["class Solution {\\n  public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    int[][] rankings = new int[n][n]; ", "class Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Map<Integer, Integer>> preferenceMap = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (int j = 0; j < n - 1; j++) {\\n                map.put(preferences[i][j], j);\\n            }", "class Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        if (preferences == null || pairs == null) {\\n            return 0;\\n        }"]}
{"id": "1297", "ref_java": ["class Solution {\\n    public int minCostConnectPoints(int[][] points) {\\n        int sz = points.length;\\n        Set<Integer> mst = new HashSet<>();\\n        int minCost  = 0;\\n        int cost[] = new int[sz];\\n        for(int dest = 0; dest < sz; dest++){\\n             cost[dest]  = findCost(points, dest, sz-1);\\n        }", "class Solution {\\n    class Edge implements Comparable<Edge> {\\n        int src[];\\n        int dst[];\\n        int wt;\\n        Edge(int src[],int dst[]){\\n            this.src = src;\\n            this.dst = dst;\\n            wt = Math.abs(src[0]-dst[0]) + Math.abs(src[1]-dst[1]);\\n        }", "class Solution {\\n    public int minCostConnectPoints(int[][] points) {\\n        int res=0, n=points.length, dist[]=new int[n], nn=n, curr=0, next_pnt=0, min_d, inf=Integer.MAX_VALUE;\\n        Arrays.fill(dist, inf-1);\\n\\n        while(nn-->1) { "]}
{"id": "1298", "ref_java": ["class Solution {\\n  public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n    final int kMod = 1_000_000_007;\\n    long ans = 0;\\n    int[] count = new int[nums.length];\\n\\n    for (int[] request : requests) {\\n      final int start = request[0];\\n      final int end = request[1];\\n      ++count[start];\\n      if (end + 1 < nums.length)\\n        --count[end + 1];\\n    }", "class Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        long[] arr=new long[n];\\n        ", "class Solution {\\n    private static final long MAX = (long) 1e9 + 7;\\n\\n    public int maxSumRangeQuery(int[] A, int[][] R) {\\n        int n = A.length;\\n        int[] U = new int[n]; "]}
{"id": "1299", "ref_java": ["class Solution {\\n    public int minSubarray(int[] nums, int p) {\\n        int n = nums.length;\\n        double sum = 0;\\n        for (int i : nums)\\n            sum += i;\\n        if (sum % p == 0.0)\\n            return 0;\\n        HashMap<Integer, Integer> mh = new HashMap<>();\\n        sum %= p;\\n        int s = (int)(sum);\\n        int len = n, mod = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (len == 1)\\n                return 1;\\n            mod = (nums[i] + mod) % p;\\n            mh.put(mod, i);\\n            if (s == mod)\\n                len = Math.min(i + 1, len);\\n            if (mh.get((mod + p - s) % p) != null) \\n                len = Math.min(len, i -  mh.get((mod + p - s) % p));\\n        }", "class Solution {\\n    /*\\n        [3, 1, 10, 2], p = 6\\n        sum = 3 + 1 + 10 + 2 = 16\\n        16 % 6 = 4, we find the shrortest subarray with remainder = 4;\\n        \\n        We use a hashmap with rem at that point as key, and idx as value.\\n        Initially len = n = 4\\n        \\n        At idx -1,  rem = 0;    Map = {0: -1}", "class Solution {\\n    public int minSubarray(int[] nums, int p) {\\n        \\n        long sum = 0;\\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\\n        if (sum % p == 0) return 0;\\n\\t\\t\\n\\t\\tint requiredRem = (int) (sum % p);\\n\\t\\t"]}
{"id": "1300", "ref_java": ["class Solution {\\n    public int maxUniqueSplit(String s) {\\n         \\n        Set<String> temp= new HashSet<>();\\n       return dfs(s,0,temp);\\n        \\n    }", "class Solution {\\n    \\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        split(0,new HashSet<>(),s);\\n        return max;\\n    }", "class Solution {\\n    int maxSplit;\\n    String s;\\n    public int maxUniqueSplit(String s) {\\n        maxSplit = 0;\\n        this.s = s;\\n        helper(0, new HashSet<String>());\\n        return maxSplit;\\n    }"]}
{"id": "1301", "ref_java": ["class Solution {\\n    public int maxProductPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        long[][] dppos = new long[m][n];\\n        long[][] dpneg = new long[m][n];\\n        dppos[0][0] = dpneg[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++) {\\n            dppos[i][0] = dpneg[i][0] = dppos[i - 1][0] * grid[i][0];\\n        }", "class Solution {\\n    public int maxProductPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        long[][] dppos = new long[m][n];\\n        long[][] dpneg = new long[m][n];\\n        dppos[0][0] = dpneg[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++) {\\n            dppos[i][0] = dpneg[i][0] = dppos[i - 1][0] * grid[i][0];\\n        }", "class Solution {\\n    private static final int MODULO = 1_000_000_007;\\n    public int maxProductPath(int[][] grid) {\\n        SignedProduct[][] products = initSignedProducts(grid);\\n        for (int i = 1; i < grid.length; i++) {\\n            for (int j = 1; j < grid[0].length; j++) {\\n                products[i][j] = getBestSignedProduct(grid[i][j], products[i-1][j], products[i][j-1]);\\n            }"]}
{"id": "1302", "ref_java": ["class Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}", "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rotatn = 0;\\n        int cust = 0;\\n        int profit = Integer.MIN_VALUE;\\n        int prRotn = 0;\\n        int cSit = 0;\\n\\n        for(int i = 0 ; i < customers.length ; i++){\\n            cust += customers[i];\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                \\n                cust = cust - 4;\\n                cSit += 4;\\n            }", "class Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}"]}
{"id": "1304", "ref_java": ["class Solution {\\n    private static final int SHIFT = (int) \\'0\\';\\n\\n    public List<String> alertNames(String[] keyName, String[] keyTime) {\\n        final Map<String, PriorityQueue<Integer>> map = new HashMap();\\n\\n        for (int i = 0; i < keyName.length; i++) {\\n            if (!map.containsKey(keyName[i])) {\\n                map.put(keyName[i], new PriorityQueue());\\n            }", "class Solution {\\n    \\n    int timeToMin(String time){\\n        String[] split = time.split(\":\");\\n        int HH = Integer.parseInt(split[0]);\\n        int MM = Integer.parseInt(split[1]);\\n        int HHToMin = HH * 60;\\n        int totalTimeInMin = HHToMin + MM;\\n        return totalTimeInMin;\\n    }", "class Solution {\\n    public List<String> alertNames(String[] keyName, String[] keyTime) {\\n        "]}
{"id": "1305", "ref_java": ["class Solution {\\n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\\n        int rows = rowSum.length, cols = colSum.length;\\n\\n        int[][] result = new int[rows][cols];\\n\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j ++) {\\n                int val = Math.min(rowSum[i], colSum[j]);\\n                rowSum[i] -= val;\\n                colSum[j] -= val;\\n                result[i][j] = val;\\n            }", "class Solution {\\n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\\n        int ans[][]=new int[rowSum.length][colSum.length];\\n\\n        int i=0;\\n        int j=0;\\n        while(i <rowSum.length && j< colSum.length){\\n            int val= Math.min(rowSum[i], colSum[j]);\\n            rowSum[i]-=val;\\n            colSum[j]-=val;\\n            ans[i][j]=val;\\n\\n            if(rowSum[i]==0){\\n                i++;\\n            }", "class Solution {\\n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\\n        int ans[][]=new int[rowSum.length][colSum.length];\\n\\n        int i=0;\\n        int j=0;\\n        while(i <rowSum.length && j< colSum.length){\\n            int val= Math.min(rowSum[i], colSum[j]);\\n            rowSum[i]-=val;\\n            colSum[j]-=val;\\n            ans[i][j]=val;\\n\\n            if(rowSum[i]==0){\\n                i++;\\n            }"]}
{"id": "1306", "ref_java": ["class Solution {\\n    public boolean isEvenOddTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int level = 0; ", "class Solution {\\n    \\n    \\n    public boolean isEvenOddTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new ArrayDeque<>();", "class Solution {\\n    boolean res=true;\\n    LinkedList<TreeNode>q=new LinkedList<>();\\n    List<Integer>b=new ArrayList<>();\\n    HashSet<Integer>h=new HashSet<>();\\n    public boolean isEvenOddTree(TreeNode root) {\\n        traversal(root);\\n        return res;\\n    }"]}
{"id": "1307", "ref_java": ["class Solution {\\n    public int maximalNetworkRank(int n, int[][] roads) {\\n          int degree[]=new int[n];\\n        boolean connected[][]=new boolean[n][n];\\n\\n        for(int a[]:roads){\\n            degree[a[0]]++;\\n            degree[a[1]]++;\\n            connected[a[0]][a[1]] =true;\\n            connected[a[1]][a[0]]=true;\\n        }", "class Solution {\\n    public int maximalNetworkRank(int n, int[][] roads) {\\n        List<Set<Integer>> adj = new ArrayList<>();\\n        int[] indegree = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            adj.add(new HashSet<>());\\n        }", "class Solution {\\n    public int maximalNetworkRank(int n, int[][] roads) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new HashSet<>());\\n        }"]}
{"id": "1308", "ref_java": ["class Solution {\\n    public boolean checkPalindromeFormation(String a, String b) {\\n        for (int i = 0; i < a.length(); i++) {\\n            ", "class Solution {\\n    public boolean checkPalindromeFormation(String a, String b) {\\n\\t\\n\\n", "class Solution {\\n    public boolean checkPalindromeFormation(String a, String b) {\\n\\t\\n\\n"]}
{"id": "1309", "ref_java": ["class Solution {\\n    public int[] bestCoordinate(int[][] towers, int radius) {\\n        int minX = 51, maxX = 0, minY = 51, maxY = 0, max = 0;\\n        int[] res = new int[2];\\n        for(int[] t : towers) {\\n            minX = Math.min(minX, t[0]);\\n            maxX = Math.max(maxX, t[0]);\\n            minY = Math.min(minY, t[1]);\\n            maxY = Math.max(maxY, t[1]);\\n        }", "class Solution {\\n    public int[] bestCoordinate(int[][] towers, int radius) {\\n        int res[] = new int[2];\\n        double maxQuality = 0;\\n        double quality = 0;\\n        int finalX = 0;\\n        int finalY = 0;\\n        for(int i=0; i<51; i++) {\\n            for(int j=0; j<51; j++) {\\n                quality = 0;\\n                for(int[] tower: towers) {\\n                    int x = tower[0]-i;\\n                    int y = tower[1]-j;\\n                    double dist = Math.sqrt(x*x+y*y); \\n                    if(dist <= radius) quality += Math.floor(tower[2]/(1+dist));\\n                }", "class Solution {\\n    public int[] bestCoordinate(int[][] towers, int radius) {\\n        int res[] = new int[2];\\n        double maxQuality = 0;\\n        double quality = 0;\\n        int finalX = 0;\\n        int finalY = 0;\\n        for(int i=0; i<51; i++) {\\n            for(int j=0; j<51; j++) {\\n                quality = 0;\\n                for(int[] tower: towers) {\\n                    int x = tower[0]-i;\\n                    int y = tower[1]-j;\\n                    double dist = Math.sqrt(x*x+y*y); \\n                    if(dist <= radius) quality += Math.floor(tower[2]/(1+dist));\\n                }"]}
{"id": "1310", "ref_java": ["class Solution {\\n    Integer[][][] memo;\\n    int n;\\n    public int numberOfSets(int n, int k) {\\n        this.n = n;\\n        this.memo = new Integer[n+1][k+1][2];\\n        return dp(0, k, 1);\\n    }", "class Solution {\\n    public int numberOfSets(int n, int k) {\\n        long mod = 1000000007;\\n        if(k == 1){\\n            return n*(n-1)/2;\\n        }", "class Solution {\\n    public int numberOfSets(int n, int k) {\\n        long mod = 1000000007;\\n        if(k == 1){\\n            return n*(n-1)/2;\\n        }"]}
{"id": "1311", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public String addNumber(String s, int a, int n) {\\n        char[] c = s.toCharArray();\\n\\n        for(int i=1; i<n; i+=2) {\\n            c[i] = (char)(\\'0\\' + ((c[i]-\\'0\\')+a)%10);\\n        }", "class Solution {\\n    public String rotateRight(String s, int b) {\\n    int len = s.length();\\n    if (len <= 1) {\\n        return s;\\n    }"]}
{"id": "1312", "ref_java": ["class Solution {\\n    int max=0;\\n    public int bestTeamScore(int[] scores, int[] ages) {\\n        int[][] arr = new int[scores.length][2];\\n\\n        for(int i=0;i<scores.length;i++)\\n            arr[i]=new int[]{scores[i],ages[i]}", "class Solution {\\n    public int solve(int[][] ageScorePair, int prev, int idx){\\n        ", "class Solution {\\n    public int bestTeamScore(int[] scores, int[] ages) {\\n        int n = scores.length;\\n        int[][] players = new int[n][2];\\n\\n        for(int i=0;i<n;i++){\\n           players[i][0]=scores[i];\\n           players[i][1]=ages[i];\\n        }"]}
{"id": "1313", "ref_java": ["class Solution {\\n    public Boolean check(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff = arr[1] - arr[0];\\n        \\n        for (int i = 2; i < arr.length; i++) {\\n            if (arr[i] - arr[i - 1] != diff) {\\n                return false;\\n            }", "class Solution {\\n    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {\\n        List<Boolean> ans = new ArrayList<>();\\n        for (int i = 0; i < l.length; i++) {\\n            int[] subArray = Arrays.copyOfRange(nums, l[i], r[i] + 1);\\n            Arrays.sort(subArray);\\n            \\n            if (subArray.length < 2) {\\n                ans.add(true);\\n            }", "class Solution {\\n    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {\\n        List<Boolean> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < l.length; i++) {\\n            int[] subarray = Arrays.copyOfRange(nums, l[i], r[i] + 1);\\n            ans.add(check(subarray));\\n        }"]}
{"id": "1314", "ref_java": ["class Solution {\\r\\n    public int minimumEffortPath(int[][] heights) {\\r\\n        if (heights.length == 0) {\\r\\n            return 0;\\r\\n        }", "class Solution {\\r\\n\\r\\n    ", "class Solution {\\r\\n    public int minimumEffortPath(int[][] heights) {\\r\\n        int rows = heights.length, cols = heights[0].length;\\r\\n        int[][] dist = new int[rows][cols];\\r\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\r\\n        minHeap.add(new int[]{0, 0, 0}"]}
{"id": "1315", "ref_java": ["class Solution {\\n    public int maxWidthOfVerticalArea(int[][] points) {\\n        int[] xSorted = Arrays.stream(points).mapToInt(point -> point[0]).sorted().toArray();\\n\\n        int maxWidth = 0;\\n        for (int i = 0; i < xSorted.length - 1; i++) {\\n            maxWidth = Math.max(maxWidth, xSorted[i + 1] - xSorted[i]);\\n        }", "class Solution {\\n    public int maxWidthOfVerticalArea(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\\n        int diff = 0;\\n        for (int i = 1; i < points.length; i++) {\\n            diff = Math.max(diff, points[i][0] - points[i - 1][0]);\\n        }", "class Solution {\\n    public int maxWidthOfVerticalArea(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        int max_width = 0;\\n\\n        for (int i = 1; i < points.length; i++) {\\n            int width = points[i][0] - points[i - 1][0];\\n            max_width = Math.max(max_width, width);\\n        }"]}
{"id": "1316", "ref_java": ["class Solution {\\n    public int countSubstrings(String s, String t) {\\n        int m = s.length(), n = t.length();\\n\\n        int[][][] dp = new int[m][n][2];\\n        \\n        int res = 0;\\n        ", "class Solution {\\n    public int countSubstrings(String s, String t) {\\n        int n = s.length();\\n        int m = t.length(); \\n        \\n        int [][] lcs = new int[n][m];\\n        int [][] diff = new int[n][m]; ", "class Solution {\\n    public int countSubstrings(String s, String t) {\\n        int m = s.length(), n = t.length();\\n\\n        int[][][] dp = new int[m][n][2];\\n        \\n        int res = 0;\\n        "]}
{"id": "1317", "ref_java": ["class Solution {\\n    public int countVowelStrings(int n) {\\n        ", "class Solution {\\n    public int countVowelStrings(int n) {\\n        int a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        while (--n > 0) {\\n            o += u;\\n            i += o;\\n            e += i;\\n            a += e;\\n        }", "class Solution {\\n    public int countVowelStrings(int n) {\\n        "]}
{"id": "1318", "ref_java": ["class Solution {\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        PriorityQueue<Integer> bricksUsed = new PriorityQueue<>(Collections.reverseOrder());\\n        int i = 0;\\n        for(i=0;i<heights.length-1;i++){\\n            if(heights[i+1] <= heights[i]) continue;\\n\\n            int diff = heights[i+1] - heights[i];\\n\\n            if(diff <= bricks){\\n                bricks -= diff;\\n                bricksUsed.add(diff);\\n            }", "class Solution {\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        PriorityQueue<Integer> bricksUsed = new PriorityQueue<>(Collections.reverseOrder());\\n        int i = 0;\\n        for(i=0;i<heights.length-1;i++){\\n            if(heights[i+1] <= heights[i]) continue;\\n\\n            int diff = heights[i+1] - heights[i];\\n\\n            if(diff <= bricks){\\n                bricks -= diff;\\n                bricksUsed.add(diff);\\n            }", "class Solution {\\n    public int furthestBuilding(int[] H, int B, int L) {\\n        int len = H.length - 1;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int i = 0; i < len; i++) {\\n            int diff = H[i+1] - H[i];\\n            if (diff > 0) {\\n                if (L > 0) {\\n                    pq.add(diff);\\n                    L--;\\n                }"]}
{"id": "1319", "ref_java": ["class Solution {\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> chars = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            chars.put(c, chars.getOrDefault(c, 0) + 1);\\n        }", "class Solution {\\n     public int minDeletions(String s) {\\n        int[] arr = new int[26];\\n        for(char ch : s.toCharArray()) {\\n            arr[ch - \\'a\\']++;\\n        }", "class Solution {\\n    public int minDeletions(String s) {\\n        if(s.length() == 0) return  0 ;\\n            \\n        int[] arr = new int[26] ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i) ;\\n            arr[ch - \\'a\\'] ++ ;\\n        }"]}
{"id": "1320", "ref_java": ["class Solution {\\n\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        int max = 0;\\n\\n        for (int x : inventory) {\\n            max = Math.max(max, x);\\n        }", "class Solution {\\n\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int maxProfit(int[] inventory, int orders) {\\n        int n = inventory.length;\\n        int max = 0;\\n\\n        for (int x : inventory) {\\n            max = Math.max(max, x);\\n        }", "class Solution {\\n    public int maxProfit(int[] inventory, int orders) {\\n        \\n        int mod = 1000000007;\\n        Arrays.sort(inventory);\\n        int curIndex = inventory.length - 1;\\n        int curValue = inventory[curIndex];\\n        long profit = 0;\\n        while (orders > 0) {\\n            while (curIndex >= 0 && inventory[curIndex] == curValue) {\\n                curIndex--;\\n            }"]}
{"id": "1321", "ref_java": ["class Solution {\\n    public int minimumDeletions(String s) {\\n        ", "class Solution {\\n    public int minimumDeletions(String s) {\\n        ", "class Solution {\\n    public int minimumDeletions(String s) {\\n        "]}
{"id": "1322", "ref_java": ["class Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ", "class Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }", "class Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }"]}
{"id": "1323", "ref_java": ["class Solution {\\n    public int co(char arr[],int key){\\n        int c=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==key){\\n                c++;\\n                arr[i]=\\'-\\';\\n            }", "class Solution {\\n   public boolean closeStrings(String word1, String word2) {\\n\\t\\tint len1, len2;\\n\\t\\t\\n\\t\\tif ((len1 = word1.length()) != (len2 = word2.length()))\\n\\t\\t\\treturn false;\\n\\t\\tbyte[] by1 = word1.getBytes(), by2 = word2.getBytes();\\n\\t\\tint[] ch1 = new int[26], ch2 = new int[26];\\n\\n\\t\\tshams(by1, ch1, len1);\\n\\t\\tshams(by2, ch2, len2);\\n\\n\\t\\tfor (int i = 0; i < 26; i++) \\n\\t\\t\\tif (ch1[i] > 0 ^ ch2[i] > 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\tArrays.sort(ch1);\\n\\t\\tArrays.sort(ch2);\\n\\t\\treturn Arrays.equals(ch1, ch2);\\n\\t}", "class Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for(char ch : word1.toCharArray())\\n            arr1[ch - \\'a\\']++;\\n        for(char ch : word2.toCharArray())\\n            arr2[ch - \\'a\\']++;\\n\\n        for(int i=0;i<26;i++) {\\n            if (arr1[i] == arr2[i]) {\\n                continue;\\n            }"]}
{"id": "1324", "ref_java": ["class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int target = -x, n = nums.length;\\n        for (int num : nums) target += num;\\n        \\n        if (target == 0) return n;\\n        \\n        int maxLen = 0, curSum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            curSum += nums[right];\\n            while (left <= right && curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }", "class Solution {\\n    public int minOperations(int[] nums, int targetSum) {\\n        int totalSum = Arrays.stream(nums).sum();\\n        int target = totalSum - targetSum; ", "class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int totalSum = 0; "]}
{"id": "1325", "ref_java": ["class Solution {\\n\\n/*\\n    static String helper(int n, int k){\\n        StringBuilder s = new StringBuilder();\\n        s.append(\"a\".repeat(n));\\n        if(n==k) return s.toString();\\n\\n        k=k-n;\\n        for(int i=0; i<n; i++){\\n            if(k>=25){\\n                s.replace(i,i+1,\"z\");\\n                k=k-25;\\n                if(k==0) break;\\n            }", "class Solution {\\n    public String getSmallestString(int n, int k) \\n    {\\n        char start=\\'z\\';\\n\\n        String ans=\"\";\\n\\n        int buf=n;\\n        int c=n-1;\\n\\n        char ch[] = new char[n];\\n\\n        while(k>0)\\n        {\\n            ", "class Solution {\\n    public String getSmallestString(int n, int k) \\n    {\\n        char start=\\'z\\';\\n\\n        String ans=\"\";\\n\\n        int buf=n;\\n        int c=n-1;\\n\\n        char ch[] = new char[n];\\n\\n        while(k>0)\\n        {\\n            "]}
{"id": "1326", "ref_java": ["class Solution {\\n    public int waysToMakeFair(int[] nums) {\\n        int esum = 0;  ", "class Solution {\\n    public int waysToMakeFair(int[] nums) {\\n        int sumEven = 0, sumOdd = 0, res = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) sumEven += nums[i];\\n            else sumOdd += nums[i];\\n        }", "class Solution {\\n    public int waysToMakeFair(int[] nums) {\\n        int sumEven = 0, sumOdd = 0, res = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) sumEven += nums[i];\\n            else sumOdd += nums[i];\\n        }"]}
{"id": "1327", "ref_java": ["class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        ListNode curr = list1;\\n        ListNode NewNode1 = list1;\\n        ListNode NewNode2 = list1;\\n        \\n        for(int i=0; i<b; i++){\\n            if(i==a-1)  NewNode1 = curr;\\n            curr = curr.next;\\n        }", "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        int count=0;\\n        ListNode ptr=list1,ptr2=list2;\\n        while(count<a-1)\\n        {\\n            ptr=ptr.next;\\n            count++;\\n        }", "class Solution {\\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\\n        \\n        ListNode dummy = new ListNode();\\n        ListNode ans = dummy;\\n        \\n        int len = 0;\\n        \\n        while (list1 != null) {\\n\\t\\n\\t\\t\\t"]}
{"id": "1329", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] stack = new int[k];\\n        for(int i=0,j=0;i<nums.length;i++) {\\n          while(j>0 && stack[j-1]>nums[i] && j+nums.length-i>k) {\\n              j--;\\n          }", "class Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] stack = new int[k];\\n        for(int i=0,j=0;i<nums.length;i++) {\\n          while(j>0 && stack[j-1]>nums[i] && j+nums.length-i>k) {\\n              j--;\\n          }"]}
{"id": "1330", "ref_java": ["class Solution {\\n    public int minMoves(int[] nums, int limit) {\\n        int[] oneMove = new int[2 * limit + 2];\\n        Map<Integer, Integer> noMove = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length / 2; i++){\\n            int j = nums.length - 1 - i;\\n            noMove.merge(nums[i] + nums[j], 1, Integer::sum);\\n            oneMove[Math.min(nums[i], nums[j]) + 1]++;\\n            oneMove[Math.max(nums[i], nums[j]) + limit + 1]--;\\n        }", "class Solution {\\n\\n    ", "class Solution {\\n    public int minMoves(int[] nums, int limit) {\\n        int n = nums.length;\\n\\n        "]}
{"id": "1331", "ref_java": ["class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int count = 0;\\n\\n        ", "class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        int count=0;\\n        \\n        Arrays.sort(nums);\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<j){\\n            if((nums[i] + nums[j]) == k){\\n                count++;\\n                 i++;\\n            j--;\\n            }", "class Solution {\\n    public int maxOperations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int lp = 0, rp = nums.length-1;\\n            while(lp < rp){\\n                if(nums[lp]+nums[rp] == k){\\n                    count++;\\n                    lp++;\\n                    rp--;\\n                }"]}
{"id": "1332", "ref_java": ["class Solution {\\n    public int concatenatedBinary(int n) {\\n        int modulo = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%modulo)+i)%modulo;\\n        }", "class Solution {\\n    ", "class Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            "]}
{"id": "1333", "ref_java": ["class Solution {\\n    public int[] getSumAbsoluteDifferences(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int prefixSum = 0;\\n        int suffixSum = 0;\\n\\n        for (int num : nums) {\\n            suffixSum += num;\\n        }", "class Solution {\\n    public int[] getSumAbsoluteDifferences(int[] nums) {\\n        int sum = 0;\\n        for (int n : nums) {\\n            sum += n;\\n        }", "class Solution {\\n    public int[] getSumAbsoluteDifferences(int[] nums) {\\n        int n = nums.length;\\n        int A = 0, B = 0;\\n        for (int x : nums) {\\n            B += x;\\n        }"]}
{"id": "1334", "ref_java": ["class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int n = aliceValues.length;\\n        \\n        int[][] stoneValues = new int[n][3];\\n        \\n        for(int i = 0; i < n; i++){\\n            stoneValues[i] = new int[]{aliceValues[i], bobValues[i],  (aliceValues[i] + bobValues[i])}", "class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int len = aliceValues.length;\\n        int[][] arr = new int[len][];\\n        for(int i=0; i<len; i++){\\n            arr[i]=new int[]{aliceValues[i]+bobValues[i], aliceValues[i], bobValues[i]}", "class Solution {\\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\\n        int len = aliceValues.length;\\n        int[][] arr = new int[len][];\\n        for(int i=0; i<len; i++){\\n            arr[i]=new int[]{aliceValues[i]+bobValues[i], aliceValues[i], bobValues[i]}"]}
{"id": "1335", "ref_java": ["class Solution {\\n    public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        char charr[] = n.toCharArray();\\n        for(int i=0; i<charr.length; i++){\\n            if(max < charr[i]-\\'0\\')  max = charr[i]-\\'0\\';\\n        }", "class Solution {\\n    public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        char charr[] = n.toCharArray();\\n        for(int i=0; i<charr.length; i++){\\n            if(max < charr[i]-\\'0\\')  max = charr[i]-\\'0\\';\\n        }", "class Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }"]}
{"id": "1336", "ref_java": ["class Solution {\\n    public int stoneGameVII(int[] S) {\\n        int N = S.length;\\n        int[] dp = new int[N];\\n        for (int i = N - 2; i >= 0; i--) {\\n            int total = S[i];\\n            for (int j = i + 1; j < N; j++) {\\n                total += S[j];\\n                dp[j] = Math.max(total - S[i] - dp[j], total - S[j] - dp[j-1]);\\n            }", "class Solution { \\n    public int stoneGameVII(int[] stones) {\\n        int totalSum=0;\\n        for(int i=0; i<stones.length ; i++){\\n            totalSum+=stones[i];\\n        }", "class Solution { \\n    public int stoneGameVII(int[] stones) {\\n        int totalSum=0;\\n        for(int i=0; i<stones.length ; i++){\\n            totalSum+=stones[i];\\n        }"]}
{"id": "1337", "ref_java": ["class Solution {\\n    public int maximumUniqueSubarray(int[] nums) {\\n        short[] nmap = new short[10001];\\n        int total = 0, best = 0;\\n        for (int left = 0, right = 0; right < nums.length; right++) {\\n            nmap[nums[right]]++;\\n            total += nums[right];\\n            while (nmap[nums[right]] > 1) {\\n                nmap[nums[left]]--;\\n                total -= nums[left++];\\n            }", "class Solution {\\n    public int maximumUniqueSubarray(int[] arr) {\\n        \\n        int n = arr.length;\\n        int ans = Integer.MIN_VALUE;\\n\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        int pre[] = new int[n+1];\\n        int sum = 0;\\n        int i = 0;\\n        int j = 0;\\n        while(j<n){\\n            pre[j+1] = pre[j]+arr[j];\\n            if(hp.containsKey(arr[j])){\\n                i = Math.max(i,hp.get(arr[j])+1);\\n            }", "class Solution {\\n    public int maximumUniqueSubarray(int[] nums) {\\n        short[] nmap = new short[10001];\\n        int total = 0, best = 0;\\n        for (int left = 0, right = 0; right < nums.length; right++) {\\n            nmap[nums[right]]++;\\n            total += nums[right];\\n            while (nmap[nums[right]] > 1) {\\n                nmap[nums[left]]--;\\n                total -= nums[left++];\\n            }"]}
{"id": "1338", "ref_java": ["class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int ans = nums[0];\\n        MaxStream<Integer> ms = new MaxStream<Integer> (k, new Comparator<Integer>() {\\n            @Override \\n            public int compare (Integer i, Integer j) {\\n                return i.compareTo(j);\\n            }", "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }", "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int ans = nums[0];\\n        MaxStream<Integer> ms = new MaxStream<Integer> (k, new Comparator<Integer>() {\\n            @Override \\n            public int compare (Integer i, Integer j) {\\n                return i.compareTo(j);\\n            }"]}
{"id": "1339", "ref_java": ["class Solution {\\n    public double averageWaitingTime(int[][] c) {\\n     int n=c.length;\\n     int ct[]=new int[n];\\n     ct[0]=c[0][0]+c[0][1];\\n     for(int i=1;i<n;i++){\\n     ct[i]=ct[i-1]+c[i][1];\\n     if(c[i][0]>ct[i-1]){\\n         ct[i]=c[i][0]+c[i][1];\\n     }", "class Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double total_wait_time=(customers[0][0]+customers[0][1])-customers[0][0];\\n        customers[0][1]=customers[0][0]+customers[0][1];\\n        for(int i=1; i<customers.length; i++){\\n            double temp=customers[i][0];\\n            customers[i][0]=Math.max(customers[i][0],customers[i-1][1]);\\n            customers[i][1]=customers[i][0]+customers[i][1];\\n            total_wait_time+=customers[i][1]-temp;\\n        }", "class Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int n = customers.length;\\n        long chefTime = customers[0][1] + customers[0][0];\\n        long waitTime = customers[0][1];\\n\\n        for(int i=1; i<n; i++){\\n            int arrival = customers[i][0];\\n            int timeRequired = customers[i][1];\\n            chefTime = Math.max(chefTime, arrival);\\n            chefTime += timeRequired;\\n            waitTime += chefTime - arrival;\\n        }"]}
{"id": "1340", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public String maximumBinaryString(String binary) {\\n        int n = binary.length();\\n        StringBuffer ans = new StringBuffer(\"\");\\n        StringBuffer buffer = new StringBuffer(\"\");\\n        int onesAfter1stZero = 0;\\n        boolean found1stZero = false;\\n        for(int i=0;i<n;i++){\\n            if(found1stZero){\\n                if(binary.charAt(i)==\\'0\\')\\n                    ans.append(\\'1\\');\\n                else\\n                    buffer.append(\\'1\\');\\n            }", "class Solution {\\n    public String maximumBinaryString(String binary) {\\n        int lastIdx = -1;\\n        char[] num = binary.toCharArray();\\n\\n        for(int i = 0; i < num.length; i++) {\\n            if(num[i] == \\'0\\') {\\n                if(lastIdx == -1) lastIdx = i;\\n                else lastIdx++;\\n            }"]}
{"id": "1341", "ref_java": ["class Solution {\\n    public int eatenApples(int[] apples, int[] days) {\\n        PriorityQueue<Apple> minHeap = new PriorityQueue<Apple>((a, b) -> (a.validDay - b.validDay));\\n        \\n        ", "class Solution {\\n    public int eatenApples(int[] apples, int[] days) {\\n        PriorityQueue<Node> pq = new PriorityQueue<>((a,b)->(a.day-b.day));\\n\\n        int totaldays = 1;\\n        int ans=0;\\n\\n        int currind=0;\\n\\n        while(currind<days.length  || !pq.isEmpty()){\\n            if(currind<days.length && apples[currind]!=0){\\n                pq.add(new Node(apples[currind], days[currind]+currind));\\n            }", "class Solution {\\n    public int eatenApples(int[] apples, int[] days) {\\n        PriorityQueue<Node> pq = new PriorityQueue<>((a,b)->(a.day-b.day));\\n\\n        int totaldays = 1;\\n        int ans=0;\\n\\n        int currind=0;\\n\\n        while(currind<days.length  || !pq.isEmpty()){\\n            if(currind<days.length && apples[currind]!=0){\\n                pq.add(new Node(apples[currind], days[currind]+currind));\\n            }"]}
{"id": "1342", "ref_java": ["class Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int row=grid.length;\\n        int col=grid[0].length;\\n        \\n        int ans[]=new int[col];\\n        \\n        for(int i=0;i<col;i++){\\n            \\n            int j=0,k=i;\\n            boolean check=false;\\n            \\n            while(j<row && k<col){\\n                if(grid[j][k]==1){\\n                    if((k<col-1 && grid[j][k+1]==-1)  || (k==col-1 && grid[j][k]==1)){\\n                        check=true;\\n                        break;\\n                    }", "class Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        final int[] result = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int cy = 0;\\n            int cx = i;\\n            while(cy < m && !isBlocked(grid, cy, cx)) {\\n                cx += grid[cy][cx];\\n                cy += 1;\\n            }", "class Solution {\\n  public int[] findBall(int[][] g) {\\n\\n    return IntStream.range(0, g[0].length).map(i -> Arrays.stream(g).reduce(i,\\n      (j,r) -> j>=0 && j+r[j]>=0 && j+r[j]<r.length && r[j]==r[j+=r[j]] ? j : -1, (a,b)->0) ).toArray();\\n\\n  }"]}
{"id": "1343", "ref_java": ["class Solution {\\n    int mod = 1000000007;\\n    public int countPairs(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        long res = 0;\\n        for (int num : arr) {\\n            int power = 1;\\n            for (int i = 0; i < 22; i++) {\\n                if (map.containsKey(power - num)) {\\n                    res += map.get(power - num);\\n                    res %= mod;\\n                }", "class Solution {\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : deliciousness){ ", "class Solution {\\n    public int countPairs(int[] d) {\\n        if(d.length==1)\\n            return 0;\\n        Arrays.sort(d);\\n        int max = d[d.length-2]+d[d.length-1];\\n        long count = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int data : d)\\n            map.put(data,map.getOrDefault(data,0)+1);\\n        for(int i=1;i<=max;i*=2){\\n          long temp = 0;\\n            for(int data : d){\\n                if(map.containsKey(i-data)&&i-data==data&&map.get(i-data)>1)\\n                    temp = temp + map.get(i-data)-1;\\n                else if(map.containsKey(i-data)&&i-data!=data)\\n                    temp = temp+map.get(i-data);\\n            }"]}
{"id": "1344", "ref_java": ["class Solution {\\n    public int waysToSplit(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }", "class Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        long res = 0;\\n        ", "class Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        long res = 0;\\n        "]}
{"id": "1345", "ref_java": ["class Solution {\\n    public int maximumGain(String s, int x, int y) {\\n        Deque<Character> deque = new ArrayDeque<>();\\n        int ans = solve(s, x > y? \"ab\" : \"ba\", Math.max(x, y), deque);\\n        StringBuilder sb = new StringBuilder();\\n        while(!deque.isEmpty()){\\n            sb.append(deque.pollLast());\\n        }", "class Solution {\\n    public int maximumGain(String s, int x, int y) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        int ans=0;\\n        if(x>y){\\n            for(char ch:s.toCharArray()){\\n                if(!stack.isEmpty() && (ch==\\'b\\' && stack.peek()==\\'a\\')){\\n                    ans += x;\\n                    stack.pop();\\n                }", "class Solution {\\n    public int maximumGain(String s, int x, int y) {\\n        int ans = 0;\\n        Stack<Character> arr = new Stack<Character>();\\n        if(x>=y)\\n        {\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(!arr.isEmpty()&&arr.peek()==\\'a\\'&&s.charAt(i)==\\'b\\')\\n                {\\n                    ans = ans+x;\\n                    arr.pop();\\n                }"]}
{"id": "1346", "ref_java": ["class Solution {\\n\\n        public int[] constructDistancedSequence(int n) {\\n            int[] ans = new int[n * 2 - 1];\\n            boolean[] visited = new boolean[n + 1];\\n            calc(0, ans, visited, n);\\n            return ans;\\n        }", "class Solution {\\n    Set<Integer> used; ", "class Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int []sol = new int[(2*n)-1];\\n        boolean[] visited = new boolean[n+1];\\n        helper(0,sol,visited,n);\\n        return sol;\\n    }"]}
{"id": "1347", "ref_java": ["class Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n\\n        if(head == null){\\n            return head;\\n        }", "class Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node = new ListNode(0); \\n        node.next = head;\\n        ListNode slow = node;\\n        ListNode fast = node;\\n        for (int i = 0; i < k; i++) {\\n            fast = fast.next;\\n        }", "class Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n\\n        ListNode beg = head, end= head, curr = head;\\n        ListNode newList = head;\\n\\n        "]}
{"id": "1348", "ref_java": ["class Solution {\\n    public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {\\n        int minHamming = 0;\\n        UnionFind uf = new UnionFind(source.length);\\n        for (int [] swap : allowedSwaps) {\\n            int firstIndex = swap[0];\\n            int secondIndex = swap[1];\\n           ", "class Solution {\\n    ", "class Solution {\\n    public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {\\n        \\n        "]}
{"id": "1349", "ref_java": ["class Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        \\n        if(nums.length < 4){\\n            return 0;\\n        }", "class Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        int m = nums.length;\\n        int factor = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i = 0; i < m - 1; i ++) {\\n            for(int j = i + 1; j < m; j ++) {\\n                int curNumber = nums[i] * nums[j];\\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\\n                hm.put(curNumber, curNumberCount);\\n            }", "class Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        int m = nums.length;\\n        int factor = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i = 0; i < m - 1; i ++) {\\n            for(int j = i + 1; j < m; j ++) {\\n                int curNumber = nums[i] * nums[j];\\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\\n                hm.put(curNumber, curNumberCount);\\n            }"]}
{"id": "1350", "ref_java": ["class Solution {\\n    public int largestSubmatrix(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (matrix[i][j] == 1) {\\n                    matrix[i][j] = matrix[i - 1][j] + 1;\\n                }", "class Solution {\\n    public int largestSubmatrix(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        ", "class Solution {\\n    public int largestSubmatrix(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (matrix[i][j] == 1) {\\n                    matrix[i][j] = matrix[i - 1][j] + 1;\\n                }"]}
{"id": "1351", "ref_java": ["class Solution {\\n    private final Map<Integer, Set<Integer>> langToPeople = new HashMap<>();\\n    private int mostSpoken = -1;\\n    private int mostSpokenCount = 0;\\n    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {\\n        Map<Integer, Set<Integer>> peopleToLanguages = initLanguages(languages);  ", "class Solution {\\n    public static int minimumTeachings(int n, int[][] languages, int[][] friendships) {\\n\\n        Map<Integer, Set<Integer>> langSpeakersMap = new HashMap<>();\\n\\n        for (int i = 0; i < languages.length; i++) {\\n            int[] langs = languages[i];\\n            for (int lang : langs) {\\n                if (langSpeakersMap.get(lang) == null) {\\n                    HashSet<Integer> speakersSet = new HashSet<>();\\n                    speakersSet.add(i + 1);\\n                    langSpeakersMap.put(lang, speakersSet);\\n                }", "class Solution {\\n    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {\\n        "]}
{"id": "1352", "ref_java": ["class Solution {\\n    public int[] decode(int[] arr) {\\n        int n = arr.length;\\n        int res[] = new int[n+1];\\n        int x = 1;\\n        for(int i=2; i<=n+1; i++){\\n            x = x^i;\\n        }", "class Solution {\\n    public int[] decode(int[] arr) {\\n        int n = arr.length;\\n        int res[] = new int[n+1];\\n        int x = 1;\\n        for(int i=2; i<=n+1; i++){\\n            x = x^i;\\n        }", "class Solution {\\n    public int[] decode(int[] encoded) {\\n        int[] perm = new int[encoded.length+1];\\n        int x=0;\\n        for(int i=1;i<=perm.length;i++)\\n            x=x^i;\\n        for(int i=0;i<encoded.length;i+=2)\\n            x=x^encoded[i];\\n        perm[perm.length-1]=x;\\n        for(int i=perm.length-2;i>=0;i--)\\n        {\\n            perm[i]=perm[i+1]^encoded[i];\\n        }"]}
{"id": "1353", "ref_java": ["class Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] aCount = new int[26];\\n        int aMax = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            aCount[a.charAt(i) - \\'a\\']++;\\n            aMax = Math.max(aMax, aCount[a.charAt(i) - \\'a\\']);\\n        }", "class Solution {\\n\\n    ", "class Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] c1=new int[26];\\n        int[] c2=new int[26];\\n        for(int i=0;i<a.length();i++){\\n            c1[a.charAt(i)-\\'a\\']++;\\n        }"]}
{"id": "1354", "ref_java": ["class Solution {\\n    public int kthLargestValue(int[][] matrix, int k) \\n    {\\n        List<Integer> list=new ArrayList<>();\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[][] dp=new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    dp[i][j]=matrix[i][j];\\n                }", "class Solution {\\n    public int kthLargestValue(int[][] matrix, int k) \\n    {\\n        List<Integer> list=new ArrayList<>();\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[][] dp=new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    dp[i][j]=matrix[i][j];\\n                }", "class Solution {\\n    public int kthLargestValue(int[][] matrix, int k) {\\n         int m = matrix.length;\\n        int n = matrix[0].length;\\n        Queue<Integer> q = new PriorityQueue<>();   "]}
{"id": "1355", "ref_java": ["class Solution {\\n    public int[] restoreArray(int[][] vals) {\\n        Map<Integer, int[]> pairs = new HashMap<>();\\n        for (int i = 0; i < vals.length; i++) {\\n            if (pairs.containsKey(vals[i][0])) {\\n                pairs.get(vals[i][0])[1] = vals[i][1];\\n            }", "class Solution {\\n  public int[] restoreArray(int[][] adjacentPairs) {\\n    var map = new HashMap<Integer, List<Integer>>();\\n\\n    for (var pair : adjacentPairs) {\\n      map.putIfAbsent(pair[0], new ArrayList<>());\\n      map.putIfAbsent(pair[1], new ArrayList<>());\\n\\n      map.get(pair[0]).add(pair[1]);\\n      map.get(pair[1]).add(pair[0]);\\n    }", "class Solution {\\n    public int[] restoreArray(int[][] adjacentPairs) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n\\n        for (int[] pair : adjacentPairs) {\\n            graph.computeIfAbsent(pair[0], k -> new ArrayList<>()).add(pair[1]);\\n            graph.computeIfAbsent(pair[1], k -> new ArrayList<>()).add(pair[0]);\\n        }"]}
{"id": "1356", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public boolean[] canEat(int[] candiesCount, int[][] queries) {\\n        ", "class Solution {\\n    public boolean[] canEat(int[] candiesCount, int[][] queries) {\\n        boolean[] result = new boolean[queries.length];\\n        long[] candiesComm = new long[candiesCount.length + 1];\\n        for (int i = 1; i <= candiesCount.length; i++) {\\n            candiesComm[i] = candiesComm[i - 1] + candiesCount[i - 1];\\n        }"]}
{"id": "1357", "ref_java": ["class Solution {\\n    public int maxAbsoluteSum(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n           sum= sum+nums[i];\\n           if(sum>max)\\n           max=sum;\\n            if(sum<0)\\n           sum=0;\\n        }", "class Solution {\\n    public int maxAbsoluteSum(int[] nums) {\\n        int sum=0,max=Integer.MIN_VALUE;\\n        ", "class Solution {\\n    public int maxAbsoluteSum(int[] nums) {\\n        int maxi = Integer.MIN_VALUE, mini = Integer.MAX_VALUE;\\n        int cur_max = 0, cur_min = 0;\\n        for(int i=0; i<nums.length; i++){\\n            cur_max = Math.max(nums[i],cur_max+nums[i]);\\n            cur_min = Math.min(nums[i],cur_min+nums[i]);\\n            maxi = Math.max(cur_max,maxi);\\n            mini = Math.min(cur_min,mini);\\n        }"]}
{"id": "1358", "ref_java": ["class Solution {\\n    public int minimumLength(String s) {\\n        int left = 0; \\n        int right = s.length() - 1;\\n        \\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right))\\n                break;\\n            char c = s.charAt(left);\\n            while(left < right && c == s.charAt(left))\\n                left++;\\n            ", "class Solution {\\n    public int minimumLength(String s) {\\n        int left=0;\\n        int right=s.length()-1;\\n\\n        while(left<right && s.charAt(left)==s.charAt(right)){\\n            char ch=s.charAt(left);\\n\\n            while(left<right && s.charAt(left)==ch){\\n                left++;\\n            }", "class Solution {\\n    public int minimumLength(String s) {\\n        int i = 0, j = s.length()-1;\\n        while(i < j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                char ch = s.charAt(i);\\n                while(s.charAt(i) == ch && i < j) i++;\\n                while(s.charAt(j) == ch && i <= j) j--;          \\n            }"]}
{"id": "1359", "ref_java": ["class Solution {\\n    public int maximumScore(int a, int b, int c) {\\n        int maximum = Math.max(a, Math.max(b, c));\\n        int minimum = Math.min(a, Math.min(b, c));\\n        int middle = a + b + c - maximum - minimum;\\n\\n        if (minimum + middle < maximum) {\\n            return minimum + middle;\\n        }", "class Solution {\\n    public int maximumScore(int a, int b, int c) {\\n        ", "class Solution {\\n    public int maximumScore(int a, int b, int c) {\\n        "]}
{"id": "1360", "ref_java": ["class Solution {\\n    public static String largestMerge(String s, String t) {\\n        char[] sarray = s.toCharArray();\\n        char[] tarray = t.toCharArray();\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n        int j = 0;\\n        while (i < sarray.length && j < tarray.length) {\\n            if (sarray[i] > tarray[j]) {\\n                sb.append(sarray[i++]);\\n            }", "class Solution {\\n    public String largestMerge(String word1, String word2) {\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        int j=0;\\n        char[] w1 = word1.toCharArray();\\n        char[] w2 = word2.toCharArray();\\n        \\n        int n1=w1.length;\\n        int n2=w2.length;\\n        \\n        ", "class Solution {\\n    public String largestMerge(String word1, String word2) {\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        int j=0;\\n        char[] w1 = word1.toCharArray();\\n        char[] w2 = word2.toCharArray();\\n        \\n        int n1=w1.length;\\n        int n2=w2.length;\\n        \\n        "]}
{"id": "1361", "ref_java": ["class Solution {\\n    public int countHomogenous(String s) {\\n        long res  = 0;\\n        char[] c = s.toCharArray();\\n        int start =0;\\n        for(int i=0;i<c.length;i++)\\n        {\\n            if(c[i]!=c[start])\\n            {\\n                int appear = i-start;\\n                while(appear>0)\\n                {\\n                    res+=appear;\\n                    appear-=1;\\n                }", "class Solution {\\n    public int countHomogenous(String s) {\\n        int left = 0;\\n        long res = 0;\\n        \\n        for (int right = 0; right < s.length(); right++) {\\n            if (s.charAt(left) == s.charAt(right)) {\\n                res += right - left + 1;\\n            }", "class Solution {\\n  public int countHomogenous(String s) {\\n    var prev = \\'?\\';\\n    var cnt = 1;\\n    var sum = 0;\\n\\n    for (var c : s.toCharArray()) {\\n      if (c != prev) {\\n        cnt = 1;\\n        prev = c;\\n      }"]}
{"id": "1362", "ref_java": ["class Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int min = 0;\\n        int max = 1000000000;\\n        \\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n            int count = 0;\\n            \\n            for (int a: nums) {\\n                count+=(a-1)/mid;\\n            }", "class Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int max = 0;\\n        for(int i:nums){\\n          max = Math.max(i,max);\\n        }", "class Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int min = 0;\\n        int max = 1000000000;\\n        \\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n            int count = 0;\\n            \\n            for (int a: nums) {\\n                count+=(a-1)/mid;\\n            }"]}
{"id": "1363", "ref_java": ["class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        for(int i=0;i<groups.length;i++)\\n        {\\n            int j=0;\\n            int k=0;\\n            for(;j<nums.length && k<groups[i].length;)\\n            {\\n                if(nums[j] == groups[i][k])\\n                {\\n                    k++;\\n                    j++;\\n                }", "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int n=groups.length;\\n        int ncol=groups[0].length;\\n        int row=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j=i;\\n            int col=0;\\n            \\n            while(col<groups[row].length && j<nums.length && groups[row][col]==nums[j])\\n            {\\n                col++;\\n                j++;\\n            }", "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int g = 0, gIdx = 0, e = groups.length - 1, eIdx = groups[groups.length - 1].length - 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (g >= groups.length) break;\\n            if (nums[i] == groups[g][gIdx]) {\\n                gIdx++;\\n                if (gIdx >= groups[g].length) {\\n                    g++;\\n                    gIdx = 0;\\n                }"]}
{"id": "1364", "ref_java": ["class Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n\\n        int[][] matrix = new int[n][m];\\n        for(int[] row: matrix){\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }", "class Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n    int[][] result = new int[isWater.length][isWater[0].length];\\n\\n    Queue<int[]> cells = findWaterCells(isWater, result);\\n    return bfs(cells, result);\\n  }", "class Solution {\\n    \\n    static int[][] DIRECTION = new int[][]{{0, -1}"]}
{"id": "1365", "ref_java": ["class Solution {\\n    public int[] minOperations(String boxes) {\\n        int moves = 0;\\n        int diff = 0;\\n        int[] ans = new int[boxes.length()];\\n        for(int i=0; i<boxes.length(); i++){\\n            for(int j=0; j<boxes.length(); j++){\\n                if(i!=j && boxes.charAt(j)==\\'1\\'){\\n                    diff = Math.abs(j-i);\\n                    moves = moves+diff;\\n                }", "class Solution {\\n    public int[] minOperations(String boxes) {\\n        int moves = 0;\\n        int diff = 0;\\n        int[] ans = new int[boxes.length()];\\n        for(int i=0; i<boxes.length(); i++){\\n            for(int j=0; j<boxes.length(); j++){\\n                if(i!=j && boxes.charAt(j)==\\'1\\'){\\n                    diff = Math.abs(j-i);\\n                    moves = moves+diff;\\n                }", "class Solution {\\n    public int[] minOperations(String boxes) {\\n        int [] m = new int[boxes.length()];\\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes.charAt(j) == \\'1\\' && i !=  j)\\n                    m[i] += Math.abs(i-j);\\n            }"]}
{"id": "1366", "ref_java": ["class Solution {\\n    \\n\\tclosestCost = Integer.MAX_VALUE;\\n    \\n    public void closestCost(int[] toppingCosts, int currIdx, int currCost , int targetCost){\\n        if(Math.abs(targetCost - currCost) < Math.abs(closestCost - targetCost))\\n            closestCost = currCost;\\n        \\n        if(Math.abs(targetCost - currCost) == Math.abs(closestCost - targetCost))\\n            closestCost = Math.min(closestCost , currCost);\\n        \\n        if(currCost < targetCost && currIdx < toppingCosts.length){\\n            closestCost(toppingCosts, currIdx + 1, currCost, targetCost);\\n            closestCost(toppingCosts, currIdx + 1, currCost + toppingCosts[currIdx], targetCost);\\n            closestCost(toppingCosts, currIdx + 1, currCost + 2*toppingCosts[currIdx] , targetCost);\\n        }", "class Solution {\\n    \\n    int closestCost = Integer.MAX_VALUE;\\n    \\n    int closestCostDiff = Integer.MAX_VALUE;\\n\\n    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\\n        for (int base : baseCosts) {\\n            dfs(toppingCosts, 0, base, target);\\n        }", "class Solution {\\n    \\n    int closestCost = Integer.MAX_VALUE;\\n    \\n    int closestCostDiff = Integer.MAX_VALUE;\\n\\n    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\\n        for (int base : baseCosts) {\\n            dfs(toppingCosts, 0, base, target);\\n        }"]}
{"id": "1367", "ref_java": ["class Solution {\\n    private int helper(int[] num1, int[] num2, int sum1, int sum2){\\n        int[] cnt = new int[6];\\n        int diff = sum2-sum1, res=0;\\n\\n        for(var i:num1) cnt[6-i]++;\\n        for(var j:num2) cnt[j-1]++;\\n\\n        for(int i=5; i>0 && diff>0; i--){\\n            int temp = Math.min(cnt[i], diff/i+(diff%i != 0?1:0));\\n            diff -= (temp*i);\\n            res+=temp;\\n        }", "class Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        ", "class Solution {\\n    public int minOperations(int[] num1, int[] num2) {\\n       int x=0,y=0;\\n       for(int i=0;i<num1.length;i++){x+=num1[i];}"]}
{"id": "1368", "ref_java": ["class Solution {\\n    public boolean checkPowersOfThree(int n) {\\n        while (n > 0) {\\n            if (n % 3 == 2) return false;\\n            else n /= 3;\\n        }", "class Solution {\\n    public boolean checkPowersOfThree(int n) {\\n        while(n>0){\\n            if(n%3==2) return false;\\n            else n=n/3;\\n        }", "class Solution {\\n    public boolean checkPowersOfThree(int n)\\n    {\\n        while(n>0)\\n        {\\n            if(n % 3 == 2)\\n                return false;\\n            \\n            n=n/3;\\n        }"]}
{"id": "1369", "ref_java": ["class Solution {\\n    public int beautySum(String s) {\\n\\n        ", "class Solution {\\n    ", "class Solution {\\n    public int beautySum(String s) {\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n        HashMap<Character, Integer> hs = new HashMap<>();\\n            for(int j=i+1;j<=s.length();j++){\\n        int max = Integer.MIN_VALUE,min=Integer.MAX_VALUE;\\n                hs.put(s.charAt(j-1),hs.getOrDefault(s.charAt(j-1),0)+1);\\n                if(hs.size() == 1) continue;\\n                else{\\n                    for (Map.Entry<Character, Integer> entry : hs.entrySet()){\\n                        max=Math.max(max,entry.getValue());\\n                        min=Math.min(min,entry.getValue());\\n                    }"]}
{"id": "1370", "ref_java": ["class Solution {\\n    public int minElements(int[] nums, int limit, int goal) {\\n        return (int)(Math.ceil((Math.abs((long)goal-(Arrays.stream(Arrays.stream(nums).mapToLong(i->i).toArray()).sum())))*1.0/limit));\\n    }", "class Solution {\\n    public int minElements(int[] nums, int limit, int goal) {\\n        long sum = 0;\\n        for (int x:nums){sum+=x;}", "class Solution {\\n    public int minElements(int[] nums, int limit, int goal) {\\n        long sum = 0;\\n        int minElements = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }"]}
{"id": "1371", "ref_java": ["class Solution {\\n    Long dp[] ;\\n    int mod = 1000000007;\\n    public int countRestrictedPaths(int n, int[][] edges) {\\n        ", "class Solution {\\n    private static final int INF = Integer.MAX_VALUE;\\n    private static final int M = 1000000007;\\n    public int countPaths(int[] dist,ArrayList<int[]>[] adj,int[] dp, int u){\\n      if(dp[u] != -1) return dp[u];\\n      int paths = 0;\\n      dp[u] = paths;\\n      for(int[] edge:adj[u]){\\n        int v = edge[0];\\n        if(dist[u] < dist[v]){\\n          paths = (paths + countPaths(dist,adj,dp,v))%M;\\n        }", "class Solution {\\n    List<List<int[]>> adj;\\n    int vals[];\\n    int MOD = (int)1e9 + 7;\\n    int cnts[];\\n    int v;\\n    int[] dijkstra(int n,int s){\\n        int dist[] = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[s] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        pq.add(new int[]{s,0}"]}
{"id": "1372", "ref_java": ["class Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }", "class Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<ClassRecord> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new ClassRecord(cl));\\n        }", "class Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                double adiff = (a[0]+1)/(a[1]+1) - (a[0]/a[1]);                \\n                double bdiff = (b[0]+1)/(b[1]+1) - (b[0]/b[1]);\\n                if(adiff==bdiff) return 0;\\n                return adiff>bdiff? -1:1;\\n            }"]}
{"id": "1374", "ref_java": ["class Solution {\\n    public int getMaximumConsecutive(int[] coins) {\\n        Arrays.sort(coins);\\n        int c=0;\\n        for(int i=0;i<coins.length;i++)\\n        {\\n            if(coins[i]>c+1)break;\\n            else c+=coins[i];\\n        }", "class Solution {\\n    public int getMaximumConsecutive(int[] coins) {\\n        Arrays.sort(coins);\\n        int count = 1;\\n        for(int can : coins ) {\\n        if(count < can) break;\\n        count +=can;\\n    }", "class Solution {\\n    public int getMaximumConsecutive(int[] arr) {\\n        Arrays.sort(arr);\\n        int max = 0;\\n        for (int num  : arr) {\\n            if (num > max + 1) {\\n                break;\\n            }"]}
{"id": "1375", "ref_java": ["class Solution {\\n    final static int MOD = (int) (1e9 + 7);\\n    class Order{\\n        int price;\\n        int amount;\\n        Order(int price, int amount){\\n            this.price = price;\\n            this.amount = amount;\\n        }", "class Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        ", "class Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        TreeMap<Integer, Integer> sell = new TreeMap<Integer, Integer>();\\n        TreeMap<Integer, Integer> buy = new TreeMap<Integer, Integer>();\\n        \\n        for(int i = 0; i < orders.length; i++)\\n        {\\n            int type = orders[i][2];\\n            int price = orders[i][0];\\n            int amt = orders[i][1];\\n\\n            if(type == 0)\\n            {\\n                while(amt!= 0)\\n                {                    \\n                    if(sell.isEmpty() || sell.firstKey() > price)\\n                    {\\n                        if(buy.containsKey(price))\\n                            buy.put(price, (buy.get(price) + amt));\\n                        else\\n                            buy.put(price, amt);\\n                        break;\\n                    }"]}
{"id": "1376", "ref_java": ["class Solution {\\n    private long check(long a, int index, int n) {\\n        long leftOffset = Math.max(a - index, 0);\\n        long result = (a + leftOffset) * (a - leftOffset + 1) / 2;\\n        long rightOffset = Math.max(a - ((n - 1) - index), 0);\\n        result += (a + rightOffset) * (a - rightOffset + 1) / 2;\\n        return result - a;\\n    }", "class Solution {\\n    public int maxValue(int n, int index, int maxSum) {\\n        int left = 1;\\n        int right = maxSum;\\n        int ans = -1;\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            if(isPossible(mid,n,index,maxSum)){\\n                ans = Math.max(ans,mid);\\n                left = mid+1;\\n            }", "class Solution {\\n    public int maxValue(int n, int index, int maxSum) {\\n        long left=index;\\n        long right=n-index-1;\\n        long start=1;\\n        long end=maxSum;\\n        while(start<=end) {\\n            long mid=start+(end-start)/2;\\n            long m=mid-1;\\n            long ls=0;\\n            long rs=0;\\n            if(m>=left) {\\n                long notInRange=m-left;\\n                ls=m*(m+1)/2-(notInRange)*(notInRange+1)/2;\\n            }"]}
{"id": "1377", "ref_java": ["class Solution {\\n    public int reinitializePermutation(int n) {\\n        int ans = 1;\\n        int num = 2;\\n        if(n == 2) return 1;\\n        while(true){\\n            if(num % (n-1) == 1)break; \\n            else {\\n                ans++;\\n                num = (num * 2) % (n-1);\\n            }", "class Solution {\\n    public int reinitializePermutation(int n) {\\n        int[] perm=new int[n];\\n        int[] nums=new int[n];\\n        for(int i=0;i<n;i++){\\n            perm[i]=i;\\n            nums[i]=i;\\n        }", "class Solution {\\n\\n    public int reinitializePermutation1(int n) {\\n        final int halfN = (n >> 1);\\n        int[] perm = initInOrder(n);\\n        int ops = 0;\\n        do {\\n            int[] arr = new int[n];\\n            for (int i = 0; i < n; ++i) {\\n                final int halfI = (i >> 1); "]}
{"id": "1378", "ref_java": ["class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> map=new HashMap<>();\\n        for(int i=0; i<knowledge.size(); i++){\\n            map.put((knowledge.get(i)).get(0),(knowledge.get(i)).get(1));\\n        }", "class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }", "class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> map=new HashMap<>();\\n        for(int i=0; i<knowledge.size(); i++){\\n            map.put((knowledge.get(i)).get(0),(knowledge.get(i)).get(1));\\n        }"]}
{"id": "1379", "ref_java": ["class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        String[] s1 = sentence1.split(\" \");\\n        String[] s2 = sentence2.split(\" \");\\n        int i = 0, j = 0;\\n        while (i < s1.length && j < s2.length){\\n            if (!s1[i].equals(s2[j])) break;\\n            i++;\\n            j++;\\n        }", "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        if(sentence1.length()==sentence2.length()){\\n            if(sentence1.equals(sentence2)) return true;\\n            else return false;\\n        }", "class Solution {\\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\\n        \\n        String[] words1 = sentence1.split(\"\\\\\\\\s\");\\n        String[] words2 = sentence2.split(\"\\\\\\\\s\");\\n        \\n        return words1.length <= words2.length ? areSentencesSimilar(words1, words2) : areSentencesSimilar(words2, words1);\\n    }"]}
{"id": "1380", "ref_java": ["class Solution {\\n    public int countNicePairs(int[] nums) {\\n        ", "class Solution {\\n    public int countNicePairs(int[] nums) {\\n        final int mod = 1000000007;\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            nums[i] = nums[i] - reverse(nums[i]);\\n        }", "class Solution {\\n  private int rev(int n) {\\n    var rev = 0;\\n\\n    while (n > 0) {\\n      rev = (rev * 10) + (n % 10);\\n      n /= 10;\\n    }"]}
{"id": "1381", "ref_java": ["class Solution {\\n    public int[] findingUsersActiveMinutes(int[][] logs, int k) {\\n        Arrays.sort(logs, Comparator.comparingInt((int[] log) -> log[0]).thenComparingInt(log -> log[1]));\\n\\n        int[] ans = new int[k];\\n        int i = 0;\\n\\n        while (i < logs.length) {\\n            ++i;\\n            int cnt = 0;\\n\\n            while (i < logs.length && logs[i][0] == logs[i - 1][0]) {\\n                if (logs[i][1] != logs[i - 1][1])\\n                    ++cnt;\\n\\n                ++i;\\n            }", "class Solution {\\n    public int[] findingUsersActiveMinutes(int[][] logs, int k) {\\n        int arr[]=new int[k];\\n        HashMap<Integer,HashSet<Integer>> h=new HashMap<>();\\n        for(int i=0; i<logs.length; i++){\\n          \\n                h.putIfAbsent(logs[i][0], new HashSet<>());\\n                h.get(logs[i][0]).add(logs[i][1]);\\n            \\n           \\n        }", "class Solution {\\n    public int[] findingUsersActiveMinutes(int[][] logs, int k) {\\n        int arr[]=new int[k];\\n        HashMap<Integer,HashSet<Integer>> h=new HashMap<>();\\n        for(int i=0; i<logs.length; i++){\\n          \\n                h.putIfAbsent(logs[i][0], new HashSet<>());\\n                h.get(logs[i][0]).add(logs[i][1]);\\n            \\n           \\n        }"]}
{"id": "1382", "ref_java": ["class Solution {\\n    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\\n        int mod = (int)1e9+7;\\n\\n        ", "class Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        int reduce = 0;        ", "class Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        int reduce = 0;        "]}
{"id": "1383", "ref_java": ["class Solution {\\n   public int findTheWinner(int n, int k) {\\n       return help(n,k)+1;\\n    }", "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(k==1){\\n            return n;\\n        }", "class Solution {\\n    int last_alive=0;\\n    public int findTheWinner(int n, int k) {\\n        int index=0;\\n        k--;\\n        int temp;\\n        List<Integer> person = new LinkedList<Integer>();\\n        int i;\\n        for(i=1;i<=n;i++)\\n        {\\n            person.add(i);\\n        }"]}
{"id": "1384", "ref_java": ["class Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        ", "class Solution {\\n    int mod = 1000000000;\\n    public int minSideJumps(int[] obstacles) {\\n        ", "class Solution {\\n    int mod = 1000000000;\\n    public int minSideJumps(int[] obstacles) {\\n        "]}
{"id": "1385", "ref_java": ["class Solution {\\n    public int[] countPoints(int[][] p, int[][] q) {\\n        int[] ans=new int[q.length];\\n        for(int i=0;i<q.length;i++){\\n            int c=0;\\n            for(int j=0;j<p.length;j++){\\n                if(Math.sqrt(square(q[i][0]-p[j][0])+square(q[i][1]-p[j][1]))<=q[i][2]){\\n                    c++;\\n                }", "class Solution {\\n    public int[] countPoints(int[][] points, int[][] queries) {\\n        int n = queries.length;\\n        int[] res = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n            res[i] = getAns(points, queries, i);\\n        return res;\\n    }", "class Solution {\\n    public int[] countPoints(int[][] points, int[][] queries) {\\n        int n = queries.length;\\n        int[] res = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n            res[i] = getAns(points, queries, i);\\n        return res;\\n    }"]}
{"id": "1386", "ref_java": ["class Solution {\\n    public int[] getMaximumXor(int[] nums, int maximumBit) {\\n        int n=nums.length;\\n        int res[]=new int[n];\\n        int ans=0;\\n        for(int i:nums)ans^=i;\\n        int maxor=(int)Math.pow(2,maximumBit)-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=ans^maxor;\\n            ans^=nums[n-i-1];\\n        }", "class Solution {\\n    public int[] getMaximumXor(int[] nums, int maximumBit) {\\n        int xor = 0, n = nums.length;\\n        int max = (1 << maximumBit) - 1;\\n        int res[] = new int[n];\\n        \\n        for(int e : nums) xor ^= e;", "class Solution {\\n    public int[] getMaximumXor(int[] nums, int maximumBit) {\\n       int n = nums.length, val = 0, k = (1<<maximumBit)-1;\\n        \\n        int ans[] = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            val^=nums[i];\\n            \\n            ans[n-i-1] = val^k;\\n        }"]}
{"id": "1387", "ref_java": ["class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n", "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n", "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i] <= coins){\\n                coins = coins - costs[i];\\n                count++;\\n            }"]}
{"id": "1388", "ref_java": ["class Solution {\\n    public int[] getOrder(int[][] tasks) {\\n        if (tasks.length == 0) {\\n            return new int[0];\\n        }", "class Solution {\\n    public int[] getOrder(int[][] tasks) {\\n        HashMap<int[],Integer> hm = new HashMap<int[],Integer>();\\n        for(int i=0;i<tasks.length;i++){\\n            hm.put(tasks[i],i); \\n        }", "class Solution {\\n    public int[] getOrder(int[][] tasks) {\\n        int[][] newTasks = new int[tasks.length][3];\\n        for (int i = 0; i < tasks.length; i++) {\\n            newTasks[i][0] = tasks[i][0];\\n            newTasks[i][1] = tasks[i][1];\\n            newTasks[i][2] = i;\\n        }"]}
{"id": "1389", "ref_java": ["class Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        int maxFrequency = 0; ", "class Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int left = 0, right = 0;\\n        long res = 0, total = 0;\\n\\n        while (right < nums.length) {\\n            total += nums[right];\\n\\n            while (nums[right] * (right - left + 1L) > total + k) {\\n                total -= nums[left];\\n                left += 1;\\n            }", "class Solution {\\n    public int maxFrequency(int[] nums, int k) {\\n        countingSort(nums);\\n        int start = 0;\\n        int preSum = 0;\\n        int total = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int length = i - start + 1;\\n            int product = nums[i] * length;\\n            preSum += nums[i];            \\n            while (product - preSum > k) {\\n                preSum -= nums[start++];\\n                length--;\\n                product = nums[i] * length;\\n            }"]}
{"id": "1390", "ref_java": ["class Solution {\\n    public int longestBeautifulSubstring(String word) {\\n        int len=1;\\n        int count=1;\\n        int maxLen=0;\\n        for(int i=1;i<word.length();i++){\\n            if(word.charAt(i-1)<=word.charAt(i)){\\n                if(word.charAt(i-1)!=word.charAt(i)){\\n                    count++;\\n                }", "class Solution {\\n    public int longestBeautifulSubstring(String word) {\\n        char[] vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}", "class Solution {\\n    public int longestBeautifulSubstring(String word) {\\n        int len=1;\\n        int count=1;\\n        int maxLen=0;\\n        for(int i=1;i<word.length();i++){\\n            if(word.charAt(i-1)<=word.charAt(i)){\\n                if(word.charAt(i-1)!=word.charAt(i)){\\n                    count++;\\n                }"]}
{"id": "1392", "ref_java": ["class Solution {\\n    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {\\n        Arrays.sort(arr);\\n        int maxVal = 1;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > maxVal) {\\n                maxVal += 1;\\n            }", "class Solution {\\n    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {\\n        Arrays.sort(arr);\\n        arr[0] = 1; ", "class Solution {\\n    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {\\n        Arrays.sort(arr);\\n        int ans = 1;\\n        \\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] >= ans + 1) {\\n                ans++;\\n            }"]}
{"id": "1393", "ref_java": ["class Solution {\\n    public boolean splitString(String s) {\\n\\t", "class Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }", "class Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { "]}
{"id": "1394", "ref_java": ["class Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int n = num.length();\\n        \\n        ", "class Solution {\\n    int n;\\n    public void nextPermutation(char[]arr){\\n        int i = n-2;\\n        while(i >= 0 && arr[i] >= arr[i + 1])\\n            i--;\\n        int j = n-1;\\n        if(i >= 0){\\n            while(j > i && arr[j] <= arr[i])\\n                j--;\\n            swap(arr,i,j);\\n        }", "class Solution {\\n    int n;\\n    public void nextPermutation(char[]arr){\\n        int i = n-2;\\n        while(i >= 0 && arr[i] >= arr[i + 1])\\n            i--;\\n        int j = n-1;\\n        if(i >= 0){\\n            while(j > i && arr[j] <= arr[i])\\n                j--;\\n            swap(arr,i,j);\\n        }"]}
{"id": "1395", "ref_java": ["class Solution {\\n    public int maxDistance(int[] nums1, int[] nums2) {\\n        int max = 0;\\n        int diff =0;\\n        int p1 =0;\\n        int p2 = 0;\\n        while(p1<nums1.length && p2<nums2.length){\\n            if(nums2[p2] >= nums1[p1]){\\n                diff = p2 -p1;\\n                max = Math.max(max,diff);\\n                p2++;\\n            }", "class Solution {\\n    public int maxDistance(int[] nums1, int[] nums2) {\\n        int diff = 0;\\n        for(int i = 0;i<nums1.length;i++){\\n            int start = i;\\n            int end = nums2.length-1;\\n            while(start <= end){\\n                int mid = start+(end-start)/2;\\n                if(nums1[i] <= nums2[mid]){\\n                    diff = Math.max(diff, mid-i);\\n                    start = mid+1;\\n                }", "class Solution {\\n    public int maxDistance(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int n1 = nums2.length;\\n        if(n == 1 && n1 == 1)\\n        {\\n            return 0;\\n        }"]}
{"id": "1396", "ref_java": ["class Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }", "class Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }", "class Solution {\\n    public int maxSumMinProduct(int[] a) {\\n        int n = a.length, M = 1_000_000_007;\\n        long res = 0L;\\n\\n        "]}
{"id": "1397", "ref_java": ["class Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int count = 1;\\n        while (memory1 - count >= 0 || memory2 - count >= 0) {\\n            int diff1 = memory1 - count, diff2 = memory2 - count;\\n            if (memory1 - count >= 0 && memory2 - count >= 0) {\\n                if (diff2 > diff1) {\\n                    memory2 -= count;\\n                    count++;\\n                    continue;\\n                }", "class Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(Math.max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }", "class Solution {\\n\\n    int time = 1, mem1, mem2;\\n\\n    public int[] memLeak(int _memory1, int _memory2) {\\n\\n        this.mem1 = _memory1;\\n        this.mem2 = _memory2;\\n\\n        "]}
{"id": "1398", "ref_java": ["class Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m=box.length,n=box[0].length;\\n        char ans[][]=new char[n][m];\\n        for(char c[]:ans)\\n        {\\n            Arrays.fill(c,\\'.\\');\\n        }", "class Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        \\n        int n=box.length;\\n        int m=box[0].length;\\n\\n        char newbox[][] = new char[m][n];\\n      ", "class Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m=box.length,n=box[0].length;\\n        char ans[][]=new char[n][m];\\n        for(char c[]:ans)\\n        {\\n            Arrays.fill(c,\\'.\\');\\n        }"]}
{"id": "1399", "ref_java": ["class Solution {\\n    public int minSwaps(String s) {\\n        int n = s.length();\\n\\n        \\n        int ones = 0;\\n        int zero = 0;\\n\\n        int a = 0;\\n        int b = 0;\\n        char c1 = \\'0\\';\\n        char c2 = \\'1\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n\\n            if(ch!=c1) a++;\\n            if(ch!=c2) b++;\\n\\n            char x = c1;\\n            c1 = c2;\\n            c2 = x;\\n\\n            if(ch==\\'1\\') ones++;\\n            if(ch==\\'0\\') zero++;\\n        }", "class Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0, ones = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                zeros++;\\n            }", "class Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0, ones = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                zeros++;\\n            }"]}
{"id": "1401", "ref_java": ["class Solution {\\n     public boolean isPossible(int[] dist, int speed, double hour) {\\n        double ans = 0;\\n        for (int i = 0; i < dist.length; i++) {\\n            double d = dist[i] * 1.0 / speed;\\n            if (i != dist.length - 1)\\n                ans = ans + Math.ceil(d);\\n            else\\n                ans += d;\\n            if (ans > hour)\\n                return false;\\n        }", "class Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        if(hour<dist.length-1) return -1;\\n        int l = 0;\\n        int r = 10000000;\\n        int m;\\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2;            \\n            if(check(dist, hour, m)){\\n                ans = m;\\n                r = m-1;\\n            }", "class Solution {\\n    public boolean isPossible(double speed, int[] dist, double hour){\\n        double total_hour_so_far = 0;\\n        <!-- Calculating total hour  -->\\n        for(int it = 0; it < dist.length - 1; it++){\\n            double h = dist[it]/speed;\\n            total_hour_so_far += Math.ceil(h);\\n\\n            if(total_hour_so_far > hour) return false;\\n        }"]}
{"id": "1402", "ref_java": ["class Solution {\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int left;\\n        int right;\\n        int farthest = 0;\\n\\n        Queue<Integer> q = new LinkedList();\\n\\n        q.add(0);\\n        while(!q.isEmpty()){\\n            int k = q.remove();\\n            if(k == s.length()-1) return true;\\n       \\n            left = Math.max(k + minJump, farthest);\\n            right = Math.min(k + maxJump, s.length()-1);\\n            for(int i = left; i<= right; i++){\\n                if(s.charAt(i)==\\'0\\') q.add(i);\\n            }", "class Solution {\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        if(s.charAt(s.length() - 1) != \\'0\\')\\n            return false;\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        \\n        ", "class Solution {\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        \\n        \\n        Queue<Integer> q = new LinkedList<>();\\n         Queue<Integer> zero = new LinkedList<>();\\n        int n = s.length();\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s.charAt(i)==\\'0\\')\\n            zero.add(i);\\n        }"]}
{"id": "1403", "ref_java": ["class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        int minMaxSum = 0;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            minMaxSum = Math.max(minMaxSum, nums[i] + nums[n - 1 - i]);\\n        }", "class Solution {\\n    public int minPairSum(int[] nums) {\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for(int i = 0; i< nums.length;i++){\\n            min.offer(nums[i]);\\n        }", "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int minMaxSum = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            minMaxSum = Math.max(minMaxSum, nums[i] + nums[nums.length - 1 - i]);\\n        }"]}
{"id": "1404", "ref_java": ["class Solution {\\n\\n    static int calc(int arr[][], int left, int right, int up, int down){\\n\\n        int sum = 0;\\n        int c1 = (left+right)/2;\\n        int c2 = c1;\\n\\n        boolean flag = true;\\n\\n        for(int i=up; i<=down; i++){\\n            if(c1==c2) sum+=arr[i][c1];\\n            else{\\n                sum+=arr[i][c1]+arr[i][c2];\\n            }", "class Solution {\\n\\n    static int calc(int arr[][], int left, int right, int up, int down){\\n\\n        int sum = 0;\\n        int c1 = (left+right)/2;\\n        int c2 = c1;\\n\\n        boolean flag = true;\\n\\n        for(int i=up; i<=down; i++){\\n            if(c1==c2) sum+=arr[i][c1];\\n            else{\\n                sum+=arr[i][c1]+arr[i][c2];\\n            }", "class Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int end = Math.min(grid.length, grid[0].length);\\n        int maxThree[] = {0,0,0}"]}
{"id": "1405", "ref_java": ["class Solution {\\n    public String maxValue(String str, int x) {\\n        \\n\\n        if(str.charAt(0)!=\\'-\\'){\\n            StringBuilder s = new StringBuilder(str);\\n            int n = s.length();\\n\\n            if (Integer.valueOf(x) == 0) {\\n                s.append(String.valueOf(x));\\n                return s.toString();\\n            }", "class Solution {\\n    public String maxValue(String n, int x) {\\n        int sign = 1, start = 0;\\n\\n        if(n.charAt(0) == \\'-\\') {\\n            sign = -1;\\n            start = 1;\\n        }", "class Solution {\\n    public String maxValue(String str, int x) {\\n        \\n\\n        if(str.charAt(0)!=\\'-\\'){\\n            StringBuilder s = new StringBuilder(str);\\n            int n = s.length();\\n\\n            if (Integer.valueOf(x) == 0) {\\n                s.append(String.valueOf(x));\\n                return s.toString();\\n            }"]}
{"id": "1406", "ref_java": ["class Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        PriorityQueue<int[]> availableServer = new PriorityQueue<int[]>((a, b) -> (a[1] != b[1] ? (a[1] - b[1]) : (a[0] - b[0])));\\n        for(int i = 0; i < servers.length; i++){\\n            availableServer.add(new int[]{i, servers[i]}", "class Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n       \\n        PriorityQueue<FreeServers> fpq = new PriorityQueue(); ", "class Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        PriorityQueue<int[]> availableServer = new PriorityQueue<int[]>((a, b) -> (a[1] != b[1] ? (a[1] - b[1]) : (a[0] - b[0])));\\n        for(int i = 0; i < servers.length; i++){\\n            availableServer.add(new int[]{i, servers[i]}"]}
{"id": "1407", "ref_java": ["class Solution {\\n    \\n    public int f(int eggs,int floors) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors;\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i <= floors;i++) {\\n            int min = Math.max( f(eggs-1,i-1) , f(eggs,floors - i));\\n            if(min < ans) ans = min;\\n        }", "class Solution {\\n    \\n    public int f(int eggs,int floors) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors;\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i <= floors;i++) {\\n            int min = Math.max( f(eggs-1,i-1) , f(eggs,floors - i));\\n            if(min < ans) ans = min;\\n        }", "class Solution {\\n    \\n    public int f(int eggs,int floors) {\\n        if(floors == 0 || floors == 1) return floors;\\n        if(eggs == 1) return floors;\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i <= floors;i++) {\\n            int min = Math.max( f(eggs-1,i-1) , f(eggs,floors - i));\\n            if(min < ans) ans = min;\\n        }"]}
{"id": "1408", "ref_java": ["class Solution {\\n    public int reductionOperations(int[] nums) {\\n        Arrays.sort(nums); ", "class Solution {\\n    public int reductionOperations(int[] nums) {\\n        Arrays.sort(nums); ", "class Solution {\\n    public int reductionOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        "]}
{"id": "1409", "ref_java": ["class Solution {\\n    public int minFlips(String s) {\\n        ", "class Solution {\\n    public int minFlips(String s) {\\n        \\n        \\n        \\n        int n = s.length();\\n        \\n        int mininumFlip = Integer.MAX_VALUE;\\n        \\n        int misMatchCount = 0;\\n        for(int i = 0; i < (2 * n); i++){\\n            \\n            int r = i % n;\\n            \\n            ", "class Solution {\\n    public int minFlips(String s) {\\n        StringBuilder sb = new StringBuilder(s).append(s);\\n\\n        StringBuilder alt1 = new StringBuilder();\\n        StringBuilder alt2 = new StringBuilder();\\n\\n        for (int i = 0; i < sb.length(); i++) {\\n            if (i % 2 == 0) {\\n                alt1.append(0);\\n                alt2.append(1);\\n            }"]}
{"id": "1410", "ref_java": ["class Solution {\\n    public int chalkReplacer(int[] chalk, int k) {\\n        int n= chalk.length;\\n\\n        ", "class Solution {\\n    public int chalkReplacer(int[] chalk, int k) \\n    {\\n        long sum =0;\\n        \\n        for(Integer i: chalk)\\n            sum += i;\\n        \\n        long l = k % sum;\\n        \\n        for(int i=0; i<chalk.length;i++)\\n        {\\n            if(l >= chalk[i])\\n                l = l - chalk[i];\\n            else\\n                return i;\\n        }", "class Solution {\\n    public int chalkReplacer(int[] chalk, int k) {\\n        long prev=0l;\\n        long []ps=new long[chalk.length];\\n        for(int i=0;i<chalk.length;i++){\\n            prev+=chalk[i];\\n            ps[i]=prev;\\n        }"]}
{"id": "1411", "ref_java": ["class Solution {\\n    static int ans = 1;\\n\\n    static void helper(int arr[][], int row, int col, int a){\\n\\n        int s = 0;\\n\\n        for(int i=row; i<row+a; i++) s = s+arr[i][col];\\n\\n        ", "class Solution {\\n    public int largestMagicSquare(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[] rowSum[]=new int[m][n+1];\\n        int[] colSum[]=new int[n][m+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                rowSum[i][j+1]=rowSum[i][j]+grid[i][j];\\n                colSum[j][i+1]=colSum[j][i]+grid[i][j];\\n            }", "class Solution {\\n    public int largestMagicSquare(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[] rowSum[]=new int[m][n+1];\\n        int[] colSum[]=new int[n][m+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                rowSum[i][j+1]=rowSum[i][j]+grid[i][j];\\n                colSum[j][i+1]=colSum[j][i]+grid[i][j];\\n            }"]}
{"id": "1412", "ref_java": ["class Solution {\\n    public int maximumRemovals(String s, String p, int[] removable) {\\n        int k=0;\\n        char[] chars=s.toCharArray();\\n        for(int i=0;i<removable.length;i++){\\n            StringBuilder str=new StringBuilder(newString(chars,removable[i]));\\n            if(!isSubsequence(str.toString(),p)){\\n                return k;\\n            }", "class Solution {\\n    public int maximumRemovals(String s, String p, int[] removable) {\\n        int k=0;\\n        char[] chars=s.toCharArray();\\n        for(int i=0;i<removable.length;i++){\\n            StringBuilder str=new StringBuilder(newString(chars,removable[i]));\\n            if(!isSubsequence(str.toString(),p)){\\n                return k;\\n            }", "class Solution {\\n    public int maximumRemovals(String s, String p, int[] removable) {\\n        int l = -1;\\n        int r = removable.length;\\n        char[] pArray = p.toCharArray();\\n        char[] sArray = s.toCharArray();\\n        int start = -1;\\n        while(l + 1 < r) {\\n            int m = l + ((r - l) >> 1);\\n            if (isSub(sArray, pArray, removable, start + 1, m)) {\\n                l = m;\\n                start = l;\\n            }"]}
{"id": "1413", "ref_java": ["class Solution {\\n    public boolean mergeTriplets(int[][] triplets, int[] t) {\\n    int[] res = new int[3];\\n    for (var s : triplets)\\n        if (s[0] <= t[0] && s[1] <= t[1] && s[2] <= t[2])\\n            res = new int[]{ Math.max(res[0], s[0]), Math.max(res[1], s[1]), Math.max(res[2], s[2]) }", "class Solution {\\n    public boolean mergeTriplets(int[][] triplets, int[] t) {\\n    int[] res = new int[3];\\n    for (var s : triplets)\\n        if (s[0] <= t[0] && s[1] <= t[1] && s[2] <= t[2])\\n            res = new int[]{ Math.max(res[0], s[0]), Math.max(res[1], s[1]), Math.max(res[2], s[2]) }", "class Solution {\\n    public boolean mergeTriplets(int[][] triplets, int[] target) {\\n        boolean x = false;\\n        boolean y = false;\\n        boolean z = false;\\n        \\n        for(int i = 0;i<triplets.length;i++){\\n            if(triplets[i][0] == target[0] && triplets[i][1] <= target[1] && triplets[i][2] <= target[2]){\\n                x = true;\\n                break;\\n            }"]}
{"id": "1414", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    ", "class Solution {\\n    public int maxEl(int[][] mat, int n, int m, int col) {\\n        int maxi = -1;\\n        int ind = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (mat[i][col] > maxi) {\\n                maxi = mat[i][col];\\n                ind = i;\\n            }"]}
{"id": "1415", "ref_java": ["class Solution {\\n    public int numberOfRounds(String loginTime, String logoutTime) {\\n        int start = convert(loginTime);\\n        int end = convert(logoutTime);\\n        \\n        if (start > end) {\\n            return numberOfRounds(loginTime, \"24:00\") + numberOfRounds(\"00:00\", logoutTime);\\n        }", "class Solution {\\n    public int numberOfRounds(String startTime, String finishTime) {\\n        Integer startHH = Integer.parseInt(startTime.substring(0,2));\\n        Integer startMM = Integer.parseInt(startTime.substring(3));\\n        Integer finishHH = Integer.parseInt(finishTime.substring(0,2));\\n        Integer finishMM = Integer.parseInt(finishTime.substring(3));\\n        \\n        int start = startHH*60 +startMM;\\n        int end = finishHH*60 +finishMM;\\n        if (start > end) {\\n           end += 24*60;\\n        }", "class Solution {\\n    public int numberOfRounds(String startTime, String finishTime) {\\n        int start = timeInMinute(startTime); "]}
{"id": "1416", "ref_java": ["class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n=grid2.length;\\n        int m=grid2[0].length;\\n\\n        int delRow[]={1,-1,0,0}", "class Solution {\\n    int n,m,n1,m1;\\n    public int bfs2(int[][] grid1, int[][] grid2,int[][] vis_grid2,int r,int c)\\n    {\\n        int val=0;\\n        vis_grid2[r][c]=1;\\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(r,c));\\n        int[] del_row={0,1,0,-1}", "class Solution {\\n    int[] xDir = {0,0,-1,1}"]}
{"id": "1417", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int[] minDifference(int[] nums, int[][] queries) {\\n        int n = nums.length;\\n        int[][] count = new int[n + 1][100];\\n        int q = queries.length;\\n        int ans[] = new int[q];\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < 100; ++j)\\n                count[i + 1][j] = count[i][j];\\n            \\n            ++count[i + 1][nums[i] - 1];\\n        }", "class Solution {\\n    BitSet[] tree;\\n    BitSet base;\\n    public int[] minDifference(int[] nums, int[][] queries) {\\n        int N = nums.length, sz = queries.length;\\n        tree = new BitSet[4 * N];\\n        base = new BitSet(101);\\n        int[] ans = new int[sz];\\n    \\n        build(nums, 0, 0, N - 1);\\n    \\n        for (int i = 0; i < sz; i++) {\\n            int[] q = queries[i];\\n            BitSet st = query(nums, 0, N - 1, 0, q[0], q[1]);\\n            int diff = 1000, prev = -1000;\\n            for (int val = 1; val <= 100; val++) {\\n                if (!st.get(val)) continue;\\n                diff = Math.min(diff, Math.abs(prev - val));\\n                prev = val;\\n            }"]}
{"id": "1419", "ref_java": ["class Solution {\\n    public String removeOccurrences(String s, String part) {\\n        int n = s.length();\\n        int index = s.indexOf(part);\\n        while(index != -1) {\\n            s = s.substring(0, index) + s.substring(index + part.length());\\n            n = s.length();\\n            index = s.indexOf(part);\\n        }", "class Solution {\\n*   \\t\\tpublic String removeOccurrences(String s, String part) {\\n\\t\\t\\tStack<Character> st = new Stack<>();\\n \\t\\tint n = s.length();\\n        int m = part.length();\\n        for(int i=0;i<n;i++){\\n            st.push(s.charAt(i));\\n            if(st.size()>=m){\\n                String x=\"\";\\n                for(int j=m-1;j>=0;j--){\\n                    char ch = part.charAt(j);\\n                    if(ch!=st.peek()){\\n                        for(int k=0;k<x.length();k++){\\n                            st.push(x.charAt(k));\\n                        }", "class Solution {\\n    public String removeOccurrences(String s, String part) {\\n        int len = part.length();\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        while(sb.indexOf(part) != -1) {\\n            int start = sb.indexOf(part);\\n            sb.delete(start, start+len);\\n        }"]}
{"id": "1420", "ref_java": ["class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n][2];\\n        dp[0][0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+nums[i]);\\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-nums[i]);\\n        }", "class Solution {\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        return solve(nums, 0, n, 1);\\r\\n    }", "class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n][2];\\n        dp[0][0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+nums[i]);\\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-nums[i]);\\n        }"]}
{"id": "1421", "ref_java": ["class Solution {\\r\\n    public int[][] rotateGrid(int[][] grid, int k) {\\r\\n\\r\\n\\r\\n        int top=0;\\r\\n        int buttom=grid.length-1;\\r\\n        int left=0;\\r\\n        int right=grid[0].length-1;\\r\\n\\r\\n        while(top<buttom && left<right){\\r\\n\\r\\n            int arr[] = new int[2*(buttom-left+1)+2*(right-left-1)];\\r\\n            int idx=0;\\r\\n            ", "class Solution {\\n    public int[][] rotateGrid(int[][] grid, int k) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int times = Math.min(n,m)/2;\\n        for(int i=1;i<=times;i++){\\n            rotateShell(grid,i,k);\\n        }", "class Solution {\\n    public int[][] rotateGrid(int[][] grid, int k) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int times = Math.min(n,m)/2;\\n        for(int i=1;i<=times;i++){\\n            rotateShell(grid,i,k);\\n        }"]}
{"id": "1422", "ref_java": ["class Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int n = word.length();\\n        long count = 0;\\n        \\n        long[] freq = new long[(1 << 10) + 1]; ", "class Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int n = word.length();\\n        long count = 0;\\n        \\n        long[] freq = new long[(1 << 10) + 1]; ", "class Solution {\\n    public long wonderfulSubstrings(String s) {\\n        long[] maskF = new long[1 << 10];\\n        maskF[0] = 1;\\n        long ans = 0;\\n        int i = 0, n = s.length(), mask = 0;\\n        while (i < n) {\\n            mask ^= 1 << (9 - (s.charAt(i++) - \\'a\\'));\\n            ans += maskF[mask]++;\\n            for (int j = 0; j < 10; j++) {\\n                ans += maskF[mask ^ (1 << j)];\\n            }"]}
{"id": "1423", "ref_java": ["class Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        int[] monsters = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            int arrival = (int) Math.ceil((double) dist[i] / speed[i]);\\n\\n            if (arrival < n) {\\n                monsters[arrival]++;\\n            }", "class Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] monstArrivalTime = new double[n];\\n        \\n        ", "class Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] monstArrivalTime = new double[n];\\n        \\n        "]}
{"id": "1424", "ref_java": ["class Solution {\\n    \\n    ", "class Solution {\\n    int mod=(int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n        long first=(n%2==0?(n/2):(n/2)+1);", "class Solution {\\n    int mod=(int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n        long first=(n%2==0?(n/2):(n/2)+1);"]}
{"id": "1425", "ref_java": ["class Solution {\\n    public int nearestExit(char[][] maze, int[] entrance) {\\n         return bfs(maze, entrance); ", "class Solution {\\n    public int nearestExit(char[][] maze, int[] entrance) {\\n        int n=maze.length;\\n        int m=maze[0].length;\\n\\n        int x=entrance[0];\\n        int y=entrance[1];\\n\\n        int delRow[]={1,-1,0,0}", "class Solution {\\n    public int nearestExit(char[][] maze, int[] entrance) {\\n         return bfs(maze, entrance); "]}
{"id": "1426", "ref_java": ["class Solution {\\n    public boolean sumGame(String num) {\\n        int q = 0, d = 0, n = num.length();\\n        for (int i = 0; i < n; i++){\\n            if (num.charAt(i) == \\'?\\'){\\n                q += 2* i < n? 1 : -1;\\n            }", "class Solution {\\n    public boolean sumGame(String num) {\\n        int leftSum = 0;\\n        int rightSum = 0;\\n        int leftMove = 0;\\n        int rightMove = 0;\\n        for(int i = 0; i < num.length() / 2; i++) {\\n            if (num.charAt(i) == \\'?\\') {\\n                leftMove++;\\n            }", "class Solution {\\n    public boolean sumGame(String num) {\\n        int q = 0, d = 0, n = num.length();\\n        for (int i = 0; i < n; i++){\\n            if (num.charAt(i) == \\'?\\'){\\n                q += 2* i < n? 1 : -1;\\n            }"]}
{"id": "1427", "ref_java": ["class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        char[] c = s.toCharArray();\\n        boolean[] v = new boolean[128];\\n        int a=0, t=0;\\n\\n        int l, r;\\n        for(char x=\\'a\\'; x<=\\'z\\'; x++){\\n            for(l=0; l<c.length && c[l]!=x; l++);\\n            if(l==c.length)continue;\\n            for(r=c.length-1; r>=0 && c[r]!=x; r--);\\n            if(l>=r)continue;\\n\\n            Arrays.fill(v, false); t=0;\\n            for(int i=l+1; i<r; i++){\\n                if(!v[c[i]]){\\n                    v[c[i]]=true; t++;\\n                    if(t==26)break;\\n                }", "class Solution {\\n    public int countPalindromicSubsequence(String inputString) {\\n        int firstIndex[] = new int[26], lastIndex[] = new int[26], result = 0;\\n        Arrays.fill(firstIndex, Integer.MAX_VALUE);\\n        for (int i = 0; i < inputString.length(); ++i) {\\n            firstIndex[inputString.charAt(i) - \\'a\\'] = Math.min(firstIndex[inputString.charAt(i) - \\'a\\'], i);\\n            lastIndex[inputString.charAt(i) - \\'a\\'] = i;\\n        }", "class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] left = new int[26];\\n        int[] right = new int[26];\\n        Arrays.fill(left, -1);\\n        int curr;\\n        for (int i = 0; i < s.length(); i++) {\\n            curr = s.charAt(i) - \\'a\\';\\n            if (left[curr] == - 1) {\\n                left[curr] = i;\\n            }"]}
{"id": "1429", "ref_java": ["class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0;\\n        int curr = 0;\\n        for(int i=0;i<rungs.length;i++){\\n            int next = rungs[i];\\n            if(next - curr > dist){\\n                res+= (next-curr-1)/dist;\\n            }", "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0;\\n        int curr = 0;\\n        for(int i=0;i<rungs.length;i++){\\n            int next = rungs[i];\\n            if(next - curr > dist){\\n                res+= (next-curr-1)/dist;\\n            }", "class Solution {\\n    public int addRungs(int[] rungs, int dist) {\\n        int res = 0;\\n        int curr = 0;\\n        for(int i=0;i<rungs.length;i++){\\n            int next = rungs[i];\\n            if(next - curr > dist){\\n                res+= (next-curr-1)/dist;\\n            }"]}
{"id": "1430", "ref_java": ["class Solution {\\n\\t\\tpublic long maxPoints(int[][] points) {\\n\\t\\t\\tlong[] frame = new long[points[0].length];\\n\\n\\t\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j <frame.length; j ++) frame[j] += points[i][j];\\n\\n\\t\\t\\t\\tfor (int j = 1; j < frame.length; j ++) frame[j] = Math.max(frame[j], frame[j - 1] - 1);\\n\\n\\t\\t\\t\\tfor (int j=frame.length-2;j>=0;j--) frame[j] = Math.max(frame[j], frame[j + 1] - 1);\\n\\n\\t\\t\\t\\tfor(long k:frame) System.out.println(k);\\n\\t\\t\\t}", "class Solution {\\n\\t\\tpublic long maxPoints(int[][] points) {\\n\\t\\t\\tlong[] frame = new long[points[0].length];\\n\\n\\t\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j <frame.length; j ++) frame[j] += points[i][j];\\n\\n\\t\\t\\t\\tfor (int j = 1; j < frame.length; j ++) frame[j] = Math.max(frame[j], frame[j - 1] - 1);\\n\\n\\t\\t\\t\\tfor (int j=frame.length-2;j>=0;j--) frame[j] = Math.max(frame[j], frame[j + 1] - 1);\\n\\n\\t\\t\\t\\tfor(long k:frame) System.out.println(k);\\n\\t\\t\\t}", "class Solution {\\n    public long maxPoints(int[][] points) {\\n        int n=points.length;\\n        int m=points[0].length;\\n        \\n        long dp[][]=new long[n][m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[0][i]=points[0][i];\\n        \\n        long left[]=new long[m];\\n        long right[]=new long[m];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            left[0]=dp[i-1][0];\\n            right[m-1]=dp[i-1][m-1];\\n            \\n            for(int j=1;j<m;j++)\\n                left[j]=Math.max(dp[i-1][j],left[j-1]-1);\\n            \\n            for(int j=m-2;j>=0;j--)\\n                right[j]=Math.max(dp[i-1][j],right[j+1]-1);\\n            \\n            for(int j=0;j<m;j++)\\n                dp[i][j]=Math.max(left[j],right[j])+points[i][j];\\n        }"]}
{"id": "1431", "ref_java": ["class Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        int targetStart = times[targetFriend][0];\\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\\n        \\n        PriorityQueue<Integer> available = new PriorityQueue<>();\\n        for (int i = 0; i < times.length; ++ i) {\\n            available.offer(i);\\n        }", "class Solution {\\n    public int smallestChair(int[][] times, int targetFriend) {\\n        \\n        int n = times.length;\\n        \\n        Pair arr[] = new Pair[n];\\n        Pair dept[] = new Pair[n];\\n        \\n        for(int i=0; i<n; i++){\\n            arr[i] = new Pair(i, times[i][0]);\\n            dept[i] = new Pair(i, times[i][1]);\\n        }", "class Solution {\\n  \\n    class Pair implements Comparable<Pair> {\\n        int seatNo;\\n        int leavingTime;\\n        \\n        Pair(int seatNo, int leavingTime){\\n            this.seatNo = seatNo;\\n            this.leavingTime = leavingTime;\\n        }"]}
{"id": "1432", "ref_java": ["\npublic List<List<Long>> splitPainting(int[][] segments) {\n    long mix[] = new long[100002], sum = 0, last_i = 0;\n    boolean ends[] = new boolean[100002];\n    List<List<Long>> res = new ArrayList<>();\n    for (var s : segments) {\n        mix[s[0]] += s[2];\n        mix[s[1]] -= s[2];\n        ends[s[0]] = ends[s[1]] = true;\n    }\n    for (int i = 1; i < 100002; ++i) {\n        if (ends[i] && sum > 0)\n            res.add(Arrays.asList(last_i, (long)i, sum));\n        last_i = ends[i] ? i : last_i;\n        sum += mix[i];\n    }    \n    return res;\n}\n", "\npublic List<List<Long>> splitPainting(int[][] segments) {\n    long mix[] = new long[100002], sum = 0, last_i = 0;\n    boolean ends[] = new boolean[100002];\n    List<List<Long>> res = new ArrayList<>();\n    for (var s : segments) {\n        mix[s[0]] += s[2];\n        mix[s[1]] -= s[2];\n        ends[s[0]] = ends[s[1]] = true;\n    }\n    for (int i = 1; i < 100002; ++i) {\n        if (ends[i] && sum > 0)\n            res.add(Arrays.asList(last_i, (long)i, sum));\n        last_i = ends[i] ? i : last_i;\n        sum += mix[i];\n    }    \n    return res;\n}\n", "\npublic List<List<Long>> splitPainting(int[][] segments) {\n    long mix[] = new long[100002], sum = 0, last_i = 0;\n    boolean ends[] = new boolean[100002];\n    List<List<Long>> res = new ArrayList<>();\n    for (var s : segments) {\n        mix[s[0]] += s[2];\n        mix[s[1]] -= s[2];\n        ends[s[0]] = ends[s[1]] = true;\n    }\n    for (int i = 1; i < 100002; ++i) {\n        if (ends[i] && sum > 0)\n            res.add(Arrays.asList(last_i, (long)i, sum));\n        last_i = ends[i] ? i : last_i;\n        sum += mix[i];\n    }    \n    return res;\n}\n"]}
{"id": "1433", "ref_java": ["class Solution {\\n    public String maximumNumber(String num, int[] change) {\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] - \\'0\\' < change[arr[i] - \\'0\\']) {\\n                while (i < arr.length && arr[i] - \\'0\\' <= change[arr[i] - \\'0\\']) {\\n                    arr[i] = (char) (change[arr[i] - \\'0\\'] + \\'0\\');\\n                    i++;\\n                }", "class Solution {\\n    public String maximumNumber(String num, int[] change) {\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] - \\'0\\' < change[arr[i] - \\'0\\']) {\\n                while (i < arr.length && arr[i] - \\'0\\' <= change[arr[i] - \\'0\\']) {\\n                    arr[i] = (char) (change[arr[i] - \\'0\\'] + \\'0\\');\\n                    i++;\\n                }", "class Solution {\\n    public String maximumNumber(String num, int[] change) {\\n        char[] sb = num.toCharArray();\\n\\n        int n =num.length();\\n        int i=0;\\n        \\n        "]}
{"id": "1434", "ref_java": ["class Solution {\\n\\t\\tint max;\\n\\t\\tpublic int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n\\t\\t\\tboolean[] visited = new boolean[students.length];\\n\\t\\t\\thelper(visited, students, mentors, 0, 0);\\n\\t\\t\\treturn max;\\n\\t\\t}", "class Solution {\\n    int ans;\\n    void helper(int[][] students,int[][] mentors,boolean track[],int index,int index2,int max)\\n    {\\n              int count=0;\\n                 for(int i=0;i<mentors[0].length;i++)\\n                  {\\n                      if(students[index][i]==mentors[index2][i])\\n                      {\\n                           count++;\\n                      }", "class Solution {\\n    private HashMap<String, Integer> dp;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        dp = new HashMap<String, Integer>();\\n        int[] map = new int[students.length];\\n        Stack<Integer> mentorstack = new Stack<Integer>();\\n        for (int i = 0; i < map.length; ++i) {\\n            map[i] = -1;\\n            mentorstack.push(i);\\n        }"]}
{"id": "1435", "ref_java": ["class Solution {\\n    public long numberOfWeeks(int[] milestones) {\\n     \\n    \\tint i,j,max=-1,n=milestones.length;\\n  \\n    \\tlong sum=0;\\n    \\tfor(i=0;i<n;i++)\\n    \\t{\\n    \\t\\tmax=Math.max(max, milestones[i]);\\n    \\t\\tsum+=milestones[i];\\n    \\t}", "class Solution {\\n    public long numberOfWeeks(int[] milestones) {\\n     \\n    \\tint i,j,max=-1,n=milestones.length;\\n  \\n    \\tlong sum=0;\\n    \\tfor(i=0;i<n;i++)\\n    \\t{\\n    \\t\\tmax=Math.max(max, milestones[i]);\\n    \\t\\tsum+=milestones[i];\\n    \\t}", "class Solution {\\n    public long numberOfWeeks(int[] milestones) {\\n        long totalSum = 0, max = 0;\\n\\n        for (int n : milestones) {\\n            totalSum += n;\\n            max = Math.max(max, n);\\n        }"]}
{"id": "1436", "ref_java": ["class Solution {\\n    public long minimumPerimeter(long neededApples) {\\n        long i=1, j=100000;\\n        while(i<j){\\n            long m=(j+i)/2;\\n            long apples=m*(m+1)*(4*m+2);\\n            if(apples<neededApples) i=m+1;\\n            else j=m;\\n        }", "class Solution {\\n    public long minimumPerimeter(long neededApples) {\\n        long i=1, j=100000;\\n        while(i<j){\\n            long m=(j+i)/2;\\n            long apples=m*(m+1)*(4*m+2);\\n            if(apples<neededApples) i=m+1;\\n            else j=m;\\n        }", "class Solution {\\n    public long minimumPerimeter(long neededApples) {\\n        long i=1, j=100000;\\n        while(i<j){\\n            long m=(j+i)/2;\\n            long apples=m*(m+1)*(4*m+2);\\n            if(apples<neededApples) i=m+1;\\n            else j=m;\\n        }"]}
{"id": "1437", "ref_java": ["class Solution {\\n    public boolean checkMove(char[][] board, int rMove, int cMove, char color) {\\n\\n        int[][] direction = {{1, 0}", "class Solution {\\n    private final List<Integer[]> moves = List.of(\\n            new Integer[] {0, -1, 0}", "class Solution {\\n    public boolean checkMove(char[][] board, int rMove, int cMove, char color) {\\n\\n        int[][] direction = {{1, 0}"]}
{"id": "1438", "ref_java": ["class Solution {\\n\\n", "class Solution {\\n\\n", "class Solution {\\n    int INF =  (int) (200 * 1e6);\\n    public int minSpaceWastedKResizing(int[] nums, int k) {\\n        int [][] dp = new int[nums.length][k+1];\\n        for(int i = 0; i < nums.length; i++)\\n            Arrays.fill(dp[i], -1);\\n        return GetMinSpace(0, k, nums, dp);\\n    }"]}
{"id": "1439", "ref_java": ["class Solution {\\n        public int minStoneSum(int[] A, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);\\n        int res = 0;\\n        for (int a : A) {\\n            pq.add(a);\\n            res += a;\\n        }", "class Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n      \\n         while(k > 0){ ", "class Solution {\\n        public int minStoneSum(int[] A, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);\\n        int res = 0;\\n        for (int a : A) {\\n            pq.add(a);\\n            res += a;\\n        }"]}
{"id": "1440", "ref_java": ["class Solution {\\n    public int minSwaps (String s) {\\n        Stack <Character> stack = new Stack ();\\n        int mismatch = 0;\\n        for (int i = 0; i < s.length (); i++) {\\n            char ch = s.charAt (i);\\n            if (ch == \\'[\\')\\n                stack.push (ch);\\n            else {\\n                if (!stack.isEmpty ())\\n                    stack.pop ();\\n                else \\n                    mismatch++;\\n            }", "class Solution {\\n    public int minSwaps(String s) {\\n        ", "class Solution {\\n    public int minSwaps(String s) {\\n        "]}
{"id": "1441", "ref_java": ["class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        boolean ch=false;\\n        while(ch==false)\\n        {\\n            r(nums);\\n            ch=check(nums);\\n        }", "class Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        int temp;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==(nums[i-1]+nums[i+1])/2)\\n            {\\n                temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n                if(i>=2) i=i-2;\\n            }", "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n       Arrays.sort(nums);\\n\\t   "]}
{"id": "1442", "ref_java": ["class Solution {\\n    public int mod = 1_000_000_007;\\n    public int minNonZeroProduct(int p) {\\n        if (p == 1) return 1;\\n        \\n        long mx = (long)(Math.pow(2, p)) - 1;\\n        long sm = mx - 1;\\n        long n = sm/2;\\n        long sum = rec(sm, n);\\n        \\n        return (int)(sum * (mx % mod) % mod); \\n    }", "class Solution {\\n    int mod = 1000_000_007;\\n    public int minNonZeroProduct(int p) {\\n        if(p==1) return 1;\\n        long n= (long)Math.pow(2,p)-1;\\n        long res = ((n%mod) * power((n-1), n/2) );\\n        return (int)(res%mod);\\n    }", "class Solution {\\n\\n    "]}
{"id": "1443", "ref_java": ["class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        ", "class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        long ans = 0;\\n        int neg = 0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] < 0) {\\n                    neg++;\\n                }", "class Solution {\\n    public long maxMatrixSum(int[][] matrix) {\\n        int r = matrix.length, c = matrix[0].length;\\n\\t\\tlong ans = 0;\\n        boolean alwaystakeAbs = true; "]}
{"id": "1444", "ref_java": ["class Solution {\\n    public int MOD = (int)(1e9 +7);\\n    public int countPaths(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> list = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            list.add(new ArrayList<>());\\n        }", "class Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        \\n        ", "class Solution {\\n    public int MOD = (int)(1e9 +7);\\n    public int countPaths(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> list = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            list.add(new ArrayList<>());\\n        }"]}
{"id": "1445", "ref_java": ["class Solution {\\n    public String findDifferentBinaryString(String[] nums) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sb.append(nums[i].charAt(i) == \\'0\\'? \"1\": \"0\");\\n        }", "class Solution {\\n    public String findDifferentBinaryString(String[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n\\n        for (String binaryString : nums) {\\n            seen.add(Integer.parseInt(binaryString, 2));\\n        }", "class Solution {\\n    public String findDifferentBinaryString(String[] nums) {\\n        int size = nums.length; "]}
{"id": "1446", "ref_java": ["class Solution {\\n    public int minimizeTheDifference(int[][] mat, int t) {\\n        int m= mat.length;\\n        int[][] dp= new int[m][5001];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<5001; j++){\\n                dp[i][j]=-1;\\n            }", "class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Integer[][] dp = new Integer[mat.length][5001];\\n        return minDiff(mat, 0, target,0, dp);\\n    }", "class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Integer[][] dp = new Integer[mat.length][5001];\\n        return minDiff(mat, 0, target,0, dp);\\n    }"]}
{"id": "1447", "ref_java": ["class Solution {\\n    public String kthLargestNumber(String[] nums, int k) {\\n        Comparator<String> comparator = Comparator.comparing(String::length).reversed()\\n                .thenComparing(Comparator.reverseOrder());\\n        \\n        Arrays.sort(nums, comparator);\\n\\n        return nums[k - 1];\\n    }", "class Solution {\\n    public String kthLargestNumber(String[] arr, int k) {\\n    PriorityQueue<BigInteger> pq = new PriorityQueue<>();\\n        for(int i = 0; i < arr.length; i++){\\n            if(i < k){\\n                pq.add(new BigInteger(arr[i]));\\n            }", "class Solution {\\n    public String kthLargestNumber(String[] nums, int k) {\\n"]}
{"id": "1448", "ref_java": ["class Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length, MAX = Integer.MAX_VALUE;\\n        int[][] dp = new int[1<<n][2];\\n        dp[0][0] = 1;\\n        dp[0][1] = 0;\\n        \\n        for(int i = 1; i < (1 << n); i++) {\\n            dp[i][0] = MAX;\\n            dp[i][1] = 0;\\n            \\n            for(int t = 0; t < n; t++) {\\n                if(((1<<t) & i) == 0) continue;\\n                \\n                int[] prev = dp[(1<<t) ^ i];\\n                if(prev[1] + tasks[t] <= sessionTime) {\\n                    dp[i] = min(dp[i], new int[]{prev[0], prev[1] + tasks[t]}", "class Solution {\\n    int minBucket = Integer.MAX_VALUE;\\n    public void helper(int[] tasks, int time, int index, List<Integer> buckets){\\n        \\n        ", "class Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        "]}
{"id": "1449", "ref_java": ["class Solution {\\n    int[] arr;\\n    public int[][] findFarmland(int[][] land) {\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<land.length;i++)\\n            for(int j=0;j<land[0].length;j++){\\n                if(land[i][j] == 1){\\n                    arr = new int[]{i,j,0,0}", "class Solution {\\n    int[] arr;\\n    public int[][] findFarmland(int[][] land) {\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<land.length;i++)\\n            for(int j=0;j<land[0].length;j++){\\n                if(land[i][j] == 1){\\n                    arr = new int[]{i,j,0,0}", "class Solution {\\n    int endRow = 0, endCol = 0;         "]}
{"id": "1451", "ref_java": ["class Solution {\\n    public int numberOfWeakCharacters(int[][] properties) {\\n        \\n        ", "class Solution {\\n    public int numberOfWeakCharacters(int[][] properties) {\\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\\n        int count = 0, max = 0;\\n        for(int[] arr: properties){\\n            if(arr[1] < max)    count++;\\n            max = Math.max(max, arr[1]);\\n        }", "class Solution {\\n    public int numberOfWeakCharacters(int[][] arr) {\\n        Arrays.sort(arr, (a, b) -> {\\n           if(a[0] != b[0]){ \\n\\t\\t\\t   "]}
{"id": "1452", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\\n        int mod = 1_000_000_007;\\n        int n = nextVisit.length;\\n        long dp[] = new long[n];\\n        for (int i = 1; i < n; ++i) {\\n            dp[i] = (dp[i - 1] + dp[i - 1] - dp[nextVisit[i - 1]] + 2 + mod) % mod;\\n        }", "class Solution {\\n    public int firstDayBeenInAllRooms(int[] next) {\\n        int i,j,n=next.length;\\n        long mod=1000_000_007l;\\n        long dp[]=new long[n];\\n        dp[0]=0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(next[i-1]==i-1)\\n            {\\n                dp[i]=(dp[i-1]+2)%mod;\\n            }"]}
{"id": "1453", "ref_java": ["class Solution {\\n    public long interchangeableRectangles(int[][] rectangles) {\\n        Map<Double,Long> mp = new HashMap<Double,Long>();\\n        long anss = 0;\\n         for(int i=0;i<rectangles.length;i++){\\n          ", "class Solution {\\n    public long interchangeableRectangles(int[][] rectangles) {\\n        \\n        HashMap<Double, Long> map = new HashMap<>();\\n        long count = 0;\\n\\t\\t\\n        for (int[] A : rectangles) {\\n\\t\\t\\n            double x = A[0];\\n            double y = A[1];\\n            double division = (double) x / y;\\n\\t\\t\\t\\n            if (map.containsKey(division)) {\\n                count += map.get(division);\\n            }", "class Solution {\\n    public long interchangeableRectangles(int[][] rec) {\\n        \\n        int i,j,n=rec.length;\\n        long sum=0;\\n        Map<Double,Integer> map=new HashMap();\\n        for(i=0;i<n;i++)\\n            map.put((double)rec[i][0]/rec[i][1],map.getOrDefault((double)rec[i][0]/rec[i][1],0)+1);\\n        for(Double key : map.keySet())\\n            sum+=(long)map.get(key)*(map.get(key)-1)/2;\\n        return sum;\\n    }"]}
{"id": "1454", "ref_java": ["class Solution {\\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        int n = strArr.length;\\n        Map<Integer, Integer> pali = new HashMap<>();\\n        ", "class Solution {\\n    \\n    int max = 0;\\n    public int maxProduct(String s) {\\n        \\n        char[] c = s.toCharArray();\\n        dfs(c, 0, \"\", \"\");\\n        \\n        return max;\\n    }", "class Solution {\\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        int n = strArr.length;\\n        Map<Integer, Integer> pali = new HashMap<>();\\n        "]}
{"id": "1455", "ref_java": ["class Solution {\\n    public int[] findOriginalArray(int[] changed) {\\n        \\n        int len = changed.length;\\n        if((len&1) != 0) return new int[0];\\n        \\n        ", "class Solution { \\n    int[] res;\\n    int index=0;\\n    public int[] findOriginalArray(int[] changed) {\\n        if(changed.length%2==1) return new int[0];\\n        res = new int[changed.length/2];\\n        \\n        int max = 0;\\n        for(int num: changed) max = Math.max(max, num);\\n        int[] nums = new int[max+1];\\n        for(int num: changed) nums[num]++;\\n        \\n        if(nums[0]%2==1) return new int[0];\\n        fill(0, nums[0]/2);\\n        \\n        for(int i=1; i<=max/2; i++){\\n            if(nums[2*i] < nums[i]) return new int[0];\\n            nums[2*i] -= nums[i];\\n            fill(i, nums[i]);\\n        }", "class Solution {\\n    public int[] findOriginalArray(int[] changed) {\\n        Arrays.sort(changed);\\n        int n = changed.length, original[]=new int[n/2],i=0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num: changed){\\n            if(num%2==0 && map.containsKey(num/2)){\\n                remove(num/2,map);\\n                original[i++]=num/2;\\n            }"]}
{"id": "1456", "ref_java": ["class Solution {\\n    public long maxTaxiEarnings(int n, int[][] rides) {\\n        Arrays.sort(rides, (a,b)->(a[1]-b[1]));\\n        TreeMap<Integer, Long> dp=new TreeMap<>();\\n        dp.put(0, 0L);\\n        for(int[] ride:rides){\\n            Long currProfit = dp.floorEntry(ride[0]).getValue() + (ride[1]-ride[0]+ride[2]);\\n            if(currProfit>dp.lastEntry().getValue()){\\n                dp.put(ride[1], currProfit);\\n            }", "class Solution {\\n    public long maxTaxiEarnings(int n, int[][] rides) {\\n        ", "class Solution {\\n\\n  private static final long CACHE_MISS = -1L;\\n\\n  public long maxTaxiEarnings(int n, int[][] rides) {\\n    Arrays.sort(rides, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    long[] cache = new long[rides.length];\\n    Arrays.fill(cache, CACHE_MISS);\\n    return recurse(rides, 0, cache);\\n  }"]}
{"id": "1457", "ref_java": ["class Solution {\\n     ArrayList<Integer>vec1=new ArrayList<>();\\n    public void lg(int [] nums){\\n        Stack<Integer>st=new Stack<>();\\n        int i=0;\\n        while(i<nums.length){\\n            \\n            if(st.size()==0)vec1.add(-1);\\n            else if(st.peek()>=nums[i]){\\n                vec1.add(st.peek());\\n            }", "class Solution {\\n     ArrayList<Integer>vec1=new ArrayList<>();\\n    public void lg(int [] nums){\\n        Stack<Integer>st=new Stack<>();\\n        int i=0;\\n        while(i<nums.length){\\n            \\n            if(st.size()==0)vec1.add(-1);\\n            else if(st.peek()>=nums[i]){\\n                vec1.add(st.peek());\\n            }", "class Solution {\\n     ArrayList<Integer>vec1=new ArrayList<>();\\n    public void lg(int [] nums){\\n        Stack<Integer>st=new Stack<>();\\n        int i=0;\\n        while(i<nums.length){\\n            \\n            if(st.size()==0)vec1.add(-1);\\n            else if(st.peek()>=nums[i]){\\n                vec1.add(st.peek());\\n            }"]}
{"id": "1459", "ref_java": ["class Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long prev[]=new long[n];\\n        long suf[] = new long[n];\\n        for(int i = 1;i<n;i++)\\n            prev[i]=prev[i-1]+grid[0][i];\\n        for(int i =n-2;i>=0;i--)\\n            suf[i]=grid[1][i]+suf[i+1];\\n        long ans=Math.min(prev[n-1],suf[0]);\\n        for(int i=1;i<n-1;i++){\\n            long cur=Math.max(prev[n-1]-prev[i],suf[0]-suf[i]);\\n            if(cur>0)\\n            ans=Math.min(ans,cur);\\n        }", "class Solution {\\n    public long gridGame(int[][] grid) {\\n        return util2(grid);\\n    }", "class Solution {\\n    public long gridGame(int[][] grid) {\\n        return util2(grid);\\n    }"]}
{"id": "1460", "ref_java": ["class Solution {\\n    public boolean horizontally(char[][] board, int r, int c, String word){\\n        if(c - 1 >= 0 && board[r][c - 1] != \\'#\\') return false;\\n\\n        for(char ch: word.toCharArray()){\\n            if(c == board[0].length) return false;\\n            if(board[r][c] != \\' \\' && board[r][c] != ch)\\n                return false;\\n            c++;\\n        }", "class Solution {\\n    \\n    ", "class Solution {\\n    \\n    public boolean placeWordInCrossword(char[][] board, String word) {\\n        if (word.length() == 0) return true;\\n\\t\\tint m = board.length;\\n\\t\\tif (m == 0) return false;\\n\\t\\tint n = board[0].length;\\n\\n        "]}
{"id": "1461", "ref_java": ["class Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(i != j){\\n                String str = nums[i].concat(nums[j]);\\n                if(str.equals(target)){\\n                    ans++;\\n                    }", "class Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(i != j){\\n                String str = nums[i].concat(nums[j]);\\n                if(str.equals(target)){\\n                    ans++;\\n                    }", "class Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;\\n        int ans=0;\\n        for(int i =0;i<n;i++){\\n            for(int j =0; j<n;j++){\\n                if( i != j){\\n                    String str = nums[i] + nums[j];\\n                    if (str.equals(target)){\\n                        ans++;\\n                    }"]}
{"id": "1462", "ref_java": ["class Solution {\\n    public int maxConsecutiveAnswers(String s, int k) {\\n        int start=0,end=0,ans=0,count=0,n=s.length();\\n        \\n        ", "class Solution {\\n\\tpublic int maxConsecutiveAnswers(String answerKey, int k) {\\n\\t\\t     int ans = 0;\\n        int max_count = 0;\\n        int[] count = new int[2];\\n        for(int l = 0,r=0;r<answerKey.length();r++)\\n        {\\n            max_count = Math.max(max_count,++count[answerKey.charAt(r) == \\'T\\' ? 1: 0]);\\n            while(max_count + k < r-l+1)\\n            {\\n                --count[answerKey.charAt(l++) == \\'T\\'? 1 : 0];\\n            }", "class Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int n = answerKey.length();\\n        int maxConsecutive = 0;\\n        int maxCount = 0;\\n        int left = 0;\\n        int[] counts = new int[26];\\n        \\n        for (int right = 0; right < n; right++) {\\n            counts[answerKey.charAt(right) - \\'A\\']++;\\n            maxCount = Math.max(maxCount, counts[answerKey.charAt(right) - \\'A\\']);\\n            \\n            while (right - left + 1 - maxCount > k) {\\n                counts[answerKey.charAt(left) - \\'A\\']--;\\n                left++;\\n            }"]}
{"id": "1463", "ref_java": ["class Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n    \\tint i,m=rolls.length,sum=0;\\n    \\tfor(i=0;i<m;i++)\\n    \\t\\tsum+=rolls[i];\\n\\t\\t\\t\\n    \\tint x=(mean*(m+n))-sum;\\n\\t\\t\\n\\t\\tif(x<=0||n*6<x||((x/n)==0)) {\\n    \\t\\treturn new int[] {}", "class Solution {\\n    private int[] makeSum(int sum, int[] arr) {\\n        int currentSum = arr.length;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            while (arr[i] < 6 && currentSum < sum) {\\n                arr[i]++;\\n                currentSum++;\\n            }", "class Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n    \\tint i,m=rolls.length,sum=0;\\n    \\tfor(i=0;i<m;i++)\\n    \\t\\tsum+=rolls[i];\\n\\t\\t\\t\\n    \\tint x=(mean*(m+n))-sum;\\n\\t\\t\\n\\t\\tif(x<=0||n*6<x||((x/n)==0)) {\\n    \\t\\treturn new int[] {}"]}
{"id": "1464", "ref_java": ["class Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        if (stones.length == 1) {\\n            return false;\\n        }", "class Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n        Map<Integer, Integer> div3 = new HashMap<>();\\n        div3.put(0, 0);\\n        div3.put(1, 0);\\n        div3.put(2, 0);\\n        \\n        for(int stone : stones){\\n            div3.put(stone%3, div3.get(stone%3)+1);\\n        }", "class Solution {\\n    public boolean stoneGameIX(int[] stones) {\\n\\t    int[] count = new int[3];\\n\\t    for(int stone:stones){\\n            count[stone%3]++;\\n        }"]}
{"id": "1465", "ref_java": ["class Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int sum = 0, m = grid.length, n = grid[0].length, c = 0;\\n        int[] arr = new int[m * n];\\n        boolean containsEven = false, containsOdd = false;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sum += grid[i][j];\\n                arr[c++] = grid[i][j];\\n                if (!containsEven || !containsOdd) {\\n                    if (grid[i][j] % 2 == 1) containsOdd = true;\\n                    else containsEven = true;\\n                }", "class Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] arr = new int[grid.length * grid[0].length];\\n        int index = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                arr[index++] = grid[i][j];\\n            }", "class Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int sum = 0, m = grid.length, n = grid[0].length, c = 0;\\n        int[] arr = new int[m * n];\\n        boolean containsEven = false, containsOdd = false;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sum += grid[i][j];\\n                arr[c++] = grid[i][j];\\n                if (!containsEven || !containsOdd) {\\n                    if (grid[i][j] % 2 == 1) containsOdd = true;\\n                    else containsEven = true;\\n                }"]}
{"id": "1467", "ref_java": ["class Solution {\\n    public boolean winnerOfGame(String colors) {\\n        return colors.replaceAll(\"A{3,}", "class Solution {\\n    public boolean winnerOfGame(String colors) {\\n        int alice_plays = 0, bob_plays = 0, count = 0;\\n        \\n        for (int i = 1; i < colors.length(); i++) {\\n            if (colors.charAt(i) == colors.charAt(i - 1)) {\\n                count++;\\n            }", "class Solution {\\n    public bool WinnerOfGame(string colors) {\\n        int countA = 0;\\n        int countB = 0;\\n        \\n        for (int i = 0; i < colors.Length; i++) {\\n            char x = colors[i];\\n            int count = 0;\\n            \\n            while (i < colors.Length && colors[i] == x) {\\n                i++;\\n                count++;\\n            }"]}
{"id": "1468", "ref_java": ["class Solution {\\n    private int getLastSend(int d, int p) {\\n        if (p >= 2 * d) {\\n            return 0;\\n        }", "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        \\n\\t\\t", "class Solution {\\n\\t\\n    List<Integer> adj[];\\n\\tint min[];\\n\\tboolean vis[];\\n\\tvoid dfs(int i,int level)\\n\\t{\\n\\t\\tfor(Integer ele : adj[i])\\n\\t\\t{\\n\\t\\t\\tif(vis[ele])\\n\\t\\t\\t{\\n                if(min[ele]>level*2) {\\n\\t\\t\\t\\t\\n                    min[ele]=level*2;\\n                    dfs(ele,level+1);\\n                }"]}
{"id": "1470", "ref_java": ["class Solution {\\n    List<Integer> or = new ArrayList<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        helper(0,nums,0);\\n        Collections.sort(or,Collections.reverseOrder());\\n        int max = or.get(0);\\n        int answer = 0;\\n        for(Integer i:or){\\n            if(max==i) answer++;\\n            else break;\\n        }", "class Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return count;\\n    }", "class Solution {\\n    private int result = 0;\\n    private int maxOR;\\n    private int[] nums;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        if(nums.length == 1){\\n            return 1;\\n        }"]}
{"id": "1471", "ref_java": ["class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int small[] = {1, 22, 122, 212, 221, 333,1333, 3133, 3313, 3331,4444}", "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n        int num = n + 1;\\n\\n        while (!isNumericallyBalanced(num)) {\\n            num++;\\n        }", "class Solution {\\n    public int nextBeautifulNumber(int n) {\\n\\n        while(true){\\n            n++;\\n           int num = n; "]}
{"id": "1472", "ref_java": ["class Solution {\\n    \\n   public int countHighestScoreNodes(int[] parents) {\\n        Node[] nodes = buildTree(parents);\\n        long[] highestScore = {0,0}", "class Solution {\\n    long max = 0, res = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n        Map<Integer, List<Integer>> hm = new HashMap();\\n        for(int i = 0; i < parents.length; i++) {   ", "class Solution {\\n    \\n   public int countHighestScoreNodes(int[] parents) {\\n        Node[] nodes = buildTree(parents);\\n        long[] highestScore = {0,0}"]}
{"id": "1473", "ref_java": ["class Solution {\\n    public int maxTwoEvents(int[][] events) \\n    {\\n        Arrays.sort(events , (a,b)-> a[0]!=b[0]?a[0]-b[0]:a[1]-b[1]);\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        int max = 0 , ans = 0;\\n        pq.add(new int[]{events[0][1] , events[0][2]}", "class Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int dp[][] = new int[events.length][3],output = 0;\\n        for(int row[]:dp) Arrays.fill(row,-1);\\n        Arrays.sort(events,(a,b)->(a[0]-b[0]));\\n        int out =  find(dp,events,0,2);\\n        for(int row[]:events) output = Math.max(output,row[2]);\\n        return Math.max(out,output);\\n    }", "class Solution {\\n    public int maxValue(int[][] events, int k) {\\n        "]}
{"id": "1474", "ref_java": ["class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n= s.length();\\n        int[] preSum=new int[n];\\n        if(s.charAt(0)==\\'*\\'){\\n            preSum[0]=1;\\n        }", "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n= s.length();\\n        int[] preSum=new int[n];\\n        if(s.charAt(0)==\\'*\\'){\\n            preSum[0]=1;\\n        }", "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n= s.length();\\n        int[] preSum=new int[n];\\n        if(s.charAt(0)==\\'*\\'){\\n            preSum[0]=1;\\n        }"]}
{"id": "1475", "ref_java": ["class Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int ans[] = new int[2];\\n        ans[0]= -1;\\n        ans[1] = -1;\\n\\n        if(head==null || head.next==null || head.next.next==null) return ans;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        ListNode t = head.next;\\n\\n        ListNode prev = head;\\n        int idx = 1;\\n\\n        while(t.next!=null){\\n            if(t.val>prev.val && t.val>t.next.val) arr.add(idx);\\n            if(t.val<prev.val && t.val<t.next.val) arr.add(idx);\\n\\n            idx++;\\n            prev = t;\\n            t=t.next;\\n        }", "class Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head.next.next==null) return new int[]{-1,-1}", "class Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head.next.next==null) return new int[]{-1,-1}"]}
{"id": "1476", "ref_java": ["class Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        \\n\\n        \\n               Queue<Integer> q = new LinkedList();\\n               HashSet<Integer> set = new HashSet();\\n             int count = 0;\\n             q.add(start);\\n             while(!q.isEmpty()){\\n\\n                 int size = q.size();\\n                 for(int i=0;i<size;i++){\\n\\n                     int front = q.remove();\\n                     if(front == goal) return count;\\n                     if(front>1000 || front<0 || set.contains(front)) continue;\\n                     set.add(front);\\n                     for(int num : nums){\\n                      \\n                         q.add(front  - num);\\n                         q.add(front + num);\\n                         q.add(front^num);\\n                     }", "class Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int res = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        q.offer(start);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i = 0;i<size;i++){\\n                int val = q.poll();\\n                if(val == goal)return res;\\n                if((val < 0 || val > 1000) || set.contains(val))continue;\\n                if(!set.contains(val))set.add(val);\\n\\n                for(int num : nums){\\n                    q.offer(val + num);\\n                    q.offer(val - num);\\n                    q.offer(val ^ num);\\n                }", "class Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        \\n\\n        \\n               Queue<Integer> q = new LinkedList();\\n               HashSet<Integer> set = new HashSet();\\n             int count = 0;\\n             q.add(start);\\n             while(!q.isEmpty()){\\n\\n                 int size = q.size();\\n                 for(int i=0;i<size;i++){\\n\\n                     int front = q.remove();\\n                     if(front == goal) return count;\\n                     if(front>1000 || front<0 || set.contains(front)) continue;\\n                     set.add(front);\\n                     for(int num : nums){\\n                      \\n                         q.add(front  - num);\\n                         q.add(front + num);\\n                         q.add(front^num);\\n                     }"]}
{"id": "1477", "ref_java": ["class Solution {\\n    \\n    boolean isVowel(char ch) {\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }", "class Solution {\\n    public boolean isVowel(char ch){\\n        return ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\';\\n    }", "class Solution {\\n    public boolean isVowel(char ch){\\n        return ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\';\\n    }"]}
{"id": "1478", "ref_java": ["class Solution {\\n    public int n = 0;\\n\\n    public int[] quantities;\\n\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        this.n = n;\\n        this.quantities = quantities;\\n\\n        ", "class Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        int lo = 1;\\n        int hi = (int)1e5;\\n        \\n        int ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = (lo + hi)/2;\\n            \\n            if(isItPossible(mid, quantities, n)){\\n                ans = mid;\\n                hi = mid-1;\\n            }", "class Solution {\\n    public int minimizedMaximum(int n, int[] quantities) {\\n        \\n        int lo = 1;\\n        int hi = (int)1e5;\\n        \\n        int ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = (lo + hi)/2;\\n            \\n            if(isItPossible(mid, quantities, n)){\\n                ans = mid;\\n                hi = mid-1;\\n            }"]}
{"id": "1480", "ref_java": ["class Solution {\\n\\tpublic int[] maximumBeauty(int[][] items, int[] q) {\\n\\n\\t\\tint n = items.length,i=0;\\n\\n\\t\\tpair[] p = new pair[n];\\n \\n\\t\\tfor (int[] x : items) {\\n\\t\\t\\tint pii = x[0];\\n\\t\\t\\tint b = x[1];\\n\\t\\t\\tpair pi = new pair(pii, b);\\n\\t\\t\\tp[i] = pi;\\n\\n\\t\\t\\tbe[i] = maxb;\\n\\t\\t\\ti++;\\n\\t\\t}", "class Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; ", "class Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        TreeMap<Integer, Integer> priceToBeauty = new TreeMap<>();\\n        for (int[] item : items) {\\n            priceToBeauty.put(item[0], Math.max(priceToBeauty.getOrDefault(item[0], 0), item[1]));\\n        }"]}
{"id": "1481", "ref_java": ["class Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }", "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   ", "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   "]}
{"id": "1482", "ref_java": ["\npublic String decodeCiphertext(String encodedText, int rows) {\n    int sz = encodedText.length(), cols = sz / rows;\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < cols; ++i)\n        for (int j = i; j < sz; j += cols + 1)\n            sb.append(encodedText.charAt(j));\n    return sb.toString().stripTrailing();\n}\n", "\npublic String decodeCiphertext(String encodedText, int rows) {\n    int sz = encodedText.length(), cols = sz / rows;\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < cols; ++i)\n        for (int j = i; j < sz; j += cols + 1)\n            sb.append(encodedText.charAt(j));\n    return sb.toString().stripTrailing();\n}\n", "\npublic String decodeCiphertext(String encodedText, int rows) {\n    int sz = encodedText.length(), cols = sz / rows;\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < cols; ++i)\n        for (int j = i; j < sz; j += cols + 1)\n            sb.append(encodedText.charAt(j));\n    return sb.toString().stripTrailing();\n}\n"]}
{"id": "1483", "ref_java": ["class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n\\t\\n     int n=plants.length;\\n        int ans=0;\\n        int temp=capacity;", "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int t=capacity;\\n        int idx=0;\\n        int c=0;\\n       for(int i=0;i<plants.length;)\\n       {\\n           if(t>=plants[i])\\n           {\\n               t-=plants[i];\\n               c++;\\n               i++;\\n           }", "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n\\t\\n     int n=plants.length;\\n        int ans=0;\\n        int temp=capacity;"]}
{"id": "1485", "ref_java": ["class Solution {\\n    public int minimumBuckets(String h) {\\n        var hamsters = h.toCharArray();\\n        for(int i = 0; i < hamsters.length;i++)\\n        {\\n            if(hamsters[i] == \\'H\\')\\n            {\\n                if(i - 1 >= 0 && hamsters[i - 1] == \\'B\\')\\n                continue;\\n\\n                if(i + 1 < hamsters.length && hamsters[i + 1] == \\'.\\')\\n                hamsters[i+1] = \\'B\\';\\n                else if(i - 1 >= 0 && hamsters[i - 1] == \\'.\\')\\n                hamsters[i-1] = \\'B\\';\\n                else\\n                return -1;\\n            }", "class Solution {\\n    public int minimumBuckets(String h) {\\n        var hamsters = h.toCharArray();\\n        for(int i = 0; i < hamsters.length;i++)\\n        {\\n            if(hamsters[i] == \\'H\\')\\n            {\\n                if(i - 1 >= 0 && hamsters[i - 1] == \\'B\\')\\n                continue;\\n\\n                if(i + 1 < hamsters.length && hamsters[i + 1] == \\'.\\')\\n                hamsters[i+1] = \\'B\\';\\n                else if(i - 1 >= 0 && hamsters[i - 1] == \\'.\\')\\n                hamsters[i-1] = \\'B\\';\\n                else\\n                return -1;\\n            }", "class Solution {\\n    public int minimumBuckets(String street)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        if(!street.contains(\".\")) return -1;\\n        int count = 0;\\n        for(int i=0;i<street.length();i++)\\n        {\\n            if(street.charAt(i)==\\'H\\')\\n            {\\n                if((i==0 && street.charAt(i+1)==\\'H\\')||(i==street.length()-1 && street.charAt(i-1)==\\'H\\'))\\n                    return -1;\\n                else if(i!=0 && i!=street.length()-1 && street.charAt(i+1)==\\'H\\' && street.charAt(i-1)==\\'H\\')\\n                    return -1;\\n            }"]}
{"id": "1486", "ref_java": ["class Solution {\\n\\tpublic int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n\\t\\tint sum = 0;\\n\\t\\twhile (startPos[0] != homePos[0]) {\\n\\t\\t\\tif (startPos[0] < homePos[0]) {\\n\\t\\t\\t\\tsum += rowCosts[++startPos[0]];\\n\\t\\t\\t}", "class Solution {\\n   \\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int sr = startPos[0];\\n        int sc = startPos[1];\\n        int hr = homePos[0];\\n        int hc = homePos[1];\\n        int cost = 0;\\n        while(sr!=hr){\\n          if(sr<hr) cost+=rowCosts[++sr];\\n          else cost+=rowCosts[--sr];\\n        }", "class Solution {\\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\\n        int total = 0;\\n        \\n        "]}
{"id": "1487", "ref_java": ["class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        ", "class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        int windowSize = 2*k+1;\\n        if(n < windowSize){\\n            return ans;\\n        }", "class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        "]}
{"id": "1488", "ref_java": ["class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min =Integer.MAX_VALUE;\\n        int max =Integer.MIN_VALUE;\\n        int minI =0 ,maxI=0;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]>max)\\n            {   \\n                max = nums[i];\\n                maxI = i;\\n            \\n            }", "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int i=0,j=nums.length-1,pnt1=1,pnt2=1,min=Integer.MIN_VALUE,max=Integer.MAX_VALUE;\\n        for(int z=0;z<nums.length;z++){\\n            if(nums[z]>min)\\n            min=nums[z];\\n             if(nums[z]<max)\\n            max=nums[z];\\n        }", "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int i=0,j=nums.length-1,pnt1=1,pnt2=1,min=Integer.MIN_VALUE,max=Integer.MAX_VALUE;\\n        for(int z=0;z<nums.length;z++){\\n            if(nums[z]>min)\\n            min=nums[z];\\n             if(nums[z]<max)\\n            max=nums[z];\\n        }"]}
{"id": "1489", "ref_java": ["class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head.next==null || head==null) {\\n            return null;\\n        }", "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null){\\n            return null;\\n        }", "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode temp = head;\\n        ListNode empty = new ListNode();\\n        if(temp == null||temp.next ==null){\\n            temp = null;\\n            return temp;\\n        }"]}
{"id": "1490", "ref_java": ["class Solution {\\n    static byte[] path = new byte[200_001];\\n    int strtLevel = -1; \\n    int destLevel = -1;\\n    int comnLevel = -1;\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        findPaths(root, startValue, destValue, 100_000);\\n        int answerIdx = comnLevel;\\n        for (int i = strtLevel; i > comnLevel; i--)  \\n            path[--answerIdx] = \\'U\\';\\n        return new String(path, answerIdx, destLevel - answerIdx);\\n    }", "class Solution {\\n    static byte[] path = new byte[200_001];\\n    int strtLevel = -1; \\n    int destLevel = -1;\\n    int comnLevel = -1;\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        findPaths(root, startValue, destValue, 100_000);\\n        int answerIdx = comnLevel;\\n        for (int i = strtLevel; i > comnLevel; i--)  \\n            path[--answerIdx] = \\'U\\';\\n        return new String(path, answerIdx, destLevel - answerIdx);\\n    }", "class Solution {\\n    \\n    private boolean DFS(TreeNode currNode, StringBuilder path, int destVal) {\\n        if(currNode == null) return false;\\n        if(currNode.val == destVal) return true;\\n        if(DFS(currNode.left, path, destVal)) path.append(\"L\");\\n        else if(DFS(currNode.right, path, destVal)) path.append(\"R\");\\n        return path.length() > 0;\\n    }"]}
{"id": "1491", "ref_java": ["class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = security.length;\\n        List<Integer> arr = new ArrayList<>();\\n        if(time>=n) {return arr;}", "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] nonincrease = new int[security.length];\\n        for(int i = 1; i < security.length - time; i++){\\n            if(security[i]>security[i-1]){\\n                nonincrease[i] = 0;\\n            }", "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> list = new ArrayList<>();\\n        int n=security.length;\\n        int dpbef[]=new int[n];\\n        int dpaft[]=new int[n];\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n               dpbef[i]=dpbef[i-1]+1;\\n            }"]}
{"id": "1492", "ref_java": ["class Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        var G = new Graph(bombs);\\n        var cc = new CC(G);\\n        return cc.maxComponent();\\n    }", "class Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int ans  = 0;\\n        int n = bombs.length;\\n        boolean[] visited = new boolean[n];\\n        int var;\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(visited, false);\\n            var = dfs(i, bombs, visited);\\n            ans = Math.max(ans, var);\\n        }", "class Solution {\\n    "]}
{"id": "1493", "ref_java": ["class Solution {\\n    class Node{\\n        long val, displace;\\n        Node(long val, long displace){\\n            this.val = val;\\n            this.displace = displace;\\n        }", "class Solution {\\n    class Node{\\n        long val, displace;\\n        Node(long val, long displace){\\n            this.val = val;\\n            this.displace = displace;\\n        }", "class Solution {\\n    class Node{\\n        long val, displace;\\n        Node(long val, long displace){\\n            this.val = val;\\n            this.displace = displace;\\n        }"]}
{"id": "1494", "ref_java": ["class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        ", "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length, ai = 0, bi = n - 1, ac = capacityA, bc = capacityB, c = 0;\\n        ", "class Solution {\\n    public int minimumRefill(int[] p, int ca, int cb) {                \\n\\t\\n        int refill= 0,oca =  ca, ocb =  cb;"]}
{"id": "1495", "ref_java": ["class Solution {\\n    public String addSpaces(String s, int[] spaces) {\\n        StringBuilder bd = new StringBuilder();\\n        int k=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            String a = \"\";\\n            if(k<spaces.length && i==spaces[k])\\n            {\\n                a = a + s.charAt(i);\\n                bd.append(\" \");\\n                k++;\\n            }", "class Solution {\\n    public String addSpaces(String s, int[] spaces) {\\n        String []words=new String[spaces.length+1];\\n        int count=0;\\n        for(int i=0;i<spaces.length;i++){\\n            if(i==0){\\n            words[count]=s.substring(0,spaces[i]);\\n            count++;\\n            }", "class Solution {\\n    public String addSpaces(String s, int[] spaces) {\\n        int n = s.length();\\n        int m = spaces.length;\\n        StringBuilder sb = new StringBuilder();\\n        int s1 = 0, s2 = 0;\\n        while(s1 < n && s2 < m){\\n            if(s1 != spaces[s2]){\\n                sb.append(s.charAt(s1));\\n                s1++;\\n            }"]}
{"id": "1496", "ref_java": ["class Solution {\\n    public static long getDescentPeriods(int[] prices) {\\n        long dp=1;\\n        long ans=1;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i-1]-1==prices[i])\\n                dp++;\\n            else\\n                dp=1;\\n            ans+=dp;\\n        }", "class Solution {\\n    public static long getDescentPeriods(int[] prices) {\\n        long dp=1;\\n        long ans=1;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i-1]-1==prices[i])\\n                dp++;\\n            else\\n                dp=1;\\n            ans+=dp;\\n        }", "class Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0;\\n        int j=1;\\n        long ans=1;\\n        while(j<prices.length){\\n            if( prices[j-1]-prices[j]==1){\\n\\t\\t\\t"]}
{"id": "1497", "ref_java": ["class Solution {\\n    private static final int NOT_VISITED = 0;\\n    private static final int VISITING = 1;\\n    private static final int VISITED = 2;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> status = new HashMap<>();\\n        Map<String, List<String>> prereqs = new HashMap<>();\\n        \\n        for (int i = 0; i < recipes.length; ++ i) {\\n            status.put(recipes[i], NOT_VISITED);\\n            prereqs.put(recipes[i], ingredients.get(i));\\n        }", "class Solution {\\n    private static final int NOT_VISITED = 0;\\n    private static final int VISITING = 1;\\n    private static final int VISITED = 2;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> status = new HashMap<>();\\n        Map<String, List<String>> prereqs = new HashMap<>();\\n        \\n        for (int i = 0; i < recipes.length; ++ i) {\\n            status.put(recipes[i], NOT_VISITED);\\n            prereqs.put(recipes[i], ingredients.get(i));\\n        }", "class Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> sup = new HashSet<>();\\n        HashMap<String, Integer> index = new HashMap<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        "]}
{"id": "1498", "ref_java": ["class Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if (s.length() % 2 == 1) {\\n            return false;\\n        }", "class Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if (s.length() % 2 == 1) {\\n            return false;\\n        }", "class Solution {\\n    public boolean canBeValid(String s, String locked) {\\n        if (s.length() % 2 == 1) {\\n            return false;\\n        }"]}
{"id": "1499", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int []execute = new int [s.length()];\\n\\n        for(int i=0;i<s.length();i++){\\n            int []nextBox = new int []{startPos[0],startPos[1]}", "class Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i] = execution(s.substring(i),n,startPos);\\n        }"]}
{"id": "1500", "ref_java": ["class Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] output = new long[arr.length];\\n        Map<Integer, Long> sumMap = new HashMap<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; ++ i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }", "class Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] output = new long[arr.length];\\n        Map<Integer, Long> sumMap = new HashMap<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; ++ i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }", "class Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] result = new long[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            List<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n            list.add(i);\\n            map.put(arr[i], list);\\n        }"]}
{"id": "1501", "ref_java": ["class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }", "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0;\\n        int prevArrLaserCount = 0;\\n        \\n        ", "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }"]}
{"id": "1502", "ref_java": ["class Solution {\\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\\n        Arrays.sort(asteroids);\\n        for (int i=0; i<asteroids.length; i++) {\\n            if (mass>=asteroids[i]) mass+=asteroids[i];\\n            else return false;\\n            if (mass>100000) return true;\\n        }", "class Solution {\\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\\n        Arrays.sort(asteroids);\\n        for (int i=0; i<asteroids.length; i++) {\\n            if (mass>=asteroids[i]) mass+=asteroids[i];\\n            else return false;\\n            if (mass>100000) return true;\\n        }", "class Solution {\\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\\n        Arrays.sort(asteroids);\\n        long m = mass;\\n        for (int a : asteroids) {\\n            if (m >= a) m += a;\\n            else return false;\\n        }"]}
{"id": "1503", "ref_java": ["class Solution {\\n    public int pairSum(ListNode head) {\\n        ", "class Solution {\\n    public int pairSum(ListNode head) {\\n        List<Integer>l1=new ArrayList<>();\\n        ListNode curr=head;\\n        int cnt=0;\\n        while(curr!=null){\\n            l1.add(curr.val);\\n            cnt++;\\n            curr=curr.next;\\n        }", "class Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode tempStart = head;\\n        ArrayList<Integer> asc = new ArrayList<>();\\n        int answer = 0;\\n\\n        while(tempStart != null) {\\n            asc.add(tempStart.val);\\n            tempStart = tempStart.next;\\n        }"]}
{"id": "1504", "ref_java": ["class Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }", "class Solution {\\n    public int longestPalindrome(String[] words) {\\n      int result=0;\\n        Map<String,Integer> map=new HashMap<>();\\n        for(String s:words)\\n        {\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }", "class Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(String s:words){\\n            if(map.containsKey(s)){\\n                map.replace(s,map.get(s)+1);\\n            }"]}
{"id": "1505", "ref_java": ["class Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] temp = new int[nums.length * 2];\\n        \\n        for(int i = 0; i < temp.length; ++i){\\n            temp[i] = nums[i % nums.length]; ", "class Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] temp = new int[nums.length * 2];\\n        \\n        for(int i = 0; i < temp.length; ++i){\\n            temp[i] = nums[i % nums.length]; ", "class Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] temp = new int[nums.length * 2];\\n        \\n        for(int i = 0; i < temp.length; ++i){\\n            temp[i] = nums[i % nums.length]; "]}
{"id": "1506", "ref_java": ["class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int n = startWords.length;\\n        int count = 0;\\n        Set<String> set = new HashSet<>();\\n        \\n        ", "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n\\n        Set<Integer> startWordMasks = new HashSet<>();\\n        for (String startWord : startWords) startWordMasks.add(mask(startWord));\\n\\n        int count = 0;\\n        for (String targetWord : targetWords) {\\n            int mask = mask(targetWord);\\n            for (char ch : targetWord.toCharArray())\\n                if (startWordMasks.contains(mask - (1 << (ch - \\'a\\')))) {\\n                    count++;\\n                    break;\\n                }", "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n\\n        Set<Integer> startWordMasks = new HashSet<>();\\n        for (String startWord : startWords) startWordMasks.add(mask(startWord));\\n\\n        int count = 0;\\n        for (String targetWord : targetWords) {\\n            int mask = mask(targetWord);\\n            for (char ch : targetWord.toCharArray())\\n                if (startWordMasks.contains(mask - (1 << (ch - \\'a\\')))) {\\n                    count++;\\n                    break;\\n                }"]}
{"id": "1507", "ref_java": ["class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int c=0;\\n        while(target>1 && maxDoubles>0)\\n        {\\n            if(target%2==0)\\n            {\\n                maxDoubles-=1;\\n                target/=2;\\n                c+=1;\\n            }", "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        ", "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        "]}
{"id": "1508", "ref_java": ["class Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n];\\n        dp[n-1] = questions[n-1][0];\\n        for (int i = n-2; i >= 0; i--) {\\n            dp[i] = Math.max(dp[i + 1], questions[i][0] + getValue(i + questions[i][1] + 1, dp));\\n        }", "class Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[] = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return helper(questions,0,dp);\\n    }", "class Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[] = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return helper(questions,0,dp);\\n    }"]}
{"id": "1509", "ref_java": ["class Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(lower); \\n        int mn = lower;\\n        int mx = lower;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            int d = differences[i];\\n            ans.add(d + ans.get(ans.size() - 1));\\n            mn = Math.min(mn, ans.get(ans.size() - 1));\\n            mx = Math.max(mx, ans.get(ans.size() - 1));\\n        }", "class Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(lower); \\n        int mn = lower;\\n        int mx = lower;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            int d = differences[i];\\n            ans.add(d + ans.get(ans.size() - 1));\\n            mn = Math.min(mn, ans.get(ans.size() - 1));\\n            mx = Math.max(mx, ans.get(ans.size() - 1));\\n        }", "class Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(lower); \\n        int mn = lower;\\n        int mx = lower;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            int d = differences[i];\\n            ans.add(d + ans.get(ans.size() - 1));\\n            mn = Math.min(mn, ans.get(ans.size() - 1));\\n            mx = Math.max(mx, ans.get(ans.size() - 1));\\n        }"]}
{"id": "1510", "ref_java": ["class Solution {\\n    static class Quad\\n    {\\n        int x,y,price,dist;\\n        Quad(int x,int y,int price,int dist)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.price=price;\\n            this.dist=dist;\\n        }", "class Solution {\\n    static class Quad\\n    {\\n        int x,y,price,dist;\\n        Quad(int x,int y,int price,int dist)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.price=price;\\n            this.dist=dist;\\n        }", "class Solution {\\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        List<List<Integer>> output = new ArrayList<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[2] != b[2]) {\\n                    return a[2] - b[2];\\n                }"]}
{"id": "1511", "ref_java": ["class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int arr1[] = new int[n/2];\\n        int arr2[] = new int[n/2];\\n        int j=0,k=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                arr1[j]=nums[i];\\n                j++;\\n            }", "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res= new int[nums.length];\\n        int[] p= new int[nums.length/2];\\n        int[] n= new int[nums.length/2];\\n        int i,j;\\n        i=j=0;\\n\\n         for(int num:nums){\\n            if(num>0){\\n                p[i++]=num;\\n                \\n            }", "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res= new int[nums.length];\\n        int[] p= new int[nums.length/2];\\n        int[] n= new int[nums.length/2];\\n        int i,j;\\n        i=j=0;\\n\\n         for(int num:nums){\\n            if(num>0){\\n                p[i++]=num;\\n                \\n            }"]}
{"id": "1512", "ref_java": ["class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        List<Integer> l1=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(!hm.containsKey(nums[i])){\\n                hm.put(nums[i],1);\\n            }", "class Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\\n        return list;\\n    }", "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return List.of();\\n        }"]}
{"id": "1513", "ref_java": ["class Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int oneCount = 0, zeroCount = 0;\\n        \\n        for(int num : nums)\\n            if(num == 1) ++oneCount;\\n        \\n        res.add(0);\\n        int max = oneCount;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(nums[i] == 1){\\n                --oneCount;\\n            }", "class Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        int N = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        int[] pref = new int[N + 1];\\n        pref[0] = 0; ", "class Solution {\\n    public List<Integer> maxScoreIndices(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int oneCount = 0, zeroCount = 0;\\n        \\n        for(int num : nums)\\n            if(num == 1) ++oneCount;\\n        \\n        res.add(0);\\n        int max = oneCount;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(nums[i] == 1){\\n                --oneCount;\\n            }"]}
{"id": "1514", "ref_java": ["class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans=new int[nums.length];\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<pivot){\\n                ans[count]=nums[i];\\n                count++;\\n            }", "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < pivot){\\n                for(int j = i; j > 0 && nums[j - 1] >= pivot; j--){\\n                    int tmp = nums[j];\\n                    nums[j] = nums[j - 1];\\n                    nums[j - 1] = tmp;\\n                }", "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int index = 0;\\n        for (int num : nums) {\\n            if (num < pivot) {\\n                ans[index++] = num;\\n            }"]}
{"id": "1515", "ref_java": ["class Solution {\\n\\t\\tpublic int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) \\n\\t\\t{\\n\\t\\t\\tchar st=(char)(startAt+\\'0\\');\\n\\t\\t\\tif(ts<60)\\n\\t\\t\\t\\treturn cost(st,ts+\"\",moveCost,pushCost);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint min=ts/60;\\n\\t\\t\\t\\tint sec=ts%60;\\n\\t\\t\\t\\tString s1=\"\",s2=\"\",or=\"\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(ts<=99)\\n\\t\\t\\t\\t\\tor=ts+\"\";  ", "class Solution {\\n\\t\\tpublic int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) \\n\\t\\t{\\n\\t\\t\\tchar st=(char)(startAt+\\'0\\');\\n\\t\\t\\tif(ts<60)\\n\\t\\t\\t\\treturn cost(st,ts+\"\",moveCost,pushCost);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint min=ts/60;\\n\\t\\t\\t\\tint sec=ts%60;\\n\\t\\t\\t\\tString s1=\"\",s2=\"\",or=\"\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(ts<=99)\\n\\t\\t\\t\\t\\tor=ts+\"\";  ", "class Solution {\\n    int moveCost = 0, pushCost = 0;\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        this.moveCost = moveCost;\\n        this.pushCost = pushCost;\\n        int mins = targetSeconds / 60;\\n        int secs = targetSeconds % 60;\\n        "]}
{"id": "1516", "ref_java": ["class Solution {\\n    public long smallestNumber(long num) {\\n\\n        if(num==0){\\n            return 0;\\n        }", "class Solution {\\n    public long smallestNumber(long num) {\\n        if(num == 0){\\n            return 0;\\n        }", "class Solution {\\n    public long smallestNumber(long num) {\\n        int[] count = new int[10];\\n        long tempNum = num > 0 ? num : num * -1;\\n        int min = 10;\\n\\t\\t"]}
{"id": "1518", "ref_java": ["class Solution {\\n    public int minimumOperations(int[] nums) {\\n        int[] freqEven = new int[100001];\\n        int[] freqOdd = new int[100001];\\n        int n= nums.length;\\n        int max = 0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                freqEven[nums[i]]++;\\n            else\\n                freqOdd[nums[i]]++;\\n            max = Math.max(max, nums[i]);\\n        }", "class Solution {\\n    public int minimumOperations(int[] nums) {\\n        int freq[][] = new int[100005][2];\\n        int i, j, k, ans=0;\\n        for(i = 0; i < nums.length; i++) {\\n    \\t\\t\\tfreq[nums[i]][i&1]++;\\n    \\t\\t}", "class Solution {\\n    public int minimumOperations(int[] nums) {\\n        int[] freqEven = new int[100001];\\n        int[] freqOdd = new int[100001];\\n        int n= nums.length;\\n        int max = 0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                freqEven[nums[i]]++;\\n            else\\n                freqOdd[nums[i]]++;\\n            max = Math.max(max, nums[i]);\\n        }"]}
{"id": "1519", "ref_java": ["class Solution {\\n\\tpublic long minimumRemoval(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tArrays.sort(arr);\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t}", "class Solution {\\n\\tpublic long minimumRemoval(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tArrays.sort(arr);\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t}", "class Solution {\\n\\tpublic long minimumRemoval(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tArrays.sort(arr);\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t}"]}
{"id": "1520", "ref_java": ["class Solution {\\n    public long[] sumOfThree(long num) {\\n         return (num%3==0) ? new long[]{(num/3)-1,num/3,(num/3)+1}", "class Solution {\\n    public long[] sumOfThree(long num) {\\n        if (num % 3 == 0) {\\n            long midd = num / 3;\\n            return new long[] {midd - 1, midd, midd + 1}", "class Solution {\\n    public long[] sumOfThree(long num) {\\n        long[] arr = new long[0];\\n        if(num%3 == 0){\\n            arr = new long[3];\\n            arr[0] = ((num/3))-1;\\n            arr[1] = (num/3);\\n            arr[2] = ((num/3))+1;\\n            return arr;\\n        }"]}
{"id": "1521", "ref_java": ["class Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum % 2 != 0) {\\n            return new ArrayList<>();\\n        }", "class Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum % 2 != 0) {\\n            return new ArrayList<>();\\n        }", "class Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) return Collections.emptyList();\\n\\n        List<Long> result = new ArrayList<>();\\n        long sum = 0, evenNum = 2;\\n        while (sum + evenNum <= finalSum) {\\n            sum += evenNum;\\n            result.add(evenNum);\\n            evenNum += 2;\\n        }"]}
{"id": "1522", "ref_java": ["class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = head.next;\\n        ListNode nn = new ListNode();\\n        head = nn;\\n\\n        int sum = 0;\\n        while(node != null) {\\n            if(node.val == 0) {\\n                nn.next = new ListNode(sum);\\n                nn = nn.next;\\n                sum = 0;\\n            }", "class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ", "class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head;\\n        ListNode zero = new ListNode();\\n        ListNode res = zero;\\n        int z = 0;\\n        int sum = 0;\\n        while(temp != null) {\\n            if(temp.val == 0) {\\n                z++;\\n            }"]}
{"id": "1523", "ref_java": ["class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c :  s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n        Queue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(\\n            (a, b) -> Character.compare(b.getKey(), a.getKey())\\n        );\\n\\n        pq.addAll(map.entrySet());\\n\\n        StringBuilder ret = new StringBuilder();\\n        int pivot = -1;\\n        while(!pq.isEmpty()) {\\n            Map.Entry<Character, Integer> node = pq.poll();\\n            if(pivot == -1 || ret.charAt(pivot) != node.getKey() || ret.length() - pivot < repeatLimit) {\\n                ret.append(node.getKey());\\n                node.setValue(node.getValue()-1);\\n                if(node.getValue()!=0)\\n                    pq.add(node);\\n                if(pivot == -1 || ret.charAt(pivot) != node.getKey())\\n                    pivot = ret.length()-1;\\n                continue;\\n            }", "class Solution {\\n    public String repeatLimitedString(String s, int k) {\\n\\n        byte[] res;\\n        int resP = 0;\\n        int[] freqs = new int[26];\\n        for (byte aChar : (res = s.getBytes(java.nio.charset.StandardCharsets.US_ASCII))) ++freqs[aChar - 97];\\n        \\n        for (int i = 25, j; i >= 0; i = j) {\\n            j = i - 1;\\n            while (freqs[i] > k) {\\n                for (int _j = 0; _j < k; ++_j) res[resP++] = (byte) (97 + i);\\n                freqs[i] -= k;\\n\\n                for (; j >= 0 && freqs[j] == 0; --j) ;\\n                if (j < 0) return new String(res, 0, resP);\\n        \\n                res[resP++] = (byte) (97 + j);\\n                --freqs[j];\\n            }", "class Solution {\\n  public String repeatLimitedString(String s, int repeatLimit) {\\n    int[] freq = new int[26];\\n\\n    for (char c : s.toCharArray())\\n      freq[c - \\'a\\']++;\\n\\n    int pendingLetterIndex = -1;\\n    StringBuilder sb = new StringBuilder();\\n\\n    for (int i=25; i >= 0; i--) {\\n      if (freq[i] == 0)\\n        continue;\\n\\n      if (pendingLetterIndex > 0) {\\n        "]}
{"id": "1524", "ref_java": ["class Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = func(s);\\n        int[] arrT = func(t);\\n\\n        int steps = 0;\\n        for(int i = 0; i < arrS.length; i++) {\\n            steps += Math.abs(arrS[i] - arrT[i]);\\n        }", "class Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freq=new int[256];\\n        for(int i=0; i<s.length(); i++){\\n            freq[s.charAt(i)]++;\\n        }", "class Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int[]string1=new int[26];\\n    int[]string2=new int[26];\\n\\n    for(int i=0;i<s.length();i++){\\n    \\n    string1[s.charAt(i)-\\'a\\']++;\\n    \\n    }"]}
{"id": "1525", "ref_java": ["class Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }", "class Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long low=1;\\n      long end=0;\\n     for(int i:time)end=Math.max(end,i);\\n       end=end*totalTrips;\\n      while(low<end)\\n      {\\n          long mid=(low+end)/2;\\n          long r=0;\\n          for(int i: time)\\n          {\\n             if(i<=mid){\\n                r+=mid/i;   \\n             }", "class Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }"]}
{"id": "1526", "ref_java": ["class Solution {\\n    public int[] sortJumbled(int[] mapping, int[] nums) {\\n        \\n        List<Integer> arr = new ArrayList<>();\\n\\t\\t\\n\\t\\t", "class Solution {\\n    public int[] sortJumbled(int[] mapping, int[] nums) {\\n        \\n        List<Integer> arr = new ArrayList<>();\\n\\t\\t\\n\\t\\t", "class Solution {\\n    public int[] sortJumbled(int[] mapping, int[] nums) {\\n        int []mapped = new int[nums.length];\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            int number = nums[i];\\n            int idx = 1;\\n            int mapped_number = 0;\\n            while (number > 0) {\\n            int remainder = number % 10;\\n            mapped_number = mapped_number + (mapping[remainder] * idx );\\n            number = number / 10;\\n            idx *= 10;\\n        }"]}
{"id": "1527", "ref_java": ["\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\n    List<List<Integer>> ans = new ArrayList();\n    List<List<Integer>> directChild = new ArrayList();\n    for (int i = 0; i < n; i++) {\n        ans.add(new ArrayList());\n        directChild.add(new ArrayList());\n    }\n    for (int[] e: edges) \n        directChild.get(e[0]).add(e[1]);\n    for (int i = 0; i < n; i++) \n        dfs(i, i, ans, directChild);\n    return ans;\n}\nprivate void dfs(int x, int curr, List<List<Integer>> ans, List<List<Integer>> directChild) {\n    for (int ch: directChild.get(curr))\n        if(ans.get(ch).size() == 0 || ans.get(ch).get(ans.get(ch).size() - 1) != x) {\n            ans.get(ch).add(x);\n            dfs(x, ch, ans, directChild);\n        }\n}\n", "\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\n    List<List<Integer>> ans = new ArrayList();\n    List<List<Integer>> directChild = new ArrayList();\n    for (int i = 0; i < n; i++) {\n        ans.add(new ArrayList());\n        directChild.add(new ArrayList());\n    }\n    for (int[] e: edges) \n        directChild.get(e[0]).add(e[1]);\n    for (int i = 0; i < n; i++) \n        dfs(i, i, ans, directChild);\n    return ans;\n}\nprivate void dfs(int x, int curr, List<List<Integer>> ans, List<List<Integer>> directChild) {\n    for (int ch: directChild.get(curr))\n        if(ans.get(ch).size() == 0 || ans.get(ch).get(ans.get(ch).size() - 1) != x) {\n            ans.get(ch).add(x);\n            dfs(x, ch, ans, directChild);\n        }\n}\n", "\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\n    List<List<Integer>> ans = new ArrayList();\n    List<List<Integer>> directChild = new ArrayList();\n    for (int i = 0; i < n; i++) {\n        ans.add(new ArrayList());\n        directChild.add(new ArrayList());\n    }\n    for (int[] e: edges) \n        directChild.get(e[0]).add(e[1]);\n    for (int i = 0; i < n; i++) \n        dfs(i, i, ans, directChild);\n    return ans;\n}\nprivate void dfs(int x, int curr, List<List<Integer>> ans, List<List<Integer>> directChild) {\n    for (int ch: directChild.get(curr))\n        if(ans.get(ch).size() == 0 || ans.get(ch).get(ans.get(ch).size() - 1) != x) {\n            ans.get(ch).add(x);\n            dfs(x, ch, ans, directChild);\n        }\n}\n"]}
{"id": "1528", "ref_java": ["class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        ", "class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        ", "class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        "]}
{"id": "1529", "ref_java": ["class Solution {\\n    public TreeNode createBinaryTree(int[][] arr) {\\n        HashSet<Integer> children = new HashSet<>();\\n        HashMap<Integer,TreeNode> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            int parent = arr[i][0];\\n            int child = arr[i][1];\\n            int isLeft = arr[i][2];\\n\\n            children.add(child);\\n    \\n            TreeNode a = hp.getOrDefault(parent,new TreeNode(parent));\\n            \\n            if(isLeft==1){\\n                a.left = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.left);\\n            }", "class Solution {\\n    public TreeNode createBinaryTree(int[][] arr) {\\n        HashSet<Integer> children = new HashSet<>();\\n        HashMap<Integer,TreeNode> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            int parent = arr[i][0];\\n            int child = arr[i][1];\\n            int isLeft = arr[i][2];\\n\\n            children.add(child);\\n    \\n            TreeNode a = hp.getOrDefault(parent,new TreeNode(parent));\\n            \\n            if(isLeft==1){\\n                a.left = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.left);\\n            }", "class Solution {\\n    public TreeNode createBinaryTree(int[][] arr) {\\n        HashSet<Integer> children = new HashSet<>();\\n        HashMap<Integer,TreeNode> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            int parent = arr[i][0];\\n            int child = arr[i][1];\\n            int isLeft = arr[i][2];\\n\\n            children.add(child);\\n    \\n            TreeNode a = hp.getOrDefault(parent,new TreeNode(parent));\\n            \\n            if(isLeft==1){\\n                a.left = hp.getOrDefault(child, new TreeNode(child));\\n                hp.put(child,a.left);\\n            }"]}
{"id": "1530", "ref_java": ["class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        ", "class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[][] A = new int[n][n];\\n        \\n        for(int[] d : dig) A[d[0]][d[1]] = 1;\\n        \\n        int[][] dir = new int[][] {\\n            {0, 0}", "class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        for(int[] d : dig){\\n            Pair<Integer, Integer> pair = new Pair<>(d[0], d[1]);\\n            set.add(pair);\\n        }"]}
{"id": "1531", "ref_java": ["class Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            if(k%2!=0){\\n                return -1;\\n            }", "class Solution {\\n\\tpublic static int maximumTop(int[] arr, int k) {\\n\\t\\tif (arr.length == 1 && k % 2 == 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}", "class Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            if(k%2!=0){\\n                return -1;\\n            }"]}
{"id": "1532", "ref_java": ["class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long result = 0, first = 0, second = 0;\\n\\n        for(int i = 0; i < text.length(); ++i) {\\n            if(text.charAt(i) == pattern.charAt(1)) {\\n                result += first;\\n                second++;\\n            }", "class Solution {\\n    public long maximumSubsequenceCount(String text, String pattern) {\\n        long result = 0, first = 0, second = 0;\\n\\n        for(int i = 0; i < text.length(); ++i) {\\n            if(text.charAt(i) == pattern.charAt(1)) {\\n                result += first;\\n                second++;\\n            }", "class Solution {\\n\\n    public long maximumSubsequenceCount(String s, String p) {\\n        long ans = 0, max = 0;\\n        int cnt = 1;\\n        "]}
{"id": "1533", "ref_java": ["class Solution {\\n    public int halveArray(int[] nums) {\\n        int ans = 0;\\n        double sum = 0;\\n\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int val : nums) {\\n            sum += val;\\n            pq.add((double)val);\\n        }", "class Solution {\\n    public int halveArray(int[] nums) {\\n        int ans=0;\\n        PriorityQueue<Double> pq=new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        double sum=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            pq.add((double)nums[i]);\\n            sum+=nums[i];\\n        }", "class Solution {\\n    public int halveArray(int[] nums) {\\n        int ans = 0;\\n        double sum = 0;\\n\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int val : nums) {\\n            sum += val;\\n            pq.add((double)val);\\n        }"]}
{"id": "1534", "ref_java": ["class Solution {\\n    public int countCollisions(String directions) {\\n        Stack<Character> stack = new Stack<>();\\n        int collisions = 0;\\n        \\n        for(char direction : directions.toCharArray()){\\n            if(!stack.isEmpty() && direction == \\'L\\' && stack.peek() != \\'L\\'){ \\n                int prev = stack.pop();\\n                collisions++;\\n                if(prev == \\'R\\')\\n                    collisions++;\\n                while(!stack.isEmpty() && stack.peek() == \\'R\\'){\\n                    collisions++;\\n                    stack.pop();\\n                }", "class Solution {\\n    public int countCollisions(String directions) {\\n        int result = 0, x = 0;\\n        char prev = directions.charAt(0);\\n\\n        for(int i = 1; i < directions.length(); ++i) {\\n            char curr = directions.charAt(i);\\n\\n            if(prev == \\'R\\' && curr == \\'L\\') {\\n                result += 2 + x;\\n                prev = \\'S\\';\\n                x = 0;\\n            }", "class Solution {\\n    public int countCollisions(String dir) {\\n        \\n        int res = 0, n = dir.length(), i = 0, carsFromRight = 0;\\n        \\n        while (i < n && dir.charAt(i) == \\'L\\') i++;\\n        \\n        for ( ; i<n; i++) {\\n            if (dir.charAt(i) == \\'R\\')  carsFromRight++;\\n            else {\\n                res += (dir.charAt(i) == \\'S\\') ? carsFromRight : carsFromRight+1;\\n                carsFromRight = 0;\\n            }"]}
{"id": "1535", "ref_java": ["class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[][] dp = new int[13][numArrows+1];\\n        \\n        for(int i=0; i<=12; i++){\\n            for(int j=0; j<=numArrows; j++){\\n                if(i==0 || j==0){\\n                    dp[i][j] = 0;\\n                }", "class Solution {\\n\\t\\t\\tint bobPoint = 0;\\n\\t\\t\\tint[] maxbob = new int[12];\\n\\t\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n\\t\\t\\t\\tint[] bob = new int[12];\\n\\t\\t\\t\\tcalculate(aliceArrows, bob, 11, numArrows, 0);  ", "class Solution {\\n    int[] optimalStrategy; "]}
{"id": "1536", "ref_java": ["class Solution {\\n    public int minDeletion(int[] nums) {\\n        \\n        int deletion = 0, n = nums.length;\\n        \\n        for (int i=0; i<n-1; ) {\\n            int newIndex = i-deletion;\\n            if ((newIndex % 2 == 0) && nums[i] == nums[i+1])   deletion++;\\n            else    i++;\\n        }", "class Solution {\\n    public int minDeletion(int[] nums) {\\n        \\n        int deletion = 0, n = nums.length;\\n        \\n        for (int i=0; i<n-1; ) {\\n            int newIndex = i-deletion;\\n            if ((newIndex % 2 == 0) && nums[i] == nums[i+1])   deletion++;\\n            else    i++;\\n        }", "class Solution {\\n    public int minDeletion(int[] nums) {\\n        \\n        int deletion = 0, n = nums.length;\\n        \\n        for (int i=0; i<n-1; ) {\\n            int newIndex = i-deletion;\\n            if ((newIndex % 2 == 0) && nums[i] == nums[i+1])   deletion++;\\n            else    i++;\\n        }"]}
{"id": "1537", "ref_java": ["class Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); ", "class Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; ", "class Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }"]}
{"id": "1538", "ref_java": ["class Solution {\\n    public int triangularSum(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int n=nums.length;\\n        while(n!=0){\\n            for(int i=0;i<n-1;i++){\\n                int m = (nums[i]+nums[i+1]);\\n                nums[i]=m%10;\\n            }", "class Solution {\\n    public int triangularSum(int[] nums) {\\n        return dfs(nums);\\n    }", "class Solution {\\n    public int triangularSum(int[] nums) {\\n        int n = nums.length;\\n        for(int i = 1; i <= n - 1; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                nums[j] = (nums[j] + nums[j + 1]) % 10;\\n            }"]}
{"id": "1539", "ref_java": ["class Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }", "class Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }", "class Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }"]}
{"id": "1540", "ref_java": ["class Solution {\\n    public List<List<Integer>> findWinners(int[][] matches) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int n=matches.length;\\n\\n        for(int i=0;i<n;i++){\\n            if(!map.containsKey(matches[i][0]))\\n                map.put(matches[i][0], 0);\\n\\n            if(map.containsKey(matches[i][1]))\\n                map.put(matches[i][1], map.get(matches[i][1])+1);\\n            else\\n                map.put(matches[i][1], 1);\\n        }", "class Solution {\\n    public List<List<Integer>> findWinners(int[][] matches) {\\n        ", "class Solution {\\n    public List<List<Integer>> findWinners(int[][] matches) {\\n        HashMap<Integer,Integer> winner = new HashMap<>();\\n        HashMap<Integer,Integer> looser = new HashMap<>();\\n\\n        List<List<Integer>> list = new LinkedList<>();\\n\\n        for(int[] match:matches){\\n            winner.put(match[0],winner.getOrDefault(match[0],0)+1);\\n            looser.put(match[1],looser.getOrDefault(match[1],0)+1);\\n        }"]}
{"id": "1541", "ref_java": ["class Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }", "class Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }", "class Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            }"]}
{"id": "1542", "ref_java": ["class Solution {\\n    public String minimizeResult(String expression) {\\n        String[] sp = expression.split(\"\\\\\\\\+\");\\n        String left = sp[0];\\n        String right = sp[1];\\n        \\n        int min = Integer.MAX_VALUE;\\n        String result = \"(\" + expression + \")\";\\n\\t\\t\\n        for(int i=0; i<left.length(); i++) { ", "class Solution {\\n    public String minimizeResult(String expression) {\\n        String[] sp = expression.split(\"\\\\\\\\+\");\\n        String left = sp[0];\\n        String right = sp[1];\\n        \\n        int min = Integer.MAX_VALUE;\\n        String result = \"(\" + expression + \")\";\\n\\t\\t\\n        for(int i=0; i<left.length(); i++) { ", "class Solution {\\n    public String minimizeResult(String expression) {\\n        String[] sp = expression.split(\"\\\\\\\\+\");\\n        String left = sp[0];\\n        String right = sp[1];\\n        \\n        int min = Integer.MAX_VALUE;\\n        String result = \"(\" + expression + \")\";\\n\\t\\t\\n        for(int i=0; i<left.length(); i++) { "]}
{"id": "1543", "ref_java": ["class Solution {\\n    public int maximumProduct(int[] nums, int k) {\\n        \\n        Queue<Integer> pq = new PriorityQueue<>();\\n        for (int num : nums)    pq.add(num);\\n        \\n        while (k-->0) {\\n            int top = pq.poll() + 1 ;\\n            pq.add(top);\\n        }", "class Solution {\\n    public int maximumProduct(int[] nums, int k) {\\n        \\n        Queue<Integer> pq = new PriorityQueue<>();\\n        for (int num : nums)    pq.add(num);\\n        \\n        while (k-->0) {\\n            int top = pq.poll() + 1 ;\\n            pq.add(top);\\n        }", "class Solution {\\n    public int maximumProduct(int[] nums, int k) {\\n        \\n        Queue<Integer> pq = new PriorityQueue<>();\\n        for (int num : nums)    pq.add(num);\\n        \\n        while (k-->0) {\\n            int top = pq.poll() + 1 ;\\n            pq.add(top);\\n        }"]}
{"id": "1544", "ref_java": ["class Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long res=0;\\n        while(total >= 0){\\n            res += ((total/cost2) + 1);\\n            total -= cost1;\\n        }", "class Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ways = 0;\\n        int np = total/cost1; ", "class Solution {\\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long ways = 0;\\n        long penscost = 0;\\n        while(penscost <= total) {\\n            long remainingAmount = total - penscost;\\n            long pencils = remainingAmount/cost2 + 1;\\n            ways += pencils;\\n            penscost += cost1;\\n        }"]}
{"id": "1546", "ref_java": ["class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> numFreq = new HashMap<>();\\n        for (int x : tasks) {\\n            numFreq.put(x, numFreq.getOrDefault(x, 0) + 1);\\n        }", "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int n=tasks.length;\\n        HashMap<Integer,Integer>hm=new HashMap();\\n        for(int i:tasks)\\n            hm.merge(i,1,(v1,v2)->v2=v1+1);\\n        int[] dp=new int[100001];\\n        ", "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count=0;\\n        Map<Integer,Integer> maplist=new HashMap<Integer,Integer>();\\n        for(int a:tasks)  maplist.put(a,maplist.getOrDefault(a,0)+1);\\n        Set<Integer> setlist=maplist.keySet();\\n        for(int key:setlist){\\n            int number=maplist.get(key);\\n            int i=0;\\n            while(true){\\n                if((number-3*i)<0){\\n                    if(number%2==0){\\n                         count+=(number/2);\\n                    }"]}
{"id": "1547", "ref_java": ["class Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] dph = new int[m][n][3];\\n        int[][][] dpv = new int[m][n][3];\\n        int hmax0 = 0;\\n        int vmax0 = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (j >= 1) {\\n                    two = dph[i][j-1][1];\\n                    five = dph[i][j-1][2];\\n                }", "class Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] dph = new int[m][n][3];\\n        int[][][] dpv = new int[m][n][3];\\n        int hmax0 = 0;\\n        int vmax0 = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (j >= 1) {\\n                    two = dph[i][j-1][1];\\n                    five = dph[i][j-1][2];\\n                }", "class Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++){\\n            ans = Math.max(ans, solve(grid));\\n            grid = rotate(grid);\\n        }"]}
{"id": "1548", "ref_java": ["class Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int count = 0;\\n        for (int[] circle: circles){\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int leftX = x - r;\\n            int leftY = r - y;\\n            int rightX = x + r;\\n            int rightY = r + y;\\n            \\n            for (int i = leftX; i <= rightX;i++){\\n                for (int j= leftY;j <= rightY;j++){\\n                    if (inCircle(i, j, circle)) {\\n                        if (!map.containsKey(i)) map.put(i, new HashSet<>());\\n                        if (!map.get(i).contains(j)){\\n                            count++;\\n                            map.get(i).add(j);\\n                        }", "class Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int count = 0;\\n        for (int[] circle: circles){\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int leftX = x - r;\\n            int leftY = r - y;\\n            int rightX = x + r;\\n            int rightY = r + y;\\n            \\n            for (int i = leftX; i <= rightX;i++){\\n                for (int j= leftY;j <= rightY;j++){\\n                    if (inCircle(i, j, circle)) {\\n                        if (!map.containsKey(i)) map.put(i, new HashSet<>());\\n                        if (!map.get(i).contains(j)){\\n                            count++;\\n                            map.get(i).add(j);\\n                        }", "class Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int count = 0;\\n        for (int[] circle: circles){\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int leftX = x - r;\\n            int leftY = r - y;\\n            int rightX = x + r;\\n            int rightY = r + y;\\n            \\n            for (int i = leftX; i <= rightX;i++){\\n                for (int j= leftY;j <= rightY;j++){\\n                    if (inCircle(i, j, circle)) {\\n                        if (!map.containsKey(i)) map.put(i, new HashSet<>());\\n                        if (!map.get(i).contains(j)){\\n                            count++;\\n                            map.get(i).add(j);\\n                        }"]}
{"id": "1549", "ref_java": ["class Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        TreeMap<Integer, List<Integer>> rects = new TreeMap<>();\\n        for(int[] rect : rectangles) {\\n            if (!rects.containsKey(rect[1])) {\\n                rects.put(rect[1], new ArrayList<Integer>());\\n            }", "class Solution {\\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\\n    ", "class Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] res = new int[points.length];\\n        List<List<Integer>> group = new ArrayList<>(101);\\n        for(int i = 0; i < 101; i++){\\n            group.add(new ArrayList<>());\\n        }"]}
{"id": "1550", "ref_java": ["class Solution {\\n    public int minimumAverageDifference(int[] nums) {\\n        int l = nums.length;  \\n        int index = 0;\\n        long min = Integer.MAX_VALUE, sum = 0, leftsum = 0, rightsum = 0;\\n        for (int j = 0; j < l; j++) {\\n            sum = sum + nums[j];\\n        }", "class Solution {\\n    public int minimumAverageDifference(int[] nums) {\\n        long min = Integer.MAX_VALUE, sum = 0;\\n        for (int i : nums) sum += i;\\n        int leftIndex = 0, resultIndex = -1;\\n        long prefixSum = 0;\\n\\n        while (leftIndex < nums.length) {\\n            prefixSum += nums[leftIndex];\\n            long leftAverage = prefixSum / (leftIndex + 1);\\n            long sumRight = sum - prefixSum;\\n            if (sumRight != 0) sumRight /= nums.length - leftIndex - 1;\\n            long res = Math.abs(leftAverage - sumRight);\\n            if (res < min) {\\n                min = res;\\n                resultIndex = leftIndex;\\n            }", "class Solution {\\n    public int minimumAverageDifference(int[] nums) {\\n        int n = nums.length;\\n        double[] prefix = new double[n + 1]; "]}
{"id": "1551", "ref_java": ["class Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int visit[][]=new int[m][n];\\n        int delRow[]={0,0,1,-1}", "class Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   ", "class Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   "]}
{"id": "1552", "ref_java": ["class Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = cards.length;\\n        ", "class Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = cards.length;\\n        ", "class Solution {\\n    public int minimumCardPickup(int[] cards) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i=0; i<cards.length; i++){\\n\\n            if(map.containsKey(cards[i])){\\n            int idx = map.get(cards[i]);\\n                int res = i - idx + 1;\\n                ans = Math.min(ans, res);\\n            }"]}
{"id": "1553", "ref_java": ["class Solution {\\n    public int countDistinct(int[] nums, int k, int p) {\\n        int n = nums.length;\\n\\t\\t", "class Solution {\\n\\t\\tpublic int countDistinct(int[] nums, int k, int p) {\\n\\t\\t\\tHashSet<String> hs = new HashSet<>();\\n\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i) {\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\t\\tfor(int j=i; j<nums.length; ++j) {\\n\\n\\t\\t\\t\\t\\tif(nums[j]%p == 0) {\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}", "class Solution {\\n    private static final int MAX_P = 200;\\n\\n    public int countDistinct(int[] nums, int k, int p) {\\n        int n = nums.length;\\n        List<int[]> child = new ArrayList<>();\\n        child.add(new int[MAX_P + 1]);\\n        int nxt = 1, ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            int count = 0, node = 0;\\n            int j = i;\\n            while (j < n && count <= k) {\\n                int c = nums[j++];\\n                if (c % p == 0) if (count++ == k) break;\\n                if (child.get(node)[c] == 0) {\\n                    ans++;\\n                    child.get(node)[c] = nxt++;\\n                    child.add(new int[MAX_P + 1]);\\n                }"]}
{"id": "1554", "ref_java": ["class Solution {\\n    public int averageOfSubtree(TreeNode root) {\\n        int[] result = new int[1];\\n        traverse(root, result);\\n        return result[0];\\n    }", "class Solution {\\n    private int res = 0;    \\n\\n    public int averageOfSubtree(TreeNode root) {\\n        postorder(root);\\n        return res;        \\n    }", "class Solution {\\n    public int averageOfSubtree(TreeNode root) {\\n        int[] result = new int[1];\\n        traverse(root, result);\\n        return result[0];\\n    }"]}
{"id": "1555", "ref_java": ["class Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 }", "class Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }", "class Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }"]}
{"id": "1556", "ref_java": ["class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int i : nums){\\n            sum+=i;\\n        }", "class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        long sum = 0;\\n        long leftSum = 0;\\n        long rightSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            sum += nums[i];\\n        }", "class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumLeft = 0, sumRight = 0 ;\\n        int result = 0 ;\\n        \\n        for (int i : nums) sumRight += i ;\\n        \\n        for (int i = 0; i < nums.length-1; i++) {\\n            sumRight -= nums[i] ;\\n            sumLeft += nums[i] ;\\n            if (sumLeft >= sumRight) result++ ;\\n        }"]}
{"id": "1557", "ref_java": ["class Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) ->  a[0] - b[0]);\\n        int n = tiles.length;\\n        int[] prefix = new int[n];\\n        int max = 0;\\n        for(int i = 0; i < n; i++){\\n            prefix[i] = (i > 0 ? prefix[i-1] : 0) + tiles[i][1] - tiles[i][0] + 1;\\n        }", "class Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int cLen) {\\n        Arrays.sort(tiles,(a,b)->{\\n            if(a[0]!=b[0])\\n                return a[0] - b[0];\\n            else\\n                return a[1] - b[1];\\n        }", "class Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) ->  a[0] - b[0]);\\n        int n = tiles.length;\\n        int[] prefix = new int[n];\\n        int max = 0;\\n        for(int i = 0; i < n; i++){\\n            prefix[i] = (i > 0 ? prefix[i-1] : 0) + tiles[i][1] - tiles[i][0] + 1;\\n        }"]}
{"id": "1558", "ref_java": ["class Solution {\\n    public int maxConsecutive(int bottom, int top, int[] special) {\\n        int diff =0,max =0;\\n        Arrays.sort(special);\\n        max = Math.max(max, special[0] - bottom);\\n        for(int i=1;i<special.length;i++)\\n        {\\n            diff = special[i]-special[i-1]-1;\\n            max = Math.max(diff, max);\\n        }", "class Solution {\\n    public int maxConsecutive(int bottom, int top, int[] special) {\\n        int diff =0,max =0;\\n        Arrays.sort(special);\\n        max = Math.max(max, special[0] - bottom);\\n        for(int i=1;i<special.length;i++)\\n        {\\n            diff = special[i]-special[i-1]-1;\\n            max = Math.max(diff, max);\\n        }", "class Solution {\\n    public int maxConsecutive(int bottom, int top, int[] special) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        Arrays.sort(special);\\n        \\n        "]}
{"id": "1559", "ref_java": ["class Solution {\\n    public int largestCombination(int[] candidates) {\\n       int[] ans=new int[32];\\n       for(int x:candidates){\\n           find(x,ans);\\n       }", "class Solution {\\n    public int largestCombination(int[] candidates) {\\n       int[] ans=new int[32];\\n       for(int x:candidates){\\n           find(x,ans);\\n       }", "class Solution {\\n    public int largestCombination(int[] candidates) {\\n       int[] ans=new int[32];\\n       for(int x:candidates){\\n           find(x,ans);\\n       }"]}
{"id": "1560", "ref_java": ["class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int temp[] = new int[capacity.length];\\n      long sum=0;\\n      for(int i=0;i<rocks.length;i++)\\n        {\\n            temp[i]=capacity[i]-rocks[i];\\n            sum=sum+(capacity[i]-rocks[i]);\\n\\n        }", "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int temp[] = new int[capacity.length];\\n      long sum=0;\\n      for(int i=0;i<rocks.length;i++)\\n        {\\n            temp[i]=capacity[i]-rocks[i];\\n            sum=sum+(capacity[i]-rocks[i]);\\n\\n        }", "class Solution {\\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\\n      int temp[] = new int[capacity.length];\\n      long sum=0;\\n      for(int i=0;i<rocks.length;i++)\\n        {\\n            temp[i]=capacity[i]-rocks[i];\\n            sum=sum+(capacity[i]-rocks[i]);\\n\\n        }"]}
{"id": "1561", "ref_java": ["class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length<=1) return 0;\\n        if(stockPrices.length==2) return 1;\\n\\n        int count = 1;\\n\\n        int[] prevPercent = new int[2];\\n        int[] currPercent = new int[2];\\n\\n        sortByXAxis(stockPrices);\\n\\n        prevPercent = getPercent(stockPrices[0], stockPrices[1]);\\n\\n        for (int i = 1; i < stockPrices.length - 1; i++) {\\n\\n            currPercent = getPercent(stockPrices[i], stockPrices[i + 1]);\\n            \\n            if (prevPercent[0] != currPercent[0]\\n                    || prevPercent[1] != currPercent[1]) {\\n                count++;\\n                prevPercent = currPercent;\\n            }", "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n        int n = stockPrices.length;\\n        if(n == 1 || n == 2) return n - 1;\\n        \\n       \\n        Arrays.sort(stockPrices,(a,b) ->{\\n              return a[0] - b[0];\\n        }", "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        "]}
{"id": "1562", "ref_java": ["class Solution {\\n    static class sArranger implements Comparable<sArranger>{\\n        String name;\\n        int count;\\n        int index;\\n        sArranger(String s,int c,int i){\\n            name=s;\\n            count=c;\\n            index=i;\\n        }", "class Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        ", "class Solution {\\n    \\n    class Pair {\\n        String name;\\n        int cnt;\\n        \\n        public Pair(String n, int c) {\\n            this.name = n;\\n            this.cnt = c;\\n        }"]}
{"id": "1563", "ref_java": ["class Solution {\\n    public long maximumImportance(int n, int[][] roads) {\\n        long ans = 0, x = 1;\\n\\t\\tlong degree[] = new long[n];\\n        for(int road[] : roads){\\n            degree[road[0]]++; \\n\\t\\t\\tdegree[road[1]]++;\\n        }", "class Solution {\\n    class Pair implements Comparable<Pair>{\\n        int val,freq;\\n        Pair(int val,int freq){\\n            this.val=val;\\n            this.freq=freq;\\n        }", "class Solution {\\n    public long maximumImportance(int n, int[][] roads) {\\n        "]}
{"id": "1564", "ref_java": ["class Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String x:arr){\\n            if(i!=arr.length-1)\\n                sb.append(convert(x,discount,df)+\" \");\\n            else\\n                sb.append(convert(x,discount,df));\\n            i++;\\n        }", "class Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String x[] = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : x) {\\n            if (isPrice(s)) sb.append(calc(Double.parseDouble(s.substring(1)), discount) + \" \"); \\n            else sb.append(s + \" \");\\n        }", "class Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        "]}
{"id": "1565", "ref_java": ["class Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack st = new Stack<Integer>();\\n        st.push(0);\\n        int steps=0;\\n        int step_arr[] = new int[nums.length]; \\n        for(int i=1;i<nums.length;i++){\\n            int max_steps = 0;\\n            while(!st.empty() && nums[i]>=nums[(Integer)st.peek()]){\\n                max_steps=Math.max(max_steps,step_arr[(Integer)st.peek()]);\\n                st.pop();\\n            }", "class Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack st = new Stack<Integer>();\\n        st.push(0);\\n        int steps=0;\\n        int step_arr[] = new int[nums.length]; \\n        for(int i=1;i<nums.length;i++){\\n            int max_steps = 0;\\n            while(!st.empty() && nums[i]>=nums[(Integer)st.peek()]){\\n                max_steps=Math.max(max_steps,step_arr[(Integer)st.peek()]);\\n                st.pop();\\n            }", "class Solution {\\n    public int totalSteps(int[] nums) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--){\\n            int cur = 0;\\n            while(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                cur = Math.max(cur + 1, dp[stack.pop()]);\\n            }"]}
{"id": "1566", "ref_java": ["class Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }", "class Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }", "class Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }"]}
{"id": "1567", "ref_java": ["class Solution {\\n    public int[] arrayChange(int[] nums, int[][] ops) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }", "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] ops) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }", "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) map.put(nums[i],i);\\n        for(int[] op: operations) {\\n            nums[map.get(op[0])] = op[1];\\n            map.put(op[1],map.get(op[0]));\\n            map.remove(op[0]);\\n        }"]}
{"id": "1568", "ref_java": ["class Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                }", "class Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                }", "class Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                }"]}
{"id": "1569", "ref_java": ["class Solution {\\nprivate:\\n    int fun(int idx, int jdx, int m, int n, vvi& grid, vvi& moveCost){\\n        ", "class Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int dp[][]=new int[n][m];\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }", "class Solution {\\n    public int rec(int i,int j,int[][]grid,int[][]move,int [][]dp){\\n        if(i==grid.length-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int max=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++){\\n            int moveCost=grid[i][j]+move[grid[i][j]][k];\\n            max=Math.min(max,moveCost+rec(i+1,k,grid,move,dp));\\n        }"]}
{"id": "1570", "ref_java": ["class Solution {\\n    private int dfs(int idx, int[] distribute, int[] cookies, int k, int zeroCount) {\\n        if (cookies.length - idx < zeroCount) {\\n            return Integer.MAX_VALUE;   \\n        }", "class Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        Arrays.sort(cookies);\\n        int ans = Integer.MAX_VALUE;\\n        do{\\n            ans = Math.min(ans, bs(cookies, k));\\n        }", "class Solution {\\n    int res = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        dist(0, cookies, new int[k], 0);\\n        return res;\\n    }"]}
{"id": "1571", "ref_java": ["class Solution {\\n    public int minimumNumbers(int nums, int k) {\\n\\t", "class Solution {\\n    public int minimumNumbers(int nums, int k) {\\n\\t", "class Solution {\\n    public int minimumNumbers(int nums, int k) {\\n\\t"]}
{"id": "1572", "ref_java": ["class Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        ", "class Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        ", "class Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        "]}
{"id": "1573", "ref_java": ["class Solution {\\n    public long countPairs(int n, int[][] edges) {\\n        ArrayList<Integer>[] neighbors = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            neighbors[i] = new ArrayList<>();\\n        }", "class Solution {\\n    private int count;\\n    public long countPairs(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            if (graph.containsKey(edge[0])) {\\n                List<Integer> exist = graph.get(edge[0]);\\n                exist.add(edge[1]);\\n                graph.put(edge[0], exist);\\n            }", "class Solution {\\n    public long countPairs(int n, int[][] edges) {\\n        long connectedPairs = 0;\\n        UnionFind uf = new UnionFind(n);\\n        for (int[] edge : edges) {\\n            uf.union(edge[0], edge[1]);\\n        }"]}
{"id": "1574", "ref_java": ["class Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }", "class Solution {\\n", "class Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }"]}
{"id": "1575", "ref_java": ["class Solution {\\n\\n    public int countHousePlacements(int n) {\\n        long mod = 1000000007;\\n        long placed = 1;\\n        long unplaced = 1;\\n        for(int i = 2; i<=n; i++){\\n            long newPlaced = unplaced;\\n            long newUnplaced = placed + unplaced;\\n            placed = newPlaced%mod;\\n            unplaced = newUnplaced%mod;\\n        }", "class Solution {\\n    int mod = (int)1e9+7;\\n    public int countHousePlacements(int n) {\\n        \\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        long a = 2;\\n        long b = 3;\\n        if(n==1)\\n            return (int)(a%mod);\\n        if(n==2)\\n            return (int)(b%mod);\\n        long c=0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = (a+b)%mod;\\n            a=b%mod;\\n            b=c%mod;\\n        }", "class Solution {\\n\\n    public int countHousePlacements(int n) {\\n        long mod = 1000000007;\\n        long placed = 1;\\n        long unplaced = 1;\\n        for(int i = 2; i<=n; i++){\\n            long newPlaced = unplaced;\\n            long newUnplaced = placed + unplaced;\\n            placed = newPlaced%mod;\\n            unplaced = newUnplaced%mod;\\n        }"]}
{"id": "1576", "ref_java": ["class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\n        int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }", "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        for(int[] row: arr)   Arrays.fill(row,-1);\\n        int top = 0, left = 0, right = n-1, bottom = m-1;\\n        while(head != null){\\n            for(int i=left; i<=right && head != null; i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }", "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode curr = head;\\n        int startRow = 0;\\n        int endRow = m - 1;\\n        int startCol = 0;\\n        int endCol = n - 1;\\n        int [][] arr = new int[m][n];\\n        while(startCol <= endCol && startRow <= endRow){\\n            "]}
{"id": "1577", "ref_java": ["class Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long mod = 1000000007L;\\n        long[] shares = new long[n + 1];\\n        long[] forgets = new long[n + 1];\\n        \\n        if (delay < n) {\\n            shares[delay + 1] = 1;\\n        }", "class Solution {\\n    ", "class Solution {\\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\\n        long mod = 1000000007L;\\n        long[] shares = new long[n + 1];\\n        long[] forgets = new long[n + 1];\\n        \\n        if (delay < n) {\\n            shares[delay + 1] = 1;\\n        }"]}
{"id": "1578", "ref_java": ["class Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        int passenger = -1, bus = 0, currCap = 0;\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        while(bus < buses.length) {\\n            currCap = 0;\\n            ", "class Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n", "class Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n"]}
{"id": "1579", "ref_java": ["class Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        pq.add(0);\\n        for (int i = 0; i < nums1.length; i++) {\\n        \\tint diff = Math.abs(nums1[i] - nums2[i]);\\n        \\tif (diff > 0)\\n        \\t\\tpq.add(diff);\\n        }", "class Solution {\\n    \\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long minSumSquare = 0;\\n        int[] diffs = new int[100_001];\\n        long totalDiff = 0;\\n        long kSum = k1 + k2;\\n        int currentDiff;\\n        int maxDiff = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            ", "class Solution {\\n    class PQcomparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(b[0], a[0]);\\n        }"]}
{"id": "1581", "ref_java": ["class Solution {\\n    public boolean canChange(String start, String target) {\\n        int ptr1=0;\\n        int ptr2=0;\\n        int n = target.length();\\n\\n        while(ptr1 <= n && ptr2 <= n){\\n            while(ptr1 < n && start.charAt(ptr1) == \\'_\\') ptr1++;\\n            while(ptr2 < n && target.charAt(ptr2) == \\'_\\') ptr2++;\\n\\n            if(ptr1 == n ||ptr2 == n){\\n                return ptr1 == n && ptr2 == n;\\n            }", "class Solution {\\n    public boolean canChange(String start, String target) {\\n        int ptr1=0;\\n        int ptr2=0;\\n        int n = target.length();\\n\\n        while(ptr1 <= n && ptr2 <= n){\\n            while(ptr1 < n && start.charAt(ptr1) == \\'_\\') ptr1++;\\n            while(ptr2 < n && target.charAt(ptr2) == \\'_\\') ptr2++;\\n\\n            if(ptr1 == n ||ptr2 == n){\\n                return ptr1 == n && ptr2 == n;\\n            }", "class Solution {\\n    public boolean canChange(String start, String target) {\\n        int ptr1=0;\\n        int ptr2=0;\\n        int n = target.length();\\n\\n        while(ptr1 <= n && ptr2 <= n){\\n            while(ptr1 < n && start.charAt(ptr1) == \\'_\\') ptr1++;\\n            while(ptr2 < n && target.charAt(ptr2) == \\'_\\') ptr2++;\\n\\n            if(ptr1 == n ||ptr2 == n){\\n                return ptr1 == n && ptr2 == n;\\n            }"]}
{"id": "1582", "ref_java": ["class Solution {\\n    public int maximumSum(int[] nums) {\\n        int ans = -1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int num : nums){\\n            int sumOfDigits = calculateSum(num);\\n            if(map.containsKey(sumOfDigits)){\\n                int prevOne = map.get(sumOfDigits);\\n                ans = Math.max(ans, prevOne + num);\\n                map.put(sumOfDigits, Math.max(prevOne, num));\\n            }", "class Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int nsum;\\n        int ans = -1;\\n        for(int i : nums){\\n            nsum = nsum(i);\\n            if(!map.containsKey(nsum)){\\n                map.put(nsum, i);\\n            }", "class Solution {\\n\\tpublic int maximumSum(int[] arr) {\\n\\t\\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tint temp = getSum(arr[i]);\\n\\t\\t\\tmap.putIfAbsent(temp, new ArrayList<Integer>());\\n\\t\\t\\tmap.get(temp).add(arr[i]);\\n\\t\\t}"]}
{"id": "1583", "ref_java": ["class Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n=queries.length;\\n        PriorityQueue<pair> q=new PriorityQueue<>((a,b)->(b.x.compareTo(a.x))==0?b.y-a.y:b.x.compareTo(a.x));\\n        int ans[]=new int[n];\\n        int r1=0;\\n        for(int p[]:queries){\\n            int k=p[0];\\n            int trim=p[1];\\n            int y1=0;\\n            for(String x:nums){\\n                int u=x.length();\\n                x=x.substring(u-trim);\\n                q.add(new pair(x,y1));\\n                if(q.size()>k){\\n                    q.poll();\\n                }", "class Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }", "class Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n=queries.length;\\n        PriorityQueue<pair> q=new PriorityQueue<>((a,b)->(b.x.compareTo(a.x))==0?b.y-a.y:b.x.compareTo(a.x));\\n        int ans[]=new int[n];\\n        int r1=0;\\n        for(int p[]:queries){\\n            int k=p[0];\\n            int trim=p[1];\\n            int y1=0;\\n            for(String x:nums){\\n                int u=x.length();\\n                x=x.substring(u-trim);\\n                q.add(new pair(x,y1));\\n                if(q.size()>k){\\n                    q.poll();\\n                }"]}
{"id": "1584", "ref_java": ["class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int i = 0;\\n        long count = 0;\\n        ArrayList<Long> al = new ArrayList<>();\\n        while(i != nums.length){\\n            ", "class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\nlong consecutive_zero=0l;\\nlong possibleSubsets=0l;\\nlong totalSubsets=0l;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n            {\\n                  consecutive_zero++;\\n            }", "class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int len0=0, sum=0;\\n        long count=0; \\n\\n        for(int i=0;i<nums.length;i++){\\n            "]}
{"id": "1586", "ref_java": ["class Solution {\\n    public int equalPairs(int[][] grid) {\\n        ", "class Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<Integer,ArrayList<Integer>>row=new HashMap<>();\\n        Map<Integer,ArrayList<Integer>>col=new HashMap<>();\\n\\n        int n=grid.length;\\n\\n        for(int i=0;i<n;i++){\\n            row.put(i,new ArrayList<>());\\n        }", "class Solution {\\n    public int equalPairs(int[][] grid) {\\n        "]}
{"id": "1588", "ref_java": ["\npublic int maximumGroups(int[] grades) {\n        int k = 0, total = 0, n = grades.length;\n        while (total + k + 1 <= n)\n            total += ++k;\n        return k;\n    }\n", "\npublic int maximumGroups(int[] grades) {\n        int k = 0, total = 0, n = grades.length;\n        while (total + k + 1 <= n)\n            total += ++k;\n        return k;\n    }\n", "\npublic int maximumGroups(int[] grades) {\n        int k = 0, total = 0, n = grades.length;\n        while (total + k + 1 <= n)\n            total += ++k;\n        return k;\n    }\n"]}
{"id": "1589", "ref_java": ["class Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int [] arr1 = new int[n];\\n        int [] arr2 = new int[n];\\n        int curr = node1;\\n        int dist = 0;\\n        Arrays.fill(arr1, -1);\\n        Arrays.fill(arr2, -1);\\n        while(curr!=-1 && arr1[curr]==-1){\\n            arr1[curr] = dist;\\n            curr = edges[curr];\\n            dist++;    \\n        }", "class Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] n1Distances = calculateDistanceFromNode(node1, edges);\\n        int[] n2Distances = calculateDistanceFromNode(node2, edges);\\n\\n        int node = -1;\\n        int dis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(n1Distances[i] == -1 || n2Distances[i] == -1) continue;\\n            int maxDistance = Math.max(n1Distances[i], n2Distances[i]);\\n            if (maxDistance < dis) {\\n                node = i;\\n                dis = maxDistance;\\n            }", "class Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];   "]}
{"id": "1590", "ref_java": ["class Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        long count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int diff = i - nums[i];\\n            if(seen.containsKey(diff)){\\n                count += (i - seen.get(diff));\\n            }", "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        long count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int diff = i - nums[i];\\n            if(seen.containsKey(diff)){\\n                count += (i - seen.get(diff));\\n            }", "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        long count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int diff = i - nums[i];\\n            if(seen.containsKey(diff)){\\n                count += (i - seen.get(diff));\\n            }"]}
{"id": "1591", "ref_java": ["class Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long currDay=0L,gap=space;\\n        int len=tasks.length;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<len;i++) {\\n            int task=tasks[i];\\n            if(!map.containsKey(task))\\n                map.put(tasks[i],currDay);\\n            else {\\n                long lastDay=map.get(task);\\n                long taskGap=currDay-lastDay;\\n                if(taskGap<=gap)\\n                    currDay+=gap-taskGap+1;\\n                map.put(task,currDay);\\n            }", "class Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long currDay=0L,gap=space;\\n        int len=tasks.length;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<len;i++) {\\n            int task=tasks[i];\\n            if(!map.containsKey(task))\\n                map.put(tasks[i],currDay);\\n            else {\\n                long lastDay=map.get(task);\\n                long taskGap=currDay-lastDay;\\n                if(taskGap<=gap)\\n                    currDay+=gap-taskGap+1;\\n                map.put(task,currDay);\\n            }", "class Solution {\\n    public long taskSchedulerII(int[] tasks, int space) {\\n        long d=1;\\n        Map<Integer,Long> map=new HashMap<>();\\n        for(int i=0;i<tasks.length;i++){\\n            if(map.containsKey(tasks[i])){\\n                long db=(d-1)-map.get(tasks[i]);\\n                if(db<space){\\n                    d+=space-db;\\n                }"]}
{"id": "1592", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    ", "class Solution {\\n    "]}
{"id": "1593", "ref_java": ["class Solution {\\n    public boolean isPairEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1];\\n    }", "class Solution {\\n    public boolean validPartition(int[] nums) {\\n    int n=nums.length;\\n    boolean dp[]=new boolean[n+1];\\n    dp[n]=true;\\n\\n    for(int i=n-1;i>=0;i--){\\n        if(i+1 <n){\\n            if(nums[i]==nums[i+1] && dp[i+2]){\\n                dp[i]=true;\\n            }", "class Solution {\\n    int[] dp = new int[100005];\\n    \\n    public int solve(int j, int[] nums) {\\n        if (j == nums.length) {\\n            return 1;\\n        }"]}
{"id": "1594", "ref_java": ["class Solution {\\n    public int longestIdealString(String s, int k) {\\n        int DP[] = new int[26], ans = 1;\\n        \\n        for (int ch = 0, n = s.length(); ch < n; ch++) {\\n            int i = s.charAt(ch) - \\'a\\';\\n            DP[i] = DP[i] + 1;\\n            \\n            for (int j = Math.max(0, i - k); j <= Math.min(25, i + k); j++)\\n                if (j != i)\\n                    DP[i] = Math.max(DP[i], DP[j] + 1);\\n            \\n            ans = Math.max(ans, DP[i]);\\n        }", "class Solution {\\n    public int longestIdealString(String s, int k) {\\n        int DP[] = new int[26], ans = 1;\\n        \\n        for (int ch = 0, n = s.length(); ch < n; ch++) {\\n            int i = s.charAt(ch) - \\'a\\';\\n            DP[i] = DP[i] + 1;\\n            \\n            for (int j = Math.max(0, i - k); j <= Math.min(25, i + k); j++)\\n                if (j != i)\\n                    DP[i] = Math.max(DP[i], DP[j] + 1);\\n            \\n            ans = Math.max(ans, DP[i]);\\n        }", "class Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int dp[][] = new int[n][26];\\n        for(int i = 0; i < n; i++){\\n            Arrays.fill(dp[i], -1);\\n        }"]}
{"id": "1595", "ref_java": ["class Solution {\\n    public int edgeScore(int[] edges) {\\n        int n_length=edges.length;\\n\\t\\t", "class Solution {\\n    public int edgeScore(int[] edges) {\\n        int n_length=edges.length;\\n\\t\\t", "class Solution {\\n    public int edgeScore(int[] edges) {\\n        long ans[]=new long[edges.length];\\n        long max=0;\\n        int a=0;\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            ans[edges[i]]+=(long)i;\\n            if(max<ans[edges[i]])\\n            {\\n                a=edges[i];\\n                max=ans[edges[i]];\\n            }"]}
{"id": "1596", "ref_java": ["class Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 9; i >= 1; i--) {\\n            stack.push(i);\\n        }", "class Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        char ch = \\'1\\';\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char cur = pattern.charAt(i);\\n            temp.append(ch++);\\n            if (cur == \\'I\\') {\\n                res.append(temp.reverse());\\n                temp = new StringBuilder();\\n            }", "class Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        char ch = \\'1\\';\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char cur = pattern.charAt(i);\\n            temp.append(ch++);\\n            if (cur == \\'I\\') {\\n                res.append(temp.reverse());\\n                temp = new StringBuilder();\\n            }"]}
{"id": "1597", "ref_java": ["class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }", "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }", "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }"]}
{"id": "1598", "ref_java": ["class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }", "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        ", "class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }"]}
{"id": "1599", "ref_java": ["class Solution {\\n    public String largestPalindromic(String num) {\\n         Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            map.merge((int) c - (int) \\'0\\', 1, Integer::sum);\\n        }", "class Solution {\\n    public String largestPalindromic(String num) {\\n        int[] n = new int[10];\\n        for (char c : num.toCharArray()) {\\n            n[c - \\'0\\']++;\\n        }", "class Solution {\\n\\n    public String largestPalindromic(String num) {\\n        \\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        for(int i=0;i<num.length();i++){\\n            int value = num.charAt(i) - \\'0\\';\\n            hm.put(value,hm.getOrDefault(value,0)+1);\\n        }"]}
{"id": "1600", "ref_java": ["class Solution {\\n    public static TreeNode parent_link(TreeNode root,Map<TreeNode,TreeNode>map,int start){\\n\\t\\tQueue<TreeNode>q=new LinkedList<>();\\n\\t\\tTreeNode res=null;\\n\\t\\tq.add(root);\\n\\n\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\tTreeNode cur=q.poll();\\n\\t\\t\\tif(cur.val==start) res=cur;\\n\\n\\t\\t\\tif(cur.left!=null){\\n\\t\\t\\t\\tmap.put(cur.left,cur);\\n\\t\\t\\t\\tq.add(cur.left);\\n\\t\\t\\t}", "class Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> mpp=new HashMap<>();\\n        TreeNode target=bfsToMapParents(root,mpp,start);\\n        \\n       return findMaxDistance(mpp, target);\\n    }", "class Solution {\\n    \\n    ArrayList<ArrayList<Integer>> ans;\\n    \\n    public  void burn(TreeNode root,int time,TreeNode exc){\\n        \\n      if(root == null || root == exc) return;\\n      if(ans.size() == time) ans.add(new ArrayList<>());\\n      ans.get(time).add(root.val);\\n      burn(root.left,time+1,exc);\\n      burn(root.right,time+1,exc);\\n        \\n  }"]}
{"id": "1601", "ref_java": ["class Solution {\\n        public String removeStars(String s) {\\n        StringBuilder res = new StringBuilder();\\n        for (char c : s.toCharArray())\\n            if (c == \\'*\\')\\n                res.setLength(res.length() - 1);\\n            else\\n                res.append(c);\\n        return res.toString();\\n    }", "class Solution {\\n    public String removeStars(String s) {\\n        char []arr=s.toCharArray();\\n        int n=arr.length;\\n        char []arr2=new char[n];\\n        int j=-1;\\n        for(int i=0;i<n;i++){\\n           if(arr[i]!=\\'*\\'){\\n               j++;\\n               arr2[j]=arr[i];\\n           }", "class Solution {\\n        public String removeStars(String s) {\\n        StringBuilder res = new StringBuilder();\\n        for (char c : s.toCharArray())\\n            if (c == \\'*\\')\\n                res.setLength(res.length() - 1);\\n            else\\n                res.append(c);\\n        return res.toString();\\n    }"]}
{"id": "1602", "ref_java": ["class Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        ", "class Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        ", "class Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int res = 0;\\n\\n        for (String g : garbage) {\\n            res += g.length();\\n        }"]}
{"id": "1603", "ref_java": ["class Solution {\\n    boolean check(String s){\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                return false;\\n            }", "class Solution {\\n    boolean check(String s){\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                return false;\\n            }", "class Solution {\\n    boolean check(String s){\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                return false;\\n            }"]}
{"id": "1604", "ref_java": ["class Solution {\\n    int m,n,res = 0, arr[], cols,mat[][];\\n    public int maximumRows(int[][] mat, int cols) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        this.cols = cols;\\n        arr = new int[cols];\\n        this.mat = mat;\\n        recurse(-1,-1);\\n        return res;\\n    }", "class Solution {\\n    int m,n,res = 0, arr[], cols,mat[][];\\n    public int maximumRows(int[][] mat, int cols) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        this.cols = cols;\\n        arr = new int[cols];\\n        this.mat = mat;\\n        recurse(-1,-1);\\n        return res;\\n    }", "class Solution {\\n    int result;\\n    public int maximumRows(int[][] mat, int cols) {\\n        int m = mat.length; "]}
{"id": "1605", "ref_java": ["class Solution {\\n    int mod= 1000000007;\\n    \\n    public int numberOfWays(int stPos, int endPos, int k) {\\n        int[][] dp= new int[5001][1001];\\n        for(int i=0; i<5001; i++){\\n            for(int j=0; j<1001 ; j++){\\n                dp[i][j]= -1;\\n            }", "class Solution {\\n    int mod= 1000000007;\\n    \\n    public int numberOfWays(int stPos, int endPos, int k) {\\n        int[][] dp= new int[5001][1001];\\n        for(int i=0; i<5001; i++){\\n            for(int j=0; j<1001 ; j++){\\n                dp[i][j]= -1;\\n            }", "class Solution {\\n    int mod= 1000000007;\\n    \\n    public int numberOfWays(int stPos, int endPos, int k) {\\n        int[][] dp= new int[5001][1001];\\n        for(int i=0; i<5001; i++){\\n            for(int j=0; j<1001 ; j++){\\n                dp[i][j]= -1;\\n            }"]}
{"id": "1606", "ref_java": ["class Solution {\\n    public int longestNiceSubarray(int[] nums) {        \\n        int i,j,n=nums.length,res,max=1;\\n        for(i=j=res=0;j<n;){\\n            if((res&nums[j])>0){\\n                res=res^nums[i];\\n                i++;\\n            }", "class Solution {\\n    public int longestNiceSubarray(int[] nums) {        \\n        int i,j,n=nums.length,res,max=1;\\n        for(i=j=res=0;j<n;){\\n            if((res&nums[j])>0){\\n                res=res^nums[i];\\n                i++;\\n            }", "class Solution {\\n    public int longestNiceSubarray(int[] nums) {        \\n        int i,j,n=nums.length,res,max=1;\\n        for(i=j=res=0;j<n;){\\n            if((res&nums[j])>0){\\n                res=res^nums[i];\\n                i++;\\n            }"]}
{"id": "1607", "ref_java": ["class Solution {\\n    public int partitionString(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i < arr.length) {\\n            int j = i + 1;\\n            boolean[] seen = new boolean[26]; ", "class Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n\\n        int i = 0;\\n        int count = 0;\\n\\n        while(i<s.length()){\\n            char c = s.charAt(i);\\n            if(hs.add(c)){\\n              i++;\\n            }", "class Solution {\\n    public int partitionString(String s) {\\n      HashSet<Character> set = new HashSet<>();\\n      int count = 1;\\n      for(char c : s.toCharArray()) {\\n          if(set.contains(c)) {\\n              count ++;\\n              set.clear();\\n          }"]}
{"id": "1608", "ref_java": ["class Solution {\\n    public int minGroups(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->\\n        {\\n            if(a[0]==b[0])return a[1]-b[1];\\n            else return a[0]-b[0];\\n        }", "class Solution {\\n    public int minGroups(int[][] intervals) {\\n        \\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        \\n        Arrays.sort(intervals,(a,b)->(a[0]==b[0])?a[1]-b[1]:a[0]-b[0]);\\n        \\n        for(int[] arr:intervals){\\n            if(pq.size()>0 && pq.peek()<arr[0]){\\n                pq.remove();\\n            }", "class Solution {\\n    public int minGroups(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->\\n        {\\n            if(a[0]==b[0])return a[1]-b[1];\\n            else return a[0]-b[0];\\n        }"]}
{"id": "1609", "ref_java": ["class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int res=0,i=0,j=0,p=players.length,t=trainers.length;\\n        Arrays.sort(players); Arrays.sort(trainers);\\n        while(i<p && j<t){\\n            if(players[i]<=trainers[j]){\\n                res++;\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        int n = p.length;\\n        int m = t.length;\\n        int i=0,j=0;\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int ans = 0;\\n        while(i<n && j<m){\\n            while(j<m && t[j] < p[i]) j++;\\n            if(j<m){\\n                ans++;\\n                i++;j++;\\n            }", "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = players.length - 1, j = trainers.length - 1, matchings = 0;\\n        while(i >= 0 && j >= 0) {\\n\\t\\t\\t"]}
{"id": "1610", "ref_java": ["class Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int max[]=new int[33],i,j=-1,arr[]=new int[33],n=nums.length,x=0, res[]= new int[n];\\n        for(int num: nums){\\n            x=x|num;\\n        }", "class Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int max[]=new int[33],i,j=-1,arr[]=new int[33],n=nums.length,x=0, res[]= new int[n];\\n        for(int num: nums){\\n            x=x|num;\\n        }", "class Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] map = new int[32];\\n        int[] res = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int num = nums[i];\\n            for (int j = 0; j <= 31; j++) {\\n                int mask = 1 << (j);\\n                if ((num & mask) > 0) {\\n                    map[j] = i;\\n                }"]}
{"id": "1611", "ref_java": ["class Solution {\\n    public int longestContinuousSubstring(String s) {\\n        ", "class Solution {\\n    public int longestContinuousSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        int i=0, res=0;\\n        \\n        ", "class Solution {\\n    public int longestContinuousSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        int i=0, res=0;\\n        \\n        "]}
{"id": "1612", "ref_java": ["class Solution {\\n    public TreeNode reverseOddLevels(TreeNode root) {\\n        Map<Integer, Queue<Integer>> map = new HashMap<>();\\n        traverseBSTLeft(root, map, 0);\\n        traverseBSTRight(root, map, 0);\\n        return root;\\n    }", "class Solution {\\n    public TreeNode reverseOddLevels(TreeNode root) {\\n        ", "class Solution {\\n    public TreeNode reverseOddLevels(TreeNode root) {\\n         traverse(root.left,root.right,1);\\n         return root;\\n    }"]}
{"id": "1613", "ref_java": ["class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int result = 0, length = 0, max = 0;\\n        for (int ele : nums) {\\n            max = Math.max(max, ele);\\n        }", "class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int result = 0, length = 0, max = 0;\\n        for (int ele : nums) {\\n            max = Math.max(max, ele);\\n        }", "class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        \\n        "]}
{"id": "1614", "ref_java": ["class Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        Deque<Integer> deq = new ArrayDeque<>();\\n        int n = nums.length;\\n        int[][] res = new int[n][2];\\n        \\n        ", "class Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        Deque<Integer> deq = new ArrayDeque<>();\\n        int n = nums.length;\\n        int[][] res = new int[n][2];\\n        \\n        ", "class Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] cntG = new int[nums.length];\\n        int[] cntP = new int[nums.length];\\n        int cnt = 1;\\n        cntG[n-1] = 1;\\n        for(int i = n-2; i >=0; i--) {\\n            cntG[i] = cnt;\\n            if(nums[i]<=nums[i+1]) {\\n              cnt++;\\n            }"]}
{"id": "1616", "ref_java": ["class Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\t        int m = nums1.length;\\n\\t        int n = nums2.length;\\n\\t        Map<Integer, Integer> freq = new HashMap<>();\\n\\t        \\n\\t        for(int i = 0; i < m; i++) {\\n\\t            int c = freq.getOrDefault(nums1[i], 0);\\n\\t            freq.put(nums1[i], c + n);\\n\\t        }", "class Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\t        int m = nums1.length;\\n\\t        int n = nums2.length;\\n\\t        Map<Integer, Integer> freq = new HashMap<>();\\n\\t        \\n\\t        for(int i = 0; i < m; i++) {\\n\\t            int c = freq.getOrDefault(nums1[i], 0);\\n\\t            freq.put(nums1[i], c + n);\\n\\t        }", "class Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\t        int m = nums1.length;\\n\\t        int n = nums2.length;\\n\\t        Map<Integer, Integer> freq = new HashMap<>();\\n\\t        \\n\\t        for(int i = 0; i < m; i++) {\\n\\t            int c = freq.getOrDefault(nums1[i], 0);\\n\\t            freq.put(nums1[i], c + n);\\n\\t        }"]}
{"id": "1617", "ref_java": ["class Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        for(int i = 0; i < n-2; i++) {\\n            for(int j = 0; j < m-2; j++) {\\n                int sum = 0;\\n                for(int z = j; z < j+3; z++) {\\n                    sum += grid[i][z];\\n                }", "class Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = -1, m = grid.length, n = grid[0].length;\\n        for (int row = 0; row < m - 2; row++) {\\n            for (int col = 0; col < n - 2; col++) {\\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n                temp += grid[row + 1][col + 1];\\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n                if (max < temp) {\\n                    max = temp;\\n                }", "class Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0, max = 0;\\n        for(int i=0; i<grid.length-2; i++){\\n            for(int j = 0; j<grid[0].length-2; j++){\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = Math.max(max, sum);\\n            }"]}
{"id": "1618", "ref_java": ["class Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int a=0,b=0,n=num1;\\n        ", "class Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCount = Integer.bitCount(num2);\\n        bitCount -= Integer.bitCount(num1);\\n\\n        int cur = 1;\\n        while (bitCount != 0) {\\n            if (bitCount < 0 && (num1 & cur) != 0) { ", "class Solution {\\n    public int minimizeXor(int num1, int num2) {\\n        int bitCount = Integer.bitCount(num2);\\n        bitCount -= Integer.bitCount(num1);\\n\\n        int cur = 1;\\n        while (bitCount != 0) {\\n            if (bitCount < 0 && (num1 & cur) != 0) { "]}
{"id": "1619", "ref_java": ["class Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] result = new int[pref.length];\\n        result[0] = pref[0];\\n        for(int i = 1; i < pref.length; i++) {\\n            result[i] = pref[i] ^ pref[i-1];\\n        }", "class Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] ans = new int[n];\\n        ans[0] = pref[0];\\n        for (int i = 1; i < n; i++) {\\n            ans[i] = pref[i] ^ pref[i - 1];\\n        }", "class Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int arr[] = new int[n];\\n        arr[0] = pref[0];\\n\\n        for(int i=1; i<n; i++){\\n            arr[i] = pref[i-1]^pref[i];\\n        }"]}
{"id": "1620", "ref_java": ["class Solution {\\n    public String robotWithString(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        dp[n-1] = n-1;\\n        for (int i = n-2; i >= 0; i--) {\\n\\t\\t\\tdp[i] = s.charAt(i)<=s.charAt(dp[i+1]) ? i : dp[i+1];\\n        }", "class Solution {\\n    public String robotWithString(String s) {\\n        char[] arr = s.toCharArray();\\n        int[] rightMin = new int[arr.length]; ", "class Solution {\\n    public String robotWithString(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        Stack<Character> t = new Stack<>();\\n        char[] schar = s.toCharArray();\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) map.put(schar[i], i);\\n        Arrays.sort(schar);\\n        \\n        int cur = -1;\\n        int i = 0;\\n        while(i < s.length()){\\n            char curch = schar[i];"]}
{"id": "1621", "ref_java": ["class Solution {\\n    BigInteger mod = new BigInteger((int)(1e9 + 7) + \"\");\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n\\n        ", "class Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        List<Long> powers = new ArrayList<>();\\n        for(int i=0; i<32; i++) {\\n            if((n & 1) == 1) {\\n                powers.add((long)Math.pow(2, i));\\n            }", "class Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod=1000000007;\\n        "]}
{"id": "1622", "ref_java": ["class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            ans = Math.max(ans, (sum + i) / (i + 1));\\n        }", "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmax = Math.max(max, ((sum += nums[i]) + i) / (i + 1));\\n\\t\\t}", "class Solution {\\n\\n    public int minimizeArrayValue(int[] nums) {\\n\\t\\n        int max = nums[0];\\n\\t\\t\\n\\t\\t"]}
{"id": "1623", "ref_java": ["class Solution {\\n    public int countDistinctIntegers(int[] nums) {\\n        Set<Integer> unique = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            if (n > 9) {\\n                int r = 0;\\n                while (n > 0) {\\n                    r += n % 10;\\n                    if (n > 9) {\\n                        r *= 10;\\n                    }", "class Solution {\\n    public int countDistinctIntegers(int[] nums) {\\n        Set<Integer> unique = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            if (n > 9) {\\n                int r = 0;\\n                while (n > 0) {\\n                    r += n % 10;\\n                    if (n > 9) {\\n                        r *= 10;\\n                    }", "class Solution {\\n    public int countDistinctIntegers(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n            StringBuilder sb = new StringBuilder(Integer.toString(nums[i]));\\n            set.add(Integer.parseInt(sb.reverse().toString()));\\n        }"]}
{"id": "1624", "ref_java": ["class Solution {\\n    public boolean sumOfNumberAndReverse(int num) {\\n        int i=0;\\n        HashSet<Integer> set=new HashSet<Integer>();\\n        if(num==0){\\n            return true;\\n        }", "class Solution {\\n    public boolean sumOfNumberAndReverse(int num) {\\n        for(int i=0;i<=num;i++){\\n            int rev=0;\\n            int temp=i;\\n            while(temp!=0){\\n                int r=temp%10;\\n                rev=rev*10+r;\\n                temp=temp/10;\\n            }", "class Solution {\\n    public boolean sumOfNumberAndReverse(int num) {\\n        for (int i = 0; i <= num; i++) {\\n            int copyI = i;\\n            int value1 = i;\\n            int value2 = 0;\\n            while (copyI > 0) {\\n                value2 = value2 * 10 + copyI % 10;\\n                copyI = copyI / 10;\\n            }"]}
{"id": "1625", "ref_java": ["class Solution {\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }", "class Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int temp=nums[i];\\n            if(temp==k){\\n                ans++;\\n            }", "class Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        \\n        int res = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                res++;\\n            }"]}
{"id": "1626", "ref_java": ["class Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        int k=q.length;\\n        List<String> nm=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            for(int j=0;j<d.length;j++)\\n            {\\n                int c=0;\\n                for(int p=0;p<Math.min(d[j].length(),q[i].length());p++)\\n                {\\n                    if(d[j].charAt(p)!=q[i].charAt(p))\\n                        c++;\\n                }", "class Solution {\\n\\n    ", "class Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> l=new ArrayList<>();\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            for(int j=0;j<dictionary.length;j++)\\n            {\\n                if(match(queries[i],dictionary[j])){l.add(queries[i]);break;}"]}
{"id": "1627", "ref_java": ["class Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Arrays.sort(nums);    ", "class Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Arrays.sort(nums);    ", "class Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Arrays.sort(nums);    "]}
{"id": "1628", "ref_java": ["class Solution {\\n    public List<List<String>> mostPopularCreator(final String[] creators, final String[] ids, final int[] views) {\\n        final List<List<String>> result = new ArrayList<>();\\n        final Map<String, Creator> totalViews = new HashMap<>();\\n        final PriorityQueue<Creator> maxHeap = new PriorityQueue<>((a, b) -> b.totalViews() - a.totalViews());\\n\\n        final int n = creators.length;\\n\\n        for(int i = 0; i < n; ++i) {\\n            totalViews.putIfAbsent(creators[i], new Creator(creators[i], views[i], ids[i]));\\n\\n            Creator creator = totalViews.get(creators[i]);\\n\\n            creator.totalViews(creator.totalViews() + views[i]);\\n\\n            if(views[i] > creator.maxViewsVideo() || (views[i] == creator.maxViewsVideo() && ids[i].compareTo(creator.maxViewsVideoId()) < 0))\\n                creator.maxViewsVideo(views[i]).maxViewsVideoId(ids[i]);\\n        }", "class Solution {\\n    public List<List<String>> mostPopularCreator(String[] cr, String[] ids, int[] vw) {\\n        HashMap<String, Integer> h = new HashMap<>();\\n\\n        for (int i = 0; i < cr.length; i++) {\\n            h.put(cr[i], h.getOrDefault(cr[i], 0) + vw[i]);\\n        }", "class Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,Pair> map=new TreeMap<>();\\n        long max=0L;\\n   \\n        for(int i=0;i<creators.length;i++){\\n            if(!map.containsKey(creators[i])){\\n             Pair temp=new Pair(creators[i],ids[i],views[i]);\\n                map.put(creators[i],temp);\\n            }"]}
{"id": "1629", "ref_java": ["class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = 0;\\n        String s = String.valueOf(n);\\n        ", "class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        ", "class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n    long n0 = n, base = 1;\\n        while (sumOfDigits(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }"]}
{"id": "1630", "ref_java": ["class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, maxSum = 0;\\n        int i = 0, j = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        while(j < nums.length){\\n            if(j - i < k && hs.size() < k){\\n                while(hs.size()>0 && hs.contains(nums[j])){\\n                    sum -= nums[i];\\n                    hs.remove(nums[i++]);\\n                }", "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n         int n=nums.length;      \\n             HashMap<Integer,Integer> hmap=new HashMap<>();\\n             int i=0,j=0;\\n             long res=0,curr=0;\\n             for( i=0;i<n;i++)\\n             {                \\n              while(j<i && (hmap.containsKey(nums[i]) || hmap.size()>=k))\\n              {\\n                 curr=curr-nums[j];\\n                 hmap.remove(nums[j++]);\\n            \\n        }", "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        int i=0;\\n        int j=0;\\n        sum=nums[i];\\n        long ans=0;\\n        HashSet<Integer> set1=new HashSet<Integer>();\\n        for(int num:nums){\\n            set1.add(num);\\n        }"]}
{"id": "1631", "ref_java": ["class Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n        int i = 0;\\n        int j = costs.length - 1;\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        long ans = 0;\\n        while (k-- > 0) {\\n            while (pq1.size() < candidates && i <= j) {\\n                pq1.offer(costs[i++]);\\n            }", "class Solution {\\n    public long totalCost(int[] costs, int k, int candidates) {\\n\\n       long cost = 0;\\n\\n        int startPtr = candidates - 1;\\n        int endPtr = costs.length - candidates;\\n\\n        if (startPtr >= endPtr) {\\n            endPtr = startPtr + 1;\\n        }", "class Solution {\\n  public long totalCost(int[] costs, int k, int candidates) {\\n    int l = 0, r = costs.length - 1;\\n    \\n    PriorityQueue<int[]> L = new PriorityQueue<>(r+1, (int[] o1, int[] o2) ->{\\n        if(o2[0] != o1[0]) return o1[0] - o2[0];\\n        return                    o1[1] - o2[1]; }"]}
{"id": "1632", "ref_java": ["class Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n          int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n\\n        for (int end = 1; end <= high; ++end) {\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n                dp[end] %= mod;\\n            }", "class Solution {\\n\\n    int mod = 1_00_00_00_00_7;\\n\\n    public int lgs(int dp[],int len,int zero,int one){\\n        if(len==0) return 1;\\n        if(len<0) return 0;\\n        if(dp[len]!=-1) return dp[len];\\n\\n        int s = (lgs(dp,len-zero,zero,one)+lgs(dp,len-one,zero,one))%mod;\\n        dp[len] = s;\\n        return s;\\n\\n    }", "class Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return countGoodStrings(low, high, one, zero);\\n        }"]}
{"id": "1633", "ref_java": ["class Solution {\\n    ", "class Solution {\\n\\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        final int n = amount.length;\\n\\t\\t", "class Solution {\\n    static int [] par;\\n    static int result; \\n    static int mostProfitablePath(int[][] edges, int bob, int[] amount) {\\n        par = new int [amount.length];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        result = (int)(-1e9);\\n        for(int i = 0; i < amount.length; i++) adj.add(new ArrayList<>());\\n        for(int []edge: edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }"]}
{"id": "1634", "ref_java": ["class Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int res = 0;\\n        int n = nums.length;\\n        for(int i=0; i<nums.length; i++){\\n            int currLcm = 1;\\n            for(int j=i; j<n; j++){\\n                currLcm = lcm(currLcm, nums[j]);\\n                \\n                res += (currLcm == k) ? 1 : 0;\\n            }", "class Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0, lcm = 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            lcm = 1;\\n            for(int j = i; j < nums.length; j++) {\\n                lcm = lcm(lcm, nums[j]);\\n                if(lcm == k) count++;\\n                else if(lcm > k) break;\\n            }", "class Solution {\\n    public int subarrayLCM(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int l = nums[i];\\n            if(l == k) count++;\\n            for(int j=i+1; j<nums.length; j++) {\\n                l = lcm(l, nums[j]);\\n                if(l == k) count++;\\n                if(l > k) break;\\n            }"]}
{"id": "1635", "ref_java": ["class Solution {\\n    public int minimumOperations(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        int s=0;\\n        while(!q.isEmpty())\\n        {\\n            int m=0,l=q.size();\\n            List<Integer> l1=new ArrayList<>();\\n            for(int i=0;i<l;i++)\\n            {\\n                if(q.peek().left!=null)\\n                {\\n                    q.add(q.peek().left);\\n                }", "class Solution {\\n    public int indexOf(int[] arr, int ele)\\n    {\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == ele) {\\n                return i;\\n            }", "class Solution {\\n    public int MinimumOperations(TreeNode root) {\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        \\n        int minOps = 0;\\n        while (queue.Count > 0) {\\n            int size = queue.Count;\\n            int[] arr = new int[size];\\n            int index = 0;\\n            for (int i = 0; i < size; i++) {\\n                var currNode = queue.Dequeue();\\n                arr[index++] = currNode.val;\\n                \\n                if (currNode.left != null)\\n                    queue.Enqueue(currNode.left);\\n                \\n                if (currNode.right != null)\\n                    queue.Enqueue(currNode.right);\\n            }"]}
{"id": "1636", "ref_java": ["class Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        \\n        List<Integer> list = new ArrayList<>();\\n        inOrder(root,list);\\n        List<List<Integer>> result = new ArrayList<>(); \\n\\n        for(int query : queries) {\\n            result.add(findMinMaxTo(list, query));\\n        }", "class Solution {\\n    static TreeSet<Integer> preorder(TreeNode root,TreeSet<Integer> set){\\n        if(root == null) return set;\\n        set  = preorder(root.left, set);\\n        set.add(root.val);\\n        set  = preorder(root.right, set);\\n        return set;\\n    }", "class Solution {\\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int max = -1;\\n        int min = -1;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        inorder(root, set);\\n        int idx = 0;\\n        for(int q : queries){\\n            ArrayList<Integer> base = new ArrayList<>();\\n            if(set.contains(q)){\\n                min = q;\\n                max = q;\\n            }"]}
{"id": "1637", "ref_java": ["class Solution {\\n    long fuel;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if(roads.length == 0) return 0;\\n        fuel = 0;\\n        List<List<Integer>> ls = new ArrayList<>();\\n        for(int i = 0; i<=roads.length; i++) ls.add(new ArrayList<>());\\n        for(int road[] : roads){\\n            ls.get(road[0]).add(road[1]);\\n            ls.get(road[1]).add(road[0]);\\n        }", "class Solution {\\n    private static long TotalCost = 0;\\n    private static int Seats;\\n\\n    public static long minimumFuelCost(int[][] roads, int seats) {\\n\\n        if (roads.length == 1) {\\n            return 0;\\n        }", "class Solution {\\n    long ans = 0; int s;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph = new ArrayList();\\n        s = seats;\\n        for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n        for (int[] r : roads) {\\n            graph.get(r[0]).add(r[1]);\\n            graph.get(r[1]).add(r[0]);\\n        }"]}
{"id": "1638", "ref_java": ["class Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] rowOnes = new int[grid.length];\\n        int[] colOnes = new int[grid[0].length];\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                rowOnes[i] += grid[i][j];\\n                colOnes[j] += grid[i][j];\\n            }", "class Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res = new int[m][n];\\n        int[] onesRow = new int[m];\\n        int[] onesCol = new int[n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                onesRow[i] += grid[i][j];\\n                onesCol[j] += grid[i][j];\\n            }", "class Solution {\\n    public int[][] onesMinusZeros(int[][] grid) {\\n        int[] rowOnes = new int[grid.length];\\n        int[] colOnes = new int[grid[0].length];\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                rowOnes[i] += grid[i][j];\\n                colOnes[j] += grid[i][j];\\n            }"]}
{"id": "1639", "ref_java": ["class Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }", "class Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }", "class Solution {\\n    public int bestClosingTime(String customers) {\\n        int penalty = 0;\\n        int n = customers.length();\\n        for(int i=0;i<n;i++){\\n            if(customers.charAt(i)==\\'Y\\'){\\n                penalty++;\\n            }"]}
{"id": "1640", "ref_java": ["class Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<s.length()&&j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<s.length()&&j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i<s.length()&& j<t.length())\\n        {\\n        \\tif(s.charAt(i)==t.charAt(j))\\n        \\t{\\n        \\t\\ti++;\\n        \\t\\tj++;\\n        \\t}"]}
{"id": "1641", "ref_java": ["class Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> stack = new Stack();\\n        ListNode rev = reverse(head);\\n        while(rev != null) {\\n            if(stack.isEmpty() || (!stack.isEmpty() && rev.val >= stack.peek())) {\\n                stack.push(rev.val);\\n            }", "class Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> stack = new Stack();\\n        ListNode rev = reverse(head);\\n        while(rev != null) {\\n            if(stack.isEmpty() || (!stack.isEmpty() && rev.val >= stack.peek())) {\\n                stack.push(rev.val);\\n            }", "class Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode cur = head;\\n        List<ListNode> list = new ArrayList<>();\\n        while (cur != null) {\\n            list.add(cur);\\n            cur = cur.next;\\n        }"]}
{"id": "1642", "ref_java": ["class Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long res=0;\\n        int d=skill[0]+skill[skill.length-1];\\n        for(int i=0;i<skill.length/2;i++)\\n        {\\n            int s=skill[i];\\n            int e=skill[skill.length-1-i];\\n            if(d!=s+e)return -1;\\n            res+=(s*e);\\n        }", "class Solution {\\n    public long dividePlayers(int[] skills) {\\n\\t\\tArrays.sort(skills);\\n\\t\\tint i = 0;\\n\\t\\tint j = skills.length-1;\\n        int reqSkill = skills[i] + skills[j];\\n        \\n        long ans = 0;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (skills[i] + skills[j] == reqSkill) {\\n\\t\\t\\t\\tans += skills[i++] * skills[j--];\\n\\t\\t\\t}", "class Solution {\\n    public long dividePlayers(int[] skill) {\\n        int len=skill.length;\\n        if(len == 2) return skill[0]*skill[1];\\n        int teams=len/2, sum=0;\\n        for(int i=0; i<len; i++){\\n            sum += skill[i];\\n        }"]}
{"id": "1643", "ref_java": ["class Solution {\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            if (!graph.containsKey(road[0])) {\\n                graph.put(road[0], new HashMap<>());\\n            }", "class Solution {\\n    public int minEdge;\\n    public int minScore(int n, int[][] roads) {\\n        this.minEdge = Integer.MAX_VALUE;\\n        Map<Integer, List<Node>> graph = constructGraph(roads);\\n        dfs(graph, 1, new HashSet<>(), n);\\n        return this.minEdge;\\n    }", "class Solution {\\n    private List<int[]>[] adj;\\n    private int score = 10001;\\n    private boolean[] vis;\\n    public int minScore(int n, int[][] roads) {\\n        adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }"]}
{"id": "1644", "ref_java": ["class Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        int n = vals.length;\\n        List<Integer>[] graph = new List[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }", "class Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        ArrayList<ArrayList<Integer>> list=new ArrayList();\\n        int arr[]=new int[vals.length];\\n        for(int i=0;i<vals.length;i++)\\n            arr[i]=vals[i];\\n", "class Solution {\\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\\n        HashMap<Integer, PriorityQueue<Integer>> hm = new HashMap<>();\\n        \\n\\t\\t"]}
{"id": "1645", "ref_java": ["class Solution {\\n    public int maxJump(int[] stones) {\\n        int ans = stones[1]; \\n        for (int i = 2; i < stones.length; ++i) \\n            ans = Math.max(ans, stones[i] - stones[i-2]); \\n        return ans; \\n    }", "class Solution {\\n    public int maxJump(int[] stones) {\\n        ", "class Solution {\\n    public int maxJump(int[] stones) {\\n        "]}
{"id": "1646", "ref_java": ["class Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            ", "class Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> squareStreak = new HashMap<>();\\n        int best = -1;\\n\\n        for (int x : nums) {\\n            double sqrt = Math.pow(x, 0.5);\\n            if (sqrt % 1 == 0 && squareStreak.containsKey((int) sqrt)) {\\n                squareStreak.put(x, squareStreak.get((int) sqrt) + 1);\\n                best = Math.max(best, squareStreak.get(x));\\n            }", "class Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int ovrlMax = -1;\\n\\n        Set<Long> set = new HashSet();\\n        for(int num : nums){\\n            set.add((long)num);\\n        }"]}
{"id": "1648", "ref_java": ["class Solution {\\n    public int smallestValue(int n) {\\n        int k=n;\\n        if(n<=4)\\n            return n;\\n\\t\\twhile(true)\\n        {\\n            int sum=0;\\n            for (int i=2;i<=n/2;i++)\\n            {\\n                ", "class Solution {\\n    public int smallestValue(int n) {\\n        if(isPrime(n)) return n; ", "class Solution {\\n    int a = 2;\\n    public int smallestValue(int n) {\\n        int sum = factorial(n,2);\\n        "]}
{"id": "1649", "ref_java": ["class Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashMap<String,Integer> mp1=new HashMap<>();\\n        HashMap<String,Integer> mp2=new HashMap<>();\\n        for(int i=0;i<positive_feedback.length;i++){\\n            mp1.put(positive_feedback[i],3);\\n        }", "class Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        ", "class Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        Set<String> pos = new HashSet<>(List.of(positive_feedback));\\n        Set<String> neg = new HashSet<>(List.of(negative_feedback));\\n        int n = report.length;\\n        int[][] rank = new int[n][2];\\n        "]}
{"id": "1650", "ref_java": ["class Solution {\\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n        int low=1;\\n        int high=Integer.MAX_VALUE;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,divisor1,divisor2,uniqueCnt1,uniqueCnt2))\\n                high=mid;\\n            else\\n                low=mid+1;\\n        }", "class Solution {\\n    int gcd(int a,int b){\\n        return b == 0 ? a : gcd(b,a % b);\\n    }", "class Solution {\\n\\tpublic int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\\n\\t\\tint g = divisor1; \\n\\t\\tfor (int x = divisor2; x > 0; ) {int tmp = g; g = x; x = tmp % x; }"]}
{"id": "1651", "ref_java": ["class Solution {\\n    public boolean valid(int arr[],int k){\\n         if(arr[0]<k || arr[1]<k || arr[2] < k) return false;\\n         return true;\\n    }", "class Solution {\\n    public int takeCharacters(String s, int k) { \\n        HashMap<Integer,Integer>map_a=new HashMap<>();\\n        HashMap<Integer,Integer>map_b=new HashMap<>();\\n        HashMap<Integer,Integer>map_c=new HashMap<>();\\n        int n=s.length();\\n        int count=0;\\n        map_a.put(0,n);\\n        map_b.put(0,n);\\n        map_c.put(0,n);\\n        for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'a\\'){\\n                count++;\\n                map_a.put(count,i);\\n            }", "class Solution {\\n    public int takeCharacters(String s, int k) {\\n        int[] arr=new int[3];\\n        "]}
{"id": "1652", "ref_java": ["class Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        int lo = 0;\\n        int hi =  price[n-1] - price[0];\\n\\n        while (lo < hi) {\\n            int mid = 1 + lo + (hi - lo) / 2; ", "class Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        int lo = 0;\\n        int hi =  price[n-1] - price[0];\\n\\n        while (lo < hi) {\\n            int mid = 1 + lo + (hi - lo) / 2; ", "class Solution {\\n    public int maximumTastiness(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        \\n        int n = arr.length;\\n        int s = 0;  "]}
{"id": "1653", "ref_java": ["class Solution {\\n    public static int p[];\\n    Solution(){ \\n        if(p==null){\\n            p=new int[1001]; ", "class Solution {\\n    public int distinctPrimeFactors(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i:nums)\\n        {\\n            if(i%2==0)\\n            {\\n                set.add(2);\\n                \\n                while(i%2==0)\\n                {\\n                    i=i/2;\\n                }", "class Solution {\\n    public int distinctPrimeFactors(int[] nums) {\\n        Set<Integer> primeFactors = new HashSet<>();\\n        for (int num : nums) {\\n            "]}
{"id": "1654", "ref_java": ["class Solution {\\n    public int minimumPartition(String s, int k) {\\n        int total = 0;\\n        for(int i = s.length() - 1, end = s.length(), temp = Long.parseLong(s.substring(i, end)) <= k ? 1 : 0; i >= 0; end = (temp == 0 ? i + 1 : end), temp = Long.parseLong(s.substring(i, end)) <= k ? 1 : 0, i -= temp, total += 1 - temp)if(i + 1 == end && temp == 0)return -1;\\n        return total + 1;\\n    }", "class Solution {\\n    int inf = (int) 1e6;\\n    int dp[];\\n    public int minimumPartition(String s, int k) {\\n        int n = s.length();\\n        dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\t\\t", "class Solution {\\n    public int minimumPartition(String s, int k) {\\n        int i=0,c=0,j=0;\\n        "]}
{"id": "1655", "ref_java": ["class Solution {\\n    public static boolean[]sieve(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++) prime[i] = true;\\n        for (int p=2;p*p<= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }", "class Solution {\\n    public static boolean[]sieve(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++) prime[i] = true;\\n        for (int p=2;p*p<= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }", "class Solution {\\n    public static boolean[]sieve(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++) prime[i] = true;\\n        for (int p=2;p*p<= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }"]}
{"id": "1657", "ref_java": ["class Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for (int num : nums)\\n            xor ^= num;\\n        return xor;\\n    }", "class Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = -1;\\n        if (nums.length == 1) return nums[0];\\n        for (int i = 1; i < nums.length; i+=2) {\\n            int a = nums[i - 1], b = nums[i];\\n            if (xor == -1) xor = a ^ 0 ^ a ^ b ^ a ^ b ^ 0 ^ b;\\n            else xor ^= a ^ 0 ^ a ^ b ^ a ^ b ^ 0 ^ b;\\n        }", "class Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xorBeauty = 0;\\n        int kBeauty = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            kBeauty = (kBeauty ^ nums[i]);\\n        }"]}
{"id": "1658", "ref_java": ["class Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\\n        public int compare(Integer a, Integer b) {\\n            return b - a;\\n        }", "class Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer>pq = new PriorityQueue<>((a,b)->b-a); ", "class Solution {\\n    public long maxKelements(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:nums)\\n            pq.add(x);\\n        long score=0;\\n        while(k-->0){\\n            int a = pq.remove();\\n            score+=a;\\n            pq.add((int)Math.ceil((double)a/3));\\n        }"]}
{"id": "1659", "ref_java": ["class Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n        for(int i = 0; i < word1.length(); i++){\\n            char ch = word1.charAt(i);\\n            int idx = ch - \\'a\\';\\n            arr1[idx] = arr1[idx] + 1;     ", "class Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] letters1 = new int[26];\\n        int[] letters2 = new int[26];\\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            letters1[c - \\'a\\']++;\\n        }", "class Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] freq1 = new int[128];\\n        int[] freq2 = new int[128];\\n        \\n        for(char c : word1.toCharArray()) freq1[c]++;\\n        for(char c : word2.toCharArray()) freq2[c]++;\\n        \\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n            \\n            if(freq1[c1] > 0) {\\n                \\n                for(char c2 = \\'a\\'; c2 <= \\'z\\'; c2++) {\\n                    \\n                    if(freq2[c2] > 0) {\\n                        freq2[c1]++;\\n                        freq1[c2]++;\\n                        freq1[c1]--;\\n                        freq2[c2]--;\\n                        \\n                        if(isEqual(freq1, freq2)) return true;\\n                        \\n                        freq2[c1]--;\\n                        freq1[c2]--;\\n                        freq1[c1]++;\\n                        freq2[c2]++;\\n                    }"]}
{"id": "1660", "ref_java": ["class Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n            int[][] mat = new int[n][n];\\n        for (int[] query : queries) {\\n            int row1 = query[0], col1 = query[1], row2 = query[2], col2 = query[3];\\n            for (int i = row1; i <= row2; i++) {\\n                for (int j = col1; j <= col2; j++) {\\n                    mat[i][j]++;\\n                }", "class Solution {\\n    public int[][] rangeAddQueries(int n, int[][] queries) {\\n        int[][] arr = new int[n][n];\\n        for(int k=0; k<queries.length; k++){\\n            for(int i=queries[k][0]; i<=queries[k][2]; i++){\\n                for(int j=queries[k][1]; j<=queries[k][3]; j++){\\n                    arr[i][j] += 1;\\n                }", "class Solution {\\n   public int[][] rangeAddQueries(int n, int[][] queries) {\\n   int[][] ans = new int[n][n];\\n   for (int[] q : queries) {\\n       int row1 = q[0], col1 = q[1], row2 = q[2], col2 = q[3];\\n       for (int i = row1; i <= row2; i++) \\n       {\\n           ans[i][col1] +=1; "]}
{"id": "1661", "ref_java": ["class Solution {\\n        public long countGood(int[] nums, int k) {\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        long countPairs = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n\\n                int val = map.get(nums[i]);\\n                ", "class Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int i=0;\\n        int j=0;\\n        long count=0;\\n        long ans=0;\\n\\n        while(j<nums.length){\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            count+=map.get(nums[j])-1;\\n\\n            while(count>=k){\\n                ans+=nums.length-j;\\n                count-=map.get(nums[i])-1;\\n                map.put(nums[i],map.getOrDefault(nums[i],0)-1);\\n\\n                if(map.get(nums[i])==0){\\n                    map.remove(nums[i]);\\n                }", "class Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        int n=nums.length;\\n        long ans=0;\\n        long c=0;\\n            \\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0;int j=0;\\n      \\n        while(j<n){\\n            \\n            if(mp.containsKey(nums[j])==false){\\n                mp.put(nums[j],1);\\n            }"]}
{"id": "1662", "ref_java": ["class Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n     long add=0,sub=0;\\n     for(int i=0;i<nums1.length;i++)\\n     {\\n         if(k==0&&nums1[i]!=nums2[i])return -1;\\n         if(nums1[i]==nums2[i])continue;\\n         else if(nums1[i]<nums2[i]){\\n             int val1=nums2[i]-nums1[i];\\n             if(val1%k==0)add+=(val1/k);\\n             else return -1;\\n         }", "class Solution {\\n\\tpublic long minOperations(int[] nums1, int[] nums2, double k) {\\n\\t\\tlong count = 0, total = 0;\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\t\\t\\tif (nums1[i] != nums2[i] && (k == 0 || (nums1[i] - nums2[i]) % k != 0)) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}", "class Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long up = 0, down = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            int abs = Math.abs(nums1[i] - nums2[i]);\\n            if(k == 0) return -1;\\n            else if( abs % k == 0){\\n                if(nums1[i] > nums2[i]) down += abs/k;\\n                else up += abs/k;\\n            }"]}
{"id": "1663", "ref_java": ["class Solution {\\n", "class Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0;\\n        int N = nums1.length;\\n\\n        if (k == 1) {\\n            for (int i = 0; i < N; i++) {\\n                long cur = (long) nums1[i] * nums2[i];\\n                ans = Math.max(ans, cur);\\n            }", "class Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0;\\n        int N = nums1.length;\\n\\n        if (k == 1) {\\n            for (int i = 0; i < N; i++) {\\n                long cur = (long) nums1[i] * nums2[i];\\n                ans = Math.max(ans, cur);\\n            }"]}
{"id": "1664", "ref_java": ["class Solution {\\n    public int[][] sortTheStudents(int[][] score, int k) {\\n        Arrays.sort(score,Comparator.comparingDouble(a -> a[k]));\\n        int i=0,j=score.length-1;\\n        while(i<j){\\n            int[] temp=score[i];\\n            score[i]=score[j];\\n            score[j]=temp;\\n            i++;\\n            j--;\\n        }", "class Solution {\\n    public int[][] sortTheStudents(int[][] score, int k) {\\n        Arrays.sort(score, new Comparator<int[]>() {           \\n          public int compare(int[] e1, int[] e2) {\\n            if (e1[k] >= e2[k]) return -1;\\n            else return 1;\\n          }", "class Solution {\\n    public int[][] sortTheStudents(int[][] score, int k)\\n    {\\n        "]}
{"id": "1665", "ref_java": ["class Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if (s.equals(target)) {     ", "class Solution {\\n    public boolean makeStringsEqual(String s, String target) {\\n        if(s.equals(target)) return true;\\n        int s1 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') s1++;\\n            if(target.charAt(i) == \\'1\\') t1++;\\n        }", "class Solution {\\n    public boolean makeStringsEqual(String s, String t) {\\n        int n = s.length();\\n        int sc0=0, sc1=0; "]}
{"id": "1666", "ref_java": ["class Solution {\\n    private static int max = 1000000007;\\n    public int monkeyMove(int n) {\\n", "class Solution {\\n    public int monkeyMove(int n) {\\n        int mod = 1000000007;\\n        int ans = (int) power(2, n, mod) - 2;\\n        ", "class Solution {\\n    int mod = 1000000007;\\n    public int monkeyMove(int n) {\\n        int  exp =(int) pow(2,n)%mod;\\n        System.out.println(exp);\\n        return (int) (exp + mod - 2) % mod;\\n    }"]}
{"id": "1667", "ref_java": ["class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }", "class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int res=0;\\n        int sum=0;\\n        int a[]=new int[100001];\\n        for(int i:banned)a[i]++;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(a[i]==0&&(i+sum)<=maxSum){\\n                res++;\\n                sum+=i;\\n            }", "class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        "]}
{"id": "1668", "ref_java": ["class Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        ", "class Solution {\\n    public int maximizeWin(int[] pos, int k) {\\n        int n = pos.length;\\n        \\n        long max1=Long.MIN_VALUE, sum=0;\\n        int maxIdx=0, i=0,j=0, maxIdx2=0;\\n        \\n        while(i<n){\\n            while(j<n && pos[j]-pos[i] <= k){\\n                sum++;\\n                j++;\\n            }", "class Solution {\\n    public int maximizeWin(int[] pos, int k) {\\n        int n = pos.length;\\n        \\n        long max1=Long.MIN_VALUE, sum=0;\\n        int maxIdx=0, i=0,j=0, maxIdx2=0;\\n        \\n        while(i<n){\\n            while(j<n && pos[j]-pos[i] <= k){\\n                sum++;\\n                j++;\\n            }"]}
{"id": "1669", "ref_java": ["class Solution {\\n", "class Solution {\\n    public boolean isPossibleToCutPath(int[][] grid) {\\n        int rows = grid.length;    \\n        int cols = grid[0].length;    \\n        if(rows == 1 && cols <=2 ) return false;\\n        if(rows == 1){\\n            int summ=0;\\n             for(int j = 0; j < cols; j++){    \\n              summ += grid[0][j];    \\n            }", "class Solution {\\n    private static final int[][] dirs={{0,1}"]}
{"id": "1670", "ref_java": ["class Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int acpt[] = new int[words.length];\\n        for(int i=0; i<words.length; i++)   acpt[i] = check(words[i]);\\n        for(int i=1; i<words.length; i++)   acpt[i] += acpt[i-1];\\n        int res[] = new int[queries.length];\\n        for(int i=0; i<queries.length; i++)\\n            res[i] = acpt[queries[i][1]]-(queries[i][0] == 0 ? 0 : acpt[queries[i][0]-1]);\\n        return res;\\n    }", "class Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        HashSet<Character> hs = new HashSet<>();\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n        \\n        int N = words.length;\\n        int[] arr = new int[N];\\n        for(int i=0; i<N; i++) {\\n            if(hs.contains(words[i].charAt(0)) && hs.contains(words[i].charAt(words[i].length()-1))){\\n                arr[i] = 1;\\n            }", "class Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int m = queries.length;\\n        int[] preSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            String word = words[i - 1];\\n            if (word.length() >= 1 && vowel(word.charAt(0)) && vowel(word.charAt(word.length() - 1))) {\\n                preSum[i] = preSum[i - 1] + 1;\\n            }"]}
{"id": "1671", "ref_java": ["class Solution {\\n    public int minCapability(int[] nums, int k) {\\n        ", "class Solution {\\n    public int minCapability(int[] nums, int k) {\\n        ", "class Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int lo = Integer.MAX_VALUE, hi = Integer.MIN_VALUE;\\n\\n        for(int it : nums){\\n            lo = Math.min(lo, it);\\n            hi = Math.max(hi, it);\\n        }"]}
{"id": "1672", "ref_java": ["class Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int low=lower-nums[i];\\n            int high=upper-nums[i];\\n            long l=help1(nums,i+1,low);\\n            long h=help2(nums,i+1,high);\\n            ans+=h-l;\\n        }", "class Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long result = 0;\\n        for(int i = 0; i < n-1; i++){\\n            long lowSum = lower - nums[i];\\n            long highSum = upper - nums[i];\\n            int count1 = lowerBound(i+1, n, nums, lowSum);\\n            int count2 = upperBound(i+1, n, nums, highSum);\\n            result += (count2 - count1);\\n        }", "class Solution {\\n    public long countFairPairs(int[] nums, int lower, int upper) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int low=lower-nums[i];\\n            int high=upper-nums[i];\\n            long l=help1(nums,i+1,low);\\n            long h=help2(nums,i+1,high);\\n            ans+=h-l;\\n        }"]}
{"id": "1673", "ref_java": ["class Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int m = queries.length;\\n        int[][] ret = new int[m][];\\n\\n        int n = s.length();\\n        Map<Integer, int[]> map = new HashMap<>();\\n        map.put(0, new int[]{s.indexOf(\"0\"),s.indexOf(\"0\")}", "class Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] ans = new int[queries.length][2];\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[]{i, i}", "class Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        "]}
{"id": "1674", "ref_java": ["class Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n        ", "class Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n        ", "class Solution {\\n  public int minimizeSum(int[] nums) {\\n    final int n = nums.length;\\n    Arrays.sort(nums);\\n    "]}
{"id": "1675", "ref_java": ["class Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int i:nums)\\n        {\\n            nm.put(i, nm.getOrDefault(i,0)+1);\\n        }", "class Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> s=new HashSet<>();\\n        for(int i: nums)s.add(i);\\n        int i=0;\\n        for(i=0;i<32;i++)\\n        {\\n            if(!s.contains((int)Math.pow(2,i))){\\n                break;\\n            }", "class Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> s=new HashSet<>();\\n        for(int i: nums)s.add(i);\\n        int i=0;\\n        for(i=0;i<32;i++)\\n        {\\n            if(!s.contains((int)Math.pow(2,i))){\\n                break;\\n            }"]}
{"id": "1676", "ref_java": ["class Solution {\\n    public int minOperations(int n) {\\n        return Integer.bitCount(n ^ (3 * n));\\n    }", "class Solution {\\n    public int minOperations(int n) {\\n        \\n        int ans = 0;\\n        \\n        if(n<2 || (n & (n - 1)) == 0)      ", "class Solution {\\n    public int minOperations(int n) {\\n        int op = 1;\\n        while(n != 0){\\n            int num = 1;\\n            while(num <= n){\\n                if(num == n){\\n                   return op; \\n                }"]}
{"id": "1677", "ref_java": ["class Solution {\\n    int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}", "class Solution {\\n    public int squareFreeSubsets(int[] nums) {\\n        int[] count = new int[31];\\n        int[] secondOrderUnpickable = new int[31];\\n        ", "class Solution {\\n    int MOD = (int)1e9 + 7;\\n    public int squareFreeSubsets(int[] nums) {\\n        int[][] dp = new int[1010][1 << 11];\\n        for (int[] d : dp) Arrays.fill(d, -1);\\n\\n        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}"]}
{"id": "1678", "ref_java": ["class Solution {\\n    public int[] divisibilityArray(String word, int m) {\\n    int n = word.length();\\n    int[] div = new int[n];\\n    long remainder = 0;\\n    for (int i = 0; i < n; i++) {\\n            int digit = word.charAt(i) - \\'0\\';\\n            remainder = (remainder * 10 + digit) % m;\\n            if (remainder == 0) {\\n                div[i] = 1;\\n            }", "class Solution {\\n    public int[] divisibilityArray(String word, int m) {\\n    int n = word.length();\\n    int[] div = new int[n];\\n    long num = 0;\\n    for (int i = 0; i < n; i++) {\\n        long digit = word.charAt(i) - \\'0\\';\\n        num = (num * 10 + digit) % m;\\n        div[i] = (num == 0) ? 1 : 0;\\n    }", "class Solution {\\n    public int[] divisibilityArray(String word, int m) {\\n        \\n        int l = word.length();\\n        int[] ans = new int[l];\\n        long num = 0;\\n        \\n        for (int i = 0; i < l; i++) {\\n            num = (num * 10) + (word.charAt(i) - \\'0\\');\\n            \\n            if (num % m == 0) ans[i] = 1;\\n            else ans[i] = 0;\\n\\n            num %= m;\\n        }"]}
{"id": "1679", "ref_java": ["class Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int counter = 0;\\n        int i =0, j =nums.length/2;\\n\\n        while(i < nums.length/2  &&  j < nums.length){\\n            if(nums[i] * 2 <= nums[j]){\\n                counter += 2;\\n                i++;j++;\\n                continue;\\n            }", "class Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int end = n - 1;\\n        int ans = 0;\\n\\n        for (int i = (n / 2) - 1; i >= 0; i--) {\\n            if (nums[i] * 2 <= nums[end]) {\\n                ans += 2;\\n                nums[i] = -1;\\n                nums[end] = -1;\\n            }", "class Solution {\\n    public int maxNumOfMarkedIndices(int[] nums) {\\n        Arrays.sort(nums);\\n        int mid=(nums.length+1)>>1;\\n        int low=0;\\n        int cnt=0;\\n        while(mid<nums.length){\\n            if(nums[mid]>=((nums[low])<<1)){\\n                low++;\\n                cnt+=2;\\n            }"]}
{"id": "1680", "ref_java": ["class Solution {\\n    public long coloredCells(int n) {\\n        long sum=1L;\\n        if(n==1)return sum;\\n        for(int i=2;i<=n;i++){\\n            sum+=(long)(4L*(long)(i-1));\\n        }", "class Solution {\\n    public long coloredCells(int n) {\\n        if(n==1)\\n            return 1l;\\n        long x=1;\\n        long i=1;\\n        while(n-->1){\\n            x+=(i*4l);\\n            i++;\\n        }", "class Solution {\\n    public long coloredCells(int n) {\\n        long sum=1L;\\n        if(n==1)return sum;\\n        for(int i=2;i<=n;i++){\\n            sum+=(long)(4L*(long)(i-1));\\n        }"]}
{"id": "1681", "ref_java": ["class Solution {\\n    public int countWays(int[][] ranges) \\n    {\\n        final long MOD = 1000000007;\\n        long ans = 1, size = ranges.length;\\n        \\n        if (size == 1) return 2;\\n        \\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = Integer.MIN_VALUE;\\n        \\n        for (int idx = 1; idx < size; idx++)\\n        {\\n            tillMax = Math.max(tillMax , ranges[idx-1][1]);\\n            \\n            if (ranges[idx][0] <=ranges[idx-1][1] || ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++;\\n        }", "class Solution {\\n    public int countWays(int[][] ranges) \\n    {\\n        final long MOD = 1000000007;\\n        long ans = 1, size = ranges.length;\\n        \\n        if (size == 1) return 2;\\n        \\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = Integer.MIN_VALUE;\\n        \\n        for (int idx = 1; idx < size; idx++)\\n        {\\n            tillMax = Math.max(tillMax , ranges[idx-1][1]);\\n            \\n            if (ranges[idx][0] <=ranges[idx-1][1] || ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++;\\n        }", "class Solution {\\n    public int countWays(int[][] ranges) \\n    {\\n        final long MOD = 1000000007;\\n        long ans = 1, size = ranges.length;\\n        \\n        if (size == 1) return 2;\\n        \\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = Integer.MIN_VALUE;\\n        \\n        for (int idx = 1; idx < size; idx++)\\n        {\\n            tillMax = Math.max(tillMax , ranges[idx-1][1]);\\n            \\n            if (ranges[idx][0] <=ranges[idx-1][1] || ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++;\\n        }"]}
{"id": "1682", "ref_java": ["class Solution {\\n    static final TreeNode[] bfsStk = new TreeNode[34500];\\n    \\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        final int rightStart = bfsStk.length - 1;\\n        int rightIdx = rightStart;\\n        int leftIdx = 0;\\n        bfsStk[leftIdx++] = root;\\n        PriorityQueue<Long> pque = new PriorityQueue<Long>(Math.min(k, 100));\\n        long lowestInPQue = -1;\\n        \\n        while (true) {\\n            {\\n                ", "class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q=new LinkedList<>();\\n        q.add(root);\\n        ", "class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> minHeap = new PriorityQueue<>();\\n        List<TreeNode> curLevel = new ArrayList<>();\\n        curLevel.add(root);\\n        while (!curLevel.isEmpty()) {\\n            List<TreeNode> nextLevel = new ArrayList<>();\\n            long s = 0;\\n            for (TreeNode node: curLevel) {\\n                if (node.left != null) {\\n                    nextLevel.add(node.left);\\n                }"]}
{"id": "1683", "ref_java": ["class Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int i=nums.length-1;\\n        Arrays.sort(nums);\\n        if(nums[nums.length-1] == 0)    return 0;\\n        while(i >= 0){\\n            sum += nums[i--];\\n            if(sum <= 0) return nums.length-i-2;\\n        }", "class Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            sum += nums[i];\\n            prefix[i] = sum;\\n            if(prefix[i] > 0) ans++;\\n        }", "class Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        int count = 0; \\n        for(int i=nums.length-1; i>=0; i--){\\n            sum += nums[i];\\n            if(sum > 0) count++;\\n            else break; \\n        }"]}
{"id": "1684", "ref_java": ["class Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long count = 0;\\n        int xor = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        \\n        for(int num : nums){\\n            count += map.merge(xor ^= num, 1, Integer::sum)-1;\\n        }", "class Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n = nums.length;\\n        \\n       \\n        int sum = 0;\\n        long count = 0;\\n        ", "class Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] ^ nums[i];\\n        }"]}
{"id": "1685", "ref_java": ["class Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        PriorityQueue<Integer> pq1 = new PriorityQueue();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue();\\n        for(int i: nums){\\n            pq1.add(i);\\n            pq2.add(i);\\n        }", "class Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int p1 = 0;\\n        int p2 = 1;\\n        int count = 0;\\n        while(p2 < nums.length){\\n            if(nums[p2] > nums[p1]){\\n                count++;\\n                p1++;\\n                p2++;\\n            }", "class Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        TreeMap<Integer, Integer> numsCount = new TreeMap<>();\\n        for (int num : nums) {\\n            numsCount.put(num, numsCount.getOrDefault(num, 0) + 1);\\n        }"]}
{"id": "1686", "ref_java": ["class Solution {\\n    public long findScore(int[] nums) {\\n        long res=0;\\n        int n=nums.length;\\n        int a[][]=new int[n][2];\\n        for(int i=0;i<n;i++){a[i][0]=i;a[i][1]=nums[i];}", "class Solution {\\n\\t\\tpublic  long findScore(int[] nums) {\\n\\t\\t\\tlong sum=0;\\n\\t\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>((x,y)-> {return  x[0]!=y[0]?x[0]-y[0]:x[1]-y[1]}", "class Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]==b[1] ? a[0]-b[0] : a[1]-b[1]);\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{i,nums[i]}"]}
{"id": "1687", "ref_java": ["class Solution {\\n    public long repairCars(int[] arr, int c) {\\n        long[] ranks = new long[arr.length];\\n        int idx = 0;\\n        for(int ele : arr)\\n        {\\n            ranks[idx++] = (ele * 1l);\\n        }", "class Solution {\\n    public boolean fun(int ranks[],int cars,long t){\\n        long a=0;\\n        for(int i:ranks){\\n            a+=Math.sqrt(t/i);\\n        }", "class Solution {\\n    public boolean fun(int ranks[],int cars,long t){\\n        long a=0;\\n        for(int i:ranks){\\n            a+=Math.sqrt(t/i);\\n        }"]}
{"id": "1688", "ref_java": ["class Solution {\\n    static void isValid(int grid[][],boolean visited[][],int v1,int v2,int move,int r,int c){\\n        if(v1<0 || v2<0 ||v1>=r || v2>=c)return;\\n        if(!visited[v1][v2]&& grid[v1][v2]==move ){\\n            visited[v1][v2]=true;\\n            isValid(grid,visited,v1+1,v2+2,move+1,r,c);\\n            isValid(grid,visited,v1+1,v2-2,move+1,r,c);\\n            isValid(grid,visited,v1-1,v2+2,move+1,r,c);\\n            isValid(grid,visited,v1-1,v2-2,move+1,r,c);\\n            \\n            isValid(grid,visited,v1+2,v2+1,move+1,r,c);\\n            isValid(grid,visited,v1-2,v2+1,move+1,r,c);\\n            isValid(grid,visited,v1+2,v2-1,move+1,r,c);\\n            isValid(grid,visited,v1-2,v2-1,move+1,r,c);\\n        }", "class Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int m=grid.length,n=grid.length;\\n        int[][] ans=new int[m][n];\\n        for(int p=0;p<m;p++){\\n            for(int q=0;q<n;q++){\\n                ans[p][q]=-1;\\n            }", "class Solution {\\n    int[][] directions = new int[][]{{-2, -1}"]}
{"id": "1689", "ref_java": ["class Solution {\\n    int map[];\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        map = new int[1003];\\n        \\n        return helper(0,k,nums)-1;\\n    }", "class Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        int n = nums.length;\\n        return dfs(nums, k, seen, n, 0) - 1;\\n    }", "class Solution {\\n    List<int []> l1;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length==1){\\n            return 1;\\n        }"]}
{"id": "1690", "ref_java": ["class Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        int vis[]=new int[value];\\n        for(int it:nums){\\n            if(it%value<0) vis[(it%value)+value]++;\\n           else vis[Math.abs(it)%value]++; \\n        }", "class Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        ", "class Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int n = nums.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            int mod = num % value;\\n            mod = mod >= 0 ? mod : mod + value;\\n            map.put(mod, map.getOrDefault(mod, 0) + 1);\\n        }"]}
{"id": "1691", "ref_java": ["class Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }", "class Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }", "class Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }"]}
{"id": "1692", "ref_java": ["class Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        List<Long> list = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        long[] arr1 = new long[n];\\n        long[] arr2 = new long[n];\\n        \\n        arr1[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            arr1[i] = arr1[i-1]+nums[i];\\n        }", "class Solution {\\n    public List<Long> minOperations(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        int m = queries.length;\\n        \\n        List<Long> list = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        long[] arr1 = new long[n];\\n        long[] arr2 = new long[n];\\n        \\n        arr1[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            arr1[i] = arr1[i-1]+nums[i];\\n        }", "class Solution {\\n    public List<Long> minOperations(int[] nums, int[] q) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n    \\n        List<Long> ans = new ArrayList<>();\\n\\n        long[] prefix = new long[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }"]}
{"id": "1693", "ref_java": ["class Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int arr[] = new int[100001];\\n        for(int i=0; i<s.length(); i++){\\n            if(chars.contains(s.charAt(i)+\"\"))  arr[i] = vals[chars.indexOf(s.charAt(i))];\\n            else arr[i] = s.charAt(i)-\\'a\\'+1;\\n        }", "class Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int arr[] = new int[100001];\\n        for(int i=0; i<s.length(); i++){\\n            if(chars.contains(s.charAt(i)+\"\"))  arr[i] = vals[chars.indexOf(s.charAt(i))];\\n            else arr[i] = s.charAt(i)-\\'a\\'+1;\\n        }", "class Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int[] nums = new int[n]; "]}
{"id": "1694", "ref_java": ["class Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }", "class Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }", "class Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }"]}
{"id": "1695", "ref_java": ["class Solution {\\n     Map<Integer,Integer> map=new HashMap<>();\\n    int ifany(Map<Integer,Integer> map)\\n    {\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)>=1)\\n                return 1;\\n        }", "class Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        int arr[]=new int[nums.length+1];\\n        Arrays.fill(arr,-1);\\n        List<Integer> l=new ArrayList<>();\\n        ans.add(l);\\n        int size=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(arr[nums[i]]==-1){\\n            l.add(nums[i]);\\n                arr[nums[i]]=0;\\n            }", "class Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            set.add(nums[i]);\\n        }"]}
{"id": "1696", "ref_java": ["class Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        int n = reward1.length;\\n        int[][] r1 = new int[n][2];\\n        ", "class Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int i = 0; i < reward1.length; i++) {\\n            int diff = reward1[i] - reward2[i];\\n            pq.offer(new Pair(i, diff));\\n        }", "class Solution {\\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\\n        List<Pair<Integer, Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < reward1.length; i++) {\\n            ans.add(new Pair<>(reward1[i] - reward2[i], i));\\n        }"]}
{"id": "1697", "ref_java": ["class Solution {\\n    public long[] distance(int[] nums) {\\n        long res[] = new long[nums.length];\\n        int count[] = new int[nums.length];\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                res[i] = res[prev]+count[prev]*(i-prev);\\n                count[i] = count[prev]+1;\\n            }", "class Solution {\\n    public long[] distance(int[] arr) {\\n        Map<Long,long[]> map = new HashMap<>(); \\n        ", "class Solution {\\n    public long[] helper1(int[] nums){\\n        long[] ans = new long[nums.length];\\n        HashMap<Integer, Integer> last = new HashMap<>();\\n        HashMap<Integer, Long> freq = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(last.containsKey(nums[i]) == true){\\n                int j = last.get(nums[i]);\\n                ans[i] = ans[j] + freq.get(nums[i]) * (i - j * 1l);\\n            }"]}
{"id": "1698", "ref_java": ["class Solution {\\n    public int minimizeMax(int[] A, int p) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int l = 0;\\n        int r = A[n-1]-A[0];\\n        int mid;\\n        while(l<r){\\n            mid = (l+r)/2;\\n            if(helper(A, mid, p)>=p) r = mid;\\n            else l = mid +1;\\n        }", "class Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if (p == 0)  return 0;\\n        if (nums.length <= 2)  return Math.abs(nums[0] - nums[1]);\\n        Arrays.sort(nums);\\n        int[] diffs = new int[nums.length - 1];\\n        int right = 0;\\n        int left  = 1_000_000_001;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            right = Math.max(right, (diffs[i] = nums[i + 1] - nums[i]));\\n            left  = Math.min(left,  diffs[i]);\\n        }", "class Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(nums.length==1){\\n            return 0;\\n        }"]}
{"id": "1707", "ref_java": ["class Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }", "class Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }", "class Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        "]}
{"id": "1708", "ref_java": ["class Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }", "class Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }", "class Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }"]}
{"id": "1709", "ref_java": ["class Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        int ans =0;\\n        int i=0;\\n        while(i<len-1){\\n            char c = word.charAt(i);\\n            char cnex = word.charAt(i+1);\\n            if(c==\\'a\\'){\\n                if(cnex ==\\'a\\')ans+=2;\\n                else if(i<len-2 && cnex==\\'b\\' && word.charAt(i+2)==\\'c\\')i+=2;\\n                else{\\n                    ans++;\\n                    i++;\\n                }", "class Solution {\\n    public int addMinimum(String word) {\\n        int len = word.length();\\n        int ans =0;\\n        int i=0;\\n        while(i<len-1){\\n            char c = word.charAt(i);\\n            char cnex = word.charAt(i+1);\\n            if(c==\\'a\\'){\\n                if(cnex ==\\'a\\')ans+=2;\\n                else if(i<len-2 && cnex==\\'b\\' && word.charAt(i+2)==\\'c\\')i+=2;\\n                else{\\n                    ans++;\\n                    i++;\\n                }", "class Solution {\\n    public int addMinimum(String word) {\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)==\\'a\\'){\\n                if(i+1<word.length() && word.charAt(i+1)==\\'b\\'){\\n                    if(i+2<word.length() && word.charAt(i+2)==\\'c\\')\\n                        i+=2;\\n                    else{\\n                        ans++;\\n                        i++;\\n                    }"]}
{"id": "1711", "ref_java": ["class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }", "class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }", "class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}"]}
{"id": "1712", "ref_java": ["class Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            ", "class Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }", "class Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            "]}
{"id": "1713", "ref_java": ["class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length;\\n        int[] ans = new int[n];\\n        int[] seen = new int[n + 1];\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2)\\n                cur++;\\n            if (++seen[B[i]] == 2)\\n                cur++;\\n            ans[i] = cur;\\n        }", "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }", "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }"]}
{"id": "1714", "ref_java": ["class Solution {\\n     int[] x = {-1,0,1,0}", "class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }", "class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t"]}
{"id": "1715", "ref_java": ["class Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n", "class Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int size = arr.length;\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        ", "class Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]> map=new HashMap<>();\\n        HashMap<Integer,Integer> row=new HashMap<>();\\n        HashMap<Integer,Integer> col=new HashMap<>();\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                map.put(mat[i][j], new int[]{i,j}"]}
{"id": "1716", "ref_java": ["class Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int cost;\\n        Pair(int x,int y,int cost){\\n            this.x=x;\\n            this.y=y;\\n            this.cost=cost;\\n        }", "class Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int[] dp = new int[specialRoads.length]; ", "class Solution {\\n    record Point(int x, int y) {}"]}
{"id": "1718", "ref_java": ["class Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int c = 0;\\n        int[] a = new int[n];\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int p = queries[i][0];\\n            int  m = queries[i][1];\\n            c = update_color(c, a, p, false);\\n            a[p] = m;\\n            c = update_color(c, a, p, true);\\n            ans[i] = c;\\n        }", "class Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        if(n==1) return new int[queries.length];\\n        \\n        int ans[]=new int[queries.length];  ", "class Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int c = 0;\\n        int[] a = new int[n];\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int p = queries[i][0];\\n            int  m = queries[i][1];\\n            c = update_color(c, a, p, false);\\n            a[p] = m;\\n            c = update_color(c, a, p, true);\\n            ans[i] = c;\\n        }"]}
{"id": "1719", "ref_java": ["class Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }", "class Solution {\\n    int myN,max;\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        myN = n;\\n        max =  helper(0,cost);\\n        helper2(0,0,cost);\\n        return ans;\\n    }", "class Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] cb = new int[n]; "]}
{"id": "1720", "ref_java": ["class Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }", "class Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length, max = Integer.MIN_VALUE, temp = 0, count = 0;\\n        int m = nums[0].length;\\n        List<Integer> arr = new ArrayList<>();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            al.add(new ArrayList<>());\\n        }", "class Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length, max = Integer.MIN_VALUE, temp = 0, count = 0;\\n        int m = nums[0].length;\\n        List<Integer> arr = new ArrayList<>();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            al.add(new ArrayList<>());\\n        }"]}
{"id": "1721", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length, pre[] = new int[n], post[] = new int[n];\\n        long res = 0L;\\n        for (int i = 1; i < n; i++) {\\n            ", "class Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        if(nums.length == 1) {\\n            return (long)nums[0] << k;\\n        }"]}
{"id": "1722", "ref_java": ["class Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }", "class Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }", "class Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n       int currXor=0;\\n       for(int i: derived)\\n        currXor ^= i;\\n        return currXor==0;\\n\\n    }"]}
{"id": "1723", "ref_java": ["class Solution {\\n  int[][] dp;\\n  int[] dirs = new int[] {-1, 0, 1}", "class Solution {\\n    int ans=0;\\n    public int maxMoves(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n            for(int i=0;i<m;i++){\\n                boolean visited[][]=new boolean[m][n];\\n                int max=0;\\n                max=count(i,0,grid,visited,m,n);\\n                ans=Math.max(ans,max);\\n            }", "class Solution {\\n    public int maxMoves(int[][] grid) {\\n        int dp[][]=new int[grid.length][grid[0].length];\\n        int max=0;\\n        for(int i=1;i<grid[0].length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                if(grid[j][i-1]<grid[j][i]){\\n                    if(i==1 || dp[j][i-1]>0)dp[j][i]=Math.max(dp[j][i],1+dp[j][i-1]);\\n                }"]}
{"id": "1724", "ref_java": ["class Solution {\\n    Set<Integer> vis = new HashSet<>();\\n    Map<Integer, Set<Integer>> nodes;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ", "class Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n       int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }", "class Solution {\\n  List<Integer>[] adj;\\n  boolean[] seen;\\n  int cnt = -1;\\n  int nodes = 0;\\n  \\n  private boolean helper(int i) {\\n    seen[i] = true;\\n    nodes++;\\n    var edges = 0;\\n    var ret = true;\\n    \\n    for (var neighbor : adj[i]) {\\n      edges++;\\n      \\n      if (!seen[neighbor])\\n        ret &= helper(neighbor);\\n    }"]}
{"id": "1727", "ref_java": ["class Solution {\\n    public int punishmentNumber(int n) {\\n       \\n        int count=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(check(0,i,0,Integer.toString(i*i))) count=count+(i*i);\\n        }", "class Solution {\\n  private Set<Integer> helper(int num, String s, int i) {\\n    var n = s.length();\\n    var ret = new HashSet<Integer>();\\n    \\n    if (i == n) {\\n      ret.add(0);\\n      return ret;\\n    }", "class Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 1;\\n        for(int i=2;i<=n;i++) {\\n            if(checkNumber(i)) {\\n                sum += (i*i);\\n            }"]}
{"id": "1729", "ref_java": ["class Solution {\\n    public int minExtraChar(String s, String[] dictionary) {\\n        int maxVal = s.length() + 1;\\n        int[] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, maxVal);\\n        dp[0] = 0;\\n\\n        Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));\\n\\n        for (int i = 1; i <= s.length(); ++i) {\\n            dp[i] = dp[i - 1] + 1;\\n            for (int l = 1; l <= i; ++l) {\\n                if (dictionarySet.contains(s.substring(i - l, i))) {\\n                    dp[i] = Math.min(dp[i], dp[i - l]);\\n                }", "class Solution {\\n    Integer[] dp; int n; String str; HashSet<String> set;\\n    public int minExtraChar(String s, String[] dictionary) {\\n        n=s.length(); dp=new Integer[n+1]; dp[n]=0;\\n        str=s; set=new HashSet<String>(Arrays.asList(dictionary));\\n        return f(0);\\n    }", "class Solution {\\n    private int[] dp = new int[51]; "]}
{"id": "1730", "ref_java": ["class Solution {\\n    private long maxStrength;\\n\\n    public long maxStrength(int[] nums) {\\n        maxStrength = Integer.MIN_VALUE;\\n        helper(nums, 0, 1, 0);\\n        return maxStrength;\\n    }", "class Solution {\\n    private long maxStrength;\\n\\n    public long maxStrength(int[] nums) {\\n        maxStrength = Integer.MIN_VALUE;\\n        helper(nums, 0, 1, 0);\\n        return maxStrength;\\n    }", "class Solution {\\n    public long maxStrength(int[] nums) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        ArrayList<Integer> neg = new ArrayList<>();\\n        long ans = 1;\\n        int n_neg = 0;\\n        int zero=0;\\n        int take=0;\\n\\n        "]}
{"id": "1731", "ref_java": ["class Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n               int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res=new int[m][n];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                res[i][j]=calculate(grid,i,j);\\n            }", "class Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n       int ans[][] = new int[grid.length][grid[0].length]; \\n       for(int i = 0 ; i<grid.length ; i++){\\n           for(int j =0 ; j<grid[0].length; j++){\\n               int temp1 = i;\\n               int temp2 = j;\\n               \\n               \\n               ArrayList<Integer> ans1 = new ArrayList<>();\\n               while(temp1>0 && temp2>0){\\n                   \\n                   \\n                 temp1--;\\n                 temp2--;\\n                 if(!ans1.contains(grid[temp1][temp2])){\\n                       ans1.add(grid[temp1][temp2]);    \\n                   }", "class Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n      \\n      int lenr=grid.length;\\n      int lenc=grid[0].length;\\n      int ans[][] =new int[lenr][lenc];\\n      for(int i=0;i<lenr;i++)\\n      {\\n          for(int j=0;j<lenc;j++)\\n          {\\n                ans[i][j]=calculate(grid,i,j);\\n          }"]}
{"id": "1732", "ref_java": ["class Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0;\\n        int n = s.length();\\n        for(int i=1; i<n; i++){\\n            if(s.charAt(i)!=s.charAt(i-1)){\\n                ans += Math.min(i,n-i);\\n            }", "class Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0;\\n        int n = s.length();\\n        for(int i=1; i<n; i++){\\n            if(s.charAt(i)!=s.charAt(i-1)){\\n                ans += Math.min(i,n-i);\\n            }", "class Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }"]}
{"id": "1733", "ref_java": ["class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        long sum = 0;\\n        for(int i=queries.length-1; i>=0; i--) {\\n            long currSum = 0;\\n            if(queries[i][0] == 0) {\\n                int row = queries[i][1];\\n                if(rows.contains(row))\\n                    continue;\\n                rows.add(queries[i][1]);\\n                int count = n - cols.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            }", "class Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        boolean[] row = new boolean[n]; ", "class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long countRowsChanged = n;\\n        boolean[] rowsChanged = new boolean[n];\\n        long countColsChanged = n;\\n        boolean[] colsChanged = new boolean[n];\\n        long result = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] query = queries[i];\\n            int type = query[0];\\n            int index = query[1];\\n            long value =  (long) query[2];\\n            if (type == 0) {\\n                if (rowsChanged[index]) {\\n                    continue;\\n                }"]}
{"id": "1736", "ref_java": ["class Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i=0, j=0, max=0, c=0;\\n        while(j<s.length()-1){\\n            if(s.charAt(j)==s.charAt(j+1)){\\n                c++;\\n            }", "class Solution {\\n          public int longestSemiRepetitiveSubstring(String s) {\\n          int ans = 0, c = 0;\\n          Stack<Character> st = new Stack<>();\\n          for(int i = 0; i < s.length(); i++) {\\n            if(st.size() == 0) {\\n                st.push(s.charAt(i));\\n            }", "class Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i=1;    \\n        int res=0;\\n        int flag=0;    "]}
{"id": "1737", "ref_java": ["class Solution {\\n  public int sumDistance(int[] nums, String s, int d) {\\n    final int modulo = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long[] position = new long[n];\\n    for (int i = 0; i < n; i++) {\\n      position[i] = (s.charAt(i) == \\'L\\' ? -1L : 1L) * d + nums[i];\\n    }", "class Solution {\\n    long MOD = 1000000007l;\\n    public int sumDistance(int[] nums, String s, int d) {\\n        int n = nums.length;\\n        long[] positions = new long[n];\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            positions[i] = nums[i] + (s.charAt(i) == \\'R\\' ? d : -d);\\n        }", "class Solution {\\n    public int sumDistance(int[] nums, String s, int d) {\\n        final int mod = 1_000_000_007;\\n        for (int i=0; i<nums.length; i++) {\\n            nums[i] += d * (s.charAt(i) == \\'R\\' ? 1 : -1);\\n        }"]}
{"id": "1738", "ref_java": ["class Solution {\\n    public String smallestString(String s) {\\n        char[] chars = s.toCharArray();\\n        int n = chars.length;\\n        boolean replace = false;\\n        for (int i = 0; i < n; i++) {\\n            if(chars[i]==\\'a\\'){\\n                if(replace){\\n                    break;\\n                }", "class Solution {\\n    public String smallestString(String s) {\\n        boolean modified = false;\\n       char ch [] = s.toCharArray();\\n       ", "class Solution {\\n    public String smallestString(String s) {\\n        boolean modified = false;\\n       char ch [] = s.toCharArray();\\n       "]}
{"id": "1739", "ref_java": ["class Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        ", "class Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = nums[i];\\n            res += (long) nums[i];\\n        }", "class Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        "]}
{"id": "1740", "ref_java": ["class Solution {\\n  public int findValueOfPartition(int[] nums) {\\n    int n = nums.length, ans = Integer.MAX_VALUE;\\n    Arrays.sort(nums);\\n    \\n    for (var i=0; i < n-1; i++)\\n      ans = Math.min(ans, nums[i+1] - nums[i]);\\n    \\n    return ans;\\n  }", "class Solution {\\n public static int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            ans=Math.min(ans,nums[i]-nums[i-1]);\\n        }", "class Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = nums[1] - nums[0];\\n        for (int i = 2; i < nums.length; i++)\\n            res = Math.min(res, nums[i] - nums[i - 1]);\\n        return res;\\n    }"]}
{"id": "1741", "ref_java": ["class Solution {\\n    int MOD = (int)1e9 + 7;\\n    int N;\\n    Integer[][] memo;\\n    int[] nums;\\n    public int specialPerm(int[] nums) {\\n        this.N = nums.length;\\n        this.memo = new Integer[N][1 << N];\\n        this.nums = nums;\\n        return backtrack(0, 0);\\n    }", "class Solution {\\n    int MOD = 1000000007;\\n    int endMask;\\n    int[] nums;\\n    Integer[][] dp;\\n    private int solve(int mask, int last) {\\n        if(mask == endMask) {\\n            return 1;\\n        }", "class Solution {\\n    int len;\\n    HashMap<String,Long> dp;\\n    \\n    public int specialPerm(int[] nums) {\\n        len = nums.length;\\n        dp = new HashMap<>();\\n        return (int)helper(nums,0,-1,new boolean[len],0);\\n    }"]}
{"id": "1742", "ref_java": ["class Solution {\\n    public int longestString(int x, int y, int z) {\\n     if(x == y) return (x + y + z) * 2;\\n     else return (Math.min(x, y) + Math.min(x, y) + 1 + z) * 2;\\n    }", "class Solution {\\n    public int longestString(int x, int y, int z) {\\n     if(x == y) return (x + y + z) * 2;\\n     else return (Math.min(x, y) + Math.min(x, y) + 1 + z) * 2;\\n    }", "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min=Math.min(x,y);\\n        return x==y?(2*min+z)*2 : (2*min+1+z)*2;\\n    }"]}
{"id": "1743", "ref_java": ["class Solution {\\n\\n    public int minimizeConcatenatedLength(String[] words) {\\n        int n = words.length;\\n        int[][][] dp = new int[n][26][26];\\n\\n        for (int i = 0; i < n-1; i++) {\\n            String word = words[i];\\n            int size = word.length();\\n            int first = word.charAt(0) - \\'a\\';\\n            int last = word.charAt(size-1) - \\'a\\';\\n\\n            for (int s = 0; s < 26; s++) {\\n                for (int e = 0; e < 26; e++) {\\n                    dp[i][s][e] = Integer.MAX_VALUE;\\n                }", "class Solution {\\n    Integer[][][] dp;\\n    private int solve(int i, int n, int ps, int pe, String[] words){\\n        ", "class Solution {\\n    Integer[][][] dp;\\n    public int minimizeConcatenatedLength(String[] words) {\\n        dp= new Integer[words.length + 1][27][27];\\n        return words[0].length() + helper(1 , words[0].charAt(0) , words[0].charAt(words[0].length() - 1) , words);\\n    }"]}
{"id": "1744", "ref_java": ["class Solution {\\n\\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\\n        int m = queries.length;\\n        int[] counts = new int[n + 1], output = new int[m];\\n        TreeMap<Integer, ArrayList<Integer>> map = new TreeMap<>();\\n        Arrays.sort(logs, Comparator.comparingInt(log -> log[1]));\\n        for (int i = 0; i < m; i++) {\\n            map.putIfAbsent(queries[i], new ArrayList<>());\\n            map.get(queries[i]).add(i);\\n        }", "class Solution {\\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\\n        ", "class Solution {\\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\\n        Arrays.sort(logs, (l1,l2)->(l1[1]-l2[1]));\\n        int[][] queriesWithSequence = new int[queries.length][2];\\n        for(int i = 0; i < queries.length; i++){\\n            queriesWithSequence[i][0] = queries[i];\\n            queriesWithSequence[i][1] = i;\\n        }"]}
{"id": "1745", "ref_java": ["class Solution {\\n    public int makeTheIntegerZero(int num1, int n2) {\\n        long n1 = num1;\\n        for (int x = 1; x < 64; x++) {\\n            n1 -= n2;\\n            ", "class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }", "class Solution {\\n    public int countBits(long num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }"]}
{"id": "1746", "ref_java": ["class Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1) indexes.add(i);\\n        }", "class Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n       List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) list.add(i);\\n        }", "class Solution {\\n    int mod=(int)1e9+7;\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        int n=nums.length;\\n        int dp[][]=new int[n][2];\\n        for(int rows[]:dp)\\n            Arrays.fill(rows,-1);\\n        return findWays(0,0,nums,dp);\\n    }"]}
{"id": "1747", "ref_java": ["class Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n            List<List<Integer>> ans=new ArrayList<>();\\n            boolean[]primes=sieveOfEratosthenes(n);\\n            int[]vis=new int[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n                if((n-i)<=n && (n-i)>0 && primes[i] && primes[n-i] && vis[i]!=1 && vis[n-i]!=1)\\n                {\\n                        ans.add(new ArrayList<>(Arrays.asList(i,n-i)));\\n                        vis[i]=1;\\n                        vis[n-i]=1;\\n                }", "class Solution {\\n    public List<List<Integer>> findPrimePairs(int n) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        if(n<=2)\\n        {\\n            return nm;\\n        }", "class Solution {\\n    \\n    static boolean[] sieve=new boolean[1000001];\\n\\n    "]}
{"id": "1748", "ref_java": ["class Solution {\\n    public long continuousSubarrays(int[] nums) {\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        int i=0,j=0;\\n        long ans=0;\\n        while(i<nums.length){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            i++;\\n        while(Math.abs(map.firstEntry().getKey()-map.lastEntry().getKey())>2){\\n            map.put(nums[j],map.getOrDefault(nums[j],0)-1);\\n            if(map.get(nums[j])==0){\\n                map.remove(nums[j]);\\n            }", "class Solution {\\n    public long continuousSubarrays(int[] nums) {\\n        long count = 0;\\n        int start = 0;\\n        int end = 0;\\n        \\n            \\n        PriorityQueue<Integer> minH = new PriorityQueue<>();", "class Solution {\\n    public long continuousSubarrays(int[] nums) {\\n        ArrayDeque<Integer> maxDeque, minDeque;\\n        maxDeque = new ArrayDeque<>();\\n        minDeque = new ArrayDeque<>();\\n        long res = 0;\\n        int l=0;\\n        int limit = 2;\\n        for(int r=0; r<nums.length; r++) {\\n            while(!maxDeque.isEmpty() && maxDeque.peekLast() < nums[r]) {\\n                maxDeque.removeLast();\\n            }"]}
{"id": "1749", "ref_java": ["class Solution {\\n    public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\\n        Map<Integer, Integer> map = new HashMap<>(); ", "class Solution {\\n    public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            set.add(n);\\n        }", "class Solution {\\n       public static List<Integer> relocateMarbles(int[] arr, int[] moveFrom, int[] moveTo) {\\nSet<Integer> op = new HashSet<>();\\n        for (int el : arr) {\\n            op.add(el);\\n        }"]}
{"id": "1750", "ref_java": ["class Solution {\\n    public boolean isFive(int num) {\\n        while (num > 1) {\\n            if (num % 5 != 0) {\\n                return false;\\n            }", "class Solution {\\n    public int minimumBeautifulSubstrings(String s) {\\n        Integer[] minBuilds = new Integer[s.length()];\\n        return findMinBeauty(0, s.toCharArray(), minBuilds);\\n    }", "class Solution {\\n    public int minimumBeautifulSubstrings(String s) {\\n        Integer[] minBuilds = new Integer[s.length()];\\n        return findMinBeauty(0, s.toCharArray(), minBuilds);\\n    }"]}
{"id": "1751", "ref_java": ["class Solution {\\n    public long[] countBlackBlocks(int m, int n, int[][] coordinates) {\\n        Map<Long, Integer> countMap = new HashMap<>(); ", "class Solution {\\n    public long[] countBlackBlocks(int m, int n, int[][] coordinates) {\\n        ", "class Solution {\\n    public long[] countBlackBlocks(int m, int n, int[][] coordinates) {\\n        "]}
{"id": "1752", "ref_java": ["class Solution {\\n    class Pair {\\n        int prev;\\n        int len;\\n\\n        public Pair(int prev, int len) {\\n            this.prev = prev;\\n            this.len = len;\\n        }", "class Solution {\\n    int memo[];\\n    private int help(int nums[], int i, int target){\\n        if(i==nums.length-1) return 0;\\n        else if(memo[i]!=0) return memo[i];\\n        int min_val=-1;\\n        for(int j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=target){\\n                int v=help(nums, j, target);\\n                if(v>=0) v+=1;\\n                min_val=Math.max(v, min_val);\\n            }", "class Solution {\\n    public int maximumJumps(int[] nums, int target) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -2);\\n        return rec(nums,n,0,target,dp);\\n    }"]}
{"id": "1753", "ref_java": ["class Solution {\\n    private Integer[][] dp;\\n    \\n    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        dp = new Integer[n][3];\\n        return solve(0, 0, n, nums1, nums2);\\n    }", "class Solution {\\n    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[][] dp = new int[n][2];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        int maxLen = 1;\\n        for(int i=1;i<n;i++){\\n            dp[i][0] = 1;\\n            dp[i][1] = 1;\\n            if (nums1[i] >= nums1[i - 1])\\n                dp[i][0] = dp[i - 1][0] + 1;\\n            if (nums1[i] >= nums2[i - 1])\\n                dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] + 1);\\n        }", "class Solution {\\n    private Integer[][] dp;\\n    \\n    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        dp = new Integer[n][3];\\n        return solve(0, 0, n, nums1, nums2);\\n    }"]}
{"id": "1754", "ref_java": ["class Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(i>n-k && nums[i]!=0){\\n                return false;\\n            }", "class Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int s = 0;\\n        int j = 0;\\n        Deque<Pair<Integer, Integer>> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; ++i) {\\n            while (!q.isEmpty() && i - q.peekFirst().getKey() >= k) {\\n                s -= q.peekFirst().getValue();\\n                q.pollFirst();\\n            }", "class Solution {\\n    public boolean checkArray(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(i>n-k && nums[i]!=0){\\n                return false;\\n            }"]}
{"id": "1755", "ref_java": ["class Solution {\\n    public int maximumBeauty(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            arr[i][0] = nums[i] - k;\\n            arr[i][1] = nums[i] + k;\\n        }", "class Solution {\\n    public int maximumBeauty(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            arr[i][0] = nums[i] - k;\\n            arr[i][1] = nums[i] + k;\\n        }", "class Solution {\\n    public int maximumBeauty(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            arr[i][0] = nums[i] - k;\\n            arr[i][1] = nums[i] + k;\\n        }"]}
{"id": "1756", "ref_java": ["class Solution {\\n    public int minimumIndex(List<Integer> nums) {\\n        int n = nums.size(), dom = -1;\\n        Map<Integer, Integer> map = new HashMap<>(); ", "class Solution {\\n    public int minimumIndex(List<Integer> nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:nums) map.put(i,map.getOrDefault(i,0)+1);\\n        \\n        Map<Integer,Integer> map1=new HashMap<>();\\n        int n=nums.size(),ans=-1;\\n      \\n        for(int i=0;i<n;i++){\\n            int num=nums.get(i);\\n            if(map.get(num)==1)continue;\\n            map1.put(num,map1.getOrDefault(num,0)+1);\\n            map.put(num,map.get(num)-1);\\n            int left=map1.get(num),right=map.get(num);\\n            if((left*2>(i+1)) && (right*2 >(n-i-1))){\\n                ans=i;\\n                break;\\n            }", "class Solution {\\n  public int minimumIndex(List<Integer> nums) {\\n    var map = new HashMap<Integer, Integer>();\\n    map.put(0, 0);\\n    int max = 0, m = nums.size();\\n    \\n    for (var n : nums) {\\n      map.put(n, map.getOrDefault(n, 0) + 1);\\n      \\n      if (map.get(n) > map.get(max))\\n        max = n;\\n    }"]}
{"id": "1757", "ref_java": ["class Solution {\\nprivate:\\n    ", "class Solution {\\n    private boolean isVowel(char c){\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || \\nc == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }", "class Solution {\\nprivate:\\n    "]}
{"id": "1758", "ref_java": ["class Solution {\\n    public long solve(int i,int[] nums, int x, int prev, long[][] dp){\\n        if(i+1 == nums.length){\\n            return 0;\\n        }", "class Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        ", "class Solution {\\n    private int getEvenOdd(int num) {\\n        return num % 2 == 0 ? 1 : 0;\\n    }"]}
{"id": "1759", "ref_java": ["class Solution {\\n\\n    public static int mod = 1000000007;\\n\\n    public static int solve(int[][] dp , ArrayList<Integer> arr , int n , int i)\\n    {\\n        if(n == 0)\\n            return 1;\\n        if(i == arr.size())\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int take = 0;\\n        if(arr.get(i) <= n)\\n            take = solve(dp , arr , n-arr.get(i) , i+1) % mod;\\n        int not_take = solve(dp , arr , n , i+1) % mod;\\n        dp[i][n] = (take+not_take) % mod;\\n        return dp[i][n];\\n    }", "class Solution {\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfWays(int n, int x) {\\n        int maxNum = (int) Math.pow(n, 1.0 / x) + 1;\\n        int[][] dp = new int[maxNum + 1][n + 1];\\n\\n        for (int i = 0; i <= maxNum; i++) {\\n            dp[i][0] = 1;\\n        }", "class Solution {\\n    private static final int MOD = 1000000007;\\n\\n    public int numberOfWays(int n, int x) {\\n        int maxNum = (int) Math.pow(n, 1.0 / x) + 1;\\n        int[][] dp = new int[maxNum + 1][n + 1];\\n\\n        for (int i = 0; i <= maxNum; i++) {\\n            dp[i][0] = 1;\\n        }"]}
{"id": "1760", "ref_java": ["class Solution {\\n    public long maxArrayValue(List<Integer> nums) {\\n        List<Long> a = new ArrayList<>(); ", "class Solution {\\n    public long maxArrayValue(int[] nums) {\\n        int len = nums.length;\\n        long sum = nums[len - 1];\\n        for(int i = len - 2; i >= 0; i--){\\n            int val1 = nums[i];\\n            if(val1 <= sum){\\n                sum = val1 + sum;\\n            }", "class Solution {\\n    public long maxArrayValue(int[] nums) {\\n        int n = nums.length;\\n        long[] nums2 = new long[n];\\n        long res = 0;\\n        for (int i = 0; i < n; i ++) {\\n            nums2[i] = (long)nums[i];\\n            res = Math.max(res, nums2[i]);\\n            \\n        }"]}
{"id": "1761", "ref_java": ["class Solution {\\n    public int countCompleteSubarrays(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) set.add(num);\\n        ", "class Solution {\\n    public int countCompleteSubarrays(int[] nums) {\\n                int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num:nums){\\n            set.add(num);\\n        }", "class Solution {\\n    public int countCompleteSubarrays(int[] nums) {\\n        Set<Integer> nm=new HashSet<>();\\n        for(int i:nums)\\n        {\\n            nm.add(i);\\n        }"]}
{"id": "1762", "ref_java": ["class Solution {\\n\\n\\tpublic String minimumString(String a, String b, String c) {\\n\\t\\treturn minStr(\"\", 0, 0, List.of(a, b, c));\\n\\t}", "class Solution {\\n    public String minimumString(String a, String b, String c) {\\n        String[] arr = {merge(merge(a,b),c),merge(merge(b,a),c),merge(merge(a,c),b),merge(merge(c,a),b),merge(merge(b,c),a),merge(merge(c,b),a)}", "class Solution {\\n\\t\\tpublic String minimumString(String a, String b, String c) {\\n\\t\\t\\tList<String> list = new ArrayList<>();\\n\\t\\t\\tlist.add(mininumStringV2(a,b,c));\\n\\t\\t\\tlist.add(mininumStringV2(a,c,b));\\n\\t\\t\\tlist.add(mininumStringV2(b,a,c));\\n\\t\\t\\tlist.add(mininumStringV2(b,c,a));\\n\\t\\t\\tlist.add(mininumStringV2(c,a,b));\\n\\t\\t\\tlist.add(mininumStringV2(c,b,a));\\n\\t\\t\\tCollections.sort(list,(e1,e2)->{\\n\\t\\t\\t\\tif(e1.length()!=e2.length()){\\n\\t\\t\\t\\t\\treturn e1.length()-e2.length();\\n\\t\\t\\t\\t}"]}
{"id": "1763", "ref_java": ["class Solution {\\n    public ListNode insertGreatestCommonDivisors(ListNode head) {\\n        if(head==null || head.next==null){\\n            return head;\\n        }", "class Solution {\\n    public ListNode insertGreatestCommonDivisors(ListNode head) {\\n        if(head.next == null) return head;\\n        ListNode node = head;\\n        \\n        while(node.next != null) {\\n            int value = gcd(node.val, node.next.val);\\n            ListNode nn = new ListNode(value);\\n            \\n            ListNode temp = node.next;\\n            node.next = nn;\\n            nn.next = temp;\\n            \\n            node = node.next.next;\\n        }", "class Solution {\\n    public ListNode insertGreatestCommonDivisors(ListNode head) {\\n        ListNode prevNode = null;\\n        ListNode currNode = head;\\n\\n        while(currNode != null) {\\n            if(prevNode != null && currNode != null) {\\n                int gcd = greatestCommonDivisor(prevNode.val, currNode.val);\\n                ListNode newNode = new ListNode(gcd, currNode);\\n                prevNode.next = newNode;\\n            }"]}
{"id": "1764", "ref_java": ["class Solution {\\n    public int minimumSeconds(List<Integer> nums) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        HashMap<Integer, Integer> dist = new HashMap();\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 2 * n; i++) {\\n            int curr = nums.get(i % n);\\n            \\n            if(map.containsKey(curr) && map.get(curr) != i) {\\n                int maxDist = i - map.get(curr);\\n                if(map.get(curr) > i) maxDist = n + map.get(curr) - i;\\n\\n                ", "class Solution {\\n\\n    private int n;\\n\\n    public int minimumSeconds(List<Integer> nums) {\\n        n = nums.size();\\n        Map<Integer, List<Integer>> positions = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer v = nums.get(i);\\n            positions.computeIfAbsent(v, _k -> new ArrayList<>()).add(i);\\n        }", "class Solution {\\n    public int minimumSeconds(List<Integer> nums) {\\n        int dist = (int)1e8, n = nums.size();\\n        Map<Integer, List<Integer>> mp = new HashMap<>();\\n        \\n        "]}
{"id": "1765", "ref_java": ["class Solution {\\n    public boolean canSplitArray(List<Integer> nums, int m) {\\n        int[][] dp = new int[nums.size()][nums.size()];\\n        for(int[] arr : dp) Arrays.fill(arr, -1);\\n        \\n        int totalSum = 0;\\n        for(int i = 0; i < nums.size(); i++) totalSum += nums.get(i);\\n        \\n        return helper(nums, 0, nums.size() - 1, m, totalSum, dp);\\n    }", "class Solution {\\n    public boolean canSplitArray(List<Integer> nums, int m) {\\n        if (nums.size() < 3)\\n            return true;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums.get(i) + nums.get(i - 1) >= m) {\\n                return true;\\n            }", "class Solution {\\n    public boolean canSplitArray(List<Integer> nums, int m) {\\n        int[][] dp = new int[nums.size()][nums.size()];\\n        for(int[] arr : dp) Arrays.fill(arr, -1);\\n        \\n        int totalSum = 0;\\n        for(int i = 0; i < nums.size(); i++) totalSum += nums.get(i);\\n        \\n        return helper(nums, 0, nums.size() - 1, m, totalSum, dp);\\n    }"]}
{"id": "1766", "ref_java": ["class Solution {\\n    int n, dir[]={-1, 0, 1, 0, -1}", "class Solution {\\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\\n        int[][] distToThief = getDistToThief(grid);\\n        int l = 0;\\n        int r = grid.size() * 2;\\n\\n        while (l < r) {\\n            final int m = (l + r) / 2;\\n            if (hasValidPath(distToThief, m))\\n                l = m + 1;\\n            else\\n                r = m;\\n        }", "class Solution {\\n    int[][] path ; \\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\\n        int n = grid.size() ; \\n        int[][] dp = new int[n][n] ; \\n        path = new int[n][n] ; \\n        "]}
{"id": "1767", "ref_java": ["class Solution {\\n    public ListNode doubleIt(ListNode head) {\\n        \\n        ", "class Solution {\\n    public ListNode doubleIt(ListNode head) {\\n        ListNode prev=null, curr=head, next=null;\\n        ", "class Solution {\\n\\n    static ListNode reverse(ListNode head){\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode after = null;\\n\\n        while(curr!=null){\\n            after = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = after;\\n        }"]}
{"id": "1768", "ref_java": ["class Solution {\\n\\t\\tpublic int minAbsoluteDifference(List<Integer> nums, int x) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tTreeSet<Integer> ts = new TreeSet<>();\\n\\t\\t\\tfor(int i=x;i<nums.size();i++){\\n\\t\\t\\t\\tts.add(nums.get(i-x));\\n\\t\\t\\t\\tInteger ceiling = ts.ceiling(nums.get(i));\\n\\t\\t\\t\\tif(ceiling!=null)\\n\\t\\t\\t\\t\\tmin = Math.min(min,Math.abs(nums.get(i)-ceiling));\\n\\t\\t\\t\\tInteger floor = ts.floor(nums.get(i));\\n\\t\\t\\t\\tif(floor!=null)\\n\\t\\t\\t\\t\\tmin = Math.min(min,Math.abs(nums.get(i)-floor));\\n\\t\\t\\t}", "class Solution {\\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\\n        if(x == 0) return 0;\\n        \\n        TreeSet<Integer> set = new TreeSet<>();\\n        int diff = Integer.MAX_VALUE;\\n        for(int i = x; i < nums.size(); i++) {\\n            set.add(nums.get(i - x));\\n            \\n            Integer low = set.lower(nums.get(i) + 1);\\n            if(low != null) {\\n                diff = Math.min(diff, nums.get(i) - low);\\n                if(diff == 0) break;\\n            }", "class Solution {\\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\\n        if(x == 0) return 0;\\n        \\n        TreeSet<Integer> set = new TreeSet<>();\\n        int diff = Integer.MAX_VALUE;\\n        for(int i = x; i < nums.size(); i++) {\\n            set.add(nums.get(i - x));\\n            \\n            Integer low = set.lower(nums.get(i) + 1);\\n            if(low != null) {\\n                diff = Math.min(diff, nums.get(i) - low);\\n                if(diff == 0) break;\\n            }"]}
{"id": "1769", "ref_java": ["class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        ", "class Solution {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length;\\n        int [] res = new int[n+m];\\n        int i=0, j=0, k=0;\\n        while(i<m && j<n){\\n            if(nums1[i]<nums2[j]) res[k++] = nums1[i++];\\n            else res[k++] = nums2[j++];\\n        }", "class Solution {\\n\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n        \\n        int totalElements = nums1.length + nums2.length;\\n        int medianThreashold = (totalElements) / 2 + 1;\\n\\n        int idx1 = 0;\\n        int idx2 = 0;\\n\\n        int prevNumInOrder = 0;\\n        int nextNumInOrder = 0;\\n\\n        int i = 0;\\n\\n            while (i++ < medianThreashold) {\\n\\n                int currentNum1 = idx1 >= nums1.length ? Integer.MAX_VALUE : nums1[idx1];\\n                int currentNum2 = idx2 >= nums2.length ? Integer.MAX_VALUE : nums2[idx2];\\n                prevNumInOrder = nextNumInOrder;\\n\\n                if (currentNum1 > currentNum2)\\n                    nextNumInOrder = nums2[idx2++];\\n\\n                else nextNumInOrder = nums1[idx1++];\\n            }"]}
{"id": "1770", "ref_java": ["class Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }", "class Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }", "class Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }"]}
{"id": "1771", "ref_java": ["class Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }", "class Solution {\\n\\n    ListNode merge2Lists(ListNode l1, ListNode l2) {\\n        if(l1 == null)\\n            return l2;\\n        if(l2 == null)\\n            return l1;\\n        ListNode sentinel = new ListNode(-1), ptr = sentinel;\\n        while(l1 != null && l2 != null) {\\n            if(l1.val <= l2.val) {\\n                ptr.next = l1;\\n                l1 = l1.next;\\n            }", "class Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> p=new PriorityQueue<>((a,b)->a.val-b.val);\\n      for(int i=0;i<lists.length;i++)\\n    {  \\n        ListNode x=lists[i];\\n        while(x!=null){\\n            p.add(x);\\n            x=x.next;\\n        }"]}
{"id": "1772", "ref_java": ["class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n\\n    ListNode pre = dummy, cur = dummy, nex = dummy;\\n    int count = 0;\\n\\n    while(cur.next != null){\\n        count++;\\n        cur = cur.next;\\n    }", "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n\\n    ListNode pre = dummy, cur = dummy, nex = dummy;\\n    int count = 0;\\n\\n    while(cur.next != null){\\n        count++;\\n        cur = cur.next;\\n    }", "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n\\n    ListNode pre = dummy, cur = dummy, nex = dummy;\\n    int count = 0;\\n\\n    while(cur.next != null){\\n        count++;\\n        cur = cur.next;\\n    }"]}
{"id": "1773", "ref_java": ["class Solution {\\n    public boolean isValid(String s,String[] words){\\n        int l=words[0].length();\\n        HashMap<String, Integer> count=new HashMap<>();\\n        for (String word : words) {\\n            count.put(word,count.getOrDefault(word, 0) + 1);\\n        }", "class Solution {\\n    long M = (long) 1e9 + 7;\\n\\tlong M1 = 37;\\n\\tlong[] sh;\\n\\tlong[] P;\\n\\tlong[] MI;\\n\\tMap<Long, Integer> whs = new HashMap<>();\\n\\n\\tpublic List<Integer> findSubstring(String s, String[] words) {\\n\\t\\tint ws = words[0].length();\\n\\t\\tint n = words.length;\\n\\t\\tsh = new long[s.length() + 1];\\n\\t\\tP = new long[s.length() + 1];\\n\\t\\tMI = new long[s.length() + 1];\\n\\t\\tP[0] = 1;\\n        MI[0]=1;\\n\\t\\tchar[] cs = s.toCharArray();\\n\\t\\tint i = 1;\\n\\n\\t\\tlong sum = 0;\\n\\t\\tfor (char c : cs) {\\n\\t\\t\\tsum += P[i - 1] * c;\\n\\t\\t\\tsum %= M;\\n\\t\\t\\tsh[i] = sum;\\n\\t\\t\\tP[i] = P[i - 1] * M1 % M;\\n\\t\\t\\tMI[i] = miv(P[i]);\\n\\t\\t\\ti++;\\n\\t\\t}", "class Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for (final String word : words) {\\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\\n        }"]}
{"id": "1774", "ref_java": ["class Solution {\\n    public int longestValidParentheses(String s) {\\n    int leftCount = 0;\\n    int rightCount = 0;\\n    int maxLength = 0;\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        }", "class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        st.push(-1);\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                st.push(i);\\n            }", "class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max =0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }"]}
{"id": "1775", "ref_java": ["class Solution {\\n    private int[][] result = new int[9][9];\\n    private boolean[][] modifiable = new boolean[9][9];\\n\\n    public void solveSudoku(char[][] board) {\\n        markModifiable(board);\\n        recurse(0);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                board[i][j] = Integer.toString(result[i][j]).charAt(0);\\n            }", "class Solution {\\n    public void solveSudoku(char[][] board) {\\n        ", "class Solution {\\n    public void solveSudoku(char[][] board) {\\n        sodoku(board);\\n    }"]}
{"id": "1776", "ref_java": ["class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        ", "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n      Arrays.sort(nums);\\n       nums = Arrays.stream(nums).filter(n->n>0).distinct().toArray();\\n       if(nums.length == 0 || nums[0]!=1){\\n           return 1;\\n       }", "class Solution {\\n    public int firstMissingPositive(int[] array) {\\n        int n = array.length;\\n\\n        "]}
{"id": "1777", "ref_java": ["class Solution {\\n    public int trap(int[] h) {\\n        int l = 0, r = h.length - 1, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE, ans = 0;\\n        while (l < r) {\\n        lmax = Math.max(lmax, h[l]);\\n        rmax = Math.max(rmax, h[r]);\\n        ans += (lmax < rmax) ? lmax - h[l++] : rmax - h[r--];\\n        }", "class Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int leftMax = height[0], rightMax = height[height.length - 1];\\n        int water = 0;\\n        while (left < right) {\\n            if (leftMax < rightMax) {\\n                left++;\\n                if (leftMax < height[left]) {\\n                    leftMax = height[left];\\n                }", "class Solution {\\n   public static int trap(int[] height) {\\n        int count = 0;\\n        for (int i = 0; i < height.length - 1; i++) {\\n            int th = height[i];\\n            int nh = height[i + 1];\\n            if (nh >= th) {\\n                continue;\\n            }"]}
{"id": "1778", "ref_java": ["class Solution {\\n    public boolean isMatch(String s, String p) {\\n        dp = new int[s.length()][p.length()];\\n        return helper(s, p, 0, 0);\\n    }", "class Solution {\\n    public boolean isMatch(String s, String p) {\\n        return solve(s,p,0,0,new Boolean[s.length()][p.length()]);\\n    }", "class Solution {\\n    public boolean isMatch(String s, String p) {\\n        int dp[][]=new int[s.length()][p.length()];\\n        for(int ar[]:dp)\\n         Arrays.fill(ar,-1);\\n        return match(s.length()-1,p.length()-1,s,p,dp)==0?false:true;\\n    }"]}
{"id": "1779", "ref_java": ["class Solution {\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> Res = new ArrayList <>();\\n        char[][] board = new char[n][n];\\n        for(char[] row : board) Arrays.fill(row, \\'.\\');\\n\\n        Queens(0, board, Res);\\n        return Res;\\n    }", "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        char [][] board = new char[n][n];\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                board[i][j] = \\'.\\';\\n            }", "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n        solve(board, 0, solutions);\\n        return solutions;\\n        \\n    }"]}
{"id": "1780", "ref_java": ["class Solution {\\n    public int totalNQueens(int num) {\\n    int[] memo = new int[num];\\n    int count = 0 ;\\n    for(int i=0;i<num;i++) {\\n      memo[0] = i;\\n      count = count + dfs(0, i, memo,num);\\n    }", "class Solution {\\n    public int totalNQueens(int num) {\\n    int[] memo = new int[num];\\n    int count = 0 ;\\n    for(int i=0;i<num;i++) {\\n      memo[0] = i;\\n      count = count + dfs(0, i, memo,num);\\n    }", "class Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }"]}
{"id": "1781", "ref_java": ["class Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact[]=new int[n+1];\\n        fact[0]=1;\\n        for(int i=1; i<n;i++) fact[i]=fact[i-1]*i;\\n        String nums=\"123456789\".substring(0,n);\\n        char[] perm=new char[n];\\n\\n        for(int i=n, j=0; i>0;i--, j++) {\\n            int p=(k-1)/fact[i-1];\\n            perm[j]=nums.charAt(p);\\n            nums=nums.substring(0, p)+nums.substring(p+1);\\n            k=k-p*fact[i-1];\\n        }", "class Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }", "class Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}"]}
{"id": "1782", "ref_java": ["class Solution {\\n    public boolean isNumber(String s) {\\n        try{\\n            Double.valueOf(s);\\n            return Character.isDigit(s.charAt(s.length() - 1)) || s.charAt(s.length() - 1) == \\'.\\';\\n        }", "class Solution {\\n    public boolean isNumber(String s) {\\n        try{\\n            Double.valueOf(s);\\n            return Character.isDigit(s.charAt(s.length() - 1)) || s.charAt(s.length() - 1) == \\'.\\';\\n        }", "class Solution {\\n    public boolean isNumber(String s) {\\n    s=s.toLowerCase();\\n     Pattern p=Pattern.compile(\"[+-]?((\\\\\\\\d+)|((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)))(e[+-]?\\\\\\\\d+)?\");\\n     Matcher m=p.matcher(s);\\n     boolean b=m.matches();\\n     if(b)\\n        {\\n            return true;\\n        }"]}
{"id": "1783", "ref_java": ["class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }", "class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int N = words.length;\\n        int idx = 0;\\n        List<String> result = new ArrayList<>();\\n        while(idx < N) {\\n            List<String> wordsInLine = getWordsForLine(idx, words, maxWidth, N);\\n            idx+=wordsInLine.size();\\n            String justifiedLine = justifyLine(wordsInLine, idx, maxWidth, N);\\n            result.add(justifiedLine);\\n        }", "class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        List<String> ans = new ArrayList<>();\\n        int start=0;\\n        while(start<n){\\n            int[] idxSum = decideLine(words, start, maxWidth, n);\\n            int end = idxSum[0];\\n            int cumSum = idxSum[1];\\n            ans.add(createLine(words, start, end, cumSum, maxWidth, n));\\n            start = end+1;\\n        }"]}
{"id": "1784", "ref_java": ["class Solution {\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null || s.length() ==0 || t.length() == 0 ||\\n                s.length() < t.length()) {\\n            return new String();\\n        }", "class Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        int[] map= new int[128];\\n        int begin=0,end=0, counter=t.length(),d= Integer.MAX_VALUE,head=0;\\n\\n        for(char c: t.toCharArray()) \\n            map[c]++;\\n\\n        char[] ch = s.toCharArray();\\n        while(end<s.length())\\n        {\\n            if(map[ch[end++]]-->0) counter--;\\n\\n            while(counter==0)\\n            {\\n                if((end-begin)<d) d= end-(head=begin);\\n                if(map[ch[begin++]]++==0) counter++;\\n            }", "class Solution {\\n    static String ans=\"\";\\n    \\n    public boolean compare(int a[],int b[]) {\\n        int p1=0,p2=0;\\n        while(p1<52 && p2<52){\\n            if(a[p1]<b[p2]) return false;\\n            else{\\n                p1++;\\n                p2++;\\n            }"]}
{"id": "1785", "ref_java": ["class Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Stack<Integer> s=new Stack<>();\\n        int nsl[]=new int[heights.length];\\n        int nsr[]=new int[heights.length];\\n        ", "class Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n        if(n == 0) return 0; ", "class Solution {\\n    public int largestRectangleArea(int[] heights) {\\n        Stack<Integer> s=new Stack<>();\\n        int nsl[]=new int[heights.length];\\n        int nsr[]=new int[heights.length];\\n        "]}
{"id": "1786", "ref_java": ["class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n\\n        int max = 0;\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int arr[] = new int[n];\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(matrix[i][j] == \\'0\\'){\\n                    arr[j] = 0;\\n                }", "class Solution {\\n    public int maximalRectangle(char[][] m) {\\n        int h[][]=new int[m.length+1][m[0].length+1];\\n        int b[][]=new int[m.length+1][m[0].length+1];\\n        int res[][]=new int[m.length][m[0].length];\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                else{\\n                    h[i+1][j+1]=h[i][j+1]+1;\\n                    b[i+1][j+1]=b[i+1][j]+1;\\n                    maxi=Math.max(maxi,Math.max(h[i+1][j+1],b[i+1][j+1]));\\n                }", "class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n\\n        int max = 0;\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int arr[] = new int[n];\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(matrix[i][j] == \\'0\\'){\\n                    arr[j] = 0;\\n                }"]}
{"id": "1787", "ref_java": ["class Solution {\\n\\n    static HashMap<String,Boolean> hp;\\n\\n    static boolean helper(String s1, String s2){\\n        if(s1.equals(s2)) return true;\\n\\n        String key = s1+\" \"+s2;\\n\\n        if(hp.containsKey(key)) return hp.get(key);\\n\\n        int n = s1.length();\\n        int count[] = new int[26];\\n        for(int i=0; i<n; i++){\\n            count[s1.charAt(i)-\\'a\\']++;\\n            count[s2.charAt(i)-\\'a\\']--;\\n        }", "class Solution {\\n    private final Map<String, Boolean> cache = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        ", "class Solution {\\n    static Map<String,Boolean> memo;"]}
{"id": "1788", "ref_java": ["class Solution {\\n    public int recursiveWithoutMemoization(String s, String t, int s_ind, int t_ind) {\\n        if (t_ind == t.length()) {\\n            return 1;\\n        }", "class Solution {\\n    public int recursiveWithoutMemoization(String s, String t, int s_ind, int t_ind) {\\n        if (t_ind == t.length()) {\\n            return 1;\\n        }", "class Solution {\\n\\n    "]}
{"id": "1789", "ref_java": ["class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice1 = Integer. MAX_VALUE, minPrice2 = Integer. MAX_VALUE;\\n        int profit1 = 0, profit2 = 0;\\n\\n        for (int currPrice : prices) {\\n            minPrice1 = Math.min(currPrice, minPrice1);\\n            profit1 = Math.max(profit1, currPrice - minPrice1);\\n\\n            minPrice2 = Math.min(minPrice2, currPrice - profit1);\\n            profit2 = Math.max(profit2, currPrice - minPrice2);\\n\\n        }", "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length, pass[] = new int[n], buy=Integer.MAX_VALUE, sell=0, prof=0, i;\\n        ", "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice1 = Integer. MAX_VALUE, minPrice2 = Integer. MAX_VALUE;\\n        int profit1 = 0, profit2 = 0;\\n\\n        for (int currPrice : prices) {\\n            minPrice1 = Math.min(currPrice, minPrice1);\\n            profit1 = Math.max(profit1, currPrice - minPrice1);\\n\\n            minPrice2 = Math.min(minPrice2, currPrice - profit1);\\n            profit2 = Math.max(profit2, currPrice - minPrice2);\\n\\n        }"]}
{"id": "1790", "ref_java": ["class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxi = {Integer.MIN_VALUE}", "class Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }", "class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; "]}
{"id": "1791", "ref_java": ["class Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> ans = new ArrayList<>(); \\n        Map<String, Set<String>> reverse = new HashMap<>(); ", "class Solution {\\n    Set<String> set = new HashSet();\\n    String beginWord, endWord;\\n    Map<String, Integer> dist = new HashMap();\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        this.res = new ArrayList();\\n        for (String word : wordList) {\\n            set.add(word);\\n        }", "class Solution {\\n    \\n    ArrayList<ArrayList<Integer>> adj =  new ArrayList<>();\\n    List<List<Integer>> paths = new ArrayList<>();\\n    ArrayList<ArrayList<Integer>> parent = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int w = wordList.size();\\n        int i, j;\\n        \\n        for(i=0;i<w+1;i++){\\n            adj.add(new ArrayList<>());\\n        }"]}
{"id": "1792", "ref_java": ["class Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        ", "class Solution {\\n\\n    class QueueElement {\\n        String word;\\n        int level;\\n        QueueElement(String word, QueueElement prev) {\\n            this.word = word;\\n            this.level = prev.level+1;\\n        }", "class Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> set = new HashSet<>();\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n        for(String word : wordList){\\n            set.add(word);\\n        }"]}
{"id": "1793", "ref_java": ["class Solution {\\n    public int minCut(String s) {\\n        return minCut(s,0,s.length()-1);\\n    }", "class Solution {\\n    public int minCut(String s) {\\n        int n = s.length();\\n        boolean[][] isPalindrome = new boolean[n][n];\\n        int[] dp = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            isPalindrome[i][i] = true;\\n        }", "class Solution {\\n    public int minCut(String s) {\\n        return minCut(s,0,s.length()-1);\\n    }"]}
{"id": "1794", "ref_java": ["class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        Arrays.fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }", "class Solution {\\n    public int candy(int[] ratings) {\\n        int sz = ratings.length;\\n        int maxRat = 2 * 10000 + 1;\\n        int cand[] = new int[sz];\\n        Arrays.fill(cand, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }", "class Solution {\\n    public int candy(int[] ratings) {\\n        int[] candy = new int[ratings.length];\\n        for(int i=0;i<ratings.length;i++)\\n        {\\n            candy[i]=1;\\n        }"]}
{"id": "1795", "ref_java": ["class Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }", "class Solution {\\n    private void solveRec(String s, int idx, Set<String> wordDict, List<String> res, StringBuilder ans){\\n        ", "class Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        HashSet set = new HashSet();\\n        boolean  []dp =  new boolean[s.length()+1];\\n        dp[0] = true;\\n        for(int i =0;i < wordDict.size(); i++) {\\n            set.add(wordDict.get(i));\\n        }"]}
{"id": "1796", "ref_java": ["class Solution {\\n    public int maxPoints(int[][] points) {\\n\\n        int res=2;\\n        int n=points.length;\\n        if(n==1)return 1;\\n        ", "class Solution {\\n    public int maxPoints(int[][] p) {\\n        int n = p.length;\\n        if(n <=2) return n;\\n        int ans = 2;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                int temp = 2;\\n                for(int k=0; k<n; k++){\\n                    if(k!= i && k!= j){\\n                        int x = (p[j][1] - p[i][1] ) * (p[k][0] - p[i][0]);\\n                        int y =  ( p[k][1] - p[i][1]) * (p[j][0]-p[i][0]) ;\\n                        if(x==y){\\n                            temp++;\\n                        }", "class Solution {\\n    public int maxPoints(int[][] points) {\\n        int max = 1;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i+1; j < points.length; j++) {\\n                max = Math.max(max, countPoints(i, j, points));\\n            }"]}
{"id": "1797", "ref_java": ["class Solution {\\n    public int findMin(int[] nums) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        return findMinRec(nums,start,end);\\n    }", "class Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0, high = nums.length - 1;\\n        int mid = 0;\\n        int value = Integer.MAX_VALUE;\\n        while(low <= high) {\\n            mid = low + (high - low) / 2;\\n            value = Math.min(value, nums[mid]);\\n\\n            if (nums[low] >= nums[mid] && nums[mid] > nums[high])\\n                low = mid + 1;\\n            else if (nums[low] < nums[mid] && nums[mid] <= nums[high]) \\n                high = mid - 1;\\n            else if (nums[low] <= nums[mid] && nums[mid] > nums[high]) \\n                low = mid + 1;\\n            else {\\n                int left = mid - 1, right = mid + 1;\\n                while (left >= 0 && right < nums.length && nums[left] == nums[right]) {\\n                    left--;\\n                    right++;\\n                }", "class Solution {\\n    public int findMin(int[] nums) {\\n        return findMin(nums, 0, nums.length-1);\\n    }"]}
{"id": "1798", "ref_java": ["class Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }", "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)return 0;\\n        Arrays.sort(nums);\\n        int maxDiff = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            maxDiff = Math.max(maxDiff, nums[i+1] - nums[i]);\\n        }", "class Solution {\\n    public int maximumGap(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: nums)    pq.add(num);\\n        int max_diff = 0;\\n        while(pq.size() > 1){\\n            max_diff = Math.max(max_diff, Math.abs(pq.poll()-pq.peek()));\\n        }"]}
{"id": "1799", "ref_java": ["class Solution {\\n    public int calculateMinimumHP(int[][] dun) {\\n        int n=dun.length, m=dun[0].length, dp[][]=new int[n+1][m+1];\\n        Arrays.fill(dp[n], Integer.MAX_VALUE);\\n        dp[n][m-1]=1;\\n        for(int i=n-1;i>=0;i--) {\\n            dp[i][m]=Integer.MAX_VALUE;\\n            if(i==n-1) dp[i][m]=1;\\n            for(int j=m-1;j>=0;j--) {\\n                int val=Math.min(dp[i+1][j], dp[i][j+1])-dun[i][j];\\n                dp[i][j]=Math.max(1, val);\\n            }", "class Solution {\\n    public int calculateMinimumHP(int[][] D) {\\n        int n = D.length - 1, m = D[0].length - 1;\\n        for(int i = n - 1; i > -1; i--)\\n            if(D[i + 1][m] < 0)\\n                D[i][m] += D[i + 1][m];\\n        for(int j = m - 1; j > -1; j--)\\n            if(D[n][j + 1] < 0)\\n                D[n][j] += D[n][j + 1];\\n        for(int i = n - 1; i > -1; i--){\\n            for(int j = m - 1; j > -1; j--){\\n                if(D[i + 1][j] < 0 && D[i][j + 1] < 0)\\n                    D[i][j] += Math.max(D[i+1][j], D[i][j+1]);\\n            }", "class Solution {\\n    public int calculateMinimumHP(int[][] dun) {\\n        int n=dun.length, m=dun[0].length, dp[][]=new int[n+1][m+1];\\n        Arrays.fill(dp[n], Integer.MAX_VALUE);\\n        dp[n][m-1]=1;\\n        for(int i=n-1;i>=0;i--) {\\n            dp[i][m]=Integer.MAX_VALUE;\\n            if(i==n-1) dp[i][m]=1;\\n            for(int j=m-1;j>=0;j--) {\\n                int val=Math.min(dp[i+1][j], dp[i][j+1])-dun[i][j];\\n                dp[i][j]=Math.max(1, val);\\n            }"]}
{"id": "1801", "ref_java": ["class Solution {\\n    static int solveTab(int[] prices,int k){\\n        int n=prices.length;\\n\\n        int [][] curr = new int[2][k+2];\\n        int [][] next = new int[2][k+2];\\n\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=1;buy>=0;buy--){\\n                for(int limit=1;limit<=k;limit++){\\n                    int profit=0;\\n                    if(buy==1){\\n                        int salekaro=prices[index]+next[0][limit-1];\\n                        int skipkaro=0+next[1][limit];\\n                        profit+=Math.max(salekaro,skipkaro);\\n                    }", "class Solution {\\n\\n    public int maxPro(int[] prices, int index, int k, int buy, int dp[][][]){\\n        if(k==0 || index >= prices.length){\\n            return 0;\\n        }", "class Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        int[][] transactions = new int[k][2];\\n        for (int i = 0; i < k; i++) {\\n            transactions[i][0] = 1000;\\n            transactions[i][1] = 0;\\n        }"]}
{"id": "1802", "ref_java": ["class Solution {\\n    private final List<String> results = new LinkedList<>();\\n\\n    private WordsTrie wordsTrie;\\n    private Board board;\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        this.board = new Board(board);\\n        this.wordsTrie = new WordsTrie(words);\\n\\n        for (int x = 0; x <= this.board.lastIndexX; x++) {\\n            for (int y = 0; y <= this.board.lastIndexY; y++) {\\n                step(x, y, wordsTrie.getRoot());\\n            }", "class Solution {\\n    private final List<String> results = new LinkedList<>();\\n\\n    private WordsTrie wordsTrie;\\n    private Board board;\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        this.board = new Board(board);\\n        this.wordsTrie = new WordsTrie(words);\\n\\n        for (int x = 0; x <= this.board.lastIndexX; x++) {\\n            for (int y = 0; y <= this.board.lastIndexY; y++) {\\n                step(x, y, wordsTrie.getRoot());\\n            }", "class Solution {\\n    private final List<String> results = new LinkedList<>();\\n\\n    private WordsTrie wordsTrie;\\n    private Board board;\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        this.board = new Board(board);\\n        this.wordsTrie = new WordsTrie(words);\\n\\n        for (int x = 0; x <= this.board.lastIndexX; x++) {\\n            for (int y = 0; y <= this.board.lastIndexY; y++) {\\n                step(x, y, wordsTrie.getRoot());\\n            }"]}
{"id": "1803", "ref_java": ["\npublic String shortestPalindrome(String s) {\n    int n = s.length(), pos = -1;\n    long B = 29, MOD = 1000000007, POW = 1, hash1 = 0, hash2 = 0;\n    for (int i = 0; i < n; i++, POW = POW * B % MOD) {\n        hash1 = (hash1 * B + s.charAt(i) - 'a' + 1) % MOD;\n        hash2 = (hash2 + (s.charAt(i) - 'a' + 1) * POW) % MOD;\n        if (hash1 == hash2) pos = i;\n    }\n    return new StringBuilder().append(s.substring(pos + 1, n)).reverse().append(s).toString();\n}\n", "\npublic String shortestPalindrome(String s) {\n    int n = s.length(), pos = -1;\n    long B = 29, MOD = 1000000007, POW = 1, hash1 = 0, hash2 = 0;\n    for (int i = 0; i < n; i++, POW = POW * B % MOD) {\n        hash1 = (hash1 * B + s.charAt(i) - 'a' + 1) % MOD;\n        hash2 = (hash2 + (s.charAt(i) - 'a' + 1) * POW) % MOD;\n        if (hash1 == hash2) pos = i;\n    }\n    return new StringBuilder().append(s.substring(pos + 1, n)).reverse().append(s).toString();\n}\n", "\npublic String shortestPalindrome(String s) {\n    int n = s.length(), pos = -1;\n    long B = 29, MOD = 1000000007, POW = 1, hash1 = 0, hash2 = 0;\n    for (int i = 0; i < n; i++, POW = POW * B % MOD) {\n        hash1 = (hash1 * B + s.charAt(i) - 'a' + 1) % MOD;\n        hash2 = (hash2 + (s.charAt(i) - 'a' + 1) * POW) % MOD;\n        if (hash1 == hash2) pos = i;\n    }\n    return new StringBuilder().append(s.substring(pos + 1, n)).reverse().append(s).toString();\n}\n"]}
{"id": "1804", "ref_java": ["class Solution {\\n    static final int LEFT=0, RIGHT=1, HEIGHT=2;\\n    public List<List<Integer>> getSkyline(int[][] buildings) {\\n        TopNode head = new TopNode(0,0);\\n        head.insert(new TopNode(Integer.MAX_VALUE, 0));\\n        TopNode start = head;\\n        \\n        for (int i = 0; i<buildings.length; i++) {\\n            int[] b = buildings[i];\\n            int bL = buildings[i][LEFT];\\n            int bR = buildings[i][RIGHT];\\n            int bH = buildings[i][HEIGHT];\\n            ", "class Solution {\\n    public List<List<Integer>> getSkyline(int[][] buildings) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<int[]> heights = new ArrayList<>();\\n        \\n        ", "class Solution {\\n    static final int LEFT=0, RIGHT=1, HEIGHT=2;\\n    public List<List<Integer>> getSkyline(int[][] buildings) {\\n        TopNode head = new TopNode(0,0);\\n        head.insert(new TopNode(Integer.MAX_VALUE, 0));\\n        TopNode start = head;\\n        \\n        for (int i = 0; i<buildings.length; i++) {\\n            int[] b = buildings[i];\\n            int bL = buildings[i][LEFT];\\n            int bR = buildings[i][RIGHT];\\n            int bH = buildings[i][HEIGHT];\\n            "]}
{"id": "1805", "ref_java": ["class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (k < 1 || t < 0) return false;\\n            Map<Long, Long> map = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n                long bucket = remappedNum / ((long) t + 1);\\n                if (map.containsKey(bucket)\\n                        || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\\n                            || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\\n                                return true;\\n                if (map.entrySet().size() >= k) {\\n                    long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\\n                    map.remove(lastBucket);\\n                }", "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (k < 1 || t < 0) return false;\\n            Map<Long, Long> map = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n                long bucket = remappedNum / ((long) t + 1);\\n                if (map.containsKey(bucket)\\n                        || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\\n                            || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\\n                                return true;\\n                if (map.entrySet().size() >= k) {\\n                    long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\\n                    map.remove(lastBucket);\\n                }", "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) {\\n            return false;\\n        }"]}
{"id": "1806", "ref_java": ["class Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> nums = new Stack<>();\\n        Stack<Character> ops = new Stack<>();\\n        nums.push(0);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }", "class Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> nums = new Stack<>();\\n        Stack<Character> ops = new Stack<>();\\n        nums.push(0);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }", "class Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st=new Stack();\\n        int ans=0,num=0,sign=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c))\\n                num=num*10+(int)(c-\\'0\\');\\n            else if(c==\\'+\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=1;\\n            }"]}
{"id": "1807", "ref_java": ["class Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }", "class Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }", "class Solution {\\n  public int countDigitOne(int n) {\\n    int ans = 0;\\n    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {\\n      final long divisor = pow10 * 10;\\n      final int quotient = (int) (n / divisor);\\n      final int remainder = (int) (n % divisor);\\n      if (quotient > 0)\\n        ans += quotient * pow10;\\n      if (remainder >= pow10)\\n        ans += Math.min(remainder - pow10 + 1, pow10);\\n    }"]}
{"id": "1808", "ref_java": ["class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        List<Integer> res = new ArrayList<>();\\n\\n        for (int i = 0; i < k; i++) {\\n            while (!dq.isEmpty() && nums[i] >= nums[dq.peekLast()]) {\\n                dq.pollLast();\\n            }", "class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n\\n      int n=nums.length;\\n      int res[]=new int[n-k+1];\\n      Deque<Integer>deque=new LinkedList<>();\\n\\n      for(int i=0;i<k;i++){\\n          while(!deque.isEmpty() && nums[i]>=nums\\n[deque.peekLast()])\\n            deque.removeLast();\\n            deque.addLast(i);\\n      }", "class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n  \\n        Deque<Integer> q=new ArrayDeque<>();\\n        int j=0;\\n        int ans[]=new int[nums.length-k+1];\\n        int i=0;\\n        for(i=0;i<k;i++){\\n            while(!q.isEmpty()&&nums[i]>=nums[q.peekLast()]){\\n                q.removeLast();\\n            }"]}
{"id": "1810", "ref_java": ["class Solution {\\n\\n    private final String[] belowTwenty = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n            \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}", "class Solution {\\n    ", "class Solution {\\n        private final String[] belowTen = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}"]}
{"id": "1811", "ref_java": ["class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }", "class Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }", "class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }"]}
{"id": "1814", "ref_java": ["class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n          List<String> res = new ArrayList<>();\\n          \\n          ", "class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n          List<String> res = new ArrayList<>();\\n          \\n          ", "class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n          List<String> res = new ArrayList<>();\\n          \\n          "]}
{"id": "1815", "ref_java": ["class Solution {\\n    public int maxCoins(int[] nums) {\\n        int[] dummy_num = new int[nums.length + 2];\\n        dummy_num[0] = dummy_num[dummy_num.length - 1] = 1;\\n        for(int i = 1;i <= nums.length;i ++)\\n            dummy_num[i] = nums[i - 1];\\n        int[][] dp = new int[dummy_num.length][dummy_num.length];\\n        for (int i = dummy_num.length - 3; i >= 0; i --) {\\n            for (int j = i + 2; j < dummy_num.length;j ++) {\\n                for (int k = i + 1; k < j; k ++)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + dummy_num[i] * dummy_num[k] * dummy_num[j]);\\n            }", "class Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int[n+2];\\n        arr[0] = arr[n+1] = 1;\\n        for(int i=1;i<=n;i++){\\n            arr[i] = nums[i-1];\\n        }", "class Solution {\\n    public int maxCoins(int[] nums) {\\n        int[] dummy_num = new int[nums.length + 2];\\n        dummy_num[0] = dummy_num[dummy_num.length - 1] = 1;\\n        for(int i = 1;i <= nums.length;i ++)\\n            dummy_num[i] = nums[i - 1];\\n        int[][] dp = new int[dummy_num.length][dummy_num.length];\\n        for (int i = dummy_num.length - 3; i >= 0; i --) {\\n            for (int j = i + 2; j < dummy_num.length;j ++) {\\n                for (int k = i + 1; k < j; k ++)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + dummy_num[i] * dummy_num[k] * dummy_num[j]);\\n            }"]}
{"id": "1816", "ref_java": ["class Solution {\\n    int bit[BIT_SIZE] = {0}", "class Solution {\\n        class Node {\\n            Node left, right;\\n            int val, sum, dup = 1;\\n            public Node(int v, int s) {\\n                val = v;\\n                sum = s;\\n            }", "class Solution {\\n    int bit[BIT_SIZE] = {0}"]}
{"id": "1817", "ref_java": ["class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }", "class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }", "class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        \\n        int res[]=new int[k];\\n\\n        for(int i=0;i<=k;i++){\\n\\n            if(!(i<=nums1.length && ((k-i)<=nums2.length))){\\n                continue;\\n            }"]}
{"id": "1818", "ref_java": ["class Solution {\\n    private int[] nums;\\n    public int[] sortArray(int[] nums) {\\n        this.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        return(nums);     \\n    }", "class Solution {\\n    private int[] nums;\\n    public int[] sortArray(int[] nums) {\\n        this.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        return(nums);     \\n    }", "class Solution {\\n    private int[] nums;\\n    public int[] sortArray(int[] nums) {\\n        this.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        return(nums);     \\n    }"]}
{"id": "1819", "ref_java": ["class Solution {\\n    int[] dir = {0, 1, 0, -1, 0}", "class Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[] {0, 1}", "class Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m][n];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == -1) dfs(matrix, dp, m, n, i, j, -1);\\n            }"]}
{"id": "1820", "ref_java": ["class Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }", "class Solution {\\n     public int minPatches(int[] nums, int n) {\\n        long sum = 0;\\n        int count = 0;\\n        for (int x : nums) {\\n            if (sum >= n) break;\\n            while (sum+1 < x && sum < n) { \\n                ++count;\\n                sum += sum+1;\\n            }", "class Solution {\\n    public int minPatches(int[] nums, int n) {\\n      Arrays.sort(nums);\\n      long maxReach = 0;\\n      int ans = 0;\\n      for (int x: nums){\\n        "]}
{"id": "1821", "ref_java": ["class Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }", "class Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.computeIfAbsent(departure, k -> new ArrayList<>()).add(arrival);\\n        }", "class Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        return util1(tickets);\\n    }"]}
{"id": "1822", "ref_java": ["class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            if (x.length <= 3) {\\n                return false;\\n            }", "class Solution {\\n\\n    ", "class Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if(distance.length<=3)return false;\\n        for(int i=3;i<distance.length;i++){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true;\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true;\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true;\\n        }"]}
{"id": "1823", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> answer = new ArrayList<>();\\n\\n\\t\\tint n = words.length;\\n\\n\\t\\tif (n == 1) {\\n\\t\\t\\treturn answer;\\n\\t\\t}", "class Solution {\\n\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> answer = new ArrayList<>();\\n\\n\\t\\tint n = words.length;\\n\\n\\t\\tif (n == 1) {\\n\\t\\t\\treturn answer;\\n\\t\\t}"]}
{"id": "1825", "ref_java": ["class Solution {\\n    public int binarySearch(int[] dp, int val){\\n        int lo=0,hi=dp.length-1,res=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(dp[mid]<val){\\n                res=mid;\\n                lo=mid+1;\\n            }", "class Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }", "class Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }"]}
{"id": "1826", "ref_java": ["class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t", "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int tar) {\\n        int n=matrix.length,m=matrix[0].length,i,j,k,l,dp[][] = new int[n][m],val,max=Integer.MIN_VALUE,target=tar;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                dp[i][j]=matrix[i][j];\\n                if(j>0) dp[i][j]+=dp[i][j-1];\\n            }", "class Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }"]}
{"id": "1828", "ref_java": ["class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        ", "class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        HashSet<String> hs=new HashSet<>();\\n        int area=0;\\n        int minX=Integer.MAX_VALUE;\\n        int minY=Integer.MAX_VALUE;\\n        int maxA=Integer.MIN_VALUE;\\n        int maxB=Integer.MIN_VALUE;\\n        for(int i=0;i<rectangles.length;i++){\\n            int x=rectangles[i][0];\\n            int y=rectangles[i][1];\\n            int a=rectangles[i][2];\\n            int b=rectangles[i][3];\\n            area+=Math.abs(y-b)*Math.abs(x-a);\\n            minX=Math.min(minX,x);\\n            minY=Math.min(minY,y);\\n            maxA=Math.max(maxA,a);\\n            maxB=Math.max(maxB,b);\\n            String bottomLeft=x+\":\"+y;\\n            String bottomRight=a+\":\"+y;\\n            String topLeft=x+\":\"+b;\\n            String topRight=a+\":\"+b;\\n            if(!hs.contains(bottomLeft))\\n                hs.add(bottomLeft);\\n            else\\n                hs.remove(bottomLeft);\\n            if(!hs.contains(bottomRight))\\n                hs.add(bottomRight);\\n            else\\n                hs.remove(bottomRight);\\n            if(!hs.contains(topLeft))\\n                hs.add(topLeft);\\n            else\\n                hs.remove(topLeft);\\n            if(!hs.contains(topRight))\\n                hs.add(topRight);\\n            else\\n                hs.remove(topRight);\\n        }", "class Solution {\\n\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        "]}
{"id": "1829", "ref_java": ["class Solution {\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] - stones[0] != 1)  return false;\\n        \\n        int stonesCount = stones.length;\\n        int stonesBase = stones[1];\\n        int stonesFarthest = (stonesCount * (stonesCount + 1)) / 2;\\n        if (stones[stonesCount - 1] - stonesBase > stonesFarthest)  \\n            return false;\\n        stonesFarthest = Math.min(stonesFarthest, \\n                        stones[stonesCount - 1] - stonesBase + stonesCount);\\n        \\n        boolean[] stonesArr = new boolean[stonesFarthest + 1];\\n        for (int i = stones.length - 1; i > 0; i--) \\n            stonesArr[stones[i] - stonesBase] = true;\\n        \\n        return dfs(0, 1, stonesArr, new HashSet<Long>(), \\n                   stones[stonesCount - 1] - stonesBase);\\n    }", "class Solution {\\n    public boolean canCross(int[] stones) {\\n        \\n        Map<Integer, Boolean>[] dp=new Map[stones.length];\\n        for(int i=0;i<dp.length;i++){\\n            Map<Integer, Boolean> map = new HashMap<>();\\n            dp[i]=map;\\n        }", "class Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 1; i < stones.length; i++){\\n            map.put(stones[i], i);\\n        }"]}
{"id": "1830", "ref_java": ["class Solution {\\nint count;\\nvoid createPQ(int[][] HM, PriorityQueue<Pair<Integer, int[]>> pq, boolean[][] vis){\\n    int n = HM.length - 1, m = HM[0].length - 1;\\n    Arrays.fill(vis[0], true);\\n    Arrays.fill(vis[n], true);\\n    for(int i = 1; i < n; i++){\\n        vis[i][0] = vis[i][m] = true;\\n        pq.add(new Pair<Integer,int[]>(HM[i][0], new int[]{i,0}", "class Solution {\\n\\n    int[] dx = {0, 0, 1, -1}", "class Solution {\\n    public int trapRainWater(int[][] heightMap) {\\n        int trappedWater = 0;\\n        int[][] waterLevelMap = new int[heightMap.length][heightMap[0].length];\\n\\n        for (int i = 1; i < heightMap.length-1; i++) {\\n            waterLevelMap[i][0] = heightMap[i][0];\\n            for (int j = 1; j < heightMap[i].length-1; j++) {\\n                waterLevelMap[i][j] = 20_000;\\n            }"]}
{"id": "1831", "ref_java": ["class Solution {\\n    int[] nums;\\n    public int splitArray(int[] nums, int m) {\\n        this.nums = nums;\\n        int low = 0, high = 0, min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            low = Math.max(low, nums[i]);\\n            high += nums[i];\\n        }", "class Solution {\\n    public int cntNoOfSplits(int []nums,int maxSum){\\n        int noOfSplits=1,sum=0;\\n        for(int x:nums){\\n            if(sum+x<=maxSum) sum+=x;\\n            else{\\n                noOfSplits++;\\n                sum=x;\\n            }", "class Solution {\\n    public int splitArray(int[] nums, int k) {\\n        int start =0;\\n        int end=0;\\n        for (int i=0;i<nums.length;i++){\\n            start = Math.max(start,nums[i]);\\n            end +=nums[i];\\n        }"]}
{"id": "1832", "ref_java": ["class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n        char[] carr = s.toCharArray();\\n        int[] arr = new int[carr.length];\\n        for (int i = 0; i < arr.length;) {\\n            if (Character.isLowerCase(carr[i])) a = 0;\\n            if (Character.isUpperCase(carr[i])) A = 0;\\n            if (Character.isDigit(carr[i])) d = 0;\\n            int j = i;\\n            while (i < carr.length && carr[i] == carr[j]) i++;\\n            arr[j] = i - j;\\n        }", "class Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1}", "class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n        char[] carr = s.toCharArray();\\n        int[] arr = new int[carr.length];\\n        for (int i = 0; i < arr.length;) {\\n            if (Character.isLowerCase(carr[i])) a = 0;\\n            if (Character.isUpperCase(carr[i])) A = 0;\\n            if (Character.isDigit(carr[i])) d = 0;\\n            int j = i;\\n            while (i < carr.length && carr[i] == carr[j]) i++;\\n            arr[j] = i - j;\\n        }"]}
{"id": "1834", "ref_java": ["class Solution {\\n    public int findKthNumber(int n, int k) {\\n        int prefix=1;\\n        for(int count=1;count<k;){\\n            int currCount=getCountWithPrefix(prefix,prefix+1,n);\\n            if(currCount+count<=k){\\n                count+=currCount;\\n                prefix++;\\n            }", "class Solution {\\n    public int findKthNumber(int n, int k) {\\n     int prefix = 1;\\n\\n        for (int count = 1; count < k; ) {\\n            int currCount = getCountWithPrefix(prefix, prefix + 1, n);\\n\\n            if (count + currCount <= k) {\\n                count += currCount;\\n                prefix++;\\n            }", "class Solution {\\n    public int findKthNumber(int n, int k) {\\n        long curr=1;\\n        k-=1;\\n        while(k>0){\\n            int gap=(int)countNodes(curr, n, k);\\n            if(k>=gap){\\n                curr++;\\n                k-=gap;\\n            }"]}
{"id": "1835", "ref_java": ["class Solution {\\n    HashMap<Pair<Integer, Long>, Integer> memo = new HashMap<>();\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int n = A.length;\\n        int total = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                total += dfs(j+1, j, (long)A[j]-A[i], A);\\n            }", "class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        HashMap<Integer, Integer>[] maps = new HashMap[nums.length];\\n        int ans = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            maps[i] = new HashMap<>();\\n        }", "class Solution {\\n     "]}
{"id": "1836", "ref_java": ["class Solution {\\n    public int poorPigs(int buckets, int timeToDie, int timeToTest) {\\n        int testsPerPig = timeToTest / timeToDie;\\n        int numPigs = 0;\\n        int states = 1; ", "class Solution {\\n    public int poorPigs(int buckets, int timeToDie, int timeToTest) {\\n        int testsPerPig = timeToTest / timeToDie;\\n        int numPigs = 0;\\n        int states = 1; ", "class Solution {\\n    public int poorPigs(int buckets, int timeToDie, int timeToTest) {\\n        int testsPerPig = timeToTest / timeToDie;\\n        int numPigs = 0;\\n        int states = 1; "]}
{"id": "1838", "ref_java": ["class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         int l1 = s1.length(), l2 = s2.length();\\n        int[] next = new int[l2 + 1];\\n        int[] count = new int[l2 + 1];\\n        int cnt = 0, p = 0;\\n        for (int i = 0; i < n1; i++) {\\n            for (int j = 0; j < l1; j++) {\\n                if (s1.charAt(j) == s2.charAt(p)) {\\n                    p++;\\n                }", "class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }", "class Solution {\\n\\n    "]}
{"id": "1839", "ref_java": ["class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> set = new HashSet<>(); \\n        List<String> result = new ArrayList<>(); \\n        for(String word : words){\\n            set.add(word);\\n        }", "class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        ArrayList<String> list= new ArrayList<String>();\\n        Trie trie = new Trie();\\n        for(String x:words){\\n            insert(x,trie);\\n        }", "class Solution {\\n    "]}
{"id": "1840", "ref_java": ["class Solution {\\n    public int largestPalindrome(int n) {\\n        if(n==1)\\n        return 9;\\n        if(n==2)\\n        return 987;\\n        if(n==3)\\n        return 123;\\n        if(n==4)return 597;\\n        if(n==5)return 677;\\n        if(n==6)return 1218;\\n        if(n==7)return 877;\\n        if(n==8)return 475;\\n        return 0;\\n    }", "class Solution {\\n    public int largestPalindrome(int n) {\\n        if (n == 1) {\\n            return 9;\\n        }", "class Solution {\\n\\n    "]}
{"id": "1841", "ref_java": ["class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }", "class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }", "class Solution {\\n    \\n    public PriorityQueue<Integer> left = new PriorityQueue<>(Collections.reverseOrder());\\n    public PriorityQueue<Integer> right = new PriorityQueue<>();\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        for(int i=0; i<k; i++) {\\n            addNum(nums[i]);\\n        }"]}
{"id": "1842", "ref_java": ["class Solution {\\n    public String smallestGoodBase(String n) {\\n        long low = Long.valueOf(n);\\n        int high = (int) (Math.log(low + 1) / Math.log(2)) - 1;\\n        \\n        long result = low - 1;\\n        for (int m = high; m > 1; m--) {\\n            long k = (long) Math.pow(low, 1.0 / m);\\n            if (geometric(k, m) == low) return String.valueOf(k);\\n        }", "class Solution {\\n    public String smallestGoodBase(String n) {\\n        long tn = Long.parseLong(n);\\n        long x = 1;\\n        \\n        for (int i = 62; i >= 1; i--) {\\n            if ((x << i) < tn) {\\n                long cur = mySolve(tn, i);\\n                if (cur != 0) {\\n                    return Long.toString(cur);\\n                }", "class Solution {\\n    \\n\\t"]}
{"id": "1843", "ref_java": ["class Solution {\\n    public int findMinStep(String board, String hand) {\\n        HashMap<Character, Integer> freq = new HashMap<Character, Integer>();\\n        for(int i=0; i<hand.length(); i++){\\n            char c = hand.charAt(i);\\n            freq.put(c, freq.getOrDefault(c, 0) +1);\\n        }", "class Solution {\\n\\tstatic class Hand {\\n\\t\\tint red;\\n\\t\\tint yellow;\\n\\t\\tint green;\\n\\t\\tint blue;\\n\\t\\tint white;\\n\\n\\t\\tHand(String hand) {\\n\\t\\t\\t", "class Solution {\\n    int INF = 100000000;\\n    String ALL = \"RYBGW\";\\n    public int findMinStep(String board, String hand) {\\n        if (board.equals(\"BRWGWYY\")){\\n            return -1;\\n        }"]}
{"id": "1844", "ref_java": ["class Solution {\\n    public int reversePairs(int[] nums) {\\n        ", "class Solution {\\n\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length - 1);\\n    }", "class Solution {\\n    public int reversePairs(int[] nums) {\\n        int[] copy = Arrays.copyOf(nums, nums.length);\\n        return mergeSort(nums, copy, 0, nums.length - 1);\\n    }"]}
{"id": "1845", "ref_java": ["class Solution {\\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\\n        int n = profits.length;\\n        int[][] projects = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            projects[i][0] = capital[i];\\n            projects[i][1] = profits[i];\\n        }", "class Solution {\\n    public int findMaximizedCapital(int k, int w, int[] pf, int[] cp) {\\n        \\n        int n = pf.length;\\n        int arr[][] = new int[n][2];\\n        for(int i=0; i<n; i++){\\n            arr[i] = new int[]{pf[i],cp[i]}", "class Solution {\\n    class Pair implements Comparable<Pair> {\\n        int capital, profit;\\n\\n        public Pair(int capital, int profit) {\\n            this.capital = capital;\\n            this.profit = profit;\\n        }"]}
{"id": "1846", "ref_java": ["class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] r=ring.toCharArray();\\n        List<Integer>[] p=new List[26];\\n        for(int i=0;i<r.length;i++) {\\n            int c=r[i]-\\'a\\';\\n            List<Integer> l=p[c];\\n            if(l==null) p[c]=l=new ArrayList<>();\\n            l.add(i);\\n        }", "class Solution {\\n\\n    public int helper(String ring, String key, int s, int x, HashMap<Character,List<Integer>> map,int[][] dp){\\n        if(s==key.length()){\\n            return 0;\\n        }", "class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int[][] minSteps = new int[key.length()][ring.length()];\\n        for (int[] step : minSteps) {\\n            Arrays.fill(step, 100_000);\\n        }"]}
{"id": "1847", "ref_java": ["class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int avg = 0;\\n\\n        for(int i = 0; i < machines.length; i++){\\n            avg += machines[i];\\n            \\n        }", "class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0;\\n        for(int i: machines){\\n            total += i;\\n        }", "class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        \\n        int totalDresses = 0;\\n        for (int machine : machines) {\\n            totalDresses += machine;\\n        }"]}
{"id": "1848", "ref_java": ["class Solution {\\n    public int removeBoxes(int[] boxes) {\\n        int [][][] dp = new int [boxes.length][boxes.length][boxes.length];\\n        return dfs(boxes, 0, boxes.length -1, 0, dp);\\n    }", "class Solution {\\n    public int removeBoxes(int[] boxes) {\\n        int n = boxes.length;\\n        int[][][] memo = new int[n][n][n];\\n        return removeBoxesSub(boxes, 0, n - 1, 0, memo);\\n    }", "class Solution {\\n    public int removeBoxes(int[] boxes) {\\n        int dp[][][] = new int[boxes.length][boxes.length][boxes.length];\\n        return remove(boxes, 0, boxes.length - 1, 0, dp);\\n    }"]}
{"id": "1849", "ref_java": ["class Solution {\\n    final int MOD = 1000000007;\\n    final int M = 6;\\n\\n    int[][] mul(int[][] A, int[][] B) {\\n        int[][] C = new int[M][M];\\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < M; j++)\\n                for (int k = 0; k < M; k++)\\n                    C[i][j] = (int) ((C[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n        return C;\\n    }", "class Solution {\\n    final int MOD = 1000000007;\\n    final int M = 6;\\n\\n    int[][] mul(int[][] A, int[][] B) {\\n        int[][] C = new int[M][M];\\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < M; j++)\\n                for (int k = 0; k < M; k++)\\n                    C[i][j] = (int) ((C[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n        return C;\\n    }", "class Solution {\\n    final int MOD = 1000000007;\\n    final int M = 6;\\n\\n    int[][] mul(int[][] A, int[][] B) {\\n        int[][] C = new int[M][M];\\n        for (int i = 0; i < M; i++)\\n            for (int j = 0; j < M; j++)\\n                for (int k = 0; k < M; k++)\\n                    C[i][j] = (int) ((C[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n        return C;\\n    }"]}
{"id": "1850", "ref_java": ["class Solution {\\n    public String nearestPalindromic(String n) {\\n        long N = Long.parseLong(n), S = previous(String.valueOf(N-1).toCharArray()), L = next(String.valueOf(N+1).toCharArray());\\n        return String.valueOf(L - N < N - S ? L : S);\\n    }", "class Solution {\\n\\n    public String nearestPalindromic(String n) {\\n        long N = Long.parseLong(n), S = previous(String.valueOf(N-1).toCharArray()), L = next(String.valueOf(N+1).toCharArray());\\n        return String.valueOf(L - N < N - S ? L : S);\\n    }", "class Solution {\\n    public String nearestPalindromic(String n) {\\n        long N = Long.parseLong(n), S = previous(String.valueOf(N-1).toCharArray()), L = next(String.valueOf(N+1).toCharArray());\\n        return String.valueOf(L - N < N - S ? L : S);\\n    }"]}
{"id": "1851", "ref_java": ["class Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }", "class Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n\\n        ", "class Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n       if(trees.length <= 3) \\n           return trees;\\n        Arrays.sort(trees, (a, b) -> {\\n            if(a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }"]}
{"id": "1852", "ref_java": ["class Solution {\\n      public boolean isValid(String exp) {\\n        int length = exp.length();\\n        Stack S=new Stack();\\n        for (int i = 0; i < length; i++) {\\n            if(i>0 && S.empty())\\n                return false;\\n            if(exp.startsWith(\"<![CDATA[\",i)){\\n                int pos=exp.indexOf(\"]]>\",i+9);\\n                if (pos==-1)\\n                    return false;\\n                else\\n                    i=pos+2;\\n            }", "class Solution {\\n  public boolean isValid(String code) {\\n    if (code.charAt(0) != \\'<\\' || code.charAt(code.length() - 1) != \\'>\\')\\n      return false;\\n\\n    Deque<String> stack = new ArrayDeque<>();\\n\\n    for (int i = 0; i < code.length(); ++i) {\\n      int closeIndex = 0;\\n      if (stack.isEmpty() && containsTag)\\n        return false;\\n      if (code.charAt(i) == \\'<\\') {\\n        ", "class Solution {\\n    public boolean isValid(String code) {\\n        ArrayList<String> stack = new ArrayList<String>();\\n        char[] c = code.toCharArray();\\n        int n = c.length;\\n        int i = 0;\\n        boolean tag_text = true, first = true, cdata = false;\\n        if((c[0] != \\'<\\')|| c[n-1] != \\'>\\')\\n            return false;\\n        while(i < n){\\n            if(!tag_text)\\n                return false;\\n            char ch = c[i];\\n            "]}
{"id": "1853", "ref_java": ["class Solution {\\n    public int findIntegers(int n) {\\n        int countOnes = helper(n);\\n        return n - countOnes + 1;\\n    }", "class Solution {\\n  public int findIntegers(int num) {\\n    StringBuilder bits = new StringBuilder();\\n    for (; num > 0; num >>= 1)\\n      bits.append(num & 1);\\n\\n    final int n = bits.length();\\n    int[] zero = new int[n];\\n    int[] one = new int[n];\\n\\n    zero[0] = 1;\\n    one[0] = 1;\\n\\n    for (int i = 1; i < n; ++i) {\\n      zero[i] = zero[i - 1] + one[i - 1];\\n      one[i] = zero[i - 1];\\n    }", "class Solution {\\n    public int findIntegers(int n) {\\n        String binary = Integer.toBinaryString(n);\\n        int k = binary.length();\\n\\n        int[] fib = new int[k+1];\\n        fib[0] = 1;\\n        fib[1] = 2;\\n        for(int i=2;i<=k;i++){\\n            fib[i] = fib[i-1]+fib[i-2];\\n        }"]}
{"id": "1855", "ref_java": ["class Solution {\\n    public int kInversePairs(int n, int k) {\\n        int[][] dp = new int[n + 1][k + 1];\\n        dp[0][0] = 1;\\n        int mod = 1000000007;\\n\\n        for(int i = 1; i <= n; i++) {\\n            int val = 0;\\n            for(int j = 0; j <= k; j++) {\\n                val += dp[i - 1][j];\\n                if(j >= i) val -= dp[i - 1][j - i];\\n                if(val < 0) val += mod;\\n                val = (val % mod);\\n                dp[i][j] = val;\\n            }", "class Solution {\\n    public int kInversePairs(int n, int k) {\\n        if (k > n * (n - 1) / 2) ", "class Solution {\\n    public int kInversePairs(int n, int k) {\\n        int MOD = 1000000007;\\n        int[][] opt = new int[k + 1][n];\\n        for (int i = 0; i <= k; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0) {\\n                    opt[i][j] = 1;\\n                }"]}
{"id": "1856", "ref_java": ["class Solution {\\n    public int scheduleCourse(int[][] courses) {\\n\\n        ", "class Solution {\\n    public int scheduleCourse(int[][] courses) {\\n\\n        ", "class Solution {\\n    public int scheduleCourse(int[][] C) {\\n        Arrays.sort(C, (a,b) -> a[1] - b[1]);\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\\n        int total = 0;\\n        for (int[] course : C) {\\n            int dur = course[0], end = course[1];\\n            if (dur + total <= end) {\\n                total += dur;\\n                pq.add(dur);\\n            }"]}
{"id": "1857", "ref_java": ["class Solution {\\n  private int[] bestRange;\\n  public int[] smallestRange(List<List<Integer>> nums) {\\n    List<Integer> firstList = nums.get(0);\\n    for (int elem : firstList) {\\n      int[] range = new int[2];\\n      range[0] = elem;\\n      range[1] = elem;\\n      expandRange(nums, 1, range);\\n    }", "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<k;i++){\\n            List<Integer> l = nums.get(i);\\n            for(int nu : l){\\n                list.add(new Pair(nu,i));\\n            }", "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-100000 , 100000}"]}
{"id": "1858", "ref_java": ["class Solution {\\n    private static final int MOD = 1000000007;\\n    public int numDecodings(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }", "class Solution {\\n    public int numDecodings(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }", "class Solution {\\n    public int numDecodings(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }"]}
{"id": "1859", "ref_java": ["class Solution {\\n    static char ch[]=new char[100]; int n;\\n    public int strangePrinter(String s) {\\n        setCompressedString(s);\\n        return f(0,n-1,new Integer[n][n]);\\n    }", "class Solution {\\n    public int strangePrinter(String s) {\\n        int dp[][]= new int [s.length()+1][s.length()+1];\\n        for(int d[]:dp) Arrays.fill(d,-1);\\n        return helper(0,s.length()-1,s,dp);\\n    }", "class Solution {\\n    public int strangePrinter(String s) {\\n        char[] sc = s.toCharArray();\\n        final int n = removeDuplicates(sc);\\n        if (n <= 1)  return n;\\n        return dfs(0, n - 1, sc, new int[n][n]);\\n    }"]}
{"id": "1860", "ref_java": ["class Solution {\\n    public int countlessthanmid(int n ,int m, int  mid){\\n        int count=0;\\n        int i=1;\\n        int j =m;\\n        while(i<=n && j>=1){\\n            if(i*j<=mid){\\n                count+=j;\\n                i++;\\n            }", "class Solution {\\n    public int countlessthanmid(int n ,int m, int  mid){\\n        int count=0;\\n        int i=1;\\n        int j =m;\\n        while(i<=n && j>=1){\\n            if(i*j<=mid){\\n                count+=j;\\n                i++;\\n            }", "class Solution {\\n    public int countlessthanmid(int n ,int m, int  mid){\\n        int count=0;\\n        int i=1;\\n        int j =m;\\n        while(i<=n && j>=1){\\n            if(i*j<=mid){\\n                count+=j;\\n                i++;\\n            }"]}
{"id": "1861", "ref_java": ["class Solution {\\n    static constexpr int DIR[4][2] = {{-1,0}", "class Solution {\\n    ", "class Solution {\\n    static int[] dy = {-1, 0, 1, 0}"]}
{"id": "1862", "ref_java": ["class Solution {\\n    private static final double EPS = 1e-6;\\n    private boolean backtrack(double[] A, int n) {\\n        if(n == 1) return Math.abs(A[0] - 24) < EPS;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                double a = A[i], b = A[j];\\n                A[j] = A[n-1];\\n                A[i] = a + b;\\n                if(backtrack(A, n - 1)) return true;\\n                A[i] = a - b;\\n                if(backtrack(A, n - 1)) return true;\\n                A[i] = b - a;\\n                if(backtrack(A, n - 1)) return true;\\n                A[i] = a * b;\\n                if(backtrack(A, n - 1)) return true;\\n                if(Math.abs(b) > EPS) {\\n                    A[i] = a / b;\\n                    if(backtrack(A, n - 1)) return true;\\n                }", "class Solution {\\n    public boolean judgePoint24(int[] cards) {\\n        List<Double> in=new ArrayList<>();\\n        \\n        for(int i : cards){\\n            in.add((double)i);\\n        }", "class Solution {\\n    final double target = 24;\\n    int[] cards;\\n    HashSet<Integer> visited = new HashSet<>();\\n    List<int[]> permutations = new ArrayList<>();\\n    Set<Character> operators = new HashSet<>();\\n    "]}
{"id": "1863", "ref_java": ["class Solution {\\n\\n\\n\\n\\n\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        ", "class Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n\\n        int[] parent = new int[n+1], ds = new int[n+1];\\n        Arrays.fill(parent ,-1);\\n        int first = -1, second = -1, last = -1;\\n        for(int i = 0; i < n; i++){\\n            int p = edges[i][0], c = edges[i][1];\\n            if(parent[c] != -1){\\n                first = parent[c];\\n                second = i;\\n                continue;\\n            }", "class Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        \\n        int[]inDegree = new int[edges.length+1];        "]}
{"id": "1864", "ref_java": ["class Solution {\\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; ++i) sum[i + 1] = sum[i] + nums[i];\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] ans = new int[3];\\n        for (int i = k, tot = sum[k] - sum[0]; i < n; ++i) {\\n            if (sum[i + 1] - sum[i + 1 - k] > tot) {\\n                left[i] = i + 1 - k;\\n                tot = sum[i + 1] - sum[i + 1 - k];\\n            }", "class Solution {    \\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\\n\\t\\tint[] res = new int[3];\\n        int[] psum = new int[nums.length+1];\\n        for(int i=1; i<psum.length; i++){\\n            psum[i] += psum[i-1]+nums[i-1];\\n        }", "class Solution {\\n    class Pair implements Comparable<Pair>{\\n        int sum;\\n        int sumleft;\\n        int sumSub;\\n        \\n        int sumRight;\\n        int a,b,c;\\n        Pair(int sum ,int i,int j,int k,int a,int b,int c){\\n            this.sum=sum;\\n             this.sumleft=i;\\n            this.sumSub=j;\\n           \\n            this.sumRight=k;\\n           this.a=a;\\n            this.b=b;\\n            this.c=c;\\n        }"]}
{"id": "1865", "ref_java": ["class Solution {\\n    private boolean empty(int[] freq) {\\n        for(int f: freq) if(f > 0) return false;\\n        return true;\\n    }", "class Solution {\\n    public int minStickers(String[] stickers, String target) {\\n        int n = stickers.length;\\n\\n        target = sortChars(target);\\n        for (int i = 0; i < n; ++i) stickers[i] = sortChars(stickers[i]);\\n\\n        Queue<String> q = new LinkedList();\\n        q.offer(target);\\n        int steps = 0;\\n        Set<String> visited = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            steps++;\\n            int size = q.size();\\n            while(size-- > 0) {\\n                String x = q.poll();\\n                for (int i = 0; i < n; ++i) {\\n                    String now = filter(x, stickers[i]);\\n                    if (now.isEmpty()) return steps;\\n                    if (!now.equals(x) && !visited.contains(now)) {\\n                        visited.add(now);\\n                        q.offer(now);\\n                    }", "class Solution {\\n    private boolean empty(int[] freq) {\\n        for(int f: freq) if(f > 0) return false;\\n        return true;\\n    }"]}
{"id": "1866", "ref_java": ["class Solution {\\n    public List<Integer> fallingSquares(int[][] positions)\\n    {\\n        int[] ends = new int[positions.length*2];\\n        for(int i=0; i<positions.length; i++)\\n        {\\n            ends[i*2+0] = positions[i][0];\\n            ends[i*2+1] = positions[i][0]+positions[i][1];\\n        }", "class Solution {\\n    public List<Integer> fallingSquares(int[][] positions) {\\n        int max = 0;\\n        List<Integer> result = new ArrayList<>();\\n        TreeSet<Node> nodes = new TreeSet<>((n1, n2) -> n1.l - n2.l);\\n        ", "class Solution {\\n    private class Interval {\\n        int start, end, height;\\n        public Interval(int start, int end, int height) {\\n            this.start = start;\\n            this.end = end;\\n            this.height = height;\\n        }"]}
{"id": "1869", "ref_java": ["class Solution {\\n    public int smallestDistancePair(int[] nums, int k) {\\n        \\n        ", "class Solution {\\n    public int smallestDistancePair(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int minDist = 0; ", "class Solution {\\n    \\n    "]}
{"id": "1870", "ref_java": ["class Solution {\\n    public String countOfAtoms(String formula) {\\n        ", "class Solution {\\n    Map<String, Integer> res = new TreeMap<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int multiplier = 1;\\n    \\n    public String countOfAtoms(String formula) {\\n        int end = formula.length() - 1, i = formula.length() - 1;\\n        \\n        while (i >= 0) {\\n            if (formula.charAt(i) == \\'(\\') {\\n                multiplier /= stack.pop();\\n                i--;\\n                continue;\\n            }", "class Solution {\\n    public String countOfAtoms(String A) {\\n        Deque<Map<String, Integer>> stack = new ArrayDeque<>();\\n        Deque<Integer> numStack = new ArrayDeque<>();\\n        StringBuilder sb = new StringBuilder();\\n        StringBuilder nsb= new StringBuilder();\\n        stack.push(new HashMap<>());\\n        long num = 0;\\n        for (int i = A.length()-1;i>=0;--i){\\n            if (A.charAt(i)==\\')\\'){\\n                stack.push(new HashMap<>());\\n                numStack.push(getnum(nsb));\\n                nsb.setLength(0);\\n            }"]}
{"id": "1871", "ref_java": ["class Solution {\\n    public int countPalindromicSubsequences(String s) {\\n        int n = s.length(), ans = 0, M = (int)1e9+7, E = 4;\\n        int[][] next = new int[n][E];\\n        int[][] prev = new int[n][E];\\n        int[][][] dp = new int[n][n][E];\\n        for (int i = 0; i < E; i++){ ", "class Solution {\\n    public int countPalindromicSubsequences(String s) {\\n        int n = s.length(), ans = 0, M = (int)1e9+7, E = 4;\\n        int[][] next = new int[n][E];\\n        int[][] prev = new int[n][E];\\n        int[][][] dp = new int[n][n][E];\\n        for (int i = 0; i < E; i++){ ", "class Solution {\\n    public int countPalindromicSubsequences(String s) {\\n        int n = s.length(), ans = 0, M = (int)1e9+7, E = 4;\\n        int[][] next = new int[n][E];\\n        int[][] prev = new int[n][E];\\n        int[][][] dp = new int[n][n][E];\\n        for (int i = 0; i < E; i++){ "]}
{"id": "1873", "ref_java": ["class Solution {\\n    String expression;\\n    int index;\\n    HashMap<String,Deque<Integer>> scope; \\n    public int evaluate(String expression) {\\n        this.expression=expression;\\n        index=0;\\n        scope=new HashMap<>();\\n        return evaluate();\\n    }", "class Solution {\\n    Map<String, Integer> vars = new HashMap<>();\\n\\n    public int evaluate(String expression) {\\n        String[] strs = split(expression);\\n\\n        switch (strs[0]) {\\n            case \"let\":\\n                Map<String, Integer> localVars = new HashMap<>(vars);\\n                Map temp = vars;\\n                for (int i = 1; i < strs.length - 1; i++) {\\n                    String name = strs[i];\\n                    int val = evaluate(strs[i + 1]);\\n                    if (localVars.containsKey(name)) localVars.replace(name, val);\\n                    else localVars.put(name, val);\\n                    i++;\\n                    vars = localVars;\\n                }", "class Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<String, Integer>());\\n    }"]}
{"id": "1874", "ref_java": ["class Solution {\\n    int max=0;\\n    public int cherryPickup(int[][] grid) {\\n        TopToBottom(grid,0,0,0);\\n        return max;\\n    }", "class Solution {\\n    public int cherryPickup(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        ", "class Solution {\\n    public int cherryPickup(int[][] grid) {\\n        int n= grid.length;\\n        int[][][][] dp= new int[55][55][55][55];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                for(int k=0; k<n; k++){\\n                    for(int l=0; l<n; l++){\\n                        dp[i][j][k][l]= -1;\\n                    }"]}
{"id": "1876", "ref_java": ["class Solution {\\n    class Region {\\n        Set<Integer> infected = new HashSet<>();\\n        Set<Integer> unInfected = new HashSet<>();\\n        int walls = 0;\\n    }", "class Solution {\\n    private final int HEALTHY = 0, UNHEALTHY = 1, FOUND = 2, CONTAMINATED = 3;\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[] {0, 1}", "class Solution {\\n    int m, n;\\n    int VIRUS = 1;\\n    int ID = 2;\\n    public int containVirus(int[][] isInfected) {\\n        m = isInfected.length;\\n        n = isInfected[0].length;\\n        int ans = 0;\\n        Comparator<Virus> comp = Comparator.comparingInt(o -> -o.border.size());\\n        PriorityQueue<Virus> maxheap = new PriorityQueue<>(comp);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (isInfected[i][j]==VIRUS){ "]}
{"id": "1877", "ref_java": ["class Solution {\\n    public String crackSafe(int n, int k) {\\n        if(n==1){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < k; i++){\\n                sb.append(i);\\n            }", "class Solution {\\n    String ans;\\n    public String crackSafe(int n, int k) {\\n        int minLen = (int)Math.pow(k, n) + (n -1);\\n        \\n        dfs(\"\", n ,k, new HashSet<String>(),minLen);\\n        return ans;\\n    }", "class Solution {\\n    private String str = \"\";\\n    public String crackSafe(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\"0\".repeat(Math.max(0, n)));\\n        slv(sb,new HashSet<>(List.of(sb.toString())), n, k);\\n        return str;\\n    }"]}
{"id": "1878", "ref_java": ["class Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = 0;\\n        long[] endStartPairs = new long[intervals.length];\\n        for (int[] interval : intervals) {\\n            endStartPairs[n] = -interval[0] & 0xFFFFFFFFL;\\n            endStartPairs[n++] |= (long) (interval[1]) << 32;\\n        }", "class Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int last = intervals[0][1];\\n        int secondLast = intervals[0][1] - 1;\\n        int size = 2;\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (start > last) {\\n                last = end;\\n                secondLast = end - 1;\\n                size += 2;\\n            }", "class Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\\n        int last = intervals[0][1];\\n        int secondLast = intervals[0][1] - 1;\\n        int size = 2;\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (start > last) {\\n                last = end;\\n                secondLast = end - 1;\\n                size += 2;\\n            }"]}
{"id": "1879", "ref_java": ["class Solution {\\n    char[] bits;\\n    int[] ptable;\\n\\n    class Node implements Comparable<Node> {\\n        long x = 0L;\\n        int n = 0;\\n\\n        public Node(long x, int n) {\\n            this.x = x;\\n            this.n = n;\\n        }", "class Solution {\\n    public String makeLargestSpecial(String S) {\\n        int count = 0, i = 0;\\n        List<String> res = new ArrayList<String>();\\n        for (int j = 0; j < S.length(); ++j) {\\n          if (S.charAt(j) == \\'1\\') count++;\\n          else count--;\\n          if (count == 0) {\\n            res.add(\\'1\\' + makeLargestSpecial(S.substring(i + 1, j)) + \\'0\\');\\n            i = j + 1;\\n          }", "class Solution {\\n    public String makeLargestSpecial(String s) {\\n        int balance=0;\\n        int left=0;\\n        List<String> list = new LinkedList<>();\\n        for(int right=0; right<s.length(); right++){\\n            if(s.charAt(right) == \\'0\\'){\\n                balance--;\\n            }"]}
{"id": "1880", "ref_java": ["class Solution {\\n    public int minSwapsCouples(int[] row) {\\n        int n = row.length;\\n        int[] pos = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            pos[row[i]] = i;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i += 2) {\\n            int actualPair = row[i] + (row[i] % 2 == 0 ? 1 : -1);\\n            int curPair = row[i+1];\\n            \\n            if( curPair != actualPair ) {\\n                swap(row, i+1, pos[actualPair]);\\n\\t\\t\\t\\t\\n                swap(pos, curPair, actualPair);\\n\\t\\t\\t\\t\\n                ans++;\\n            }", "class Solution {\\n\\n    public int minSwapsCouples(int[] row) {\\n        \\n        int n = row.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            map.put(row[i], i);\\n        }", "class Solution {\\n    public int minSwapsCouples(int[] row) {\\n        if (row == null || row.length < 2) return 0;\\n\\n        int number = 0;\\n        DisjointSets disjointSets = new DisjointSets(row.length/2);\\n        for (int i = 0; i<row.length; i = i+2){\\n            if (!isCouple(row[i], row[i+1])){\\n                if (disjointSets.union(row[i]/2, row[i+1]/2)){\\n                    number++;\\n                }"]}
{"id": "1881", "ref_java": ["class Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n        \\n        int n = arr.length;\\n        int[] maxTillNow = new int[n];\\n        int[] minOnRight = new int[n];\\n        \\n        maxTillNow[0] = arr[0];\\n        for(int i=1; i<n; i++){\\n            maxTillNow[i] = Math.max(arr[i], maxTillNow[i-1]);\\n        }", "class Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n        \\n        int[] rmin = new int[arr.length+1];\\n        rmin[arr.length]=Integer.MAX_VALUE;\\n        for(int i=arr.length-1 ;i>=0;i--){\\n            rmin[i]=Math.min(rmin[i+1],arr[i]);\\n        }", "class Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n        int n = arr.length;\\n        \\n        "]}
{"id": "1882", "ref_java": ["class Solution {\\n    int n;\\n    String s;\\n    char[] arr;\\n    int[] braces;\\n    HashMap<String, Integer> variables = new HashMap<>();\\n    \\n    public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {\\n        s = expression;\\n        arr = s.toCharArray();\\n        n = arr.length;\\n        braces = new int[n];\\n        Arrays.fill(braces, -1);\\n        int[] stack = new int[n/2];\\n        int index = -1;\\n        for(int i=0; i<n; ++i) {\\n            if(arr[i] == \\'(\\') stack[++index] = i;\\n            else if(arr[i] == \\')\\') {\\n                int last = stack[index--];\\n                braces[last] = i;\\n                braces[i] = last;\\n            }", "class Solution {\\n    class Node {\\n        Map<List<String>, Integer> mem = new HashMap<>();\\n        \\n        void update(List<String> cur, int cnt) {\\n            Collections.sort(cur);\\n            mem.put(cur, mem.getOrDefault(cur, 0) + cnt);\\n        }", "class Solution {\\n    int n;\\n    String s;\\n    char[] arr;\\n    int[] braces;\\n    HashMap<String, Integer> variables = new HashMap<>();\\n    \\n    public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {\\n        "]}
{"id": "1883", "ref_java": ["class Solution {\\n    int min = Integer.MAX_VALUE;\\n    int[][] dirs = {{0, 1}", "class Solution {\\n    ", "class Solution {\\n    public int slidingPuzzle(int[][] board) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        String target = \"123450\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sb.append(board[i][j]);\\n            }"]}
{"id": "1884", "ref_java": ["class Solution {\\n    public static int Dijkstra(int[][] grid){\\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->a.value-b.value);\\n        pq.add(new pair(0,0,grid[0][0]));\\n        int[][] distance={{-1,0}", "class Solution {\\n    public int swimInWater(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (int[] m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\\n                grid[ia][jb] = 3000;\\n            }", "class Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n=grid.length;\\n        int l=grid[0][0];\\n        int r=n*n-1;\\n        while(l<r)\\n        {\\n            int m= l+(r-l)/2;\\n            boolean v[][]=new boolean[n][n];\\n            if(dfs(grid,0,0,v,m)==true)\\n                r=m;\\n            else l=m+1;\\n        }"]}
{"id": "1885", "ref_java": ["class Solution {\\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\\n        while (tx >= sx && ty >= sy) {\\n            if (tx == ty) break;\\n            if (tx > ty) {\\n                if (ty > sy) tx %= ty;\\n                else return (tx - sx) % ty == 0;\\n            }", "class Solution {\\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\\n\\t\\t while(tx >= sx && ty >= sy){\\n            if(tx > ty) {\\n                if(sy == ty) return (tx - sx) % ty == 0;\\n                tx %= ty;\\n            }", "class Solution {\\n\\n    "]}
{"id": "1886", "ref_java": ["class Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int r = 0; r < N; ++r)\\n            for (int c = 0; c < N; ++c) {\\n                if ((board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1)\\n                    return -1;\\n            }", "class Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int r = 0; r < N; ++r)\\n            for (int c = 0; c < N; ++c) {\\n                if ((board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1)\\n                    return -1;\\n            }", "class Solution {\\n    int n;\\n    int[][] board;\\n    int countInRow(int r,int what){\\n        int count=0;\\n        for(int i =0;i<n;i++)if(board[r][i]==what)count++;\\n\\n        return count;\\n    }"]}
{"id": "1887", "ref_java": ["class Solution {\\n    public int preimageSizeFZF(int k) {\\n        \\n        long low = 0;\\n        long high = (long)Math.pow(10,10);\\n        \\n        while(low<=high){\\n            long mid  = low + (high-low)/2;\\n            long val = mid;\\n            long ans = 0;\\n            while(val!=0){\\n                val/=5;\\n                ans+=val;\\n            }", "class Solution {\\n    public int preimageSizeFZF(int k) {\\n        return (int)(rightBoundOfKTrailingZeros(k) - leftBoundOfKTrailingZeros(k) + 1);\\n    }", "class Solution {\\n    public int preimageSizeFZF(int k) {\\n        long n = 4L * k;\\n        int resp = 0;\\n        while (true) {\\n            int t = zeros(n);\\n            if (t > k) return 0;\\n            if (t == k) return 5;\\n            n++;\\n        }"]}
{"id": "1888", "ref_java": ["class Solution {\\n    public int bestRotation(int[] nums) {\\n        final int size = nums.length;\\n        int[] rsc = new int[size];\\n        for(int i = 0; i < size - 1; i++) {\\n            int value = nums[i];\\n            int downPos = (i + 1 + size - value) % size;\\n            rsc[downPos]--;\\n        }", "class Solution {\\n\\n    ", "class Solution {\\n    public int bestRotation(int[] nums) {\\n        int n = nums.length;\\n        int[] loss = new int[n];\\n        for(int i = 0; i < n; i++){\\n            loss[(i - nums[i] + 1 + n) % n]--;\\n        }"]}
{"id": "1889", "ref_java": ["class Solution {\\n    public int minSwap(int[] A, int[] B) {\\n        int swapRecord = 1, fixRecord = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i - 1] >= B[i] || B[i - 1] >= A[i]) {\\n                swapRecord++;\\n            }", "class Solution {\\n\\n    public int minSwap(int[] nums1, int[] nums2) {\\n\\t\\n        int dp[] = new int[nums1.length];\\n        Arrays.fill(dp,-1);\\n        \\n        int ans = solve(nums1,nums2,0,dp);\\n        \\n        return ans;\\n    }", "class Solution {\\n    Integer[][] memo;\\n    int SWAPPED = 0;\\n    int NOT_SWAPPED = 1;\\n\\n    int NOT_VALID = (int) Math.pow(10, 6);\\n    public int minSwap(int[] nums1, int[] nums2) {\\n        this.memo = new Integer[nums1.length][2];\\n        return dfs(nums1, nums2, 0, NOT_SWAPPED);\\n    }"]}
{"id": "1890", "ref_java": ["class Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] ans = new int[hits.length];\\n        \\n        for(int[] hit : hits) {\\n            grid[hit[0]][hit[1]] *= -1;\\n        }", "class Solution {\\n    int[][] dirs = new int[][]{{1,0}", "class Solution {\\n    int[] parents;\\n    int[] sizes;\\n    int m, n;\\n    \\n    private static final int[][] DIRECTIONS = {{1, 0}"]}
{"id": "1891", "ref_java": ["class Solution {\\n    private int[] nums;\\n    private int[] sums;\\n\\n    public boolean splitArraySameAverage(int[] nums) {\\n        int len = nums.length;\\n        if (len == 1) {\\n            return false;\\n        }", "class Solution {\\n    public boolean splitArraySameAverage(int[] nums) {\\n        int n = nums.length, sum = Arrays.stream(nums).sum();\\n        Set<Integer>[] a = new HashSet[n/2+1];\\n        Set<Integer>[] b = new HashSet[n/2+2];\\n        Arrays.setAll(a, o -> new HashSet<>());\\n        Arrays.setAll(b, o -> new HashSet<>());\\n        gen(0, n/2, 0, 0, nums, a);\\n        gen(n/2, n, 0, 0, nums, b);\\n        for (int i = 0; i < a.length; i++){ ", "class Solution {\\n    public boolean splitArraySameAverage(int[] nums) {\\n        int n = nums.length, sum = Arrays.stream(nums).sum();\\n        Set<Integer>[] a = new HashSet[n/2+1];\\n        Set<Integer>[] b = new HashSet[n/2+2];\\n        Arrays.setAll(a, o -> new HashSet<>());\\n        Arrays.setAll(b, o -> new HashSet<>());\\n        gen(0, n/2, 0, 0, nums, a);\\n        gen(n/2, n, 0, 0, nums, b);\\n        for (int i = 0; i < a.length; i++){ "]}
{"id": "1892", "ref_java": ["class Solution {\\n    public boolean xorGame(int[] nums) {\\n        int x = 0;\\n        for(int i=0;i<nums.length;i++){\\n            x^=nums[i];\\n        }", "class Solution {\\n    ", "class Solution {\\n    public boolean xorGame(int[] nums) {\\n        int x = 0;\\n        for(int i=0;i<nums.length;i++){\\n            x^=nums[i];\\n        }"]}
{"id": "1893", "ref_java": ["class Solution {\\n    public int numBusesToDestination(int[][] routes, int source, int target) {\\n        if (source == target) {\\n            return 0;\\n        }", "class Solution {\\n    public int numBusesToDestination(int[][] routes, int source, int target) {\\n        int len = routes.length;\\n        HashMap<Integer, List<Integer>> map = new HashMap();\\n        \\n        for(int i = 0; i < routes.length; i++)\\n        {\\n            for(int j = 0; j < routes[i].length; j++)\\n            {\\n                if(map.containsKey(routes[i][j]))\\n                {\\n                    List<Integer> current = map.get(routes[i][j]);\\n                    current.add(i);\\n                    map.put(routes[i][j], current);\\n                }", "class Solution {\\n    public int numBusesToDestination(int[][] routes, int source, int target) {\\n        Map<Integer, List<Integer>> stopToBuses = new HashMap<>();\\n\\n        for (int busId = 0; busId < routes.length; busId++) {\\n            for (int stop : routes[busId]) {\\n                stopToBuses.computeIfAbsent(stop, k -> new ArrayList<>()).add(busId);\\n            }"]}
{"id": "1894", "ref_java": ["class Solution {\\n   List<Integer[]> queue = new ArrayList<Integer[]>(); \\n   HashSet<Integer[]> visited = new HashSet<Integer[]>(); \\n   int moves, position, speed = 0;\\n    public int racecar(int target) {\\n          queue.add(new Integer[]{0,0,1}", "class Solution {\\n    public int racecar(int target) {\\n        \\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        HashSet<Pair<Integer, Integer>> visited = new HashSet<>();\\n        \\n        ", "class Solution {\\n\\t\\tpublic int racecar(int target) {\\n\\t\\t"]}
{"id": "1895", "ref_java": ["class Solution {\\n    public int largestIsland(int[][] grid) {\\n        int[] componentSizes = new int[grid.length * grid.length + 2];\\n        int max = 0;\\n        int id = 2;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 1) {\\n                    int[] size = new int[1];\\n                    dfs(grid, componentSizes, id, i, j);\\n                    if(componentSizes[id] > max){\\n                        max = componentSizes[id];\\n                    }", "class Solution {\\n    private boolean isValid(int adjr, int adjc, int n){\\n        return adjr >= 0 && adjr < n && adjc >= 0 && adjc < n;\\n    }", "class Solution {\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> regionsArea = new HashMap<>();\\n        regionsArea.put(0,0);\\n        \\n        int n = grid.length;\\n        int region = 2;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    int area = floodFill(grid, i, j, region);\\n                    regionsArea.put(region, area);\\n                    region++;\\n                }"]}
{"id": "1896", "ref_java": ["class Solution {\\n    public int uniqueLetterString(String s) {\\n        int n = s.length();\\n        ", "class Solution {\\n    public int uniqueLetterString(String s) {\\n        int n = s.length();\\n        int[] right = new int[n];\\n        int[] left = new int[26];\\n        Arrays.fill(left , n);\\n        Arrays.fill(right , n);\\n        int ans = 0 ;\\n        for(int i = n - 1; i >= 0 ; i--){\\n            int curr = s.charAt(i) - \\'A\\';\\n            right[i] = left[curr];\\n            left[curr] = i;\\n        }", "class Solution {\\n    public int uniqueLetterString(String s) {\\n        int n = s.length();\\n        "]}
{"id": "1897", "ref_java": ["class Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; i += 2) {\\n            count = 0;\\n            while (N % i == 0) {\\n                N /= i;\\n                count++;\\n            }", "class Solution {\\n\\n    public int consecutiveNumbersSum(int n) {\\n\\t    final double eightN = (8d * ((double) n)); ", "class Solution {\\n\\n    public int consecutiveNumbersSum(int n) {\\n\\t    final double eightN = (8d * ((double) n)); "]}
{"id": "1898", "ref_java": ["class Solution {\\n    int head[30010], end[60010], next[60010], idx;\\n    int siz[30010], n;\\n    vector<int> ans;\\n    void add (int a, int b) {\\n        end[idx] = b, next[idx] = head[a], head[a] = idx++;\\n    }", "class Solution {\\n    int head[30010], end[60010], next[60010], idx;\\n    int siz[30010], n;\\n    vector<int> ans;\\n    void add (int a, int b) {\\n        end[idx] = b, next[idx] = head[a], head[a] = idx++;\\n    }", "class Solution {\\n    int head[30010], end[60010], next[60010], idx;\\n    int siz[30010], n;\\n    vector<int> ans;\\n    void add (int a, int b) {\\n        end[idx] = b, next[idx] = head[a], head[a] = idx++;\\n    }"]}
{"id": "1899", "ref_java": ["class Solution {\\n    public int numSimilarGroups(String[] strs) {\\n        int n=strs.length, dsu[]=new int[n], cnt=n;\\n        for(int i=0;i<n;dsu[i]=i++);\\n        for(int i=0; i<n;i++){\\n            for(int j=i+1, l=0; j<n;l=0, j++) {\\n                for(int k=0;k<strs[i].length();k++)\\n                    if(strs[i].charAt(k)!=strs[j].charAt(k)) l++;\\n                if(l<=2 && find(i, dsu)!=find(j,dsu)) union(i ,j, dsu, --cnt);\\n            }", "class Solution {\\n    char[][] ss;\\n    public int numSimilarGroups(String[] strs) {\\n        int ans = 0;\\n    boolean[] seen = new boolean[strs.length];\\n\\n    ss = new char[strs.length][];\\n    for (int i = 0; i < strs.length; i++) \\n        ss[i] = strs[i].toCharArray();\\n\\n    for (int i = 0; i < strs.length; ++i)\\n      if (!seen[i]) {\\n        dfs(strs, i, seen);\\n        ++ans;\\n      }", "class Solution {\\n    public int numSimilarGroups(String[] strs) {\\n        int n = strs.length;  "]}
{"id": "1900", "ref_java": ["class Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random ran = new Random();\\n        ArrayList<String> possibles = new ArrayList<>();\\n        for (String word : wordlist){\\n            possibles.add(word);\\n        }", "class Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random ran = new Random();\\n        ArrayList<String> possibles = new ArrayList<>();\\n        for (String word : wordlist){\\n            possibles.add(word);\\n        }", "class Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random ran = new Random();\\n        ArrayList<String> possibles = new ArrayList<>();\\n        for (String word : wordlist){\\n            possibles.add(word);\\n        }"]}
{"id": "1901", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int shortestPathLength(int[][] graph) {\\n        int n=graph.length;\\n        Queue<int[]> q=new LinkedList<>(); ", "class Solution {\\n    public int shortestPathLength(int[][] graph) {\\n        int n = graph.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        List<Set<Integer>> dp = new ArrayList<>();\\n        for(int i = 0;i < n;i++)\\n            dp.add(new HashSet<>());\\n        int minPath = Integer.MAX_VALUE, targetBitMask = (int)Math.pow(2, n) - 1;\\n        for(int i = 0;i < n;i++){\\n            int bitMask = 1 << i;\\n            q.add(new int[]{i, bitMask, 0}"]}
{"id": "1902", "ref_java": ["class Solution {\\n    public int rectangleArea(int[][] A) {\\n        int ans = 0, L = 1, R = -1, px = 0, M = (int)1e9+7;\\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>(); ", "class Solution {\\n    public int rectangleArea(int[][] rectangles) {\\n        int n = rectangles == null ? 0 : rectangles.length;\\n        if (n == 0) return 0;\\n        long xmin = Long.MAX_VALUE;\\n        long ymin = Long.MAX_VALUE;\\n        long xmax = Long.MIN_VALUE;\\n        long ymax = Long.MIN_VALUE;\\n        for(int[] r: rectangles) {\\n            if (r[0] < xmin) xmin = r[0];\\n            if (r[1] < ymin) ymin = r[1];\\n            if (r[2] > xmax) xmax = r[2];\\n            if (r[3] > ymax) ymax = r[3];\\n        }", "class Solution {\\n\\n    "]}
{"id": "1903", "ref_java": ["class Solution {\\n    public int kSimilarity(String a, String b) {\\n        int ans = 0;\\n        char[] achars = a.toCharArray();\\n        char[] bchars = b.toCharArray();\\n        ans += getAllPerfectMatches(achars, bchars);\\n        for (int i = 0; i < achars.length; i++) {\\n            if (achars[i] == bchars[i]) {\\n                continue;\\n            }", "class Solution {\\n    public int kSimilarity(String s1, String tar) {\\n        Queue<String> q = new ArrayDeque<>();\\n        q.add(s1);\\n        \\n        int lvl = 0;\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                String s = q.remove();\\n                if(s.equals(tar))return lvl;\\n                \\n                \\n                int i = 0;\\n                while(s.charAt(i) == tar.charAt(i))i++;\\n                \\n                int j = i;\\n                \\n                while(j < s.length()){\\n                    if(s.charAt(j) == tar.charAt(i) && tar.charAt(j) != s.charAt(j)){\\n                        StringBuilder sb = new StringBuilder(s);\\n                        sb.setCharAt(i, s.charAt(j));\\n                        sb.setCharAt(j, s.charAt(i));\\n                        \\n\\t\\t\\t\\t\\t\\t", "class Solution {\\n    public int kSimilarity(String s1, String s2) {\\n        HashSet<String> vis = new HashSet<>();\\n        \\n        ArrayDeque<String> queue = new ArrayDeque<>();\\n        int level = 0;\\n        queue.add(s1);\\n        \\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                \\n                String rem = queue.remove();        "]}
{"id": "1904", "ref_java": ["class Solution {\\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\\n        int n = quality.length;\\n        Worker[] a = new Worker[n];\\n        for (int i = 0; i < n; ++i) {\\n            a[i] = new Worker(quality[i], wage[i]);\\n        }", "class Solution {\\n    \\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\\n        \\n        ArrayList<node> arr = new ArrayList<>();\\n        ", "class Solution {\\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\\n        double[][] workers = new double[wage.length][2];\\n        for(int i=0;i<wage.length;i++){\\n            workers[i][0] = (double)(wage[i])/quality[i];\\n            workers[i][1] = quality[i];\\n        }"]}
{"id": "1905", "ref_java": ["class Solution {\\n    public int shortestSubarray(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n+1];\\n        for(int i=0; i<n; i++)\\n            pref[i+1] = pref[i] + nums[i]; ", "class Solution {\\n    public int shortestSubarray(int[] nums, int k) {\\n        int len = nums.length;\\n\\t\\tlong[] sum = new long[len + 1];\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tsum[i + 1] = sum[i] + nums[i];\\n\\t\\t}", "class Solution {\\n    public int shortestSubarray(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n+1];\\n        for(int i=0; i<n; i++)\\n            pref[i+1] = pref[i] + nums[i]; "]}
{"id": "1906", "ref_java": ["class Solution {\\n    \\n    private char[][] grid;\\n    private static final int[] DIRS = {-1, 0, 1, 0, -1}", "class Solution {\\n    static final int START = -2;\\n    static final int WALL  = -1;\\n    static final int EMPTY = 0;\\n    static final int KEYS  = 1;     ", "class Solution {\\n  public int shortestPathAllKeys(String[] grid) {\\n    int y = grid.length, x = grid[0].length(), maskKeys = 0;\\n    int vis[][][] = new int[y][x][64];             "]}
{"id": "1907", "ref_java": ["class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel >= target) return 0;\\n        int[][] dp = new int[stations.length + 1][stations.length + 1];\\n        for (int i = 0; i < dp.length; i++) dp[i][0] = startFuel;\\n        for (int j = 1; j < dp.length; j++) {\\n            for (int i = j; i < dp.length; i++) {\\n                dp[i][j] = Math.max(dp[i-1][j], stations[i-1][0] > dp[i-1][j-1] ?\\n                        Integer.MIN_VALUE : dp[i-1][j-1] + stations[i-1][1]);\\n                if(dp[i][j] >= target) return j;\\n            }", "class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> fuelInStation = new PriorityQueue<>((x, y) -> (y - x));\\n        \\n        int res = 0;\\n        int fuel = startFuel;\\n        \\n        for (int[] station : stations) {\\n            while (fuel < station[0]) {\\n                if (fuelInStation.isEmpty()) return -1;\\n                fuel += fuelInStation.poll();\\n                res++;\\n            }", "class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> fuelInStation = new PriorityQueue<>((x, y) -> (y - x));\\n        \\n        int res = 0;\\n        int fuel = startFuel;\\n        \\n        for (int[] station : stations) {\\n            while (fuel < station[0]) {\\n                if (fuelInStation.isEmpty()) return -1;\\n                fuel += fuelInStation.poll();\\n                res++;\\n            }"]}
{"id": "1908", "ref_java": ["class Solution {\\n    public int nthMagicalNumber(int n, int a, int b) {\\n        \\n        long A = a, B = b;\\n        long mod = (long)(Math.pow(10,9)+7);\\n        \\n        \\n        long left = Math.min(a,b), right = (long)n*Math.min(a,b);\\n        \\n\\t\\t", "class Solution {\\n    public int nthMagicalNumber(int n, int a, int b) {\\n        \\n        long A = a, B = b;\\n        int mod =  1_000_000_007;               \\n        long l = Math.min(a,b), r = (long) n * Math.min(a, b);        \\t\\t\\t\\t\\n        while (B > 0) {\\n            long t = A;\\n            A = B;\\n            B = t % B;\\n        }", "class Solution {\\n    public int nthMagicalNumber(int n, int a, int b) {\\n        long A = a, B = b;\\n        long mod = (long)(Math.pow(10,9)+7);\\n        long left = Math.min(a,b), right = (long)n*Math.min(a,b);\\n        while (B > 0) {\\n            long tmp = A;\\n            A = B;\\n            B = tmp % B;\\n        }"]}
{"id": "1909", "ref_java": ["class Solution {\\n    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {\\n        int[][][] cache = new int[n+1][101][];\\n        for (int i = 0; i < cache.length; i++) {\\n            for (int j = 0; j < cache[0].length; j++) {\\n                int[] tmp = new int[101];\\n                Arrays.fill(tmp, -1);\\n                cache[i][j] = tmp;\\n            }", "class Solution {\\n    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {\\n        \\n        int mod = 1000000007;\\n        int[][][] dp = new int[group.length + 1][n + 1][minProfit + 1];\\n        dp[0][0][0] = 1;\\n        for (int i = 1; i <= group.length; i++) {\\n            int members = group[i - 1], earn = profit[i - 1];\\n            for (int j = 0; j <= n; j++) {\\n                for (int k = 0; k <= minProfit; k++) {\\n                    dp[i][j][k] = dp[i - 1][j][k];\\n                    if (j >= members) {\\n                        dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - members][Math.max(0, k - earn)]) % mod;\\n                    }", "class Solution {\\n    int MOD = 1_000_000_000 + 7;\\n\\n    int[] group, profit;\\n    int minProfit, totalCrimes;\\n\\n    Integer[][][] cache;\\n    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {\\n      this.group = group; this.profit = profit;\\n      this.minProfit = minProfit; this.totalCrimes = profit.length;\\n\\n      "]}
{"id": "1910", "ref_java": ["class Solution {\\n  public int reachableNodes(int[][] edges, int maxMoves, int n) {\\n    List<Pair<Integer, Integer>>[] graph = new List[n];\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]); ", "class Solution {\\n    public int reachableNodes(int[][] edges, int maxMoves, int n) {\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n        int[] dis = new int[n];\\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            dis[i] = Integer.MAX_VALUE;\\n            adj.add(new ArrayList<>());\\n        }", "class Solution {\\n    public int reachableNodes(int[][] edges, int maxMoves, int n) {\\n        int[][] graph = new int[n][n];\\n        for ( int[] t: graph ) {\\n            Arrays.fill(t, -1);\\n        }"]}
{"id": "1911", "ref_java": ["class Solution {\\n  public int superEggDrop(int k, int n) {\\n    ", "class Solution {\\n    public static int [][] t;\\n    public int superEggDrop(int k, int n) {\\n        t=new int[k+1][n+1];\\n        for(int [] i:t) Arrays.fill(i,-1);\\n        return solve(k,n);\\n    }", "class Solution {\\n    public int superEggDrop(int k, int n) {\\n  Integer[][] dp = new Integer[k+1][n+1];\\n        return superEggDropHelper(k, n, dp);\\n    }"]}
{"id": "1912", "ref_java": ["class Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}", "class Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}", "class Solution {\\n\\n    "]}
{"id": "1914", "ref_java": ["class Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }", "class Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }", "class Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        "]}
{"id": "1915", "ref_java": ["class Solution {\\n    public int atMostNGivenDigitSet(String[] digits, int n) {\\n        String N = Integer.toString(n);\\n        int ans=0;\\n        for(int i=1; i<= N.length(); ++i){\\n            if(N.equals(\"0\")){\\n                return 0;\\n            }", "class Solution {\\n    public int atMostNGivenDigitSet(String[] digits, int n) {\\n        String N = Integer.toString(n);\\n        int ans=0;\\n        for(int i=1; i<= N.length(); ++i){\\n            if(N.equals(\"0\")){\\n                return 0;\\n            }", "class Solution {\\n    public int atMostNGivenDigitSet(String[] digits, int n) {\\n        String N =  String.valueOf(n);\\n        int k =  N.length();\\n        int numsLen =digits.length;\\n        \\n        int count = 0;\\n        \\n\\t\\t"]}
{"id": "1916", "ref_java": ["class Solution {\\n    int mod = 1000000007;\\n    public int numPermsDISequence(String s) {\\n        int n=s.length();\\n        int cnt=0;\\n        boolean check[]=new boolean[n+1];\\n         Integer dp[][]=new Integer[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            check[i]=true;\\n            cnt+=fun(n-1,n,s.toCharArray(),i ,check, dp); cnt%=mod;\\n            check[i]=false;\\n        }", "class Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t}", "class Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t}"]}
{"id": "1917", "ref_java": ["class Solution {\\n    public int superpalindromesInRange(String left, String right) {\\n        int ans = 9 >= Long.parseLong(left) && 9 <= Long.parseLong(right) ? 1 : 0;\\n        for (int dig = 1; dig < 10; dig++) {\\n            boolean isOdd = dig % 2 > 0 && dig != 1;\\n            int innerLen = (dig >> 1) - 1,\\n                innerLim = Math.max(1, (int)Math.pow(2, innerLen)),\\n                midPos = dig >> 1, midLim = isOdd ? 3 : 1;\\n            for (int edge = 1; edge < 3; edge++) {\\n                char[] pal = new char[dig];\\n                Arrays.fill(pal, \\'0\\');\\n                pal[0] = (char)(edge + 48);\\n                pal[dig-1] = (char)(edge + 48);\\n                if (edge == 2) {\\n                    innerLim = 1;\\n                    midLim = Math.min(midLim, 2);\\n                }", "class Solution {\\n    public int superpalindromesInRange(String left, String right) {\\n        int ans = 9 >= Long.parseLong(left) && 9 <= Long.parseLong(right) ? 1 : 0;\\n  \\n        for (int dig = 1; dig < 10; dig++) {\\n            boolean isOdd = dig % 2 > 0 && dig != 1;\\n            int innerLen = (dig >> 1) - 1,\\n                innerLim = Math.max(1, (int)Math.pow(2, innerLen)),\\n                midPos = dig >> 1, midLim = isOdd ? 3 : 1;\\n            for (int edge = 1; edge < 3; edge++) {\\n                char[] pal = new char[dig];\\n                Arrays.fill(pal, \\'0\\');\\n                pal[0] = (char)(edge + 48);\\n                pal[dig-1] = (char)(edge + 48);\\n                if (edge == 2) {\\n                    innerLim = 1;\\n                    midLim = Math.min(midLim, 2);\\n                }", "class Solution {\\n\\n    "]}
{"id": "1918", "ref_java": ["class Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n\\n        int[] nonZeroNeighbor = new int[n];\\n        for(int i = 0; i < n; i++){\\n            nonZeroNeighbor[i] = graph[i].length;\\n            for(int neighbor : graph[i]){\\n                if(neighbor == 0){\\n                    nonZeroNeighbor[i]--;\\n                    break;\\n                }", "class Solution {\\n    private int M;\\n    Integer memo[][][];\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        M = 4*n + 200; ", "class Solution {\\n    public static final int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\\n    public static final int MOUSE_TURN = 0, CAT_TURN = 1;\\n    public static final int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\\n    private int n;\\n    private int[][] graph;\\n    private int[][][] degrees;\\n    private int[][][] results;\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.n = graph.length;\\n        this.graph = graph;\\n        this.degrees = new int[n][n][2];\\n        this.results = new int[n][n][2];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                degrees[i][j][MOUSE_TURN] = graph[i].length;\\n                degrees[i][j][CAT_TURN] = graph[j].length;\\n            }"]}
{"id": "1919", "ref_java": ["class Solution {\\n\\n    private long[][] dp;\\n    private int k;\\n    private int n;\\n    private int mod = 1000000007;\\n\\n    public int numMusicPlaylists(int n, int goal, int k) {\\n        dp = new long[n+1][goal+1];\\n        this.k = k;\\n        this.n = n;\\n        for (int i = 0; i < n + 1; i ++) {\\n            Arrays.fill(dp[i], -1L);\\n        }", "class Solution {\\n    int n, goal, k;\\n    long[][] memo;\\n    int MOD = 1_000_000_000 + 7;\\n    public int numMusicPlaylists(int n, int goal, int k) {\\n        this.n = n;\\n        this.goal = goal;\\n        this.k = k;\\n        memo = new long[goal+1][n+1];\\n        for(int i=0; i<goal+1; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }", "class Solution {\\n    public int numMusicPlaylists(int n, int goal, int k) {\\n        final int MOD = (int)1e9 + 7;\\n        long[][] dp = new long[2][n+1];\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= goal; i++) {\\n            dp[i%2][0] = 0;\\n            for (int j = 1; j <= Math.min(i, n); j++) {\\n                dp[i%2][j] = dp[(i - 1)%2][j - 1] * (n - (j - 1)) % MOD;\\n                if (j > k)\\n                    dp[i%2][j] = (dp[i%2][j] + dp[(i - 1)%2][j] * (j - k)) % MOD;\\n            }"]}
{"id": "1920", "ref_java": ["class Solution {\\n    public int minMalwareSpread(int[][] graph, int[] initial) {\\n        int N = graph.length;\\n        DSU dsu = new DSU(N);\\n\\n        for(int i=0;i<N;i++){\\n            for(int j=i+1;j<N;j++){\\n                if(graph[i][j]==1 || graph[j][i]==1)\\n                    dsu.union(i,j);\\n            }", "class Solution {\\n    private int dfs(int[][] graph, int u, boolean[] visited, boolean[] initial) {\\n        if(initial[u]) return 0;\\n        visited[u] = true;\\n        int count = 1;\\n        for(int v = 0; v < graph[u].length; v++) {\\n            if(!visited[v] && graph[u][v] == 1) {\\n                int c = dfs(graph, v, visited, initial);\\n                if(c == 0) return 0;\\n                count += c;\\n            }", "class Solution {\\n    private int findPar(int i, int[] par) {\\n        if (i == par[i]) return i;\\n        return par[i] = findPar(par[i], par);\\n    }"]}
{"id": "1921", "ref_java": ["class Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1}", "class Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int oneSum = 0;\\n        for(int x : arr) oneSum +=x;\\n        if(oneSum % 3 !=0)return new int[]{-1,-1}", "class Solution {\\n    public int[] threeEqualParts(int[] arr) {\\n        int totalOnes = 0;\\n        for(int e:arr){\\n            if(e==1){\\n                totalOnes++;\\n            }"]}
{"id": "1922", "ref_java": ["class Solution {\\n    private int dfs(int[][] graph, int u, boolean[] visited, boolean[] infected) {\\n        if(infected[u]) return 0;\\n        visited[u] = true;\\n        int count = 1;\\n        for(int v = 0; v < graph[u].length; v++) {\\n            if(!visited[v] && graph[u][v] == 1) {\\n                int c = dfs(graph, v, visited, infected);\\n                if(c == 0) {\\n                    infected[u] = true;\\n                    return 0;\\n                }", "class Solution {\\n    private int dfs(int[][] graph, int u, boolean[] visited, boolean[] infected) {\\n        if(infected[u]) return 0;\\n        visited[u] = true;\\n        int count = 1;\\n        for(int v = 0; v < graph[u].length; v++) {\\n            if(!visited[v] && graph[u][v] == 1) {\\n                int c = dfs(graph, v, visited, infected);\\n                if(c == 0) {\\n                    infected[u] = true;\\n                    return 0;\\n                }", "class Solution {\\n    private int dfs(int[][] graph, int u, boolean[] visited, boolean[] infected) {\\n        if(infected[u]) return 0;\\n        visited[u] = true;\\n        int count = 1;\\n        for(int v = 0; v < graph[u].length; v++) {\\n            if(!visited[v] && graph[u][v] == 1) {\\n                int c = dfs(graph, v, visited, infected);\\n                if(c == 0) {\\n                    infected[u] = true;\\n                    return 0;\\n                }"]}
{"id": "1923", "ref_java": ["class Solution {\\n    public int[] movesToStamp(String stamp, String target) {\\n        char[] S = stamp.toCharArray();\\n        char[] T = target.toCharArray();\\n        List<Integer> res = new ArrayList<>();\\n        boolean[] visited = new boolean[T.length];\\n        int stars = 0;\\n        \\n        while (stars < T.length) {\\n            boolean doneReplace = false;\\n            for (int i = 0; i <= T.length - S.length; i++) {\\n                if (!visited[i] && canReplace(T, i, S)) {\\n                    stars = doReplace(T, i, S.length, stars);\\n                    doneReplace = true;\\n                    visited[i] = true;\\n                    res.add(i);\\n                    if (stars == T.length) {\\n                        break;\\n                    }", "class Solution {\\n    public int[] movesToStamp(String S, String T) {\\n        if (S == T) return new int[]{0}", "class Solution {\\n    "]}
{"id": "1924", "ref_java": ["class Solution {\\n    int q = 1000000007;\\n    public int distinctSubseqII(String s) {\\n        int[] hash = new int[26]; ", "class Solution {\\n    public int distinctSubseqII(String s) {\\n        int mod = (int) 1e9 + 7;\\n        int n = s.length();\\n        int[] record4DeDup = new int[26];\\n        int curRes = 1;", "class Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public long helper(char[] arr, int i, Long[] dp) {\\n        if(i>=arr.length) return 0;\\n        if(dp[i] != null) return dp[i];\\n        Set<Character> set = new HashSet<>();\\n        long ans = 0;\\n        for(int j=i;j<arr.length;j++) {\\n            if(set.contains(arr[j])) continue;\\n            set.add(arr[j]);\\n            ans = (ans%MOD + 1 + helper(arr, j+1, dp)%MOD)%MOD;\\n        }"]}
{"id": "1925", "ref_java": ["class Solution {\\n    public String shortestSuperstring(String[] words) {\\n        int n = words.length;\\n        int[][] mat = new int[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i+1; j < n; j++) {\\n                mat[i][j] = dist(words[i], words[j]);\\n                mat[j][i] = dist(words[j], words[i]);\\n            }", "class Solution {\\n    public String shortestSuperstring(String[] words) {\\n        int n = words.length;\\n        int[][] discount = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                for (int k = 0; k < words[i].length()&&i!=j; k++){ ", "class Solution {\\n    public String shortestSuperstring(String[] words) {\\n        "]}
{"id": "1926", "ref_java": ["class Solution {\\n    public int gcd(int a, int b) {\\n        if(a < b) {\\n            int h = a;\\n            a = b;\\n            b = h;\\n        }", "class Solution {\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int x = nums[0];\\n        for (int num : nums)\\n            x = Math.max(x, num);\\n        DSU dsu = new DSU(x + 1);\\n        \\n        for (int num : nums) {\\n            for (int i = 2; i * i <= num; i++) {\\n                if (num % i == 0) {\\n                    dsu.union(num, i);\\n                    dsu.union(num, num/i);\\n                }", "class Solution {\\n    int parent [];\\n    int size [];\\n    public int largestComponentSize(int[] nums) {\\n     int max = nums[0] ;\\n     HashMap<Integer,HashSet<Integer>> primeFactors = new HashMap<>();\\n     for(int val : nums)   max = Math.max(max,val);\\n     int seive [] = new int[max + 1];\\n     parent = new int[max + 1];\\n     size  = new int[max + 1];\\n\\n     for(int i = 0; i < seive.length ; i++)   parent[i] = seive[i] = i;\\n\\n     for(int i = 2; i*i < seive.length ; i++){\\n         if(seive[i] == i){\\n             for(int j = i; j < seive.length ; j+=i){\\n                 if(seive[j] == j) seive[j] = i;\\n             }"]}
{"id": "1927", "ref_java": ["class Solution {\\n    \\n    public int tallestBillboard(int[] rods) {\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for (int rod : rods) {\\n            sum += rod;\\n        }", "class Solution {\\n    public int tallestBillboard(int[] rods) {\\n        int[] dp = new int[5001];\\n        for (int d = 1; d < 5001; d++) dp[d] = -10000;\\n        for (int x : rods) {\\n            int[] cur = dp.clone();\\n            for (int d = 0; d + x < 5001; d++) {\\n                dp[d + x] = Math.max(dp[d + x], cur[d]);\\n                dp[Math.abs(d - x)] = Math.max(dp[Math.abs(d - x)], cur[d] + Math.min(d, x));\\n            }", "class Solution {\\n    public int tallestBillboard(int[] rods) {\\n        int sum = 0;\\n        for (int rod : rods) {\\n            sum += rod;\\n        }"]}
{"id": "1928", "ref_java": ["class Solution {\\n    public int minDeletionSize(String[] strs) {\\n    \\n        int length = strs[0].length();\\n        int[] dp = new int[length];\\n        \\n        int max = 0;\\n        for (int i = 0; i < length; i++){\\n            dp[i] = 1;\\n            for (int j = 0; j < i; j++){\\n                if (checkLager(j,i, strs)){\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }", "class Solution {\\npublic int minDeletionSize(String[] strs) {\\n    int n = strs.length;\\n    int m = strs[0].length();\\n    int[] dp = new int[m];\\n    \\n    int overallMax = 0;\\n    for(int i=0;i<m;i++){\\n        dp[i] = 1;\\n        for(int j=0;j<i;j++){\\n            \\n            if(isValid(strs,i,j)){\\n                dp[i] = Math.max(dp[i],dp[j]+1);\\n            }", "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n    \\n        int length = strs[0].length();\\n        int[] dp = new int[length];\\n        \\n        int max = 0;\\n        for (int i = 0; i < length; i++){\\n            dp[i] = 1;\\n            for (int j = 0; j < i; j++){\\n                if (checkLager(j,i, strs)){\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }"]}
{"id": "1929", "ref_java": ["class Solution {\\n    public int leastOpsExpressTarget(int x, int y) {\\n        int pos = 0, neg = 0, k = 0, pos2, neg2, cur;\\n        while (y > 0) {\\n            cur = y % x;\\n            y /= x;\\n            if (k > 0) {\\n                pos2 = Math.min(cur * k + pos, (cur + 1) * k + neg);\\n                neg2 = Math.min((x - cur) * k + pos, (x - cur - 1) * k + neg);\\n                pos = pos2;\\n                neg = neg2;\\n            }", "class Solution {\\n\\n    ", "class Solution {\\n    public int leastOpsExpressTarget(int x, int y) {\\n        int pos = 0, neg = 0, k = 0, pos2, neg2, cur;\\n        while (y > 0) {\\n            cur = y % x;\\n            y /= x;\\n            if (k > 0) {\\n                pos2 = Math.min(cur * k + pos, (cur + 1) * k + neg);\\n                neg2 = Math.min((x - cur) * k + pos, (x - cur - 1) * k + neg);\\n                pos = pos2;\\n                neg = neg2;\\n            }"]}
{"id": "1930", "ref_java": ["class Solution {\\n    int count = 0;\\n    public int dfs(TreeNode root){\\n        \\n         if(root == null) return 1;\\n        if(root.left == null && root.right== null) return -1;\\n       \\n       int  l= dfs(root.left);\\n       int  r = dfs(root.right); \\n        if(l==-1 || r == -1){\\n            count++;\\n            return 0;\\n        }", "class Solution {\\n    \\n    int NOT_NEEDED = 2;\\n    int NEED = 1;\\n    int COVERED = 0;\\n    int res = 0;\\n    public int minCameraCover(TreeNode root) {\\n        return (dfs(root) < 1 ? 1 : 0) + res;\\n    }", "class Solution {\\n    int res = 0;\\n    public int minCameraCover(TreeNode root) \\n    {\\n        return (dfs(root) < 1 ? 1 : 0) + res;\\n    }"]}
{"id": "1931", "ref_java": ["class Solution {\\n  public boolean isRationalEqual(String s, String t) {\\n    return Math.abs(valueOf(s) - valueOf(t)) < 1e-9;\\n  }", "class Solution {\\n\\n    public boolean isRationalEqual(String s, String t) {\\n        String[] ss = s.split(\"\\\\\\\\.\");\\n        String[] tt = t.split(\"\\\\\\\\.\");\\n        String s0 = ss[0];\\n        String t0 = tt[0];\\n\\n        String s1 = ss.length == 1 ? \"\" : ss[1];\\n        String t1 = tt.length == 1 ? \"\" : tt[1];\\n\\n        int s0N = s0.length();\\n        int t0N = t0.length();\\n\\n        int s1N = s1.length();\\n        int t1N = t1.length();\\n        if (!s0.equals(t0)) { ", "class Solution {\\n    public boolean isRationalEqual(String s, String t) {\\n        s = expand(s);\\n        t = expand(t);\\n\\n        BigDecimal ds = new BigDecimal(s);\\n        BigDecimal dt = new BigDecimal(t);\\n\\n        BigDecimal re = new BigDecimal(\"1E-10\");\\n        BigDecimal rr = ds.compareTo(dt) == 1 ? ds.subtract(dt) : dt.subtract(ds);\\n\\n        if (ds.compareTo(dt) == 0 || rr.equals(re)) {\\n            return true;\\n        }"]}
{"id": "1932", "ref_java": ["class Solution {\\n    public int oddEvenJumps(int[] arr) {\\n        int[] count = new int[100001];\\n        boolean[][] res = new boolean[2][arr.length];\\n        res[0][arr.length - 1] = true;\\n        res[1][arr.length - 1] = true;\\n        count[arr[arr.length - 1]] = arr.length;\\n        int min = arr[arr.length - 1], max = arr[arr.length - 1];\\n        int result = 1;\\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            int nextSmallIndex = findNextSmall(count, min, max, arr[i]);\\n            int nextLargeIndex = findNextLarge(count, min, max, arr[i]);\\n            if(nextSmallIndex == -1) {\\n                res[0][i] = false;\\n            }", "class Solution {\\n    public int oddEvenJumps(int[] arr) {\\n        TreeMap<Integer,Integer> tm = new TreeMap<>();\\n        int ind = 0;\\n        \\n\\n        int oddArr[] = new int[arr.length]; ", "class Solution {\\n    public int oddEvenJumps(int[] arr) {\\n        "]}
{"id": "1933", "ref_java": ["class Solution {\\n    static int count=0;\\n    static int[] dx = {-1, 0, 1, 0}", "class Solution {\\n    private int dfs(int[][] grid, int x, int y, int zero){\\n        if(x>=grid.length || y >= grid[0].length || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }", "class Solution {\\npublic int uniquePathsIII(int[][] grid) {\\n\\t\\tint noOfEmptySquares = 0;\\n\\t\\tint startingSquareRow = 0;\\n\\t\\tint startingSquareColumn = 0;\\n\\n\\t\\t"]}
{"id": "1934", "ref_java": ["class Solution {\\n    public int countTriplets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }", "class Solution {\\n    public int countTriplets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }", "class Solution {\\n    public int countTriplets(int[] nums) {\\n        \\n        "]}
{"id": "1935", "ref_java": ["class Solution {\\n    List<Putin> list = new ArrayList<>();\\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\\n        inOrder(root, 0, 0);\\n        return result();\\n    }", "class Solution {\\n    Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> levelItems; \\n    int minIndex, maxIndex;\\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\\n        if (root == null) return new ArrayList<>();\\n        \\n        this.levelItems = new HashMap<>();\\n        this.minIndex = Integer.MAX_VALUE;\\n        this.maxIndex = Integer.MIN_VALUE;\\n\\n        dfs(root, 0, 0);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = minIndex; i <= maxIndex; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            TreeMap<Integer, PriorityQueue<Integer>> treeMap = levelItems.get(i);\\n            for (int row : treeMap.keySet()) {\\n                PriorityQueue<Integer> pq = treeMap.get(row);\\n                while (!pq.isEmpty()) {\\n                    innerList.add(pq.poll());\\n                }", "class Solution {\\n\\n    "]}
{"id": "1936", "ref_java": ["class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return helper(nums, k) - helper(nums, k-1);\\n    }", "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n        \\n    }", "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return helper(nums, k) - helper(nums, k-1);\\n    }"]}
{"id": "1937", "ref_java": ["class Solution {\\n        public int minKBitFlips(int[] A, int K) {\\n            int n = A.length, flipped = 0, res = 0;\\n            int[] isFlipped = new int[n];\\n            for (int i = 0; i < A.length; ++i) {\\n                if (i >= K)\\n                    flipped ^= isFlipped[i - K];\\n                if (flipped == A[i]) {\\n                    if (i + K > A.length)\\n                        return -1;\\n                    isFlipped[i] = 1;\\n                    flipped ^= 1;\\n                    res++;\\n                }", "class Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n            if (bit == 0) {\\n                ", "class Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int target = 0, ans = 0;;\\n        boolean[] flip = new boolean[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            if (flip[i]){\\n                target^=1;\\n            }"]}
{"id": "1938", "ref_java": ["class Solution {\\n    public int numSquarefulPerms(int[] nums) {\\n        return permutate(nums, 0);\\n    }", "class Solution {\\n    public int numSquarefulPerms(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] res = new int[]{0}", "class Solution {\\n    int count;\\n    public int numSquarefulPerms(int[] nums) {\\n        int n = nums.length;\\n        if(n<2)\\n            return count;\\n        backtrack(nums,n,0);\\n        return count;\\n        \\n    }"]}
{"id": "1939", "ref_java": ["class Solution {\\n    int prefix[];\\n    public int mergeStones(int[] stones, int k) {\\n        int n=stones.length;\\n        if((n-1)%(k-1) != 0) return -1;\\n        prefix=new int[stones.length+1];\\n        prefix[0]=0;\\n        int sum=0;\\n        for(int i=0;i<stones.length;i++){\\n            sum+=stones[i];\\n            prefix[i+1]=sum;\\n        }", "class Solution {\\n    public int mergeStones(int[] stones, int K) {\\n        final int LEN = stones.length;\\n        int[][] dp = new int[LEN + 1][LEN + 1];\\n        int[] prefixSum = new int[LEN + 1];\\n        \\n        ", "class Solution {\\n    public int mergeStones(int[] stones, int k) {\\n        int n = stones.length;\\n        if((n-k) % (k-1) != 0)\\n            return -1;\\n\\n        int[] prefixSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + stones[i - 1];\\n        }"]}
{"id": "1940", "ref_java": ["class Solution {\\n    private int n;\\n    private HashMap<Integer, Integer> rowIllum;\\n    private HashMap<Integer, Integer> colIllum;\\n    private HashMap<Integer, Integer> dia1Illum;\\n    private HashMap<Integer, Integer> dia2Illum;\\n    private HashMap<Integer, ArrayList<Integer>> lamps;\\n\\n    public boolean isIlluminated(int x, int y) {\\n        return rowIllum.getOrDefault(x, 0) > 0 || colIllum.getOrDefault(y, 0) > 0 || \\n                dia1Illum.getOrDefault(x - y, 0) > 0 || dia2Illum.getOrDefault(x + y, 0) > 0;\\n    }", "class Solution {\\n    private int n;\\n    private HashMap<Integer, Integer> rowIllum;\\n    private HashMap<Integer, Integer> colIllum;\\n    private HashMap<Integer, Integer> dia1Illum;\\n    private HashMap<Integer, Integer> dia2Illum;\\n    private HashMap<Integer, ArrayList<Integer>> lamps;\\n\\n    public boolean isIlluminated(int x, int y) {\\n        return rowIllum.getOrDefault(x, 0) > 0 || colIllum.getOrDefault(y, 0) > 0 || \\n                dia1Illum.getOrDefault(x - y, 0) > 0 || dia2Illum.getOrDefault(x + y, 0) > 0;\\n    }", "class Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[] {0, 1}"]}
{"id": "1941", "ref_java": ["class Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }", "class Solution {\\n    Integer[][][][] dp;\\n    private int solve(char[] num, int curDig, boolean isStrict, int bit, boolean repeated) {\\n        if(curDig == num.length) return repeated ? 1 : 0;\\n        if(dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] != null) return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0];\\n        int end = isStrict ? num[curDig] - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            if(bit == 0 && i == 0) \\n                res += solve(num, curDig + 1, isStrict && i == end, bit, repeated);\\n            else\\n                res += solve(num, curDig + 1, isStrict && i == end, bit | (1 << i), repeated | (bit & (1 << i)) != 0);\\n        }", "class Solution {\\n    Integer[][][][] dp;\\n    private int solve(char[] num, int curDig, boolean isStrict, int bit, boolean repeated) {\\n        if(curDig == num.length) return repeated ? 1 : 0;\\n        if(dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] != null) return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0];\\n        int end = isStrict ? num[curDig] - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            if(bit == 0 && i == 0) \\n                res += solve(num, curDig + 1, isStrict && i == end, bit, repeated);\\n            else\\n                res += solve(num, curDig + 1, isStrict && i == end, bit | (1 << i), repeated | (bit & (1 << i)) != 0);\\n        }"]}
{"id": "1942", "ref_java": ["class Solution {\\n\\tStack<Tup<TreeNode, Integer>> stack = new Stack<>();\\n\\tTreeNode root = new TreeNode();\\n\\tTup<ArrayList<Integer>, ArrayList<Integer>> content;\\n\\tint n;\\n\\n\\tpublic TreeNode recoverFromPreorder(String traversal) {\\n\\t\\tcontent = modify(traversal);\\n\\t\\tn = content.first.size();\\n\\t\\tstack.push(new Tup<>(root, -1));\\n\\t\\tbuild(0);\\n\\t\\treturn root.left;\\n\\t}", "class Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return traverse(traversal,0);\\n    }", "class Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(!traversal.contains(\"-\"))\\n            return new TreeNode(Integer.parseInt(traversal));\\n        String number = \"\";\\n        int i = 0;\\n        while(traversal.charAt(i)!=\\'-\\'){\\n            number+=traversal.charAt(i);\\n            i++;\\n        }"]}
{"id": "1944", "ref_java": ["class Solution {\\n    \\n    int[]source;\\n    int[]target;\\n    int xmin;\\n    int xmax;\\n    int ymin;\\n    int ymax;\\n    HashSet<Node>blocks;\\n    HashSet<Node>been;\\n    LinkedList<Integer>vertical;\\n    LinkedList<Integer>horizontal;\\n    int[][]neigh={{-1,-1}", "class Solution {\\n\\n    private static final int TOTAL_ROWS = (int) Math.pow(10, 6);\\n    private static final int TOTAL_COLUMNS = TOTAL_ROWS;\\n    private static final int[][] MOVES = {{1, 0}", "class Solution {\\n\\n    private static final int TOTAL_ROWS = (int) Math.pow(10, 6);\\n    private static final int TOTAL_COLUMNS = TOTAL_ROWS;\\n    private static final int[][] MOVES = {{1, 0}"]}
{"id": "1945", "ref_java": ["class Solution {\\n    public String longestDupSubstring(String S) {\\n        String ans = \"\";\\n        \\n        int left = 1;\\n        int right = S.length()-1;\\n        \\n        while(left <= right){\\n            int m = left + (right - left)/2;\\n            \\n            String dup = getDup(m,S);\\n            \\n            if(dup != null){\\n                ans = dup;\\n                left = m+1;\\n            }", "class Solution {\\n    public String longestDupSubstring(String s) {\\n        int left=1;\\n        int right=s.length()-1;\\n        \\n        String result=\"\";\\n        while(left<=right){\\n            int mid=left + (right-left)/2;\\n             \\n            String str=rabinKarp(s,mid);\\n            if(str.length()!=0){\\n                result=str;\\n                left=mid+1;\\n            }", "class Solution {\\n    static final int CHAR_BASE = \\'a\\';   "]}
{"id": "1946", "ref_java": ["class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        ", "class Solution {\\n\\tpublic int numSubmatrixSumTarget(int[][] arr, int target) {\\n\\t\\tint n = arr.length;\\n\\t\\tint m = arr[0].length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[m];\\n\\t\\t\\tfor (int row = i; row < n; row++) {\\n\\t\\t\\t\\tfor (int col = 0; col < m; col++) {\\n\\t\\t\\t\\t\\ttemp[col] += arr[row][col];\\n\\t\\t\\t\\t}", "class Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }"]}
{"id": "1947", "ref_java": ["class Solution {\\n\\n    static String dp[][];\\n\\n    static String LCS(String s1, String s2, int i, int j){  \\n\\n        if(i>=s1.length() || j>=s2.length()){\\n            return \"\";\\n        }", "class Solution {\\n    public String lcs(String s1, String s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        int dp[][]=new int[m+1][n+1];\\n    \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }", "class Solution {\\n    public String lcs(String s1, String s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        int dp[][]=new int[m+1][n+1];\\n    \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }"]}
{"id": "1948", "ref_java": ["class Solution {\\n    public int findInMountainArray(int B, MountainArray A) {\\n        int n = A.length();\\n        int maxPosition = -1;\\n        int left = 1;\\n        int right = n-2;\\n        int mid;\\n        while(left<right){\\n            mid = left + (right-left)/2;\\n            if(A.get(mid)<A.get(mid+1)){\\n                left = mid +1;\\n            }", "class Solution {\\n    public int findInMountainArray(int target, MountainArray mountainArr) {\\n        ", "class Solution {\\n\\n    public int findpeek(MountainArray mountainArr){\\n        int si = 0;\\n        int ei = mountainArr.length()-1;\\n        int index = -1;\\n        while(si <= ei){\\n            int mid = si + (ei-si)/2;\\n            if(mountainArr.get(mid) <= mountainArr.get(mid+1)){\\n                si = mid+1;\\n            }"]}
{"id": "1949", "ref_java": ["class Solution {\\n    public List<String> braceExpansionII(String A) {\\n        Deque<Set<String>> stack = new ArrayDeque<>();\\n        Deque<Character> opStack = new ArrayDeque<>();\\n        StringBuilder sb = new StringBuilder();\\n        int[] order = new int[128];\\n        order[\\'x\\']=1; ", "class Solution {\\n    public List<String> braceExpansionII(String expression) {\\n        Set<String> s = new HashSet<>();\\n        Queue<String> q = new LinkedList<>();\\n        q.add(expression);\\n\\n        while (!q.isEmpty()) {\\n            String temp = q.poll();\\n            int left = -1, right = 0;\\n            while (right < temp.length() && temp.charAt(right) != \\'}", "class Solution {\\n    public List<String> braceExpansionII(String expression) {\\n        \\n\\t\\t"]}
{"id": "1950", "ref_java": ["class Solution {\\n    \\n    int pos = 0;\\n    \\n    public boolean parseBoolExpr(String s) {\\n        pos = 0;\\n        return solve(s, \\'-\\');\\n    }", "class Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Boolean> stack = new ArrayDeque<>(); ", "class Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c: expression.toCharArray()) {\\n            "]}
{"id": "1951", "ref_java": ["class Solution {\\n    int[][] dp;\\n    boolean[][] choice;\\n    int req_mask, m;\\n\\n    public int solve(List<Integer> people, int i, int mask) {\\n        if (mask == req_mask)\\n            return 0;\\n        if (i == m)\\n            return 10000;\\n        if (dp[mask][i] != -1)\\n            return dp[mask][i];\\n        int ans1 = solve(people, i + 1, mask | people.get(i)) + 1;\\n        int ans2 = solve(people, i + 1, mask);\\n        if (ans1 < ans2)\\n            choice[mask][i] = true;\\n        return dp[mask][i] = Math.min(ans1, ans2);\\n    }", "class Solution {\\n    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < req_skills.length; i++) {\\n            String s = req_skills[i];\\n            map.put(s, i);\\n        }", "class Solution {\\n    List<Integer> mainTeam = new ArrayList<>();\\n    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int i = 0;\\n        for( String skill : req_skills) \\n            map.put(skill,i++);\\n\\n        int reqSkills = (1<<i) -1;\\n        "]}
{"id": "1952", "ref_java": ["class Solution {\\n    public int longestDecomposition(String text) {\\n        String l=\"\",r=\"\";\\n        int c=0;\\n        for(int i=0;i<text.length();i++){\\n            l=l+text.charAt(i);\\n            r=text.charAt(text.length()-i-1)+r;\\n            if(l.equals(r)){\\n                c++;\\n                l=\"\";\\n                r=\"\";\\n            }", "class Solution {\\n    public int longestDecomposition(String text) {\\n        String l=\"\",r=\"\";\\n        int c=0;\\n        for(int i=0;i<text.length();i++){\\n            l=l+text.charAt(i);\\n            r=text.charAt(text.length()-i-1)+r;\\n            if(l.equals(r)){\\n                c++;\\n                l=\"\";\\n                r=\"\";\\n            }", "class Solution {\\n     public int longestDecomposition(String text) {\\n        int n = text.length();   \\n        for (int i = 0; i < n/2; i++) \\n            if (text.substring(0, i + 1).equals(text.substring(n-1-i, n))) \\n                return 2+longestDecomposition(text.substring(i+1, n-1-i));\\n        return (n==0)?0:1;\\n    }"]}
{"id": "1954", "ref_java": ["class Solution {\\n\\n    public String lastSubstring(String s) {\\n    int maxIndex = s.length() - 1;\\n    \\n    for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n        if(s.charAt(currIndex) > s.charAt(maxIndex))\\n            maxIndex = currIndex;\\n            \\n        else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n            int i = currIndex + 1;\\n            int j = maxIndex + 1;\\n            \\n            \\n            while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public String lastSubstring(String s) {\\n        int xStart = 0, yStart = 1, len = 0;\\n        int sLen = s.length();\\n\\n        while(xStart < sLen && yStart < sLen && len < sLen) {\\n            if(xStart + len >= sLen || yStart + len >= sLen) {\\n                break;\\n            }", "class Solution {\\n    public String lastSubstring(String s) {\\n        int i = 0;\\n        int j = 1;\\n        int k = 0;\\n        int n = s.length();\\n        char[] ca = s.toCharArray();\\n\\n        while (j + k < n){\\n            if (ca[i + k] == ca[j + k]) {\\n                k++;\\n            }"]}
{"id": "1956", "ref_java": ["class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }", "class Solution {\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }", "class Solution {\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }"]}
{"id": "1957", "ref_java": ["class Solution {\\n    \\n    HashMap<Integer, Integer> dp[];\\n    TreeSet<Integer> ts;\\n    \\n    int makeArrayIncr(int i, int prev, int[] arr1) {\\n        \\n        if(i == arr1.length) return 0;\\n        \\n        if(dp[i].containsKey(prev)) return dp[i].get(prev);\\n        \\n        int notswap = 5000;\\n        \\n        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);\\n        \\n        int swap = 5000;\\n        \\n        Integer curr = ts.higher(prev);\\n        \\n        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);\\n        \\n        dp[i].put(prev, Math.min(swap, notswap));\\n        \\n        ", "class Solution { \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr2);\\n        \\n        int answer = helper(0, -1, arr1, arr2);\\n        \\n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\\n    }", "class Solution {\\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n         Arrays.sort(arr2);\\n\\n        int answer = dfs(0, -1, arr1, arr2);\\n\\n        return answer < 2001 ? answer : -1;\\n    }"]}
{"id": "1958", "ref_java": ["class Solution {\\n    int[] disc, low;\\n    int time = 1;\\n    List<List<Integer>> ans = new ArrayList<>();\\n    Map<Integer,List<Integer>> edgeMap = new HashMap<>();\\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\\n        disc = new int[n];\\n        low = new int[n];\\n        for (int i = 0; i < n; i++)\\n            edgeMap.put(i, new ArrayList<Integer>());\\n        for (List<Integer> conn : connections) {\\n            edgeMap.get(conn.get(0)).add(conn.get(1));\\n            edgeMap.get(conn.get(1)).add(conn.get(0));\\n        }", "class Solution {\\nprivate:\\n    int timer = 1;\\n    void dfs(int node, int parent, vector<int> &vis,\\n             vector<int> adj[], int tin[], int low[], vector<vector<int>> &bridges) {\\n        vis[node] = 1;\\n        tin[node] = low[node] = timer;\\n        timer++;\\n        for (auto it : adj[node]) {\\n            if (it == parent) continue;\\n            if (vis[it] == 0) {\\n                dfs(it, node, vis, adj, tin, low, bridges);\\n                low[node] = min(low[it], low[node]);\\n                ", "class Solution {\\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\\n        List<Set<Integer>> adj = new ArrayList<>();\\n        int[] parent = new int[n];\\n        for(int i=0;i<n;i++){\\n            adj.add(new HashSet<>()); "]}
{"id": "1959", "ref_java": ["class Solution {\\n    private static final int[] EMPTY_LIST = new int[0];\\n    \\n    ", "class Solution {\\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\\n        ", "class Solution {\\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        Map<Integer,List<Integer>>groupGraph=new HashMap<>();\\n        Map<Integer,List<Integer>>inGroupGraph=new HashMap<>();\\n        Map<Integer,Integer>groupDegrees=new HashMap<>();\\n        int[]arrDegrees=new int[n];\\n        int []gr=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(group[i]>-1)\\n                gr[i]=group[i];\\n            else\\n                gr[i]=i+m+1;\\n            inGroupGraph.put(i,new ArrayList<Integer>());\\n            groupDegrees.putIfAbsent(gr[i],0);\\n            groupGraph.putIfAbsent(gr[i],new ArrayList<Integer>());\\n        }"]}
{"id": "1961", "ref_java": ["class Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1}", "class Solution {\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int pos;\\n        int st;\\n        \\n        Pair(int x, int y, int pos, int st){\\n            this.x = x;\\n            this.y = y;\\n            this.pos = pos;\\n            this.st = st;\\n        }", "class Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1}"]}
{"id": "1962", "ref_java": ["class Solution {\\n    long MOD = (long)(1e9 + 7);\\n    \\n    public int countVowelPermutation(int n) {\\n        return (int)findPerm(n, 0);\\n    }", "class Solution {\\n    public int countVowelPermutation(int n) {\\n        final int MOD = (int) 1e9 + 7;\\n        long[][] dp = new long[n][5];\\n        \\n        for (int i = 0; i < 5; ++i) {\\n            dp[0][i] = 1;\\n        }", "class Solution {\\n    public int countVowelPermutation(int n) {\\n        if (n == 1) {\\n            return 5;\\n        }"]}
{"id": "1963", "ref_java": ["class Solution {\\n    public int dieSimulator(int n, int[] rollMax) {\\n        long p = 1_000_000_007;\\n        long[][] dp = new long[n + 1][6];\\n        long[] sum = new long[n+1];\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j < 6; ++j)  {\\n                for (int k = 1; k <= rollMax[j] && i - k >= 0; ++k)\\n                    dp[i][j] = (dp[i][j] + sum[i-k] - dp[i-k][j] + p) % p;\\n                sum[i] = (sum[i] + dp[i][j]) % p;\\n            }", "class Solution {\\n    public int dieSimulator(int n) {\\n        int[][] dp = new int[n][6];\\n        ", "class Solution {\\n    public int dieSimulator(int n, int[] rollMax) {\\n        int[][] dp = new int[6][15];\\n        int modval = (int) Math.pow(10, 9) + 7;\\n        \\n        "]}
{"id": "1964", "ref_java": ["class Solution {\\n    public int maxEqualFreq(int[] nums) {\\n        int max=0; ", "class Solution {\\n    public int maxEqualFreq(int[] nums) {\\n\\n        ", "class Solution {\\n    public int maxEqualFreq(int[] nums) {\\n\\n        "]}
{"id": "1965", "ref_java": ["class Solution {\\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\\n        int ans= helper(startTime,endTime,profit);\\n         return ans;\\n    }", "class Solution {\\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\\n        int ans= helper(startTime,endTime,profit);\\n         return ans;\\n    }", "class Solution {\\n    int n;\\n    \\n    private int getNext(ArrayList<int[]> nums, int low, int target) {\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (nums.get(mid)[0] >= target) {\\n                high = mid - 1;\\n            }"]}
{"id": "1966", "ref_java": ["class Solution {\\n    int ret; ", "class Solution {\\n    ", "class Solution {    \\n    private int trUtil(int n, int m, int[][] cache)\\n    {\\n        if (n > m)\\n        {\\n            int temp = n;\\n            n = m;\\n            m = temp;\\n        }"]}
{"id": "1967", "ref_java": ["class Solution {\\n\\n    public int gcd(int a, int b)\\n    {\\n        if (b==0) return a;\\n\\n        if (a>b)\\n        return gcd(b , a%b);\\n\\n        else \\n        return gcd(a, b%a);\\n    }", "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        ", "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       \\n\\n        "]}
{"id": "1968", "ref_java": ["class Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        if (words == null || words.length == 0 || letters == null || letters.length == 0 || score == null || score.length == 0) return 0;\\n        int[] count = new int[score.length];\\n        for (char ch : letters) {\\n            count[ch - \\'a\\']++;\\n        }", "class Solution {\\n    static int maxScore=0;\\n    public static boolean isValid(String s,int arr[])\\n    {\\n        int a[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]++;\\n        }", "class Solution {\\n\\tpublic int maxScoreWords(String[] arr, char[] letters, int[] score) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < letters.length; i++) {\\n\\t\\t\\tfreq[letters[i] - \\'a\\']++;\\n\\t\\t}"]}
{"id": "1969", "ref_java": ["class Solution {\\n    private char[][] G;\\n    private int rows;\\n    private int cols;\\n    private int[] dir = new int[]{-1,0,1,0,-1}", "class Solution {\\n    \\n    \\n    \\n    \\n    \\n    private static final int [][] DIRS = {{1,0}", "class Solution {\\n        char[][] grid;\\n        int m, n;\\n        int[][] DIRS = new int[][]{{0, 1}"]}
{"id": "1970", "ref_java": ["class Solution {\\n    public int numWays(int steps, int arrLen) {\\n        int maxPosition = Math.min(steps / 2 + 1, arrLen);\\n        int[] curWays = new int[maxPosition + 2];\\n        int[] nextWays = new int[maxPosition + 2];\\n        curWays[1] = 1;\\n        int mod = 1000000007;\\n\\n        while (steps > 0) {\\n            for (int pos = 1; pos <= maxPosition; pos++) {\\n                nextWays[pos] = (int)(((long)curWays[pos] + curWays[pos - 1] + curWays[pos + 1]) % mod);\\n            }", "class Solution {\\n    private static final int MOD = 1000000007;\\n    public int numWays(int steps, int arrLen) {\\n        return countWays(steps, 0, arrLen);\\n    }", "class Solution {\\n    public int numWays(int steps, int arrLen) {\\n        int m = (int) 1e9 + 7;\\n        arrLen = Math.min(arrLen, steps);\\n        int[][] dp = new int[arrLen][steps + 1];\\n        dp[0][0] = 1;\\n        int ans;\\n        for (int remain = 1; remain <= steps; remain++) {\\n            for (int curr = 0; curr<arrLen; curr++) {\\n                ans = dp[curr][remain - 1];\\n                if (curr > 0) {\\n                    ans = (ans + dp[curr - 1][remain - 1]) % m;\\n                }"]}
{"id": "1971", "ref_java": ["class Solution {\\n    static int M = Integer.MAX_VALUE;\\n    int[][] dp;\\n    int[][] palCount;\\n    public int palindromePartition(String s, int k) {\\n        dp = new int[s.length()][k+1];\\n        palCount = new int[s.length()][s.length()+1];\\n        for(int i=0; i<s.length();i++) {\\n            Arrays.fill(dp[i], -1);\\n            for(int j=i+1; j<=s.length(); j++) {\\n                palCount[i][j] = makePalindrome(s.substring(i,j));\\n            }", "class Solution {\\n    public int palindromePartition(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[n][n];\\n\\n        for (int gap = 0; gap < n; gap++) {\\n            for (int i = 0, j = gap; j < n; i++, j++) {\\n                if (gap == 0) {\\n                    dp[i][j] = 0;\\n                }", "class Solution {\\n    public int palindromePartition(String s, int k) {\\n        if(s.length() == k) return 0;\\n        int n = s.length();\\n        int dp[][] = new int[n][n];\\n        \\n        "]}
{"id": "1972", "ref_java": ["class Solution {\\n    int count =0;\\n    public int minFlips(int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        for(int i=0; i< m ; i++){\\n            for(int j =0; j< n; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }", "class Solution {\\n    int[] row={0,0,1,-1}", "class Solution {\\n    public int minFlips(int[][] mat) {\\n           \\n\\n           "]}
{"id": "1973", "ref_java": ["class Solution {\\n    int m;\\n    int n;\\n    Integer memo[][];\\n\\n    public int minFallingPathSum(int[][] grid) {   \\n         m=grid.length;\\n         n=grid[0].length;\\n        ", "class Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int result = Integer.MAX_VALUE;\\n        if(matrix == null || matrix.length < 1){\\n            return 0;\\n        }", "class Solution {\\n            public int minFallingPathSum(int[][] grid) {\\n                int minSum = Integer.MAX_VALUE;\\n                int n = grid.length;\\n                if(n==1)return grid[0][0];\\n\\n                for(int i=n-2;i>=0;i--){\\n                    \\n                    for(int j=0;j<n;j++){\\n                        int min = minNum(grid, j, i+1, n);\\n                        grid[i][j] +=min;\\n                    }"]}
{"id": "1974", "ref_java": ["class Solution {\\n    public int shortestPath(int[][] grid, int k) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n        boolean[][][] visited = new boolean[m][n][k + 1];\\n        \\n\\t\\tQueue<int[]> Q = new LinkedList(); \\n        Q.add(new int[]{0, 0, k}", "class Solution {\\n    int[][] arr;", "class Solution {\\n    private static final int[][] DIRECTIONS = {{1, 0}"]}
{"id": "1975", "ref_java": ["class Solution {\\n\\t\\t\\tpublic int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint n=initialBoxes.length;\\n\\n\\t\\t\\t\\tif(n==0)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tQueue<Integer> q=new LinkedList<>();\\n\\t\\t\\t\\tint totalCandies=0;\\n\\n\\t\\t\\t\\tfor(int i:initialBoxes)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttotalCandies+=candies[i];              ", "class Solution {\\n\\t\\tpublic int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes)\\n\\t\\t{\\n\\t\\t\\tint n=initialBoxes.length;\\n\\n\\t\\t\\tif(n==0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tQueue<Integer> q=new LinkedList<>();\\n\\t\\t\\tint totalCandies=0;\\n\\n\\t\\t\\tfor(int i:initialBoxes)\\n\\t\\t\\t{\\n                if(status[i]==0)\\n                {\\n                    q.add(i);\\n                }", "class Solution {\\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\\n        int n=status.length;\\n        boolean visBox[]=new boolean[n];"]}
{"id": "1976", "ref_java": ["class Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size();\\n        int mod = (int)1e9 + 7;\\n\\n        int[][] dp = new int[n][n];\\n        int[][] dp2 = new int[n][n];\\n        dp2[n - 1][n - 1] = 1;\\n\\n        for(int i = n - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                if(i == n - 1 && j == n - 1) continue;\\n                if(board.get(i).charAt(j) == \\'X\\'){\\n                    dp[i][j] = (int)(-1e9);\\n                    dp2[i][j] = 0;\\n                }", "class Solution {\\n\\n    private static int INF = Integer.MIN_VALUE;\\n\\n    private static long MOD = (long) (1e9 + 7);\\n\\n    ", "class Solution {\\n    int mod =(int)1e9+7;\\n    public int[] pathsWithMaxScore(List<String> list) {\\n        int[] ans = new int[2];\\n        int[][] dp1 =new int[list.size()][list.get(0).length()];\\n        for(int[] row :dp1)Arrays.fill(row,-1);\\n       ans[0] =Math.max(helper(1,0,list,dp1),Math.max(helper(0,1,list,dp1),helper(1,1,list,dp1)));\\n        if(ans[0] <=(int)-1e8){\\n            ans[0] =0;\\n            ans[1] =0;\\n            return ans;\\n        }"]}
{"id": "1977", "ref_java": ["class Solution {\\n    public boolean isSolvable(String[] words, String result) {\\n        Map<Character, Integer> letterDigitMap = new HashMap<Character, Integer>();\\n        Set<Character> leadingSet = new HashSet<Character>();\\n        int resultLength = result.length();\\n        for (String word : words) {\\n            if (word.length() > resultLength)\\n                return false;\\n            if (word.length() > 1)\\n                leadingSet.add(word.charAt(0));\\n        }", "class Solution {\\n    int[] c2N = new int[26];\\n    int[] n2C = new int[10];\\n    boolean[] not0 = new boolean[26];\\n    public boolean isSolvable(String[] words, String result) {\\n        int maxWord = 1;\\n        for (String word : words) {\\n            if (word.length() > 1) {\\n                not0[word.charAt(0) - \\'A\\'] = true;\\n            }", "class Solution {\\n     public static boolean isSolvable(String[] words, String result) {\\n\\t    "]}
{"id": "1978", "ref_java": ["class Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        char []str = s.toCharArray();\\n        int [][] answ = new int[s.length() + 1][s.length() + 1];\\n        int n = s.length();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            for (int j = n - 1; j > -1; j--)\\n            {\\n                if (str[i] == str[j]) answ[i + 1][n - j] = answ[i - 1 + 1][n - j - 1 ] + 1;\\n                else answ[i + 1][n - j ] = Math.max(answ[i - 1 + 1][n - j ], answ[i + 1][n - j - 1]);\\n            }", "class Solution {\\n    public int minInsertions(String s) {\\n        String s2 = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(s.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }", "class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = \"\";\\n        for(int i=0;i<s.length();i++){\\n            s1 = s.charAt(i) + s1;\\n        }"]}
{"id": "1979", "ref_java": ["class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<Long> st = new HashSet<>();\\n        RollingHash rh = new RollingHash(text);\\n        for(int i = 0; i < text.length(); i++){\\n            for(int j = i; j < text.length(); j++){\\n                if( (j-i+1) % 2 == 0){\\n                    int mid = (i+1)+(j+1-(i+1))/2;\\n                    if(rh.get(i+1, mid) == rh.get(mid+1, j+1)){\\n                        st.add(rh.get(i+1, j+1));\\n                    }", "class Solution {\\n    private long[] h;\\n    private long[] p;\\n\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int base = 131;\\n        h = new long[n + 10];\\n        p = new long[n + 10];\\n        p[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int t = text.charAt(i) - \\'a\\' + 1;\\n            h[i + 1] = h[i] * base + t;\\n            p[i + 1] = p[i] * base;\\n        }", "class Solution {\\npublic static int distinctEchoSubstrings(String text) {\\n    \\n    Set<String> s = new HashSet<>();\\n    \\n    for (int i = 0; i < text.length(); i++)\\n        \\n    for (int j = i + 1; j < text.length(); j++)\\n        \\n    if (text.charAt(i) == text.charAt(j) && j + j - i <= text.length())\\n        \\n    if (text.substring(i, j).equals(text.substring(j, j + j - i)))\\n        \\n    s.add(text.substring(i, j) + text.substring(j, j + j - i));\\n    \\n    return s.size();\\n    \\n}"]}
{"id": "1980", "ref_java": ["class Solution {\\n    Map<String, Integer> memo;\\n    public int minimumDistance(String word) {\\n        memo = new HashMap<>();\\n        return solve(word, 0, new int[]{-1,-1}", "class Solution {\\n    public int minimumDistance(String word) {\\n        int[] keys = new int[word.length()];\\n        for (int i = 0; i < word.length(); i++) keys[i] = word.charAt(i) - \\'A\\';\\n\\n        int[][] cost = new int[27][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                cost[i][j] = Math.abs(i/6 - j/6) + Math.abs(i%6 - j%6);\\n                cost[j][i] = cost[i][j];\\n            }", "class Solution {\\n    public int minimumDistance(String word) {\\n        HashMap<String,Integer> cache= new HashMap<>();\\n        return type(word,\\'\\\\0\\', \\'\\\\0\\',0,cache);\\n    }"]}
{"id": "1981", "ref_java": ["class Solution {\\n\\n\\n    int res = Integer.MAX_VALUE;\\n    public int minTaps(int n, int[] ranges) {\\n        helper(0,0,0,ranges,0);\\n\\n        return res==Integer.MAX_VALUE?-1:res;\\n    }", "class Solution {\\n    public int minTaps(int n, int[] ranges) {\\n       int []newRanges = new int[n+1];\\n        for(int pos = 0; pos <= n; pos++){\\n            if(ranges[pos] == 0)continue;\\n            int leftLimit = Math.max(0, pos - ranges[pos]);\\n            int rightLimit = Math.min(n, pos + ranges[pos]);\\n            newRanges[leftLimit] = Math.max(newRanges[leftLimit], rightLimit);\\n        }", "class Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        "]}
{"id": "1982", "ref_java": ["class Solution {\\n    \\n    private int getAbsoluteDifference(int a, int b){\\n        return Math.abs(a - b);\\n    }", "class Solution {\\n    \\n    private int getAbsoluteDifference(int a, int b){\\n        return Math.abs(a - b);\\n    }", "class Solution {\\n    \\n    private int getAbsoluteDifference(int a, int b){\\n        return Math.abs(a - b);\\n    }"]}
{"id": "1983", "ref_java": ["class Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (d > len) return -1;\\n        int[][] minDifficulty = new int[d][len];\\n        for (int i = 1; i < d; i++) {\\n            Arrays.fill(minDifficulty[i], Integer.MAX_VALUE);\\n        }", "class Solution {\\n   public int minDifficulty(int[] jobDifficulty, int d) {\\n    int n = jobDifficulty.length;\\n    if (d > n) return -1;\\n    int[][] F = new int[d+1][n+1];\\n    for (int i = 1; i <= n; i++) F[1][i] = Math.max(F[1][i-1], jobDifficulty[i-1]);\\n    for (int i = 2; i <= d; i++) {\\n        for (int j = i; j <= n; j++) {\\n            F[i][j] = Integer.MAX_VALUE;\\n            int currMax = 0;\\n            for (int k = j; k >= i; k--) {\\n                currMax = Math.max(currMax, jobDifficulty[k-1]);\\n                F[i][j] = Math.min(F[i][j], F[i-1][k-1] + currMax);\\n            }", "class Solution {\\n   public int minDifficulty(int[] jobDifficulty, int d) {\\n    int n = jobDifficulty.length;\\n    if (d > n) return -1;\\n    int[][] F = new int[d+1][n+1];\\n    for (int i = 1; i <= n; i++) F[1][i] = Math.max(F[1][i-1], jobDifficulty[i-1]);\\n    for (int i = 2; i <= d; i++) {\\n        for (int j = i; j <= n; j++) {\\n            F[i][j] = Integer.MAX_VALUE;\\n            int currMax = 0;\\n            for (int k = j; k >= i; k--) {\\n                currMax = Math.max(currMax, jobDifficulty[k-1]);\\n                F[i][j] = Math.min(F[i][j], F[i-1][k-1] + currMax);\\n            }"]}
{"id": "1984", "ref_java": ["class Solution {\\n    public int maxJumps(int[] arr, int d) {\\n        List jumpsFrom[] =  new List[arr.length];  ", "class Solution {\\n    Integer[] dp;\\n    int[] arr;\\n    int n;\\n    int d;\\n    \\n    boolean isValley(int man){\\n        if( man >= n || man < 0 ){ \\n            return true;\\n        }", "class Solution {\\n    public int maxJumps(int[] arr, int d) {\\n        int[] maxJumpsFromHere = new int[arr.length];\\n        int maxJumps = 0;\\n\\n        for (int i=0; i<arr.length; i++) {\\n            maxJumps = Math.max(maxJumps, calMaxJumps(i, maxJumpsFromHere, arr, d));\\n        }"]}
{"id": "1985", "ref_java": ["class Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }", "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }", "class Solution {\\n    public int minJumps(int[] arr) {\\n\\n        int n=arr.length;\\n        Map<Integer,List<Integer>> valIndex=new HashMap<>();\\n\\n        for(int i=0;i<n;i++)\\n            valIndex.computeIfAbsent(arr[i],l->new ArrayList<>()).add(i);\\n\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(0);\\n\\n        Set<Integer> visited=new HashSet<>();\\n        visited.add(0);\\n\\n        int step=0;\\n\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int i=q.poll();\\n\\n\\n                if(i==n-1)\\n                    return step;\\n\\n                List<Integer> adjList=valIndex.get(arr[i]);\\n\\n                adjList.add(i-1);\\n                adjList.add(i+1);\\n\\n                for(int j:adjList)\\n                {\\n                    if(j>=0&& j<n && !visited.contains(j))\\n                        {\\n                            q.add(j);\\n                            visited.add(j);\\n                        }"]}
{"id": "1986", "ref_java": ["class Solution {\\n    int m, n;\\n    public int maxStudents(char[][] seats) {\\n        m = seats.length;\\n        n = seats[0].length;\\n        Map<Integer, Map<Integer, Map<Integer, Map<Integer, Integer>>>> memo = new HashMap<>();\\n        for (int i = -1; i < seats.length; ++i) memo.put(i, new HashMap<>());\\n        return dfs(seats, memo, -1, seats[0].length, 0, 0);\\n    }", "class Solution {\\n    public boolean isInside(int x, int y, char[][] seats) {\\n        if (x < 0 || x >= seats.length || y < 0 || y >= seats[0].length)\\n            return false;\\n        \\n        return true;\\n    }", "class Solution {\\n    private Integer[][] f;\\n    private int n;\\n    private int[] ss;\\n\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length;\\n        n = seats[0].length;\\n        ss = new int[m];\\n        f = new Integer[1 << n][m];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (seats[i][j] == \\'.\\') {\\n                    ss[i] |= 1 << j;\\n                }"]}
{"id": "1987", "ref_java": ["class Solution {\\n    public boolean isPossible(int[] arr) {\\n        long sum = 0;\\n        int max = 0;\\n\\n        int n = arr.length;\\n        for(int i=0; i<n; i++){\\n            sum+=arr[i];\\n            if(arr[i]>arr[max]) max=i;\\n        }", "class Solution {\\n    public boolean isPossible(int[] arr) {\\n        long sum = 0;\\n        int max = 0;\\n\\n        int n = arr.length;\\n        for(int i=0; i<n; i++){\\n            sum+=arr[i];\\n            if(arr[i]>arr[max]) max=i;\\n        }", "class Solution {\\n    public boolean isPossible(int[] target) {\\n        Queue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\\n        int sum = 0;\\n        for (int num : target) {\\n            sum += num;\\n            pq.add(num);\\n        }"]}
{"id": "1988", "ref_java": ["class Solution {\\n    public int countOrders(int n) {\\n        long[] dp = new long[n + 1];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i < dp.length; i++) {\\n            long k = i * (i + (i - 1));\\n            dp[i] = (dp[i - 1] * k) % 1000000007;\\n        }", "class Solution {\\n    public int countOrders(int n) {\\n        int MOD = (int)1e9 + 7;\\n        long[] dp = new long[n+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] * (2 * i - 1) * i % MOD;\\n        }", "class Solution {\\n    "]}
{"id": "1989", "ref_java": ["class Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int[] D = new int[10];\\n        int sum = 0;\\n        for(int d : digits){\\n            D[d]++;\\n            sum += d;\\n        }", "class Solution {\\n  public String largestMultipleOfThree(int[] digits) {\\n    StringBuilder ans = new StringBuilder();\\n    int[] mod1 = new int[] {1, 4, 7, 2, 5, 8}", "class Solution {\\n    public String largestMultipleOfThree(int[] digits) {\\n        int n=digits.length;\\n        Arrays.sort(digits);\\n        \\n        if(digits[digits.length-1]==0){\\n            return \"0\";\\n        }"]}
{"id": "1990", "ref_java": ["class Solution {\\n\\n    \\n\\n    static int n;\\n    static int m;\\n\\n    static int helper(int arr[][]){\\n\\n        int dx[] = {0,0,1,-1}", "class Solution {\\n\\n    int[][] dirs = {{0,1}", "class Solution {\\n    class Tuple {\\n        int row, col, cost;\\n        public Tuple(int r, int c, int co) {\\n            row = r;\\n            col = c;\\n            cost = co;\\n        }"]}
{"id": "1991", "ref_java": ["class Solution {\\n    int maxSum = 0;  ", "class Solution {\\n    \\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        findMaxSum(root);\\n        return maxSum;\\n    }", "class Solution {\\n    \\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        findMaxSum(root);\\n        return maxSum;\\n    }"]}
{"id": "1992", "ref_java": ["class Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] adj=new ArrayList[n];", "class Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n       \\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int ar[]:edges){\\n          int u=ar[0];\\n          int v=ar[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }", "class Solution {\\n    List<Integer>[] adj;\\n    int time;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        time=t;\\n        adj = new List[n+1];\\n        for(int i=0; i<=n; i++)adj[i]=new ArrayList<>();\\n        for(int i=0; i<edges.length; i++){\\n            adj[edges[i][0]].add(edges[i][1]);\\n            adj[edges[i][1]].add(edges[i][0]);\\n        }"]}
{"id": "1993", "ref_java": ["class Solution {\\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\\n        int[][] players = new int[n][2];\\n        for (int i=0; i<n; i++) {\\n            players[i][0] = efficiency[i];\\n            players[i][1] = speed[i];\\n        }", "class Solution {\\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\\n        int[][] players = new int[n][2];\\n        for (int i=0; i<n; i++) {\\n            players[i][0] = efficiency[i];\\n            players[i][1] = speed[i];\\n        }", "class Solution {\\n\\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\\nPriorityQueue<Integer> min_heap = new PriorityQueue<>();\\n            int[][] eng = new int[n][2];\\n        for (int i = 0; i < n; i++) eng[i] = new int[] {efficiency[i], speed[i]}"]}
{"id": "1994", "ref_java": ["class Solution {\\n    public int maxSizeSlices(int[] slices) {\\n        int n = slices.length;\\n        int ans = 0;\\n        if(n == 3){\\n            for(int a : slices) ans = Math.max(ans, a);\\n            return ans;\\n        }", "class Solution {\\n    public int maxSizeSlices(int[] slices) {\\n        int n = slices.length;\\n        int ans = 0;\\n        if(n == 3){\\n            for(int a : slices) ans = Math.max(ans, a);\\n            return ans;\\n        }", "class Solution {\\n    public int maxSizeSlices(int[] slices) {\\n        int n = slices.length;\\n        int ans = 0;\\n        if(n == 3){\\n            for(int a : slices) ans = Math.max(ans, a);\\n            return ans;\\n        }"]}
{"id": "1995", "ref_java": ["class Solution {\\n    public String longestPrefix(String s) {\\n        char str[]=s.toCharArray();\\n        int n=str.length;\\n        int arr[]=new int[n];\\n        int max=0,i=1;\\n        while(i<n){\\n            if(str[max]==str[i]){\\n                max++;\\n                arr[i]=max;\\n                i++;\\n            }", "class Solution {\\n    public String longestPrefix(String s) {\\n        int n = s.length();\\n        int [] lps = new int[n];\\n        int j=0; \\n        for(int i=1;  i<n; i++){\\n            while(j>0 && s.charAt(i) != s.charAt(j)){\\n                j = lps[j-1]; \\n            }", "class Solution {\\n    public String longestPrefix(String s) {\\n        int n = s.length();\\n        int[] lps = new int[s.length()];\\n        int i = 1, len = 0;\\n        while (i < n) {\\n            if (s.charAt(i) == s.charAt(len)) {\\n                len++;\\n                lps[i] = len;\\n                i++;\\n            }"]}
{"id": "1996", "ref_java": ["class Solution {\\n    Integer[][][][] dp;\\n    int mod = 1000000007;\\n    int[] lps;\\n    private int add(int a, int b) {\\n        return (a % mod + b % mod) % mod;\\n    }", "class Solution {\\n    final int MOD = 1000000007;\\n    final boolean PRINT = false;\\n    \\n    boolean[] suffix;\\n    char[] a, b, e;\\n    int n, m;\\n    \\n    ", "class Solution {\\n    static final int MOD = 1_000_000_000 + 7;\\n    Map<String, Integer> index = new HashMap<>();\\n    HashMap[][][] memo;\\n    String A;\\n    String Z;\\n    public int findGoodStrings(int n, String s1, String s2, String evil) {\\n        A = generate(n, \\'a\\');\\n        Z = generate(n, \\'z\\');\\n\\n        memo = new HashMap[4][4][n + 1];\\n        index.put(s1, 0);\\n        index.put(s2, 1);\\n        index.put(A, 2);\\n        index.put(Z, 3);\\n        return f(n, s1, s2, evil, Collections.emptyList());\\n    }"]}
{"id": "1997", "ref_java": ["class Solution {\\n  public int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    int sum = 0, tot = 0, maxi = 0;\\n    \\n    for(int i = satisfaction.length - 1; i >= 0 && sum >= 0; --i){\\n      tot += sum + satisfaction[i];\\n      sum += satisfaction[i];\\n      if( tot > maxi) maxi = tot;\\n    }", "class Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n\\n        for(int i=0; i<satisfaction.length; i++){\\n            for(int j=i+1; j<satisfaction.length; j++){\\n                if(satisfaction[i] > satisfaction[j]){\\n                    int temp = satisfaction[i];\\n                    satisfaction[i] = satisfaction[j];\\n                    satisfaction[j] = temp;\\n                }", "class Solution {\\n    "]}
{"id": "1998", "ref_java": ["class Solution {\\n    public String stoneGameIII(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        Integer[] memo = new Integer[n];\\n        int dif = f(stoneValue, n, 0, memo);\\n        if (dif > 0) {\\n            return \"Alice\";\\n        }", "class Solution {\\n    public String stoneGameIII(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] dp = new int[3];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            int takeOne = stoneValue[i] - dp[(i + 1) % 3];\\n\\n            int takeTwo = Integer.MIN_VALUE;\\n            if (i + 1 < n)\\n                takeTwo = stoneValue[i] + stoneValue[i + 1] - dp[(i + 2) % 3];\\n\\n            int takeThree = Integer.MIN_VALUE;\\n            if (i + 2 < n)\\n                takeThree = stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] - dp[(i + 3) % 3];\\n\\n            dp[i % 3] = Math.max(Math.max(takeOne, takeTwo), takeThree);\\n        }", "class Solution {\\n    public String stoneGameIII(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] dp = new int[3];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            int takeOne = stoneValue[i] - dp[(i + 1) % 3];\\n\\n            int takeTwo = Integer.MIN_VALUE;\\n            if (i + 1 < n)\\n                takeTwo = stoneValue[i] + stoneValue[i + 1] - dp[(i + 2) % 3];\\n\\n            int takeThree = Integer.MIN_VALUE;\\n            if (i + 2 < n)\\n                takeThree = stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] - dp[(i + 3) % 3];\\n\\n            dp[i % 3] = Math.max(Math.max(takeOne, takeTwo), takeThree);\\n        }"]}
{"id": "1999", "ref_java": ["class Solution {\\n    public int numOfWays(int n) {\\n        long distinct = 6;\\n        long nonDistinct = 6;\\n        long mod = 1000000007;\\n\\n        for(int i = 1 ; i < n ; i++){\\n            long newDistinct = (distinct * 2 + nonDistinct * 2) % mod;\\n            long newNonDistinct = (distinct * 2 + nonDistinct * 3) % mod;\\n\\n            distinct = newDistinct;\\n            nonDistinct = newNonDistinct;\\n        }", "class Solution {\\n    public int numOfWays(int n) {\\n        long MOD = 1_000_000_007;\\n        long dpPreviousRed = 6;\\n        long dpPreviousBlue = 6;\\n\\n        for (int i = 2; i <= n; i++) {\\n            long newDpRed = (2 * dpPreviousRed + 2 * dpPreviousBlue) % MOD;\\n            long newDpBlue = (2 * dpPreviousRed + 3 * dpPreviousBlue) % MOD;\\n            \\n            dpPreviousRed = newDpRed;\\n            dpPreviousBlue = newDpBlue;\\n        }", "class Solution {\\n    public int numOfWays(int n) {\\n\\n\\n        "]}
{"id": "2000", "ref_java": ["class Solution {\\n    public int numberOfArrays(String s, int k) {\\n        int mod =  1_000_000_007;\\n        int n =  s.length();\\n        int dp[] =  new int[n+1];\\n        dp[0] =  1;\\n        \\n        ", "class Solution {\\n    static int mod = (int)1e9+7;\\n    public int numberOfArrays(String s, int k) {\\n        int[] dp = new int[s.length()+1];\\n        dp[s.length()]=1;\\n        for(int i=s.length()-1;i>=0;i--){\\n            long num=0, sum=0;\\n            for(int j=i;j<s.length();j++){\\n                num=num*10+(s.charAt(j)-\\'0\\');\\n                if(num==0 || num>k)\\n                    break;\\n                sum+=dp[j+1];\\n            }", "class Solution {\\n    int mod = 1000000007;\\n    public int numberOfArrays(String s, int k) {\\n        return helper(s, k, 0);\\n    }"]}
{"id": "2001", "ref_java": ["class Solution {\\n    private static final int MOD = 1_000_000_007;\\n\\n    public int numOfArrays(int length, int maxVal, int cost) {\\n        if (cost == 0) {\\n            return 0;\\n        }", "class Solution {\\n    private static final int MOD = 1_000_000_007;\\n\\n    public int numOfArrays(int length, int maxVal, int cost) {\\n        if (cost == 0) {\\n            return 0;\\n        }", "class Solution {\\n    int[][][] dp;\\n    int n, m, k;\\n\\n    public int solve(int idx, int lenLis, int lar) {\\n        if (idx == n) {\\n            if (lenLis == k) {\\n                return 1;\\n            }"]}
{"id": "2002", "ref_java": ["class Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = dp[0];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(nums[0]);\\n        for(int i=1;i<nums.length;i++){\\n            dp[i] = nums[i];\\n            if(i>k && dq.getFirst() == dp[i-k-1]){\\n                dq.removeFirst();\\n            }", "class Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        ", "class Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp=new int[nums.length];\\n        dp[0]=nums[0];\\n        int max=Integer.MIN_VALUE;\\n        max=Math.max(dp[0],max);\\n\\n        Deque<Integer> q=new ArrayDeque();\\n        q.offer(nums[0]);\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=nums[i];\\n            if(i>k && q.peekFirst()==dp[i-k-1]){\\n                q.removeFirst();\\n            }"]}
{"id": "2003", "ref_java": ["class Solution {\\n    public int numberWays(List<List<Integer>> hats) {\\n        int n = hats.size(), M = (int)1e9+7;\\n        int[] mask = new int[41];\\n        for (int i = 0; i < n; i++){\\n            for (int h : hats.get(i)){\\n                mask[h]|=1<<i;\\n            }", "class Solution {\\n    public int numberWays(List<List<Integer>> hats) {\\n        int n = hats.size(), M = (int)1e9+7;\\n        int[] mask = new int[41];\\n        for (int i = 0; i < n; i++){\\n            for (int h : hats.get(i)){\\n                mask[h]|=1<<i;\\n            }", "class Solution {\\n    Integer[][] dp;\\n    int maxMask;\\n    int MOD = (int)1e9+7;\\n\\n    public int numberWays(List<List<Integer>> hats) {\\n        maxMask = (int)Math.pow(2, hats.size())-1;\\n        dp = new Integer[41][maxMask];\\n\\n        List<Integer>[] newHats = new ArrayList[41];\\n        for (int i = 1; i < 41; i++) {\\n            newHats[i] = new ArrayList<>();\\n        }"]}
{"id": "2004", "ref_java": ["class Solution {\\n\\tpublic int kthSmallest(int[][] mat, int k) {\\n\\t\\tint[] row = mat[0];\\n\\n\\t\\tfor (int i = 1; i < mat.length; i++)\\n\\t\\t\\trow = kSmallestPairSums(row, mat[i], k);\\n\\t\\treturn row[k - 1];\\n\\t}", "class Solution {\\n    public int kthSmallest(int[][] mat, int k) {\\n        int[] row = mat[0];\\n        \\n        for(int i=1; i<mat.length; i++) {\\n            row = findKthSmallest(row, mat[i], k);\\n        }", "class Solution {\\n    public int kthSmallest(int[][] mat, int k) {\\n        PriorityQueue<Integer> current = new PriorityQueue<>(Collections.reverseOrder());\\n        current.offer(0);\\n        \\n        for(int i=0; i< mat.length; i++) {\\n            PriorityQueue<Integer> next = new PriorityQueue<>(Collections.reverseOrder());\\n            for(int j=0; j < mat[0].length; j++) {\\n                for(int sum: current) {\\n                    next.offer(sum + mat[i][j]);\\n                    if(next.size() > k) {\\n                        next.poll();\\n                    }"]}
{"id": "2005", "ref_java": ["class Solution {\\n    private String[] pizza;\\n    private Map<String, Integer> waysCountPerPizzaIdx;\\n    private int MODULO = 1_000_000_007;\\n\\n    public int ways(String[] pizza, int k) {\\n        this.pizza = pizza;\\n        this.waysCountPerPizzaIdx = new HashMap<>();\\n\\n        return ways(k, 0, pizza.length, 0, pizza[0].length());\\n    }", "class Solution {\\n    int[][] apples;\\n    int m;int n;\\n    long[][][] dp;\\n    public int ways(String[] pizza, int k) {\\n        m=pizza.length;\\n        n=pizza[0].length();\\n        apples=new int[m+1][n+1];\\n        dp=new long[m+1][n+1][k+1];\\n        for(long[][] dd:dp)for(long[] d:dd)Arrays.fill(d,-1);\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                apples[i][j]=apples[i+1][j]+apples[i][j+1]-apples[i+1][j+1]+(pizza[i].charAt(j)==\\'A\\'?1:0);\\n            }", "class Solution {\\n    public int ways(String[] pizza, int k) {\\n        \\n        int m = pizza.length, n = pizza[0].length();\\n        Integer[][][] dp = new Integer[k][m][n];\\n        "]}
{"id": "2006", "ref_java": ["class Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        Arrays.fill(dp, \"\");\\n\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 0; j < cost.length; j++) {\\n                if(i < cost[j]) continue;\\n                if((i - cost[j]) == 0 || ((i - cost[j]) > 0 \\n                && !dp[i - cost[j]].equals(\"\")))\\n                dp[i] = max(dp[i],(j+1) + dp[i - cost[j]]);\\n            }", "class Solution {\\n   public String largestNumber(int[] cost, int target) {\\n          String[][] memo = new String[cost.length+1][target+1];\\n          String str = largestNum(cost, target, 1, memo);\\n          return !str.isEmpty() ? str : \"0\";\\n    }", "class Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        Arrays.fill(dp, \"\");\\n\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 0; j < cost.length; j++) {\\n                if(i < cost[j]) continue;\\n                if((i - cost[j]) == 0 || ((i - cost[j]) > 0 \\n                && !dp[i - cost[j]].equals(\"\")))\\n                dp[i] = max(dp[i],(j+1) + dp[i - cost[j]]);\\n            }"]}
{"id": "2007", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    public int numPoints(int[][] points, int r) {\\n        int maxPoints = 1;\\n        int pointsCount = points.length;\\n        for (int i = 0; i < pointsCount; i++) {\\n            for (int j = i + 1; j < pointsCount; j++) {\\n                double[][] intersections = getIntersections(points[i], points[j], r);\\n                for (double[] intersection : intersections) {\\n                    int pointsInCircle = 0;\\n                    for (int[] point : points) {\\n                        double distance = distance(intersection, point);\\n                        if (distance <= r + 1e-5)\\n                            pointsInCircle++;\\n                    }", "class Solution {\\n    public int numPoints(int[][] darts, int r) {\\n        int n = darts.length;\\n        int ans = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                double[] center = getCenter(darts[i], darts[j], r);\\n                if (center == null) continue;\\n                int cnt = 0;\\n                for (int k = 0; k < n; k++) {\\n                    double dist = Math.sqrt(Math.pow(center[0] - darts[k][0], 2) + Math.pow(center[1] - darts[k][1], 2));\\n                    if (dist <= r + 1e-6) cnt++;\\n                }"]}
{"id": "2008", "ref_java": ["class Solution {\\n    public int maxDotProduct(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length;\\n        int[] current = new int[n + 1], previous = new int[n + 1];\\n        Arrays.fill(current, Integer.MIN_VALUE);\\n        Arrays.fill(previous, Integer.MIN_VALUE);\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int curr_product = nums1[i - 1] * nums2[j - 1];\\n                current[j] = Math.max(Math.max(Math.max(curr_product, previous[j]), current[j - 1]), curr_product + Math.max(0, previous[j - 1]));\\n            }", "class Solution {\\n    public int maxDotProduct(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int[][] dp = new int[n + 1][m + 1];\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[i][j] = -10;\\n            }", "class Solution {\\n    public int maxDotProduct(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        if (m < n) {\\n            return maxDotProduct(nums2, nums1);\\n        }"]}
{"id": "2009", "ref_java": ["class Solution {\\n    Integer dp[][][], n, m;\\n    int grid[][];\\n    public int cherryPickup(int[][] grid) {\\n        this.grid=grid;\\n        n=grid.length; m=grid[0].length; dp=new Integer[n][m][m];\\n        return f(0,0,m-1);\\n    }", "class Solution {\\n    public int cherryPickup(int[][] grid) {\\n        int dir[] = new int[]{-1, 0, 1}", "class Solution {\\n    int recursive_approach(int r,int c0,int c1,int[][] grid){\\n\\n        int row=grid.length;\\n        int col=grid[0].length;\\n\\n        "]}
{"id": "2010", "ref_java": ["class Solution {\\n    public double getProbability(int[] balls) {\\n        int sum = 0;\\n        for (int i = 0; i < balls.length; ++i) sum += balls[i];\\n        ", "class Solution {\\n    double equals = 0, ne = 0;\\n    public double getProbability(int[] balls) {\\n        equals = 0;\\n        ne = 0;\\n        int size = 0;\\n        for (int i = 0; i < balls.length; i++) {\\n            size += balls[i];\\n        }", "class Solution {\\n    "]}
{"id": "2011", "ref_java": ["class Solution {\\n    public int helper(int idx, int[] houses, int[][] cost,int target, int prevColor,int neigh,Integer[][][] dp)\\n    {\\n        if(idx==houses.length || neigh>target)\\n        {\\n            if(neigh==target)\\n                return 0;\\n            return Integer.MAX_VALUE;\\n        }", "class Solution {\\n    Integer[][][] dp;\\n    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {\\n        dp = new Integer[m][n+1][target+1];\\n        \\n        ", "class Solution {\\n    Integer[][][] dp;\\n    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {\\n        dp = new Integer[m][n+1][target+1];\\n        \\n        "]}
{"id": "2012", "ref_java": ["class Solution {\\n    int MAX = 10000000;\\n\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[n][k];\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return solve(houses, k, 0, 0, dp);\\n    }", "class Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        for (int i = 1; i < n; i++){ ", "class Solution {\\n    private Integer[][] cache;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        cache = new Integer[houses.length+1][k+1];\\n        int res = dfs(houses, 0, k);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }"]}
{"id": "2014", "ref_java": ["class Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        int maxSize;\\n\\n        public UnionFind(int size) {\\n            this.parent = new int[size];\\n            this.size = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n                this.size[i] = 1;\\n            }", "class Solution {\\n    int minWtKruskal(int n, vector<vector<int>> &edges, vector<int> include, vector<int> exclude){\\n        int mstWt = 0;\\n        DSU dsu(n);\\n\\n        if( include.size() ){\\n            ", "class Solution {\\n    class DSU {\\n        int[] arr=new int[100];\\n        DSU() {for(int i=0;i<100;arr[i]=i++);}"]}
{"id": "2015", "ref_java": ["class Solution {\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        \\n        ", "class Solution {\\n    int[] prerequisites;\\n    int[] dp;\\n    int k; \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n\\t    prerequisites = new int[n]; ", "class Solution {\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] pres = new int[n];\\n        for (int[] r : relations) {\\n            int prev = r[0] - 1;\\n            int next = r[1] - 1;\\n            pres[next] |= (1 << prev);\\n        }"]}
{"id": "2016", "ref_java": ["class Solution {\\n    public int findMaxValueOfEquation(int[][] points, int k) {\\n        int maxM=Integer.MIN_VALUE;\\n        int lastKnownGreater=1;\\n        int i=0;\\n        while(i<points.length)\\n        {\\n            if(lastKnownGreater<=i)\\n            {\\n                lastKnownGreater=i+1;\\n            }", "class Solution {\\n    public int findMaxValueOfEquation(int[][] points, int k) {\\n        int maximum = Integer.MIN_VALUE; ", "class Solution {\\n    public int findMaxValueOfEquation(int[][] points, int k) {\\n        int ans=Integer.MIN_VALUE;\\n\\t\\tint i=0;\\n        int f=1;\\n        while(i < points.length) {\\n            if(f<i+1)\\n                f=i+1;\\n            for (int j = f; j <= points.length-1; j++) {\\n                if(points[j][0]>(points[i][0]+k))\\n\\t\\t\\t\\t\\tbreak;\\n                if((points[i][1]+points[j][1]+points[j][0]-points[i][0])>ans){\\n                    ans=points[i][1]+points[j][1]+points[j][0]-points[i][0];\\n                    f=j-1;\\n                }"]}
{"id": "2017", "ref_java": ["class Solution {\\n    public String minInteger(String num, int k) {\\n        ", "class Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        char[] arr = num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            if(k<=0){\\n                break;\\n            }", "class Solution {\\n    public static String minInteger(String num, int k) {\\n        char[] array = num.toCharArray(); "]}
{"id": "2018", "ref_java": ["class Solution {\\n    Boolean[] dp = new Boolean[100001];\\n\\n        public boolean winnerSquareGame(int n) {\\n            if (n == 0) return false;\\n            if (dp[n] != null) return dp[n];\\n            boolean winner = false;\\n            for (int i = 1; i * i <= n; i++) {\\n                if (!winnerSquareGame(n - i * i)) {\\n                    winner = true;\\n                    break;\\n\\n                }", "class Solution {\\n    public boolean winnerSquareGame(int n) {\\n        return winnerUtil(n);\\n    }", "class Solution {\\n    public boolean winnerSquareGame(int n) {\\n        boolean[] dp = new boolean[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j*j <= i; j++) {\\n                if(!dp[i-j*j]) {\\n                    dp[i] = true;\\n                    break;\\n                }"]}
{"id": "2019", "ref_java": ["class Solution {\\n    private static final double MIN_STEP = 0.0000001;\\n    private static final int[][] DIRECTIONS = {{-1, 0}", "class Solution {\\n    private double getDistance(int[][] positions, double x, double y) {\\n        double distance = 0.0;\\n        for (int i = 0; i < positions.length; ++i) {\\n            distance += Math.sqrt((x - positions[i][0]) * (x - positions[i][0]) + (y - positions[i][1]) * (y - positions[i][1]));\\n        }", "class Solution {\\n    public double getMinDistSum(int[][] positions) {\\n        \\n        "]}
{"id": "2020", "ref_java": ["class Solution {\\n    public List<String> maxNumOfSubstrings(String s) {\\n        \\n        List<String> res=new ArrayList<>();\\n        \\n        Map<Character,int[]> map=new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(map.containsKey(s.charAt(i))){\\n                map.get(s.charAt(i))[1]=i;\\n            }", "class Solution {\\n    \\n    int[] l;\\n    int[] r;\\n    \\n    public List<String> maxNumOfSubstrings(String s) {\\n        List<String> res = new ArrayList<String>();\\n        l = new int[\\'z\\'-\\'a\\'+1];\\n        r = new int[\\'z\\'-\\'a\\'+1];\\n        Arrays.fill(l,Integer.MAX_VALUE);\\n        Arrays.fill(r,-1);\\n        for(int i = 0;i<s.length();i++){\\n            int index = s.charAt(i)-\\'a\\';\\n            l[index] = Math.min(i,l[index]);\\n            r[index] = i;\\n        }", "class Solution {\\n    \\n    int[] l;\\n    int[] r;\\n    \\n    public List<String> maxNumOfSubstrings(String s) {\\n        List<String> res = new ArrayList<String>();\\n        l = new int[\\'z\\'-\\'a\\'+1];\\n        r = new int[\\'z\\'-\\'a\\'+1];\\n        Arrays.fill(l,Integer.MAX_VALUE);\\n        Arrays.fill(r,-1);\\n        for(int i = 0;i<s.length();i++){\\n            int index = s.charAt(i)-\\'a\\';\\n            l[index] = Math.min(i,l[index]);\\n            r[index] = i;\\n        }"]}
{"id": "2021", "ref_java": ["class Solution {\\n    public int closestToTarget(int[] arr, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans =100000000;\\n        for(int x:arr){\\n            Set<Integer> newSet = new HashSet<>();\\n            newSet.add(x);\\n            for(int y : set)newSet.add(y&x);\\n            for(int y : newSet)ans = Math.min(ans,Math.abs(target-y));\\n            set = newSet;\\n        }", "class Solution {\\n    public int closestToTarget(int[] arr, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans =100000000;\\n        for(int x:arr){\\n            Set<Integer> newSet = new HashSet<>();\\n            newSet.add(x);\\n            for(int y : set)newSet.add(y&x);\\n            for(int y : newSet)ans = Math.min(ans,Math.abs(target-y));\\n            set = newSet;\\n        }", "class Solution {\\n    public int closestToTarget(int[] arr, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans =100000000;\\n        for(int x:arr){\\n            Set<Integer> newSet = new HashSet<>();\\n            newSet.add(x);\\n            for(int y : set)newSet.add(y&x);\\n            for(int y : newSet)ans = Math.min(ans,Math.abs(target-y));\\n            set = newSet;\\n        }"]}
{"id": "2022", "ref_java": ["class Solution {\\n    public int minNumberOperations(int[] target) {\\n        int cnt =0, prev = 0;\\n        \\n        for(int i=0; i<target.length; i++) {\\n            if(target[i] > prev) {\\n                cnt+=(target[i]-prev);\\n            }", "class Solution {\\n    public int minNumberOperations(int[] target) {\\n        int operations = target[0];\\n        for(int i=1;i<target.length;i++) {\\n            if(target[i] > target[i-1]) {\\n                operations += target[i] - target[i-1];\\n            }", "class Solution {\\n    public int minNumberOperations(int[] target) {\\n \\n        int prev=0;\\n        int n=target.length;\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(prev<target[i]){\\n                ans +=target[i]-prev;\\n            }"]}
{"id": "2023", "ref_java": ["class Solution {\\n    public int getLengthOfOptimalCompression(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[110][110];\\n        for (int i = 0; i <= n; i++) \\n            for (int j = 0; j <= n; j++) \\n                dp[i][j] = 9999;\\n\\t\\t        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 0; j <= k; j++) {                \\n                int cnt = 0, del = 0;\\n                for(int l = i; l >= 1; l--) { \\n                    if(s.charAt(l - 1) == s.charAt(i - 1)) cnt++;\\n                    else del++;\\n                    if(j - del >= 0) \\n                        dp[i][j] = Math.min(dp[i][j], \\n                                            dp[l-1][j-del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1: 0));\\n                }", "class Solution {\\n    public int getLengthOfOptimalCompression(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[110][110];\\n        for (int i = 0; i <= n; i++) \\n            for (int j = 0; j <= n; j++) \\n                dp[i][j] = 9999;\\n\\t\\t        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 0; j <= k; j++) {                \\n                int cnt = 0, del = 0;\\n                for(int l = i; l >= 1; l--) { \\n                    if(s.charAt(l - 1) == s.charAt(i - 1)) cnt++;\\n                    else del++;\\n                    if(j - del >= 0) \\n                        dp[i][j] = Math.min(dp[i][j], \\n                                            dp[l-1][j-del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1: 0));\\n                }", "class Solution {\\n    public int getLengthOfOptimalCompression(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[110][110];\\n        for (int i = 0; i <= n; i++) \\n            for (int j = 0; j <= n; j++) \\n                dp[i][j] = 9999;\\n\\t\\t        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 0; j <= k; j++) {                \\n                int cnt = 0, del = 0;\\n                for(int l = i; l >= 1; l--) { \\n                    if(s.charAt(l - 1) == s.charAt(i - 1)) cnt++;\\n                    else del++;\\n                    if(j - del >= 0) \\n                        dp[i][j] = Math.min(dp[i][j], \\n                                            dp[l-1][j-del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1: 0));\\n                }"]}
{"id": "2024", "ref_java": ["class Solution {\\n    public int maxSum(int[] nums1, int[] nums2) {\\n        long currSum = 0, sum1 = 0, sum2 = 0;\\n        int i = 0;\\n        int j = 0;\\n        while(i < nums1.length && j < nums2.length){\\n            if(nums1[i] == nums2[j]) {\\n                currSum += Math.max(sum1, sum2) + nums2[j];\\n                sum1 = 0;\\n                sum2 = 0;\\n                i++;\\n                j++;\\n            }", "class Solution {\\n    public int maxSum(int[] nums1, int[] nums2) {\\n        \\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i=0, j=0;\\n        long si=0, sj=0;\\n        long res = 0;\\n        \\n        while(i<n && j<m)\\n        {\\n            if(nums1[i] < nums2[j])\\n            {\\n                si += nums1[i];\\n                i++;\\n            }", "class Solution {\\n    public int maxSum(int[] nums1, int[] nums2) {\\n        long sum1=0,sum2=0,res=0;\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length){\\n             if(nums1[i]<nums2[j]){\\n                sum1+=nums1[i++];\\n             }"]}
{"id": "2025", "ref_java": ["class Solution {\\n    public int longestAwesome(String s) {\\n        return util1(s);\\n    }", "class Solution {\\n    public int longestAwesome(String s) {\\n        int ans = 0;\\n        ", "class Solution {\\n\\n    public int longestAwesome(String s) {\\n        int n = s.length() , max = 0, mask = 0;\\n        Map <Integer, Integer> firstMaskAppearanceMap = new HashMap(); "]}
{"id": "2026", "ref_java": ["class Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] newCuts = new int[cuts.length + 2];\\n        newCuts[0] = 0;\\n        newCuts[newCuts.length - 1] = n;\\n        System.arraycopy(cuts, 0, newCuts, 1, cuts.length);\\n        Arrays.sort(newCuts);\\n        \\n        int[][] dp = new int[newCuts.length][newCuts.length];\\n        for (int len = 2; len < newCuts.length; len++) {\\n            for (int i = 0; i + len < newCuts.length; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + newCuts[j] - newCuts[i]);\\n                }", "class Solution {\\n    Integer dp[][]; int n, cuts[];\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        dp = new Integer[cuts.length+2][cuts.length+2];\\n        this.n=n;\\n        this.cuts=cuts;\\n        return f(0, cuts.length+1);\\n    }", "class Solution {\\n    int minCostHelp(int i, int j, vector<vector<int>> &dp, vector<int> &cuts) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for (int k = i; k <= j; k++) {\\n            mini = min(mini,\\n                    cuts[j + 1] - cuts[i - 1] + minCostHelp(i, k - 1, dp, cuts) + minCostHelp(k + 1, j, dp, cuts));\\n        }"]}
{"id": "2027", "ref_java": ["class Solution {\\n\\n    static HashMap<Integer,Integer> hp;\\n\\n    static int helper(int n){  ", "class Solution {\\n    private HashMap<Integer,Integer> mp = new HashMap<>();\\n    public int minDays(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(mp.containsKey(n))\\n            return mp.get(n);\\n        \\n        mp.put(n, 1 + Math.min(n % 2 + minDays(n/2), n % 3 + minDays(n/3)));\\n        return mp.get(n);\\n    }", "class Solution {\\n    Map<Integer ,Integer>dp = new HashMap<>();\\n    public int minDays(int n)\\n    {\\n        if(n<=1)\\n            return n;\\n        if(!dp.containsKey(n))\\n            dp.put(n,1+Math.min(n%2+minDays(n/2),n%3+minDays(n/3)));\\n        return dp.get(n);\\n    }"]}
{"id": "2028", "ref_java": ["class Solution {\\n    Integer[][] dp;\\n    public int stoneGameV(int[] stoneValue) {\\n        dp = new Integer[stoneValue.length][stoneValue.length];\\n        int total = 0;\\n        for(int x:stoneValue){\\n            total+=x;\\n        }", "class Solution {\\n    public int findSum(int[] stoneValue)\\n    {\\n        int sum=0;\\n        for(int n:stoneValue) sum+=n;\\n        return sum; ", "class Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }"]}
{"id": "2029", "ref_java": ["class Solution {\\n    int[] xDir = {0,0,-1,1}", "class Solution {\\n    int[] xDir = {0,0,-1,1}", "class Solution {\\n    static int [][]dirs={{-1,0}"]}
{"id": "2030", "ref_java": ["class Solution {\\n    private static final int MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }", "class Solution {\\n    public int numOfWays(int[] nums) {\\n        List<Integer> arr=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            arr.add(nums[i]);\\n        }", "class Solution {\\n    int mod = 1e9+7;\\n    vector<vector<ll>> pascal;\\n    \\n    ll numOfWaysHelp(vector<int>& nums) {\\n        if(nums.size() <= 2) return 1;\\n\\n        vector<int> leftSubtree, rightSubtree;\\n        int n = nums.size();\\n        for(int i=1; i<n; i++){\\n            if( nums[i] < nums[0] ) leftSubtree.push_back(nums[i]);\\n            else rightSubtree.push_back(nums[i]);\\n        }"]}
{"id": "2031", "ref_java": ["class Solution {\\n    \\n    int MOD = (int)1e9 + 7;\\n    public int countRoutes(int[] locations, int start, int finish, int fuel) {\\n\\n        int l = locations.length;\\n        int[][] dp = new int[l + 1][fuel + 1];\\n        for(int[] num : dp){\\n            Arrays.fill(num, -1);\\n        }", "class Solution {\\n    \\n    int MOD = (int)1e9 + 7;\\n    public int countRoutes(int[] locations, int start, int finish, int fuel) {\\n\\n        int l = locations.length;\\n        int[][] dp = new int[l + 1][fuel + 1];\\n        for(int[] num : dp){\\n            Arrays.fill(num, -1);\\n        }", "class Solution {\\n    int [][] dp;\\n    int n;\\n    int finish;\\n    public int solve(int[] locations, int currCity, int remainingFuel) {\\n        if (remainingFuel < 0) {\\n            return 0;\\n        }"]}
{"id": "2032", "ref_java": ["class Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n        var alice = new UF(n);\\n        var bob = new UF(n);\\n\\n        var remainigEdges = edges.length;\\n        ", "class Solution {\\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\\n\\n        Arrays.sort(edges, (a, b) -> b[0]-a[0]); ", "class Solution {\\n    class DSU{\\n        int[] parent;\\n        int[] rank;\\n        int islands;\\n\\n        DSU(int size){\\n            islands=size;\\n            parent = new int[size];\\n            rank = new int[size];\\n            for(int i=0; i<size; i++){\\n                parent[i]=i;\\n                rank[i]=0;\\n            }"]}
{"id": "2033", "ref_java": ["class Solution {\\n    public boolean isTransformable(String s, String t) \\n    {\\n        int[][] sr = new int[10][10];\\n        int[][] tr = new int[10][10];\\n        int[] sc = new int[10];\\n        int[] tc = new int[10];\\n        boolean equal = true;\\n        \\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            int ss = s.charAt(i) - \\'0\\';\\n            int tt = t.charAt(i) - \\'0\\';\\n            if (equal) \\n            {\\n                switch (Integer.compare(tt,ss)) \\n                {\\n                    case 1: return false; ", "class Solution {\\n    public boolean isTransformable(String s, String t) {\\n        int[][] sr = new int[10][10];\\n        int[][] tr = new int[10][10];\\n        int[] sc = new int[10];\\n        int[] tc = new int[10];\\n        boolean equal = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            int ss = s.charAt(i) - \\'0\\';\\n            int tt = t.charAt(i) - \\'0\\';\\n            if (equal) {\\n                switch (Integer.compare(tt,ss)) {\\n                    case 1: return false; ", "class Solution {\\n    public boolean isTransformable(String s, String t) {\\n        if (!equal(s, t)) return false;\\n        int[] countS = new int[10];\\n        int[] countT = new int[10];\\n        int[][] prev = new int[10][10];\\n        int[][] after = new int[10][10];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int s1 = s.charAt(i) - \\'0\\';\\n            int t1 = t.charAt(i) - \\'0\\';\\n            countS[s1]++;\\n            countT[t1]++;\\n            \\n\\t\\t\\t"]}
{"id": "2034", "ref_java": ["class Solution {\\n    private boolean isRectangle(int[][] grid , int n , int r1 , int c1,int r2, int c2, Set<Integer> rect){\\n        for(; r1 <= r2; r1++){\\n            for(int i = c1; i <= c2; i++){\\n                if(grid[r1][i] == n || rect.contains(grid[r1][i])){\\n                    continue;\\n                }", "class Solution {\\n    private final Map<Integer, Coordinates> colorsToCoordinates = new HashMap<>();\\n    private final Map<Integer, Set<Integer>> nodeToChildren = new HashMap<>();\\n    private final Map<Integer, Integer> inDegree = new HashMap<>();\\n    private final List<Integer> colors = new ArrayList<>();\\n\\n    public boolean isPrintable(int[][] targetGrid) {\\n        extractColors(targetGrid);\\n        createGraph(targetGrid);\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int color: colors) if (!inDegree.containsKey(color)) queue.add(color);\\n        int index = 0;\\n        while (!queue.isEmpty()) {\\n            int color = queue.remove();\\n            for (int child: nodeToChildren.getOrDefault(color, new HashSet<>())) {\\n                inDegree.put(child, inDegree.get(child) - 1);\\n                if (inDegree.get(child) == 0) {\\n                    queue.add(child);\\n                }", "class Solution {\\n    private Set<Integer>[] graph;\\n    private int m, n;\\n    private final int maxColor = 60;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        m = targetGrid.length;\\n        n = targetGrid[0].length;\\n        graph = new HashSet[maxColor + 1];\\n        for(int color = 1; color <= maxColor; ++color) {\\n            int minI = m, minJ = n;\\n            int maxI = -1, maxJ = -1;\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(targetGrid[i][j] == color) {\\n                        minI = Math.min(minI, i);\\n                        minJ = Math.min(minJ, j);\\n                        maxI = Math.max(maxI, i);\\n                        maxJ = Math.max(maxJ, j);\\n                    }"]}
{"id": "2035", "ref_java": ["class Solution {\\n    int Asize=0;\\n    int[][][] map;\\n    int resultMask=0;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        Asize=cost.get(0).size();\\n        resultMask=(1<<(Asize))-1;\\n        map=new int[cost.get(0).size()][cost.size()][resultMask+1];\\n        return helper(cost,0,0,0);\\n    }", "class Solution {\\n\\tprivate int minCost;\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tminCost = Integer.MAX_VALUE;\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n\\t\\tboolean[] connected = new boolean[gp1Size + gp2Size];\\n\\t\\tdfs(0, 0, cost, connected);\\n\\t\\treturn minCost;\\n\\t}", "class Solution {\\n    int m;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        this.m = cost.get(0).size();\\n        int nState = 1 << m;\\n        int[][] dp = new int[n + 1][nState];\\n        int[][] costsOfNSecondGroupForOneFirstGroup = new int[n][nState];\\n        for (int i = 0; i < n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                costsOfNSecondGroupForOneFirstGroup[i][state] = getCostsForOneToN(cost, i, state);\\n            }"]}
{"id": "2036", "ref_java": ["class Solution {\\n    int permits;\\n    public int maximumRequests(int n, int[][] requests) {\\n        permits = 0;\\n        backtrack(0, 0, requests, new int[n]);\\n        return permits;\\n    }", "class Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }", "class Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }"]}
{"id": "2037", "ref_java": ["class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        ", "class Solution {\\n    \\n    ServerComparator serverComparator = new ServerComparator();\\n    \\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int[] serverRequestsCounter = new int[k];\\n        \\n        \\n        ", "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();\\n        for (int i = 0; i < k; i++) {\\n            available.add(i);\\n        }"]}
{"id": "2038", "ref_java": ["class Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int overlap = 0;\\n        List<Double> list = new ArrayList<>(points.size());\\n        for (List<Integer> p : points) {\\n            if (p.get(0) == location.get(0) && p.get(1) == location.get(1)) {\\n                overlap++;\\n            }", "class Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int[][] A = new int[points.size()][2];\\n        for (int i = 0; i < points.size(); i++){\\n            A[i][0]=points.get(i).get(0)-location.get(0);\\n            A[i][1]=points.get(i).get(1)-location.get(1);\\n        }", "class Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int pointer = 0;\\n        List<Double> lis = new ArrayList<>();\\n        for(List<Integer> point : points){\\n            if(point.get(0) - location.get(0) == 0 && point.get(1) - location.get(1) == 0) {\\n                pointer++; continue;\\n            }"]}
{"id": "2039", "ref_java": ["class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int multiplier = 1;\\n        int res = 0;\\n        while (n > 0) {\\n            res += n ^ (n - 1) * multiplier;\\n            multiplier = -1 * multiplier;\\n            n &= n - 1;\\n        }", "class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int ans = 0, f = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            if (((n >> i) & 1) == 1) {\\n                if (f == 0) {\\n                    ans = ans + ((1 << (i + 1))) - 1;\\n                    f = 1;\\n                }", "class Solution {\\n    int min = Integer.MAX_VALUE;\\n    public int minimumOneBitOperations(int n) {\\n        if (n <= 1) return n;\\n        int count = 0;\\n        while ((1<<count) <= n) count++;\\n        return ((1<<count)-1) - minimumOneBitOperations(n-(1<<(count-1)));\\n    }"]}
{"id": "2040", "ref_java": ["class Solution {\\n\\n    List<Integer>[] tree, subTree;\\n    int subTreeRoot, maxPath;\\n    boolean[] inStack; ", "class Solution {\\n    private List<Integer>[] g;\\n    private int msk;\\n    private int nxt;\\n    private int mx;\\n\\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\\n        g = new List[n];\\n        Arrays.setAll(g, k -> new ArrayList<>());\\n        for (int[] e : edges) {\\n            int u = e[0] - 1, v = e[1] - 1;\\n            g[u].add(v);\\n            g[v].add(u);\\n        }", "class Solution {\\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\\n         \\n        \\n       ArrayList<Integer>[] graph = (ArrayList<Integer>[]) new ArrayList[n];\\n       for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        \\n         for(int i=0;i<edges.length;i++)\\n         {\\n             int u = edges[i][0];\\n             int v = edges[i][1];\\n             \\n             --u;\\n             --v;\\n             \\n             graph[u].add(v);\\n             graph[v].add(u);\\n         }"]}
{"id": "2042", "ref_java": ["class Solution {\\n    class UF {\\n        int arr[], N; boolean vis[];\\n        UF(int n) {\\n            N=n+1;\\n            arr=new int[N]; vis=new boolean[N];\\n            for(int i=0; i<n; arr[i]=i++);\\n        }", "class Solution {\\n    int[] p;\\n    int[] r;\\n    \\n    int find(int x){\\n        if(p[x]==x){\\n            return x;\\n        }", "class Solution {\\n\\n\\n    class UFDS {\\n\\n        private int [] p;\\n        private int [] rank;\\n\\n        UFDS(int n) {\\n            this.p = new int[n];\\n            this.rank = new int[n];\\n            for(int i = 0; i < n; i++) {\\n                p[i] = i;\\n            }"]}
{"id": "2043", "ref_java": ["class Solution {\\n    public int[][] matrixRankTransform(int[][] m) {\\n        int M = m.length, N = m[0].length;\\n        int[][] a = new int[M][N];\\n        int[] maxRankRow = new int[M];\\n        int[] maxRankCol = new int[N];\\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>();\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                map.putIfAbsent(m[i][j], new ArrayList<>());\\n                map.get(m[i][j]).add(new int[] { i, j }", "class Solution {\\n    int[] parent;\\n    public int[][] matrixRankTransform(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] answer = new int[m][n];\\n        \\n        ", "class Solution {\\n    public int[][] matrixRankTransform(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] idx = IntStream.range(0, m*n).boxed().sorted(Comparator.comparingInt(o -> matrix[o/n][o%n])).mapToInt(o->o).toArray(); "]}
{"id": "2044", "ref_java": ["class Solution {\\n    int[][] count;\\n    int MOD = (int) (Math.pow(10, 9) + 7);\\n    Long[][] memo;\\n    \\n    public int numWays(String[] words, String target) {\\n        count = new int[26][words[0].length()];\\n        memo = new Long[words[0].length()][target.length()];\\n        \\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                count[word.charAt(i) - \\'a\\'][i]++;\\n            }", "class Solution {\\n    \\n    long MOD = 1000000007;\\n    public int numWays(String[] words, String target) {\\n        \\n        int len = target.length();\\n        int max = words[0].length();\\n        \\n        int[][] charFrequency = new int[max][26];\\n\\t\\t", "class Solution {\\n    private int mod=(int)1e9+7;\\n    public int numWays(String[] words, String target) {\\n        int charsAtInd[][]=new int[words[0].length()][26];\\n        for(int j=0;j<words[0].length();j++){\\n            for(String w:words)    charsAtInd[j][w.charAt(j)-\\'a\\']++;\\n        }"]}
{"id": "2045", "ref_java": ["class Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }", "class Solution {\\n    ", "class Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int m=d[0]+1;\\n        int n=d[1]+1;\\n        int dp[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n          for(int j=0;j<n;j++){\\n            if(i==0 && j==0) dp[i][j]=1;\\n            else if(i==0)dp[i][j]=dp[i][j-1];\\n            else if(j==0)dp[i][j]=dp[i-1][j];\\n            else dp[i][j]=dp[i][j-1]+dp[i-1][j];\\n          }"]}
{"id": "2046", "ref_java": ["class Solution {\\n    public class SegTree{\\n        private SegTree left,right;\\n        private int start,end,info;\\n        public SegTree(int start, int end){\\n            this.start = start ;\\n            this.end = end;\\n            this.info = 0;\\n            this.left = null;\\n            this.right = null;\\n        }", "class Solution {\\n    public class SegTree{\\n        private SegTree left,right;\\n        private int start,end,info;\\n        public SegTree(int start, int end){\\n            this.start = start ;\\n            this.end = end;\\n            this.info = 0;\\n            this.left = null;\\n            this.right = null;\\n        }", "class Solution {\\n    int[] tree;\\n    public int createSortedArray(int[] instructions) {\\n        if(instructions.length == 0) {\\n            return 0;\\n        }"]}
{"id": "2047", "ref_java": ["class Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int sum = 0;\\n        for (int num : quantity)\\n            sum += num;\\n        if (sum > nums.length)\\n            return false;\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int num : nums) {\\n            int count = map.getOrDefault(num, 0) + 1;\\n            map.put(num, count);\\n        }", "class Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        \\n        ", "class Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n   "]}
{"id": "2048", "ref_java": ["class Solution {\\n    static int NONE = 0;\\n    static int INTROVERT = 1;\\n    static int EXTROVERT = 2;\\n\\n    public int adjust(int board, int this_is, int col, int index) {\\n        int shift_by = 2 * (col - 1);\\n\\n        ", "class Solution {\\n    static int[][][][][] dp;\\n\\n    public int getMaxGridHappiness(int m, int n, int intr, int extr) {\\n\\n        dp = new int[30][33][33][intr + 1][extr + 1];\\n\\n        for (int i = 0; i < 30; i++) {\\n            for (int j = 0; j < 33; j++) {\\n                for (int k = 0; k < 33; k++) {\\n                    for (int l = 0; l <= intr; l++) {\\n                        Arrays.fill(dp[i][j][k][l], -1);\\n                    }", "class Solution {\\n    int M, INF = (int)-1e9; "]}
{"id": "2049", "ref_java": ["class Solution {\\n    public int minimumEffort(int[][] tasks) {\\n        Arrays.sort(tasks, (a, b) -> Integer.compare(a[1] - a[0], b[1] - b[0]));\\n        int has = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            has = Math.max(tasks[i][1], has + tasks[i][0]);\\n        }", "class Solution {\\n    public int minimumEffort(int[][] tasks) {\\n        Arrays.sort(tasks,(a,b)->a[1]-a[0]-b[1]+b[0]);\\n        int prev=0;\\n        for (int[] item:tasks){\\n            prev=Math.max(prev+item[0],item[1]);\\n        }", "class Solution {\\n    public int minimumEffort(int[][] tasks) {\\n        int[] mapDiffToCost = new int[10001];\\n        for(int[] task : tasks) {\\n            mapDiffToCost[task[1] - task[0]] += task[0];\\n        }"]}
{"id": "2050", "ref_java": ["class Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int left[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    left[i]=Math.max(left[i],left[j]+1);\\n                }", "class Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        ", "class Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<=i-1;prev++)\\n            {\\n                if(nums[prev]<nums[i] && dp1[prev]+1>dp1[i])\\n                    dp1[i]=dp1[prev]+1;\\n            }"]}
{"id": "2051", "ref_java": ["class Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int x : nums)\\n            if (x%2 == 0)\\n                set.add(x);\\n            else\\n                set.add(x*2);\\n        int ans = Integer.MAX_VALUE;\\n        while (true) {\\n            int val = set.last();\\n            ans = Math.min(ans, val - set.first());\\n            if (val%2 == 0) {\\n                set.remove(val);\\n                set.add(val/2);\\n            }", "class Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int min=Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num*=2;\\n            }", "class Solution {\\n    public int minimumDeviation(int[] nums) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n        \\n        for(int i:nums){\\n            if(i%2==1) i*=2;\\n            set.add(i);\\n        }"]}
{"id": "2052", "ref_java": ["class Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Integer[] mem = new Integer[1<<nums.length];\\n        int min =  min(nums,k,(1<<nums.length)-1,mem);\\n        return min==Integer.MAX_VALUE?-1:min;\\n    }", "class Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        k=nums.length/k;\\n        int n = nums.length,INF=100;\\n        int[][] dp = new int[1<<n][n];\\n        for (int[] d : dp){\\n            Arrays.fill(d, INF);\\n        }", "class Solution {\\n\\n\\tstatic HashMap<Integer, Integer> m;\\n\\tpublic static int minimumIncompatibility(int[] nums, int k) {        \\n        m = new HashMap<>();\\n        \\n        int ans = dp(0, nums, k);\\n        if (ans >= (int)(1e9)) {\\n        \\treturn -1;\\n        }"]}
{"id": "2053", "ref_java": ["class Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }", "class Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n=boxes.length, presum[]=new int[n+1], preWeight[]=new int[n+1], mb=maxBoxes, mw=maxWeight;\\n        \\n        for(int i=0; i<n; i++){\\n            ", "class Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        "]}
{"id": "2054", "ref_java": ["class Solution {     \\n    public int maxHeight(int[][] cuboids) {\\n\\t\\t\\n        \\n        for(int[] el: cuboids){\\n            if(el[0] > el[2]){\\n                int temp = el[0];\\n                el[0] = el[2];\\n                el[2] = temp;\\n            }", "class Solution {\\n    public int maxHeight(int[][] arr) {\\n        for(int[]a:arr)Arrays.sort(a);\\n        \\n        Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[]a,int[]b){\\n                if(a[0]!=b[0])return a[0]-b[0];\\n                else\\n                if(a[1]!=b[1])return a[1]-b[1];\\n                return a[2]-b[2];\\n            }", "class Solution {\\n    public int maxHeight(int[][] cuboids) {\\n         int n = cuboids.length;\\n        for(int i = 0; i< n;i++){\\n            Arrays.sort(cuboids[i]);\\n        }"]}
{"id": "2055", "ref_java": ["class Solution {\\n    int p[];\\n    int find(int a) { return p[a]==a? a: (p[a]=find(p[a])); }", "class Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        var uf = new UF(n);\\n        Arrays.sort(edgeList, Comparator.comparingInt(a -> a[2]));\\n\\n        for (var e : edgeList)\\n            uf.union(e[0], e[1], e[2]);\\n        \\n        var answer = new boolean[queries.length];\\n        for (var i = 0; i < queries.length; ++i)\\n            answer[i] = uf.connected(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }", "class Solution {\\n    \\n    int[] parent;\\n    int[] rank;\\n    \\n    Solution(){\\n        int n = 100004;\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i = 0;i<n;i++)\\n            parent[i] = i;\\n    }"]}
{"id": "2056", "ref_java": ["class Solution {\\n    public int minMoves(int[] nums, int k) {\\n      \\n        List<Integer> ones = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                ones.add(i);\\n            }", "class Solution {\\n    private List<Integer> list;\\n    public int minMoves(int[] nums, int k) {\\n        if(nums.length == k) return 0;\\n        int Le = 0, Re = 0, mid, L = 0, R = 0, cost, minCost = Integer.MAX_VALUE, j;\\n        list = new ArrayList<>();\\n        for(int i = 0; i<nums.length; ++i){\\n            if(nums[i] == 1){\\n                list.add(i);\\n            }", "class Solution {\\n    public int minMoves(int[] a, int k) {\\n\\t\\tint n = a.length;\\n\\t\\tArrayList<Integer> oneInd = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tif (a[i] == 1)\\n\\t\\t\\t\\toneInd.add(i);\\n\\t\\tint prfsm[] = new int[oneInd.size()];\\n\\t\\tfor (int i = 0; i < oneInd.size(); i++)\\n\\t\\t\\tprfsm[i] += oneInd.get(i) + (i == 0 ? 0 : prfsm[i - 1]);\\n\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\tint left = 0, right = k - 1;\\n\\t\\twhile (right < oneInd.size()) {\\n\\t\\t\\tif (k % 2 == 1) {\\n\\t\\t\\t\\tint medianInd = left + (k + 1) / 2 - 1;\\n\\t\\t\\t\\tint rad = medianInd - left;\\n\\t\\t\\t\\tint res = (prfsm[right] - prfsm[medianInd])\\n\\t\\t\\t\\t\\t\\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1])) - rad * (rad + 1);\\n\\t\\t\\t\\tans = Math.min(ans, res);\\n\\t\\t\\t}"]}
{"id": "2057", "ref_java": ["class Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            int xi = queries[i][0];\\n            int ai = queries[i][1];\\n            \\n            int maxXOR = -1;\\n            \\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[j] <= ai) {\\n                    maxXOR = Math.max(maxXOR, nums[j] ^ xi);\\n                }", "class Solution {\\n\\n    class Trie {\\n        Trie[] children;\\n        public Trie() {\\n            children = new Trie[2];\\n        }", "class Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        Integer[] idx = IntStream.range(0, ans.length).boxed().toArray(Integer[]::new);\\n        Arrays.sort(idx, Comparator.comparingInt(o -> queries[o][1])); "]}
{"id": "2058", "ref_java": ["class Solution {\\n  private int upperBound(List<Integer> domain, int value, int left, int right) {\\n    if (left == right) {\\n      return left;\\n    }", "class Solution {\\n  public int minOperations(int[] target, int[] arr) {\\n    List<Integer> indices = new ArrayList<>();\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n\\n    for (int i = 0; i < target.length; ++i)\\n      numToIndex.put(target[i], i);\\n\\n    for (final int a : arr)\\n      if (numToIndex.containsKey(a))\\n        indices.add(numToIndex.get(a));\\n\\n    return target.length - lengthOfLIS(indices);\\n  }", "class Solution {\\n\\t\\tpublic int minOperations(int[] target, int[] arr) {\\n\\t\\t\\tint n = target.length;\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tmap.put(target[i], i);\\n\\t\\t\\t}"]}
{"id": "2059", "ref_java": ["class Solution {\\n    public int checkWays(int[][] pairs){\\n        int MAX = 501;\\n        Node[] map = new Node[MAX];\\n        Arrays.setAll(map, o -> new Node(o));\\n        for (int[] p : pairs){ ", "class Solution {\\n    public int checkWays(int[][] pairs) {\\n        int result = 1;\\n        \\n        ", "class Solution {\\n    public int checkWays(int[][] pairs) {\\n        int result = 1;\\n        \\n        "]}
{"id": "2060", "ref_java": ["class Solution {\\n    int ans = Integer.MAX_VALUE;\\n    void rec(int ix, int[] jobs, int k, int[] dist, HashSet<Integer> assigned){\\n        if(ix == jobs.length){\\n            int max = 0;\\n            for(int job: dist){\\n                max = Math.max(max, job);\\n            }", "class Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int length = jobs.length;\\n        Arrays.sort(jobs);\\n        backtrack(jobs, length - 1, new int [k]);\\n        return result;\\n    }", "class Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int N = 1 << jobs.length, INF = (int)2e9;\\n        int[] dp = new int[N];\\n        Arrays.fill(dp, INF);\\n        dp[N-1]=0;\\n        for (int i = 0; i < k; i++){ "]}
{"id": "2061", "ref_java": ["class Solution {\\n    int[] dx = new int[]{0, 0, 1 ,-1}", "class Solution {\\n    int[] dx = new int[]{0, 0, 1 ,-1}", "class Solution {\\n    int[] dx = new int[]{0, 0, 1 ,-1}"]}
{"id": "2062", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n    static final long MOD = 1000000007;\\n    static final int MAX = 10000;\\n    static final int[] divs = new int[MAX + 1];\\n    static final int[] counts = new int[MAX + 1];\\n\\n    public int[] waysToFillArray(int[][] queries) {\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            res[i] = waysToFillArray(queries[i][0], queries[i][1]);\\n        }", "class Solution {\\n    int MOD = (int)1e9+7;\\n    static int[][] ncr;\\n    static int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}"]}
{"id": "2063", "ref_java": ["class Solution {\\n\\n    static final double ONE_THIRD = 1.0d / 3.0d;\\n\\n    public int minimumBoxes(int n) {\\n        int k = findLargestTetrahedralNotGreaterThan(n);\\n        int used = tetrahedral(k);\\n        int floor = triangular(k);\\n        int unused = (n - used);\\n        if (unused == 0) {\\n            return floor;\\n        }", "class Solution {\\n\\n    ", "class Solution {\\n    public int minimumBoxes(int n) {\\n        int cur = 0, ans1 = 0, ans2 = 0;\\n\\n        while (cur + (ans1 + 1) * (ans1 + 2) / 2 <= n) {\\n            cur += (ans1 + 1) * (ans1 + 2) / 2;\\n            ans1 += 1;\\n        }"]}
{"id": "2064", "ref_java": ["class Solution {\\n    public boolean checkPartitioning(String s) {\\n        boolean[][] isP = precomputeSubarrayPaildrome(s);\\n        int requiredCuts = 3 ;\\n        return helper(s,0,requiredCuts,isP);\\n        \\n    }", "class Solution {\\n    public boolean checkPartitioning(String s) {\\n        int N = s.length();\\n        char[] A = s.toCharArray();\\n        ", "class Solution {\\n    public boolean checkPartitioning(String s) {\\n        boolean[][] isP = precomputeSubarrayPaildrome(s);\\n        int requiredCuts = 3 ;\\n        return helper(s,0,requiredCuts,isP);\\n        \\n    }"]}
{"id": "2065", "ref_java": ["class Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n        return backtrack(0, -1, 0, events, k);\\n    }", "class Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                if(a[0]!=b[0]){\\n                    return a[0]-b[0];\\n                }", "class Solution {\\n    Integer dp[][]; int n;\\n    public int maxValue(int[][] events, int k) {\\n        n=events.length; dp=new Integer[n][k];\\n        Arrays.sort(events,(a,b)->a[0]-b[0]);\\n        return find(0, events, -1, k, 0);\\n    }"]}
{"id": "2066", "ref_java": ["class Solution {\\n    int[] arr;\\n    public int minAbsDifference(int[] nums, int goal) {\\n        arr = nums;\\n        int n = nums.length;\\n        \\n        \\n        List<Integer> first = new ArrayList<>();\\n        List<Integer> second = new ArrayList<>();\\n        \\n        generate(0,n/2,0, first); ", "class Solution {\\n    public int minAbsDifference(int[] nums, int goal)\\n    {\\n         ", "class Solution {\\n    public int minAbsDifference(int[] nums, int goal) {\\n        int n = nums.length;\\n        if(n==1){\\n            return Math.min(Math.abs(0-goal),Math.abs(nums[0]-goal));\\n        }"]}
{"id": "2067", "ref_java": ["class Solution {\\n    public int minTrioDegree(int n, int[][] edges) {\\n        int[][] adj = new int[n+1][n+1];\\n        int[] degree = new int[n+1];\\n       for(int[] edge : edges){\\n           int x = edge[0];\\n           int y = edge[1];\\n           \\n           adj[x][y] = 1;\\n           adj[y][x] = 1;\\n           \\n           degree[x]++;\\n           degree[y]++;\\n       }", "class Solution {\\n    int[] indegree;\\n    public int minTrioDegree(int n, int[][] edges) {\\n        int[][] graph=new int[n+1][n+1];\\n         indegree=new int[n+1];\\n        for(int[] edge:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            indegree[u]++;\\n            indegree[v]++;\\n            graph[u][v]=1;\\n            graph[v][u]=1;\\n        }", "class Solution {\\n    public int minTrioDegree(int n, int[][] edges) {\\n        int en=edges.length;\\n        int[] count=new int[n];\\n        for(int i=0;i<en;i++){\\n            count[edges[i][0]-1]++;\\n            count[edges[i][1]-1]++;\\n        }"]}
{"id": "2068", "ref_java": ["class Solution {\\n    private final int[][] memo = new int[51][51];\\n    public int[] getCoprimes(int[] nums, int[][] edges) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for (int[] edge: edges) {\\n            tree.computeIfAbsent(edge[0], e-> new ArrayList<>()).add(edge[1]);\\n            tree.computeIfAbsent(edge[1], e -> new ArrayList<>()).add(edge[0]);\\n        }", "class Solution {\\n    ", "class Solution {\\n\\n    int n , nums[];\\n    boolean [][] gcds;\\n    public int[] getCoprimes(int[] nums, int[][] edges) {\\n        n= nums.length;\\n        this.nums = nums;\\n        int sol[] = new int [n]; \\n        Stack[] ancWithVal = new Stack[51] , valToDepth = new Stack[51];\\n        gcds = new boolean [51][51];\\n        for (int i = 1; i<51; i++){\\n            valToDepth[i] = new Stack<Integer>();\\n            ancWithVal[i] = new Stack<Integer>();\\n            for (int j = i; j<51; j++) {\\n                gcds[i][j] = gcd(i,j);\\n                gcds[j][i] = gcds[i][j];\\n            }"]}
{"id": "2069", "ref_java": ["class Solution {\\n    int n, m;\\n    Integer[][] dp;\\n    public int maximumScore(int[] nums, int[] multipliers) {\\n        n = nums.length;\\n        m = multipliers.length;        \\n        \\n        dp = new Integer[1001][1001];\\n        return helper(0, 0, nums, multipliers);\\n    }", "class Solution {\\n    int N, M;\\n    public int maximumScore(int[] nums, int[] multipliers) {\\n        N = nums.length;\\n        M = multipliers.length;\\n\\t    return helper(nums, multipliers, 0, 0, new Integer[M][M]);\\n    }", "class Solution {\\n    public int maximumScore(int[] nums, int[] multipliers) {\\n\\n        int N = nums.length;\\n        int M = multipliers.length;\\n\\n        "]}
{"id": "2070", "ref_java": ["class Solution {\\n    public int longestPalindrome(String word1, String word2) {\\n        int len1 = word1.length(), len2 = word2.length();\\n        int starti = Integer.MAX_VALUE, startj = Integer.MIN_VALUE;\\n        for (int i = 0; i < len1; i++) {\\n            for (int j = 0; j < len2; j++) {\\n                if (word1.charAt(i) == word2.charAt(j)) {\\n                    starti = Math.min(starti, i);\\n                    startj = Math.max(startj, j);\\n                }", "class Solution {\\n    public int longestPalindrome(String word1, String word2) {\\n        int len1 = word1.length(), len2 = word2.length();\\n        int starti = Integer.MAX_VALUE, startj = Integer.MIN_VALUE;\\n        for (int i = 0; i < len1; i++) {\\n            for (int j = 0; j < len2; j++) {\\n                if (word1.charAt(i) == word2.charAt(j)) {\\n                    starti = Math.min(starti, i);\\n                    startj = Math.max(startj, j);\\n                }", "class Solution {\\n    public int longestPalindrome(String word1, String word2) {\\n        String lWord = word1 + word2;\\n        return palindrome(lWord, 0, lWord.length()-1, word1.length(), false, \\n                          new int[lWord.length()][lWord.length()][2]);\\n    }"]}
{"id": "2071", "ref_java": ["class Solution {\\n    public double[] getCollisionTimes(int[][] cars) {\\n        int n = cars.length;\\n        double[] res = new double[n];\\n        Arrays.fill(res, -1.0);\\n        \\n        ", "class Solution {\\n    public double[] getCollisionTimes(int[][] cars) {\\n        return util1(cars);\\n    }", "class Solution {\\n    class Node {\\n        int id; "]}
{"id": "2072", "ref_java": ["class Solution {\\n    public int[] countPairs(int n, int[][] edges, int[] queries) {\\n        Map<Integer, Map<Integer, Integer>> dupMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int[] ans = new int[queries.length];\\n        int[] count = new int[n];\\n        for (int[] e : edges){\\n            int min = Math.min(e[0]-1, e[1]-1);\\n            int max = Math.max(e[0]-1, e[1]-1);\\n            dupMap.computeIfAbsent(min, o -> new HashMap<>()).merge(max, 1, Integer::sum);\\n            map.computeIfAbsent(min, o -> new HashSet<>()).add(max);\\n            count[min]++;\\n            count[max]++;\\n        }", "class Solution {\\n    public int[] countPairs(int n, int[][] edges, int[] queries) {\\n        Map<Integer, Map<Integer, Integer>> dupMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int[] ans = new int[queries.length];\\n        int[] count = new int[n];\\n        for (int[] e : edges){\\n            int min = Math.min(e[0]-1, e[1]-1);\\n            int max = Math.max(e[0]-1, e[1]-1);\\n            dupMap.computeIfAbsent(min, o -> new HashMap<>()).merge(max, 1, Integer::sum);\\n            map.computeIfAbsent(min, o -> new HashSet<>()).add(max);\\n            count[min]++;\\n            count[max]++;\\n        }", "class Solution {\\n    "]}
{"id": "2073", "ref_java": ["class Solution {\\n    public int minChanges(int[] nums, int K) {\\n        int INF = (int)1e9, A = 1<<10;\\n        BitSet[] bit = new BitSet[K];\\n        Arrays.setAll(bit, o -> new BitSet());\\n        int[][] count = new int[K][A];\\n        int[] ttl = new int[K];\\n        for (int i = 0; i < nums.length; i++){\\n            bit[i%K].set(nums[i]);\\n            count[i%K][nums[i]]++;\\n            ttl[i%K]++;\\n        }", "class Solution {\\n    public int minChanges(int[] nums, int K) {\\n        int INF = (int)1e9, A = 1<<10;\\n        BitSet[] bit = new BitSet[K];\\n        Arrays.setAll(bit, o -> new BitSet());\\n        int[][] count = new int[K][A];\\n        int[] ttl = new int[K];\\n        for (int i = 0; i < nums.length; i++){\\n            bit[i%K].set(nums[i]);\\n            count[i%K][nums[i]]++;\\n            ttl[i%K]++;\\n        }", "class Solution {\\n    public int minChanges(int[] nums, int K) {\\n        int INF = (int)1e9, A = 1<<10;\\n        BitSet[] bit = new BitSet[K];\\n        Arrays.setAll(bit, o -> new BitSet());\\n        int[][] count = new int[K][A];\\n        int[] ttl = new int[K];\\n        for (int i = 0; i < nums.length; i++){\\n            bit[i%K].set(nums[i]);\\n            count[i%K][nums[i]]++;\\n            ttl[i%K]++;\\n        }"]}
{"id": "2074", "ref_java": ["class Solution {\\n    public int maximumScore(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        int[] leftBoundary = new int[n]; ", "class Solution {\\n    public int maximumScore(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        int[] leftBoundary = new int[n]; ", "class Solution {\\n    public int maximumScore(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        int[] leftBoundary = new int[n]; "]}
{"id": "2075", "ref_java": ["class Solution {\\n    Map<String, Integer> dp = new HashMap<>();\\n    int len;\\n    public int maxScore(int[] nums) {\\n        len = nums.length;\\n        char[] mask = new char[len];\\n        for (int i = 0; i < len; i++) mask[i] = \\'0\\';\\n        return dfs(mask, 0, nums);\\n    }", "class Solution {\\n    public int maxScore(int[] nums) {\\n        dp=new HashMap<>();\\n        return util(nums, new boolean[nums.length], nums.length/2);\\n    }", "class Solution {\\n    public int maxScore(int[] nums) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return helper(nums, 1, 0, memo);\\n    }"]}
{"id": "2076", "ref_java": ["class Solution {\\n    public int countPairs(int[] nums, int low, int high) {\\n        int count = 0;\\n        Trie trie = new Trie();\\n        for(int num : nums){\\n            int highLimit = trie.countPairs(num, (high+1));\\n            int lowLimit = trie.countPairs(num, low);\\n            count += (highLimit-lowLimit);\\n            trie.add(num);\\n        }", "class Solution {\\n    class TrieNode {\\n        int count = 0;\\n        TrieNode[] children = new TrieNode[2];\\n    }", "class Solution {\\n    final static int MAX_BIT=14;\\n    public int countPairs(int[] nums, int low, int high) {\\n        int n=nums.length, count=0;\\n        Trie root=new Trie(Integer.MAX_VALUE);\\n        for(int i=0; i<n; i++){\\n            count+=query(nums[i], high, root, 14);\\n            count-=query(nums[i], low-1, root, 14);\\n            insert(nums[i], root);\\n        }"]}
{"id": "2077", "ref_java": ["class Solution {\\nprivate static long mod = 1000000007;\\nprivate static long pow(long n){\\n    if(n==0) return 1;\\n    long half=pow(n/2);\\n    if(n%2==0) return (half*half)%mod;\\n    return (3*half*half)%mod;\\n}", "class Solution {\\n\\n\\n    long mod = 1000000007;\\n    \\n    public int maxNiceDivisors(int n) {\\n        long ans = 0;\\n        if(n == 1)\\n            return 1;\\n       \\n        if(n%3 == 0) ans = power(3, n/3);\\n        if(n%3 == 1) ans = (4*power(3,n/3-1))%mod;\\n        if(n%3 == 2) ans = (2*power(3,n/3))%mod;\\n        \\n        return (int)ans;\\n        \\n    }", "class Solution {\\n    int MOD = (int)(1e9+7);\\n\\n    public int maxNiceDivisors(int n) {\\n        if(n <= 3) return n;\\n        \\n        \\n        \\n        \\n        long divisorCount = 1L;\\n        int remainder = n % 3;\\n        \\n        if(remainder == 0){\\n            divisorCount = power(3, n / 3);\\n        \\n        }"]}
{"id": "2078", "ref_java": ["class Solution {\\n    \\n    HashMap<Long, Integer> map = new HashMap<>();\\n    \\n    class State {\\n        long mask = 0;\\n        \\n        State(long v) {\\n            mask = v;\\n        }", "class Solution {\\n    public int maxHappyGroups(int batchSize, int[] groups) {\\n        int[] lack=new int[9];\\n        for(int i=0;i<groups.length;i++)\\n            lack[groups[i]%batchSize]++;\\n        return helper(0,new HashMap<>(),batchSize,groups.length-lack[0],lack)+lack[0];\\n    }", "class Solution {\\n    \\n    HashMap<Long, Integer> map = new HashMap<>();\\n    \\n    class State {\\n        long mask = 0;\\n        \\n        State(long v) {\\n            mask = v;\\n        }"]}
{"id": "2079", "ref_java": ["class Solution {\\n    int max = 0;\\n    Set<Integer> exist = new HashSet();\\n    public int countDifferentSubsequenceGCDs(int[] nums) {\\n        getMax(nums);\\n        for(int num : nums) exist.add(num);\\n        int count = 0;\\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      ", "class Solution {\\n    ", "class Solution {\\n    public int countDifferentSubsequenceGCDs(int[] nums) {\\n        "]}
{"id": "2081", "ref_java": ["class Solution {\\n    Map<Integer, BigInteger> factorMemo = new HashMap();\\n\\t\\n\\tpublic BigInteger factorial(int n) {\\n        if(factorMemo.get(n) != null) {\\n            return factorMemo.get(n);\\n        }", "class Solution {\\n    ", "class Solution {\\n    public int makeStringSorted(String s) {\\n        BigInteger res = new BigInteger(\"0\");\\n        BigInteger mod = new BigInteger(\"1000000007\");\\n        \\n        int[] count = new int[26];\\n        BigInteger[] fact = factory(s.length(), mod);\\n        \\n        int n = s.length();\\n        BigInteger div = new BigInteger(\"1\");\\n                \\n        for (int i = n - 1; i >= 0; --i) {\\n            char c = s.charAt(i);\\n            count[c-\\'a\\'] ++;\\n            BigInteger c1 = countInverse(count, c);            \\n            BigInteger ans = c1.multiply(fact[n-i-1]);\\n            div = div.multiply(new BigInteger(String.valueOf(count[c-\\'a\\'])));\\n            ans = ans.multiply(div.modPow(mod.subtract(new BigInteger(String.valueOf(2))), mod)).mod(mod);\\n            res = res.add(ans).mod(mod);\\n        }"]}
{"id": "2082", "ref_java": ["class Solution {\\n\\n    int cal(int[] a,int[] b){\\n        int out=0,c=0;\\n        for(int i:a)\\n            c^=i;\\n        for(int i:b){\\n            out^=(i&c);\\n        }", "class Solution {\\n\\n    int cal(int[] a,int[] b){\\n        int out=0,c=0;\\n        for(int i:a)\\n            c^=i;\\n        for(int i:b){\\n            out^=(i&c);\\n        }", "class Solution {\\n    public int getXORSum(int[] arr1, int[] arr2) {\\n        int xor1 = 0;\\n        int xor2 =0;\\n \\n        for(int i = 0 ;i<arr2.length;i++){\\n            xor2 = xor2^arr2[i];\\n        }"]}
{"id": "2083", "ref_java": ["class Solution {\\n    public int maxBuilding(int n, int[][] restrictions) {\\n        List<int[]> list=new ArrayList<>();\\n        list.add(new int[]{1,0}", "class Solution {\\n    public int maxBuilding(int n, int[][] restrictions) \\n    {\\n        int[][] arr = new int[restrictions.length + 2][2];\\n        arr[0][0] = 1;\\n        arr[0][1] = 0;\\n        arr[arr.length - 1][0] = n;\\n        arr[arr.length - 1][1] = n - 1;\\n        for (int i = 1; i < arr.length - 1; i++)\\n        {\\n            arr[i][0] = restrictions[i - 1][0];\\n            arr[i][1] = restrictions[i - 1][1];\\n        }", "class Solution {\\n    public int maxBuilding(int n, int[][] R) {\\n        Arrays.sort(R, Comparator.comparingInt(o -> -o[0]));\\n        int cur = (int)2e9, pre = -1, ans = 0, x = 1, y = 0;\\n        for (int[] r : R){\\n            cur = Math.min(r[1], pre-r[0]+cur);\\n            r[1] = cur;\\n            pre = r[0];\\n        }"]}
{"id": "2084", "ref_java": ["class Solution {\\n    public int[] closestRoom(int[][] rooms, int[][] queries) {\\n        Arrays.sort(rooms,new Pair());\\n        int[] ans=new int[queries.length];\\n        \\n        for(int i=0;i<ans.length;i++){\\n            int size=queries[i][1];\\n            int p=queries[i][0];\\n            \\n            int start=binarySearch(rooms,size);\\n            if(start==-1){\\n                ans[i]=-1;\\n                continue;\\n            }", "class Solution {\\n    public int[] closestRoom(int[][] rooms, int[][] queries) {\\n        Arrays.sort(rooms,new Pair());\\n        int[] ans=new int[queries.length];\\n        \\n        for(int i=0;i<ans.length;i++){\\n            int size=queries[i][1];\\n            int p=queries[i][0];\\n            \\n            int start=binarySearch(rooms,size);\\n            if(start==-1){\\n                ans[i]=-1;\\n                continue;\\n            }", "class Solution {\\n    public int[] closestRoom(int[][] rooms, int[][] queries) {\\n        int n = rooms.length, k = queries.length;\\n        Integer[] indexes = new Integer[k];\\n        for (int i = 0; i < k; i++) indexes[i] = i;\\n        Arrays.sort(rooms, (a, b) -> Integer.compare(b[1], a[1])); "]}
{"id": "2085", "ref_java": ["class Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        HashMap<Integer,Integer> map = new HashMap<>(); \\n        Arrays.sort(intervals,(x,y)->(x[0]-y[0]));\\n        int arr[] = new int[queries.length],i=0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((x,y)->((x[1]-x[0]) - (y[1]-y[0])));\\n        for(int j=0;j<arr.length;j++) arr[j]=queries[j];\\n        Arrays.sort(arr);\\n        for(int q : arr){\\n            while(i<intervals.length && intervals[i][0]<=q){\\n                pq.offer(intervals[i++]);\\n            }", "class Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int[] res = new int[queries.length];\\n        Integer[] qi = new Integer[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            qi[i] = i;\\n        }", "class Solution { \\n    class Event{\\n        int value;"]}
{"id": "2086", "ref_java": ["class Solution {\\r\\nboolean cycle=false;\\r\\n\\r\\npublic int largestPathValue(String colors , int[][] edges) {\\r\\n        \\r\\n        if(edges.length==0){\\r\\n                return 1;\\r\\n        }", "class Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        if(edges.length == 0){\\r\\n            return 1;\\r\\n        }", "class Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        int m = edges.length;\\r\\n        GraphNode graph[] = new GraphNode[n];\\r\\n        int count[][] = new int[n][26];\\r\\n        int indegree[] = new int[n];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph[i] = new GraphNode(i);\\r\\n        }"]}
{"id": "2087", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n\\n    ", "class Solution {\\n    public int sumOfFlooredPairs(int[] nums) {\\n   int MOD = 1000000007;\\n        int maxNum = Arrays.stream(nums).max().getAsInt();\\n        int[] count = new int[maxNum + 1];\\n        for (int num : nums) {\\n            count[num]++;\\n        }"]}
{"id": "2088", "ref_java": ["class Solution {\\n\\n    ", "class Solution {\\n\\n    public static int rearrangeSticks(int n, int k) {\\n        final int MOD = 1_000_000_007;\\n\\n        ", "class Solution {\\n    int dp[][] = new int[1001][1001], mod = 1_000_000_007;\\n    public int rearrangeSticks(int n, int k) {\\n        if (n == k) return 1;\\n        if (k == 0) return 0;\\n\\n        if (dp[n][k] == 0){\\n            dp[n][k] = (int)((1L * rearrangeSticks(n - 1, k - 1) + 1L * rearrangeSticks(n - 1, k) * (n - 1)) % mod);\\n        }"]}
{"id": "2089", "ref_java": ["class Solution {\\n    int memo[];\\n    public int stoneGameVIII(int[] stones) {\\n        memo = new int[stones.length];\\n        Arrays.fill(memo, Integer.MIN_VALUE);\\n        \\n        int difference = helper(stones, 0);\\n        return difference;\\n    }", "class Solution {\\n    public int stoneGameVIII(int[] stones) {\\n        int n = stones.length;\\n        int[] prefix = new int[n];\\n        prefix[0] = stones[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] + stones[i];\\n        }", "class Solution {\\n    int memo[];\\n    public int stoneGameVIII(int[] stones) {\\n        memo = new int[stones.length];\\n        Arrays.fill(memo, Integer.MIN_VALUE);\\n        \\n        int difference = helper(stones, 0);\\n        return difference;\\n    }"]}
{"id": "2090", "ref_java": ["class Solution {\\n    public int minimumXORSum(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int bool[] = new int[n];\\n        Map<String,Integer> map = new HashMap<>();\\n        return func(0,bool,nums1,nums2,map);\\n    }", "class Solution {\\n    public int minimumXORSum(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int bool[] = new int[n];\\n        Map<String,Integer> map = new HashMap<>();\\n        return func(0,bool,nums1,nums2,map);\\n    }", "class Solution {\\n    int dp[];\\n    boolean vis[];\\n    public int minimumXORSum(int[] a, int[] b) {\\n        dp = new int[1 << b.length];\\n        vis = new boolean[b.length];\\n        Arrays.fill(dp , Integer.MAX_VALUE);\\n        return solve(a , b , 0);\\n    }"]}
{"id": "2091", "ref_java": ["class Solution {\\n    public int minSkips(int[] dist, int speed, int hoursBefore) {\\n        int N = dist.length, INF = (int)1e9;\\n        int[] dp = new int[N];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0; ", "class Solution {\\n    public int minSkips(int[] dist, int speed, int hoursBefore) {\\n        ", "class Solution {\\n    public int minSkips(int[] dist, int speed, int hoursBefore) {\\n        "]}
{"id": "2092", "ref_java": ["class Solution {\\n    public int minWastedSpace(int[] packages, int[][] boxes) {\\n        Arrays.sort(packages);\\n        long[] ps=new long[packages.length+1];\\n        for(int i=1;i<ps.length;i++) ps[i]=ps[i-1]+packages[i-1];\\n        long min=Long.MAX_VALUE;\\n        for(int[] provider: boxes) {\\n            Arrays.sort(provider);\\n            if(packages[packages.length-1]>provider[provider.length-1]) continue;\\n            long sum=0;\\n            int packagesIndex=0, providerIndex=0;\\n            while(packagesIndex<packages.length) {\\n                providerIndex=bs(providerIndex,provider.length-1,packages[packagesIndex],false,provider);\\n                int lastPackagesIndex=bs(packagesIndex,packages.length-1,provider[providerIndex],true,packages);\\n                sum+=(lastPackagesIndex+0l-packagesIndex)*provider[providerIndex]-(ps[lastPackagesIndex]-ps[packagesIndex]);\\n                packagesIndex=lastPackagesIndex;\\n            }", "class Solution {\\n    public int minWastedSpace(int[] packages, int[][] boxes) {\\n        Arrays.sort(packages);\\n        long[] ps=new long[packages.length+1];\\n        for(int i=1;i<ps.length;i++) ps[i]=ps[i-1]+packages[i-1];\\n        long min=Long.MAX_VALUE;\\n        for(int[] provider: boxes) {\\n            Arrays.sort(provider);\\n            if(packages[packages.length-1]>provider[provider.length-1]) continue;\\n            long sum=0;\\n            int packagesIndex=0, providerIndex=0;\\n            while(packagesIndex<packages.length) {\\n                providerIndex=bs(providerIndex,provider.length-1,packages[packagesIndex],false,provider);\\n                int lastPackagesIndex=bs(packagesIndex,packages.length-1,provider[providerIndex],true,packages);\\n                sum+=(lastPackagesIndex+0l-packagesIndex)*provider[providerIndex]-(ps[lastPackagesIndex]-ps[packagesIndex]);\\n                packagesIndex=lastPackagesIndex;\\n            }", "class Solution {\\n    public int minWastedSpace(int[] packages, int[][] boxes) {\\n        int n = packages.length;\\n        long sum = 0;\\n        long mod = 1_000_000_007;\\n        for(int i=0; i<n; i++)\\n            sum += packages[i];\\n\\n        Arrays.sort(packages);\\n        BIT bit = new BIT(100001);\\n        for(int v : packages)\\n            bit.add(v);\\n\\n        long ans = -1;\\n        for(int[] box : boxes){\\n            Arrays.sort(box);\\n            if(box[box.length-1] < packages[n-1])\\n                continue;\\n            long total = 0;\\n            int precnt = 0;\\n            for(int b : box){\\n                int nn = bit.query(b);\\n                int cnt = nn - precnt;\\n                total += (long)cnt*b;\\n                precnt += cnt;\\n            }"]}
{"id": "2093", "ref_java": ["class Solution {\\n    Deque<int[]> stack = new ArrayDeque<>();\\n    Deque<Character> opStack = new ArrayDeque<>();\\n    public int minOperationsToFlip(String expression) {\\n        for (char ch : expression.toCharArray()){\\n            if (ch == \\'(\\'){\\n                opStack.push(ch);\\n            }", "class Solution {\\n    class Node {\\n        char op = \\'\\\\u0000\\';\\n        Node left = null;\\n        Node right = null;\\n    }", "class Solution {\\n    "]}
{"id": "2094", "ref_java": ["class Solution {\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        return solve(n, (1<<n)-1, 0, n-1, firstPlayer-1, secondPlayer-1, new HashMap<>());\\n    }", "class Solution {\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        return solve(n, (1<<n)-1, 0, n-1, firstPlayer-1, secondPlayer-1, new HashMap<>());\\n    }", "class Solution {\\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\\n        return solve(n, (1<<n)-1, 0, n-1, firstPlayer-1, secondPlayer-1, new HashMap<>());\\n    }"]}
{"id": "2096", "ref_java": ["class Solution {\\n    private static final int p = 1_000_000_007;\\n    private static final BigInteger bigP = BigInteger.valueOf(p);\\n\\n\\n    public int waysToBuildRooms(int[] prevRoom) {\\n        int n = prevRoom.length;\\n        List<Integer>[] children = new List[n];\\n        for (int i = 1; i < n; i++) {\\n            int father = prevRoom[i];\\n            if (children[father] == null) children[father] = new LinkedList<>();\\n            children[father].add(i);\\n        }", "class Solution {\\r\\n    ", "class Solution {\\n    int mod = 1000_000_007;\\n    public int waysToBuildRooms(int[] prevRoom) {\\n        int n = prevRoom.length;\\n        List<Integer>[] children = new List[n];\\n        for(int i=0;i<n;i++) {\\n            children[i] = new ArrayList<>();\\n        }"]}
{"id": "2097", "ref_java": ["class Solution {\\n    \\n    ", "class Solution {\\n    \\n    private long[] p = {100000007,100000037}", "class Solution {\\n    public int longestCommonSubpath(int n, int[][] paths) {\\n        int minPathLen = Integer.MAX_VALUE;\\n        for (int[] p : paths) {\\n            minPathLen = Math.min(minPathLen, p.length);\\n        }"]}
{"id": "2098", "ref_java": ["class Solution {\\n    record Node(int i, int t) {}", "class Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<Edge>[] adj = new ArrayList[n];\\n        for (int k = 0; k < n; k++) {\\n            adj[k] = new ArrayList();\\n        }", "class Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<Edge>[] adj = new ArrayList[n];\\n        for (int k = 0; k < n; k++) {\\n            adj[k] = new ArrayList();\\n        }"]}
{"id": "2099", "ref_java": ["class Solution {\\n    public static final int p = 1_000_000_007;\\n\\n    public int colorTheGrid(int m, int n) {\\n        if (m == 1) return (int) (3L * powMod(2, n - 1) % p);\\n        if (m == 2) return (int) (6L * powMod(3, n - 1) % p);\\n        if (n == 1) return (int) (3L * powMod(2, m - 1) % p);\\n        if (n == 2) return (int) (6L * powMod(3, m - 1) % p);\\n\\n        int totalTemplates = 1 << (m - 2);\\n        int totalPaintings = binPow(3, m);\\n\\n        int[] paintingToTemplate = new int[totalPaintings];\\n        long[] paintingCountForTemplate = new long[totalTemplates];\\n        long[][] templateEdgeCount = new long[totalTemplates][totalTemplates];\\n\\n        Map<Integer, Integer> templateToIndex = new HashMap<>(1 << (m - 2));\\n\\n        int templateCounter = 0;\\n        for (int i = 0; i < totalPaintings; i++) {\\n            int type = getType(i, m);\\n            if (type == -1) {\\n                paintingToTemplate[i] = -1;\\n                continue;\\n            }", "class Solution {\\n    public int colorTheGrid(int m, int n) {\\n        int A = 1 << 2*m, M = (int)1e9+7;\\n        int[] dp = new int[A];\\n        for (int i = 1; i < A; i++){\\n            if (ok(i,i>>2,m-1)){ ", "class Solution {\\n  public int colorTheGrid(int m, int n) {\\n    this.m = m;\\n    this.n = n;\\n    return dp(0, 0, 0, 0);\\n  }"]}
{"id": "2100", "ref_java": ["class Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }", "class Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }", "class Solution {\\n    public TreeNode canMerge(List<TreeNode> trees) {\\n        \\n        HashMap <Integer,TreeNode> map = new HashMap <Integer,TreeNode>();\\n\\n        for(int i = 0; i < trees.size(); i++)\\n        {\\n            if(map.containsKey(trees.get(i).val))\\n            {\\n                return null;\\n            }"]}
{"id": "2101", "ref_java": ["class Solution {\\n    \\n    class Trie {\\n        class TrieNode {\\n            int count = 0;\\n            TrieNode[] chld = new TrieNode[2];\\n        }", "class Solution {\\n    \\n    class Trie {\\n        class TrieNode {\\n            int count = 0;\\n            TrieNode[] chld = new TrieNode[2];\\n        }", "class Solution {\\n    \\n    class Trie {\\n        class TrieNode {\\n            int count = 0;\\n            TrieNode[] chld = new TrieNode[2];\\n        }"]}
{"id": "2102", "ref_java": ["class Solution {\\n    public int[] canSeePersonsCount(int[] heights) {\\n        int n = heights.length;\\n        int[] answer = new int[n];\\n        Stack<Integer> nitha = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!nitha.isEmpty() && heights[i] > heights[nitha.peek()]) {\\n                answer[i]++;\\n                nitha.pop();\\n            }", "class Solution {\\n    public int[] canSeePersonsCount(int[] heights) {\\n        int n = heights.length;\\n        int[] answer = new int[n];\\n        Stack<Integer> nitha = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!nitha.isEmpty() && heights[i] > heights[nitha.peek()]) {\\n                answer[i]++;\\n                nitha.pop();\\n            }", "class Solution {\\n    public int[] canSeePersonsCount(int[] heights) {\\n        int n = heights.length;\\n        int[] answer = new int[n];\\n        Stack<Integer> nitha = new Stack<>();\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!nitha.isEmpty() && heights[i] > heights[nitha.peek()]) {\\n                answer[i]++;\\n                nitha.pop();\\n            }"]}
{"id": "2103", "ref_java": ["class Solution {\\n    \\n    class Node {\\n        Integer hash;\\n        boolean marked;\\n        String name;\\n        HashMap<String,Node> children;\\n        Node(String name){\\n            this.name = name;\\n            children = new HashMap<>();\\n        }", "class Solution {\\n    \\n    class Node {\\n        Integer hash;\\n        boolean marked;\\n        String name;\\n        HashMap<String,Node> children;\\n        Node(String name){\\n            this.name = name;\\n            children = new HashMap<>();\\n        }", "class Solution {\\n    class TrieNode {\\n        TreeMap<String, TrieNode> children;\\n        boolean isEndOfDir;\\n        boolean deleted;\\n        \\n        public TrieNode() {\\n            children = new TreeMap<>();\\n            isEndOfDir = false;\\n            deleted = false;\\n        }"]}
{"id": "2104", "ref_java": ["class Solution {\\n    public int countSpecialSubsequences(int[] nums) {\\n        int n = nums.length;\\n        Integer dp[][] = new Integer[n][4];\\n        return helper(0,0,nums,dp);\\n    }", "class Solution {\\n    public int countSpecialSubsequences(int[] nums) {\\n        long z = 0; ", "class Solution {\\n    public int countSpecialSubsequences(int[] nums) {\\n        int n = nums.length;\\n        Integer dp[][] = new Integer[n][4];\\n        return helper(0,0,nums,dp);\\n    }"]}
{"id": "2105", "ref_java": ["class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }", "class Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }", "class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }"]}
{"id": "2106", "ref_java": ["class Solution {\\n    int ar[], n, p=-1, max=Integer.MIN_VALUE, res[];\\n    public int[] longestObstacleCourseAtEachPosition(int[] obs) {\\n        n=obs.length;\\n        ar=new int[n];\\n        res=new int[n];\\n        for(int i=0, ind;i<n;i++) {\\n            if(max<=obs[i]) {\\n                max=obs[i];\\n                p++;\\n                ind=p;\\n            }", "class Solution {\\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\\n        int n= obstacles.length, tailsEnd=0;\\n        int[]  ans = new int [n], tails = new int [n] ;\\n        for (int i=0;i<n;i++){\\n            int lastSubSeq = BS(tails,obstacles[i],tailsEnd);\\n            if (lastSubSeq==tailsEnd) tailsEnd++;\\n            tails[lastSubSeq] = obstacles[i];\\n            ans[i] = 1 + lastSubSeq;\\n        }", "class Solution {\\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\\n        \\n       int n = obstacles.length;\\n       int[] res = new int[n];\\n       int[] indices = new int[n + 1];\\n       int len = 0;\\n\\n       for(int i = 0; i < n; i++){\\n           int newLen = bs(1, len, obstacles[i], indices, obstacles);\\n           res[i] = newLen;\\n           len = Math.max(len, newLen);\\n           indices[newLen] = i;\\n       }"]}
{"id": "2107", "ref_java": ["class Solution {\\n    int row = 0;\\n    int col = 0;\\n    int [][]cells;\\n    public int[][] directions = new int[][]{{1, 0}", "class Solution {\\n\\n    private int[][] dirs = new int[][]{{1, 0}", "class Solution {\\n    public int latestDayToCross(int row, int col, int[][] cells) {\\n        int grid[][] = new int[row][col];\\n        for(int i=0;i<cells.length;i++){\\n            grid[cells[i][0]-1][cells[i][1]-1]=i+1;\\n        }"]}
{"id": "2108", "ref_java": ["class Solution {\\n    private static final int p = 1_000_000_007;\\n\\n    public int numberOfCombinations(String num) {\\n        int n = num.length();\\n        if (num.charAt(0) == \\'0\\') return 0;\\n        if (n == 1) return 1;\\n        long[] prev = new long[n + 1], next = new long[n + 1], tmp;\\n        prev[0] = 1;\\n        next[0] = 1;\\n\\n        for (int d = 1; d <= n; d++) {\\n            System.arraycopy(prev, 1, next, 1, n);\\n            for (int j1 = 0, i1 = j1 - d, j2 = j1 + d; j2 <= n; j1++, j2++, i1++) {\\n                if (num.charAt(j1) != \\'0\\') {\\n                    if (i1 < 0 || num.charAt(i1) != \\'0\\' && ok(num, i1, j1, d)) next[j2] += next[j1];\\n                    else next[j2] += prev[j1];\\n                    if (next[j2] >= p) next[j2] -= p;\\n                }", "class Solution {\\n    static int mod = (int) 1e9 + 7;\\n\\n    public int numberOfCombinations(String num) {\\n        char[] cs = num.toCharArray();\\n        int n = cs.length;\\n        int[][] rank = new int[n][n + 1];\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(1, (a, b) -> a[1] - b[1]);\\n\\n        for (int i = 1; i <= n; ++i) {\\n            int c = 0, prev = 0;\\n\\n            for (int j = 0; j + i <= n; ++j) {\\n                pq.add(new int[]{j, rank[j][i - 1] * 10 + cs[i + j - 1] - \\'0\\'}", "class Solution {\\n    public int numberOfCombinations(String num) {\\n        int n=num.length();\\n        Integer[][] dp= new Integer[n][n];\\n\\n        int[][] compare= new int[n+1][n+1];\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(num.charAt(i)==num.charAt(j)){\\n                    compare[i][j]=compare[i+1][j+1]+1;\\n                }"]}
{"id": "2109", "ref_java": ["class Solution {\\n    public int[] recoverArray(int n, int[] sums) {\\n        Arrays.sort(sums);\\n        int m = sums.length;\\n        int[] res = new int[n], left = new int[m / 2], right = new int[m / 2];\\n        for (int i = 0; i < n; ++i) {\\n            int diff = sums[1] - sums[0], hasZero = 0, p = -1, q = -1, k = 0;\\n            for (int j = 0; j < m; ++j) {\\n                if (k <= q && right[k] == sums[j]) k++;\\n                else {\\n                    if (0 == sums[j]) hasZero = 1;\\n                    left[++p] = sums[j];\\n                    right[++q] = sums[j] + diff;\\n                }", "class Solution {\\n    public int[] recoverArray(int n, int[] sums) {\\n        Arrays.sort(sums);\\n        int m = sums.length;\\n        int[] res = new int[n], left = new int[m / 2], right = new int[m / 2];\\n        for (int i = 0; i < n; ++i) {\\n            int diff = sums[1] - sums[0], hasZero = 0, p = -1, q = -1, k = 0;\\n            for (int j = 0; j < m; ++j) {\\n                if (k <= q && right[k] == sums[j]) k++;\\n                else {\\n                    if (0 == sums[j]) hasZero = 1;\\n                    left[++p] = sums[j];\\n                    right[++q] = sums[j] + diff;\\n                }", "class Solution {\\n    public int[] recoverArray(int n, int[] sums) {\\n        Arrays.sort(sums);\\n        int m = sums.length;\\n        int[] res = new int[n], left = new int[m / 2], right = new int[m / 2];\\n        for (int i = 0; i < n; ++i) {\\n            int diff = sums[1] - sums[0], hasZero = 0, p = -1, q = -1, k = 0;\\n            for (int j = 0; j < m; ++j) {\\n                if (k <= q && right[k] == sums[j]) k++;\\n                else {\\n                    if (0 == sums[j]) hasZero = 1;\\n                    left[++p] = sums[j];\\n                    right[++q] = sums[j] + diff;\\n                }"]}
{"id": "2110", "ref_java": ["class Solution {\\n    public int numberOfUniqueGoodSubsequences(String binary) {\\n        int initialZeroCount= 0;\\n        while(initialZeroCount < binary.length() && binary.charAt(initialZeroCount) == \\'0\\') initialZeroCount++;\\n        if(initialZeroCount == binary.length()) return 1;\\n        long[] dp = new long[binary.length()];\\n        dp[initialZeroCount] = 1;\\n        int lastOne = 0, lastZero = 0;\\n        long mod = (long) Math.pow(10, 9)+7;\\n        for(int i=initialZeroCount+1;i<binary.length();i++){\\n            int j = binary.charAt(i) == \\'1\\' ? lastOne : lastZero;\\n            long dup = j > 0 ? dp[j-1] : 0;\\n            dp[i] = 2 * dp[i-1] - dup;\\n            if(dp[i] < 0) dp[i] += mod;\\n            dp[i] %= mod;\\n            if(binary.charAt(i) == \\'0\\') lastZero = i;\\n            else lastOne = i;\\n        }", "class Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int numberOfUniqueGoodSubsequences(String binary) {\\n        int[] count = new int[binary.length()];\\n        \\n        int[] occurrence = new int[2];\\n        int[] lastPosition = new int[] {-1, -1}", "class Solution {\\n    public int numberOfUniqueGoodSubsequences(String binary) {\\n        "]}
{"id": "2111", "ref_java": ["class Solution {\\n    static int mod = (int) 1e9 + 7;\\n    static int[] map = new int[31];\\n    static {\\n        int[] prime = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}", "class Solution {\\n\\n    long mod = (long) (1e9 + 7);\\n\\n    public int numberOfGoodSubsets(int[] nums) {\\n        \\n        int n = nums.length;\\n\\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}", "class Solution {\\n    static int MOD = 1_000_000_000 + 7;\\n\\n    "]}
{"id": "2112", "ref_java": ["class Solution {\\n    class UnionFind {\\n        int[] p;\\n        int[] sz;\\n        UnionFind(int n){\\n            p = new int[n];\\n            sz = new int[n];\\n            for(int i=0;i<n;i++){\\n                p[i]=i;\\n                sz[i]=1;\\n            }", "class Solution {\\n    class UnionFind {\\n        int[] p;\\n        int[] sz;\\n        UnionFind(int n){\\n            p = new int[n];\\n            sz = new int[n];\\n            for(int i=0;i<n;i++){\\n                p[i]=i;\\n                sz[i]=1;\\n            }", "class Solution {\\n    public boolean gcdSort(final int[] nums) {\\n        final var sorted = nums.clone();\\n        Arrays.sort(sorted);\\n        final int len = nums.length, max = sorted[len - 1];\\n        final var nodes = new int[max + 1];\\n        for (int i = 0; i < len; i++) nodes[nums[i]] = -1;\\n        for (int p = 2; p <= max / 2; p++) {\\n            if (nodes[p] > 0) continue;\\n            nodes[p] = p;\\n            for (int group = p, num = p + p; num <= max; num += p) {\\n                var existing = nodes[num];\\n                if (existing < 0) nodes[num] = group;\\n                else if (existing <= 1) nodes[num] = 1;\\n                else if ((existing = root(nodes, existing)) < group) {\\n                    nodes[group] = existing;\\n                    group = existing;\\n                }"]}
{"id": "2113", "ref_java": ["class Solution {\\n    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {\\n        int n = parents.length;\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = 1;\\n        }", "class Solution {\\n    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        int node = 0, len = parents.length, node_val_one = -1;\\n        for(int parent : parents){\\n            if(parent != -1){\\n                if(!graph.containsKey(parent)){\\n                    graph.put(parent, new ArrayList<Integer>());\\n                }", "class Solution {\\n    private List<Integer> rootToLeaf;\\n    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {\\n        int n = parents.length;\\n        rootToLeaf = new ArrayList<>();\\n        ArrayList<Integer>[] adj = new ArrayList[n];\\n        boolean oneAbsent = true;\\n        int[] result = new int[n];\\n        int maxValue = 0;\\n        for(int i = 0; i<n; ++i){\\n            result[i] = 1;\\n            adj[i] = new ArrayList<>();\\n            if(nums[i] == 1) oneAbsent = false; \\n            maxValue = (int)Math.max(maxValue, nums[i]);\\n        }"]}
{"id": "2114", "ref_java": ["class Solution {\\n    public int minOperations(int[] nums) {\\n        int maxi = 0; ", "class Solution {\\n    public int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int uniqueLen = 1;\\n        for (int i = 1; i < nums.length; ++i) {\\n            if (nums[i] != nums[i - 1]) {\\n                nums[uniqueLen++] = nums[i];\\n            }", "class Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums); "]}
{"id": "2115", "ref_java": ["class Solution {\\n    char[] A;\\n    public String longestSubsequenceRepeatedK(String s, int k) {\\n        A = s.toCharArray();\\n        Queue<String> queue = new ArrayDeque<>();\\n        queue.offer(\"\");\\n        String ans = \"\";\\n        int[] count = new int[26];\\n        BitSet bit = new BitSet();\\n        for (char ch : A) if (++count[ch-\\'a\\'] >= k){\\n            bit.set(ch-\\'a\\');\\n        }", "class Solution {\\n    public String longestSubsequenceRepeatedK(String s, int k) {\\n        String res = \"\";\\n        \\n        int[] map = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            map[ch-\\'a\\']++;\\n        }", "class Solution {\\n    char[] A;\\n    public String longestSubsequenceRepeatedK(String s, int k) {\\n        A = s.toCharArray();\\n        Queue<String> queue = new ArrayDeque<>();\\n        queue.offer(\"\");\\n        String ans = \"\";\\n        int[] count = new int[26];\\n        BitSet bit = new BitSet();\\n        for (char ch : A) if (++count[ch-\\'a\\'] >= k){\\n            bit.set(ch-\\'a\\');\\n        }"]}
{"id": "2116", "ref_java": ["class Solution {\\n\\n    HashSet<Integer>[][] dp;\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int correct = evaluateExp(s);\\n        dp = new HashSet[s.length()][s.length()];\\n        HashSet<Integer> set = dfs(0, s.length()-1, s);\\n        int res = 0;\\n        for (int a : answers) {\\n            res += ( (a==correct) ? 5 : set.contains(a) ? 2 : 0 );\\n        }", "class Solution {\\n    private Set[][] dp;\\n\\n    public int scoreOfStudents(String s, int[] answers) {\\n        int correctAns = evaluate(s);\\n        int len = s.length();\\n        dp = new Set[len][len];\\n        Set<Integer> values = solve(0, len - 1, s.toCharArray());\\n        int sum = 0;\\n        for(int val : answers) {\\n            if(val == correctAns) {\\n                sum += 5;\\n            }", "class Solution {\\n    HashMap<String , HashSet<Integer>> cache =new HashMap<>();\\n    public int scoreOfStudents(String s, int[] ans) {\\n        int sign=1;\\n        int i=0;\\n        Stack<Integer>st=new Stack<>();\\n"]}
{"id": "2117", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long totalSum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            arr[i] = (long)(nums[i]);\\n            totalSum += arr[i];\\n        }", "class Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        int[] pref = new int[n];\\n        pref[0] = nums[0];        \\n        Map<Integer, Integer> count = new HashMap<>(); "]}
{"id": "2118", "ref_java": ["class Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int r) {\\n        int n_letters = 0;\\n        for (int i = 0; i < s.length(); i++)\\n            if (s.charAt(i) == letter)\\n                n_letters ++;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            while (!stack.isEmpty() && stack.peek() > c && (s.length() - i + stack.size() > k) && (stack.peek() != letter || n_letters > r)) {\\n                if (stack.pop() == letter) r ++;\\n            }", "class Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int freq = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == letter) freq++;\\n        }", "class Solution {\\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\\n        int letterCount = 0;\\n\\n        for (char ch : s.toCharArray()) {\\n\\n            if (ch == letter) {\\n                letterCount++;\\n            }"]}
{"id": "2119", "ref_java": ["class Solution {\\n     public static int lowerBound(ArrayList<Integer> list, int key) {\\n        int left = 0;\\n        int right = list.size()-1;\\nint ans=list.size()-1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midValue = list.get(mid);\\n\\n            if (midValue >= key) {\\n               ans=mid;\\n               right=mid-1;\\n            }", "class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; ", "class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }"]}
{"id": "2120", "ref_java": ["class Solution {\\n    \\n     public long kthSmallestProduct(int[] nums1, int[] nums2, long k)\\n    {\\n        long si = -1000_000_0000l;\\n        long ei = 1000_000_0000l;\\n        long ans = 0;\\n        while(si <= ei)\\n        {\\n            long mid = si + (ei - si) / 2;\\n            long count = 0;\\n            if(countofProduct(nums1,nums2,mid) >= k)\\n            {\\n                ans = mid;\\n                ei = mid - 1;\\n            }", "class Solution {\\n    static long INF = (long) 1e10;\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        int m = nums1.length, n = nums2.length;\\n        long lo = -INF - 1, hi = INF + 1;\\n        while (lo < hi) {            \\n            long mid = lo + ((hi - lo) >> 1), cnt = 0;\\n            for (int i : nums1) {\\n                if (0 <= i) {\\n                    int l = 0, r = n - 1, p = 0;\\n                    while (l <= r) {\\n                        int c = l + ((r - l) >> 1);\\n                        long mul = i * (long) nums2[c];\\n                        if (mul <= mid) {\\n                            p = c + 1;\\n                            l = c + 1;\\n                        }", "class Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long l = (long)-1e11;\\n        long r = (long)1e11;\\n        long res = 0;\\n        while ( l<=r ) {\\n            long mid = (l+r)/2;\\n            "]}
{"id": "2121", "ref_java": ["class Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\t\\t", "class Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, List<Integer>> g = new HashMap();\\n        for(int[] e : edges) {\\n            int u  = e[0], v = e[1];\\n            g.computeIfAbsent(u, x -> new ArrayList()).add(v);\\n            g.computeIfAbsent(v, x -> new ArrayList()).add(u);\\n        }", "class Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\t\\t"]}
{"id": "2122", "ref_java": ["class Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }", "class Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }", "class Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time){\\n        int[] result = new int[time.length + 1];\\n        int var = 1, N = relations.length - 1;\\n        "]}
{"id": "2123", "ref_java": ["class Solution {\\n    int[][] dirs = {{1, 0}", "class Solution {\\n    int[][][] all = new int[][][]{\\n        {{0, 0}", "class Solution {\\n    int[][] dirs = {{1, 0}"]}
{"id": "2124", "ref_java": ["class Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean possiblyEquals(String s1, String s2) {\\n        return helper(s1, s2, 0, 0, 0);\\n    }", "class Solution {\\n    ", "class Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean possiblyEquals(String s1, String s2) {\\n        return helper(s1, s2, 0, 0, 0);\\n    }"]}
{"id": "2125", "ref_java": ["class Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<int[]>[] adj = new List[n];\\n        for (int i = 0; i < n; ++i) adj[i] = new LinkedList();\\n        for (int[] e : edges) {\\n            int i = e[0], j = e[1], t = e[2];\\n            adj[i].add(new int[]{j, t}", "class Solution {\\n    int max = 0;\\n\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, List<int[]>> adjList = buildGraph(edges);\\n        dfs(0, 0, adjList, 0, maxTime, values, 0, new HashMap<>());\\n        return max;\\n    }", "class Solution {\\n    int max = 0;\\n\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, List<int[]>> adjList = buildGraph(edges);\\n        dfs(0, 0, adjList, 0, maxTime, values, 0, new HashMap<>());\\n        return max;\\n    }"]}
{"id": "2126", "ref_java": ["class Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n\\n        int lo=0,hi=Math.min(tasks.length, workers.length);\\n\\n        while(lo<hi) {\\n            int mid = (lo+hi+1)/2;\\n            if(check(mid,tasks,workers,pills,strength)) {\\n                lo = mid;\\n            }", "class Solution {\\n    \\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {   \\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        \\n        int st = 0;\\n        int end = Math.min(tasks.length, workers.length)-1;\\n        int ans =0;\\n        while(st<=end){\\n            int mid = (st+end)/2;\\n            if(isPossible(tasks, workers, pills, strength, mid)){\\n                st = mid+1;\\n                ans = Math.max(ans, mid+1);\\n            }", "class Solution {\\n    public int maxTaskAssign(int[] t, int[] w, int p, int s) {\\n        int n = w.length;\\n        int m = t.length;\\n        Arrays.sort(t);\\n        \\n        int lo = 1, hi = Math.min(n, m);  "]}
{"id": "2127", "ref_java": ["class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DisjointSet set = new DisjointSet(n, restrictions);\\n        boolean[] queries = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++) \\n            queries[i] = set.union(requests[i][0], requests[i][1]);\\n        return queries;\\n    }", "class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }", "class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        if (restrictions.length==0){\\n            boolean [] queries = new boolean [requests.length];\\n            Arrays.fill(queries,true);\\n            return queries;\\n        }"]}
{"id": "2128", "ref_java": ["class Solution {\\n    public long kMirror(int k, int n) {\\n        long res = 0;\\n        long cnt = 0;\\n        for (long i = 1; i < Long.MAX_VALUE; i++) {\\n            if (iskmirror(k,i) && iskmirror(10,i)) {\\n                res += i;\\n                cnt++;\\n                if (cnt == n) {\\n                    return res;\\n                }", "class Solution {\\n    int num;\\n    long sum;\\n    int base;\\n    \\n    public long kMirror(int k, int n) {\\n        base = k;\\n        sum = 0l;\\n        num = n;\\n\\n        List<String> one = new ArrayList<>();\\n        one.add(\"0\");\\n        for(int i = 1; i < k && num > 0; i++) {\\n            one.add(Integer.toString(i));\\n            if (n > 0) {\\n                sum += i;\\n                num--;\\n            }", "class Solution {\\n    "]}
{"id": "2129", "ref_java": ["class Solution {\\n    public int countPyramids(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] rev = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) rev[m - i - 1][j] = grid[i][j];\\n        }", "class Solution {\\n    public int countPyramids(int[][] grid) {\\n        return countPyramids(grid.length - 2, -1, 1, grid) +\\n                countPyramids(0, 1, -1, grid);\\n    }", "class Solution {\\n    public int countPyramids(int[][] grid) {\\n        return countPyramids(grid.length - 2, -1, 1, grid) +\\n                countPyramids(0, 1, -1, grid);\\n    }"]}
{"id": "2130", "ref_java": ["class Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\n\\t\\t", "class Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }", "class Solution {\\n   "]}
{"id": "2131", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        Map<Integer,Integer> map2 = new HashMap<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            if(!map.containsKey(pairs[i][0])){\\n                ArrayList<Integer> arr = new ArrayList<>();\\n                arr.add(pairs[i][1]);\\n                map.put(pairs[i][0], arr);\\n            }", "class Solution {\\n    public int[][] validArrangement(int[][] pairs) {\\n        int n = pairs.length;\\n        \\n        int[][] ans = new int[n][2];\\n        for (int[] a : ans) {\\n            a[0] = -1;\\n            a[1] = -1;\\n        }"]}
{"id": "2133", "ref_java": ["class Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        int posOfLastFruit = fruits[n-1][0];\\n        int prefixArr[] = new int[posOfLastFruit + 1];\\n        int start = Math.max(startPos - k, 0);\\n        int end = Math.min(startPos + k, prefixArr.length-1);\\n        \\n        if(startPos > posOfLastFruit) {\\n            int diff = startPos - posOfLastFruit;\\n            startPos = posOfLastFruit;\\n             k = k - diff;\\n            if(k == 0)\\n                return fruits[posOfLastFruit][1];\\n            else if(k < 0)\\n                return 0;\\n        }", "class Solution {\\n    Map< Integer, Integer > map = new HashMap<>();\\n    int max = 0;\\n    public int maxTotalFruits(int[][] arr, int startPos, int k) {\\n\\n        for (int[] a : arr){\\n            map.put(a[0],a[1]);\\n        }", "class Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        int posOfLastFruit = fruits[n-1][0];\\n        int prefixArr[] = new int[posOfLastFruit + 1];\\n        int start = Math.max(startPos - k, 0);\\n        int end = Math.min(startPos + k, prefixArr.length-1);\\n        \\n        if(startPos > posOfLastFruit) {\\n            int diff = startPos - posOfLastFruit;\\n            startPos = posOfLastFruit;\\n             k = k - diff;\\n            if(k == 0)\\n                return fruits[posOfLastFruit][1];\\n            else if(k < 0)\\n                return 0;\\n        }"]}
{"id": "2134", "ref_java": ["class Solution {\\n  public int kIncreasing(int[] arr, int k) {\\n    int total = 0;\\n    for(int i=0; i < k; i++){\\n      List<Integer> list = new ArrayList<>();\\n      for(int j=i; j < arr.length; j = j+k)\\n        list.add(arr[j]);\\n      total += list.size() - lengthOfLIS(list);\\n    }", "class Solution {\\n  public int kIncreasing(int[] arr, int k) {\\n    int total = 0;\\n    for(int i=0; i < k; i++){\\n      List<Integer> list = new ArrayList<>();\\n      for(int j=i; j < arr.length; j = j+k)\\n        list.add(arr[j]);\\n      total += list.size() - lengthOfLIS(list);\\n    }", "class Solution {\\n    public int kIncreasing(int[] arr, int k) {\\n        int ans = arr.length;\\n        int[] tails = new int[arr.length];\\n        for (int i = 0; i < k; i ++) {\\n            int size = 0;\\n            for (int j = i; j < arr.length; j += k) {\\n                if (size == 0 || arr[j] >= tails[size - 1]) {\\n                    tails[size ++] = arr[j];\\n                }"]}
{"id": "2135", "ref_java": ["class Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        int zero = 0;\\n        boolean mod = false;\\n        \\n        long val = 1L;\\n        for (int i = left; i <= right; i++) {\\n            val *= i;\\n            while (val % 10 == 0) {\\n                val /= 10;\\n                zero++;\\n            }", "class Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        int zero = 0;\\n        boolean mod = false;\\n        \\n        long val = 1L;\\n        for (int i = left; i <= right; i++) {\\n            val *= i;\\n            while (val % 10 == 0) {\\n                val /= 10;\\n                zero++;\\n            }", "class Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        int zero = 0;\\n        boolean mod = false;\\n        \\n        long val = 1L;\\n        for (int i = left; i <= right; i++) {\\n            val *= i;\\n            while (val % 10 == 0) {\\n                val /= 10;\\n                zero++;\\n            }"]}
{"id": "2136", "ref_java": ["class Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int N = nums.length;\\n        Arrays.sort(nums);\\n        List<Integer> diffList = new ArrayList<>();\\n        for (int i = 1; i < N; i++) {\\n            int diff = Math.abs(nums[i] - nums[0]);\\n            if (diff % 2 == 0 && diff > 0) diffList.add(diff / 2);\\n        }", "class Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] res = new int[nums.length / 2];\\n        int prev = 0; ", "class Solution {\\n    public int[] recoverArray(int[] nums) {\\n        \\n    \\tint i,n=nums.length;\\n    \\tint ans[]=new int[n/2];\\n    \\tArrays.sort(nums);\\n    \\tPriorityQueue<Integer> pq=new PriorityQueue<>();\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tpq.add(nums[i]);\\n    \\tfor(i=1;i<n;i++)\\n    \\t{\\n    \\t\\tPriorityQueue<Integer> pq1=new PriorityQueue<>(pq);\\n    \\t\\tint p=0;\\n    \\t\\tif((nums[0]+nums[i])%2==0)\\n    \\t\\t{\\n    \\t\\t\\tint k=(nums[0]+nums[i])/2-nums[0];\\n    \\t\\t\\tif(k==0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tint curr=pq1.poll();\\n    \\t\\t\\twhile(pq1.contains((curr+k+k))) {\\n    \\t\\t\\t\\n    \\t\\t\\t\\tpq1.remove(curr+k+k); \\n\\t\\t\\t\\t\\tans[p++]=curr+k;\\n\\t\\t\\t\\t\\tif(p==n/2)\\n\\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcurr=pq1.poll();\\n    \\t\\t\\t}"]}
{"id": "2137", "ref_java": ["class Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            graph.add(new ArrayList<>());\\n        }", "class Solution {\\n    int N;\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    int singleMaxCycleSize = 0;\\n    List<List<Integer>> pairs = new ArrayList<>();\\n    int[] favorite;\\n    public int maximumInvitations(int[] favorite) {\\n        this.favorite = favorite;\\n        N = favorite.length;\\n        ", "class Solution {\\n    int maxCircle;\\n    int n;\\n    List<List<Integer>> graph;\\n    List<int[]> pairs;\\n\\n    public int maximumInvitations(int[] favorite) {\\n        n = favorite.length;\\n        graph = new ArrayList<>();\\n        pairs = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }"]}
{"id": "2138", "ref_java": ["class Solution {\\n    private static final int FILLED = 1;\\n\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        ", "class Solution {\\n    private static final int FILLED = 1;\\n\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        ", "class Solution {\\n    \\n    "]}
{"id": "2139", "ref_java": ["class Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int arr[][]=new int[growTime.length][2];\\n        for(int i=0;i<growTime.length;i++){\\n            arr[i][0]=growTime[i];\\n            arr[i][1]=plantTime[i];\\n        }", "class Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime)\\n    {\\n        List<Pair>flowers = new ArrayList();\\n        int flowerCount = plantTime.length;\\n        for (int i = 0; i < flowerCount; i++) flowers.add(new Pair(growTime[i], plantTime[i]));\\n        ", "class Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n                int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }"]}
{"id": "2140", "ref_java": ["class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        long left = 1, right = (long)Arrays.stream(batteries).asLongStream().sum() / n;\\n        while (left < right) {\\n            long target = right - (right - left) / 2;\\n            long total = Arrays.stream(batteries).asLongStream().map(battery -> Math.min(battery, target)).sum();\\n            if (total >= target * n) {\\n                left = target;\\n            }", "class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sp = 0;\\n        for (long power : batteries)\\n            sp += power;\\n        long low = 1, high = sp / n;\\n        \\n        while (low < high){\\n            long time = (low+high+1) / 2;\\n            if (check(batteries, n, time))\\n                low = time;\\n            else\\n                high = time - 1;\\n        }", "class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long start = 1;\\n        long end = 0;\\n        for(int e : batteries){\\n            end+=e;\\n        }"]}
{"id": "2141", "ref_java": ["class Solution {\\n    public int numberOfWays(String corridor) {\\n        final int mod = 1000000007;  ", "class Solution {\\n    ", "class Solution {\\n    numberOfWays(corridor) {\\n        const MOD = 1e9 + 7;\\n        let zero = 0;\\n        let one = 0;\\n        let two = 1;\\n\\n        for (const thing of corridor) {\\n            if (thing === \\'S\\') {\\n                zero = one;\\n                [one, two] = [two, one];\\n            }"]}
{"id": "2142", "ref_java": ["class Solution {\\n    public int maximumGood(int[][] statements) {  \\n        ", "class Solution {\\n    public int maximumGood(int[][] statements) {  \\n        ", "class Solution {\\n    public int maximumGood(int[][] sts) {\\n        "]}
{"id": "2143", "ref_java": ["class Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\t\\t", "class Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\t\\t", "class Solution {\\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\\n\\t\\t"]}
{"id": "2144", "ref_java": ["class Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char ch : words[i].toCharArray()) {\\n                masks[i] |= (1 << ch - \\'a\\');\\n            }", "class Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char ch : words[i].toCharArray()) {\\n                masks[i] |= (1 << ch - \\'a\\');\\n            }", "class Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int[] parents = new int[n];\\n        int[] ranks = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        Arrays.fill(ranks, 1);\\n\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int val = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                val += (1 << (words[i].charAt(j) - \\'a\\'));\\n            }"]}
{"id": "2145", "ref_java": ["class Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n=nums.length;  ", "class Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n=nums.length;  ", "class Solution {\\n    public long minimumDifference(int[] nums) {\\n        PriorityQueue<Integer> pq_start = new PriorityQueue<>((a,b)->{\\n            return b - a;\\n        }"]}
{"id": "2146", "ref_java": ["class Solution {\\n    private int[][] dp;\\n    private int minTime(String s, int idx, int stage) {\\n        if (idx == s.length()) return 0;\\n        else if(dp[idx][stage] != -1)   return dp[idx][stage];\\n\\n        int requiredTime = Integer.MAX_VALUE;\\n        char curr = s.charAt(idx);\\n        for (int i = stage; i < 3; i++) {\\n            int temp = Integer.MAX_VALUE;\\n            if (i == 0 ||  i == 2) {\\n                temp = 1 + minTime(s, idx + 1, i);\\n            }", "class Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int min = s.length();\\n        int[] nums = new int[n];\\n        for (int i = 0; i < n; i++)\\n            nums[i] = s.charAt(i) - \\'0\\';\\n\\n\\t\\t", "class Solution {\\n    private int[][] dp;\\n    private int minTime(String s, int idx, int stage) {\\n        if (idx == s.length()) return 0;\\n        else if(dp[idx][stage] != -1)   return dp[idx][stage];\\n\\n        int requiredTime = Integer.MAX_VALUE;\\n        char curr = s.charAt(idx);\\n        for (int i = stage; i < 3; i++) {\\n            int temp = Integer.MAX_VALUE;\\n            if (i == 0 ||  i == 2) {\\n                temp = 1 + minTime(s, idx + 1, i);\\n            }"]}
{"id": "2147", "ref_java": ["class Solution {\\n    int[][] dp;\\n    public int maximumANDSum(int[] nums, int ns) {\\n        dp = new int[nums.length][(int)Math.pow(2,ns*2)];\\n        for(int[] d:dp)Arrays.fill(d,-1);\\n        return solve(nums,0,0,ns);\\n    }", "class Solution {\\n    int[][] dp;\\n    public int maximumANDSum(int[] nums, int ns) {\\n        dp = new int[nums.length][(int)Math.pow(2,ns*2)];\\n        for(int[] d:dp)Arrays.fill(d,-1);\\n        return solve(nums,0,0,ns);\\n    }", "class Solution {\\n    int[] memo;\\n    int[] nums;\\n    int numSlots;\\n    public int maximumANDSum(int[] nums, int numSlots) {\\n        this.memo=new int[1<<(2*numSlots)];\\n        this.nums=nums;\\n        this.numSlots=numSlots;\\n        return helper(0,0);\\n    }"]}
{"id": "2148", "ref_java": ["class Solution {\\n    class BIT {\\n        long[] arr;\\n        public BIT(int n) {\\n            this.arr = new long[n + 1];\\n        }", "class Solution {\\n\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> elemToIndexMappingInB = new HashMap<>();\\n        int n = nums1.length;\\n        long[] segmentTree = new long[n * 4 + 1];\\n        long ans = 0;\\n        for (int i = 0; i < nums2.length; i++) {\\n            elemToIndexMappingInB.put(nums2[i], i);\\n        }", "class Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int []pos = new int[n];\\n        \\n        FenwickTree ft = new FenwickTree(n+1);\\n        \\n        for(int i=0;i<n;i++)\\n            pos[nums2[i]]=i;\\n        \\n        long []left=new long[n];\\n        long []right = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n            int idx = pos[nums1[i]];\\n            left[i] = ft.sum(idx-1);\\n            ft.update(idx,1);\\n        }"]}
{"id": "2149", "ref_java": ["class Solution {\\n    public long countPairs(int[] nums, int k) {\\n       HashMap<Integer,Long> map = new HashMap<>();\\n       long ans = 0L;\\n       for(int i=0;i<nums.length;i++){\\n           int gcd = gcd(nums[i],k);\\n           for(Map.Entry<Integer,Long> e : map.entrySet()){\\n               long num = (long)e.getKey()*(long)gcd;\\n               if(num%(long)k==0L)\\n                   ans+=e.getValue();\\n           }", "class Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long result = 0;\\n        Map<Integer, Integer> gcdMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = findGcd(nums[i], k);\\n            for (int num : gcdMap.keySet()) {\\n                if ((long) gcd * num % k == 0) { ", "class Solution {\\n    public long coutPairs(int[] nums, int k) {\\n        long result = 0;\\n        Map<Integer, Integer> gcdMap = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = findGcd(nums[i], k);\\n            for (int num : gcdMap.keySet()) {\\n                if ((long) gcd * num % k == 0) { "]}
{"id": "2150", "ref_java": ["class Solution {\\n    \\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        \\n        int n = tires.length; \\n        if(numLaps==0) return 0; \\n        int min[] = new int[numLaps+1]; \\n\\n        Arrays.fill(min, Integer.MAX_VALUE); \\n\\n        for(int i=0;i<n;i++){\\n            int base = tires[i][0];\\n            int curr = tires[i][0];\\n            int factor = tires[i][1];\\n            int lap = 1; \\n            int sum = curr; \\n            while(curr<changeTime + base && lap<=numLaps)\\n                {\\n                min[lap] = Math.min(min[lap], sum);\\n                curr = curr*factor;\\n                sum+=curr;\\n                lap++;\\n                }", "class Solution {\\n    int[] best, memo;\\n    int numLaps, changeTime, maxLaps=0;\\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        this.memo=new int[numLaps];\\n        this.best=new int[numLaps];\\n        this.numLaps=numLaps;\\n        this.changeTime=changeTime;\\n        int minChangeTime=Integer.MAX_VALUE;\\n        for(int[] t: tires) if(t[0]<minChangeTime) minChangeTime=t[0];\\n        minChangeTime+=changeTime;\\n        ", "class Solution {\\n    \\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\\n        \\n        int n = tires.length; \\n        if(numLaps==0) return 0; \\n        int min[] = new int[numLaps+1]; \\n\\n        Arrays.fill(min, Integer.MAX_VALUE); \\n\\n        for(int i=0;i<n;i++){\\n            int base = tires[i][0];\\n            int curr = tires[i][0];\\n            int factor = tires[i][1];\\n            int lap = 1; \\n            int sum = curr; \\n            while(curr<changeTime + base && lap<=numLaps)\\n                {\\n                min[lap] = Math.min(min[lap], sum);\\n                curr = curr*factor;\\n                sum+=curr;\\n                lap++;\\n                }"]}
{"id": "2151", "ref_java": ["class Solution {\\n\\n\\t\\tpublic int minMovesToMakePalindrome(String s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tchar[] strArr = s.toCharArray();        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           ", "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count = 0;\\n        \\n        while(s.length() > 2) {\\n            char ch1 = s.charAt(0);\\n            int len = s.length();\\n            char ch2 = s.charAt(len - 1);\\n            \\n            if (ch1 == ch2) {\\n                s = s.substring(1, len - 1);\\n            }", "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char arr[]=s.toCharArray();\\n        int i=0; \\n        int j=arr.length-1;\\n        while(i<j){\\n            int high=j;\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }"]}
{"id": "2152", "ref_java": ["class Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n    LinkedList<Integer> ans = new LinkedList<>();\\n    for (int num : nums) {\\n      while (!ans.isEmpty() && gcd(ans.getLast(), num) > 1)\\n        num = lcm(ans.removeLast(), num);\\n      ans.addLast(num);\\n    }", "class Solution {\\n\\t\\tpublic List<Integer> replaceNonCoprimes(int[] nums) \\n\\t\\t{\\n\\t\\t\\tList<Integer> al=new ArrayList<>();\\n\\t\\t\\tlong n1=nums[0];\\n\\t\\t\\tint idx=1;\\n\\n\\t\\t\\twhile(idx<nums.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((int)gcd(n1,nums[idx])==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t\\t\\t}", "class Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n    LinkedList<Integer> ans = new LinkedList<>();\\n    for (int num : nums) {\\n      while (!ans.isEmpty() && gcd(ans.getLast(), num) > 1)\\n        num = lcm(ans.removeLast(), num);\\n      ans.addLast(num);\\n    }"]}
{"id": "2153", "ref_java": ["class Solution {\\n    ArrayList<int[]>[] nextGraph, preGraph;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        buildGraph(n, edges);\\n        \\n        long[] src1To = new long[n], src2To = new long[n], toDest = new long[n];\\n        Arrays.fill(src1To, -1);\\n        Arrays.fill(src2To, -1);\\n        Arrays.fill(toDest, -1);\\n        \\n        shortestPath(src1, src1To, nextGraph);\\n        shortestPath(src2, src2To, nextGraph);\\n        shortestPath(dest, toDest, preGraph);\\n        \\n        long res = -1;\\n        for (int i = 0; i < n; i++) {\\n            long d1 = src1To[i], d2 = src2To[i], d3 = toDest[i];\\n            if (d1 >= 0 && d2 >= 0 && d3 >= 0) {\\n                long d = d1 + d2 + d3;\\n                if (res == -1 || d < res) {\\n                    res = d;\\n                }", "class Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        ArrayList<ArrayList<Pair>> adj= new ArrayList<>();\\n        ArrayList<ArrayList<Pair>> revAdj= new ArrayList<>();\\n\\n        for(int i=0;i<n; i++){\\n            adj.add(new ArrayList<>());\\n            revAdj.add(new ArrayList<>());\\n        }", "class Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        ArrayList<ArrayList<Pair>> adj= new ArrayList<>();\\n        ArrayList<ArrayList<Pair>> revAdj= new ArrayList<>();\\n\\n        for(int i=0;i<n; i++){\\n            adj.add(new ArrayList<>());\\n            revAdj.add(new ArrayList<>());\\n        }"]}
{"id": "2154", "ref_java": ["class Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }", "class Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }", "class Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t"]}
{"id": "2155", "ref_java": ["class Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int k=queryIndices.length;\\n        SegmentTree tree=new SegmentTree(s);\\n        for(int i=0;i<k;i++){\\n            tree.update(0,0,s.length()-1,queryIndices[i],queryCharacters.charAt(i));\\n            queryIndices[i]=tree.tree[0].max;\\n        }", "class Solution {\\n    class TreeNode {\\n        ", "class Solution {\\n    class TreeNode {\\n        "]}
{"id": "2156", "ref_java": ["class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        ", "class Solution {\\n    int dp[][];\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        dp = new int[n+1][k+1];\\n        for(int i = 1; i <= n; i++){\\n            for(int coins = 0; coins <= k; coins++){\\n                dp[i][coins] = -1;\\n            }", "class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];"]}
{"id": "2157", "ref_java": ["class Solution {\\n    public static long sumScores(String s) {\\n\\t\\tint[] ans = patternMatching(s.toCharArray());\\n\\t\\tlong sum = s.length();\\n\\t\\tfor (int i : ans) {\\n\\t\\t\\tsum += i;\\n\\t\\t}", "class Solution {\\n    public static long sumScores(String s) {\\n\\t\\tint[] ans = patternMatching(s.toCharArray());\\n\\t\\tlong sum = s.length();\\n\\t\\tfor (int i : ans) {\\n\\t\\t\\tsum += i;\\n\\t\\t}", "class Solution {\\n    public long[] hsh, hsh2, pw, pw2;\\n    public int mod = (int) 1e9+7;\\n    public long sumScores(String s) {\\n        int n = s.length(), base = 131, base2 = 137;\\n        hsh = new long[n+1]; pw = new long[n+1];\\n        hsh2 = new long[n+1]; pw2 = new long[n+1];\\n        pw[0] = 1; pw2[0] = 1;\\n        for (int j = 1; j <= n; j++) {\\n            hsh[j] = (hsh[j-1]*base + s.charAt(j-1))%mod;\\n            pw[j] = pw[j-1]*base%mod;\\n            hsh2[j] = (hsh2[j-1]*base2 + s.charAt(j-1))%mod;\\n            pw2[j] = pw2[j-1]*base2%mod;\\n        }"]}
{"id": "2159", "ref_java": ["class Solution {\\n    \\n    ", "class Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }", "class Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }"]}
{"id": "2160", "ref_java": ["class Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.length == 0 || edges == null || edges.length == 0) {\\n            return -1;\\n        }", "class Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.length == 0 || edges == null || edges.length == 0) {\\n            return -1;\\n        }", "class Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        PriorityQueue<Integer>[] minheap = new PriorityQueue[scores.length];\\n        Comparator<Integer> cmp = Comparator.comparingInt(o -> scores[o]);\\n        Arrays.setAll(minheap, o -> new PriorityQueue<>(cmp));\\n        for (int[] e : edges){\\n            minheap[e[0]].offer(e[1]);\\n            minheap[e[1]].offer(e[0]);\\n            if (minheap[e[0]].size()>3){\\n                minheap[e[0]].poll();\\n            }"]}
{"id": "2161", "ref_java": ["class Solution {\\n    int ans = 1;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int i = 1; i < n; i++) adj.get(parent[i]).add(i);\\n        longestPathDfs(0, adj, s);\\n        return ans;\\n    }", "class Solution {\\n    ", "class Solution {\\n    int distance[] = new int[100005];\\n    int output = 1;\\n\\n    void longestPath(int currNode, String s, ArrayList<ArrayList<Integer>> adj) {\\n        distance[currNode] = 1;\\n        for (int node : adj.get(currNode)) {\\n            longestPath(node, s, adj);\\n            if (s.charAt(node) == s.charAt(currNode))\\n                continue;\\n            output = Math.max(output, distance[currNode] + distance[node]);\\n            distance[currNode] = Math.max(distance[currNode], distance[node] + 1);\\n        }"]}
{"id": "2162", "ref_java": ["class Solution {\\n    public int[] fullBloomFlowers(int[][] flowers, int[] people) {\\n        int[] sortedArrivalTimes = Arrays.copyOf(people, people.length);\\n        Arrays.sort(sortedArrivalTimes);\\n\\n        ", "class Solution {\\n    public int[] fullBloomFlowers(int[][] flowers, int[] people) {\\n        TreeMap<Integer, Integer> flowerCount = new TreeMap<>();\\n\\n        for (int[] flower : flowers) {\\n            flowerCount.put(flower[0], flowerCount.getOrDefault(flower[0], 0) + 1);\\n            flowerCount.put(flower[1] + 1, flowerCount.getOrDefault(flower[1] + 1, 0) - 1);\\n        }", "class Solution {\\n    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {\\n        int n = persons.length;\\n        int[] result = new int[n];\\n        \\n        "]}
{"id": "2163", "ref_java": ["class Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}", "class Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}", "class Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}"]}
{"id": "2164", "ref_java": ["class Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            c-=a[s.charAt(i)-\\'a\\'];\\n            ans+=c+=a[s.charAt(i)-\\'a\\']=i+1;\\n        }", "class Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            c-=a[s.charAt(i)-\\'a\\'];\\n            ans+=c+=a[s.charAt(i)-\\'a\\']=i+1;\\n        }", "class Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            c-=a[s.charAt(i)-\\'a\\'];\\n            ans+=c+=a[s.charAt(i)-\\'a\\']=i+1;\\n        }"]}
{"id": "2165", "ref_java": ["class Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}", "class Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  ", "class Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}"]}
{"id": "2166", "ref_java": ["class Solution {\\n    int Kadane(int x, int y, string &s)\\n    {\\n        int d = 0, n = s.size();\\n        int ans = 0, ycnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if((s[i]-\\'a\\') == x)\\n            {\\n                d++;\\n            }", "class Solution {\\n  public int largestVariance(String s) {\\n    int ans = 0;\\n\\n    for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1)\\n      for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2)\\n        if (c1 != c2)\\n          ans = Math.max(ans, kadane(s, c1, c2));\\n\\n    return ans;\\n  }", "class Solution {\\n    public int largestVariance(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray())\\n        map.put(c, map.getOrDefault(c, 0) + 1);\\n        int max = 0;\\n        for(char c1 : map.keySet()) {\\n            for(char c2 : map.keySet()) {\\n                if(c1 == c2) continue;\\n                int c1Freq = 0, c2Freq = 0;\\n                int c1Remaining = map.get(c1);\\n                for(char c : s.toCharArray()) {\\n                    if(c == c1) {\\n                    c1Freq ++;\\n                    c1Remaining --;\\n                    }"]}
{"id": "2168", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }", "class Solution {\\n    "]}
{"id": "2170", "ref_java": ["class Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int arr[][] = new int[grid.length][grid[0].length];\\n        for(int a[] : arr){\\n            Arrays.fill(a,Integer.MAX_VALUE);\\n        }", "class Solution {\\n    int min_removal= Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(0,0,grid,0,visited);\\n        return min_removal;\\n    }", "class Solution {\\n    int [][]grid;\\n    int n,m;\\n    boolean [][]seen;\\n    int []dx = new int[]{0,0,1,-1}"]}
{"id": "2172", "ref_java": ["class Solution {\\n    public boolean matchReplacement(String s, String sub, char[][] mappings) {\\n        HashMap<Character, HashSet<Character>> m = new HashMap<>();\\n        for(char[] carr: mappings) {\\n            if (!m.containsKey(carr[0])){\\n                m.put(carr[0], new HashSet<Character>());\\n            }", "class Solution {\\n    private static final int ALPHABET_SIZE = 62;\\n\\n    public boolean matchReplacement(String s, String sub, char[][] mappings) {\\n        boolean[][] map = new boolean[ALPHABET_SIZE][ALPHABET_SIZE];\\n        for (char[] mapping : mappings) map[idx(mapping[0])][idx(mapping[1])] = true;\\n        for (int i = 0; i < ALPHABET_SIZE; i++) map[i][i] = true;\\n        int n = s.length(), m = sub.length();\\n        int[] a = new int[n], b = new int[m];\\n        for (int i = 0; i < n; i++) a[i] = idx(s.charAt(i));\\n        for (int i = 0; i < m; i++) b[i] = idx(sub.charAt(i));\\n\\n        int k = n - m + 1, t = nextPow2(n + m - 1);\\n        long[] result = new long[k];\\n\\n        double[][] arr1 = new double[2][t], arr2 = new double[2][t];\\n        double[] re1 = arr1[0], re2 = arr2[0], im1 = arr1[1], im2 = arr2[1];\\n        for (int c1 = 0, c2 = 1; c1 < ALPHABET_SIZE; c1 += 2, c2 += 2) {\\n            for (int i = 0; i < n; i++) re1[i] = a[i] == c1 ? 1 : 0;\\n            for (int i = 0, j = m - 1; i < m; i++, j--) re2[j] = map[b[i]][c1] ? 0 : 1;\\n            Arrays.fill(re1, n, t, 0);\\n            Arrays.fill(re2, m, t, 0);\\n           \\n\\t\\t\\tfor (int i = 0; i < n; i++) im1[i] = a[i] == c2 ? 1 : 0;\\n\\t\\t\\tfor (int i = 0, j = m - 1; i < m; i++, j--) im2[j] = map[b[i]][c2] ? 0 : -1;\\n\\t\\t\\tArrays.fill(im1, n, t, 0);\\n\\t\\t\\tArrays.fill(im2, m, t, 0);\\n            \\n            multiply(arr1, arr2);\\n            for (int i = 0, j = m - 1; i < k; i++, j++) result[i] |= Math.round(re1[j]);\\n        }", "class Solution {\\n    public boolean matchReplacement(String s, String sub, char[][] mappings) {\\n        int m = sub.length(), n = s.length();\\n        final int RANGE = \\'z\\' - \\'0\\' + 1;\\n        \\n        boolean[][] multiMap = new boolean[RANGE][RANGE];\\n        for (char[] map : mappings) {\\n            char from = map[0], to = map[1];\\n            multiMap[from - \\'0\\'][to - \\'0\\'] = true;\\n        }"]}
{"id": "2173", "ref_java": ["\npublic long countSubarrays(int[] nums, long k) {\n    long sum = 0, res = 0;\n    for (int i = 0, j = 0; i < nums.length; ++i) {\n        sum += nums[i];\n        while (sum * (i - j + 1) >= k)\n            sum -= nums[j++];\n        res += i - j + 1;\n    }\n    return res;\n}\n", "\npublic long countSubarrays(int[] nums, long k) {\n    long sum = 0, res = 0;\n    for (int i = 0, j = 0; i < nums.length; ++i) {\n        sum += nums[i];\n        while (sum * (i - j + 1) >= k)\n            sum -= nums[j++];\n        res += i - j + 1;\n    }\n    return res;\n}\n", "\npublic long countSubarrays(int[] nums, long k) {\n    long sum = 0, res = 0;\n    for (int i = 0, j = 0; i < nums.length; ++i) {\n        sum += nums[i];\n        while (sum * (i - j + 1) >= k)\n            sum -= nums[j++];\n        res += i - j + 1;\n    }\n    return res;\n}\n"]}
{"id": "2174", "ref_java": ["class Solution {\\n    public long DistinctNames(string[] ideas) {\\n        long distinctCompany = 0;\\n        Dictionary<char, HashSet<string>> dict = new Dictionary<char, HashSet<string>>();\\n        ", "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        Set<String>[] sets = new Set[26];\\n        for (int i = 0; i < 26; i++) {\\n            sets[i] = new HashSet();\\n        }", "class Solution {\\n       public long distinctNames(String[] ideas) {\\n       List<String> arr[] = new ArrayList[26];               "]}
{"id": "2175", "ref_java": ["class Solution {\\n    Long[][] dp;\\n    record Pair(int x, int y) { }", "class Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] price : prices) {\\n            dp[price[0]][price[1]] = price[2];\\n        }", "class Solution {\\n    Long[][] dp;\\n    record Pair(int x, int y) { }"]}
{"id": "2176", "ref_java": ["class Solution {\\n    private static final int k = 6, p = 1_000_000_007;\\n\\n    public int distinctSequences(int n) {\\n        if (n == 1) return 6;\\n        int counter = 0;\\n        Map<Pair, Integer> map = new HashMap<>();\\n\\t\\t", "class Solution {\\n    static long[][] dp;\\n    public int distinctSequences(int n) {\\n        if(n==1) return 6;\\n        int mod = 1_000_000_007;\\n        dp =new long[][]\\n                {\\n                    {0,1,1,1,1,1}", "class Solution {\\n    \\n    public static int[][] arr = {{}"]}
{"id": "2177", "ref_java": ["class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0, n=nums1.length;\\n        for(int num:nums1) sum1+=num;\\n        for(int num:nums2) sum2+=num;\\n        \\n        if(sum2>sum1){\\n            int temp = sum2;\\n            sum2 = sum1;\\n            sum1 = temp;\\n            int[] temparr = nums2;\\n            nums2 = nums1;\\n            nums1 = temparr;\\n        }", "class Solution {\\n    long solve(int[] nums1, int[] nums2, long sum1, long sum2)\\n    {\\n        long windowSum1 = 0, windowSum2 = 0;\\n        int low = 0, n = nums1.length;\\n        long mxSum = 0;\\n        for (int high = 0; high < n; high++)\\n        {\\n            windowSum1 += nums1[high];\\n            windowSum2 += nums2[high];\\n            while (windowSum1 > windowSum2 && low <= high)\\n            {\\n                windowSum1 -= nums1[low];\\n                windowSum2 -= nums2[low];\\n                low++;\\n            }", "class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int prefix1[] = new int[n+1];\\n        prefix1[0]= 0;\\n        for(int i=1;i<=n;i++)\\n            prefix1[i] = prefix1[i-1]+ nums1[i-1];\\n        \\n        int prefix2[] = new int[n+1];\\n        prefix2[0]= 0;\\n        for(int i=1;i<=n;i++)\\n            prefix2[i] = prefix2[i-1]+ nums2[i-1];\\n\\n        int minA =0,minB = 0;\\n        int diff1[] = new int[n+1];\\n        int diff2[] = new int[n+1];\\n        diff1[0] = prefix1[n];\\n        diff2[0] = prefix2[n];\\n \\n        for(int i=1;i<=n;i++){\\n\\n           int temp1 = prefix2[i]-prefix1[i];\\n            diff1[i]= prefix1[n]+temp1-minA;\\n            minA = Math.min(minA, temp1);\\n\\n            int temp2 = prefix1[i]-prefix2[i];\\n            diff2[i]= prefix2[n]+temp2-minB;\\n            minB = Math.min(minB, temp2);\\n\\n        }"]}
{"id": "2178", "ref_java": ["class Solution {\\n    private ArrayList<Integer> tree[];\\n    private int val[];\\n    private int minScore;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        val = nums;\\n        int nodes = nums.length;\\n        int len = edges.length;\\n        tree = new ArrayList[nodes];\\n        \\n        for(int node =0;node<nodes;node++) tree[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            tree[node1].add(node2);\\n            tree[node2].add(node1);\\n        }", "class Solution {\\n    private ArrayList<Integer> tree[];\\n    private int val[];\\n    private int minScore;\\n    \\n    public int minimumScore(int[] nums, int[][] edges) {\\n        val = nums;\\n        int nodes = nums.length;\\n        int len = edges.length;\\n        tree = new ArrayList[nodes];\\n        \\n        for(int node =0;node<nodes;node++) tree[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            tree[node1].add(node2);\\n            tree[node2].add(node1);\\n        }", "class Solution {\\n    public int minimumScore(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        xor = new int[n];\\n        tree = new ArrayList[n];\\n        for(int i=0;i<n;i++)tree[i] = new ArrayList<>();\\n        for(int[] e : edges){\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n\\n        }"]}
{"id": "2179", "ref_java": ["class Solution {\\n    int[][] dir={{1,0}", "class Solution {\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length; ", "class Solution {\\n    private final int mod = (int) (1e9 + 7);\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1}"]}
{"id": "2180", "ref_java": ["class Solution {\\n    ", "class Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        int[] next_small = new int[n];\\n        int[] prev_small = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        Arrays.fill(next_small, n);\\n        Arrays.fill(prev_small, -1);\\n        for(int i=1;i<n;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\\n                stack.pop();\\n            }", "class Solution {\\n    "]}
{"id": "2181", "ref_java": ["class Solution {\\n    int M =(int)1e9+7;\\n    public int idealArrays(int n, int maxValue) {\\n        long ans = 0;\\n        int N = n+maxValue;\\n        long[] inv = new long[N];\\n        long[] fact = new long[N];\\n        long[] factinv = new long[N];\\n        inv[1]=fact[0]=fact[1]=factinv[0]=factinv[1]=1;\\n        for (int i = 2; i < N; i++){ ", "class Solution {\\n    public int idealArrays(int n, int m) {\\n        ", "class Solution {\\n    public int idealArrays(int n, int m) {\\n        "]}
{"id": "2182", "ref_java": ["class Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        Arrays.sort(numsDivide);\\n        int val=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            val=gcd(val,numsDivide[i]);\\n        }", "class Solution {\\n    static int gcd(int a,int b){\\n        if(a==0)\\n        return b;\\n        return gcd(b%a,a);\\n    }", "class Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        Arrays.sort(numsDivide);\\n        int val=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            val=gcd(val,numsDivide[i]);\\n        }"]}
{"id": "2183", "ref_java": ["class Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int len = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:rolls)\\n        {\\n            set.add(i);\\n            if(set.size()==k)\\n            {\\n                set = new HashSet<>();\\n                len++;\\n            }", "class Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int len = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:rolls)\\n        {\\n            set.add(i);\\n            if(set.size()==k)\\n            {\\n                set = new HashSet<>();\\n                len++;\\n            }", "class Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int len = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:rolls)\\n        {\\n            set.add(i);\\n            if(set.size()==k)\\n            {\\n                set = new HashSet<>();\\n                len++;\\n            }"]}
{"id": "2184", "ref_java": ["class Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer,Set<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int x = Integer.bitCount(i);\\n            map.putIfAbsent(x,new HashSet<>());\\n            map.get(x).add(i);\\n        }", "class Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer,Set<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int x = Integer.bitCount(i);\\n            map.putIfAbsent(x,new HashSet<>());\\n            map.get(x).add(i);\\n        }", "class Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer,Set<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int x = Integer.bitCount(i);\\n            map.putIfAbsent(x,new HashSet<>());\\n            map.get(x).add(i);\\n        }"]}
{"id": "2185", "ref_java": ["class Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] cycleLength = new int[edges.length];\\n        Arrays.fill(cycleLength, -1);\\n        boolean[] visited = new boolean[edges.length];\\n        int max = -1;\\n        for (int i = 0; i < edges.length; i++) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                int destination = edges[i];\\n                int length = 1;\\n                HashMap<Integer, Integer> nodeToDistance = new HashMap<>();\\n                nodeToDistance.put(i, 0);\\n                while (destination != -1 && !visited[destination]) {\\n                    nodeToDistance.put(destination, length);\\n                    visited[destination] = true;\\n                    destination = edges[destination];\\n                    length++;\\n                }", "class Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] cycleLength = new int[edges.length];\\n        Arrays.fill(cycleLength, -1);\\n        boolean[] visited = new boolean[edges.length];\\n        int max = -1;\\n        for (int i = 0; i < edges.length; i++) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                int destination = edges[i];\\n                int length = 1;\\n                HashMap<Integer, Integer> nodeToDistance = new HashMap<>();\\n                nodeToDistance.put(i, 0);\\n                while (destination != -1 && !visited[destination]) {\\n                    nodeToDistance.put(destination, length);\\n                    visited[destination] = true;\\n                    destination = edges[destination];\\n                    length++;\\n                }", "class Solution {\\n\\tint maxi = -1;\\n\\n\\tpublic int longestCycle(int[] edges) {\\n        "]}
{"id": "2186", "ref_java": ["class Solution {\\n    public long minimumReplacement(int[] nums) {\\n        int currentLargest = nums[nums.length - 1];\\n        long totalReplacements = 0;\\n        \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] <= currentLargest) {\\n                currentLargest = nums[i];\\n                continue;\\n            }", "class Solution {\\n    public long minimumReplacement(int[] nums) \\n    {\\n        long ans = 0, limit = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--)\\n        {\\n            if (nums[i] <= lim)\\n                limit = nums[i];\\n            else\\n            {\\n                long partitions = nums[i] / limit + ((nums[i] % limit != 0) ? 1 : 0);\\n                limit = nums[i] / partitions;\\n                ans += partitions - 1;\\n            }", "class Solution {\\n    public long minimumReplacement(int[] nums) {\\n        long result=0;\\n        int n = nums.length;\\n        int prev = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            if(prev>=nums[i]){\\n                prev = nums[i];\\n            }"]}
{"id": "2187", "ref_java": ["class Solution {\\n    public int countSpecialNumbers(int n) {\\n        String s = \"\"+n;\\n        int ans = 0;\\n        int[][][] dp = new int[s.length()+1][1<<10][2];\\n        dp[s.length()][0][0]=1; ", "class Solution {\\n    public int countSpecialNumbers(int n) {\\n        String s = \"\"+n;\\n        int ans = 0;\\n        int[][][] dp = new int[s.length()+1][1<<10][2];\\n        dp[s.length()][0][0]=1; ", "class Solution {\\n    public int countSpecialNumbers(int n) {\\n        String s = \"\"+n;\\n        int ans = 0;\\n        int[][][] dp = new int[s.length()+1][1<<10][2];\\n        dp[s.length()][0][0]=1; "]}
{"id": "2188", "ref_java": ["class Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] result = new long[n]; ", "class Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        ", "class Solution {\\n    class Node {\\n        Node root;\\n        long total;\\n\\n        Node(long val) {\\n            total = val;\\n        }"]}
{"id": "2189", "ref_java": ["class Solution {\\n    public long kSum(int[] nums, int k) {\\n        long sum = 0;\\n        Queue<Pair<Long, Integer>> pq = new PriorityQueue<>((a, b) -> Long.compare(b.getKey(), a.getKey()));\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + Math.max(0, nums[i]);\\n        }", "class Solution {\\n    public long kSum(int[] nums, int k) {\\n        long minus = 0, all = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            all += Math.max(nums[i], 0); ", "class Solution {\\n    public long kSum(int[] nums, int k) {\\n        long sum=0L;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]>0)  sum+=nums[i];\\n            else    nums[i]=-nums[i];\\n        }"]}
{"id": "2190", "ref_java": ["class Solution {\\n    public int[][] buildMatrix(int k, int[][] R, int[][] C) {\\n        int[][] ans = new int[k][k];\\n        int[] yp = new int[k+1]; ", "class Solution {\\n    public int[][] buildMatrix(int k, int[][] R, int[][] C) {\\n        int[][] ans = new int[k][k];\\n        int[] yp = new int[k+1]; ", "class Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        int[][] ans = new int[k][k];\\n        \\n        "]}
{"id": "2191", "ref_java": ["class Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length, ans=0, r=0, l=0;\\n        long currSum = 0;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        while(r<n) {\\n            ", "class Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length, ans=0, r=0, l=0;\\n        long currSum = 0;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        while(r<n) {\\n            ", "class Solution {\\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\\n        int n = chargeTimes.length, ans=0, r=0, l=0;\\n        long currSum = 0;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        while(r<n) {\\n            "]}
{"id": "2192", "ref_java": ["class Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n        PriorityQueue<long[]> queue = new PriorityQueue<>(\\n                (a, b) -> a[0] == b[0] ? (int) (a[1] - b[1]) : (int) (a[0] - b[0]));\\n        ", "class Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        LinkedList<long[]> list=new LinkedList<>();\\n        PriorityQueue<long[]> pq=new PriorityQueue<>((a,b)-> a[1]==b[1]? Long.compare(a[0],b[0]): Long.compare(a[1],b[1]));\\n        HashMap<Long,Integer> hm=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            pq.add(new long[]{i,0}", "class Solution {\\n    \\n    "]}
{"id": "2193", "ref_java": ["class Solution {\\n\\n    int N = 100001;\\n    int[] seg = new int[2*N];\\n    \\n    void update(int pos, int val){  ", "class Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        ArrayList<TreeSet> arr=new ArrayList<>();\\n        arr.add(new TreeSet());\\n        for(int i=0;i<nums.length;i++){\\n            int val=nums[i];\\n            int n=arr.size();\\n            if(arr.get(0).lower(val)==null ){\\n                arr.get(0).add(val);\\n            }", "class Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        SegmentTree root = new SegmentTree(1, 100000);\\n        int res = 0;\\n        for (int num : nums) {\\n            int preMax = root.rangeMaxQuery(root, num - k, num - 1);\\n            root.update(root, num, preMax + 1);\\n            res = Math.max(res, preMax + 1);\\n        }"]}
{"id": "2194", "ref_java": ["class Solution {\\n    public long minimumMoney(int[][] txs) {\\n        long netLosingCost = 0;\\n        int maxCashBack = 0;\\n        int maxCost = 0;\\n        for (int[] t : txs) {\\n            if (t[0] > t[1]) { ", "class Solution {\\n    public long minimumMoney(int[][] txs) {\\n        long netLosingCost = 0;\\n        int maxCashBack = 0;\\n        int maxCost = 0;\\n        for (int[] t : txs) {\\n            if (t[0] > t[1]) { ", "class Solution {\\n    public long minimumMoney(int[][] txs) {\\n        long netLosingCost = 0;\\n        int maxCashBack = 0;\\n        int maxCost = 0;\\n        for (int[] t : txs) {\\n            if (t[0] > t[1]) { "]}
{"id": "2195", "ref_java": ["class Solution {\\n    \\n    Node root;\\n    public int[] sumPrefixScores(String[] words) {\\n        root = new Node();\\n        int n = words.length;\\n        int[] ans = new int[n];\\n        for(int i = 0;i<n;i++){\\n            add(words[i]);\\n        }", "class Solution {\\n    \\n    private class TrieNode{\\n        TrieNode[]children;\\n        boolean isEnd;\\n        int pre_count=0;\\n        \\n        TrieNode(){\\n            children=new TrieNode[26];\\n            isEnd=false;\\n        }", "class Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        Tries trie=new Tries();\\n        \\n        \\n        \\n        for(String word:words){\\n            \\n            add(word,trie);\\n        }"]}
{"id": "2196", "ref_java": ["class Solution {\\n    int[] parents;\\n    \\n    private int find(int x){\\n        if(x != parents[x]) \\n            parents[x] = find(parents[x]);\\n        return parents[x];\\n    }", "class Solution {\\n    public int numberOfGoodPaths(int[] vals, int[][] edges) {\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            adj.computeIfAbsent(a, value -> new ArrayList<Integer>()).add(b);\\n            adj.computeIfAbsent(b, value -> new ArrayList<Integer>()).add(a);\\n        }", "class Solution {\\n    int[] parent, count; "]}
{"id": "2197", "ref_java": ["class Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingBIT().numberOfPairs(A, B, diff);\\n    }", "class Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingBIT().numberOfPairs(A, B, diff);\\n    }", "class Solution {\\n    public long numberOfPairs(int[] A, int[] B, int diff) {\\n        return new UsingBIT().numberOfPairs(A, B, diff);\\n    }"]}
{"id": "2198", "ref_java": ["class Solution {\\n    Integer[] dp;\\n    public int deleteString(String s) {\\n        dp = new Integer[s.length()];\\n        return helper(s , 0);\\n        \\n    }", "class Solution {\\n    int[] dp;\\n    public int deleteString(String s) {\\n        dp = new int[s.length()];\\n        return helper(s, 0);\\n    }", "class Solution {\\n    int[] dp;\\n    public int deleteString(String s) {\\n        dp = new int[s.length()];\\n        return helper(s, 0);\\n    }"]}
{"id": "2199", "ref_java": ["class Solution {\\n    int MOD = 1_000_000_000 + 7;\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] dp = new int[m][n][k + 1];\\n        \\n        ", "class Solution {\\n    int[][][] dp;\\n    int mod = 1_000_000_007;\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        dp = new int[rows][cols][k];\\n        for(int[][] a : dp) {\\n            for(int[] b : a) {\\n                Arrays.fill(b, -1);\\n            }", "class Solution {\\n    private int MOD = 1_000_000_007;\\n\\n    public int numberOfPaths(int[][] grid, int k) {\\n        if (grid == null || grid.length == 0) return 0;\\n\\n        int m = grid.length, n = grid[0].length;\\n        Integer[][][] dp = new Integer[m + 1][n + 1][k + 1];\\n        \\n        return solve(m - 1, n - 1, grid, k, 0, dp);\\n    }"]}
{"id": "2200", "ref_java": ["class Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }", "class Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }", "class Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }"]}
{"id": "2201", "ref_java": ["class Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res=0;\\n        int start=0,minstart=0,maxstart=0;\\n        boolean isMin=false,isMax=false;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int num=nums[i];\\n            if(num<minK || num>maxK){\\n                isMin=false;\\n                isMax=false;\\n                start=i+1;\\n            }", "class Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        int minI = -1, maxI = -1, left = -1, right = 0;\\n        long count = 0;\\n        while(right < nums.length){\\n            if(nums[right] < minK || nums[right] > maxK){\\n                minI = right;\\n                maxI = right;\\n                left = right;\\n            }", "class Solution {\\n    public long countSubarrays(int[] nums, int minK, int maxK) {\\n        long res=0;\\n        int start=0,minstart=0,maxstart=0;\\n        boolean isMin=false,isMax=false;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int num=nums[i];\\n            if(num<minK || num>maxK){\\n                isMin=false;\\n                isMax=false;\\n                start=i+1;\\n            }"]}
{"id": "2202", "ref_java": ["class Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        TreeMap<Integer, Long> numCosts = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            numCosts.put(nums[i], numCosts.getOrDefault(nums[i], (long) 0) + cost[i]);\\n        }", "class Solution {\\n\\tint[] nums, cost; ", "class Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int min=10000000, max=0;\\n        for(int i:nums) {\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }"]}
{"id": "2203", "ref_java": ["class Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        PriorityQueue<Integer> pqNumsOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqNumsEven = new PriorityQueue<>();\\n        \\n        PriorityQueue<Integer> pqTargetOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqTargetEven = new PriorityQueue<>();\\n\\n        for(int num : nums) {\\n            if(num % 2 == 0) {\\n                pqNumsEven.add(num);\\n            }", "class Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int n = nums.length;\\n        List<Integer> oddNums = new ArrayList<>(), evenNums = new ArrayList<>();\\n        List<Integer> oddTarget = new ArrayList<>(), evenTarget = new ArrayList<>();\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] % 2 == 1) {\\n                oddNums.add(nums[i]);\\n            }", "class Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 1){\\n                nums[i] = -nums[i];\\n            }"]}
{"id": "2204", "ref_java": ["class Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        for(int i = 0;i<n;i++) ans[i] = -1;\\n\\t\\t", "class Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        for(int i = 0;i<n;i++) ans[i] = -1;\\n\\t\\t", "class Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, -1);\\n        ListNode head = new ListNode();\\n        ListNode prev, cur;\\n        for (int i = 0; i < nums.length; ++i) {\\n            prev = head;\\n            cur = head.next;\\n            while (cur != null && nums[i] > cur.val) {\\n                ++cur.count;\\n                if (cur.count == 2) {\\n                    result[cur.idx] = nums[i]; "]}
{"id": "2205", "ref_java": ["class Solution {\\n    Map<Integer, CustomTreeNode> valToCustomNode = new HashMap<>();\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        CustomTreeNode customRoot = buildCustomTree(null, root); ", "class Solution {\\n    private Map<Integer, Integer> leftMap = new HashMap<>();\\n    private Map<Integer, Integer> rightMap = new HashMap<>();\\n    private Map<Integer, Integer> removed = new HashMap<>();\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        populateHeights(root, 0);\\n        calculateRemovedHeights(root, 0);\\n        \\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            output[i] = removed.get(queries[i]);\\n        }", "class Solution {\\n    Map<Integer, CustomTreeNode> valToCustomNode = new HashMap<>();\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        CustomTreeNode customRoot = buildCustomTree(null, root); "]}
{"id": "2206", "ref_java": ["class Solution {\\n\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        int m = robot.size(), n = factory.length;\\n        long[][] dp = new long[m + 1][n + 1];\\n        Arrays.sort(factory, (f1, f2) -> f1[0] - f2[0]);\\n        Collections.sort(robot);\\n        for (int i = 1; i <= m; i++) dp[i][0] = 200000000001L; ", "class Solution {\\n    Long[][] dp;\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        Collections.sort(robot);  ", "class Solution {\\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\\n        \\n         "]}
{"id": "2207", "ref_java": ["class Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        try{\\n            for(int parts=1;parts<=100000;parts++)\\n            {\\n                int extralen=(3+Integer.toString(parts).length())*parts;\\n                int extra=0;\\n                if(parts>=10000)\\n                    extra=9+90*2+900*3+9000*4+1*5;\\n                else if(parts>=1000)\\n                    extra=9+90*2+900*3+(parts-1000+1)*4;\\n                else if(parts>=100)\\n                    extra=9+90*2+(parts-100+1)*3;\\n                else if(parts>=10)\\n                    extra=9+(parts-10+1)*2;\\n                else\\n                    extra=parts;\\n                extralen+=extra;\\n                int totallen=extralen+message.length();\\n                if((limit*(parts-1)<totallen)&&(totallen-limit*(parts-1)<=limit))\\n                {\\n                    String ans[]=new String[parts];\\n                    int i=0;\\n                    for(int currpart=0;currpart<ans.length;currpart++)\\n                    {\\n                        String num=Integer.toString(currpart+1);\\n                        String deno=Integer.toString(parts);\\n                        String suffix=\"<\"+num+\"/\"+deno+\">\";\\n                        int len=limit-suffix.length();\\n                        if(currpart==ans.length-1)\\n                            ans[currpart]=message.substring(i,message.length())+suffix;\\n                        else\\n                            ans[currpart]=message.substring(i,i+len)+suffix;\\n                        i+=len;\\n                    }", "class Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int size = message.length();\\n        int lenOfIndice = 1, total = 1;\\n        while (size + (3 + len(total)) * total + lenOfIndice > limit * total) {\\n            if (3 + len(total) * 2 >= limit) return new String[0];\\n            total += 1;\\n            lenOfIndice += len(total);\\n        }", "class Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int[] stgTable = {\\n                (limit - 5) * 9,\\n                (limit - 6) * 9 + (limit - 7) * 90,\\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\\n        }"]}
{"id": "2208", "ref_java": ["class Solution {\\n  \\n    int k;\\n    boolean[] used;\\n    public int maxPalindromes(String s, int k) {\\n        this.k=k;\\n        used= new boolean[s.length()];\\n        Arrays.fill(used,false);\\n        if(k==1) return s.length();\\n        int res=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int oddLength = centerExpansion(i,i,s);\\n            int evenLength = centerExpansion(i,i+1,s);\\n            if(oddLength==i && evenLength==i) \\n            {\\n                i++;\\n            }", "class Solution {\\n    public int maxPalindromes(String s, int k) {\\n        int result = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isPalindrome(s, i, i + k - 1)) {\\n                result++;\\n                i = i + k - 1;\\n            }", "class Solution {\\n    public int maxPalindromes(String s, int k) {\\n        "]}
{"id": "2209", "ref_java": ["class Solution {\\n    int mod = 1000000007;\\n    boolean is[];\\n    public int beautifulPartitions(String s, int K, int minLength) {\\n        is = new boolean[10];\\n        is[2] = is[3] = is[5] = is[7] = true;\\n        \\n        int n = s.length();\\n        int a[] = new int[n + 1];\\n        for(int i = 0; i < n; i++) a[i + 1] = s.charAt(i) - \\'0\\';\\n        if(!is[a[1]]) {\\n            return 0;\\n        }", "class Solution {\\n    private static final int MOD = 1_000_000_007;\\n\\n    Set<Character> primes = Set.of(\\'2\\', \\'3\\', \\'5\\', \\'7\\');\\n    int n;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        n = s.length();\\n        if(primes.contains(s.charAt(s.length() - 1))) return 0;\\n        if(!primes.contains(s.charAt(0))) return 0;\\n        int[][] dp = new int[s.length() + 1][k];\\n        for(int[] A : dp) Arrays.fill(A, -1);\\n        return numOfWays(dp, 0, k - 1, s, minLength);\\n    }", "class Solution {\\n    private static int mod = (int) 1e9 + 7;\\n    public int beautifulPartitions(String s, int k, int l) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n\\t\\t"]}
{"id": "2210", "ref_java": ["class Solution {\\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long totalCount = 0;\\n        \\n        ", "class Solution {\\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long totalCount = 0;\\n        \\n        ", "class Solution {\\n    private final int mod = (int) 1e9 + 7;\\n    private Integer[][][][] dp;\\n    private int n;\\n\\n    public int countPalindromes(String s) {\\n        n = s.length();\\n        dp = new Integer[n][11][11][6];\\n        return solve(0, 10, 10, 0, s.toCharArray());\\n    }"]}
{"id": "2211", "ref_java": ["class Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        ", "class Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] smaller = new int[n + 1];  ", "class Solution {\\n\\n    \\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = 0;\\n        for (ind = 0; ind < nums.length; ind++) {\\n            if (nums[ind] == k) {\\n                break;\\n            }"]}
{"id": "2212", "ref_java": ["class Solution {\\n\\tpublic static int magnificentSets(int n, int[][] edges) {\\n\\t\\t", "class Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        ", "class Solution {\\n\\n    int bfs(int src, Map<Integer, List<Integer> > graph, int[] colors) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(src);\\n        queue.offer(-1);\\n        colors[src] = 1;\\n        int levels = 0;\\n        while (!queue.isEmpty()) {\\n            src = queue.poll();\\n            if (src == -1) {\\n                if (!queue.isEmpty())\\n                    queue.offer(-1);\\n                levels++;\\n                continue;\\n            }"]}
{"id": "2213", "ref_java": ["class Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        int k = 0, m = 0, n = nums1.length; \\n        boolean[] operated = new boolean[n];\\n        long output = 0;\\n        for (int i = 0; i < n; i++) if (nums1[i] == nums2[i]) {\\n            operated[i] = true;\\n            counts.put(nums1[i], counts.getOrDefault(nums1[i], 0) + 1);\\n            m++;\\n            output += i;\\n        }", "class Solution {\\n    public long minimumTotalCost(int[] a, int[] b) {\\n        ", "class Solution {\\n    public long minimumTotalCost(int[] a, int[] b) {\\n        "]}
{"id": "2214", "ref_java": ["class Solution {\\n    public int[] maxPoints(int[][] grid, int[] queries) {\\n        Queue<int[]> processQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int k = queries.length;\\n        int[] answer = new int[k];\\n\\n        for (int i = 0; i < k; i++) {\\n            processQueue.offer(new int[]{queries[i], i}", "class Solution {\\n    public int[] maxPoints(int[][] a, int[] q) {\\n        \\n        int n = a.length;\\n        int m = a[0].length;\\n        \\n        int l = q.length;\\n        int[][] p = new int[l][2];\\n        \\n        for(int i = 0 ; i < l ; i++) {\\n            \\n            p[i][0] = i;\\n            p[i][1] = q[i];\\n        }", "class Solution {\\n    private static final int[][] DIRS = {{1, 0}"]}
{"id": "2215", "ref_java": ["class Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edgesList) {\\n        Set<Pair<Integer,Integer>> edges = new HashSet<>();\\n        int[] degree = new int[n+1];\\n        \\n        for(List<Integer> edge : edgesList) {\\n            edges.add(new Pair(edge.get(0), edge.get(1)));\\n            edges.add(new Pair(edge.get(1), edge.get(0)));\\n            \\n            degree[edge.get(0)]++;\\n            degree[edge.get(1)]++;\\n        }", "class Solution {\\n\\tpublic boolean isPossible(int n, List<List<Integer>> edges) {\\n\\t\\tHashSet<Integer>[] graph = new HashSet[n]; \\n        for (int i = 0; i < n; ++i) graph[i] = new HashSet(); \\n\\t\\tfor (var e : edges) {\\n            graph[e.get(0)-1].add(e.get(1)-1); \\n            graph[e.get(1)-1].add(e.get(0)-1); \\n\\t\\t}", "class Solution {\\n    public boolean isPossible(int n, List<List<Integer>> edges) {\\n        List<Set<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new HashSet<>());\\n        }"]}
{"id": "2216", "ref_java": ["class Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] res = new int[queries.length];\\n        int ind = 0;\\n        for(int[] q: queries) {\\n            int lca = findLCA(q[0], q[1]);\\n            res[ind++] = findDist(q[0]) - findDist(lca) + findDist(q[1]) - findDist(lca) + 1;\\n        }", "class Solution {\\n    \\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int a = (int)(Math.log(queries[i][0])/Math.log(2));\\n            int b = (int)(Math.log(queries[i][1])/Math.log(2));\\n            ", "class Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int sz = queries.length; \\n\\t\\tint[] ans = new int[sz]; \\n\\t\\tfor (int i = 0; i < sz; ++i) {\\n\\t\\t\\tHashMap<Integer, Integer> dist = new HashMap(); \\n\\t\\t\\tfor (int u = queries[i][0], d = 0; u > 0; u /= 2) \\n\\t\\t\\t\\tdist.put(u, ++d); \\n\\t\\t\\tfor (int v = queries[i][1], d = 0; v > 0; v /= 2, ++d) \\n\\t\\t\\t\\tif (dist.containsKey(v)) {\\n\\t\\t\\t\\t\\tans[i] = d + dist.get(v); \\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}"]}
{"id": "2217", "ref_java": ["class Solution {\\n    long mod = (long) (1e9 + 7);\\n    long[] fac;\\n    public int countAnagrams(String s) {\\n\\n        fac = new long[s.length() + 1];\\n        fac[1] = 1;\\n      for (int i = 2; i <= s.length(); i++) {\\n            fac[i] = (fac[i - 1] * i) % mod;\\n        }", "class Solution {\\n\\tpublic int countAnagrams(String s) {\\n\\t\\tfinal int mod = 1_000_000_007; \\n\\t\\tint n = s.length(); \\n\\t\\tlong[] fact = new long[n+1], ifact = new long[n+1], inv = new long[n+1]; \\n\\t\\tfact[0] = ifact[0] = inv[0] = inv[1] = 1; \\n\\t\\tfor (int x = 1; x <= n; ++x) {\\n\\t\\t\\tif (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod; \\n\\t\\t\\tfact[x] = fact[x-1] * x % mod; \\n\\t\\t\\tifact[x] = ifact[x-1] * inv[x] % mod; \\n\\t\\t}", "class Solution {\\n    long mod = (long) 1e9+7;\\n    public int countAnagrams(String s) {\\n        int n = s.length();\\n        long[] fact = new long[n+1];\\n        fact[0] = 1L;\\n        for(int i=1;i<=n;i++){\\n            fact[i] = fact[i-1]*i%mod;\\n        }"]}
{"id": "2218", "ref_java": ["class Solution { \\n\\n\\tprivate Long[][] dp;   ", "class Solution {\\n    int mod = 1000000007;\\n    \\n    public int countPartitions(int[] nums, int k) {     \\n        int n = nums.length;\\n        int[][] dp = new int[n + 1][k + 1];\\n        for (int i = 0; i <= n; i++) dp[i][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = k; j >= 1; j--) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j - nums[i - 1] >= 0) {                    \\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - nums[i - 1]]) % mod;\\n                }", "class Solution { \\n\\n\\tprivate Long[][] dp;   "]}
{"id": "2219", "ref_java": ["class Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length; \\n        long lo = 0, hi = k + Arrays.stream(stations).asLongStream().sum();\\n        while (lo < hi) {\\n            long mid = lo + (hi-lo+1)/2, prefix = 0; \\n            int kk = k; \\n            int[] ss = stations.clone(); \\n            boolean ok = true; \\n            for (int i = 0; i < n+r; ++i) {\\n                if (i < n) prefix += ss[i]; \\n                if (i >= 2*r+1) prefix -= ss[i-2*r-1]; \\n                if (i >= r && prefix < mid) {\\n                    if (kk < mid - prefix) {\\n                        ok = false; \\n                        break; \\n                    }", "class Solution {\\n    private int len, r;\\n    public long maxPower(int[] stations, int r, int k) {\\n        this.len = stations.length;\\n        this.r = r;\\n\\n        long[] prefixSum = new long[len + 1], powers = new long[len + 1];\\n        for (int i = 1; i <= len; ++i) {\\n            prefixSum[i] += prefixSum[i - 1] + stations[i - 1];\\n        }", "class Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length;\\n        long left = 0, right = k;\\n        for (int x: stations)\\n            right += x;\\n        "]}
{"id": "2220", "ref_java": ["class Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        Worker[] worker = new Worker[k];\\n        for(int i=0;i<k;i++) {\\n            worker[i] = new Worker(i, time[i][0], time[i][1], time[i][2], time[i][3]);\\n        }", "class Solution {\\n    class WorkerOnBank{\\n        int details[], id;\\n        WorkerOnBank(int details[], int id){\\n            this.details = details;\\n            this.id = id;\\n        }", "class Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        Queue<Integer> leftPending = new PriorityQueue<>((i, j) -> {\\n            if (time[i][0] + time[i][2] != time[j][0] + time[j][2]) {\\n                return Integer.compare(time[j][0] + time[j][2], time[i][0] + time[i][2]);\\n            }"]}
{"id": "2221", "ref_java": ["class Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        Map<Integer, Long>[] adjList = new Map[n];\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new HashMap<>();\\n        }", "class Solution {\\n    Set<Integer>[] graph;\\n    long[][] dp;   \\n    int[] price;\\n    long max = 0;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        graph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new HashSet<>();\\n        }", "class Solution {\\n    Set<Integer>[] graph;\\n    long[][] dp;   \\n    int[] price;\\n    long max = 0;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        graph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new HashSet<>();\\n        }"]}
{"id": "2222", "ref_java": ["class Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int gcd = gcd(targetX, targetY);\\n        return (gcd & (gcd - 1)) == 0;\\n    }", "class Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        if (targetX > targetY)\\n            return isReachable(targetY, targetX);\\n        if (targetX % 2 == 0)\\n            return isReachable(targetX / 2, targetY);\\n        if (targetY % 2 == 0)\\n            return isReachable(targetX, targetY / 2);\\n            \\n        if (targetX == 1) \\n            return true;\\n        \\n        if (targetY == targetX)\\n            return false;\\n\\n        return isReachable(targetX, (targetX + targetY) / 2);\\n    }", "class Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        int g = BigInteger.valueOf(targetX).gcd(BigInteger.valueOf(targetY)).intValue();\\n        return (g & (g-1)) == 0; \\n    }"]}
{"id": "2223", "ref_java": ["class Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] cost = new int[n][n];\\n        for (int len = n; len >= 1; len--) {\\n            compute(cost, nums, len, k);\\n        }", "class Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] cost = new int[n][n];\\n        for (int len = n; len >= 1; len--) {\\n            compute(cost, nums, len, k);\\n        }", "class Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        int[][] trimmed = new int[n][n];\\n        for(int i=0;i<n;i++) {\\n            int curr = 0;\\n            int[] freq = new int[n];\\n            for(int j=i;j<n;j++) {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2) {\\n                    curr+=2;\\n                }"]}
{"id": "2224", "ref_java": ["class Solution {\\n\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }", "class Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(k == n) return 0;\\n        int costs[] = new int[n - 1];\\n        for(int i = 0; i < n - 1; i ++) {\\n            costs[i] = weights[i] + weights[ i + 1];\\n        }", "class Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }"]}
{"id": "2225", "ref_java": ["class Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long[] cnt = new long[n];\\n        long ans = 0;\\n        for (int j = 0; j < n; j++) {\\n            int prev_small = 0;\\n            for (int i = 0; i < j; i++) {\\n                if (nums[j] > nums[i]) {\\n                    prev_small++;\\n                    ans += cnt[i];\\n                }", "class Solution {\\n    public long countQuadruplets(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        \\n        Fenwick t1 = new Fenwick(new int[n + 1]);\\n        Fenwick t2 = new Fenwick(new int[n + 1]);\\n        long ans = 0;\\n        \\n        for(int i=1;i<=n;i++) t2.update(i,1);\\n        \\n        for(int j = 0 ; j < n ; j++) {\\n            \\n            t2.update(nums[j], -1);\\n            \\n            for(int k = j + 1 ; k < n ; k++) {\\n                \\n                t2.update(nums[k],-1);\\n                \\n                if(nums[j] > nums[k]) {\\n                    \\n                    long c1 = t1.query(1, nums[k]);\\n                    long c2 = t2.query(nums[j], n);\\n                    \\n                    ans += (c1 * c2);\\n                }", "class Solution {\\n    public long countQuadruplets(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        BIT bit = new BIT(n);\\n        \\n        int val;\\n        long running;\\n        \\n        long result = 0;\\n        \\n        for (int j = 0; j < n; ++j) {\\n            running = 0;\\n            val = nums[j];\\n            for (int k = j + 1; k < n; ++k) {\\n                if (nums[k] == nums[j])\\n                    continue;\\n                else if (nums[k] > nums[j]){\\n                    result += running;\\n                }"]}
{"id": "2226", "ref_java": ["class Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        long sum = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele : basket1)\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        for(int ele : basket2)\\n            map.put(ele,map.getOrDefault(ele,0)-1);\\n        \\n        List<Integer> list = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int key : map.keySet()){\\n            min = Math.min(min,key);\\n            int x =Math.abs(map.get(key));\\n            if(x == 0)   continue;\\n            if(x%2!=0) return -1;\\n            for(int i=0;i<x/2;i++)\\n                list.add(key);\\n        }", "class Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int min=basket1[0];\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int f:basket1){\\n            min=Math.min(min,f);\\n            hm.put(f,hm.getOrDefault(f,0)+1);\\n        }", "class Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int c: basket1) \\n            cnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n        for (int c: basket2) \\n            cnt.put(c, cnt.getOrDefault(c, 0) - 1);\\n        List<Integer> last = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> e: cnt.entrySet()) {\\n            int v = e.getValue();\\n            "]}
{"id": "2227", "ref_java": ["class Solution {\\n    public int minimumScore(String s, String t) {\\n        int leftT = 0;\\n        List<Integer> leftSs = new ArrayList<>();\\n\\n        for (int i = 0; i < s.length() && leftT < t.length(); i++) {\\n            if (s.charAt(i) == t.charAt(leftT)) {\\n                leftSs.add(i);\\n                leftT++;\\n            }", "class Solution {\\n    public int minimumScore(String s, String t) {\\n        int m = s.length(), n = t.length();\\n        int []left = new int[n+2];\\n        int []right = new int[n+2];\\n        int p = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (p < m && s.charAt(p) != t.charAt(i)) p++;\\n            left[i+1] = p++;\\n        }", "class Solution {\\n    public int minimumScore(String s, String t) {\\n        int leftT = 0;\\n        List<Integer> leftSs = new ArrayList<>();\\n\\n        for (int i = 0; i < s.length() && leftT < t.length(); i++) {\\n            if (s.charAt(i) == t.charAt(leftT)) {\\n                leftSs.add(i);\\n                leftT++;\\n            }"]}
{"id": "2228", "ref_java": ["class Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> list = new ArrayList<>();\\n        long answer = 0L;\\n        int n = nums1.length;\\n        for(int i=0;i<n;i++) if(nums1[i] == 0) nums1[i] = -1;\\n        SegmentTree sg = new SegmentTree(nums1);\\n        for(int a: nums2) answer += a;\\n        for(int[] q: queries){\\n            if(q[0] == 1) sg.multiplyToRange(q[1],q[2],-1);\\n            else if(q[0] == 2) answer += q[1]*((sg.getSumInRange(0,n-1)+n)/2);\\n            else list.add(answer);\\n        }", "class Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Deque<Long> dq = new LinkedList();\\n        long sum = 0;\\n        for (int i : nums2) sum += i;\\n        Segment root = build(nums1, 0, nums1.length - 1);\\n        for (int[] q : queries) {\\n            if (1 == q[0]) root.flip(q[1], q[2]);\\n            else if (2 == q[0]) sum += root.sum * q[1];\\n            else dq.add(sum);\\n        }", "class Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> ls = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n        for(int i = 0;i < n;i++){\\n            sum += 1L * nums2[i];\\n            if(nums1[i] == 1) bs.set(i);\\n        }"]}
{"id": "2229", "ref_java": ["class Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        ", "class Solution {\\n    class DSU {\\n        public int[] roots;\\n        public int[] sizes;\\n        DSU(int n) {\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                roots[i] = i;\\n                sizes[i] = 1;\\n            }", "class Solution {\\n    class DSU {\\n        public int[] roots;\\n        public int[] sizes;\\n        DSU(int n) {\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                roots[i] = i;\\n                sizes[i] = 1;\\n            }"]}
{"id": "2230", "ref_java": ["class Solution {\\n  class Cell {\\n    public int r;\\n    public int c;\\n    public int value;\\n\\n    Cell(int x, int y, int value) {\\n      this.r = x;\\n      this.c = y;\\n      this.value = value;\\n    }", "class Solution {\\n    private static final int[][] DIRS = new int[][] { { 1, 0 }", "class Solution {\\n  class Cell {\\n    public int r;\\n    public int c;\\n    public int value;\\n\\n    Cell(int x, int y, int value) {\\n      this.r = x;\\n      this.c = y;\\n      this.value = value;\\n    }"]}
{"id": "2231", "ref_java": ["class Solution {\\n\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n        \\n        List<Integer>[] graph = new ArrayList[n];\\n        Set<Integer>[] guessesGraph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            guessesGraph[i] = new HashSet<>();\\n        }", "class Solution {\\n    public int rootCount(int[][] eg, int[][] gu, int k) {\\n        ", "class Solution {\\n\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n        \\n        List<Integer>[] graph = new ArrayList[n];\\n        Set<Integer>[] guessesGraph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            guessesGraph[i] = new HashSet<>();\\n        }"]}
{"id": "2232", "ref_java": ["class Solution {\\n    public int findValidSplit(int[] nums) {\\n        ", "class Solution {\\n    ", "class Solution {\\n    "]}
{"id": "2233", "ref_java": ["class Solution {\\n    int mod = 1000000007;\\n    int solve(int[][] types, int i, int n, int target, int[][] dp){\\n        if(target == 0){\\n            return 1;\\n        }", "class Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] memo = new int[target + 1][types.length + 1];\\n        for (int[] ints : memo) {\\n            Arrays.fill(ints, -1);\\n        }", "class Solution {\\n    int mod = 1000000007;\\n    int solve(int[][] types, int i, int n, int target, int[][] dp){\\n        if(target == 0){\\n            return 1;\\n        }"]}
{"id": "2234", "ref_java": ["class Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (t1, t2) -> (t1[1] - t2[1]));\\n        \\n        boolean[] visited = new boolean[2010];\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < tasks.length; i++) {\\n\\t\\t\\tint nums = 0;\\n            ", "class Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(t1,t2)->(t1[1]==t2[1])?t1[0]-t2[0]:t1[1]-t2[1]);\\n        Set<Integer> used = new HashSet<>();\\n        int answer = 0;\\n        for(int[] task: tasks){\\n            int usedTime = 0;\\n            for(int i=task[0];i<=task[1];i++) if(used.contains(i)) usedTime++;\\n            int time_left = task[2]-usedTime;\\n            for(int i=task[1];time_left>0;i--){\\n                if(used.add(i)){\\n                    answer++;\\n                    time_left--;\\n                }", "class Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (t1, t2) -> (t1[1] - t2[1]));\\n        \\n        boolean[] visited = new boolean[2010];\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < tasks.length; i++) {\\n\\t\\t\\tint nums = 0;\\n            "]}
{"id": "2235", "ref_java": ["class Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        HashSet<Integer>[] map = new HashSet[coins.length];\\n        for (int i = 0; i < coins.length; i++) {\\n            map[i] = new HashSet<>();\\n        }", "class Solution {\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n\\n    int n = edges.length;\\n    ArrayList<HashSet<Integer>> list = new ArrayList<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    int totalEdges = 2*n;\\n    int deletedEdges = 0;\\n\\n    for(int i=0;i<=n;i++){\\n        list.add(new HashSet<Integer>());\\n    }", "class Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        List<Integer>[] g = new List[n];\\n        "]}
{"id": "2236", "ref_java": ["class Solution {\\n   \\n\\n    public static int findShortestCycle(int n, int[][] edges) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }", "class Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<Integer>());\\n        \\n        for(int edge[]: edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }", "class Solution {\\n   \\n\\n    public static int findShortestCycle(int n, int[][] edges) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }"]}
{"id": "2237", "ref_java": ["class Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n    TreeSet<Integer> even = new TreeSet(); \\n    TreeSet<Integer> odd = new TreeSet();\\n    int ans[] = new int[n];\\n    Arrays.fill(ans, -1);\\n    boolean vis[] = new boolean[n];\\n    for(int x : banned)\\n    vis[x] = true; \\n    for(int i=0; i<n; i++)\\n    {\\n     if(vis[i] || i==p)\\n     continue; \\n     if(i%2==0)\\n     even.add(i);\\n     else\\n     odd.add(i);   \\n    }", "class Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }", "class Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n    TreeSet<Integer> even = new TreeSet(); \\n    TreeSet<Integer> odd = new TreeSet();\\n    int ans[] = new int[n];\\n    Arrays.fill(ans, -1);\\n    boolean vis[] = new boolean[n];\\n    for(int x : banned)\\n    vis[x] = true; \\n    for(int i=0; i<n; i++)\\n    {\\n     if(vis[i] || i==p)\\n     continue; \\n     if(i%2==0)\\n     even.add(i);\\n     else\\n     odd.add(i);   \\n    }"]}
{"id": "2238", "ref_java": ["class Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(m == 1 && n == 1)\\n            return 1;\\n        \\n        int[][] visited = new int[m][n];\\n        queue.add(new int[]{0, 0}", "class Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(m == 1 && n == 1)\\n            return 1;\\n        \\n        int[][] visited = new int[m][n];\\n        queue.add(new int[]{0, 0}", "class Solution {\\n    public int minimumVisitedCells(int[][] grid) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(m == 1 && n == 1)\\n            return 1;\\n        \\n        int[][] visited = new int[m][n];\\n        queue.add(new int[]{0, 0}"]}
{"id": "2241", "ref_java": ["class Solution {\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n        ", "class Solution {\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    int[] freq;\\n    int[] price;\\n    int[][] dp;\\n    \\n\\t", "class Solution {\\n     int con[] ;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> al[] = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n        }"]}
{"id": "2243", "ref_java": ["class Solution {\\n    int[] seg;\\n    void build(int index,int start,int end){\\n        if(start==end){\\n            seg[index] = 1;\\n            return;\\n        }", "class Solution {\\npublic long countOperationsToEmptyArray(int[] nums) {\\n        ", "class Solution {\\npublic long countOperationsToEmptyArray(int[] nums) {\\n        "]}
{"id": "2244", "ref_java": ["class Solution {\\n    public String smallestBeautifulString(String s, int k) {\\n      int n=s.length();\\n      char arr[]=s.toCharArray();\\n      arr[n-1]++;\\n      for(int i=n-1;i<n;)\\n      {\\n          if(arr[i]==\\'a\\'+k)\\n          {\\n              arr[i--]=\\'a\\';\\n              if(i<0)return \"\";\\n              arr[i]++;\\n          }", "class Solution {\\n    private static char next(char ch) {\\n        return (char) (ch + 1);\\n    }", "class Solution {\\n    private static char next(char ch) {\\n        return (char) (ch + 1);\\n    }"]}
{"id": "2245", "ref_java": ["class Solution {\\n    public int sumOfPower(int[] nums) {\\n       ArrayList<Long >arr=new ArrayList<>();\\n            for(int i:nums)      \\n            {\\n                 arr.add((long)i);   \\n            }", "class Solution {\\n    const int M = 1000000007;\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }", "class Solution {\\n    public int sumOfPower(int[] nums) {\\n        long res = 0, s = 0, base = 1000000007;\\n        Arrays.sort(nums);\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }"]}
{"id": "2246", "ref_java": ["class Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        Map<Integer, Integer>[] adjs = new Map[n];\\n        for (int i = 0; i < n; i++) {\\n            adjs[i] = new HashMap<>();\\n        }", "class Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\t", "class Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        int adj[][] = new int[n][n];\\n        for(int i [] :edges){\\n            int a = i[0];\\n            int b = i[1];\\n            int w = i[2];\\n            adj[a][b] = w;\\n            adj[b][a] = w;\\n        }"]}
{"id": "2247", "ref_java": ["class Solution {\\n    int getf(vector<int> &f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }", "class Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        if (nums.length == 1) return true;\\n\\n        Map<Integer, Integer> dsu = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            ", "class Solution {\\n    int limit=100001;\\n    public int findp(int[]par,int i){\\n        if(par[i]==i) return i;\\n        return par[i]=findp(par,par[i]);\\n    }"]}
{"id": "2248", "ref_java": ["class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        final int m = mat.length, n = mat[0].length;\\n        int[] r = new int[m], c = new int[n];\\n        Map<Integer, List<int[]>> vmap = new HashMap<>();\\n        int[][] temp = new int[m][n];\\n        Set<Integer> s = new TreeSet<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap.computeIfAbsent(-mat[i][j], k->new ArrayList<>()).add(new int[]{i,j}", "class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        final int m = mat.length, n = mat[0].length;\\n        int[] r = new int[m], c = new int[n];\\n        Map<Integer, List<int[]>> vmap = new HashMap<>();\\n        int[][] temp = new int[m][n];\\n        Set<Integer> s = new TreeSet<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap.computeIfAbsent(-mat[i][j], k->new ArrayList<>()).add(new int[]{i,j}", "class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n                      int[][] dp = new int[m][n];\\n        int maxCells = 1; \\n        \\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                      int cells = dfs(mat, dp, i, j, m, n);\\n                   maxCells = Math.max(maxCells, cells);\\n            }"]}
{"id": "2249", "ref_java": ["class Solution {\\n    Integer dp[][][];\\n    int mod=1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        dp=new Integer[num1.length()][max_sum+1][2];\\n        int v1=f(0, num1, false, 0, max_sum, min_sum);\\n        dp=new Integer[num2.length()][max_sum+1][2];\\n        int v2=f(0, num2, false, 0, max_sum, min_sum);\\n\\n        int sum=0; \\n        for(char ch: num1.toCharArray()) sum+=ch-\\'0\\';\\n        if(sum>=min_sum && sum<=max_sum) v1--;\\n\\n        return (int)(((long)v2+mod-v1)%mod);\\n    }", "class Solution {\\n    const int M = 1000000007;\\n    \\n    void add(int &x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }", "class Solution {\\n    String s;\\n    int min;\\n    int max;\\n    int mod = 1000000007;\\n    public int count(String num1, String num2, int min_sum, int max_sum) {\\n        min = min_sum;\\n        max = max_sum;\\n        int sum = 0;\\n        for(char ch : num1.toCharArray()) sum += ch-\\'0\\';\\n\\n        s = num1;\\n        int ans1= f(0,true, 0);\\n        s = num2;\\n        int ans2= f(0,true, 0);\\n        if(sum >= min_sum && sum <= max_sum){\\n            return (ans2- ans1+mod)%mod +1;\\n        }"]}
{"id": "2250", "ref_java": ["class Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            boolean allZero = true;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) {\\n                    allZero = false;\\n                    break;\\n                }", "class Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for(int i=0;i<n;i++) {\\n            boolean found = true;\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) found = false;\\n            }", "class Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for(int i=0;i<n;i++) {\\n            boolean found = true;\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) found = false;\\n            }"]}
{"id": "2251", "ref_java": ["class Solution {\\n    public int[] maximumSumQueries(int[] a1, int[] a2, int[][] queries) {\\n        int n = a1.length;\\n        int a[][] = new int[n][2];\\n        for(int i = 0; i < n; i++){\\n            a[i][0] = a1[i];\\n            a[i][1] = a2[i];\\n        }", "class Solution {\\n    public int[] maximumSumQueries(int[] a1, int[] a2, int[][] queries) {\\n        int n = a1.length;\\n        int a[][] = new int[n][2];\\n        for(int i = 0; i < n; i++){\\n            a[i][0] = a1[i];\\n            a[i][1] = a2[i];\\n        }", "class Solution {\\n    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\\n        int q2[][] = new int[queries.length][3], ans[] = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            q2[i][0] = queries[i][0];\\n            q2[i][1] = queries[i][1];\\n            q2[i][2] = i;\\n        }"]}
{"id": "2252", "ref_java": ["class Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        return paintWalls(cost,time,0,cost.length-1);\\n    }", "class Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, (int) 1e9);\\n        dp[0] = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = n; j > 0; --j) {\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n            }", "class Solution {\\n\\n    "]}
{"id": "2253", "ref_java": ["class Solution {\\n    class Pair{\\n        int p;\\n        int h;\\n        char d;\\n        int idx;\\n        Pair(int p,int h,char d,int i){\\n            this.p=p;\\n            this.h=h;\\n            this.d=d;\\n            this.idx=i;\\n        }", "class Solution {\\n    class Pair{\\n        int p;\\n        int h;\\n        char d;\\n        int idx;\\n        Pair(int p,int h,char d,int i){\\n            this.p=p;\\n            this.h=h;\\n            this.d=d;\\n            this.idx=i;\\n        }", "class Solution {\\n    class Pair{\\n        int p;\\n        int h;\\n        char d;\\n        int idx;\\n        Pair(int p,int h,char d,int i){\\n            this.p=p;\\n            this.h=h;\\n            this.d=d;\\n            this.idx=i;\\n        }"]}
{"id": "2254", "ref_java": ["class Solution {\\n    public int sumImbalanceNumbers(int[] nums) {        \\n        int n = nums.length;        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n - 1; i++){            \\n            int arr[] = new int[1005];            \\n            arr[nums[i]] = 1;            \\n            int temp = 0;\\n            \\n            for(int j = i + 1; j < n; j++){                \\n                int val = nums[j];                        \\n                if(arr[val] == 1) {                    \\n                    count += temp;\\n                }", "class Solution {\\n    public int sumImbalanceNumbers(int[] nums) {\\n        int n = nums.length;\\n\\n        int res = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            TreeSet<Integer> subarray = new TreeSet<>();\\n            int imbalance = 0;\\n            for (int j = i; j < n; ++j) {\\n                Integer floor = subarray.floor(nums[j]);\\n                Integer ceiling = subarray.ceiling(nums[j]);\\n                if (floor != null && nums[j] - floor > 1) {\\n                    ++imbalance;\\n                }", "class Solution {\\n    public int sumImbalanceNumbers(int[] nums) {\\n        int n = nums.length;\\n\\n        int res = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            TreeSet<Integer> subarray = new TreeSet<>();\\n            int imbalance = 0;\\n            for (int j = i; j < n; ++j) {\\n                Integer floor = subarray.floor(nums[j]);\\n                Integer ceiling = subarray.ceiling(nums[j]);\\n                if (floor != null && nums[j] - floor > 1) {\\n                    ++imbalance;\\n                }"]}
{"id": "2255", "ref_java": ["class Solution {\\n    public int longestValidSubstring(String word, List<String> forbidden) {\\n        Set<String> set = new HashSet<>();\\n        int max = 0;\\n        for(String s : forbidden){\\n            max = Math.max(max , s.length());\\n            set.add(s);\\n        }", "class Solution {\\n    public int longestValidSubstring(String word, List<String> forbidden) {\\n        Set<String> set = new HashSet<>();\\n        int max = 0;\\n        for(String s : forbidden){\\n            max = Math.max(max , s.length());\\n            set.add(s);\\n        }", "class Solution {\\n    public int longestValidSubstring(String word, List<String> forbidden) {\\n           int len = 0;\\n        Set<String> all = new HashSet<>();\\n        for (String s : forbidden) {\\n            all.add(s);\\n            len = Math.max(len, s.length());\\n        }"]}
{"id": "2256", "ref_java": ["class Solution {\\n    public int maxIncreasingGroups(List<Integer> usageLimits) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        pq.addAll(usageLimits);\\n        int k = 1;\\n        while(k < pq.size()) {\\n            List<Integer> curr = new ArrayList<>();\\n            int i = k;\\n            while(i > 0) {\\n                i--;\\n                int top = pq.poll();\\n                if(--top > 0) {\\n                    curr.add(top);\\n                }", "class Solution {\\n  public int maxIncreasingGroups(List<Integer> usageLimits) {\\n        int n = usageLimits.size();\\n        long a[] = new long[usageLimits.size() + 1];\\n        int l = 1;\\n        Collections.sort(usageLimits, Collections.reverseOrder());\\n        int max = usageLimits.size();\\n        int min = 1;\\n        int ans = 1;\\n        while (max >= min) {\\n            int mid = (max + min) / 2;\\n            if (can(mid, usageLimits)) {\\n                min = mid + 1;\\n                ans = mid;\\n            }", "class Solution {\\n    public int maxIncreasingGroups(List<Integer> usageLimits) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        pq.addAll(usageLimits);\\n        int k = 1;\\n        while(k < pq.size()) {\\n            List<Integer> curr = new ArrayList<>();\\n            int i = k;\\n            while(i > 0) {\\n                i--;\\n                int top = pq.poll();\\n                if(--top > 0) {\\n                    curr.add(top);\\n                }"]}
{"id": "2257", "ref_java": ["class Solution {\\n    long long dfs(int x, int mask, const string &s, const vector<vector<int>>& con, unordered_map<int, int>& have) {\\n        long long r = 0;\\n        if (x) {\\n            mask ^= 1 << (s[x] - \\'a\\');\\n            for (int i = 1 << 25; i; i >>= 1) {\\n                if (have.count(mask ^ i)) {\\n                    r += have[mask ^ i];\\n                }", "class Solution {\\n    \\n    List<int []> [] graph;\\n    \\n    int [] nodeVals;\\n    \\n    Map<Integer, Integer> map;\\n    \\n    public long countPalindromePaths(List<Integer> parent, String s) {\\n        int n = parent.size();\\n        \\n        graph = new List[n];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            graph[i] = new ArrayList<>();\\n        }", "class Solution {\\n    \\n    List<int []> [] graph;\\n    \\n    int [] nodeVals;\\n    \\n    Map<Integer, Integer> map;\\n    \\n    public long countPalindromePaths(List<Integer> parent, String s) {\\n        int n = parent.size();\\n        \\n        graph = new List[n];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            graph[i] = new ArrayList<>();\\n        }"]}
{"id": "2258", "ref_java": ["class Solution {\\n\\tprivate int mod = 1000000007;\\n    ", "class Solution {\\n\\n    final static int MOD = (int)(1e9 + 7);\\n    Integer[][][][] dp;\\n    public int countSteppingNumbers(String low, String high) {\\n        dp = new Integer[low.length() + 1][10][2][2];\\n        int count1 = solve(low, 0, 0, 1, 1);\\n        dp = new Integer[high.length() + 1][10][2][2];\\n        int count2 = solve(high, 0, 0, 1, 1);\\n        int res = (count2 - count1 + isStep(low) + MOD) % MOD;\\n        return res;\\n    }", "class Solution {\\n\\n    final static int MOD = (int)(1e9 + 7);\\n    Integer[][][][] dp;\\n    public int countSteppingNumbers(String low, String high) {\\n        dp = new Integer[low.length() + 1][10][2][2];\\n        int count1 = solve(low, 0, 0, 1, 1);\\n        dp = new Integer[high.length() + 1][10][2][2];\\n        int count2 = solve(high, 0, 0, 1, 1);\\n        int res = (count2 - count1 + isStep(low) + MOD) % MOD;\\n        return res;\\n    }"]}
{"id": "2259", "ref_java": ["class Solution {\\n    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\\n        int n = nums1.size();\\n        Integer[] ind = new Integer[n]; ", "class Solution {\\n    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\\n        int n = nums1.size();\\n        Integer[] ind = new Integer[n]; ", "class Solution {\\n    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\\n        int n = nums1.size();\\n        Integer[] ind = new Integer[n]; "]}
{"id": "2260", "ref_java": ["class Solution {\\n    public long findMaximumElegance(int[][] items, int k) {\\n        Arrays.sort(items, (a,b)-> b[0]-a[0]);\\n        Stack<Integer> duplicates=new Stack<>();\\n        HashSet<Integer> selected_cats=new HashSet<>(k);\\n\\n        long total_profit=0, elegance=0, size;\\n        for(int i=0;i<items.length;i++) {\\n            if(i<k){\\n                total_profit+=items[i][0];\\n                if(selected_cats.contains(items[i][1])) duplicates.add(items[i][0]);\\n            }", "class Solution {\\n    long long sqr(long long x) {\\n        return x * x;\\n    }", "class Solution {\\n    public long findMaximumElegance(int[][] items, int k) {\\n        Arrays.sort(items, (a,b)-> b[0]-a[0]);\\n        Stack<Integer> duplicates=new Stack<>();\\n        HashSet<Integer> selected_cats=new HashSet<>(k);\\n\\n        long total_profit=0, elegance=0, size;\\n        for(int i=0;i<items.length;i++) {\\n            if(i<k){\\n                total_profit+=items[i][0];\\n                if(selected_cats.contains(items[i][1])) duplicates.add(items[i][0]);\\n            }"]}
{"id": "2261", "ref_java": ["class Solution {\\n    static int MOD = (int)1e9 + 7;\\n    class MyNum {\\n        int value;\\n        int left;\\n        int right;\\n        int idx;\\n        int score;\\n        MyNum(int v, int l, int r, int i, int s) {\\n            this.value = v;\\n            this.left = l;\\n            this.right = r;\\n            this.idx = i;\\n            this.score = s;\\n        }", "class Solution {\\n    public int countDistinctPrimeFactors(int N) {\\n        if (N < 2) {\\n            return 0;\\n        }", "class Solution {\\n    public int maximumScore(List<Integer> nums, int k) {\\n        int[] f = new int[nums.size()];\\n        for (int i = 0; i < nums.size(); i++) {\\n            f[i] = primeFactor(nums.get(i));\\n        }"]}
