{"id": "1", "ref_js": ["var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};", "var twoSum = function(nums, target) {\\n    const numToIndex = new Map(); ", "var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};"]}
{"id": "2", "ref_js": ["var isPalindrome = function(x) {\\n    \\n    if(x < 0) return false\\n\\n    if(0 <= x && x < 10 ) return true\\n\\n    let splitDigits = []\\n\\n\\twhile (x > 0) {\\n\\t\\tsplitDigits.push(x % 10)\\n\\n\\t\\tx = parseInt(x / 10)\\n\\t}\\n\\n\\tfor (let index = 0; index < Math.floor(splitDigits.length / 2); index++) {\\n\\t\\tlet lastIndex = index + 1\\n\\t\\n\\t\\tif (\\n\\t\\t\\tsplitDigits[index] - splitDigits[splitDigits.length - lastIndex] !==\\n\\t\\t\\t0\\n\\t\\t) \\n\\t\\t\\treturn false\\n\\t\\t\\t\\n\\t\\t\\n        \\n\\t}\\n    return true\\n    \\n};", "var isPalindrome = function(x) {\\n    var reverse = 0;\\n    var copy = x;\\n\\n    ", "var isPalindrome = function(x) {\\n    var s = x.toString();\\n    var t = s.split(\"\").reverse().join(\"\");\\n    return s === t;\\n};"]}
{"id": "3", "ref_js": ["var romanToInt = function(s) {\\n      const sym = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const cur = sym[s[i]];\\n        const next = sym[s[i + 1]];\\n\\n        if (cur < next) {\\n            result += next - cur;\\n            i++;\\n        } else {\\n            result += cur;\\n        }\\n    }\\n\\n    return result;\\n};", "var romanToInt = function(s) {\\n    const romanValues = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    };", "var romanToInt = function(s) {\\n      const sym = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const cur = sym[s[i]];\\n        const next = sym[s[i + 1]];\\n\\n        if (cur < next) {\\n            result += next - cur;\\n            i++;\\n        } else {\\n            result += cur;\\n        }\\n    }\\n\\n    return result;\\n};"]}
{"id": "4", "ref_js": ["var longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};", "var longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};", "var longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};"]}
{"id": "5", "ref_js": ["var isValid = function(s) {\\n    let stack = []; ", "var isValid = function(s) {\\n    ", "var isValid = function(s) {\\n    \\n    "]}
{"id": "6", "ref_js": ["var mergeTwoLists = function(list1, list2) {\\n\\n    if(!list1 || !list2) return list1 || list2\\n    if(list1.val<list2.val){\\n        return new ListNode(list1.val,mergeTwoLists(list1.next,list2))\\n    }\\n    return new ListNode(list2.val,mergeTwoLists(list1,list2.next))\\n    \\n   \\n};", "var mergeTwoLists = function (l1, l2) {\\n    if (!l1) return l2;\\n    else if (!l2) return l1;\\n    else if (l1.val <= l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2\\n    }\\n};", "var mergeTwoLists = function(list1, list2) {\\n    "]}
{"id": "7", "ref_js": ["var longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};", "var longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};", "var longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};"]}
{"id": "8", "ref_js": ["var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};", "var twoSum = function(nums, target) {\\n    const numToIndex = new Map(); ", "var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};"]}
{"id": "9", "ref_js": ["var strStr = function (haystack, needle) {\\n  function findFrom(i) {\\n    if (haystack[i] === undefined) return -1;\\n    if (haystack[i] === needle[0]) {\\n      const initial = i;\\n      i++;\\n      let next = -1; ", "var strStr = function (haystack, needle) {\\n    return haystack.indexOf(needle);\\n};", "var strStr = function(haystack, needle) {\\n    \\n\\n    for(let i=0;i<=haystack.length-needle.length;i++){\\n        let str=\"\"\\n       for(let j=i;j<i+needle.length;j++){\\n            str+=haystack[j]\\n        }\\n        if(str==needle){\\n            return i\\n        }\\n\\n    }\\n    return -1\\n  \\n};"]}
{"id": "10", "ref_js": ["var searchInsert = function(nums, target) {\\n    function mergeSort(arr,target,left,right){\\n        if(left>right){\\n             return left\\n        }\\n        const mid=Math.floor((left+right)/2)\\n        if(arr[mid]==target) return mid\\n        else if(arr[mid]<target){\\n            return mergeSort(arr,target,mid+1,right)\\n        }else{\\n            return mergeSort(arr,target,left,mid-1)\\n        }\\n    }\\n\\n    return mergeSort(nums,target,0,nums.length-1)\\n};", "var searchInsert = function(nums, target) {\\n     let leftPosition = 0;\\n  let rightPosiition = nums.length - 1;\\n  let middle = Math.floor((leftPosition + rightPosiition) / 2);\\n  let insertedPosition = 0;\\n\\n  while (leftPosition <= rightPosiition) {\\n    if (target < nums[middle]) {\\n      insertedPosition = middle;\\n      rightPosiition = middle - 1;\\n    } else if (target > nums[middle]) {\\n      insertedPosition = middle + 1;\\n\\n      leftPosition = middle + 1;\\n    } else if (target === nums[middle]) {\\n      return middle;\\n    }\\n    middle = Math.floor((leftPosition + rightPosiition) / 2);\\n  }\\n  if (nums[middle] === target) {\\n    return middle;\\n  } else {\\n    return insertedPosition;\\n  }\\n    \\n};", "var searchInsert = function(nums, target) {\\n    function mergeSort(arr,target,left,right){\\n        if(left>right){\\n             return left\\n        }\\n        const mid=Math.floor((left+right)/2)\\n        if(arr[mid]==target) return mid\\n        else if(arr[mid]<target){\\n            return mergeSort(arr,target,mid+1,right)\\n        }else{\\n            return mergeSort(arr,target,left,mid-1)\\n        }\\n    }\\n\\n    return mergeSort(nums,target,0,nums.length-1)\\n};"]}
{"id": "11", "ref_js": ["var lengthOfLastWord = function (s) {\\n  return s.trimEnd().split(\\' \\').pop().length\\n};", "var lengthOfLastWord = function(s) {\\n    let trimmedString = s.trim();\\n    \\n    return trimmedString.length - trimmedString.lastIndexOf(\\' \\') - 1;\\n};", "var lengthOfLastWord = function(s) {\\n    var cnt = 0;\\n\\n    for(var i = s.length-1;i>=0;i--)\\n    {\\n        if(s[i]==\\' \\')\\n        {\\n            if(cnt>0)\\n            {\\n                return cnt;    \\n            }\\n            continue;\\n        }\\n\\n        cnt+=1;\\n    }\\n    return cnt;\\n};"]}
{"id": "12", "ref_js": ["var plusOne = function(digits) {\\n    let rem = 1;\\n    for(let i=digits.length-1; i>=0; i--) {\\n        let temp = (digits[i] + rem);\\n        digits[i] = temp % 10;\\n        rem = Math.floor(temp / 10);\\n    }\\n    return (rem==0) ? digits : [rem].concat(digits); \\n};", "var plusOne = function(digits) {\\n    let n = digits.length;\\n    for(let i = n-1; i >= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++;\\n            return digits;\\n        } else {\\n            digits[i] = 0;\\n        } \\n    }\\n    console.log(\"before unshift\", digits);\\n    digits.unshift(1);\\n    console.log(\"after unshift\", digits);\\n    return digits;\\n};", "var plusOne = function(digits) {\\n    var strFromInt = \"\"; var intFromStr; \\n    for(let i = 0; i < digits.length; i++) {\\n        strFromInt += digits[i].toString();\\n\\n        "]}
{"id": "13", "ref_js": ["var addBinary = function(a, b) {\\n    ", "var addBinary = function(a, b) {\\n    let l1 = a.length;\\n    let l2 = b.length;\\n    if (a.length > b.length) {\\n        let diff = a.length - b.length;\\n        for (let i = 0; i < diff; i++) {\\n            b = \"0\" + b;\\n        }\\n    }\\n    if (a.length < b.length) {\\n        let diff = b.length - a.length;\\n        for (let i = 0; i < diff; i++) {\\n            a = \"0\" + a;\\n        }\\n    }\\n    let carry = 0;\\n    let ans = \"\";\\n    for (let i = a.length - 1; i >= 0; i--) {\\n        if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        }\\n    }\\n    if (carry === 1) {\\n        ans = \"1\" + ans;\\n    }\\n    return ans; \\n};", "var addBinary = function(a, b) {\\n  const aBin = `0b${a}`\\n  const bBin = `0b${b}`\\n  const sum = BigInt(aBin) + BigInt(bBin)\\n  return sum.toString(2)\\n};"]}
{"id": "14", "ref_js": ["var mySqrt = function(x) {\\n    if(x<2) return x\\n    let left=0,right=x/2\\n    while(left<=right){\\n        const mid=Math.floor((left+right)/2)\\n        if(mid*mid<=x && x<(mid+1)*(mid+1)){\\n            return mid\\n        }else if((mid*mid)>x){\\n            right=mid-1\\n        }else{\\n            left=mid+1\\n        }\\n    }\\n    return -1\\n};", "var mySqrt = function(x) {\\n    return Math.floor(x**(1/2));\\n};", "var mySqrt = function(x) {\\n    var beg = 0, end = x, ans = 0;\\n    \\n    while(beg <= end) {\\n        var mid = Math.floor((beg + end)/2);\\n        \\n        if(mid*mid > x) {\\n            end = mid - 1;\\n        }\\n         \\n        else { "]}
{"id": "15", "ref_js": ["var climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};", "var climbStairs = function(n) {\\n        let arr = [1, 1];\\n        for(let i=2; i<=n; i++) {\\n            arr.push(arr[i-1] + arr[i-2]);\\n        }\\n        return arr[n];\\n};", "var climbStairs = function(n) {\\n    let q = n/2;\\n    let count = 0;\\n\\n    while (q <= n){\\n        let combN = q\\n        let combR = n-q\\n\\n        count += calculate_nCr(combN, combR)\\n\\n        q += 1;\\n    }\\n\\n    return count;\\n};"]}
{"id": "16", "ref_js": ["var deleteDuplicates = function(head) {\\n    let cur=head\\n    while(cur && cur.next){\\n        if(cur.val==cur.next.val){\\n            cur.next=cur.next.next\\n        }else{\\n            cur=cur.next\\n        }\\n    }\\n    return head\\n};", "var deleteDuplicates = function(head) {\\n    ", "var deleteDuplicates = function(head) {\\n\\n    var temp = head;\\n\\n    while(temp !== null){\\n\\n        if((temp.next !== null) && temp.val === temp.next.val){\\n            var next_next = temp.next.next;\\n            var nodeToDelete = temp.next;\\n            temp.next = next_next;\\n            delete(nodeToDelete);\\n        }else{\\n            temp = temp.next;\\n        } \\n    }\\n    return head;\\n    \\n};"]}
{"id": "17", "ref_js": ["var merge = function(nums1, m, nums2, n) {\\n    for (let i = m, j = 0; j < n; i++, j++) {\\n        nums1[i] = nums2[j];\\n    }\\n    nums1.sort((a, b) => a - b);\\n};", "var merge = function(nums1, m, nums2, n) {\\n    ", "var merge = function(nums1, m, nums2, n) {\\n  let i = m-1; "]}
{"id": "18", "ref_js": ["var inorderTraversal = function(root) {\\n    const result = [];\\n    helper(root, result);\\n    return result;\\n};", "var inorderTraversal = function(root) {\\n    const res = [];\\n\\n    function inorder(node) {\\n        if (!node) {\\n            return;\\n        }\\n        inorder(node.left);\\n        res.push(node.val);\\n        inorder(node.right);\\n    }\\n\\n    inorder(root);\\n    return res;    \\n};", "var inorderTraversal = function(root) {\\n    const ans = [];\\n    const inorder = (node) => {\\n        if (node) {\\n            inorder(node.left);\\n            ans.push(node.val);\\n            inorder(node.right);\\n        }\\n    };"]}
{"id": "19", "ref_js": ["var isSameTree = function(p, q) {\\n    ", "var isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};", "var isSameTree = function(p, q) {\\n    "]}
{"id": "20", "ref_js": ["var isSymmetric = function(root) {\\n    ", "var isSymmetric = function (root) {\\n    if (root == null) return true;\\n    return isMirror(root.left, root.right);\\n\\n    function isMirror(leftNode, rightNode) {\\n        if (leftNode == null && rightNode == null) return true;\\n        if (leftNode == null || rightNode == null) return false;\\n        return leftNode.val === rightNode.val &&\\n            isMirror(leftNode.left, rightNode.right) &&\\n            isMirror(leftNode.right, rightNode.left);\\n    }\\n};", "var isSymmetric = function(root) {\\n    \\n    let answer = true;\\n    function traverse(root1,root2){\\n\\n        if(root1 && root2) {\\n            if(root1.val !== root2.val){\\n                answer = false;\\n                return false;\\n            }\\n            traverse(root1.left,root2.right)\\n            traverse(root1.right,root2.left)\\n        }\\n        if(root1 && !root2) {\\n            answer = false;\\n            return false\\n        }\\n        if(!root1 && root2) {\\n            answer = false;\\n            return false;\\n        }\\n\\n    }\\n\\n    traverse(root.left,root.right)\\n    return answer;\\n\\n};"]}
{"id": "21", "ref_js": ["var maxDepth = function(root) {\\n    ", "var maxDepth = function(root) {\\n        if(root === undefined || root===null){\\n            return 0;\\n        }\\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\\n    };", "var maxDepth = function(root) {\\n        if(root === undefined || root===null){\\n            return 0;\\n        }\\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\\n    };"]}
{"id": "22", "ref_js": ["var sortedArrayToBST = function(nums) {\\n    ", "var sortedArrayToBST = function(nums) {\\n    if(!nums.length) return null;\\n    let mid = Math.floor(nums.length/2);\\n    let node = new TreeNode(nums[mid]);\\n    node.left = sortedArrayToBST(nums.slice(0,mid));\\n    node.right = sortedArrayToBST(nums.slice(mid+1));\\n    return node;\\n};", "var sortedArrayToBST = function(nums) {\\n    "]}
{"id": "23", "ref_js": ["var isBalanced = function(root) {\\n    ", "var isBalanced = function(root) {\\n\\n    ", "var isBalanced = function(root) {\\n    \\n    function height(root) {\\n        \\n        if(root == null) return 0\\n        \\n        return 1+Math.max(height(root.left), height(root.right));\\n    }\\n    \\n    if(root == null) \\n        return true;\\n    \\n    let leftH = height(root.left);\\n    let rightH = height(root.right);\\n    \\n    return Math.abs(leftH - rightH) <= 1 && isBalanced(root.left) == true && isBalanced(root.right) == true;\\n};"]}
{"id": "24", "ref_js": ["var minDepth = function(root) {\\n    ", "var minDepth = function(root) {\\n  \\n  if (root === null) {\\n    return 0;\\n  }\\n\\n  if (root.left === null && root.right === null) {\\n    return 1;\\n  }\\n\\n  if (root.left === null) {\\n    return minDepth(root.right) + 1;\\n  }\\n\\n  if (root.right === null) {\\n    return minDepth(root.left) + 1;\\n  }\\n\\n  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;  \\n};", "var minDepth = function(root) {\\n    if (!root) return 0\\n\\n    const stack =  [[root, 1]]\\n    let minDepth = Infinity\\n\\n    while(stack.length){\\n        const [node, depth] = stack.pop()\\n        if (depth >= minDepth) continue\\n        if (!node.left && !node.right )minDepth = depth\\n        if (node.left) stack.push([node.left, depth + 1])\\n        if (node.right) stack.push([node.right, depth + 1])\\n    }\\n    return minDepth\\n};"]}
{"id": "25", "ref_js": ["var hasPathSum = function(root, targetSum) {\\n    if (root == null) {\\n        return false;\\n    }\\n\\n    ", "var hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};", "var hasPathSum = function(root, targetSum) {\\n    if (!root) return false "]}
{"id": "26", "ref_js": ["var generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    if (numRows === 1) {\\n        return [[1]];\\n    }\\n    \\n    let prevRows = generate(numRows - 1);\\n    let newRow = new Array(numRows).fill(1);\\n    \\n    for (let i = 1; i < numRows - 1; i++) {\\n        newRow[i] = prevRows[numRows - 2][i - 1] + prevRows[numRows - 2][i];\\n    }\\n    \\n    prevRows.push(newRow);\\n    return prevRows;\\n};", "var generate = function(numRows) {\\n    arr = []; \\n    for(let i=1; i<=numRows; i++) {\\n        arr.push(new Array(i).fill(0));\\n    }\\n    arr[0][0] = 1;\\n    for(let i=0; i<numRows-1; i++) {\\n        for(let j=0; j<=i; j++) {\\n            arr[i+1][j] = arr[i+1][j] + arr[i][j];\\n            arr[i+1][j+1] = arr[i+1][j+1] + arr[i][j];\\n        }\\n    }\\n    return arr;\\n};", "var generate = function(numRows) {\\n    let triangle = [];\\n    if (numRows === 0) return triangle;\\n\\n    triangle.push([1]);\\n\\n    for (let i = 1; i < numRows; i++) {\\n        let prevRow = triangle[i - 1];\\n        let newRow = [1];\\n\\n        for (let j = 1; j < prevRow.length; j++) {\\n            newRow.push(prevRow[j - 1] + prevRow[j]);\\n        }\\n\\n        newRow.push(1);\\n        triangle.push(newRow);\\n    }\\n\\n    return triangle;\\n};"]}
{"id": "27", "ref_js": ["var ncr= function(n, r, dp) {\\n        if (r === 0 || r === n) return 1;\\n        if (r === 1 || r === n - 1) return n;\\n        if (dp[n][r] !== -1) return dp[n][r];\\n        dp[n][r] =  ncr(n - 1, r, dp) +  ncr(n - 1, r - 1, dp);\\n        return dp[n][r];\\n    }\\n\\n    var getRow = function(rowIndex) {\\n        const ans = [];\\n        const dp = new Array(rowIndex + 1).fill(-1).map(() => new Array(rowIndex + 1).fill(-1));\\n        for (let i = 0; i <= rowIndex; i++) {\\n            ans.push( ncr(rowIndex, i, dp));\\n        }\\n        return ans;\\n    }\\n```\\n\\n**C#:**\\n\\n```csharp\\npublic class Solution {\\n    public int Ncr(int n, int r, int[][] dp) {\\n        if (r == 0 || r == n) return 1;\\n        if (r == 1 || r == n - 1) return n;\\n        if (dp[n][r] != -1) return dp[n][r];\\n        dp[n][r] = Ncr(n - 1, r, dp) + Ncr(n - 1, r - 1, dp);\\n        return dp[n][r];\\n    }\\n\\n    public int[] GetRow(int rowIndex) {\\n        int[] ans = new int[rowIndex + 1];\\n        int[][] dp = new int[rowIndex + 1][];\\n        for (int i = 0; i <= rowIndex; i++) {\\n            dp[i] = new int[rowIndex + 1];\\n            for (int j = 0; j <= rowIndex; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        for (int i = 0; i <= rowIndex; i++) {\\n            ans[i] = Ncr(rowIndex, i, dp);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Ruby:**\\n\\n```ruby []\\n\\n    def ncr(n, r, dp)\\n        return 1 if r == 0 || r == n\\n        return n if r == 1 || r == n - 1\\n        return dp[n][r] if dp[n][r] != -1\\n\\n        dp[n][r] = ncr(n - 1, r, dp) + ncr(n - 1, r - 1, dp)\\n        dp[n][r]\\n    end\\n\\n    def get_row(row_index)\\n        ans = []\\n        dp = Array.new(row_index + 1) { Array.new(row_index + 1, -1) }\\n        (0..row_index).each do |i|\\n            ans << ncr(row_index, i, dp)\\n        end\\n        ans\\n    end\\n```\\n\\n---\\n**Approach 2 : Efficiently Generating Pascal\\'s Triangle**\\n\\n\\n\\n**Understanding Pascal\\'s Triangle:**\\n\\nBefore delving into the details of Approach 2, let\\'s briefly recap Pascal\\'s Triangle. It starts with a 1 at the apex and then continues with rows of numbers. The first few rows look like this:\\n\\n```\\n       1\\n      1 1\\n     1 2 1\\n    1 3 3 1\\n   1 4 6 4 1\\n```\\n\\nEach number in the triangle is the sum of the two numbers directly above it. For example, in the fourth row, the middle number \\'3\\' is the sum of \\'1\\' and \\'2\\' from the row above it.\\n\\n## **Approach 2: Efficient Row Generation**\\n\\nIn Approach 2, we will use an efficient algorithm to generate the k-th row of Pascal\\'s Triangle. The key idea behind this approach is to maintain a single array, `A`, of size `k+1`, where each element of the array represents a number in the k-th row.\\n\\nHere\\'s a step-by-step breakdown of Approach 2:\\n\\n1. Initialize an array `A` of size `k+1` and set the first element, `A[0]`, to 1. This is because the first element of every row in Pascal\\'s Triangle is always 1.\\n\\n2. Use a nested loop to iterate through the remaining elements of `A`. The outer loop runs from `i = 1` to `k`, representing each row, and the inner loop starts from the current value of `i` and goes down to `1`.\\n\\n3. In each iteration of the inner loop, update the `j`-th element of `A` by adding the values of `A[j]` and `A[j-1]`. This step follows the fundamental property of Pascal\\'s Triangle, where each number is the sum of the two numbers directly above it.\\n\\n4. After completing the loops, the array `A` contains the k-th row of Pascal\\'s Triangle.\\n\\nCertainly, let\\'s analyze the time and space complexity of the given code.\\n\\n**Time Complexity:**\\nThe time complexity of this code can be analyzed as follows:\\n\\n1. The code uses two nested loops. The outer loop runs from `i = 1` to `rowIndex`, and the inner loop runs from `j = i` to `1`. \\n\\n2. In each iteration of the inner loop, there is a constant-time operation, which is adding `A[j-1]` to `A[j]`.\\n\\n3. The number of iterations in the inner loop decreases with each iteration of the outer loop. In the first outer loop iteration, the inner loop runs `i` times. In the second iteration, it runs `i-1` times, and so on.\\n\\n4. Therefore, the total number of operations can be computed as the sum of the first `rowIndex` natural numbers, which is O(rowIndex^2).\\n\\n5. In summary, the time complexity of this code is O(rowIndex^2) due to the nested loops.\\n\\n**Space Complexity:**\\nThe space complexity of this code is determined by the auxiliary space used for the `A` vector, which stores the result.\\n\\n1. The `A` vector is of size `rowIndex + 1`, so it requires O(rowIndex) space.\\n\\n2. The space required for variables like `i`, `j`, and other constants is negligible and does not contribute significantly to the space complexity.\\n\\n3. Therefore, the overall space complexity of the code is O(rowIndex).\\n\\n\\n\\n```cpp []\\nvector<int> getRow(int rowIndex) {\\n    vector<int> A(rowIndex+1, 0);\\n    A[0] = 1;\\n    for(int i=1; i<rowIndex+1; i++)\\n        for(int j=i; j>=1; j--)\\n            A[j] += A[j-1];\\n    return A;\\n}\\n```\\n\\n\\n```java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> A = new ArrayList<>(rowIndex + 1);\\n        A.add(1);\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = i; j >= 1; j--) {\\n                if (j == A.size()) {\\n                    A.add(A.get(j - 1));\\n                } else {\\n                    A.set(j, A.get(j) + A.get(j - 1));\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```\\n\\n\\n```python []\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        A = [0] * (rowIndex + 1)\\n        A[0] = 1\\n        for i in range(1, rowIndex + 1):\\n            for j in range(i, 0, -1):\\n                A[j] += A[j - 1]\\n        return A\\n```\\n\\n```javascript []\\nvar getRow = function(rowIndex) {\\n    let A = new Array(rowIndex + 1).fill(0);\\n    A[0] = 1;\\n    for (let i = 1; i <= rowIndex; i++) {\\n        for (let j = i; j >= 1; j--) {\\n            A[j] += A[j - 1];\\n        }\\n    }\\n    return A;\\n};", "var getRow = function(rowIndex) {\\n    let res = [1];\\n    let prev = 1;\\n    for(let k = 1; k <= rowIndex; k++) {\\n        let next_val = prev * (rowIndex - k + 1) / k;\\n        res.push(next_val);\\n        prev = next_val;\\n    }\\n    return res;\\n};", "var getRow = function(rowIndex) {\\n    if (rowIndex === 0) {\\n        return [1];\\n    }\\n    \\n    let row = [1];\\n    for (let i = 1; i <= rowIndex; i++) {\\n        for (let j = row.length - 1; j > 0; j--) {\\n            row[j] = row[j] + row[j - 1];\\n        }\\n        row.push(1);\\n    }\\n    \\n    return row;\\n};"]}
{"id": "28", "ref_js": ["var maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};", "var maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};", "var maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};"]}
{"id": "29", "ref_js": ["var isPalindrome = function(s) {\\n    const normalized = s.toLowerCase().replace(/[^a-zA-Z0-9]/g, \\'\\');\\n    for(let i = 0; i < normalized.length; i++) {\\n        if(normalized[i] !== normalized[normalized.length - i - 1]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n};", "var isPalindrome = function(s) {\\n    let newStr = s.replace(/[^a-z0-9]/gi,\"\").toLowerCase();\\n    return newStr.split(\"\").reverse().join(\"\") === newStr ? true : false;\\n};", "var isPalindrome = function(s) {\\n    const normalized = s.toLowerCase().replace(/[^a-zA-Z0-9]/g, \\'\\');\\n    for(let i = 0; i < normalized.length; i++) {\\n        if(normalized[i] !== normalized[normalized.length - i - 1]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n};"]}
{"id": "30", "ref_js": ["var singleNumber = function(nums) {\\n    let hash = new Map();\\n    for(let i of nums) {\\n        if(hash.has(i)) {\\n            hash.delete(i);\\n        }\\n        else {\\n            hash.set(i, i);\\n        }\\n    }\\n    let res;\\n    hash.forEach (function(value, key) { res = key});\\n    return res;\\n};", "var singleNumber = function(nums) {\\n    ", "var singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); "]}
{"id": "31", "ref_js": ["var hasCycle = function(head) {\\n    let slow_pointer = head, fast_pointer = head;\\n    while (fast_pointer !== null && fast_pointer.next !== null) {\\n        slow_pointer = slow_pointer.next;\\n        fast_pointer = fast_pointer.next.next;\\n        if (slow_pointer === fast_pointer) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};", "var hasCycle = function(head) {\\n    let fast= head\\n    while(fast && fast.next){\\n        \\n        head=head.next\\n        fast=fast.next.next\\n        if(fast==head){\\n            return true\\n        } \\n    }\\n    return false\\n};", "var hasCycle = function(head) {\\n    let fast= head\\n    while(fast && fast.next){\\n        \\n        head=head.next\\n        fast=fast.next.next\\n        if(fast==head){\\n            return true\\n        } \\n    }\\n    return false\\n};"]}
{"id": "32", "ref_js": ["var preorderTraversal = function(root) {\\n    var target = []\\n    \\n    function dfs(node){\\n        if (!node){\\n            return;\\n        }\\n        target.push(node.val)\\n        dfs(node.left)\\n        dfs(node.right)\\n    }\\n    dfs(root)\\n    return target\\n};", "var preorderTraversal = function(root) {\\n    let res = [];\\n    preOrder(root, res);\\n    return res;\\n};", "var preorderTraversal = function(root) {\\n    if(!root) return [];\\n    const stack  = [root];\\n    const result = [];\\n    while(stack.length) {\\n        let current = stack.pop();\\n        result.push(current.val)\\n        if(current.right) stack.push(current.right);\\n        if(current.left) stack.push(current.left);\\n    }\\n\\n    return result;\\n};"]}
{"id": "33", "ref_js": ["var postorderTraversal = function(root) {\\n    let res = [];\\n    postOrder(root, res);\\n    return res;\\n};", "var postorderTraversal = function(root) {\\n    const result = [];\\n    postorderTraversalHelper(root, result)\\n    return result;\\n   \\n};", "var postorderTraversal = function(root) {\\n    let res = []; "]}
{"id": "34", "ref_js": ["var getIntersectionNode = function(headA, headB) {\\n    let a = headA, b = headB\\n    while (a !== b) {\\n        a = !a ? headB : a.next\\n        b = !b ? headA : b.next\\n    }\\n    return a\\n};", "var getIntersectionNode = function(headA, headB) {\\n    let set = new Set();\\n    while(headA) {\\n        set.add(headA);\\n        headA = headA.next;\\n    }\\n    while(headB) {\\n        if(set.has(headB)) return headB;\\n        headB = headB.next;\\n    }\\n    return null;\\n};", "var getIntersectionNode = function(headA, headB) {\\n\\n    let l1 = headA\\n    let l2 = headB\\n\\n    while(l1 != l2){  \\n        if(l1) l1 = l1.next \\n        else l1 = headA "]}
{"id": "35", "ref_js": ["var convertToTitle = function(columnNumber) {\\n    let result = \\'\\'\\n    while(columnNumber > 26) {\\n        let last = columnNumber % 26\\n        last == 0 ? last = 26 : 0\\n        result += String.fromCharCode(64 + last)\\n        columnNumber = (columnNumber - last) / 26\\n    }\\n    console.log(columnNumber)\\n    result += String.fromCharCode(64 + columnNumber)\\n    return result.split(\\'\\').reverse().join(\\'\\')\\n};", "var convertToTitle = function(columnNumber) {\\n    let res = \"\";\\n\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        res = String.fromCharCode((columnNumber % 26) + \"A\".charCodeAt(0)) + res;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    \\n    return res;    \\n};", "var convertToTitle = function(columnNumber) {\\n    let ans = \\'\\'\\n\\n    while(columnNumber>0){\\n        let code = (--columnNumber)%26\\n        ans = String.fromCharCode(code+65) + ans\\n        columnNumber = (columnNumber-code)/26\\n    }\\n    \\n    return ans\\n};"]}
{"id": "36", "ref_js": ["var majorityElement = function(nums) {\\n    ", "var majorityElement = function(nums) {\\n      let dict = {};", "var majorityElement = function(nums) {\\n    "]}
{"id": "37", "ref_js": ["var titleToNumber = function(columnTitle) {\\n    let result = 0;\\n    let length = columnTitle.length;\\n    for(let i = 0; i < length; i++){\\n        result += (columnTitle.charCodeAt(i) - 64) * Math.pow(26, length - (i + 1));\\n    }\\n    return result;\\n};", "var titleToNumber = function(columnTitle) {\\n   let res = 0;\\n    for(let i = 0; i<columnTitle.length; i++){\\n        res = (res * 26 ) + ((columnTitle.charCodeAt(i) - (\\'A\\').charCodeAt(0)) + 1)\\n    }\\n    return res;\\n};", "var titleToNumber = function(columnTitle) {\\n    let sum = 0;\\n    let index = 1;\\n    for(let i = columnTitle.length - 1; i >= 0; i--) {\\n        sum += index * (columnTitle[i].charCodeAt() - 64)\\n        index*= 26\\n    }\\n    return sum\\n};"]}
{"id": "42", "ref_js": ["var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };", "var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };", "var reverseBits = function(n) {\\n      var result = 0;\\n      var count = 32;\\n    \\n      while (count--) {\\n        result *= 2;\\n        result += n & 1;\\n        n = n >> 1;\\n      }\\n      return result;\\n    };"]}
{"id": "43", "ref_js": ["var hammingWeight = function(n) {\\n        let res = 0;\\n        for (let i = 0; i < 32; i++) {\\n            if ((n >> i) & 1) {\\n                res += 1;\\n            }\\n        }\\n        return res;   \\n};", "var hammingWeight = function(n) {\\n    let bitMask = 1;\\n    let count = 0;\\n    for(let i = 0; i < 32; i++)\\n    {\\n        if(n & bitMask)\\n            count++;\\n        n >>= bitMask;\\n    }\\n    return count;\\n};", "var hammingWeight = function(n) {\\n        let res = 0;\\n        for (let i = 0; i < 32; i++) {\\n            if ((n >> i) & 1) {\\n                res += 1;\\n            }\\n        }\\n        return res;   \\n};"]}
{"id": "48", "ref_js": ["var isHappy = function(n) {\\n    let isHappy = undefined, latestN = n;\\n    const squaredSet = new Set();\\n\\n    while(isHappy === undefined) {\\n        let squaredNumsSum = 0;\\n        const squaredNums = latestN.toString().split(\"\").map(num => num * num);\\n\\n        for (let i = 0; i < squaredNums.length; i++) {\\n            squaredNumsSum += squaredNums[i];\\n        }\\n\\n        if (squaredNumsSum == 1) {\\n            isHappy = true;\\n        }\\n\\n        if (squaredSet.has(squaredNumsSum)) {\\n            isHappy = false;\\n        } else {\\n            squaredSet.add(squaredNumsSum);\\n        }\\n\\n        latestN = squaredNumsSum;\\n    }\\n\\n    return isHappy;\\n};", "var isHappy = function(n) {\\n    if(n<10){\\n        if(n === 1 || n === 7){\\n            return true\\n        }\\n        return false\\n    }\\n    let total = 0\\n    while(n>0){\\n        let sq = n % 10\\n        total += sq**2\\n        n -= sq\\n        n /= 10\\n    }\\n    if(total === 1){\\n        return true\\n    }\\n    return isHappy(total)\\n};", "var isHappy = function(n) {\\n    let isHappy = undefined, latestN = n;\\n    const squaredSet = new Set();\\n\\n    while(isHappy === undefined) {\\n        let squaredNumsSum = 0;\\n        const squaredNums = latestN.toString().split(\"\").map(num => num * num);\\n\\n        for (let i = 0; i < squaredNums.length; i++) {\\n            squaredNumsSum += squaredNums[i];\\n        }\\n\\n        if (squaredNumsSum == 1) {\\n            isHappy = true;\\n        }\\n\\n        if (squaredSet.has(squaredNumsSum)) {\\n            isHappy = false;\\n        } else {\\n            squaredSet.add(squaredNumsSum);\\n        }\\n\\n        latestN = squaredNumsSum;\\n    }\\n\\n    return isHappy;\\n};"]}
{"id": "49", "ref_js": ["var removeElements = function(head, val) {\\n    \\n    let tempHead = head,prev\\n    while (tempHead){\\n        if (tempHead.val ===val){\\n            ", "var removeElements = function(head, val) {\\n    if(!head) return null;\\n    if(head.next === null && head.val === val) return null;\\n\\n    let ref = head;\\n    while(head.next !== null){\\n        if(ref && ref.val === val){\\n            ref = ref.next;\\n        }\\n        else if(head.next.val === val){\\n            head.next = head.next.next;\\n        }\\n        else{\\n            head = head.next;\\n        }\\n    }\\n    return ref;\\n};", "var removeElements = function(head, val) {\\n    "]}
{"id": "50", "ref_js": ["var isIsomorphic = function(s, t) {\\n    ", "var isIsomorphic = function(s, t) {\\n\\n    for (let i=0; i<s.length; i++) {\\n\\n        if (s.indexOf(s[i], i + 1) !== t.indexOf(t[i], i + 1)) {\\n            \\n            return false;\\n        }\\n    }\\n    return true;\\n};", "var isIsomorphic = function(s, t) {\\n    const map = new Map();\\n    const set = new Set();\\n    let n = s.length - 1;\\n\\n    while (n >= 0) {\\n        if (map.has(s[n]) && map.get(s[n]) !== t[n]) {\\n        return false;\\n        }\\n        if (!map.has(s[n]) && set.has(t[n])) {\\n        return false;\\n        }\\n        set.add(t[n]);\\n        map.set(s[n], t[n]);\\n        n--;\\n    }\\n\\n    return true;\\n};"]}
{"id": "51", "ref_js": ["var reverseList = function(head) {\\n    ", "var reverseList = function(head) {\\n    \\n    if(!head || !head.next) return head\\n    reversedPart=reverseList(head.next)\\n    head.next.next=head\\n    head.next=null\\n    return reversedPart\\n};", "var reverseList = function (head) {\\n    "]}
{"id": "52", "ref_js": ["var containsDuplicate = function(nums) {\\n    const s = new Set(nums); return s.size !== nums.length\\n};", "var containsDuplicate = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i <= nums.length-1; i++){\\n        if(nums[i] === nums[i+1]){\\n            return true\\n        }\\n    }\\n    return false\\n};", "var containsDuplicate = function(nums) {\\n    const s = new Set(nums); return s.size !== nums.length\\n};"]}
{"id": "53", "ref_js": ["var containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        ", "var containsNearbyDuplicate = function(nums, k) {\\n  const hi = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    \\n    if (hi.has(nums[i]) && i - hi.get(nums[i])<= k) {\\n      return true;\\n    }\\n    hi.set(nums[i],i)\\n ", "var containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        "]}
{"id": "54", "ref_js": ["var countNodes = function(root) {\\n    let num = [0];\\n    countingTraversal(root, num);\\n    return num[0];\\n};", "var countNodes = function (r) {\\n\\n  function dfs(r) {\\n    if (!r) return 0;\\n\\n    let ll = dfs(r.left)\\n    let rr = dfs(r.right)\\n\\n    return 1 + ll + rr;\\n  }\\n\\n  return dfs(r);\\n};", "var countNodes = function (r) {\\n\\n  function dfs(r) {\\n    if (!r) return 0;\\n\\n    let ll = dfs(r.left)\\n    let rr = dfs(r.right)\\n\\n    return 1 + ll + rr;\\n  }\\n\\n  return dfs(r);\\n};"]}
{"id": "56", "ref_js": ["var invertTree = function(root) {\\n    ", "var invertTree = function(root) {\\n    if(!root) return root;\\n    const queue = [];\\n    queue.push(root);\\n    while(queue.length){\\n        let current = queue.shift();\\n        const temp = current.left;\\n        current.left = current.right;\\n        current.right = temp;\\n        if(current.left) queue.push(current.left);\\n        if(current.right) queue.push(current.right);\\n    }\\n    return root\\n};", "var invertTree = function(root) {\\n    if(!root) return root;\\n    const queue = [];\\n    queue.push(root);\\n    while(queue.length){\\n        let current = queue.shift();\\n        const temp = current.left;\\n        current.left = current.right;\\n        current.right = temp;\\n        if(current.left) queue.push(current.left);\\n        if(current.right) queue.push(current.right);\\n    }\\n    return root\\n};"]}
{"id": "57", "ref_js": ["var summaryRanges = function(nums) {\\n    let i=0, j=0;\\n    let ret=[];\\n    while(i<nums.length) {\\n        j=i+1;\\n        while(j<nums.length && nums[j]-1===nums[j-1]) {\\n            j++;\\n        }\\n        if(i!==j-1) {\\n            ret.push(\"\"+nums[i]+\"->\"+nums[j-1]);\\n        }else {\\n            ret.push(\"\"+nums[i]);\\n        }\\n        i=j;\\n    }\\n    return ret;\\n};", "var summaryRanges = function(nums) {\\n  const result = [];\\n  let start = nums[0];\\n  \\n  for (let i = 1; i <= nums.length; i++) {\\n      if (nums[i - 1] + 1 === nums[i]) continue;\\n\\n      if (start === nums[i - 1]) {\\n          result.push(`${start}`);\\n      } else {\\n          result.push(`${start}->${nums[i - 1]}`);\\n      }\\n      start = nums[i];\\n  }\\n\\n  return result;\\n};", "var summaryRanges = function (nums) {\\n    let arr =[]\\n    let res =[]\\n    for(let j=0;j<nums.length;j++){\\n       if(nums[j]+1 === nums[j+1]){\\n        arr.push(nums[j])\\n       }else if(nums[j]+1!==nums[j+1]&&nums[j]===nums[j-1]+1){\\n            arr.push(nums[j])\\n            res.push(arr)\\n            arr=[]\\n       }else{\\n        res.push(nums[j])\\n       }\\n    }\\n    for(let j=0;j<res.length;j++){\\n        if(Array.isArray(res[j])){\\n                res[j] = `${res[j][0]}->${res[j][res[j].length-1]}`\\n        }else{\\n                res[j]=`${res[j]}`\\n        }\\n    }\\nreturn res\\n};"]}
{"id": "58", "ref_js": ["var isPowerOfTwo = function(n) {\\n    if (n == 0)\\n        return 0;\\n    while (n != 1) {\\n        if (n%2 != 0)\\n            return 0;\\n        n = n/2;\\n    }\\n    return 1;\\n};", "var isPowerOfTwo = function(n) {\\n    return n > 0 && (n & n - 1) === 0;\\n};", "var isPowerOfTwo = function(n) {\\n    return n > 0 && (n & n - 1) === 0;\\n};"]}
{"id": "60", "ref_js": ["var isPalindrome = function(head) {\\n    let slow = head, fast = head, prev, temp\\n    while (fast && fast.next)\\n        slow = slow.next, fast = fast.next.next\\n    prev = slow, slow = slow.next, prev.next = null\\n    while (slow)\\n        temp = slow.next, slow.next = prev, prev = slow, slow = temp\\n    fast = head, slow = prev\\n    while (slow)\\n        if (fast.val !== slow.val) return false\\n        else fast = fast.next, slow = slow.next\\n    return true\\n};", "var isPalindrome = function(head) {\\n    let ptr = head;\\n    let num = [];\\n    while(ptr.next !== null){\\n        num.push(ptr.val);\\n        ptr = ptr.next;\\n        if(ptr.next === null){\\n            num.push(ptr.val);\\n        }\\n    }\\n    let end = num.length - 1;\\n    for(let i=0;i<num.length;i++){\\n        if(num[i] === num[end]){\\n            end--;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    return true;\\n};", "var isPalindrome = function(head) {\\n    let arr = []\\n    while(head) {\\n        arr.push(head.val)\\n        head = head.next\\n    }\\n    return arr.join(\\'\\') == arr.reverse().join(\\'\\')\\n};"]}
{"id": "61", "ref_js": ["var isAnagram = function(s, t) {\\n    if (s.length !== t.length) return false;\\n\\n        const charMap = Array(26).fill(0);\\n\\n        for (let i = 0; i < s.length; i++) {\\n            charMap[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++;\\n            charMap[t.charCodeAt(i) - \\'a\\'.charCodeAt(0)]--;\\n        }\\n\\n        return charMap.every(count => count === 0);\\n};", "var isAnagram = function(s, t) {\\n    if (s.length !== t.length) {\\n        return false;\\n    }\\n\\n    const counter = new Map();\\n\\n    for (let char of s) {\\n        counter.set(char, (counter.get(char) || 0) + 1);\\n    }\\n\\n    for (let char of t) {\\n        if (!counter.has(char) || counter.get(char) === 0) {\\n            return false;\\n        }\\n        counter.set(char, counter.get(char) - 1);\\n    }\\n\\n    return true;    \\n};", "var isAnagram = function(s, t) {\\n    if (s.length !== t.length) return false;\\n\\n        const charMap = Array(26).fill(0);\\n\\n        for (let i = 0; i < s.length; i++) {\\n            charMap[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++;\\n            charMap[t.charCodeAt(i) - \\'a\\'.charCodeAt(0)]--;\\n        }\\n\\n        return charMap.every(count => count === 0);\\n};"]}
{"id": "62", "ref_js": ["var binaryTreePaths = function(root) {\\n    const paths = [];\\n\\n    function dfs(node, path) {\\n        if (!node) return;\\n        path.push(node.val.toString());\\n        if (!node.left && !node.right) {\\n            paths.push(path.join(\\'->\\'));\\n        } else {\\n            dfs(node.left, path.slice()); ", "var binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};", "var binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    "]}
{"id": "63", "ref_js": ["var addDigits = function(num) {\\n    return 1 + (num - 1) % 9;\\n};", "var addDigits = function(num) {\\n    if (isNaN(num) || num === 0) return 0;\\n    if (num < 10) return num;\\n    return num % 9 === 0 ? 9 : num % 9;\\n};", "var addDigits = function(num) {\\n    return 1 + (num - 1) % 9;\\n};"]}
{"id": "64", "ref_js": ["var isUgly = function(n) {\\n    if (n === 1) return true\\n    if (n <= 0) return false\\n\\n    while (n !== 0) {\\n      if (n % 5 === 0) {\\n        return isUgly(n / 5)\\n      } else if (n % 3 === 0) {\\n        return isUgly(n / 3)\\n      } else if (n % 2 === 0) {\\n        return isUgly(n / 2)\\n      }\\n      return false\\n    }\\n};", "var isUgly = function (n) {\\n    if(n <= 0) return false\\n\\n    while (n != 1) {\\n        if (n % 2 === 0) {\\n            n /= 2\\n        } else if (n % 3 === 0) {\\n            n /= 3\\n        } else if (n % 5 === 0) {\\n            n /= 5\\n        } else {\\n            return false\\n        }\\n    }\\n\\n    return true\\n};", "var isUgly = function(n) {\\n    if (n === 1) return true\\n    if (n <= 0) return false\\n\\n    while (n !== 0) {\\n      if (n % 5 === 0) {\\n        return isUgly(n / 5)\\n      } else if (n % 3 === 0) {\\n        return isUgly(n / 3)\\n      } else if (n % 2 === 0) {\\n        return isUgly(n / 2)\\n      }\\n      return false\\n    }\\n};"]}
{"id": "65", "ref_js": ["var missingNumber = function (nums) {\\n  const n = nums.length;\\n  const expectedSum = (n * (n + 1)) / 2;\\n  let actualSum = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    actualSum = actualSum + nums[i]\\n  }\\n  \\n  return expectedSum-actualSum\\n};", "var missingNumber = function(nums) {\\n     let n = nums.length + 1;\\n        let total = (n * (n-1)) / 2;\\n        \\n        for (let num of nums) {\\n            total -= num;\\n        }\\n        \\n        return total;\\n};", "var missingNumber = function(nums) {\\n    const n = nums.length;\\n\\n    const sumOriginal = n * (n + 1) / 2;\\n    const sumGiven = nums.reduce((acc, current) => acc + current, 0);\\n\\n    return sumOriginal - sumGiven;\\n};"]}
{"id": "66", "ref_js": ["var solution = function(isBadVersion) {\\n    \\n    return function(n) {\\n        let left=1,right=n\\n        while(left<=right){\\n            const mid= Math.floor((left+right)/2)\\n            const midVal=isBadVersion(mid)\\n            const prevMid=isBadVersion(mid-1)\\n            if( midVal && !prevMid) return mid\\n            else if(prevMid) right=mid-1\\n            else left=mid+1 \\n        }\\n    };", "var solution = function(isBadVersion) {\\n    \\n     \\n    return function(n) {\\n       let start = 1\\n       let end = n\\n       while (start <= end) {\\n           let mid = Math.floor((start + end) / 2)\\n           if (!isBadVersion(mid)) {\\n               start = mid + 1\\n           } else {\\n               end = mid - 1\\n           }\\n       }\\n       return start\\n    };", "var solution = function(isBadVersion: any) {\\n\\n    return function(n: number): number {\\n\\n      "]}
{"id": "67", "ref_js": ["var moveZeroes = function(nums) {\\n    let left = 0;\\n\\n    for (let right=0; right<nums.length; right++) {\\n        if (nums[right] != 0) {\\n            let tmp = nums[right];\\n            nums[right] = nums[left];\\n            nums[left] = tmp;\\n            left ++;\\n        }\\n    }\\n};", "var moveZeroes = function(nums) {\\n\\n  let left = 0;\\n  let right = 0;\\n\\n\\n\\n  while(left < nums.length){\\n      if(nums[left] !== 0){\\n          [nums[left],nums[right]] = [nums[right], nums[left]];\\n          right++\\n        }\\n\\n        left++\\n    }\\n\\n};", "var moveZeroes = function(nums) {\\n    let left = 0;\\n\\n    for (let right=0; right<nums.length; right++) {\\n        if (nums[right] != 0) {\\n            let tmp = nums[right];\\n            nums[right] = nums[left];\\n            nums[left] = tmp;\\n            left ++;\\n        }\\n    }\\n};"]}
{"id": "68", "ref_js": ["var wordPattern = function(pattern, s) {\\n\\n    ", "var wordPattern = function(pattern, s) {\\n    const arrayString = s.split(\\' \\');\\n    const hashMapPattern = {};", "var wordPattern = function(pattern, str) {\\n    const words = str.split(/\\\\s+/);\\n    const map = new Map();\\n    \\n    if(words.length !== pattern.length) return false;\\n    if(new Set(words).size !== new Set(pattern).size) return false;\\n    \\n    for(let i = 0; i < pattern.length; i++) {\\n        if(map.has(pattern[i]) && \\n           map.get(pattern[i]) !== words[i]) return false;\\n        map.set(pattern[i], words[i]);\\n    }\\n    return true;\\n};"]}
{"id": "69", "ref_js": ["var canWinNim = function(n) {\\n    if( n % 4 == 0) return false;\\n    else return true;\\n};", "var canWinNim = function(n) {\\n    return n%4\\n};", "var canWinNim = function(n) {\\n    return n%4\\n};"]}
{"id": "71", "ref_js": ["var isPowerOfThree = function(n) {\\n    if (n < 1) return false\\n    for(let i = 0; i <= n; i++) {\\n        let num = Math.pow(3, i)\\n        if (num === n) return true\\n        if (num > n) return false\\n    }\\n};", "var isPowerOfThree = function(n) {\\n    if (n < 1) return false\\n    for(let i = 0; i <= n; i++) {\\n        let num = Math.pow(3, i)\\n        if (num === n) return true\\n        if (num > n) return false\\n    }\\n};", "var isPowerOfThree = function(n) {\\n    if (n < 1) return false\\n    for(let i = 0; i <= n; i++) {\\n        let num = Math.pow(3, i)\\n        if (num === n) return true\\n        if (num > n) return false\\n    }\\n};"]}
{"id": "72", "ref_js": ["var countBits = function(n) {\\n    var dp = new Array(n + 1).fill(0);\\n    var sub = 1;\\n\\n    for (var i = 1; i <= n; i++) {\\n        if (sub * 2 === i) {\\n            sub = i;\\n        }\\n\\n        dp[i] = dp[i - sub] + 1;\\n    }\\n\\n    return dp;    \\n};", "var countBits = function(n) {\\n    var dp = new Array(n + 1).fill(0);\\n    var sub = 1;\\n\\n    for (var i = 1; i <= n; i++) {\\n        if (sub * 2 === i) {\\n            sub = i;\\n        }\\n\\n        dp[i] = dp[i - sub] + 1;\\n    }\\n\\n    return dp;    \\n};", "var countBits = function(n) {\\n    var dp = new Array(n + 1).fill(0);\\n    var sub = 1;\\n\\n    for (var i = 1; i <= n; i++) {\\n        if (sub * 2 === i) {\\n            sub = i;\\n        }\\n\\n        dp[i] = dp[i - sub] + 1;\\n    }\\n\\n    return dp;    \\n};"]}
{"id": "73", "ref_js": ["var isPowerOfFour = function(n) {\\n    if (n <= 0) {\\n        return false;\\n    }\\n    return Number.isInteger(Math.log(n) / Math.log(4));    \\n};", "var isPowerOfFour = function(n) {\\n    if (n <= 0) return false;\\n    let root = Math.floor(Math.log(n) / Math.log(4));\\n    if(Math.pow(4,root) == n) return true;\\n    else return false;\\n};", "var isPowerOfFour = function(n) {\\n    return Number.isInteger(Math.log(n) / Math.log(4))\\n};"]}
{"id": "74", "ref_js": ["var reverseString = function(s) {\\n    let left = 0; ", "var reverseString = function(s) {\\n    \\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left <= right) {\\n    [s[left],s[right]] = [s[right],s[left]]\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};", "var reverseString = function(s) {\\n    \\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left <= right) {\\n    [s[left],s[right]] = [s[right],s[left]]\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};"]}
{"id": "75", "ref_js": ["var reverseVowels = function(s) {\\n   const vowels = \\'aeiouAEIOU\\';\\n  let left = 0;\\n  let right = s.length - 1;\\n  const sArray = s.split(\\'\\'); ", "var reverseVowels = function(s) {\\n   const vowels = \\'aeiouAEIOU\\';\\n  let left = 0;\\n  let right = s.length - 1;\\n  const sArray = s.split(\\'\\'); ", "var reverseVowels = function(s) {\\n   const vowels = \\'aeiouAEIOU\\';\\n  let left = 0;\\n  let right = s.length - 1;\\n  const sArray = s.split(\\'\\'); "]}
{"id": "76", "ref_js": ["var intersection = function(nums1, nums2) {\\n    const set = new Set();\\n    const res = new Set();\\n    for(const num of nums1) set.add(num);\\n    for(const num of nums2) set.has(num) && res.add(num);\\n    return [...res];\\n};", "var intersection = function(nums1, nums2) {\\n    let result = [];\\n    nums2.sort((a,b)=> a-b)\\n\\n    ", "var intersection = function(nums1, nums2) {\\n    let set1 = new Set(nums1);\\n    let set2 = new Set(nums2);\\n\\n    if (set1.size < set2.size) {\\n        return set_intersection(set1, set2);\\n    }\\n    else {\\n        return set_intersection(set2, set1);\\n    }\\n};"]}
{"id": "77", "ref_js": ["var intersect = function(nums1, nums2) {\\n    const map1 = nums1.reduce((acc, num) => ({\\n        ...acc,\\n        [num]: (acc[num] ?? 0) + 1,\\n    }), {});\\n    const map2 = nums2.reduce((acc, num) => ({\\n        ...acc,\\n        [num]: (acc[num] ?? 0) + 1,\\n    }), {});\\n    return Object.keys(map1).flatMap((num) => {\\n        const count = Math.min(map1[num], map2[num] ?? 0);\\n        return Array(count).fill(num);\\n    });\\n};", "var intersect = function(nums1, nums2) {\\n    const map = new Map();\\n    for (const n of nums1) {\\n        if (map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    const result = [];\\n    for (const n of nums2) {\\n        if (map.has(n) && map.get(n) > 0) {\\n            result.push(n);\\n            map.set(n, map.get(n) - 1);\\n        }\\n    }\\n    return result;\\n};", "var intersect = function(nums1, nums2) {\\n    const map1 = nums1.reduce((acc, num) => ({\\n        ...acc,\\n        [num]: (acc[num] ?? 0) + 1,\\n    }), {});\\n    const map2 = nums2.reduce((acc, num) => ({\\n        ...acc,\\n        [num]: (acc[num] ?? 0) + 1,\\n    }), {});\\n    return Object.keys(map1).flatMap((num) => {\\n        const count = Math.min(map1[num], map2[num] ?? 0);\\n        return Array(count).fill(num);\\n    });\\n};"]}
{"id": "78", "ref_js": ["var isPerfectSquare = function(num) {\\n    return num ** 0.5 == parseInt(num ** 0.5)\\n};", "var isPerfectSquare = function(num) {\\n    for (let i = 0; i <= num; i++) {\\n        if (i*i === num) return true;\\n        if (i*i > num) return false;\\n    }\\n};", "var isPerfectSquare = function(num) {\\n    return num ** 0.5 == parseInt(num ** 0.5)\\n};"]}
{"id": "79", "ref_js": ["var guess = function(num) {}\\n */\\n\\n\\nvar guessNumber = function(n) {\\n    const recursive = (start, end) => {\\n        const mid = Math.floor((start+end)/2);        \\n        if(guess(mid) === 0) return mid;\\n        if(guess(mid) === 1) return recursive(mid+1,end);\\n        if(guess(mid) === -1) return recursive(start,mid-1);   \\n    }\\n    return recursive(0,n);\\n};", "var guess = function(num) {}\\n */\\n\\n\\nvar guessNumber = function(n) { \\n    var start = 1;\\n    var end = n;   \\n    while(start <= end){\\n        var num = Math.ceil(start + (end - start)/2);\\n        var ask = guess(num);\\n        if(ask == 0) return num;\\n        else if(ask == -1) end = num - 1;\\n        else if(ask == 1) start = num + 1;\\n    }\\n    return start;\\n};", "var guessNumber = function(n) {\\n    const findNumber = (start, end) => {\\n        const mid = Math.floor((end + start)/2);\\n        \\n        if (guess(mid) === 0) return mid;\\n        if (guess(mid) === -1) return findNumber(start, mid - 1);\\n        if (guess(mid) === 1) return findNumber(mid + 1, end);\\n    }\\n    \\n    return findNumber(0, n);\\n};"]}
{"id": "80", "ref_js": ["var containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        ", "var containsNearbyDuplicate = function(nums, k) {\\n  const hi = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    \\n    if (hi.has(nums[i]) && i - hi.get(nums[i])<= k) {\\n      return true;\\n    }\\n    hi.set(nums[i],i)\\n ", "var containsNearbyDuplicate = function(nums, k) {\\n    const hasmap = new Map();\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        "]}
{"id": "81", "ref_js": ["var firstUniqChar = function(s) {\\n    \\n    for(let i=0;i<s.length;i++){\\n      \\n    let firstIndex = s.indexOf(s[i])\\n    let lastIndex = s.lastIndexOf(s[i])\\n  \\n  if(firstIndex === lastIndex){\\n      return i\\n  }\\n    }\\n\\nreturn -1\\n};", "var firstUniqChar = function(s) {\\n    for (let idx = 0; idx < s.length; idx++){\\n        ", "var firstUniqChar = function(s) {\\n     for(let i = 0; i < s.length; i++){\\n       if(s.indexOf(s[i]) === s.lastIndexOf(s[i])){\\n           return s.indexOf(s[i])\\n       }\\n   }\\n   return -1;\\n};"]}
{"id": "82", "ref_js": ["var findTheDifference = function(s, t) {\\n    let result = 0; \\n    for (let i = 0; i < s.length; i++) {\\n        result ^= s.charCodeAt(i);\\n    }\\n    for (let i = 0; i < t.length; i++) {\\n        result ^= t.charCodeAt(i);\\n    }\\n    return String.fromCharCode(result); \\n};", "var findTheDifference = function(s, t) {\\n    const count = new Map();\\n    \\n    for (const char of t) {\\n        count.set(char, (count.get(char) || 0) + 1);\\n    }\\n    \\n    for (const char of s) {\\n        count.set(char, count.get(char) - 1);\\n        if (count.get(char) === 0) {\\n            count.delete(char);\\n        }\\n    }\\n    \\n    return Array.from(count.keys())[0];    \\n};", "var findTheDifference = function(s, t) {\\n    let result = 0; \\n    for (let i = 0; i < s.length; i++) {\\n        result ^= s.charCodeAt(i);\\n    }\\n    for (let i = 0; i < t.length; i++) {\\n        result ^= t.charCodeAt(i);\\n    }\\n    return String.fromCharCode(result); \\n};"]}
{"id": "83", "ref_js": ["var isSubsequence = function(s, t) {\\n    if (s.length > t.length) {\\n        return false;\\n    }\\n\\n    if (s.length === 0 || t.length === 0) {\\n        return true;\\n    }\\n\\n    let i = 0;\\n    let j = 0;\\n\\n    while (i < s.length && j < t.length) {\\n        if (s[i] === t[j]) {\\n            i++;\\n            j++;\\n            if (i === s.length) {\\n                return true;\\n            }\\n        } else {\\n            j++;\\n        }\\n    }\\n\\n    return false;\\n};", "var isSubsequence = function(s, t) {\\n    let sIdx = 0;\\n    let tIdx = 0;\\n\\n    while (sIdx < s.length && tIdx < t.length) {\\n        if (s[sIdx] === t[tIdx]) {\\n            sIdx++;\\n        }\\n        tIdx++;\\n    }\\n\\n    return sIdx === s.length;    \\n};", "var isSubsequence = function(s, t) {\\n    let sIdx = 0;\\n    let tIdx = 0;\\n\\n    while (sIdx < s.length && tIdx < t.length) {\\n        if (s[sIdx] === t[tIdx]) {\\n            sIdx++;\\n        }\\n        tIdx++;\\n    }\\n\\n    return sIdx === s.length;    \\n};"]}
{"id": "84", "ref_js": ["var readBinaryWatch = function(num) {\\n  const times = [];\\n  for (let h = 0; h < 12; h++) {\\n    for (let m = 0; m < 60; m++) {\\n      const hOnes = h ? h.toString(2).match(/1/g).length : 0;\\n      const mOnes = m ? m.toString(2).match(/1/g).length : 0;\\n      if (hOnes + mOnes === num) {\\n        times.push(`${h}:${m < 10 ? `0${m}` : m}`);\\n      }\\n    }\\n  }\\n  return times;\\n};", "var readBinaryWatch = function(turnedOn) {\\n    let ans=[]\\n    for(let h=0;h<12;h++){\\n        for(let m=0;m<60;m++){\\n            ", "var readBinaryWatch = function(num) {\\n   let answer = [];\\n   for(let h = 0; h < 12; h++){\\n       for(let m = 0; m < 60; m++){\\n           let ones = Number(h * 64 + m).toString(2).split(\"\").filter(d => d === \"1\").length;\\n           if (ones === num) answer.push(m < 10 ? `${h}:0${m}` : `${h}:${m}`);\\n       }\\n   }    \\n   return answer;\\n};"]}
{"id": "85", "ref_js": ["var sumOfLeftLeaves = function(root) {\\n    let sum = 0, res =[];\\n    function inorder(node, isLeft=false){\\n        if(!node)   return null;\\n\\n        inorder(node.left,true);\\n        if(node.left === null && node.right === null && isLeft){\\n            sum = sum+ node.val;\\n        }\\n        inorder(node.right)\\n    }\\n    inorder(root);\\n    return sum;\\n};", "var sumOfLeftLeaves = function(root) {\\n    if(!root) return 0; const { left, right } = root;\\n    \\n    let [sumLeft, sumRight] = [sumOfLeftLeaves(left), sumOfLeftLeaves(right)];\\n    \\n    if(!sumLeft && left && !left.left && !left.right) sumLeft = left.val;\\n    \\n    return Number(sumLeft) + Number(sumRight);\\n};", "var sumOfLeftLeaves = function(root) {\\n    let sum = 0, res =[];\\n    function inorder(node, isLeft=false){\\n        if(!node)   return null;\\n\\n        inorder(node.left,true);\\n        if(node.left === null && node.right === null && isLeft){\\n            sum = sum+ node.val;\\n        }\\n        inorder(node.right)\\n    }\\n    inorder(root);\\n    return sum;\\n};"]}
{"id": "86", "ref_js": ["var toHex = function(num) {\\n\\n    const hexas = {\\n        0: 0, 6: 6, 10: \"a\",\\n        1: 1, 7: 7, 11: \"b\",\\n        2: 2, 8: 8, 12: \"c\",\\n        3: 3, 9: 9, 13: \"d\",\\n        4: 4, 14: \"e\",\\n        5: 5, 15: \"f\"\\n    }\\n\\n    if(num >= 0 && num <= 15) return hexas[num].toString();\\n    if(num < 0) num = num >>> 0;\\n\\n    let newArr = [];\\n    while(num >= 16) {\\n\\n        let rest = (num % 16);\\n\\n        newArr.unshift(hexas[rest]);\\n\\n        num = Math.floor(num / 16);\\n    }\\n\\n    newArr.unshift(hexas[num]);\\n\\n    return newArr.join(\"\");\\n};", "var toHex = function(num) {\\n    let temp = Math.abs(num);\\nlet rev_a = []\\nwhile (temp > 0) {\\n    rev_a.push(parseInt(temp % 16))\\n    temp = parseInt(temp / 16);\\n}\\nlet a = [];\\nfor (let i = rev_a.length; i <= 7; i++) {\\n    rev_a.push(0)\\n}\\nfor (let i = rev_a.length - 1; i >= 0; i--) {\\n    a.push(rev_a[i])\\n}\\nif (num < 0) {\\n    for (let i = 0; i <= 7; i++) {\\n        a[i] = 15 - a[i]\\n    }\\n    let c = 1;\\n    let i = 7;\\n    while ( i >= 0) {\\n        if (a[i] < 15) {\\n            a[i] = a[i] + c;\\n            break;\\n        }\\n        else {\\n            temp = a[i];\\n            a[i] = (a[i] + c) % 16;\\n            c = parseInt((temp + c) / 16);\\n            i = i - 1;\\n        }\\n    }\\n}\\ni = 0;\\nwhile (i < 7 && a[i] == 0) {\\n    i = i + 1;\\n}\\nlet str = \"\";\\nfor (let j = i; j <= 7; j++) {\\n    if (a[j] <= 9) {\\n        str = str + a[j];\\n    }\\n   \\n    else if (a[j] == 10) {\\n        str = str + \"a\";\\n    }\\n    else if (a[j] == 11) {\\n        str = str + \"b\"\\n    }\\n    else if (a[j] == 12) {\\n        str = str + \"c\"\\n    }\\n    else if (a[j] == 13) {\\n        str = str + \"d\"\\n    }\\n    else if (a[j] == 14) {\\n        str = str + \"e\"\\n    }\\n    else if (a[j] == 15) {\\n        str = str + \"f\"\\n    }\\n}\\nif(num==0)\\n{\\n    return \"0\"\\n}\\nreturn(str);\\n\\n    \\n};", "var toHex = function(num) {\\n\\n    num = num<0 ? ~-num+1>>>0 : num\\n\\n    const hex = []\\n    while (num >= 16) {\\n        hex.unshift(num % 16)\\n        num = Math.floor(num / 16)\\n    }\\n    hex.unshift(num)\\n\\n    return hex.map(e=>\"0123456789abcdef\"[e]).join``\\n};"]}
{"id": "87", "ref_js": ["var longestPalindrome = function(s) {\\n  let ans = 0;\\n  let keys = {};", "var longestPalindrome = function(s) {\\n    const obj = {}\\n    let sum = 0;\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const ch = s[i]\\n        if(!obj[ch]){\\n            obj[ch] = 1;\\n        }else{\\n            obj[ch] = 0;\\n            sum += 2;\\n        }\\n    }\\n    \\n    if( sum < s.length ){\\n        return sum + 1;\\n    }else{\\n        return sum;\\n    }\\n};", "var longestPalindrome = function(s) {\\n    let obj ={};"]}
{"id": "88", "ref_js": ["var fizzBuzz = function(n) {\\n    return Array.from({length: n}, (_, i) => {\\n        i += 1;\\n        return i % 3 === 0 && i % 5 === 0 ? \\'FizzBuzz\\'\\n            : i % 3 === 0 ? \\'Fizz\\' \\n            : i % 5 === 0 ? \\'Buzz\\'\\n            : `${i}`;\\n    });\\n};", "var fizzBuzz = function(n) {\\n    let T = []\\n    for(let i=1;i<=n;i++){\\n        let out = \"\" ", "var fizzBuzz = function(n) {\\n    let T = []\\n    for(let i=1;i<=n;i++){\\n        let out = \"\" "]}
{"id": "89", "ref_js": ["var thirdMax = function(nums) {\\n    let a = nums.sort((a,b) => b-a)\\n    let set = new Set(a)\\n    let newArray = Array.from(set)\\n    if(newArray.length < 3) return newArray[0]\\n    return newArray[2]\\n};", "var thirdMax = function (nums) \\n\\t {\\n\\t \\n            let sort = nums.sort((a, b) => b - a)\\n            let arr = []\\n            let k = 0\\n            for (let i = 0; i < nums.length; i++) {\\n                if (arr.indexOf(sort[i]) == -1 && sort[i] != undefined) {\\n                    arr.push(sort[i])\\n                    k++\\n                }\\n                if (k == 3)  break\\n            }\\n            if (arr.length == 1 || arr.length == 2) return arr[0]\\n            return arr[arr.length - 1]\\n        };", "var thirdMax = function(nums) {\\n    let tmp\\n    for(let i=0; i<nums.length; i++){\\n        for(let j=i+1; j<nums.length; j++){\\n            if(nums[i] === nums[j]) {\\n                nums.splice(j, 1)\\n                j = i\\n                continue\\n            }\\n            else {\\n                if(nums[i] < nums[j]){\\n                    tmp = nums[i]\\n                    nums[i] = nums[j]\\n                    nums[j] = tmp\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    return nums.length >= 3 ? nums[2] : nums[0]\\n};"]}
{"id": "90", "ref_js": ["var addStrings = function(num1, num2) {\\n  num1 = num1.split(\"\");\\n  num2 = num2.split(\"\");\\n  let carry = \"0\";\\n  let result = [];\\n  while (num1.length || num2.length) {\\n    let [c1 = \"0\", c2 = \"0\"] = [num1.pop(), num2.pop()];\\n    let added = (Number(carry) + Number(c1) + Number(c2)).toString();\\n    carry = \"0\";\\n    if (Number(added) >= 10) {\\n      const [c1, c2] = added.split(\"\");\\n      carry = c1;\\n      added = c2;\\n    }\\n    result.unshift(added);\\n  }\\n  if (Number(carry) > 0) result.unshift(carry);\\n  return result.join(\"\");\\n};", "var addStrings = function(num1, num2) {\\n    \\n    let carry = null;\\n    let left = num1.length - 1;\\n    let right = num2.length - 1;\\n    let result = \\'\\'\\n    while(left >=0 && right >= 0){\\n        let sum = (+num1[left] + +num2[right]);\\n        if(carry){\\n            sum+= +carry;\\n        }\\n        if(sum>=10){\\n            carry = sum.toString().slice(0, sum.toString().length-1)\\n        }else{\\n            carry = null;\\n        }\\n        if(sum>=10){\\n            result = sum.toString().at(-1) + result;\\n        }else{\\n            result = sum + result;\\n        }\\n\\n        left--;\\n        right--;\\n    }\\n\\n    while(num1[left]){\\n       \\n        let sum = Number(num1[left]);\\n        if(carry){\\n            sum+= Number(carry)\\n        }\\n\\n        if(sum>=10){\\n            carry = sum.toString().slice(0, sum.toString().length - 1);\\n        }else{\\n            carry = null;\\n        }\\n\\n        if(sum>=10){\\n            result = sum.toString().at(-1) + result\\n        }else{\\n            result = sum.toString() + result;\\n        }\\n        left--\\n    }\\n    while(num2[right]){\\n        let sum = Number(num2[right]);\\n        if(carry){\\n            sum+= Number(carry)\\n        }\\n\\n        if(sum>=10){\\n            carry = sum.toString().slice(0, sum.toString().length - 1);\\n        }else{\\n            carry = null;\\n        }\\n\\n        if(sum>=10){\\n            result = sum.toString().at(-1) + result\\n        }else{\\n            result = sum.toString() + result;\\n        }\\n        right--\\n    }\\n\\n    if(carry){\\n        result = carry + result;\\n    }\\n\\n    return result;\\n\\n};", "var addStrings = function(num1, num2) {\\n    \\n    let carry = null;\\n    let left = num1.length - 1;\\n    let right = num2.length - 1;\\n    let result = \\'\\'\\n    while(left >=0 && right >= 0){\\n        let sum = (+num1[left] + +num2[right]);\\n        if(carry){\\n            sum+= +carry;\\n        }\\n        if(sum>=10){\\n            carry = sum.toString().slice(0, sum.toString().length-1)\\n        }else{\\n            carry = null;\\n        }\\n        if(sum>=10){\\n            result = sum.toString().at(-1) + result;\\n        }else{\\n            result = sum + result;\\n        }\\n\\n        left--;\\n        right--;\\n    }\\n\\n    while(num1[left]){\\n       \\n        let sum = Number(num1[left]);\\n        if(carry){\\n            sum+= Number(carry)\\n        }\\n\\n        if(sum>=10){\\n            carry = sum.toString().slice(0, sum.toString().length - 1);\\n        }else{\\n            carry = null;\\n        }\\n\\n        if(sum>=10){\\n            result = sum.toString().at(-1) + result\\n        }else{\\n            result = sum.toString() + result;\\n        }\\n        left--\\n    }\\n    while(num2[right]){\\n        let sum = Number(num2[right]);\\n        if(carry){\\n            sum+= Number(carry)\\n        }\\n\\n        if(sum>=10){\\n            carry = sum.toString().slice(0, sum.toString().length - 1);\\n        }else{\\n            carry = null;\\n        }\\n\\n        if(sum>=10){\\n            result = sum.toString().at(-1) + result\\n        }else{\\n            result = sum.toString() + result;\\n        }\\n        right--\\n    }\\n\\n    if(carry){\\n        result = carry + result;\\n    }\\n\\n    return result;\\n\\n};"]}
{"id": "91", "ref_js": ["var countSegments = function(s) {\\n    ", "var countSegments = function(s) {\\n    return s.split(\\' \\')?.filter(item => !!item)?.length;\\n};", "var countSegments = function(s) {\\n    "]}
{"id": "92", "ref_js": ["var arrangeCoins = function (n) {\\n    let sum = 0;\\n    for(let i=1;i<=n;i++){\\n        sum = sum + i\\n        if(sum === n){\\n            return i\\n        }\\n        if(sum >= n){\\n            return i-1\\n        }\\n    }\\n};", "var arrangeCoins = function (n) {\\n    let sum = 0;\\n    for(let i=1;i<=n;i++){\\n        sum = sum + i\\n        if(sum === n){\\n            return i\\n        }\\n        if(sum >= n){\\n            return i-1\\n        }\\n    }\\n};", "var arrangeCoins = function (n) {\\n    let sum = 0;\\n    for(let i=1;i<=n;i++){\\n        sum = sum + i\\n        if(sum === n){\\n            return i\\n        }\\n        if(sum >= n){\\n            return i-1\\n        }\\n    }\\n};"]}
{"id": "93", "ref_js": ["var findDisappearedNumbers = function(nums) {\\n    let disAppearedNumber = []\\n    for(let i=0; i< nums.length; i++){\\n        let index = Math.abs(nums[i]) -1\\n        if(nums[index]> 0){\\n            nums[index] = -nums[index]\\n        }\\n    }\\n    for(let i=0; i< nums.length; i++){\\n        if(nums[i] > 0){\\n            disAppearedNumber.push(i+ 1)\\n        }\\n    }\\n    return disAppearedNumber\\n};", "var findDisappearedNumbers = function(nums) {\\n   let n = nums.length;\\n    let ans ={};", "var findDisappearedNumbers = function (nums) {\\n  const uniqueValues = new Set(nums);\\n  const result = [];\\n\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!uniqueValues.has(i)) {\\n      result.push(i);\\n    }\\n  }\\n\\n  return result;\\n};"]}
{"id": "94", "ref_js": ["var findContentChildren = function(g, s) {\\n    g.sort((a,b) => a-b);\\n    s.sort((a,b) => a-b);\\n    let j = 0, res = 0;\\n    for (let num of s) {\\n        if (num >= g[j]) res++, j++;\\n    }\\n    return res;\\n    ", "var findContentChildren = function(g, s) {\\n    g = g.sort((a, b) => a - b);\\n    s = s.sort((a, b) => a - b);\\n    let cursorG = 0;\\n    let cursorS = 0;\\n    let output = 0;\\n    \\n    while (cursorS <= s.length && cursorG <= g.length) {\\n        if (s[cursorS] >= g[cursorG]) {\\n            cursorS++;\\n            cursorG++;\\n            output++;\\n        } else {\\n            cursorS++;\\n        }\\n    }\\n    \\n    return output;\\n};", "var findContentChildren = function(g, s) {\\n  g.sort((a, b) => a - b);\\n  s.sort((a, b) => a - b);\\n  \\n  let child = 0;\\n  for (const cookie of s) {\\n    if (cookie >= g[child]) child++;\\n  }\\n\\n  return child;\\n};"]}
{"id": "95", "ref_js": ["var repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    for (let i = 1; i <= n / 2; i++) {\\n        if (n % i === 0) {\\n            const substring = s.slice(0, i);\\n            let repeated = \"\";\\n            for (let j = 0; j < n / i; j++) {\\n                repeated += substring;\\n            }\\n            if (repeated === s) return true;\\n        }\\n    }\\n    return false;\\n};", "var repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n\\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\\n        if (n % i === 0 && s.slice(0, i).repeat(n / i) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;    \\n};", "var repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n\\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\\n        if (n % i === 0 && s.slice(0, i).repeat(n / i) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;    \\n};"]}
{"id": "96", "ref_js": ["var hammingDistance = function(x, y) {\\n    x = x.toString(2).split(\\'\\').reverse()\\n    y = y.toString(2).split(\\'\\').reverse()\\n    while(x.length < y.length) x.push(\\'0\\')\\n    while(x.length > y.length) y.push(\\'0\\')\\n    let count = 0\\n    for(let i = 0; i < x.length; i++){\\n        if(x[i] != y[i]) count++\\n    }\\n    return count\\n};", "var hammingDistance = function(x, y) {\\n    x=x.toString(2);\\n    y=y.toString(2);\\n    if(x.length < y.length){\\n        while(x.length !== y.length) \\n        x = \"0\" + x;\\n    }\\n    else{\\n        while(x.length !== y.length) \\n        y = \"0\" + y;\\n    }\\n    let count=0;\\n    for(let i=0;i<x.length;i++){\\n        if(x.charAt(i)!==y.charAt(i))\\n        count++;\\n    }\\n    return count;\\n};", "var hammingDistance = function(x, y) {\\n    x = x.toString(2).split(\\'\\').reverse()\\n    y = y.toString(2).split(\\'\\').reverse()\\n    while(x.length < y.length) x.push(\\'0\\')\\n    while(x.length > y.length) y.push(\\'0\\')\\n    let count = 0\\n    for(let i = 0; i < x.length; i++){\\n        if(x[i] != y[i]) count++\\n    }\\n    return count\\n};"]}
{"id": "97", "ref_js": ["var islandPerimeter = function(grid) {\\n\\n    let totalPerimeter = 0;\\n    let overlapPerimeter = 0\\n\\n    for(let i=0; i< grid.length; i++){\\n\\n        for(let j=0; j< grid[i].length; j++){\\n            if(grid[i][j] === 0){\\n                continue;\\n            }\\n            if(grid[i][j] === 1){\\n                totalPerimeter +=1;\\n            }\\n            if( j< grid[i].length-1 && grid[i][j] === 1 && grid[i][j+1] === 1){\\n                overlapPerimeter++;\\n            }\\n            if(i < grid.length-1 && grid[i][j] === 1 && grid[i+1][j] === 1 ){\\n                overlapPerimeter++;\\n            }\\n        }\\n    }\\n    totalPerimeter = 4*totalPerimeter;\\n    overlapPerimeter = overlapPerimeter*2;\\n\\n    return totalPerimeter- overlapPerimeter;\\n};", "var islandPerimeter = function(grid) {\\n    return grid.reduce(\\n        (perimeter, row, r) => perimeter +\\n            row.reduce(\\n                (memo, cell, c) => {\\n                    if (cell === 0) return memo;\\n\\n                    let perimeterOfCell = 4;\\n                    if (grid[r][c - 1] === 1) perimeterOfCell--;\\n                    if (grid[r][c + 1] === 1) perimeterOfCell--;\\n                    if (grid[r - 1]?.[c] === 1) perimeterOfCell--;\\n                    if (grid[r + 1]?.[c] === 1) perimeterOfCell--;\\n\\n                    return memo + perimeterOfCell;\\n                },\\n                0,\\n            ),\\n        0,\\n    );\\n};", "var islandPerimeter = function(grid) {\\n    let perimeter = 0\\n    let row = grid.length\\n    let col = grid[0].length\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 1) {\\n                if (i === 0 || i > 0 && grid[i-1][j] === 0) perimeter++ \\n                if (i === row-1 || i < row-1 && grid[i+1][j] === 0) perimeter++              \\n                if (j === 0 || j > 0 && grid[i][j-1] === 0) perimeter++\\n                if (j === col - 1 || j < col && grid[i][j+1] === 0) perimeter++\\n            }\\n        }\\n    }\\n    \\n    return perimeter\\n};"]}
{"id": "98", "ref_js": ["var findComplement = function(num) {\\n    const binaryString = num.toString(2);\\n    let binaryComplementString = \\'\\';\\n    for (let i = 0; i < binaryString.length; i++) {\\n        binaryComplementString += Number(binaryString[i]) ? 0 : 1;\\n    }\\n    return parseInt(binaryComplementString, 2).toString(10);\\n};", "var findComplement = function(num) {    \\n    let d = 2;\\n    while (d <= num) {\\n        d *= 2;\\n    }    \\n    return d - num - 1;\\n};", "var findComplement = function(num) {    \\n    let d = 2;\\n    while (d <= num) {\\n        d *= 2;\\n    }    \\n    return d - num - 1;\\n};"]}
{"id": "99", "ref_js": ["var licenseKeyFormatting = function(s, k) {\\n    \\n    ", "var licenseKeyFormatting = function(S, K) {\\n```\\n    const newStr = S.replace(/-/g, \\'\\').toUpperCase(), ", "var licenseKeyFormatting = function(s, k) {\\n    let output = \\'\\';\\n    const arrayString = s.replaceAll(\\'-\\', \\'\\').split(\\'\\');\\n    let count = 1;\\n\\n    for (let i = arrayString.length - 1; i >= 0; i--) {\\n        output = arrayString[i].toUpperCase() + output;\\n        if (!(count%k) && count && i) {\\n            output = \\'-\\' + output;\\n        }\\n        count++;\\n    }\\n\\n    return output;\\n};"]}
{"id": "100", "ref_js": ["var findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            current += 1;\\n        } else {\\n            current = 0;\\n        }\\n\\n        if (current > max) {\\n            max = current;\\n        } \\n    }\\n    return max;\\n};", "var findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n  \\n    for (let i = 0; i < nums.length; i++) {\\n      ", "var findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            current += 1;\\n        } else {\\n            current = 0;\\n        }\\n\\n        if (current > max) {\\n            max = current;\\n        } \\n    }\\n    return max;\\n};"]}
{"id": "101", "ref_js": ["var constructRectangle = function(area) {\\n    const mid = Math.floor(Math.sqrt(area));\\n    \\n    for (let i = mid; i >= 1; i--) {\\n        if (!(area%i)) return [area/i, i];\\n    }\\n    \\n    return [area, 1];\\n};", "var constructRectangle = function (area) {\\n  let mid = Math.floor(Math.sqrt(area));\\n\\n  while (mid !== 1) {\\n    if (area % mid === 0) {\\n      return [area / mid, mid];\\n    }\\n    mid--;\\n  }\\n  return [area, 1];\\n};", "var constructRectangle = function(area) {\\n    let w = Math.floor(Math.sqrt(area));\\n    while (true) {\\n      if (Number.isInteger(area / w)) {\\n        return [area / w,w]\\n      } else {\\n        w--\\n      }\\n    }\\n};"]}
{"id": "102", "ref_js": ["var findPoisonedDuration = function(timeSeries, duration) {\\n    let poison = 0;\\n    if(!duration||!timeSeries.length) return 0;\\n    for(let i=1;i<timeSeries.length;i++) {\\n        if(timeSeries[i]-timeSeries[i-1]>duration) {\\n            poison+=duration;\\n        }\\n        else {\\n            let exist=timeSeries[i]-timeSeries[i-1];\\n            poison+=exist;\\n        }        \\n    }\\n     poison+=duration;\\n    return poison;\\n};", "var findPoisonedDuration = function(timeSeries, duration) {\\n    let totalTime=duration\\n    \\n    for(let i=0;i+1<timeSeries.length;i++){\\n        let diff=timeSeries[i+1]-timeSeries[i]\\n        totalTime+= diff>duration ? duration : diff \\n    }\\n    return totalTime\\n    \\n};", "var findPoisonedDuration = function(timeSeries, duration) {\\n    if (timeSeries.length === 0 ) return 0; \\n    let res = duration;\\n    for (let i = 1; i < timeSeries.length; i++) {\\n            res += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\\n    }\\n    return res; \\n};"]}
{"id": "103", "ref_js": ["var nextGreaterElement = function(nums1, nums2) {\\n    if (nums1 === null || nums2 === null || nums1.length === 0 || nums2.length === 0) {\\n      return [];\\n    }\\n    let m     = new Map();\\n    let stack = [];\\n    let out   = [];\\n    for(let i=nums2.length-1; i>=0; i--){\\n        while(stack.length >0 && stack[stack.length-1] <=nums2[i]){\\n            stack.pop();\\n        }\\n        ", "var nextGreaterElement = function (a, b) {\\n  let res = new Array(a.length).fill(-1);\\n\\n  for (let i = 0; i < a.length; i++) {\\n    let rig;\\n    let jIndex = b.indexOf(a[i]) + 1;\\n\\n    for (let j = jIndex; j < b.length; j++) {\\n      if (b[j] > a[i]) {\\n        rig = b[j];\\n        break;\\n      }\\n    }\\n\\n    res[i] = rig ? rig : res[i];\\n  }\\n  return res;\\n};", "var nextGreaterElement = function(nums1, nums2) {\\n    if (nums1 === null || nums2 === null || nums1.length === 0 || nums2.length === 0) {\\n      return [];\\n    }\\n    let m     = new Map();\\n    let stack = [];\\n    let out   = [];\\n    for(let i=nums2.length-1; i>=0; i--){\\n        while(stack.length >0 && stack[stack.length-1] <=nums2[i]){\\n            stack.pop();\\n        }\\n        "]}
{"id": "104", "ref_js": ["var findWords = function(words) {\\n\\n  const rows = [/^[qwertyuiop]+$/, /^[asdfghjkl]+$/, /^[zxcvbnm]+$/];\\n  \\n  return words.filter(word => rows.some(row => row.test(word.toLowerCase())));\\n};", "var findWords = function(words) {\\n\\n  const rows = [/^[qwertyuiop]+$/, /^[asdfghjkl]+$/, /^[zxcvbnm]+$/];\\n  \\n  return words.filter(word => rows.some(row => row.test(word.toLowerCase())));\\n};", "var findWords = function(words) {\\n\\n  const rows = [/^[qwertyuiop]+$/, /^[asdfghjkl]+$/, /^[zxcvbnm]+$/];\\n  \\n  return words.filter(word => rows.some(row => row.test(word.toLowerCase())));\\n};"]}
{"id": "105", "ref_js": ["var findMode = function(root) {\\n    let currentVal = null;\\n    let currentCount = 0;\\n    let maxCount = 0;\\n    let modes = [];\\n\\n    function inOrderTraversal(node) {\\n        if (!node) return;\\n\\n        inOrderTraversal(node.left);\\n\\n        currentCount = (node.val === currentVal) ? currentCount + 1 : 1;\\n        if (currentCount === maxCount) {\\n            modes.push(node.val);\\n        } else if (currentCount > maxCount) {\\n            maxCount = currentCount;\\n            modes = [node.val];\\n        }\\n        currentVal = node.val;\\n\\n        inOrderTraversal(node.right);\\n    }\\n\\n    inOrderTraversal(root);\\n    return modes;\\n};", "var findMode = function(root) {\\n    const counts = {};", "var findMode = function(root) {\\n    let mode = [];\\n    let maxCount = 0;\\n    let prev = -1;\\n    let count = 0;\\n\\n    const inorder = function(node) {\\n        if (node === null) {\\n            return;\\n        }\\n\\n        inorder(node.left);\\n\\n        if (prev === -1) {\\n            prev = node.val;\\n            count = 1;\\n        } else if (prev === node.val) {\\n            count++;\\n        } else {\\n            prev = node.val;\\n            count = 1;\\n        }\\n\\n        if (count > maxCount) {\\n            maxCount = count;\\n            mode = [node.val];\\n        } else if (count === maxCount) {\\n            mode.push(node.val);\\n        }\\n\\n        inorder(node.right);\\n    };"]}
{"id": "106", "ref_js": ["var convertToBase7 = function(num) {\\n    if(num === 0) return \\'0\\';\\n    \\n    let temp = Math.abs(num);\\n    let res = \\'\\';\\n    \\n    while(temp !== 0){\\n        res = temp % 7 + res;\\n        temp = Math.floor(temp / 7);\\n    }\\n    \\n    return num >= 0 ? res : `-${res}`;\\n};", "var convertToBase7 = function(num) {\\n    return num.toString(7);\\n};", "var convertToBase7 = function(num) {\\n    if(num === 0) return \\'0\\';\\n    \\n    let temp = Math.abs(num);\\n    let res = \\'\\';\\n    \\n    while(temp !== 0){\\n        res = temp % 7 + res;\\n        temp = Math.floor(temp / 7);\\n    }\\n    \\n    return num >= 0 ? res : `-${res}`;\\n};"]}
{"id": "107", "ref_js": ["var findRelativeRanks = function(scores) {\\n    const prizes = [];\\n\\n    scores\\n        .reduce((acc, score, i) => {\\n            acc.push([score, i]);\\n            return acc;\\n        }, [])\\n        .sort(([a], [b]) => b - a)\\n        .forEach(([, index], i) => {\\n            prizes[index] = PRIZE_TITLES[i] ?? String(i + 1);\\n        });\\n    \\n    return prizes;\\n};", "var findRelativeRanks = function(score) {\\n    const hashmap = {};", "var findRelativeRanks = function(score) {\\n    const hashmap = {};"]}
{"id": "108", "ref_js": ["var checkPerfectNumber = function(num) {\\n    let count = 0;\\n\\n    for (let i = 1; i <= num / 2; i++) {\\n        if (num % i === 0) {\\n            count += i;\\n        }\\n    }\\n\\n    return num === count;\\n};", "var checkPerfectNumber = function(num) {\\n    var temp = 0;\\n    for(var i=1;i<=num/2;i++)\\n      {\\n          if(num%i === 0)\\n           {\\n             temp += i;\\n           }\\n      }\\n      if(temp === num && temp !== 0)\\n         {\\n        return true\\n         } \\n      else\\n         {\\n        return false\\n         }   \\n};", "var checkPerfectNumber = function(num) {\\n    if (num === 1) return false;\\n    let output = 0;\\n    \\n    for (let i = 2; i <= Math.sqrt(num); i++) {\\n        if (!(num%i)) {\\n            output += num/i !== i ? (num/i + i) : i;\\n        }\\n    }\\n    \\n    return output + 1 === num;\\n};"]}
{"id": "109", "ref_js": ["var fib = function(n) {\\n    if (n <= 1) {\\n        return n;\\n    }\\n    let fib_array = new Array(n+1).fill(0);\\n    fib_array[1] = 1;\\n    for (let i = 2; i <= n; i++) {\\n        fib_array[i] = fib_array[i-1] + fib_array[i-2];\\n    }\\n    return fib_array[n];\\n};", "var fib = function(n) {\\n    if(n<=1){\\n        return n;\\n    }\\n    return fib(n-1) + fib(n-2)\\n};", "var fib = function(n) {\\n    if(n<=1){\\n        return n;\\n    }\\n    return fib(n-1) + fib(n-2)\\n};"]}
{"id": "111", "ref_js": ["var detectCapitalUse = function(word) {\\n    return (word.toUpperCase()== word || word.slice(1) == word.slice(1).toLowerCase());\\n}\\n```\\n## Approach 2\\n### JavaScript Code\\n```\\n\\nvar detectCapitalUse = function(word) {\\n    let capital=0; let small=0;\\n    for(let c of word){\\n        ", "var detectCapitalUse = function(word) {\\n    return (word.toUpperCase()== word || word.slice(1) == word.slice(1).toLowerCase());\\n}\\n```\\n## Approach 2\\n### JavaScript Code\\n```\\n\\nvar detectCapitalUse = function(word) {\\n    let capital=0; let small=0;\\n    for(let c of word){\\n        ", "var detectCapitalUse = function(word) {\\n    return (word.toUpperCase()== word || word.slice(1) == word.slice(1).toLowerCase());\\n}\\n```\\n## Approach 2\\n### JavaScript Code\\n```\\n\\nvar detectCapitalUse = function(word) {\\n    let capital=0; let small=0;\\n    for(let c of word){\\n        "]}
{"id": "112", "ref_js": ["var findLUSlength = function(a, b) {\\n    return a === b ? -1 : Math.max(a.length, b.length);\\n};", "var findLUSlength = function(a, b) {\\n    return a == b ? -1: Math.max(a.length, b.length)\\n};", "var findLUSlength = function(a, b) {\\n    return a === b ? -1 : Math.max(a.length, b.length);\\n};"]}
{"id": "113", "ref_js": ["var getMinimumDifference = function (root) {\\n  let lowest = Infinity;\\n  let arr = [];\\n  iterate(root);\\n  function iterate(node) {\\n    if (!node) return;\\n    arr.push(node.val);\\n    iterate(node.left);\\n    iterate(node.right);\\n  }\\n  arr = arr.sort((a, b) => a - b);\\n  for (let i = 0; i < arr.length; i++) {\\n    if (arr[i - 1] !== undefined) {\\n      let val = arr[i] - arr[i - 1];\\n      if (val < lowest) lowest = val;\\n    }\\n  }\\n  return lowest;\\n};", "var getMinimumDifference = function(root) {\\n    let arr = [];\\n    function inOrder(node){\\n        if(node){\\n            inOrder(node.left);\\n            arr.push(node.val);\\n            inOrder(node.right);\\n        }\\n    }\\n    ", "var getMinimumDifference = function(root) {\\n    const DFS = (node, lo, hi) => {\\n        if (!node) return hi - lo;\\n        const left = DFS(node.left, lo, node.val);\\n        const right = DFS(node.right, node.val, hi);\\n        return Math.min(left, right);\\n    };"]}
{"id": "114", "ref_js": ["var reverseStr = function(s, k) {\\n     let arr=s.split(\"\");\\n     for(let i=1;i<s.length;i+=2*k){\\n         \\n         let jPointer=(i+k-2)\\n         let iPointer=i-1;\\n         while(jPointer>iPointer){\\n         let c=arr[iPointer];\\n         arr[iPointer++]=arr[jPointer];\\n         arr[jPointer--]=c\\n         }\\n     }\\n\\n     return arr.join(\"\");\\n};", "var reverseStr = function (s, k, arr = s.split(\"\"), k2 = k * 2) {\\n  for (let i = 0; i < arr.length - 1; i += k2) {\\n    swap(i, Math.min(i + k - 1, arr.length - 1));\\n  }\\n  return arr.join(\"\");\\n\\n  function swap(start, end) {\\n    while (start < end) {\\n      [arr[start], arr[end]] = [arr[end], arr[start]];\\n      start++;\\n      end--;\\n    }\\n  }\\n};", "var reverseStr = function(s, k) {\\n    const arrayString = s.split(\\'\\');\\n    \\n    if (!Math.floor(s.length/k)) return arrayString.reverse().join(\\'\\');\\n\\n    const unit = Math.floor(s.length/(2*k));\\n    \\n    for (let i = 0; i <= unit; i++) {\\n        const unitString = arrayString.slice(i*2*k, i*2*k + k);\\n        arrayString.splice(i*2*k, k, ...unitString.reverse());\\n    }\\n\\n    return arrayString.join(\\'\\');\\n};"]}
{"id": "115", "ref_js": ["var diameterOfBinaryTree = function(root) {\\n    let diameter = 0;\\n    \\n    dfs(root);\\n    \\n    return diameter;\\n    \\n    function dfs(node, level) {\\n        if (!node) return 0;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        ", "var diameterOfBinaryTree = function(root) {\\n    let diameter = 0;\\n    \\n    dfs(root);\\n    \\n    return diameter;\\n    \\n    function dfs(node, level) {\\n        if (!node) return 0;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        ", "var diameterOfBinaryTree = function(root) {\\n    let diameter = 0;\\n    \\n    dfs(root);\\n    \\n    return diameter;\\n    \\n    function dfs(node, level) {\\n        if (!node) return 0;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        "]}
{"id": "116", "ref_js": ["var checkRecord = function(s) {\\n  let absent = 0\\n  let ldays = 0\\n  for(let i=0;i<s.length;i++){\\n    if(s[i]==\\'A\\'){\\n      absent++\\n    } \\n  }\\n  for(let i =0;i<s.length;i++){\\n    if(s[i]==\\'L\\'){\\n      ldays+=1\\n      if(ldays>=3){\\n        return false\\n      }\\n    } else {\\n      ldays=0\\n    }\\n  }\\n  return absent<2\\n};", "var checkRecord = function(s) {\\n   let count = 0;\\n    let cons = 0;\\n    \\n    for(let i=0; i< s.length; i++){\\n        if(s[i] ===\"A\"){\\n            count++;\\n            cons =0;\\n        }\\n        if(count > 1) return false\\n        if(s[i] ===\"L\"){\\n            cons++;\\n        }else{\\n           cons =0; \\n        }\\n        if(cons > 2)return false\\n    }\\n    return true;\\n};", "var checkRecord = function(s) {\\n   let count = 0;\\n    let cons = 0;\\n    \\n    for(let i=0; i< s.length; i++){\\n        if(s[i] ===\"A\"){\\n            count++;\\n            cons =0;\\n        }\\n        if(count > 1) return false\\n        if(s[i] ===\"L\"){\\n            cons++;\\n        }else{\\n           cons =0; \\n        }\\n        if(cons > 2)return false\\n    }\\n    return true;\\n};"]}
{"id": "117", "ref_js": ["var reverseWords = function(s) {\\n        return s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n    }\\n```\\n``` PHP []\\nclass Solution {\\n    function reverseWords($s) {\\n        return implode(\\' \\', array_map(function($word) {\\n            return strrev($word);\\n        }, explode(\\' \\', $s)));\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        return String.Join(\" \", s.Split(\\' \\').Select(word => new string(word.Reverse().ToArray())));\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::string reverseWords(std::string s) {\\n        std::istringstream stream(s);\\n        std::string word, result;\\n        \\n        while (stream >> word) {\\n            std::reverse(word.begin(), word.end());\\n            result += word + \" \";\\n        }\\n        \\n        if (!result.empty()) {\\n            result.pop_back();  ", "var reverseWords = function(s) {\\n    const words = s.split(\\' \\'); \\n    for (let i = 0; i < words.length; i++) {\\n        words[i] = words[i].split(\\'\\').reverse().join(\\'\\');\\n    }\\n    return words.join(\\' \\');\\n};", "var reverseWords = function(s) {\\n    const words = s.split(\\' \\'); \\n    for (let i = 0; i < words.length; i++) {\\n        words[i] = words[i].split(\\'\\').reverse().join(\\'\\');\\n    }\\n    return words.join(\\' \\');\\n};"]}
{"id": "118", "ref_js": ["var maxDepth = function(root) {\\n    if (root == null)\\n        return 0;\\n    \\n    let maximumDepth = 0;\\n    for (let node of root.children){\\n        maximumDepth = Math.max(maximumDepth, maxDepth(node));\\n    }\\n    return maximumDepth + 1;\\n};", "var maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = 0;\\n    for(let child of root.children) {\\n       max = Math.max(max, maxDepth(child));\\n    }\\n    return max + 1;\\n}\\n```\\n**DFS Recursion with helper function:**\\n```\\n\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = -1;\\n    \\n    const helper = (node, depth) => {\\n        if(depth > max) max = depth;\\n        for(let c of node.children){\\n            helper(c, depth + 1);\\n        }\\n    }\\n    \\n    helper(root, 1)\\n    return max;\\n};", "var maxDepth = function(root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let child of root.children) {\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    \\n    return max + 1;\\n};"]}
{"id": "119", "ref_js": ["var arrayPairSum = function(nums) {\\n    return nums.sort((a,b)=>a-b).filter((e,i)=>i%2==0).reduce((ac,cu)=>ac+cu,0);\\n};", "var arrayPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var sum = 0\\n    for(var i = 0; i<nums.length; i+= 2){\\n        sum += nums[i]\\n    }\\n    return sum\\n};", "var arrayPairSum = function(nums) {\\n    nums = nums.sort((a,b) => a - b);\\n    let output = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        output += Math.min(nums[i], nums[i+1]);\\n        i++;\\n    }\\n    \\n    return output;\\n};"]}
{"id": "120", "ref_js": ["var findTilt = function(root) {\\n    const tilt = { val: 0 };", "var findTilt = function(root) {\\n    const tilt = { val: 0 };", "var findTilt = function (root) {\\n    let sumTilts = 0;\\n\\n    const dfs = function (node) {\\n        if (!node) return 0;\\n\\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n\\n        sumTilts += Math.abs(left - right);\\n\\n        return left + node.val + right;\\n    }\\n\\n    dfs(root);\\n    return sumTilts;\\n};"]}
{"id": "121", "ref_js": ["var matrixReshape = function(mat, r, c) {\\n    let rows = mat.length\\n    let cols = mat[0].length\\n    if(rows*cols !== r*c) return mat;\\n    let newMat = [[]];\\n\\n    for(let i = 0, k = 0; i < rows; i++) {\\n        for(let j = 0; j < cols; j++) {\\n            if(newMat[k].length === c) {\\n              newMat.push([]);\\n              k++;\\n            }\\n            newMat[k].push(mat[i][j])\\n        }  \\n    }\\n    return newMat;\\n};", "var matrixReshape = function(mat, r, c) {\\n    ", "var matrixReshape = function (nums, r, c) {\\n  var arr = nums.flat();\\n  if (r * c != arr.length) return nums;\\n\\n  var res = [];\\n  while (arr.length) res.push(arr.splice(0, c));\\n  return res;\\n};"]}
{"id": "122", "ref_js": ["var isSubtree = function(root, subRoot) {\\n\\t\\tif(subRoot === null)  return true;\\n\\t\\tif(root === null) return false;\\n\\n\\t\\tif (isSameTree(root, subRoot)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn (isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot));\\n\\t};", "var isSubtree = function(s, t) {\\n    return JSON.stringify(s).indexOf(JSON.stringify(t))!==-1\\n};", "var isSubtree = function(root, subRoot) {\\n\\t\\tif(subRoot === null)  return true;\\n\\t\\tif(root === null) return false;\\n\\n\\t\\tif (isSameTree(root, subRoot)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn (isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot));\\n\\t};"]}
{"id": "123", "ref_js": ["var distributeCandies = function(candyType) {\\n    const hashmap = {};", "var distributeCandies = function(candies) {\\n    return Math.min(new Set(candies).size, candies.length / 2);\\n};", "var distributeCandies = function(candyType) {\\n    const hashmap = {};"]}
{"id": "127", "ref_js": ["var preorder = function(root, output = []) {\\n    ", "var preorder = function(root) {\\n    ", "var preorder = function(root, ans=[]) {\\n    if (!root) return ans\\n    ans.push(root.val)\\n    for (let child of root.children)\\n        preorder(child, ans)\\n    return ans\\n};"]}
{"id": "128", "ref_js": ["var postorder = function(root) {\\n    ", "var postorder = function(root) {\\n    const res = [], stack = [root];\\n    while (stack.length) {\\n        const curr = stack.pop();\\n        if (!curr) continue;\\n        res.push(curr.val);\\n        stack.push(...curr.children);\\n    }\\n    return res.reverse();\\n};", "var postorder = function(root) {\\n    if (root === null) return [];\\n\\n    const stack = [ root ];\\n    const answer = [];\\n\\n    while (stack.length > 0) {\\n        let current = stack.pop();\\n        answer.push(current.val);\\n\\n        for (let child of current.children) {\\n            stack.push(child);\\n        }\\n\\n    };"]}
{"id": "129", "ref_js": ["var findLHS = function(nums) {\\n    let map= {};", "var findLHS = function(nums) {\\nlet map=new Map(),len=0;\\nfor (let i = 0, j = 0; i < nums.length; i++) map.set(nums[i], map.get(nums[i]) + 1 || 1);\\nfor (const [key,value] of map) if (map.get(key - 1)) len = Math.max(len, map.get(key - 1) + value);\\nreturn len; \\n};", "var findLHS = function(nums) {\\r\\n  const map = new Map();\\r\\n\\r\\n  "]}
{"id": "132", "ref_js": ["var maxCount = function(m, n, ops) {\\n    var min_row = m;\\n    var min_col = n;\\n    for (let i=0; i<ops.length; i++){\\n        if (ops[i][0]<min_row) min_row=ops[i][0];\\n        if (ops[i][1]<min_col) min_col=ops[i][1];\\n    }        \\n    return min_row*min_col;\\n};", "var maxCount = function(m, n, ops) {\\n    if (!ops.length) return m*n;\\n    \\n    let currentX = ops[0][0];\\n    let currentY = ops[0][1];\\n\\n    for (let i = 1; i < ops.length; i++) {\\n        if ((ops[i][0] >= currentX && ops[i][1] < currentY) || (ops[i][1] < currentY && ops[i][0] >= currentX)) {\\n            currentY = ops[i][1];\\n        }\\n        \\n        if ((ops[i][0] < currentX && ops[i][1] >= currentY) || (ops[i][1] >= currentY && ops[i][0] < currentX)) {\\n            currentX = ops[i][0];\\n        }\\n        \\n        if (ops[i][1] < currentY && ops[i][0] < currentX) {\\n            currentY = ops[i][1];\\n            currentX = ops[i][0];\\n        }\\n        \\n    }\\n    \\n    return currentX * currentY;\\n};", "var maxCount = function(m, n, ops) {\\n    return ops.reduce((r,x) => [Math.min(x[0],r[0]), Math.min(x[1],r[1])], [m,n]).reduce((r,x) => r*x, 1);\\n};"]}
{"id": "133", "ref_js": ["var findRestaurant = function (list1, list2) {\\n  let res = []\\n\\n  let leastIndex = 9999\\n\\n  for (let i = 0; i < list1.length; i++) {\\n    const j = list2.indexOf(list1[i])\\n\\n    if (j !== -1) {\\n      if (i + j < leastIndex) {\\n        res = [list1[i]]\\n        leastIndex = i + j\\n        continue\\n      }\\n      if (i + j === leastIndex) {\\n        res.push(list1[i])\\n        leastIndex = i + j\\n      }\\n    }\\n  }\\n\\n  return res\\n};", "var findRestaurant = function(list1, list2) {\\n    const hashmap = new Map();\\n    let output;\\n    \\n    for (let i = 0; i < list1.length; i++) {\\n        hashmap.set(list1[i], i);\\n    }\\n    \\n    for (let j = 0; j < list2.length; j++) {\\n        const isExist = hashmap.has(list2[j]);\\n        const indexOfRestaurant = hashmap.get(list2[j]);\\n        if (isExist && (!output || j + indexOfRestaurant < output.sumIndex)) {\\n            output = {\\n                value: [list2[j]],\\n                sumIndex: j + indexOfRestaurant,\\n            }\\n        } else if (isExist && j + indexOfRestaurant === output.sumIndex) {\\n            output.value.push(list2[j]);\\n        }\\n    }\\n    \\n    return output.value;\\n};", "var findRestaurant = function(list1, list2) {\\n    const hashmap = new Map();\\n    let output;\\n    \\n    for (let i = 0; i < list1.length; i++) {\\n        hashmap.set(list1[i], i);\\n    }\\n    \\n    for (let j = 0; j < list2.length; j++) {\\n        const isExist = hashmap.has(list2[j]);\\n        const indexOfRestaurant = hashmap.get(list2[j]);\\n        if (isExist && (!output || j + indexOfRestaurant < output.sumIndex)) {\\n            output = {\\n                value: [list2[j]],\\n                sumIndex: j + indexOfRestaurant,\\n            }\\n        } else if (isExist && j + indexOfRestaurant === output.sumIndex) {\\n            output.value.push(list2[j]);\\n        }\\n    }\\n    \\n    return output.value;\\n};"]}
{"id": "134", "ref_js": ["var canPlaceFlowers = function(flowerbed, n) {\\n    let count = 0;\\n    let pre = -1;\\n    let next = 1;\\n\\n    for (let i = 0; i < flowerbed.length; i++, pre++, next++) {\\n        if ((getValue(flowerbed, pre) + getValue(flowerbed, i) + getValue(flowerbed, next)) == 0) {\\n            flowerbed[i] = 1;\\n            count++;\\n        }\\n    }\\n\\n    return count >= n;\\n};", "var canPlaceFlowers = function(flowerbed, n) {\\n    \\n    for(let i=0;i<flowerbed.length;i++){\\n        if(n==0) return true;\\n        let prev = i>0?flowerbed[i-1]: 0\\n        let next = i<flowerbed.length-1?flowerbed[i+1]: 0\\n        \\n        if(prev!=1 && next!=1 && flowerbed[i]!=1){\\n            flowerbed[i] = 1;\\n            n--;\\n        }\\n    }\\n\\n    return n<=0 \\n};", "var canPlaceFlowers = function(flowerbed, n) {\\n    flowerbed = [0, ...flowerbed, 0];\\n    for(let i = 1; i < flowerbed.length - 1; ++i) {\\n        if(flowerbed[i - 1] === 0 && flowerbed[i] === 0 && flowerbed[i + 1] === 0) {\\n            flowerbed[i] = 1;\\n            --n;\\n        }\\n        if(n === 0)\\n            return true;\\n    }\\n    return n <= 0;\\n};"]}
{"id": "135", "ref_js": ["var tree2str = function(root) {\\n    ", "var tree2str = function(t) {\\n    let res = [];\\n    dfs(t, res);\\n    return res.join(\\'\\');\\n\\n    function dfs(t, res) {\\n        if (t === null)\\n            return;\\n\\n        res.push(t.val);\\n\\n        if (t.left === null && t.right === null)\\n            return;\\n\\n        res.push(\\'(\\');\\n        dfs(t.left, res);\\n        res.push(\\')\\');\\n\\n        if (t.right !== null) {\\n            res.push(\\'(\\');\\n            dfs(t.right, res);\\n            res.push(\\')\\');\\n        }\\n    }\\n};", "var tree2str = function(root) {\\n    "]}
{"id": "138", "ref_js": ["var mergeTrees = function (root1, root2) {\\n    if (!root1) return root2;\\n    else if (!root2) return root1;\\n    else {\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1\\n    }\\n};", "var mergeTrees = function (root1, root2) {\\n  if (!root1) return root2;\\n  if (!root2) return root1;\\n\\n  const queue = [[root1, root2]];\\n\\n  while (queue.length) {\\n    const [node1, node2] = queue.shift();\\n\\n    node1.val += node2.val;\\n\\n    ", "var mergeTrees = function (root1, root2) {\\n    if (!root1) return root2;\\n    else if (!root2) return root1;\\n    else {\\n        root1.val += root2.val;\\n        root1.left = mergeTrees(root1.left, root2.left);\\n        root1.right = mergeTrees(root1.right, root2.right);\\n        return root1\\n    }\\n};"]}
{"id": "142", "ref_js": ["var maximumProduct = function(nums) {\\n  let max1 = -Infinity;\\n  let max2 = -Infinity;\\n  let max3 = -Infinity;\\n  let min2 = Infinity;\\n  let min1 = Infinity;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > max1) {\\n      [max1, max2, max3] = [nums[i], max1, max2];\\n    } else if (nums[i] > max2) {\\n      [max2, max3] = [nums[i], max2];\\n    } else if (nums[i] > max3) {\\n      max3 = nums[i];\\n    }\\n    if (nums[i] < min1) {\\n      [min2, min1] = [min1, nums[i]];\\n    } else if (nums[i] < min2) {\\n      min2 = nums[i];\\n    }\\n  }\\n  return Math.max(max1 * max2 * max3, max1 * min1 * min2);\\n};", "var maximumProduct = function(nums) {\\n    nums = nums.sort((a,b) => b-a)\\n    return Math.max(nums[0]*nums[1]*nums[2], nums[nums.length-1]*nums[nums.length-2]*nums[0])\\n};", "var maximumProduct = function(nums) {\\n    nums = nums.sort((a,b) => b-a)\\n    return Math.max(nums[0]*nums[1]*nums[2], nums[nums.length-1]*nums[nums.length-2]*nums[0])\\n};"]}
{"id": "143", "ref_js": ["var averageOfLevels = function(root) {\\n    let q = [root], ans = []\\n    while (q.length) {\\n        let qlen = q.length, row = 0\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = q.shift()\\n            row += curr.val\\n            if (curr.left) q.push(curr.left)\\n            if (curr.right) q.push(curr.right)\\n        }\\n        ans.push(row/qlen)\\n    }\\n    return ans\\n};", "var averageOfLevels = function(root) {\\n    let list = []\\n    let count = []\\n    function level_sum(root, level){\\n        if(root == null)    return\\n        if(list.length <= level){\\n            list.push(0.00)\\n            count.push(0)\\n        }\\n        list[level] += root.val;\\n        count[level] += 1\\n        level_sum(root.left, level+1)\\n        level_sum(root.right, level+1)\\n    }\\n    level_sum(root, 0)\\n    for(let level=0; level<list.length; level++){\\n        list[level] = list[level] / count[level]\\n    }\\n    return list\\n};", "var averageOfLevels = function(root) {\\n    \\n    const queue = [root];\\n    \\n    let temp = [];\\n    \\n    const ans = [];\\n    \\n    let sum = 0, count = 0;\\n    \\n    while(queue.length > 0){\\n        \\n        let curr = queue.shift();\\n        \\n        sum += curr.val;\\n        \\n        count += 1;\\n        \\n        if(curr.left) temp.push(curr.left);\\n        \\n        if(curr.right) temp.push(curr.right);\\n        \\n        if(queue.length == 0){\\n\\n            ans.push(sum / count);\\n\\n            sum = 0;\\n\\n            count = 0;\\n\\n            queue.push(...temp);\\n\\n            temp = [];\\n\\n        }\\n        \\n    }\\n    \\n    return ans;\\n    \\n};"]}
{"id": "144", "ref_js": ["var findMaxAverage = function(nums, k) {\\n    let currSum = nums.slice(0 , k).reduce((r, n) => r + n, 0);\\n    let bestSum = currSum;\\n    for (let i = 1; i < nums.length - k + 1; i++) {\\n        currSum = currSum - nums[i - 1] + nums[i + k - 1]\\n        bestSum = Math.max(bestSum, currSum);\\n    }\\n    return bestSum / k;\\n};", "var findMaxAverage = function(nums, k) {\\n    let averageValue = -Infinity\\n    let left = 0\\n    let sum = 0\\n    for(let right = 0; right < nums.length; right++){\\n        sum += nums[right]\\n        if(right - left +1 === k){\\n            averageValue = Math.max(averageValue, sum/k)\\n    \\n            sum -= nums[left]\\n            left++\\n        }\\n    }\\n    return averageValue\\n};", "var findMaxAverage = function (nums, k) {\\n  let total = 0;\\n  let leftPtr = 0;\\n  let maxAvg = Number.NEGATIVE_INFINITY;\\n  for (let rightPtr = 0; rightPtr < nums.length; rightPtr++) {\\n    total += nums[rightPtr];\\n\\n    if (rightPtr - leftPtr + 1 > k) {\\n      total -= nums[leftPtr];\\n      leftPtr++;\\n    }\\n    if (rightPtr - leftPtr + 1 === k) {\\n      maxAvg = Math.max(maxAvg, total / k);\\n    }\\n  }\\n  return maxAvg;\\n};"]}
{"id": "145", "ref_js": ["var findErrorNums = function(nums) {\\n    ", "var findErrorNums = function(nums) {\\n    let N = nums.length, dupe, sum = N * (N + 1) / 2,\\n        seen = new Uint8Array(N+1)\\n    for (let i = 0; i < N; i++) {\\n        let num = nums[i]\\n        sum -= num\\n        if (seen[num]) dupe = num\\n        seen[num]++\\n    }\\n    return [dupe, sum + dupe]\\n};", "var findErrorNums = function(nums) {\\n    let sum = (nums.length * (nums.length + 1)) / 2;\\n    let dup = 0;\\n    let arr = Array(nums.length).fill(0);\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (arr[nums[i] - 1] === nums[i]) dup = nums[i];\\n        else {\\n            arr[nums[i] - 1] = nums[i];\\n            sum -= nums[i];\\n        }\\n    }\\n\\n    return [dup, sum];\\n};"]}
{"id": "146", "ref_js": ["var findTarget = function(root, k) {\\n    let set = new Set();\\n    return calc(root, k, set);\\n};", "var findTarget = function (root, k) {\\n\\n\\n    function search(root, elem) {\\n        if (!root) {\\n            return false\\n        }\\n        if (root.val === elem) {\\n            return true\\n        }\\n\\n        if (root.val < elem) {\\n            return search(root.right, elem)\\n        }\\n\\n        if (root.val > elem) {\\n            return search(root.left, elem)\\n        }\\n\\n    }\\n\\n    function find(root, k, parent) {\\n        if (!root) {\\n            return false\\n        }\\n\\n        let elem = k - root.val\\n\\n        let isPresent = search(parent, elem)\\n        if (elem === root.val) {\\n            return find(root.left, k, parent) || find(root.right, k, parent)\\n\\n        }\\n        if (isPresent) {\\n            return true\\n        } else {\\n            return find(root.left, k, parent) || find(root.right, k, parent)\\n\\n        }\\n\\n    }\\n\\n    return find(root, k, root)\\n\\n};", "var findTarget = function(root, k) {\\n    let set = new Set();\\n    return calc(root, k, set);\\n};"]}
{"id": "147", "ref_js": ["var judgeCircle = function(moves) {\\n    let start = [0, 0]\\n    let directions = {\\n        \\'U\\': [0, 1],\\n        \\'D\\': [0, -1],\\n        \\'L\\': [-1, 0],\\n        \\'R\\': [1, 0]\\n    }\\n    for(let i = 0; i < moves.length; i++) {\\n        start[0] += directions[moves[i]][0]\\n        start[1] += directions[moves[i]][1]\\n    }\\n    return start[0] == 0 && start[1] == 0\\n};", "var judgeCircle = function(str) {\\n    let horizontal = 0;\\n    let vertical = 0;\\n    for (let i = 0; i < str.length; i++) {\\n        if (str[i] === \\'L\\') ++horizontal;\\n        if (str[i] === \\'R\\') --horizontal;\\n        if (str[i] === \\'U\\') ++vertical;\\n        if (str[i] === \\'D\\') --vertical;\\n    }\\n\\n    return horizontal === 0 && vertical === 0\\n};", "var judgeCircle = function(moves) {\\n    let start = [0, 0]\\n    let directions = {\\n        \\'U\\': [0, 1],\\n        \\'D\\': [0, -1],\\n        \\'L\\': [-1, 0],\\n        \\'R\\': [1, 0]\\n    }\\n    for(let i = 0; i < moves.length; i++) {\\n        start[0] += directions[moves[i]][0]\\n        start[1] += directions[moves[i]][1]\\n    }\\n    return start[0] == 0 && start[1] == 0\\n};"]}
{"id": "148", "ref_js": ["var imageSmoother = function(img) {\\n    const m = img.length;\\n    const n = img[0].length;\\n    const res = new Array(m).fill(0).map(() => new Array(n).fill(0));\\n\\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            res[i][j] = smoothen(img, i, j);\\n        }\\n    }\\n\\n    return res;\\n};", "var imageSmoother = function(img) {\\n    const rows = img.length;\\n    const cols = img[0].length;\\n    const result = new Array(rows);\\n\\n    for (let i = 0; i < rows; ++i) {\\n        result[i] = new Array(cols);\\n\\n        for (let j = 0; j < cols; ++j) {\\n            let totalSum = 0;\\n            let count = 0;\\n\\n            for (let x = Math.max(0, i - 1); x < Math.min(rows, i + 2); ++x) {\\n                for (let y = Math.max(0, j - 1); y < Math.min(cols, j + 2); ++y) {\\n                    totalSum += img[x][y];\\n                    count += 1;\\n                }\\n            }\\n\\n            result[i][j] = Math.floor(totalSum / count);\\n        }\\n    }\\n\\n    return result;\\n};", "var imageSmoother = function(img) {\\n    const rows = img.length;\\n    const cols = img[0].length;\\n\\n    "]}
{"id": "149", "ref_js": ["var findSecondMinimumValue = function(root) {\\n   let small1 = Infinity;\\n   let  small2 = Infinity;\\n\\n   function traverse(node){\\n       if(node?.val < small1) small1 = node.val;\\n       if(node?.val < small2 && node.val !== small1){\\n           small2 = node.val;\\n       }\\n       if(node.left) traverse(node.left);\\n       if(node.right) traverse(node.right);\\n   }\\n   traverse(root);\\n   if(small2 === Infinity) return -1;\\n   return small2;\\n};", "var findSecondMinimumValue = function(root) {\\n   let small1 = Infinity;\\n   let  small2 = Infinity;\\n\\n   function traverse(node){\\n       if(node?.val < small1) small1 = node.val;\\n       if(node?.val < small2 && node.val !== small1){\\n           small2 = node.val;\\n       }\\n       if(node.left) traverse(node.left);\\n       if(node.right) traverse(node.right);\\n   }\\n   traverse(root);\\n   if(small2 === Infinity) return -1;\\n   return small2;\\n};", "var findSecondMinimumValue = function(root) {\\n   let small1 = Infinity;\\n   let  small2 = Infinity;\\n\\n   function traverse(node){\\n       if(node?.val < small1) small1 = node.val;\\n       if(node?.val < small2 && node.val !== small1){\\n           small2 = node.val;\\n       }\\n       if(node.left) traverse(node.left);\\n       if(node.right) traverse(node.right);\\n   }\\n   traverse(root);\\n   if(small2 === Infinity) return -1;\\n   return small2;\\n};"]}
{"id": "150", "ref_js": ["var findLengthOfLCIS = function(nums) {\\n    let output = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!count || nums[i] > nums[i - 1]) {\\n            count++;\\n        } else {\\n            output = Math.max(output, count);\\n            count = 1;\\n        }\\n    }\\n    \\n    return Math.max(output, count);\\n};", "var findLengthOfLCIS = function(nums) {\\n    let max = 0, curr = 0\\n    for(let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] < nums[i + 1]) {\\n            curr++\\n            max = Math.max(max, curr)\\n        } else {\\n            curr = 0\\n        }\\n    }\\n    return max > 0 ? max + 1 : 1\\n};", "var findLengthOfLCIS = function(nums) {\\n    let count = 1;\\n    let max = 1;\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] < nums[i+1]){\\n            count++;\\n            if(count > max) {\\n                max = count;\\n            }\\n        } else {\\n            count = 1;\\n        }\\n    }\\n    return max;\\n};"]}
{"id": "151", "ref_js": ["var validPalindrome = function(s) {\\n    let low = 0, high = s.length-1;\\n    while (low < high) {\\n        if (s[low] !== s[high]) {\\n            return isPalindrome(s, low+1, high) || isPalindrome(s, low, high-1);\\n        }\\n        low++, high--;\\n    }\\n    return true;\\n    ", "var validPalindrome = function(s, corrections = 1) {\\n  let lo = 0;\\n  let hi = s.length - 1;\\n  \\n  while (lo < hi) {\\n    if (s[lo] === s[hi]) {\\n      lo++;\\n      hi--;\\n      continue;\\n    }\\n    \\n    if (corrections === 0) {\\n      return false;\\n    }\\n    \\n    return validPalindrome(s.slice(lo, hi), 0) \\n      || validPalindrome(s.slice(lo + 1, hi + 1), 0);\\n  }\\n  \\n  return true;\\n};", "var validPalindrome = function(s, corrections = 1) {\\n  let lo = 0;\\n  let hi = s.length - 1;\\n  \\n  while (lo < hi) {\\n    if (s[lo] === s[hi]) {\\n      lo++;\\n      hi--;\\n      continue;\\n    }\\n    \\n    if (corrections === 0) {\\n      return false;\\n    }\\n    \\n    return validPalindrome(s.slice(lo, hi), 0) \\n      || validPalindrome(s.slice(lo + 1, hi + 1), 0);\\n  }\\n  \\n  return true;\\n};"]}
{"id": "152", "ref_js": ["var calPoints = function(operations) {\\n    let arr = []\\n    operations.reverse()\\n    while(operations.length) {\\n        let curr = operations.pop()\\n        if(curr == \\'C\\') arr.pop()\\n        if(curr == \\'D\\') {\\n            let num = 2 * arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr == \\'+\\') {\\n            let num = arr[arr.length - 2] + arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr !== \\'+\\' && curr !== \\'D\\' && curr !== \\'C\\') {\\n            arr.push(curr * 1)\\n        }\\n    }\\n    let sum = 0\\n    console.log(arr)\\n    arr.forEach((el) => {\\n        sum += el\\n    })\\n    return sum\\n};", "var calPoints = function(ops) {\\n    let arr = [];\\n\\n    for (let i = 0; i < ops.length; i++) {\\n        if (ops[i] == \\'C\\') {\\n            arr.pop();\\n            continue;\\n        }\\n        if (ops[i] == \\'D\\') {\\n            arr.push(arr[arr.length - 1] * 2);\\n            continue;\\n        }\\n        if (ops[i] == \\'+\\') {\\n            arr.push((arr[arr.length - 2]) + arr[arr.length - 1]);\\n            continue;\\n        }\\n        ops[i] = +ops[i];\\n        if (Number.isInteger(ops[i])) {\\n            arr.push(ops[i]);\\n        }\\n    }\\n    return arr.reduce((a, b) => a + b, 0);\\n};", "var calPoints = function(operations) {\\n    let arr = []\\n    operations.reverse()\\n    while(operations.length) {\\n        let curr = operations.pop()\\n        if(curr == \\'C\\') arr.pop()\\n        if(curr == \\'D\\') {\\n            let num = 2 * arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr == \\'+\\') {\\n            let num = arr[arr.length - 2] + arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr !== \\'+\\' && curr !== \\'D\\' && curr !== \\'C\\') {\\n            arr.push(curr * 1)\\n        }\\n    }\\n    let sum = 0\\n    console.log(arr)\\n    arr.forEach((el) => {\\n        sum += el\\n    })\\n    return sum\\n};"]}
{"id": "153", "ref_js": ["var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};", "var twoSum = function(nums, target) {\\n    const numToIndex = new Map(); ", "var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};"]}
{"id": "154", "ref_js": ["var countBinarySubstrings = function(s) {\\n    let curr = 1, prev = 0, ans = 0\\n    for (let i = 1; i < s.length; i++)\\n        if (s[i] === s[i-1]) curr++\\n        else ans += Math.min(curr, prev), prev = curr, curr = 1\\n    return ans + Math.min(curr, prev)\\n};", "var countBinarySubstrings = function(s) {\\n    let prev = 0; ", "var countBinarySubstrings = function(s) {\\n    let prev = 0; "]}
{"id": "155", "ref_js": ["var findShortestSubArray = function(nums) {\\n    ", "var findShortestSubArray = function(nums) {\\n    ", "var findShortestSubArray = function(nums) {\\n    "]}
{"id": "156", "ref_js": ["var searchBST = function(root, val) {\\n    let res = null;\\n    const helper = (node) => {\\n        if(!node) return;\\n        if(node.val === val){\\n            res = node;\\n            return;\\n        }\\n        if(val < node.val) helper(node.left)\\n        if(val > node.val) helper(node.right)\\n    }\\n    \\n    helper(root);   \\n    return res;\\n};", "var searchBST = function(root, val) {\\n    let res = null;\\n    const helper = (node) => {\\n        if(!node) return;\\n        if(node.val === val){\\n            res = node;\\n            return;\\n        }\\n        if(val < node.val) helper(node.left)\\n        if(val > node.val) helper(node.right)\\n    }\\n    \\n    helper(root);   \\n    return res;\\n};", "var searchBST = function(root, val) {\\n    let res = null;\\n    const helper = (node) => {\\n        if(!node) return;\\n        if(node.val === val){\\n            res = node;\\n            return;\\n        }\\n        if(val < node.val) helper(node.left)\\n        if(val > node.val) helper(node.right)\\n    }\\n    \\n    helper(root);   \\n    return res;\\n};"]}
{"id": "158", "ref_js": ["var search = function(nums, target) {\\n    let lo = 0, hi = nums.length-1;\\n    while (lo < hi) {\\n        let mid = lo + Math.floor((hi-lo+1)/2);\\n        if (target < nums[mid]) {\\n            hi = mid - 1\\n        } else {\\n            lo = mid; \\n        }\\n    }\\n    return nums[lo]==target?lo:-1;\\n};", "var search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length-1;\\n\\n    while(left<=right){\\n        const mid = left + Math.floor((right-left)/2);\\n        const guess = nums[mid];\\n\\n        if(guess === target){\\n            return mid\\n        }\\n\\n        if(guess>target){\\n            right = mid-1;\\n        }else{\\n            left = mid+1;\\n        }\\n    }\\n    return -1\\n};", "var search = function(nums, target) {\\n    let lo = 0, hi = nums.length-1;\\n    while (lo < hi) {\\n        let mid = lo + Math.floor((hi-lo+1)/2);\\n        if (target < nums[mid]) {\\n            hi = mid - 1\\n        } else {\\n            lo = mid; \\n        }\\n    }\\n    return nums[lo]==target?lo:-1;\\n};"]}
{"id": "161", "ref_js": ["var toLowerCase = function(s) {\\n    let ans = \"\"\\n    for (let c of s) {\\n        let n = c.charCodeAt()\\n        ans += n > 64 && n < 91 ? String.fromCharCode(n + 32) : c \\n    }\\n    return ans\\n};", "var toLowerCase = function(s) {\\n    let ans = \"\"\\n    for (let c of s) {\\n        let n = c.charCodeAt()\\n        ans += n > 64 && n < 91 ? String.fromCharCode(n + 32) : c \\n    }\\n    return ans\\n};", "var toLowerCase = function(s) {\\n    let ans = \"\"\\n    for (let c of s) {\\n        let n = c.charCodeAt()\\n        ans += n > 64 && n < 91 ? String.fromCharCode(n + 32) : c \\n    }\\n    return ans\\n};"]}
{"id": "162", "ref_js": ["var isOneBitCharacter = function(bits) {\\n    let result = false;\\n    let i = 0;\\n    while(i < bits.length){\\n        if(bits[i] === 0) {\\n            i++;\\n            result = true;\\n        } else {\\n            i += 2;\\n            result = false;\\n        }\\n    }\\n    return result;\\n};", "var isOneBitCharacter = function(bits) {\\n    let i=0;\\n\\n    while (i < bits.length) {\\n        ", "var isOneBitCharacter = function(bits) {\\n    let i = 0;\\n\\n    while(i < bits.length - 2){\\n        if(bits[i] === 1) i++;\\n        i++;\\n    }\\n    return bits[i] === 0;\\n};"]}
{"id": "163", "ref_js": ["var pivotIndex = function(nums) {\\n\\n\\n    let sum = nums.reduce(function (a,b) { return a+b;}); ", "var pivotIndex = function(nums) {\\n    \\n\\n    ", "var pivotIndex = function(nums) {\\n\\n\\n    let sum = nums.reduce(function (a,b) { return a+b;}); "]}
{"id": "164", "ref_js": ["var selfDividingNumbers = function(left, right) {\\n    const output = [];\\n    \\n    const isDivingNumber = (number) => {\\n        const string = number.toString();\\n        for (let i = 0; i < string.length; i++) {\\n            if (string[i] === \\'0\\' || number % Number(string[i])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    for (let i = left; i <= right; i++) {\\n        if (isDivingNumber(i)) output.push(i);\\n    }\\n    \\n    return output;\\n};", "var selfDividingNumbers = function(left, right) {\\n    let arr = []\\n    while(left <= right) {\\n        ", "var selfDividingNumbers = function(left, right) {\\n    const output = [];\\n    \\n    const isDivingNumber = (number) => {\\n        const string = number.toString();\\n        for (let i = 0; i < string.length; i++) {\\n            if (string[i] === \\'0\\' || number % Number(string[i])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    for (let i = left; i <= right; i++) {\\n        if (isDivingNumber(i)) output.push(i);\\n    }\\n    \\n    return output;\\n};"]}
{"id": "165", "ref_js": ["var floodFill = function(image, sr, sc, color) {\\n\\n    const queue = new Queue()\\n\\n    queue.enqueue([sr, sc])\\n    \\n    const curCol = image[sr][sc]\\n\\n    const rowList = [1,0,0,-1]\\n    const colList = [0,1,-1,0]\\n\\n    const rowLen = image.length\\n    const colLen = image[0].length;\\n\\n    image[sr][sc] = color\\n\\n    if(color === curCol) return image\\n\\n    while(!queue.isEmpty()){\\n        const [row, col] = queue.dequeue()\\n\\n        for(let i=0; i < 4; i++){\\n            const deltaRow = row + rowList[i]\\n            const deltaCol = col + colList[i]\\n\\n            if(deltaRow < 0 || deltaCol < 0 || deltaRow >= rowLen || \\n                deltaCol >= colLen ) continue;\\n\\n            if(deltaRow === row && deltaCol === col) continue;\\n            if(image[deltaRow][deltaCol] === curCol){\\n                image[deltaRow][deltaCol] = color\\n                queue.enqueue([deltaRow, deltaCol])\\n            }\\n        }\\n\\n    }\\n\\n    return image\\n};", "var floodFill = function(image, sr, sc, color) {\\n    ", "var floodFill = function(image, sr, sc, color) {\\n    "]}
{"id": "166", "ref_js": ["var nextGreatestLetter = function(letters, target) {\\n    let set = new Set(letters)\\n    for(let c of set){\\n        if(c>target) return c\\n    }\\n    return letters[0]\\n};", "var nextGreatestLetter = function(letters, target) {\\n    for (let i = 0; i < letters.length; i++) {\\n        if (letters[i].charCodeAt(0) > target.charCodeAt(0)) return letters[i];\\n    }\\n    \\n    return letters[0];\\n};", "var nextGreatestLetter = function(letters, target) {\\n    const N = letters.length; let l = 0, r = N;\\n    \\n    while(l < r) {\\n        let mid = l + (r-l >> 1);\\n\\t\\t"]}
{"id": "167", "ref_js": ["var minCostClimbingStairs = function(cost) {\\n    cost.push(0);\\n\\n    for (let i = cost.length - 4; i >= 0; i--) {\\n        cost[i] += Math.min(cost[i + 1], cost[i + 2]);\\n    }\\n\\n    return Math.min(cost[0], cost[1]);    \\n};", "var minCostClimbingStairs = function(cost) {\\n    cost.push(0);\\n\\n    for (let i = cost.length - 4; i >= 0; i--) {\\n        cost[i] += Math.min(cost[i + 1], cost[i + 2]);\\n    }\\n\\n    return Math.min(cost[0], cost[1]);    \\n};", "var minCostClimbingStairs = function(cost) {\\n    cost.push(0);\\n\\n    for (let i = cost.length - 4; i >= 0; i--) {\\n        cost[i] += Math.min(cost[i + 1], cost[i + 2]);\\n    }\\n\\n    return Math.min(cost[0], cost[1]);    \\n};"]}
{"id": "168", "ref_js": ["var dominantIndex = function(nums) {\\n  let arr=[...nums];\\n\\n  arr.sort((a,b)=>a-b);\\n if( arr[arr.length-1]>=arr[arr.length-2]*2){\\n     return nums.indexOf(arr[arr.length-1]);\\n }else{\\n     return -1\\n } \\n\\n\\n};", "var dominantIndex = function(nums) {\\n    let max = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > max) {\\n            max = nums[i];\\n        }\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] * 2 > max && nums[i] !== max) {\\n            return -1;\\n        }\\n    }\\n\\n    return nums.indexOf(max);\\n};", "var dominantIndex = function(nums) {\\n    const hashmap = {};"]}
{"id": "169", "ref_js": ["var shortestCompletingWord = function(licensePlate, words) {\\n    const hashmap = new Map();\\n    let output;\\n\\n    for (let i = 0; i < licensePlate.length; i++) {\\n        const character = licensePlate[i];\\n        if (regex.test(character)) {\\n            const key = character.toLowerCase();\\n            hashmap.set(key, hashmap.has(key) ? hashmap.get(key) + 1 : 1)\\n        }\\n    }\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const newHashmap = cloneMap(hashmap);\\n        for (let j = 0; j < words[i].length; j++) {\\n            const word = words[i][j];\\n            if (newHashmap.has(word)) {\\n                newHashmap.set(word, newHashmap.get(word) - 1);\\n                if (!newHashmap.get(word)) newHashmap.delete(word);\\n            }\\n            if (!newHashmap.size) {\\n                if (!output || words[i].length < output.length) output = words[i];\\n                break;\\n            }\\n        }\\n    }\\n\\n    return output;\\n};", "var shortestCompletingWord = function(licensePlate, words) {\\n    const hashmap = new Map();\\n    let output;\\n\\n    for (let i = 0; i < licensePlate.length; i++) {\\n        const character = licensePlate[i];\\n        if (regex.test(character)) {\\n            const key = character.toLowerCase();\\n            hashmap.set(key, hashmap.has(key) ? hashmap.get(key) + 1 : 1)\\n        }\\n    }\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const newHashmap = cloneMap(hashmap);\\n        for (let j = 0; j < words[i].length; j++) {\\n            const word = words[i][j];\\n            if (newHashmap.has(word)) {\\n                newHashmap.set(word, newHashmap.get(word) - 1);\\n                if (!newHashmap.get(word)) newHashmap.delete(word);\\n            }\\n            if (!newHashmap.size) {\\n                if (!output || words[i].length < output.length) output = words[i];\\n                break;\\n            }\\n        }\\n    }\\n\\n    return output;\\n};", "var shortestCompletingWord = function(licensePlate, words) {\\n    const hashmap = new Map();\\n    let output;\\n\\n    for (let i = 0; i < licensePlate.length; i++) {\\n        const character = licensePlate[i];\\n        if (regex.test(character)) {\\n            const key = character.toLowerCase();\\n            hashmap.set(key, hashmap.has(key) ? hashmap.get(key) + 1 : 1)\\n        }\\n    }\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const newHashmap = cloneMap(hashmap);\\n        for (let j = 0; j < words[i].length; j++) {\\n            const word = words[i][j];\\n            if (newHashmap.has(word)) {\\n                newHashmap.set(word, newHashmap.get(word) - 1);\\n                if (!newHashmap.get(word)) newHashmap.delete(word);\\n            }\\n            if (!newHashmap.size) {\\n                if (!output || words[i].length < output.length) output = words[i];\\n                break;\\n            }\\n        }\\n    }\\n\\n    return output;\\n};"]}
{"id": "170", "ref_js": ["var countPrimeSetBits = function (left, right) {\\n    ", "var countPrimeSetBits = function(left, right) {\\n    arr = [2, 3, 5, 7, 11, 13, 17, 19]\\n    prime = 0\\n\\n    for (let i = left; i <= right; i++) {\\n        if (arr.indexOf(i.toString(2).replaceAll(0,\\'\\').length) >= 0) prime ++\\n    }\\n\\n    return prime\\n};", "var countPrimeSetBits = function(left, right) {\\n   let primes = [2, 3, 5, 7, 11, 13, 17, 19];\\n   let count = 0;\\n\\n   for(let i = left; i <= right; i++){\\n    let setBitCount = [...i.toString(2)].reduce((s, c) => s + +c, 0);\\n    if(primes.includes(setBitCount)) count++;\\n   }    \\n   return count;\\n};"]}
{"id": "171", "ref_js": ["var isToeplitzMatrix = function(matrix) {\\n    for (let i = 1; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            if (matrix[i-1][j - 1] !== undefined && matrix[i][j] !== matrix[i-1][j - 1]) return false;\\n        }\\n    }\\n    return true;\\n};", "var isToeplitzMatrix = function(matrix) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    \\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 1; j < n; j++) {\\n            if (matrix[i][j] != matrix[i - 1][j - 1]) return false;\\n        }     \\n    }\\n\\t\\n    return true;\\n};", "var isToeplitzMatrix = function(matrix) {\\n    for (let i=0; i < matrix.length-1; i++) {\\n        for (let j=0; j < matrix[i].length-1; j++) {    \\n            if (matrix[i][j] !== matrix[i+1][j+1]) {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n};"]}
{"id": "172", "ref_js": ["var numJewelsInStones = function (jewels, stones) {\\n  let res = 0;\\n\\n  for (let index = 0; index < jewels.length; index++) {\\n    let re = new RegExp(jewels[index], \"g\");\\n    if (stones.match(re) != null) res += stones.match(re).length;\\n  }\\n\\n  return res;\\n};", "var numJewelsInStones = function(jewels, stones) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < jewels.length; i++) {\\n        const jewel = jewels[i];\\n        hashmap.set(jewel, i);\\n    }\\n    \\n    for (let i = 0; i < stones.length; i++) {\\n        const stone = stones[i];\\n        if(hashmap.has(stone)) output++;\\n    }\\n    \\n    return output;\\n};", "var numJewelsInStones = function(jewels, stones) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < jewels.length; i++) {\\n        const jewel = jewels[i];\\n        hashmap.set(jewel, i);\\n    }\\n    \\n    for (let i = 0; i < stones.length; i++) {\\n        const stone = stones[i];\\n        if(hashmap.has(stone)) output++;\\n    }\\n    \\n    return output;\\n};"]}
{"id": "173", "ref_js": ["var minDiffInBST = function(root) {\\n    ", "var minDiffInBST = function(root) {\\n    ", "var minDiffInBST = function(root) {\\n    "]}
{"id": "174", "ref_js": ["var rotateString = function(s, goal) {\\n    if (s.length !== goal.length) return false;\\n    return s.concat(s).includes(goal);\\n};", "var rotate = function(nums, k) {\\n    const temp = [...nums];\\n    if (k >= nums.length) {\\n        k = k % nums.length;\\n    }\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        nums[i + k > nums.length - 1 ? (i + k - nums.length) : (i + k) ] = temp[i];\\n    }\\n    return nums;\\n};", "var rotateString = function(s, goal) {\\n    if (s.length !== goal.length) return false;\\n    return s.concat(s).includes(goal);\\n};"]}
{"id": "175", "ref_js": ["var uniqueMorseRepresentations = function(words) {\\n    let hashMap = {\\n    \"a\": \".-\",\\n    \"b\": \"-...\",\\n    \"c\": \"-.-.\",\\n    \"d\": \"-..\",\\n    \"e\": \".\",\\n    \"f\": \"..-.\",\\n    \"g\": \"--.\",\\n    \"h\": \"....\",\\n    \"i\": \"..\",\\n    \"j\": \".---\",\\n    \"k\": \"-.-\",\\n    \"l\": \".-..\",\\n    \"m\": \"--\",\\n    \"n\": \"-.\",\\n    \"o\": \"---\",\\n    \"p\": \".--.\",\\n    \"q\": \"--.-\",\\n    \"r\": \".-.\",\\n    \"s\": \"...\",\\n    \"t\": \"-\",\\n    \"u\": \"..-\",\\n    \"v\": \"...-\",\\n    \"w\": \".--\",\\n    \"x\": \"-..-\",\\n    \"y\": \"-.--\",\\n    \"z\": \"--..\"\\n  }\\n  let currentIndexStr = \\'\\'\\n  for (let i = 0; i < words.length; i++) {\\n    let currentLength = words[i].length\\n    for (let j = 0; j < currentLength; j++) {\\n      currentIndexStr += hashMap[words[i][j]]\\n    }\\n    words[i] = currentIndexStr\\n    currentIndexStr = \\'\\'\\n  }\\n  return new Set(words).size\\n};", "var uniqueMorseRepresentations = function (words) {\\n    const morseCode = [\\n        \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n        \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\\n        \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n    ];\\n\\n    const uniqueMorse = new Set();\\n\\n    for (const word of words) {\\n        let morseRepresentation = \"\";\\n        for (const char of word) {\\n            morseRepresentation += morseCode[char.charCodeAt(0) - \\'a\\'.charCodeAt(0)];\\n        }\\n        uniqueMorse.add(morseRepresentation);\\n    }\\n\\n    return uniqueMorse.size;\\n};", "var uniqueMorseRepresentations = function(words) {\\n    let hashMap = {\\n    \"a\": \".-\",\\n    \"b\": \"-...\",\\n    \"c\": \"-.-.\",\\n    \"d\": \"-..\",\\n    \"e\": \".\",\\n    \"f\": \"..-.\",\\n    \"g\": \"--.\",\\n    \"h\": \"....\",\\n    \"i\": \"..\",\\n    \"j\": \".---\",\\n    \"k\": \"-.-\",\\n    \"l\": \".-..\",\\n    \"m\": \"--\",\\n    \"n\": \"-.\",\\n    \"o\": \"---\",\\n    \"p\": \".--.\",\\n    \"q\": \"--.-\",\\n    \"r\": \".-.\",\\n    \"s\": \"...\",\\n    \"t\": \"-\",\\n    \"u\": \"..-\",\\n    \"v\": \"...-\",\\n    \"w\": \".--\",\\n    \"x\": \"-..-\",\\n    \"y\": \"-.--\",\\n    \"z\": \"--..\"\\n  }\\n  let currentIndexStr = \\'\\'\\n  for (let i = 0; i < words.length; i++) {\\n    let currentLength = words[i].length\\n    for (let j = 0; j < currentLength; j++) {\\n      currentIndexStr += hashMap[words[i][j]]\\n    }\\n    words[i] = currentIndexStr\\n    currentIndexStr = \\'\\'\\n  }\\n  return new Set(words).size\\n};"]}
{"id": "176", "ref_js": ["var numberOfLines = function(widths, s) {\\n    let currentSumPixels = 0;\\n    const output = [1, 0];\\n    for (let i = 0; i < s.length; i++) {\\n        const indexOfChar = s.charCodeAt(i) - 97;\\n        currentSumPixels += widths[indexOfChar];\\n        if (currentSumPixels > 100) {\\n            currentSumPixels = 0;\\n            output[0]++;\\n            i--;\\n        } else if (currentSumPixels === 100) {\\n            currentSumPixels = 0;\\n            output[0]++;\\n        }\\n    }\\n    \\n    output[1] = currentSumPixels || 100;\\n    if (!currentSumPixels) output[0]--;\\n\\n    return output;\\n};", "var numberOfLines = function(widths, s) {\\n\\n  let result = [0,0]\\n  let px = 0\\n  for(let i=0; i<s.length; i++){\\n\\n      let newPx = widths[s.charCodeAt(i) - 97]\\n      if(px + newPx > 100){\\n\\n        result[0] = result[0] + 1\\n        result[1] = px\\n        \\n        px = 0\\n      }\\n\\n      px += newPx\\n\\n      if(i+1 == s.length){\\n        result[0] = result[0]+1\\n        result[1] = px\\n      }\\n\\n  }\\n  return result\\n};", "var numberOfLines = function(widths, s) {\\n\\n  let result = [0,0]\\n  let px = 0\\n  for(let i=0; i<s.length; i++){\\n\\n      let newPx = widths[s.charCodeAt(i) - 97]\\n      if(px + newPx > 100){\\n\\n        result[0] = result[0] + 1\\n        result[1] = px\\n        \\n        px = 0\\n      }\\n\\n      px += newPx\\n\\n      if(i+1 == s.length){\\n        result[0] = result[0]+1\\n        result[1] = px\\n      }\\n\\n  }\\n  return result\\n};"]}
{"id": "177", "ref_js": ["var reverseWords = function(s) {\\n        return s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n    }\\n```\\n``` PHP []\\nclass Solution {\\n    function reverseWords($s) {\\n        return implode(\\' \\', array_map(function($word) {\\n            return strrev($word);\\n        }, explode(\\' \\', $s)));\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        return String.Join(\" \", s.Split(\\' \\').Select(word => new string(word.Reverse().ToArray())));\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::string reverseWords(std::string s) {\\n        std::istringstream stream(s);\\n        std::string word, result;\\n        \\n        while (stream >> word) {\\n            std::reverse(word.begin(), word.end());\\n            result += word + \" \";\\n        }\\n        \\n        if (!result.empty()) {\\n            result.pop_back();  ", "var reverseWords = function(s) {\\n    const words = s.split(\\' \\'); \\n    for (let i = 0; i < words.length; i++) {\\n        words[i] = words[i].split(\\'\\').reverse().join(\\'\\');\\n    }\\n    return words.join(\\' \\');\\n};", "var reverseWords = function(s) {\\n    const words = s.split(\\' \\'); \\n    for (let i = 0; i < words.length; i++) {\\n        words[i] = words[i].split(\\'\\').reverse().join(\\'\\');\\n    }\\n    return words.join(\\' \\');\\n};"]}
{"id": "178", "ref_js": ["var mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};", "var mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};", "var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };"]}
{"id": "179", "ref_js": ["var shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};", "var shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};", "var shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};"]}
{"id": "180", "ref_js": ["var toGoatLatin = function(sentence) {\\n    let output = \\'\\';\\n    sentence = sentence.split(\\' \\');\\n\\n    for (let i = 0; i < sentence.length; i++) {\\n        let word = sentence[i];\\n        \\n        if (vowel[word[0]]) {\\n            word += \"ma\";\\n        } else {\\n            word = word.substr(1, word.length) + word[0] + \"ma\";\\n        }\\n        \\n        for (let j = 0; j <= i; j++) {\\n            word += \"a\";\\n        }\\n        \\n        output += word + (i !== sentence.length - 1 ? \\' \\' : \\'\\');\\n    }\\n    \\n    return output;\\n};", "var toGoatLatin = function(sentence) {\\n    const vowelSet = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']);\\n    return sentence.split(\\' \\').map((str, i) => {\\n        return (\\n            vowelSet.has(str[0]) ?\\n                str + \\'ma\\' :\\n                str.substring(1) + str[0] + \\'ma\\'\\n        ) + \\'a\\'.repeat(i + 1);\\n    }).join(\\' \\');\\n};", "var toGoatLatin = function (sentence) {\\n  sentence = sentence.split(\" \");\\n  let vowels = /^[aeiou]$/i;\\n  let str = \"\";\\n  for (let i = 0; i < sentence.length; i++) {\\n    if (vowels.test(sentence[i][0])) {\\n      str +=\\n        sentence[i] +\\n        \"ma\" +\\n        \"a\".repeat(i + 1) +\\n        (i !== sentence.length - 1 ? \" \" : \"\");\\n    } else {\\n      str +=\\n        sentence[i].substr(1) +\\n        sentence[i][0] +\\n        \"ma\" +\\n        \"a\".repeat(i + 1) +\\n        (i !== sentence.length - 1 ? \" \" : \"\");\\n    }\\n  }\\n  return str;\\n};"]}
{"id": "181", "ref_js": ["var largeGroupPositions = function(s) {\\n    const output = [];\\n    let start = 0;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i + 1] && s[i] !== s[i + 1]) {\\n            if (i - start >= 2) output.push([start, i]);\\n            start = i+1;\\n        }\\n    }\\n    \\n    if (s.length - 1 - start >= 2) output.push([start, s.length - 1]);\\n    \\n    return output;\\n};", "var largeGroupPositions = function(S) {\\n    let j = 0, res = [];\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] !== S[i+1]) {\\n            if (i-j+1 >= 3) res.push([j,i]);\\n            j = i+1;\\n        }\\n    }\\n    return res;\\n};", "var largeGroupPositions = function (s) {\\n  let [count, minIdx, maxIdx, arr, res] = [0, 0, 0, [], []];\\n  for (let i = 0; i < s.length - 1; i++) {\\n    if (s[i] == s[i + 1]) {\\n      count++;\\n      if (count == 1) minIdx = i;\\n      maxIdx = i + 1;\\n      if (count >= 2 && s[i+1] !== s[i+2]) arr = [minIdx, maxIdx];\\n    } else {\\n      arr = [];\\n      count = 0;\\n    }\\n    if (arr.length !== 0) res.push(arr);\\n  }\\n  return res;\\n};"]}
{"id": "182", "ref_js": ["var flipAndInvertImage = function(image) {\\n    const output = [];\\n    for (let i = 0; i < image.length; i++) {\\n        output[i] = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            output[i][j] = image[i][image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return output;\\n};", "var flipAndInvertImage = function(image) {\\n    return image.map((x)=>x.reverse().map((y)=>y?0:1))\\n};", "var flipAndInvertImage = function(image) {\\n    for(let i = 0; i < image.length; i++){\\n        let left = 0;\\n        let right = image[i].length-1;\\n        while(left <= right){\\n            if(left === right){\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n            }else{\\n                [image[i][left], image[i][right]] = [image[i][right], image[i][left]]\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n                image[i][right] = image[i][right] === 0 ? 1 : 0\\n            }\\n            left++\\n            right--\\n        }\\n    }\\n    return image\\n};"]}
{"id": "183", "ref_js": ["var isRectangleOverlap = function(rec1, rec2) {\\n    const [aX1, aY1, aX2, aY2] = rec1;\\n    const [bX1, bY1, bX2, bY2] = rec2;\\n    \\n    return aX1 < bX2 && aX2 > bX1 && aY1 < bY2 && aY2 > bY1;\\n};", "var isRectangleOverlap = function(rec1, rec2) {\\n    const [[aX1, aY1, aX2, aY2], [bX1, bY1, bX2, bY2]] = [rec1, rec2]\\n\\n    return aX1 < bX2 && bX1 < aX2 && bY1 < aY2 && aY1 < bY2\\n};", "var isRectangleOverlap = function(rec1, rec2) {\\n    const [aX1, aY1, aX2, aY2] = rec1;\\n    const [bX1, bY1, bX2, bY2] = rec2;\\n    \\n    return aX1 < bX2 && aX2 > bX1 && aY1 < bY2 && aY2 > bY1;\\n};"]}
{"id": "184", "ref_js": ["var loopCheck = function(str) {\\n    let res = \"\";\\n    for(let i=0; i<str.length; i++) {\\n        if(str[i]==\"#\") res = res.slice(0, -1);\\n        else res = res + str[i];\\n    }\\n    return res;\\n}\\nvar backspaceCompare = function(s, t) {\\n    console.log(loopCheck(s));\\n    console.log(loopCheck(t));\\n    if(loopCheck(s) == loopCheck(t)) return true;\\n    else return false;\\n};", "var backspaceCompare = function(s, t) {\\n    function get_next_valid_char_index(str, end) {\\n        let backspace_count = 0;\\n        while (end >= 0) {\\n            if (str.charAt(end) === \\'#\\') {\\n                backspace_count++;\\n            } else if (backspace_count > 0) {\\n                backspace_count--;\\n            } else {\\n                break;\\n            }\\n            end--;\\n        }\\n        return end;\\n    }\\n\\n    let ps = s.length - 1;\\n    let pt = t.length - 1;\\n\\n    while (ps >= 0 || pt >= 0) {\\n        ps = get_next_valid_char_index(s, ps);\\n        pt = get_next_valid_char_index(t, pt);\\n\\n        if (ps < 0 && pt < 0) {\\n            return true;\\n        }\\n        if (ps < 0 || pt < 0) {\\n            return false;\\n        } else if (s.charAt(ps) !== t.charAt(pt)) {\\n            return false;\\n        }\\n\\n        ps--;\\n        pt--;\\n    }\\n\\n    return true;    \\n};", "var backspaceCompare = function(s, t) {\\n    function get_next_valid_char_index(str, end) {\\n        let backspace_count = 0;\\n        while (end >= 0) {\\n            if (str.charAt(end) === \\'#\\') {\\n                backspace_count++;\\n            } else if (backspace_count > 0) {\\n                backspace_count--;\\n            } else {\\n                break;\\n            }\\n            end--;\\n        }\\n        return end;\\n    }\\n\\n    let ps = s.length - 1;\\n    let pt = t.length - 1;\\n\\n    while (ps >= 0 || pt >= 0) {\\n        ps = get_next_valid_char_index(s, ps);\\n        pt = get_next_valid_char_index(t, pt);\\n\\n        if (ps < 0 && pt < 0) {\\n            return true;\\n        }\\n        if (ps < 0 || pt < 0) {\\n            return false;\\n        } else if (s.charAt(ps) !== t.charAt(pt)) {\\n            return false;\\n        }\\n\\n        ps--;\\n        pt--;\\n    }\\n\\n    return true;    \\n};"]}
{"id": "185", "ref_js": ["var buddyStrings = function(s, goal) {\\n    ", "var buddyStrings = function(s, goal) {\\n    let differences = []\\n    let sSet = new Set(s)\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] !== goal[i]) differences.push([s[i], goal[i]])\\n    }\\n\\n    if(s.length !== goal.length) return false\\n\\n    if(s === goal) return sSet.size < s.length\\n \\n    if(differences.length === 2) return differences[0].toString() === differences[1].reverse().toString()\\n    \\n    return false\\n};", "var buddyStrings = function(s, goal) {\\n    "]}
{"id": "186", "ref_js": ["var lemonadeChange = function (bills) {\\n    ", "var lemonadeChange = function(bills) {\\n    const numberOf5 = [];\\n    const numberOf10 = [];\\n    \\n    for (let i = 0; i < bills.length; i++) {\\n        if (bills[i] === 5) {\\n            numberOf5.push(5);\\n        } else if (bills[i] === 10) {\\n            if (!numberOf5.length) return false;\\n            numberOf5.pop();\\n            numberOf10.push(10);\\n        } else {\\n            if (numberOf10.length && numberOf5.length) {\\n                numberOf10.pop();\\n                numberOf5.pop();\\n            } else if (!numberOf10.length && numberOf5.length >= 3) {\\n                numberOf5.splice(numberOf5.length - 3, 3);\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return true;\\n};", "var lemonadeChange = function(bills) {\\n    let fives = 0\\n    let tens = 0\\n    let len = bills.length\\n    for (let i=0; i<len; i++) {\\n        if (bills[i] === 5) fives ++\\n        if (bills[i] === 10) {\\n            if (fives < 1) return false\\n            fives --\\n            tens ++\\n        }\\n        if (bills[i] === 20) {\\n            if (fives < 1) {\\n                return false\\n            } else if (tens < 1) {\\n                if (fives < 3) return false\\n                fives -= 3\\n            } else {\\n                tens --\\n                fives --\\n            }\\n        }\\n    }\\n    return true\\n};"]}
{"id": "187", "ref_js": ["var transpose = function(matrix) {\\n    let row = matrix.length;\\n    let col = matrix[0].length;\\n    let result = Array.from({ length: col }, () => Array(row).fill(0));\\n    \\n    for (let i = 0; i < col; ++i) {\\n        for (let j = 0; j < row; ++j) {\\n            result[i][j] = matrix[j][i];\\n        }\\n    }\\n    \\n    return result;\\n};", "var transpose = function(matrix) {\\n    let row = matrix.length;\\n    let col = matrix[0].length;\\n    let result = Array.from({ length: col }, () => Array(row).fill(0));\\n    \\n    for (let i = 0; i < col; ++i) {\\n        for (let j = 0; j < row; ++j) {\\n            result[i][j] = matrix[j][i];\\n        }\\n    }\\n    \\n    return result;\\n};", "var transpose = function(matrix) {\\n    let row = matrix.length;\\n    let col = matrix[0].length;\\n    let result = Array.from({ length: col }, () => Array(row).fill(0));\\n    \\n    for (let i = 0; i < col; ++i) {\\n        for (let j = 0; j < row; ++j) {\\n            result[i][j] = matrix[j][i];\\n        }\\n    }\\n    \\n    return result;\\n};"]}
{"id": "188", "ref_js": ["var binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};", "var binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};", "var binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};"]}
{"id": "189", "ref_js": ["var leafSimilar = function(root1, root2) {\\n\\n    \\n\\n    let res1 = [];\\n    let res2 = [];\\n\\n   \\n\\n    function leaf(root,res)\\n    {\\n        if(!root)return ; \\n\\n        if(!root.left && !root.right)\\n        {\\n            res.push(root.val);\\n        }\\n\\n        if(root.left)leaf(root.left , res);\\n        if(root.right)leaf(root.right , res);\\n\\n        return res;\\n\\n    }\\n\\n    leaf(root1, res1);\\n    leaf(root2 , res2);\\n\\n    console.log(res1, res2)\\n    \\n    return res1.toString() === res2.toString() ;\\n\\n    \\n};", "var leafSimilar = function(root1, root2) {\\n\\n    \\n\\n    let res1 = [];\\n    let res2 = [];\\n\\n   \\n\\n    function leaf(root,res)\\n    {\\n        if(!root)return ; \\n\\n        if(!root.left && !root.right)\\n        {\\n            res.push(root.val);\\n        }\\n\\n        if(root.left)leaf(root.left , res);\\n        if(root.right)leaf(root.right , res);\\n\\n        return res;\\n\\n    }\\n\\n    leaf(root1, res1);\\n    leaf(root2 , res2);\\n\\n    console.log(res1, res2)\\n    \\n    return res1.toString() === res2.toString() ;\\n\\n    \\n};", "var leafSimilar = function(root1, root2) {\\n\\n    \\n\\n    let res1 = [];\\n    let res2 = [];\\n\\n   \\n\\n    function leaf(root,res)\\n    {\\n        if(!root)return ; \\n\\n        if(!root.left && !root.right)\\n        {\\n            res.push(root.val);\\n        }\\n\\n        if(root.left)leaf(root.left , res);\\n        if(root.right)leaf(root.right , res);\\n\\n        return res;\\n\\n    }\\n\\n    leaf(root1, res1);\\n    leaf(root2 , res2);\\n\\n    console.log(res1, res2)\\n    \\n    return res1.toString() === res2.toString() ;\\n\\n    \\n};"]}
{"id": "190", "ref_js": ["var middleNode = function(head) {\\n    let slow=head,fast=head\\n    while(fast && fast.next){\\n        slow=slow.next\\n        fast=fast.next.next\\n    }\\n    return slow\\n};", "var middleNode = function(head) {\\n    let twice = head;\\n    let once = head;\\n    while(twice && twice.next){\\n        twice = twice.next.next;\\n        once = once.next\\n    }\\n    return once\\n};", "var middleNode = function(head) {\\n    "]}
{"id": "191", "ref_js": ["var projectionArea = function(grid) {\\nlet top = grid.reduce((acc, curr) => acc += curr.filter(num => num > 0).length, 0);\\nlet front = grid[0].reduce((acc, curr, i) => acc += (Math.max(...grid.map(arr => arr[i]))), 0);\\nlet side = grid.reduce((acc, curr) => acc += Math.max(...curr), 0);    \\nreturn top + front + side;\\n};", "var projectionArea = function(grid) {\\n    let max=0,max2=0,sum=0,n=grid.length;\\n    for(let i=0;i<n;i++){\\n        max=0;\\n        max2=0;\\n        for(let j=0;j<n;j++){\\n            if(grid[i][j]>max)\\n            max=grid[i][j];\\n            if(grid[j][i]>max2)\\n            max2=grid[j][i];\\n            if(grid[i][j])\\n            sum++;\\n        }\\n        sum+=max+max2;\\n    }\\n    return sum;\\n};", "var projectionArea = function(grid) {\\n    let result = 0; "]}
{"id": "192", "ref_js": ["var uncommonFromSentences = function (s1, s2) {\\n    let s1Map = new Map()\\n    let s2Map = new Map()\\n    let result = []\\n\\t\\n    for (let word of s1.split(\\' \\')) {\\n        !s1Map.has(word) ? s1Map.set(word, 1) : s1Map.set(word, s1Map.get(word) + 1)\\n    }\\n\\n    for (let word of s2.split(\\' \\')) {\\n        !s2Map.has(word) ? s2Map.set(word, 1) : s2Map.set(word, s2Map.get(word) + 1)\\n    }\\n\\n    for (let [word, count] of s1Map) {\\n        if (count === 1 && !s2Map.has(word)) result.push(word)\\n    }\\n\\n    for (let [word, count] of s2Map) {\\n        if (count === 1 && !s1Map.has(word)) result.push(word)\\n    }\\n\\n    return result\\n};", "var uncommonFromSentences = function(s1, s2) {\\n    const arrayS1 = s1.split(\\' \\');\\n    const arrayS2 = s2.split(\\' \\');\\n    const hashmap = new Map ();\\n    const output = [];\\n    \\n    for (let i = 0; i < arrayS1.length; i++) {\\n        if (!hashmap.has(arrayS1[i])) {\\n            hashmap.set(arrayS1[i], 1);\\n        } else {\\n            hashmap.set(arrayS1[i], hashmap.get(arrayS1[i]) + 1);\\n        }\\n    }\\n    \\n    for (let i = 0; i < arrayS2.length; i++) {\\n        if (!hashmap.has(arrayS2[i])) {\\n            hashmap.set(arrayS2[i], 1)\\n        } else {\\n            hashmap.set(arrayS2[i], hashmap.get(arrayS2[i]) + 1);\\n        }\\n    }\\n    \\n    hashmap.forEach((value, key) => {\\n        if (value === 1) output.push(key);\\n    })\\n    \\n    return output;\\n};", "var uncommonFromSentences = function(s1, s2) {\\n    let a = [...s1.split(\\' \\'), ...s2.split(\\' \\')]\\n    const obj = {};"]}
{"id": "193", "ref_js": ["var fairCandySwap = function(aliceSizes, bobSizes) {\\n    const totalAliceSize = aliceSizes.reduce((prev, current) => prev + current, 0);\\n    const totalBobSize = bobSizes.reduce((prev, current) => prev + current, 0);\\n    \\n    const resolve = (array1, array2, difference) => {\\n        const hashmap = new Map();\\n        for (let i = 0; i < array1.length; i++) {\\n            hashmap.set(array1[i], i);\\n        }\\n        \\n        for (let i = 0; i < array2.length; i++) {\\n            if (hashmap.has(array2[i] + difference/2)) return [array2[i] + difference/2, array2[i]];\\n        }\\n    }\\n    \\n    return resolve(aliceSizes, bobSizes, totalAliceSize - totalBobSize);\\n};", "var fairCandySwap = function(aliceSizes, bobSizes) {\\n    const suma = aliceSizes.reduce((a, b) => a + b, 0)\\n    const sumb = bobSizes.reduce((a, b) => a + b, 0)\\n    const diff = (sumb - suma) / 2\\n    const lena = aliceSizes.length\\n    const lenb = bobSizes.length\\n    for (let i=0; i<lena; i++) {\\n        for (let j=0; j<lenb; j++) {\\n            if (bobSizes[j] - aliceSizes[i] === diff) {\\n                return [aliceSizes[i], bobSizes[j]]\\n            }\\n        }\\n    }\\n};", "var fairCandySwap = function(aliceSizes, bobSizes) {\\n    let totalA = aliceSizes.reduce((a, b) => a + b, 0);\\n    let totalB = bobSizes.reduce((a, b) => a + b, 0);\\n\\n    let setB = new Set(bobSizes);\\n    let setA = new Set(aliceSizes);\\n\\n    for(let x of setA){\\n        let calc = (totalB - totalA) / 2 + x;\\n\\n        if(setB.has(calc)){\\n            return [\\n                x, \\n                calc\\n            ]\\n        }\\n    }\\n};"]}
{"id": "194", "ref_js": ["var surfaceArea = function(grid) {\\n    let cube=0, overlap=0;\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[i].length; j++){\\n            cube+=grid[i][j];\\n            if(i>0){overlap+=Math.min(grid[i][j], grid[i-1][j]);} ", "var surfaceArea = function(grid) {\\n    const n = grid.length\\n    let a = 0\\n    let i\\n    let j\\n    for (i=0; i<n; i++) {\\n        for (j=0; j<n; j++) {\\n            if (grid[i][j]) a += 2\\n            if (i === 0) a+= grid[i][j]\\n            if (j === 0) a+= grid[i][j]\\n            if (i === n-1) a+= grid[i][j]\\n            if (j === n-1) a+= grid[i][j]\\n            if (i>0 && grid[i-1][j] < grid[i][j]) a += (grid[i][j] - grid[i-1][j])\\n            if (i<n-1 && grid[i+1][j] < grid[i][j]) a += (grid[i][j] - grid[i+1][j])\\n            if (j>0 && grid[i][j-1] < grid[i][j]) a += (grid[i][j] - grid[i][j-1])\\n            if (j<n-1 && grid[i][j+1] < grid[i][j]) a += (grid[i][j] - grid[i][j+1])\\n        }\\n    }\\n    return a\\n};", "var surfaceArea = function(grid) {\\n    let n = grid.length, res = 0;\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < n; j++){\\n            if(grid[i][j] !== 0) res+=grid[i][j] * 4 + 2;\\n            if(i !== 0) res -= Math.min(grid[i][j], grid[i-1][j]);\\n            if(j !== 0) res -= Math.min(grid[i][j], grid[i][j-1]);\\n            if(i !== n - 1) res -= Math.min(grid[i][j], grid[i+1][j]);\\n            if(j !== n - 1) res -= Math.min(grid[i][j], grid[i][j+1]);\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "195", "ref_js": ["var isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n};", "var isMonotonic = function(nums) {\\n    if (nums.length < 2) return true;\\n\\n    let direction = 0;  ", "var isMonotonic = function(nums) {\\n    if (nums.length < 2) return true;\\n\\n    let direction = 0;  "]}
{"id": "196", "ref_js": ["var increasingBST = function(root) {\\n    const result = new TreeNode();\\n    let auxPointer = result;\\n    const inorderTraversal = (node) => {\\n        if (!node) return;\\n        inorderTraversal(node.left);\\n        auxPointer.right = new TreeNode(node.val);\\n        auxPointer = auxPointer.right;\\n        inorderTraversal(node.right);\\n    };", "var increasingBST = function(root) {\\n    let data=[]\\n    function dfs(root){\\n        if(!root) return null\\n        dfs(root.left)\\n        data.push(root.val)\\n        dfs(root.right)\\n    }\\n    dfs(root)\\n    let node = new TreeNode(data[0])\\n    let curr=node\\n    for(let i =1; i<data.length; i++){\\n        curr.right=new TreeNode(data[i])\\n        curr=curr.right\\n   }\\n    return node\\n};", "var increasingBST = function(root) {\\n    const result = new TreeNode();\\n    let auxPointer = result;\\n    const inorderTraversal = (node) => {\\n        if (!node) return;\\n        inorderTraversal(node.left);\\n        auxPointer.right = new TreeNode(node.val);\\n        auxPointer = auxPointer.right;\\n        inorderTraversal(node.right);\\n    };"]}
{"id": "197", "ref_js": ["var sortArrayByParity = function(nums) {\\n    const result = [];\\n    \\n    for (const num of nums) {\\n        if (num % 2 === 0) {\\n            result.unshift(num);\\n        } else {\\n            result.push(num);\\n        }\\n    }\\n    \\n    return result;\\n};", "var sortArrayByParity = function(nums) {\\n    let i = 0, j = nums.length - 1;\\n    \\n    while (i < j) {\\n        while (i < j && nums[i] % 2 === 0)\\n            i++;\\n        while (i < j && nums[j] % 2 === 1)\\n            j--;\\n        \\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    return nums;\\n};", "var sortArrayByParity = function(nums) {\\n    let i = 0, j = nums.length - 1;\\n    \\n    while (i < j) {\\n        while (i < j && nums[i] % 2 === 0)\\n            i++;\\n        while (i < j && nums[j] % 2 === 1)\\n            j--;\\n        \\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    return nums;\\n};"]}
{"id": "198", "ref_js": ["var smallestRangeI = function(nums, k) {\\n    const min = Math.min(...nums);\\n    const max = Math.max(...nums);\\n    \\n    if (max - min <= 2*k) return 0;\\n    return max - min - 2*k;\\n};", "var smallestRangeI = function(nums, k) {\\n    if (nums.length <= 1) return 0;\\n    let biggest = Math.max(...nums), lowBOfBiggest = biggest-k;\\n    let smallest = Math.min(...nums), uppBOfSmallest = smallest+k;\\n    if (lowBOfBiggest-uppBOfSmallest <= 0) return 0;\\n    else return lowBOfBiggest-uppBOfSmallest; \\n};", "var smallestRangeI = function(nums, k) {\\n    let diff = Math.max(...nums) - Math.min(...nums) - 2 * k;\\n    return diff < 0 ? 0 : diff;\\n};"]}
{"id": "199", "ref_js": ["var hasGroupsSizeX = function(deck) {\\n    if (deck.length === 1) return false;\\n    const hashmap = {};", "var hasGroupsSizeX = function(deck) {\\n   let gcd = (a, b) => b > 0 ? gcd(b, a % b) : a;\\n   let count = new Map();\\n   let res = 0;\\n   deck.forEach(n => count.set(n, (count.get(n) || 0) + 1));\\n   count.forEach(c => res = gcd(c, res));\\n   return res > 1;    \\n};", "var hasGroupsSizeX = function (deck) {\\n  const map = new Map();\\n  for (const d of deck) {\\n    if (map.has(d)) {\\n      map.set(d, map.get(d) + 1);\\n    } else {\\n      map.set(d, 1);\\n    }\\n  }\\n  return getGroupSize(map) >= 2;\\n};"]}
{"id": "200", "ref_js": ["var reverseOnlyLetters = function(s) {\\n    s = s.split(\\'\\');\\n    let start = 0;\\n    let end = s.length - 1;\\n    const regex = /[a-zA-Z]/g; \\n    while (start < end) {\\n        if (s[start].match(regex) === null) { ", "var reverseOnlyLetters = function(s) {\\n    let output = \\'\\';\\n    let cursorS = 0;\\n    let cursorReverse = s.length - 1;\\n    \\n    while (cursorS < s.length) {\\n        if (!regex.test(s[cursorReverse]) && cursorReverse >= 0) {\\n            cursorReverse--;\\n            continue;\\n        }\\n        if (regex.test(s[cursorS])) {\\n            output += s[cursorReverse];\\n            cursorReverse--;\\n        } else {\\n            output += s[cursorS];\\n        }\\n        cursorS++;\\n    }\\n    \\n    return output;\\n};", "var reverseOnlyLetters = function(s) {\\n    const l = s.split``.filter(v=>/[a-zA-Z]/.test(v))\\n    const arr = []\\n    for (let i=0;i<s.length;i++){\\n        if (/[a-zA-Z]/.test(s[i])){\\n            arr.push(l.pop())\\n        } else {\\n            arr.push(s[i])\\n        }\\n    }\\n    return arr.join``\\n};"]}
{"id": "201", "ref_js": ["var sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};", "var sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};", "var sortArrayByParityII = function(nums) {\\n\\n    let even = 0;\\n    let odd = 1;\\n\\n    while(even < nums.length && odd < nums.length) {\\n        const isEvenValid = even % 2 === nums[even] % 2;\\n        const isOddValid = odd % 2 === nums[odd] % 2;\\n\\n        if(!isEvenValid && !isOddValid) {\\n            [nums[even], nums[odd]] = [nums[odd], nums[even]];\\n            even += 2;\\n            odd += 2;\\n        }\\n        else{\\n            if(isEvenValid) even += 2;\\n            if(isOddValid) odd += 2;\\n        }\\n    }\\n\\n    return nums;\\n};"]}
{"id": "202", "ref_js": ["var isLongPressedName = function(name, typed) {\\n    let namePointer = 0;\\n    let typedPointer = 0;\\n\\n    if (typed.length < name.length) return false\\n\\n    while (typedPointer < typed.length) {\\n        if (name[namePointer] === typed[typedPointer]) {\\n            namePointer += 1;\\n            typedPointer += 1;\\n        } else if (name[namePointer - 1] === typed[typedPointer]) {\\n            typedPointer += 1;\\n        } else {\\n            return false\\n        }\\n    }\\n\\n    return name.length === namePointer\\n};", "var isLongPressedName = function(name, typed) {\\n    if (typed.length < name.length || typed[typed.length - 1] !== name[name.length - 1]) return false;\\n    const hashmap = new Map();\\n    let cursorName = 0;\\n    \\n    for (let i = 0; i < name.length; i++) {\\n        hashmap.set(i, name[i]);\\n    }\\n    for (let i = 0; i < typed.length; i++) {\\n        const character = typed[i];\\n        if (character === hashmap.get(cursorName)) {\\n            cursorName++;\\n        } else if (character !== hashmap.get(cursorName - 1)) {\\n            return false;\\n        }\\n    }\\n    \\n    if (cursorName < name.length - 1) return false;\\n    \\n    return true;\\n};", "var isLongPressedName = function(name, typed) {\\n    return new RegExp(\"^\" + name.match(/(.)\\\\1*/g).join(\"+\") + \"+$\").test(typed)\\n};"]}
{"id": "203", "ref_js": ["var numUniqueEmails = function(emails) {\\n    \\n    let uniqueEmails = new Set();  ", "var numUniqueEmails = function(emails) {\\n    let dec = {};", "var numUniqueEmails = function(emails) {\\n  return (new Set(emails.map(email => {\\n    const [local, domain] = email.split(\\'@\\');\\n    return local.split(\\'+\\').shift().split(\\'.\\').join(\\'\\') + \\'@\\' + domain;\\n  }))).size;\\n};"]}
{"id": "205", "ref_js": ["var rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};", "var rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); ", "var rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); "]}
{"id": "206", "ref_js": ["var validMountainArray = function (arr) {\\n  if (arr.length < 3 || arr[0]>=arr[1]) return false;\\n  let peak = true;\\n  for (let i = 0; i < arr.length - 1; i++) {\\n    if (peak && arr[i] > arr[i + 1]) {\\n      peak = false;\\n    } else if ((!peak && arr[i] <= arr[i + 1])||(arr[i]===arr[i+1])) {\\n      return false;\\n    }\\n  }\\n  return peak ? false : true;\\n};", "var validMountainArray = function(arr) {\\n    if (arr.length < 3) return false;\\n\\n    let isGoingUp;\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i+1] && arr[i+1] > arr[i] && (isGoingUp || isGoingUp === undefined)) {\\n            isGoingUp = true;\\n        } else if (arr[i+1] && arr[i+1] < arr[i] && isGoingUp) {\\n            isGoingUp = false;\\n        } else if (arr[i+1] && arr[i+1] < arr[i] && isGoingUp === false) {\\n            isGoingUp = false;\\n        } else if (arr[i+1]) {\\n            return false;\\n        }\\n    }\\n    \\n    return isGoingUp === false;\\n};", "var validMountainArray = function(arr) {\\n    "]}
{"id": "207", "ref_js": ["var diStringMatch = function (s) {\\n  let count1 = -1;\\n  let count2 = s.length + 1;\\n  const result = [];\\n  for (let i = 0; i <= s.length; i++) {\\n    if (s[i] === \"I\") {\\n      count1 = count1 + 1;\\n      result.push(count1);\\n    } else {\\n      count2 = count2 - 1;\\n      result.push(count2);\\n    }\\n  }\\n  return result;\\n};", "var diStringMatch = function(s) {\\n    const output = [];\\n    let countI = 0;\\n    let countD = s.length;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"I\") {\\n            output.push(countI);\\n            countI++;\\n        } else {\\n            output.push(countD);\\n            countD--;\\n        }\\n    }\\n    \\n    output.push(s[s.length - 1] === \"I\" ? countD : countI);\\n    \\n    return output;\\n};", "var diStringMatch = function (s) {\\n  let count1 = -1;\\n  let count2 = s.length + 1;\\n  const result = [];\\n  for (let i = 0; i <= s.length; i++) {\\n    if (s[i] === \"I\") {\\n      count1 = count1 + 1;\\n      result.push(count1);\\n    } else {\\n      count2 = count2 - 1;\\n      result.push(count2);\\n    }\\n  }\\n  return result;\\n};"]}
{"id": "208", "ref_js": ["var minDeletionSize = function(strs) {\\n    const row=strs.length;\\n    const col=strs[0].length;\\n    let ans=0;\\n    for(let i=0;i<col;i++)\\n    {\\n        for(let j=0;j<row-1;j++)\\n        {\\n            if(strs[j][i]>strs[j+1][i])\\n            {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n};", "var minDeletionSize = function(strs) {\\n    \\n    let count =0\\n    let row = strs.length\\n    let col = strs[0].length\\n\\n    for(let  i =0 ; i< col ; i ++){\\n        for(let j =0 ; j < row-1 ; j++){\\n            if(strs[j][i] > strs[j+1][i]) {count++\\n            \\n            break\\n            }\\n        }\\n    }\\n\\n   return count\\n};", "var minDeletionSize = function (strs) {\\n    let count = 0;\\n    for (let index = 0; index < strs[0].length; index++) {\\n        let store = null;\\n        for (const iterator of strs) {\\n            if (store === null) {\\n                store = iterator[index];\\n            } else if (!(store <= iterator[index])) {\\n                count++;\\n                break;\\n            } else {\\n                store = iterator[index];\\n            }\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "209", "ref_js": ["var isAlienSorted = function(words, order) {\\n    let map = {}\\n    for (let i = 0; i < order.length; i++) {\\n        map[order[i]] = i\\n    }\\n\\n    for (let i = 0; i < words.length - 1; i++) {\\n        for (let j = 0; j < words[i].length; j++) {\\n            if (j >= words[i+1].length) return false\\n            if (words[i][j] == words[i+1][j]) continue\\n            let pos1 = map[words[i][j]]\\n            let pos2 = map[words[i+1][j]]\\n            if (pos1 < pos2) break\\n            else return false\\n        }\\n    }\\n    return true\\n};", "var isAlienSorted = function(words, order) {\\n    if (words.length === 1) return true\\n\\n    let orderMap = new Map()\\n    for (let s = 0; s< order.length; s++){\\n        orderMap.set(order[s], s + 1)\\n    }\\n\\n    for (let i = 0; i < words.length - 1; i++){\\n        let iter = 0\\n        while (words[i][iter] || words[i + 1][iter]){\\n            if (orderMap.get(words[i][iter]) > orderMap.get(words[i + 1][iter])) return false\\n            if (orderMap.get(words[i][iter]) < orderMap.get(words[i + 1][iter])) break\\n            iter++\\n            if (words[i][iter] !== undefined && words[i + 1][iter] === undefined) return false\\n        }\\n    }\\n    return true\\n};", "var isAlienSorted = function(words, order) {\\n    if (words.length === 1) return true\\n\\n    let orderMap = new Map()\\n    for (let s = 0; s< order.length; s++){\\n        orderMap.set(order[s], s + 1)\\n    }\\n\\n    for (let i = 0; i < words.length - 1; i++){\\n        let iter = 0\\n        while (words[i][iter] || words[i + 1][iter]){\\n            if (orderMap.get(words[i][iter]) > orderMap.get(words[i + 1][iter])) return false\\n            if (orderMap.get(words[i][iter]) < orderMap.get(words[i + 1][iter])) break\\n            iter++\\n            if (words[i][iter] !== undefined && words[i + 1][iter] === undefined) return false\\n        }\\n    }\\n    return true\\n};"]}
{"id": "210", "ref_js": ["var repeatedNTimes = function(a) {\\n    let d = []\\n    for(let i of a){\\n        if(d.includes(i)){\\n           return i \\n        }else{\\n            d.push(i)\\n        }\\n    }\\n    \\n    \\n};", "var repeatedNTimes = function(nums) {\\n    const arrSet = new Set();\\n    for (const item of nums) {\\n        if (arrSet.has(item)) {\\n            return item;\\n        }\\n        arrSet.add(item);\\n    }\\n};", "var repeatedNTimes = function(A) {\\n  let lookup = new Set();\\n\\n  for (let n of A) {\\n    if (lookup.has(n)) return n;\\n    lookup.add(n);\\n  }\\n\\n  return -1;\\n};"]}
{"id": "211", "ref_js": ["var isUnivalTree = function(root) {\\n  if (!root) return true;\\n  const uni = root.val;\\n  let queue = [root];\\n  let curNode;\\n\\n  while (queue.length > 0) {\\n    curNode = queue.shift();\\n    if (curNode.val !== uni) return false;\\n    curNode.left && queue.push(curNode.left);\\n    curNode.right && queue.push(curNode.right);\\n  }\\n  \\n  return true;\\n};", "var isUnivalTree = function(root) {\\n  const isRightEqual = !root.right || (root.val === root.right.val && isUnivalTree(root.right));\\n  const isLeftEqual = !root.left || (root.val === root.left.val && isUnivalTree(root.left));\\n  return isLeftEqual && isRightEqual;\\n};", "var isUnivalTree = function(root, value = root.val) {\\n  if (!root) {\\n    return true;\\n  }\\n  \\n  if (root.val !== value) {\\n    return false;\\n  }\\n  \\n  return isUnivalTree(root.left, value) && isUnivalTree(root.right, value);\\n};"]}
{"id": "212", "ref_js": ["var largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\\n            return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n    }\\n\\n    return 0;\\n};", "var largestPerimeter = function(nums) {\\n    nums = nums.sort((a,b) => a-b);\\n    \\n    for (let i = nums.length - 1; i >= 2; i--) {\\n        const perimeter = getPerimeter([nums[i], nums[i - 1], nums[i - 2]]);\\n        if (perimeter) return perimeter;\\n    }\\n    \\n    return 0;\\n};", "var largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\\n            return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n    }\\n\\n    return 0;\\n};"]}
{"id": "213", "ref_js": ["var sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};", "var sortedSquares = function(nums) {\\n    ", "var sortedSquares = function(nums) {\\n    return nums.map((num) => num*num).sort((a, b) => (a - b));    \\n};"]}
{"id": "214", "ref_js": ["var addToArrayForm = function(num, k) {\\n    let sum = BigInt(num.join(\\'\\')) + BigInt(k);\\n    let convertSum = sum.toString().split(\\'\\').map((num) => parseInt(num));\\n    return convertSum;\\n};", "var addToArrayForm = function(num, k) {\\n    return [...(BigInt(num.join(\"\"))+BigInt(k)).toString()]\\n};", "var addToArrayForm = function(num, k) {\\n    let sum = BigInt(num.join(\\'\\')) + BigInt(k);\\n    let convertSum = sum.toString().split(\\'\\').map((num) => parseInt(num));\\n    return convertSum;\\n};"]}
{"id": "215", "ref_js": ["var isCousins = function(root, x, y) {\\n  const queue = [root];\\n  while (queue.length) {\\n    const size = queue.length;\\n    let foundX = false;\\n    let foundY = false;\\n    ", "var isCousins = function(root, x, y) {\\n    let xHeight = 1;\\n    let xParent = null;\\n    let yHeight = 1;\\n    let yParent = null;\\n    \\n    const helper = (node, depth, parent) => {\\n        if(node === null)\\n            return null;\\n        \\n        helper(node.left, depth + 1, node);\\n        helper(node.right, depth + 1, node);\\n        \\n        let val = node.val;\\n        \\n        if(val === x) {\\n            xHeight = depth;\\n            xParent = parent;\\n        }\\n        \\n        if(val === y) {\\n            yHeight = depth;\\n            yParent = parent;\\n        }\\n    }\\n    \\n    helper(root, 0);\\n    \\n    return xHeight === yHeight && xParent !== yParent ? true : false;\\n};", "var isCousins = function(root, x, y) {\\n  const queue = [root];\\n  while (queue.length) {\\n    const size = queue.length;\\n    let foundX = false;\\n    let foundY = false;\\n    "]}
{"id": "216", "ref_js": ["var findJudge = function(n, trust) {\\n  \\n    if(n === 1) return 1;\\n    ", "var findJudge = function(n, trust) {\\n    const Trusted = new Array(n+1).fill(0);\\n    for(let [i,j] of trust) {\\n        Trusted[i] -= 1\\n        Trusted[j] += 1\\n    }\\n    for(let i = 1; i < Trusted.length; i++) {\\n        if ((n-1) === Trusted[i]) {\\n            return i;\\n        }\\n    }\\n    return -1\\n};", "var findJudge = function(n, trusts) {\\n    if (trusts.length == 0 && n == 1)\\n        return 1;   "]}
{"id": "217", "ref_js": ["var numRookCaptures = function(board) {\\n    var pawnCount = 0;\\n    var horizontal;\\n    var vertical = \"\";\\n    \\n    for (let i in board) {\\n        if (board[i].includes(\\'R\\')) {\\n            horizontal = board[i].join(\"\");\\n            for (let j = 0; j < 8; j++) {\\n                vertical += board[j][board[i].indexOf(\\'R\\')]\\n            }\\n        }\\n    }\\n\\n    for (let match of horizontal.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of horizontal.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    \\n    return pawnCount;\\n};", "var numRookCaptures = function(board) {\\n    let counter =0;\\n    let valueArr\\n    let NewArr=[];\\n    for(let i=0;i<board.length;i++){\\n        for(let j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'R\\'){\\n                valueArr = board[i].filter(e=>e!=\\'.\\').join(\\'\\')\\n                valueArr.includes(\\'Rp\\') && counter++;\\n                valueArr.includes(\\'pR\\') && counter++;\\n                for(let k=0;k<8;k++){\\n                    NewArr.push(board[k][j]);\\n                }\\n                valueArr = NewArr.filter(e=>e!=\\'.\\').join(\\'\\')\\n                valueArr.includes(\\'Rp\\') && counter++;\\n                valueArr.includes(\\'pR\\') && counter++;\\n            }\\n        }\\n    }\\n    return counter;\\n    \\n};", "var numRookCaptures = function(board) {\\n    let [rows, cols] = [new Array(8).fill(\\'\\'), new Array(8).fill(\\'\\')];\\n    let rookRow, rookCol;\\n\\n    for(let i = 0; i < 8; i++)\\n    for(let j = 0; j < 8; j++){\\n        rows[i] += board[i][j];\\n        cols[i] += board[j][i];\\n        if(\\'R\\' === board[i][j]) [rookRow, rookCol] = [i, j];\\n    }\\n    let captures = 0;\\n    if(/p\\\\.*R/.test(rows[rookRow])) captures++;\\n    if(/R\\\\.*p/.test(rows[rookRow])) captures++;\\n    if(/p\\\\.*R/.test(cols[rookCol])) captures++;\\n    if(/R\\\\.*p/.test(cols[rookCol])) captures++;\\n   return captures;\\n};"]}
{"id": "218", "ref_js": ["var commonChars = function(words) {\\n    \\n    let charFreqs = new Map();\\n    ", "var commonChars = function(words) {\\n    let result = []\\n    for(let i = 0 ; i < words[0].length ; i++)\\n        for(let j = 1 ; j < words.length ; j++){\\n            if(!words[j].includes(words[0][i])) break;\\n            else  \\n                words[j] = words[j].replace(words[0][i],\\'\\')\\n            if(j == words.length - 1) result.push(words[0][i]);\\n        }\\n    return result;\\n};", "var commonChars = function(A) {\\n    const result = []\\n    const firstWordArr = [...A[0]]\\n    \\n    for(const letter of firstWordArr) {\\n        if(A.every(word => word.includes(letter))) {\\n            result.push(letter)\\n            A = A.map(word => word.replace(letter, \\'\\'))\\n        }\\n    }    \\n    \\n    return result\\n};"]}
{"id": "219", "ref_js": ["var largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};", "var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        ", "var largestSumAfterKNegations = function(nums, k) {\\n   let numbers = nums.sort((a, b) => a - b)\\n   let index = 0\\n   while (k > 0) {\\n       if (k == 1 && numbers[index] > 0 && numbers[index+1] > 0) {\\n           numbers[index] = -numbers[index]\\n           return numbers.reduce((a,b) => a+b, 0);\\n           }      \\n       if (numbers[index] < 0 && numbers[index+1] > 0 && k >= 3 && k % 2 != 0) {\\n          k = 1\\n       }\\n       if (numbers[index] < 0 ) {\\n           numbers[index] = -numbers[index]\\n           k--\\n           index++\\n        } else if (numbers[index] == 0) {\\n        return numbers.reduce((a,b) => a+b, 0);\\n        } else if (k > 2) {\\n        k = k - 2\\n        } \\n        else {\\n            if (numbers[index-1] < numbers[index]) {\\n                numbers[index-1] = -numbers[index-1]\\n                k--\\n                index++\\n            } else {\\n        numbers[index] = -numbers[index]\\n        k--\\n        index++\\n        }\\n    }\\n    if (index == nums.length) {\\n        index = nums.length - 1\\n    }\\n   }\\n   let sum = numbers.reduce((a,b) => a+b, 0);\\n   return sum\\n};"]}
{"id": "220", "ref_js": ["var bitwiseComplement = function(n) {\\n    var mask = Math.pow(2, n.toString(2).length) - 1;\\n    return ~n & mask;\\n};", "var bitwiseComplement = function(n) {\\n      let bin = n.toString(2), bin2 = \"\";\\n      for(let i = 0; i < bin.length; i++){\\n          if(bin[i] === \\'0\\') bin2 = bin2 + \\'1\\';\\n          else bin2 = bin2 + \\'0\\';\\n      } \\n      return parseInt(bin2, 2);\\n};", "var bitwiseComplement = function(n) {\\n    let ans = 0, rem, mul = 1;\\n    if(n == 0) return 1;\\n    while(n){\\n        rem = n % 2;\\n        rem = rem ^ 1;\\n        n = Math.floor(n / 2);\\n        ans = ans + rem * mul;\\n        mul *= 2;\\n    }\\n    return ans;\\n};"]}
{"id": "221", "ref_js": ["var canThreePartsEqualSum = function(A) {\\nlet totalSum=0;\\n    for(let i=0;i<A.length;i++){\\n        totalSum+=A[i]\\n    }\\n    const average = totalSum/3;\\n    let sum=0,count=0;\\n    for(let i=0;i<A.length;i++){\\n        sum+=A[i];\\n        if(sum===average){\\n            count++;\\n            sum=0;\\n        }\\n    }\\n    return count>=3;\\n};", "var canThreePartsEqualSum = function(arr) {\\n     sum = arr.reduce((a, b) => a + b);\\n     part = sum / 3;\\n     counter = 0;\\n     temp = 0;\\n\\n     for(let i = 0; i < arr.length; i++){\\n         if((temp += arr[i]) === part){\\n             counter++;\\n             temp = 0;\\n         }\\n     }  \\n     return counter >= 3;\\n};", "var canThreePartsEqualSum = function(arr) {\\n    var tot=arr.reduce((a,b)=>a+b);\\n    var part=tot/3;\\n    var ct=0;\\n    var sum=0;\\n    for(var i=0;i<arr.length;i++)\\n    {\\n        sum=sum+arr[i];\\n        if(sum==part)\\n        {\\n            sum=0;\\n            ct++;\\n        }\\n        else if(sum>part && i==arr.length)\\n        {\\n            return false;\\n        }\\n    }\\n    if(ct>=3)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n};"]}
{"id": "222", "ref_js": ["var prefixesDivBy5 = function(nums) {\\n   let res = [];\\n   let binary = 0;\\n   for(let num of nums){\\n       binary = (binary % 5) * 2 + num;\\n       let checkBinary = (binary % 5 === 0);\\n       res.push(checkBinary);\\n   }    \\n   return res;\\n};", "var prefixesDivBy5 = function(nums) {\\n    let result = [];\\n    let binary = 0;\\n    for(let num of nums){\\n        binary = (binary % 5) * 2 + num;\\n        let checkBinary = ( binary % 5 == 0);\\n        result.push(checkBinary);\\n    }\\n    return result\\n};", "var prefixesDivBy5 = function(nums) {\\n    let ans = []\\n    let len = nums.length\\n    let n = 0\\n    let zero = 0\\n    for(let i = len - 1; i >= 0; i--) {\\n        n += nums[i] * (2 ** zero) "]}
{"id": "223", "ref_js": ["var removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};", "var removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};", "var removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};"]}
{"id": "224", "ref_js": ["var sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        ", "var sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    ", "var sumRootToLeaf = function(root) {\\n   let sum = 0;\\n   DFS(root, \"\");\\n   return sum;\\n\\n   function DFS(root, path){\\n       if(!root) return;\\n       if(!root.left && !root.right){\\n           sum += parseInt(path + root.val, 2);\\n           return;\\n       }\\n       DFS(root.left, path + root.val);\\n       DFS(root.right, path + root.val);\\n   }    \\n};"]}
{"id": "225", "ref_js": ["var divisorGame = function(n) {\\n    return n%2==0?true:false\\n};", "var divisorGame = function(N) {\\n    return N%2===0;\\n};", "var divisorGame = function(n) {\\n    const canWin = new Array(n + 1).fill(false);\\n    canWin[1] = false;\\n    for (let i = 2; i <= n; i++) {\\n        for (let x = 1; x < i; x++) {\\n            if (i % x === 0 && !canWin[i - x]) {\\n                canWin[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return canWin[n];\\n};"]}
{"id": "226", "ref_js": ["var allCellsDistOrder = function(rows, cols, rCenter, cCenter) {\\n  const buckets = [];\\n  const result = [];\\n  const maxDist = Math.max(rCenter, rows - 1 - rCenter) + Math.max(cCenter, cols - 1 - cCenter);\\n\\n  for (let i = 0; i <= maxDist; i++) {\\n    buckets.push([]);\\n  }\\n \\n  for (let r = 0; r < rows; r++) {\\n    for (let c = 0; c < cols; c++) {\\n      const dist = Math.abs(r - rCenter) + Math.abs(c - cCenter);\\n      buckets[dist].push([r, c]);\\n    }\\n  }\\n\\n  for (let i = 0; i <= maxDist; i++) {\\n    result.push(...buckets[i]);\\n  }\\n  \\n  return result;\\n};", "var allCellsDistOrder = function(rows, cols, rCenter, cCenter) {\\n    let l = [];\\n    for(let i=0;i<rows;i++){\\n        for(let j=0;j<cols;j++){\\n            l.push([i,j]);\\n        }\\n    }\\n    l.sort((x,y)=>Math.abs(x[0] - rCenter) + Math.abs(x[1] - cCenter)-(Math.abs(y[0] - rCenter) + Math.abs(y[1] - cCenter)));\\n    return l;\\n};", "var allCellsDistOrder = function(rows, cols, rCenter, cCenter) {\\n    let l = [];\\n    for(let i=0;i<rows;i++){\\n        for(let j=0;j<cols;j++){\\n            l.push([i,j]);\\n        }\\n    }\\n    l.sort((x,y)=>Math.abs(x[0] - rCenter) + Math.abs(x[1] - cCenter)-(Math.abs(y[0] - rCenter) + Math.abs(y[1] - cCenter)));\\n    return l;\\n};"]}
{"id": "227", "ref_js": ["var isBoomerang = function(points) {\\n    ", "var isBoomerang = function(points) {\\n    let isBoomerang = false;\\n    if((0.5 * (points[0][0] * (points[1][1] - points[2][1]) + points[1][0] * (points[2][1] - points[0][1]) + points[2][0] * (points[0][1] - points[1][1]))) !== 0) {\\n        isBoomerang = true;\\n    } else isBoomerang = false;\\n    return isBoomerang;\\n};", "var isBoomerang = function (points) {\\n    let m = 0;\\n\\n    let [x1, y1] = points[0];\\n    let [x2, y2] = points[1];\\n    let [x3, y3] = points[2];\\n    m1 = ((y2 - y1) / (x2 - x1))\\n    m2 = ((y3 - y2) / (x3 - x2))\\n    m3 = ((y3 - y1) / (x3 - x1))\\n    if(((x1 === x2)&& (y1===y2))||((x3 === x2)&& (y3===y2))||((x1 === x3)&& (y1===y3))){\\n        return false;\\n    }\\n    const area = (1/2)*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n    return area === 0 ? false : true;\\n    \\n\\n\\n\\n};"]}
{"id": "228", "ref_js": ["var lastStoneWeight = function(stones) {\\n    while(stones.length >1){\\n         stones.sort((a, b) => a - b)\\n         if(stones[stones.length-1]-stones[stones.length-2]===0){\\n            stones.pop()\\n            stones.pop()\\n         } else if (stones[stones.length - 1] - stones[stones.length - 2] !== 0){\\n            stones[stones.length - 2] = stones[stones.length - 1] - stones[stones.length -2]\\n            stones.pop()\\n         }\\n    }\\n   return stones\\n};", "var lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); ", "var lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); "]}
{"id": "229", "ref_js": ["var removeDuplicates = function(s) {\\n    const stack1 = new Stacks();\\n  for(let i = 0; i < s.length; i++){\\n    if(stack1.peek() == s.charAt(i)){\\n      stack1.deleteTail_pop();\\n    }\\n    else stack1.appendLast_push(s.charAt(i));\\n  }\\n  return stack1.join();\\n};", "var removeDuplicates = function(s) {\\n    q = []\\n    for (let c of s) {\\n        if (q.length != 0 && c == q[0])\\n            q.shift()\\n        else\\n            q.unshift(c)\\n    }\\n    return q.reverse().join(\\'\\')\\n};", "var removeDuplicates = function(s) {\\n    q = []\\n    for (let c of s) {\\n        if (q.length != 0 && c == q[0])\\n            q.shift()\\n        else\\n            q.unshift(c)\\n    }\\n    return q.reverse().join(\\'\\')\\n};"]}
{"id": "231", "ref_js": ["var heightChecker = function (heights) {\\n  let count = 0;\\n  const ss = [...heights];\\n  ss.sort((a, b) => a - b);\\n  for (let i = 0; i < heights.length; i++) {\\n    if (ss[i] !== heights[i]) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};", "var heightChecker = function(heights) {\\n    const sortedHeights = [...heights].sort((a,b) => a - b);\\n    let output = 0;\\n    \\n    for (let i = 0; i < heights.length; i++) {\\n        if (heights[i] !== sortedHeights[i]) output++;\\n    }\\n    \\n    return output;\\n};", "var heightChecker = function (heights) {\\n  let count = 0;\\n  const ss = [...heights];\\n  ss.sort((a, b) => a - b);\\n  for (let i = 0; i < heights.length; i++) {\\n    if (ss[i] !== heights[i]) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};"]}
{"id": "233", "ref_js": ["var gcdOfStrings = function(str1, str2) {\\n    \\n  if(str1 + str2 != str2 + str1){\\n      return \"\";\\n  } else if(str1 == str2){\\n      return str1;\\n  } else if(str1.length > str2.length){\\n      return gcdOfStrings(str1.substring(str2.length), str2);\\n  } else{\\n          return gcdOfStrings(str2.substring(str1.length), str1)\\n      }  \\n};", "var gcdOfStrings = function(str1, str2) {\\n    \\n    if (str1 + str2 !== str2 + str1) {\\n\\n        return \"\";\\n    }\\n\\n    let n = str1.length;\\n\\n    let k = str2.length;\\n\\n    let gcds = function (x, y) {\\n        \\n        if (!y) {\\n            return x;\\n        }\\n        return gcds(y, x % y);\\n    }\\n\\n    let div = gcds (n, k);\\n\\n    return str1.slice(0, div);\\n};", "var gcdOfStrings = function(str1, str2) {\\n    if(str1 + str2 != str2 + str1) return \\'\\';\\n \\n    let isValidate = (w,str) =>{\\n        if(str.length == 0) return true;\\n        if(!str.startsWith(w)) return false;\\n        return isValidate(w,str.slice(w.length))\\n    }\\n\\n    let res = \\'\\'\\n\\n    for(let i = 1; i<=str1.length; i++){\\n        let curV = str1.slice(0,i)\\n        if(isValidate(curV,str2) && isValidate(curV,str1)) res = curV;\\n    }\\n\\n    return res;\\n};"]}
{"id": "235", "ref_js": ["var findOcurrences = function(text, first, second) {\\n    let results = [];\\n    let arr = text.split(\\' \\');\\n    for (let i = 2; i < arr.length; i++) {\\n        if (arr[i - 2] === first && arr[i - 1] === second) {\\n            results.push(arr[i]);\\n        }\\n    }\\n    return results;\\n};", "var findOcurrences = function(text, first, second) {\\n    text = text.split(\\' \\');\\n    const output = [];\\n    \\n    for (let i = 0; i < text.length - 2; i++) {\\n        if (text[i] === first && text[i + 1] === second) output.push(text[i + 2]);\\n    }\\n        \\n    return output;\\n};", "var findOcurrences = function(text, first, second) {\\n     return text.split(\\' \\').filter((item, idx, self) => {\\n        if (self[idx - 2] === first && self[idx - 1] === second) {\\n            return item\\n        }\\n    })\\n};"]}
{"id": "237", "ref_js": ["var duplicateZeros = function(arr) {\\n    \\n    for (var i=0; i<arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i+=1\\n        }\\n    }\\n    \\n};", "var duplicateZeros = function(arr) {\\n    for (let i = 0 ; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};", "var duplicateZeros = function (arr) {\\n  const newArr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    newArr.push(arr[i]);\\n    arr[i] === 0 && newArr.push(0);\\n  }\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = newArr[i];\\n  }\\n};"]}
{"id": "238", "ref_js": ["var distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};", "var distributeCandies = function(candies, num_people) {\\n\\n    let cand = 1;\\n    let result = new Array(num_people).fill(0);\\n    let pointer = 0; \\n\\n    while (candies > 0){\\n        if(pointer === num_people){\\n            pointer = 0;\\n        }\\n        result[pointer] += Math.min(cand,candies);\\n        candies -= cand;\\n        pointer++;\\n        cand++;\\n    }\\n\\n    return result;\\n    \\n};", "var distributeCandies = function(candies, num_people) {\\n   let arr = new Array(num_people).fill(0);\\n   let p = 1;\\n   let j = 0;\\n\\n   while(candies > 0){\\n       if(candies < p){\\n           arr[j] += candies;\\n           break;\\n       }\\n       arr[j] += p;\\n       candies -= p;\\n       p++;\\n       j = (j + 1) % num_people;\\n   }  \\n   return arr;\\n};"]}
{"id": "239", "ref_js": ["var defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};", "var defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};", "var defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};"]}
{"id": "241", "ref_js": ["var relativeSortArray = function(arr1, arr2) {\\n    return arr1.sort((a,b) => (arr2.indexOf(a) === -1 ? arr1.length + a : arr2.indexOf(a)) - (arr2.indexOf(b) === -1 ? arr1.length + b : arr2.indexOf(b)));\\n};", "var relativeSortArray = function(arr1, arr2) {\\n  const lookup = new Map();\\n  const N = arr2.length;\\n  arr2.forEach((a, i) => {\\n    lookup.set(a, i);\\n  });\\n  return arr1.sort((a, b) => {\\n    a = lookup.has(a) ? lookup.get(a) : N + a;\\n    b = lookup.has(b) ? lookup.get(b) : N + b;\\n    return a - b;\\n  });\\n};", "var relativeSortArray = function(arr1, arr2) {\\n    let res1 = [];\\n    for(let i=0;i<arr2.length;i++){\\n        for(let j=0;j<arr1.length;j++){\\n            if(arr2[i] == arr1[j]){\\n                res1.push(arr1[j]);\\n                arr1.splice(j,1);\\n                j--;\\n            }\\n        }\\n    }\\n    arr1.sort((a, b)=>a-b);\\n    return [...res1, ...arr1];\\n};"]}
{"id": "242", "ref_js": ["var numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};", "var numEquivDominoPairs = function(d) {\\n    arr = Array(100).fill(0)\\n    ans = 0\\n\\n    for (let i = 0; i < d.length; i++) {\\n        v = Math.min(d[i][0], d[i][1]) * 10 + Math.max(d[i][0], d[i][1])    \\n        if (arr[v] > 0) ans += arr[v]\\n        arr[v] ++\\n    }\\n \\n    return ans\\n};", "var numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for(let [a, b] of dominoes){\\n        let key = a < b ? `${a}${b}` : `${b}${a}`\\n        if(map.has(key)){\\n            let currIndex = map.get(key) + 1;\\n            map.set(key, currIndex);\\n            count += currIndex;\\n        }\\n        else {\\n            map.set(key, 0);\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "243", "ref_js": ["var tribonacci = function(n) {\\n    let dp = new Array(n+1).fill(0);\\n    dp[1] = 1\\n    dp[2] = 1;\\n    for(let i =3; i<=n; i++){\\n        dp[i] = dp[i-1] + dp[i-2] +dp[i-3]\\n    }\\n    return dp[n]\\n};", "var tribonacci = function (n) {\\n    if (cache[n] === undefined) {\\n        cache[n] = tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1);\\n    }\\n    return cache[n];\\n};", "var tribonacci = function(n) {\\n    if (n == 0) return 0;\\n    if (n == 1) return 1;\\n    if (n == 2) return 1;\\n    return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n};"]}
{"id": "246", "ref_js": ["var dayOfYear = function(date) {\\n    const d = new Date(date)\\n    let sum = 0\\n    const days = [31,leap(d.getFullYear()),31,30,31,30,31,31,30,31,30,31]\\n   \\n    for(let month=0;month<d.getMonth();month++){\\n        sum += days[month]\\n    }\\n    \\n    return sum + d.getDate()\\n};", "var dayOfYear = function(date) {\\n    let months = [31,28,31,30,31,30,31,31,30,31,30,31];\\n    let days = new Date(date);\\n    let theDay = days.getDate();\\n    let year = days.getFullYear();\\n    let month = days.getMonth();\\n    let sum = 0;\\n    for(let i=0; i<month; i++) sum+=months[i];\\n    if (isLeapYear(year) && month + 1 > 2) return(sum + theDay + 1);\\n    else  return(sum + theDay);\\n};", "var dayOfYear = function(date) {\\n    const year = parseInt(date.slice(0,4));\\n    const month = parseInt(date.slice(5,7));\\n    const day = parseInt(date.slice(8,10));\\n    const arrMonth=[31,28,31,30,31,30,31,31,30,31,30,31];\\n    let yearOfDay =0;\\n    for(let i=0;i<month-1;i++){\\n        yearOfDay = arrMonth[i]+yearOfDay\\n    }\\n    yearOfDay = yearOfDay+day;\\n\\n<!-- LEAP YEAR CASE -->\\n\\n    if(year % 4== 0 &&  month>2 ){\\n        if(year % 100 == 0){\\n            if(year%400 == 0){\\n                yearOfDay +=1\\n            }\\n        }else{\\n            yearOfDay+=1;\\n        }\\n    }\\n    return yearOfDay;\\n\\n};"]}
{"id": "247", "ref_js": ["var countCharacters = function(words, chars) {\\n    const counts = new Array(26).fill(0);\\n\\n    ", "var countCharacters = function(words, chars) {\\n    const ch = {};", "var countCharacters = function(words, chars) {\\n    const counts = new Array(26).fill(0);\\n\\n    "]}
{"id": "249", "ref_js": ["var numPrimeArrangements = function(n) {\\n    let mod = 10 ** 9 + 7;\\n    let primes = 0, nonPrimes = 0;\\n    let res = 1;\\n    for(let i = 1; i <= n; i++){\\n        if(isPrime(i)) res *= ++primes;\\n        else res *= ++nonPrimes;\\n        res = res % mod;\\n    }\\n    return res;\\n};", "var numPrimeArrangements = function(n) {\\n    let prime = 0\\n    let nonprime = 0\\n    let arrangements = 1\\n    let MOD = 10**9 + 7\\n\\n    const isPrime = (num) => {\\n        if(num < 2) return false\\n        if(num % 2 == 0) return num == 2\\n        let root = Math.floor(Math.sqrt(num))\\n\\n        for(let i = 3; i <= root; ++i) {\\n            if(num % i == 0) return false\\n        }\\n\\n        return true\\n    }\\n\\n    for(let i = 1; i <= n; ++i) {\\n        if(isPrime(i)) arrangements *= ++prime\\n        else if(!isPrime(i)) arrangements *= ++nonprime\\n        arrangements %= MOD\\n    }\\n\\n    return arrangements\\n};", "var numPrimeArrangements = function(n) {\\n    const mod = 10**9 + 7;\\n    let primes = 0, nonPrimes = 0;\\n    let res = 1;\\n    var isPrime = function(n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        let i = 2;\\n        while (i <= Math.sqrt(n)) {\\n            if (n % i == 0) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n    for (let i = 1; i <= n; i++) {\\n        if (isPrime(i)) res *= ++primes;\\n        else res *= ++nonPrimes;\\n        res = res % mod;\\n    }\\n    return res;\\n};"]}
{"id": "251", "ref_js": ["var distanceBetweenBusStops = function (distance, start, destination) {\\n  let result = 0;\\n  let result2 = 0;\\n  let sum = 0;\\n  if (start > destination) {\\n    [start, destination] = [destination, start]\\n  }\\n\\n  result=clockWise(distance, start, destination);\\n  result2=antiClockWise(distance,result)\\n  const output = result > result2 ? result2 : result;\\n  return output\\n  };", "var distanceBetweenBusStops = function(distance, start, destination) {\\n    let totalDistance = 0;\\n    let output = 0;\\n    \\n    for (let i = 0; i < distance.length; i++) {\\n        totalDistance += distance[i];\\n        \\n        if (start < destination) {\\n            if (i + 1 > start && i + 1 <= destination) {\\n                output += distance[i];\\n            }\\n        } else if (start > destination) {\\n            if ((i + 1 <= destination) || (i + 1 > start)) {\\n                output += distance[i];\\n            }\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    return Math.min(output, totalDistance - output);\\n};", "var distanceBetweenBusStops = function(distance, start, destination) {\\n    let totalDistance = distance.reduce((a,b) => a+b,0);\\n    let clockwiseDistance = 0;\\n    \\n    let begining = Math.min(start, destination);\\n    let finish = Math.max(start, destination);\\n     \\n    for (let i = begining; i < finish; i++) {\\n        clockwiseDistance += distance[i];\\n    }\\n\\n    let counterclockwiseDistance = totalDistance - clockwiseDistance;\\n\\n    return Math.min(clockwiseDistance, counterclockwiseDistance);\\n};"]}
{"id": "252", "ref_js": ["var dayOfTheWeek = function(day, month, year) {\\n    let weekDay = [\"Saturday\",\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"];\\n\\n    if (month < 3) {\\n        month += 12;\\n        year -= 1;\\n    }\\n    \\n    let k = year%100\\n    let j = Math.floor(year/100)\\n    let q =day\\n    let m= month;\\n    \\n    return weekDay[calculate(q,k,j,m)]\\n\\nfunction calculate(q,k,j,m){\\n    let h = q+Math.floor(13*(m+1)/5)+k+Math.floor(k/4)+Math.floor(j/4)+5*j\\n    return h%7\\n}\\n};", "var dayOfTheWeek = function(day, month, year) {\\n    let options = {weekday: \\'long\\'}\\n    let date = new Date(year, month - 1, day)\\n    return date.toLocaleDateString(\\'en-US\\', options)\\n};", "var dayOfTheWeek = function (day, month, year) {\\n    let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\\n\\nconst d = new Date(`${month},${day},${year}`);\\nlet dayy = d.getDay()\\nreturn days[dayy]\\n\\n};"]}
{"id": "253", "ref_js": ["var maxNumberOfBalloons = function(text) {\\n    const map = { b: 0, a: 0, l: 0, o: 0, n: 0, };", "var maxNumberOfBalloons = function(text) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < text.length; i++) {\\n        if (hashmap.has(text[i])) {\\n            hashmap.set(text[i], hashmap.get(text[i]) + 1);\\n        } else {\\n            hashmap.set(text[i], 1);\\n        }\\n    }\\n    \\n    let output = Infinity;\\n    const arr = Object.keys(BALLOON);\\n    for (let i = 0; i < arr.length; i++) {\\n        const character = arr[i];\\n        if (!hashmap.has(character)) return 0;\\n\\n        output = Math.min(Math.floor(hashmap.get(character)/(BALLOON[character])), output)\\n    }\\n    return output;\\n};", "var maxNumberOfBalloons = function(text) {\\n    const map = {};"]}
{"id": "254", "ref_js": ["var minimumAbsDifference = function(arr) {\\n    let minAblosute = Infinity;\\n    let output = [];\\n\\n    arr = arr.sort((a, b) => a - b);\\n    for (let i = 0; i < arr.length - 1; i++) {\\n        const minus = arr[i + 1] - arr[i];\\n        if (minus < minAblosute) {\\n            minAblosute = minus;\\n            output = [[arr[i], arr[i + 1]]];\\n        } else if (minus === minAblosute) {\\n            output.push([arr[i], arr[i + 1]]);\\n        }\\n    }\\n    \\n    return output;\\n};", "var minimumAbsDifference = function (arr) {\\n    arr = arr.sort((a, b) => a - b)\\n    let sol = []\\n    let min = arr[1] - arr[0]\\n\\n    for (let i = 1; i < arr.length - 1; i++) {\\n        if (arr[i + 1] - arr[i] < min) {\\n            min = arr[i + 1] - arr[i]\\n            sol = []\\n        }\\n        if (arr[i + 1] - arr[i] == min) sol.push([arr[i], arr[i + 1]])\\n    }\\n\\n    if (min == arr[1] - arr[0]) sol.unshift([arr[0], arr[1]])\\n\\t\\n    return sol\\n};", "var minimumAbsDifference = function(arr) {\\n    let min = Number.MAX_VALUE;\\n    let result = [];\\n    arr = arr.sort((a,b) => a-b);\\n    for(let i = 1; i < arr.length;i++){\\n        let diff = arr[i] - arr[i-1];\\n        if(diff < min){\\n            min = diff;\\n            result = [[arr[i-1], arr[i]]];\\n        }else if(diff == min){\\n            result.push([arr[i-1], arr[i]])\\n        }\\n    }\\n    return result\\n};"]}
{"id": "255", "ref_js": ["var uniqueOccurrences = function(arr) {\\n    let count = 1;\\n    let countArr = [];\\n\\n    ", "var uniqueOccurrences = function (arr) {\\n    ", "var uniqueOccurrences = function (arr) {\\n    "]}
{"id": "257", "ref_js": ["var minCostToMoveChips = function(position) {\\n    let countOdd = 0;\\n\\n    for (let i = 0; i < position.length; i++) {\\n        if (position[i]%2) countOdd++;\\n    }\\n    \\n    return countOdd >= position.length/2 ? position.length - countOdd : countOdd;\\n};", "var minCostToMoveChips = function(position) {\\n    let even = 0, odd = 0\\n    for(let i = 0; i < position.length; i++) {\\n        if(position[i] % 2 == 0) {\\n            even++\\n        } else {\\n            odd++\\n        }\\n    }\\n    return even < odd ? even : odd\\n};", "var minCostToMoveChips = function(position) {\\n    let even = 0, odd = 0\\n    for(let i = 0; i < position.length; i++) {\\n        if(position[i] % 2 == 0) {\\n            even++\\n        } else {\\n            odd++\\n        }\\n    }\\n    return even < odd ? even : odd\\n};"]}
{"id": "258", "ref_js": ["var balancedStringSplit = function (s) {\\n  let count = 0\\n  let countBalanced = 0\\n\\n  for (let i = 0; i < s.length; i++) {\\n    s[i] === \\'L\\' ? count++ : count-- \\n\\n    if (count === 0) {\\n      countBalanced++\\n    }\\n  }\\n\\n  return countBalanced\\n};", "var balancedStringSplit = function(s) {\\n    let output = 1;\\n    for (let i = 2; i < s.length; i += 2) {\\n        if (checkBalanced(s.slice(0, i))) {\\n            const newValue = 1 + balancedStringSplit(s.slice(i, s.length));\\n            if (newValue > output) {\\n                output = newValue;\\n                break;\\n            }\\n        }\\n    }\\n    return output;\\n};", "var balancedStringSplit = function (s) {\\n  let balance = 0;\\n  let result = 0;\\n\\n  for (const i of s) {\\n    if (i === \\'L\\') balance--;\\n    else balance++;\\n    if (balance === 0) result++;\\n  }\\n\\n  return result;\\n};"]}
{"id": "259", "ref_js": ["var isStraight = function([[ax,ay],[bx,by],[cx,cy]]) {\\n    return ((by-ay)*(cx-bx)===(cy-by)*(bx-ax));\\n};", "var checkStraightLine = function(coordinates) {\\r\\n    coordLen = coordinates.length\\r\\n\\r\\n    if(coordLen <= 2) return true\\r\\n\\r\\n    function calculateSlope(x1, y1, x2, y2, x, y) {\\r\\n    return (y2 - y1) * (x - x1) - (y - y1) * (x2 - x1);\\r\\n  }\\r\\n\\r\\n    let [x1, y1] = coordinates[0]\\r\\n    let [x2, y2] = coordinates[1]\\r\\n\\r\\n   for (let i = 2; i < coordinates.length; i++) {\\r\\n    let [x, y] = coordinates[i];\\r\\n    if (calculateSlope(x1, y1, x2, y2, x, y) !== 0) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return true;\\r\\n};", "var isStraight = function([[ax,ay],[bx,by],[cx,cy]]) {\\n    return ((by-ay)*(cx-bx)===(cy-by)*(bx-ax));\\n};"]}
{"id": "261", "ref_js": ["var oddCells = function(m, n, indices) {\\n    const matrix = new Array(m).fill(0).map(item => new Array(n).fill(0));\\n    let output = 0;\\n    \\n    for (let i = 0; i < indices.length; i++) {\\n        const [x, y] = indices[i];\\n        \\n        for (let j = 0; j < n; j++) {\\n            matrix[x][j]++;\\n            if (matrix[x][j]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n        for (let p = 0; p < m; p++) {\\n            matrix[p][y]++;\\n            if (matrix[p][y]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n    }\\n    return output;\\n};", "var oddCells = function(m, n, indices) {\\n    const matrix = new Array(m).fill(0).map(item => new Array(n).fill(0));\\n    let output = 0;\\n    \\n    for (let i = 0; i < indices.length; i++) {\\n        const [x, y] = indices[i];\\n        \\n        for (let j = 0; j < n; j++) {\\n            matrix[x][j]++;\\n            if (matrix[x][j]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n        for (let p = 0; p < m; p++) {\\n            matrix[p][y]++;\\n            if (matrix[p][y]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n    }\\n    return output;\\n};", "var oddCells = function(m, n, indices) {\\n    const matrix = new Array(m).fill(0).map(item => new Array(n).fill(0));\\n    let output = 0;\\n    \\n    for (let i = 0; i < indices.length; i++) {\\n        const [x, y] = indices[i];\\n        \\n        for (let j = 0; j < n; j++) {\\n            matrix[x][j]++;\\n            if (matrix[x][j]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n        for (let p = 0; p < m; p++) {\\n            matrix[p][y]++;\\n            if (matrix[p][y]%2) {\\n                output++;\\n            } else {\\n                output--;\\n            }\\n        }\\n    }\\n    return output;\\n};"]}
{"id": "262", "ref_js": ["var shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};", "var shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};", "var shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};"]}
{"id": "263", "ref_js": ["var toTime = function(from, to) {\\n    var xDiff = Math.abs(from[0] - to[0]);\\n    var yDiff = Math.abs(from[1] - to[1]);\\n\\n    return Math.max(xDiff, yDiff);\\n};", "var minTimeToVisitAllPoints = function(points) {\\n    let ans = 0;\\n    const n = points.length;\\n\\n    for (let i = 1; i < n; ++i) {\\n        const diffx = Math.abs(points[i][0] - points[i - 1][0]);\\n        const diffy = Math.abs(points[i][1] - points[i - 1][1]);\\n\\n        ans += Math.max(diffx, diffy);\\n    }\\n\\n    return ans;\\n};", "var minTimeToVisitAllPoints = function(points) {\\n    let a = points[0][0];\\n    let b = points[0][1];\\n    let res = 0;\\n    for(let i=1; i<points.length; i++) {\\n        let maxa = Math.abs(a - points[i][0]);\\n        let maxb = Math.abs(b - points[i][1]);\\n        res = res + Math.max(maxa, maxb);\\n        a = points[i][0];\\n        b = points[i][1];\\n    }\\n    return res;\\n};"]}
{"id": "264", "ref_js": ["var tictactoe = function(moves) {\\n  ", "var tictactoe = function(moves) {\\n    let n = 3;\\n    ", "var tictactoe = function(moves) {\\n    let n = 3;\\n    "]}
{"id": "266", "ref_js": ["var subtractProductAndSum = function (n) {\\n  let pro = 1;\\n  let sum = 0;\\n\\n  while (n > 0) {\\n    const dig = n % 10;\\n    pro *= dig;\\n    sum += dig;\\n    n = Math.floor(n / 10);\\n  }\\n\\n  return pro - sum;\\n};", "var subtractProductAndSum = function(n) {\\n    n = n.toString();\\n    let sum=0;\\n    let product =1;\\n    for(let i = 0 ; i<n.length ; i++){\\n        sum += parseInt(n[i]);\\n        product *= parseInt(n[i]);\\n    }\\n\\n    let result = product - sum ;\\n\\n    return result;\\n    \\n};", "var subtractProductAndSum = function(n) {\\n    let prod = 1;\\n    let sum = 0;\\n    while(n !== 0){\\n        let lastDigit = n % 10;\\n        prod *= lastDigit;\\n        sum += lastDigit;\\n        n = Math.floor(n / 10);\\n    }\\n    return prod - sum;\\n};"]}
{"id": "267", "ref_js": ["var findSpecialInteger = function(arr) {\\n    const n = arr.length;\\n    const quarter = Math.floor(n / 4);\\n\\n    for (let i = 0; i < n - quarter; i++) {\\n        if (arr[i] === arr[i + quarter]) {\\n            return arr[i];\\n        }\\n    }\\n};", "var findSpecialInteger = function(arr) {\\n    let size = arr.length;\\n    let qtr = Math.floor(size / 4);\\n    let cnt = 1;\\n    let p = arr[0];\\n\\n    for (let i = 1; i < size; i++) {\\n        if (p === arr[i]) {\\n            cnt++;\\n        } else {\\n            cnt = 1;\\n        }\\n\\n        if (cnt > qtr) {\\n            return arr[i];\\n        }\\n\\n        p = arr[i];\\n    }\\n\\n    return p;\\n\\n};", "var findSpecialInteger = function(arr) {\\n    let size = arr.length;\\n    let qtr = Math.floor(size / 4);\\n    let cnt = 1;\\n    let p = arr[0];\\n\\n    for (let i = 1; i < size; i++) {\\n        if (p === arr[i]) {\\n            cnt++;\\n        } else {\\n            cnt = 1;\\n        }\\n\\n        if (cnt > qtr) {\\n            return arr[i];\\n        }\\n\\n        p = arr[i];\\n    }\\n\\n    return p;\\n\\n};"]}
{"id": "268", "ref_js": ["var getDecimalValue = function(head) {\\n    let cur = head, len = 0, sum = 0;\\n    \\n    while (cur) {\\n        cur = cur.next;\\n        len++;\\n    }\\n    \\n    while (head) {\\n        sum += Math.pow(2, --len) * head.val\\n        head = head.next;\\n    }\\n    \\n    return sum;\\n    \\n};", "var getDecimalValue = function(head) {\\n    let total=0;\\n    while(head!=null){\\n        total=total*2+head.val;\\n        head=head.next;\\n    }\\n    return total;\\n};", "var getDecimalValue = function(head) {\\n    let total=0;\\n    while(head!=null){\\n        total=total*2+head.val;\\n        head=head.next;\\n    }\\n    return total;\\n};"]}
{"id": "269", "ref_js": ["var findNumbers = function(nums) {\\n     let count=0;\\n     for(let x of nums)\\n     count+=Math.floor(Math.log10(x)+1)%2==0;\\n     return count;\\n};", "var findNumbers = function(nums) {\\n  let count=0\\n  for(let j=0;j<nums.length;j++){\\n  let numToArray =  Array.from(String(nums[j]), Number);\\n    if(numToArray.length%2 === 0){\\n        count++\\n    }\\n\\n  }\\n  return count\\n};", "var findNumbers = function(nums) {\\n  let count=0\\n  for(let j=0;j<nums.length;j++){\\n  let numToArray =  Array.from(String(nums[j]), Number);\\n    if(numToArray.length%2 === 0){\\n        count++\\n    }\\n\\n  }\\n  return count\\n};"]}
{"id": "270", "ref_js": ["var replaceElements = function(arr) {\\n    let max = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n    \\n    for(let i = arr.length - 2; i >= 0; i--) {\\n        let curr = arr[i];\\n        arr[i] = max;\\n        if(curr > max) max = curr;\\n    }\\n    \\n    return arr;\\n};", "var replaceElements = function(arr) {\\n    let currentMax = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n\\n    for (let i = arr.length - 2; i >= 0; i--) {\\n        if (currentMax > arr[i]) {\\n            arr[i] = currentMax;\\n        } else {\\n            const temp = currentMax;\\n            currentMax = arr[i];\\n            arr[i] = temp;\\n        }\\n    }\\n    \\n    return arr;\\n};", "var replaceElements = function(arr) {\\n    let currentMax = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n\\n    for (let i = arr.length - 2; i >= 0; i--) {\\n        if (currentMax > arr[i]) {\\n            arr[i] = currentMax;\\n        } else {\\n            const temp = currentMax;\\n            currentMax = arr[i];\\n            arr[i] = temp;\\n        }\\n    }\\n    \\n    return arr;\\n};"]}
{"id": "271", "ref_js": ["var sumZero = function(n) {\\n    let i=0\\n    const arr=[]\\n    if(n%2==0){\\n        let t=0-(n/2)-1\\n        for(i=0;i<n;i++){\\n            t++\\n            if(t==0){\\n                t++\\n            }\\n            arr[i]=t\\n            \\n        }\\n    }else{\\n        let t=0-Math.floor(n/2)-1\\n        for(i=0;i<n;i++){\\n            t++\\n            arr[i]=t\\n        }\\n    }\\n    return arr\\n};", "var sumZero = function(n) {\\n    let arr = [];\\n    \\n    for (let i = 1; i <= n/2; i++) {\\n       arr.push(i, -i); \\n    }\\n    \\n    if (n%2){\\n      arr.push(0);\\n    } \\n    \\n    return arr;\\n};", "var sumZero = function(n) {\\n  let answer = new Array(n).fill(0)\\n  \\n  var x\\n  if(n%2 ==0){\\n       x=Math.floor(n/2);\\n        answer[n-1]=0;  \\n  }  else{\\n      x=Math.floor((n-1)/2);  \\n  }\\n    for(let i=1;i<=x;i++){    \\n              answer[i-1]=-1*i;          \\n              answer[i-1+x]=i;\\n        }\\n      return answer; \\n};"]}
{"id": "272", "ref_js": ["var freqAlphabets = function(s) {\\n   ", "var freqAlphabets = function(s) {\\n    s = s.split(\\'#\\');\\n    let output = \\'\\';\\n    \\n    for (let i = 0; i < s.length - 1; i++) {\\n        const character = s[i];\\n        const double = character.substring(character.length - 2, character.length);\\n        \\n        for (let j = 0; j < character.length - 2; j++) {\\n            output +=  String.fromCharCode(+character[j] + 96);\\n        }\\n        output +=  String.fromCharCode(+double + 96)\\n    }\\n    \\n    const character = s[s.length - 1];\\n    if (character) {\\n        for (let i = 0; i < character.length; i++) {\\n            output +=  String.fromCharCode(+character[i] + 96);\\n        }\\n    }\\n\\n    return output;\\n};", "var freqAlphabets = function(s) {\\n   "]}
{"id": "273", "ref_js": ["var decompressRLElist = function(nums) {\\n  let result = [];\\n  let i = 0, j = 1;\\n\\n  while(j < nums.length) {\\n    let freq = nums[i];\\n    for(let count = 0; count < freq; ++count) {\\n        result.push(nums[j]);\\n    }\\n     i += 2;\\n     j += 2;\\n  }\\n\\n\\n  return result;  \\n};", "var decompressRLElist = function (nums) {\\n  let result = [];\\n\\n  for (let i = 0; i < nums.length; i += 2) {\\n    let counter = nums[i];\\n    while (counter--) {\\n      result.push(nums[i + 1]);\\n    }\\n  }\\n  \\n  return result;\\n};", "var decompressRLElist = function (nums) {\\n  let result = [];\\n\\n  for (let i = 0; i < nums.length; i += 2) {\\n    let counter = nums[i];\\n    while (counter--) {\\n      result.push(nums[i + 1]);\\n    }\\n  }\\n  \\n  return result;\\n};"]}
{"id": "274", "ref_js": ["var getNoZeroIntegers = function(n) {\\n    for(let indexI=1; indexI<n; indexI++){\\n        const firstNum=indexI;\\n        const secondNum = n-indexI;\\n\\n        if(secondNum.toString().match(/[0]/g) || firstNum.toString().match(/[0]/g)) continue;\\n\\n        return [firstNum, secondNum]\\n    }\\n};", "var getNoZeroIntegers = function (n) {\\n    let b = 1;\\n    let a = n - b;\\n\\n    while (a.toString().includes(\\'0\\') || b.toString().includes(\\'0\\')) {\\n        a -= 1;\\n        b += 1\\n    }\\n    return [a, b]\\n};", "var getNoZeroIntegers = function(n) {\\n \\n    for(let i=1;i<n;i++)\\n    {\\n            let a=i;\\n           let  b=n-i;\\n           if(!String(a).includes(\\'0\\') && !String(b).includes(\\'0\\'))\\n           return [a,b]\\n    }\\n   \\n};"]}
{"id": "275", "ref_js": ["var maximum69Number  = function(num) {\\n    return +num.toString().replace(\\'6\\',\\'9\\');\\n};", "var maximum69Number  = function(num) {\\n    let numStr = num.toString();\\n    \\n    ", "var maximum69Number  = function(num) {\\n    let nums = num.toString();\\n    const numsArray = nums.split(\\'\\');\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i]==6){\\n            numsArray[i] = \\'9\\';\\n            break;\\n        }\\n    }\\n    nums = numsArray.join(\\'\\');\\n    return parseInt(nums);\\n};"]}
{"id": "277", "ref_js": ["var arrayRankTransform = function(arr) {\\n    let obj = {}\\n    let newArr = [...arr].sort((a,b) => a-b)\\n    let rank = 1\\n    for(let i = 0; i < newArr.length;i++) {\\n        if(obj[newArr[i]]) {\\n        } else {\\n            obj[newArr[i]] = rank\\n            rank++\\n        }\\n    }\\n\\n    for(let i = 0; i < arr.length;i++) {\\n        arr[i] = obj[arr[i]]\\n    }\\n\\n    return arr\\n};", "var arrayRankTransform = function (arr) {\\n  var sorted = Array.from(new Set(arr)).sort((a, b) => a - b);\\n  return arr.map((x) => sorted.indexOf(x) + 1);\\n};", "var arrayRankTransform = function(arr) {\\n    let keys = 0;\\n\\n    const ranks = [...arr].sort((a, b) => a - b).reduce((res, x) => {\\n        if (!res[x]) {\\n            res[x] = 1 + keys++;\\n        }\\n        \\n        return res;\\n    }, {});\\n    \\n    return arr.map(x => ranks[x]);\\n};"]}
{"id": "278", "ref_js": ["var removePalindromeSub = function(S) {\\n    if (!S) return 0\\n    for (let i = 0, j = S.length - 1; i < j; i++, j--)\\n        if (S.charAt(i) !== S.charAt(j)) return 2\\n    return 1\\n};", "var removePalindromeSub = function(s) {\\n  return s === s.split(\\'\\').reverse().join(\\'\\') ? 1 : 2;\\n};", "var removePalindromeSub = function(s) {\\n    if (s.length === 0) {\\n        return 0;\\n    }\\n    \\n    return checkIfPalindrome(s);\\n};"]}
{"id": "279", "ref_js": ["var kWeakestRows = function(mat, k) {\\n    let rowStrengthSet = new Set();\\n\\n    for (let rowIndex = 0; rowIndex < mat.length; rowIndex++) {\\n        let oneCount = 0;\\n\\n        for (let colIndex = 0; colIndex < mat[rowIndex].length; colIndex++) {\\n            if (mat[rowIndex][colIndex] === 1) {\\n                oneCount++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        rowStrengthSet.add([oneCount, rowIndex]);\\n    }\\n\\n    const sortedRows = Array.from(rowStrengthSet);\\n    sortedRows.sort((a, b) => a[0] - b[0]);\\n\\n    let weakestRowIndices = [];\\n    for (let i = 0; i < k; i++) {\\n        weakestRowIndices.push(sortedRows[i][1]);\\n    }\\n\\n    return weakestRowIndices;    \\n};", "var kWeakestRows = function(mat, k) {\\n    let rowStrengths = mat.map((row, i) => [row.reduce((a, b) => a + b, 0), i]);\\n    rowStrengths.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    return rowStrengths.slice(0, k).map(([_, i]) => i);\\n};", "var kWeakestRows = function(mat, k) {\\n    let rowStrengthSet = new Set();\\n\\n    for (let rowIndex = 0; rowIndex < mat.length; rowIndex++) {\\n        let oneCount = 0;\\n\\n        for (let colIndex = 0; colIndex < mat[rowIndex].length; colIndex++) {\\n            if (mat[rowIndex][colIndex] === 1) {\\n                oneCount++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        rowStrengthSet.add([oneCount, rowIndex]);\\n    }\\n\\n    const sortedRows = Array.from(rowStrengthSet);\\n    sortedRows.sort((a, b) => a[0] - b[0]);\\n\\n    let weakestRowIndices = [];\\n    for (let i = 0; i < k; i++) {\\n        weakestRowIndices.push(sortedRows[i][1]);\\n    }\\n\\n    return weakestRowIndices;    \\n};"]}
{"id": "280", "ref_js": ["var numberOfSteps = function(num) {\\n\\n\\tif (num == 0)\\n\\t\\treturn num;\\n\\n\\treturn 1 + (num % 2 == 0 ? numberOfSteps(num / 2) : numberOfSteps(num - 1));\\n\\n    \\n};", "var numberOfSteps = function (num) {\\n  let steps = 0;\\n\\n  while (num > 0) {\\n    steps++;\\n\\n    if (num % 2 === 0) {\\n      num /= 2;\\n    } else {\\n      num -= 1;\\n    }\\n  }\\n\\n  return steps;\\n};", "var numberOfSteps = function(num) {\\n\\n\\tif (num == 0)\\n\\t\\treturn num;\\n\\n\\treturn 1 + (num % 2 == 0 ? numberOfSteps(num / 2) : numberOfSteps(num - 1));\\n\\n    \\n};"]}
{"id": "281", "ref_js": ["var checkIfExist = function(arr) {\\n   let check = false\\n    for(let i = 0;i<arr.length;i++){\\n      for(let j=0;j<arr.length;j++){\\n          if(i!=j && arr[i]==2*arr[j]){\\n            check = true\\n          }\\n      }\\n    }\\n  return check\\n};", "var checkIfExist = function(arr) {\\n   let check = false\\n    for(let i = 0;i<arr.length;i++){\\n      for(let j=0;j<arr.length;j++){\\n          if(i!=j && arr[i]==2*arr[j]){\\n            check = true\\n          }\\n      }\\n    }\\n  return check\\n};", "var checkIfExist = function(arr) {\\n   let check = false\\n    for(let i = 0;i<arr.length;i++){\\n      for(let j=0;j<arr.length;j++){\\n          if(i!=j && arr[i]==2*arr[j]){\\n            check = true\\n          }\\n      }\\n    }\\n  return check\\n};"]}
{"id": "282", "ref_js": ["var countNegatives = function(grid) {\\n    let count = 0;\\n    for(let i of grid)\\n    for(let j of i)\\n    {\\n        if(j<0)\\n        count++;\\n    }\\n    return count;\\n};", "var countNegatives = function(grid) {\\n    let [x,y] = [grid.length, grid[0].length];\\n    let output = 0;\\n    for (let i = 0; i < x; i++) {\\n        for (let j = 0; j < y; j++) {\\n            if (grid[i][j] < 0) {\\n                output += (y - j)*(grid.length - i);\\n                y = j;\\n                break;\\n            }\\n        }\\n    }\\n    return output;\\n};", "var countNegatives = function(grid) {\\n    let count = 0;\\n\\n    grid.forEach((elem) => {\\n        count = linearSearch(elem, count);\\n    });\\n\\n    return count;\\n    \\n    function linearSearch(array, score){\\n        array.forEach((elem) => {\\n            if(elem < 0){\\n                score++;\\n            }\\n        });\\n        return score;\\n    }\\n};"]}
{"id": "283", "ref_js": ["var sortByBits = function(arr) {\\n    return arr.sort((a, b) => {\\n        let countA = a.toString(2).split(\\'\\').filter(bit => bit === \\'1\\').length;\\n        let countB = b.toString(2).split(\\'\\').filter(bit => bit === \\'1\\').length;\\n        return countA - countB || a - b;\\n    });\\n};", "var sortByBits = function(arr) {\\n    return arr.sort((a, b) => {\\n        let countA = a.toString(2).split(\\'\\').filter(bit => bit === \\'1\\').length;\\n        let countB = b.toString(2).split(\\'\\').filter(bit => bit === \\'1\\').length;\\n        return countA - countB || a - b;\\n    });\\n};", "var sortByBits = function(arr) {\\n    return arr.sort((a, b) => {\\n        let countA = a.toString(2).split(\\'\\').filter(bit => bit === \\'1\\').length;\\n        let countB = b.toString(2).split(\\'\\').filter(bit => bit === \\'1\\').length;\\n        return countA - countB || a - b;\\n    });\\n};"]}
{"id": "284", "ref_js": ["var daysBetweenDates = function(date1, date2) {\\n    const days1 = calculateDays(date1)\\n    const days2 = calculateDays(date2)\\n    \\n    return Math.abs(days1 - days2)\\n};", "var daysBetweenDates = function(date1, date2) {\\n    const days1 = calculateDays(date1)\\n    const days2 = calculateDays(date2)\\n    \\n    return Math.abs(days1 - days2)\\n};", "var daysBetweenDates = function(date1, date2) {\\n    const days1 = calculateDays(date1)\\n    const days2 = calculateDays(date2)\\n    \\n    return Math.abs(days1 - days2)\\n};"]}
{"id": "285", "ref_js": ["var smallerNumbersThanCurrent = function(nums) {\\n    let i=0;\\n    let res = []\\n    forLoop(nums, i, res);\\n    return res;\\n};", "var smallerNumbersThanCurrent = function (nums) {\\n  let res = [];\\n\\n  for (const i of nums) {\\n    const c = nums.reduce((count, num) => {\\n      if (num < i) count++;\\n      return count;\\n    }, 0);\\n    res.push(c);\\n  }\\n\\n  return res;\\n};", "var smallerNumbersThanCurrent = function(nums) {\\n    let newArray=[]\\n    for(i=0;i<nums.length;i++){\\n    let count=0\\n        for(j=0;j<nums.length;j++){\\n            if(nums[j]<nums[i])\\n        {\\n            count++\\n        }\\n\\n        }\\n        if(count===0){\\n            newArray.push(count)\\n        }else{\\n             newArray.push(count)\\n        }\\n    }\\n    return  newArray\\n};"]}
{"id": "286", "ref_js": ["var sortString = function(s) {\\n    memo=new Array(26).fill(0)\\n    str=[]\\n    for(let i=0;i<s.length;i++){\\n        memo[s.charCodeAt(i)-97]++\\n    }\\n    let flag=true\\n    while(str.length!==s.length){\\n        \\n        for(let i=0;i<memo.length;i++){\\n            let pos=i\\n            \\n            if(!flag){\\n                pos=25-i\\n            }\\n            if(memo[pos]!== 0){\\n            str.push(String.fromCharCode(pos+97))\\n            memo[pos]--\\n            }\\n        }\\n        flag = ! flag\\n    }\\n  \\n  return str.join(\\'\\')\\n};", "var sortString = function (s) {\\n  const map = new Array(26).fill(0);\\n\\n  for (const char of s) {\\n    const charCode = char.charCodeAt(0) - 97;\\n    map[charCode]++;\\n  }\\n\\n  function appendCharToRes(i) {\\n    const char = String.fromCharCode(i + 97);\\n    res += char;\\n    map[i]--;\\n  }\\n\\n  let res = \"\";\\n\\n  while (res.length !== s.length) {\\n    for (let i = 0; i < map.length; i++) {\\n      if (!map[i]) continue;\\n      appendCharToRes(i);\\n    }\\n\\n    for (let i = map.length - 1; i >= 0; i--) {\\n      if (!map[i]) continue;\\n      appendCharToRes(i);\\n    }\\n  }\\n\\n  return res;\\n};", "var sortString = function(s) {\\n    const hashmap = {};"]}
{"id": "287", "ref_js": ["var generateTheString = function(n) {\\n    return n%2 ? new Array(n).fill(\\'a\\').join(\\'\\') : new Array(n - 1).fill(\\'a\\').join(\\'\\') + \\'b\\';\\n};", "var generateTheString = function(n) {\\n  return n % 2 === 0 ? `${\\'a\\'.repeat(n - 1)}b` : \\'a\\'.repeat(n);\\n};", "var generateTheString = function(n) {\\n  return n % 2 === 0 ? `${\\'a\\'.repeat(n - 1)}b` : \\'a\\'.repeat(n);\\n};"]}
{"id": "290", "ref_js": ["var luckyNumbers  = function(matrix) {\\n    for(let i = 0;i < matrix.length;i++) {\\n        let min = Math.min(...matrix[i]),\\n            idx = matrix[i].indexOf(min);\\n\\n        if(matrix.every(arr => arr[idx] <= min)) return [min];\\n    }\\n\\n    return [];\\n};", "var luckyNumbers  = function(matrix) {\\n    for(let i=0;i<matrix.length;i++){\\n        for(let j=0;j<matrix[0].length;j++){\\n            if(checkMinInRow(matrix,i,j) && checkMaxInCol(matrix,i,j)){\\n                return [matrix[i][j]]\\n            }\\n        }\\n    }\\n    return []\\n};", "var luckyNumbers  = function(matrix) {\\n    let [i, j] = [0,0];\\n    let rows = matrix.length - 1;\\n    let colums = matrix[0].length - 1;\\n    let final = [];\\n    for( let i = 0; i <= rows; i++ ){\\n        const smallest = Math.min(...matrix[i]);\\n        let result = findMaxInCol( smallest, matrix[i].indexOf(smallest), matrix );\\n        if( result == true) final.push(smallest);\\n    }\\n    return final; \\n};"]}
{"id": "291", "ref_js": ["var findTheDistanceValue = function(arr1, arr2, d) {\\n    let result = 0;\\n\\n    for(let i=0; i<arr1.length; i++){\\n        let flag = 0;\\n        for(let j=0; j<arr2.length; j++){\\n            if(Math.abs(arr1[i] - arr2[j]) <= d){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0){\\n            result++;\\n        }\\n    }\\n    return result;\\n};", "var findTheDistanceValue = function(arr1, arr2, d) {\\n    let count=0\\n    for(let i=0;i<arr1.length;i++){\\n        let c=0\\n        for(let j=0;j<arr2.length;j++){\\n            arr1[i]-arr2[j]\\n            const dis = Math.abs(arr1[i]-arr2[j]);\\n            if(dis<=d){\\n                c=1\\n                break;\\n            }\\n           \\n        }\\n        if(c===0){\\n            count++\\n        }\\n    }\\n    return count\\n};", "var findTheDistanceValue = function(arr1, arr2, d) {\\n    "]}
{"id": "292", "ref_js": ["var createTargetArray = function (nums, index) {\\n  let result = [];\\n\\n  for (let i = 0; i < index.length; i++) {\\n    result.splice(index[i], 0, nums[i]);\\n  }\\n\\n  return result;\\n};", "var createTargetArray = function (nums, index) {\\n  let result = [];\\n\\n  for (let i = 0; i < index.length; i++) {\\n    result.splice(index[i], 0, nums[i]);\\n  }\\n\\n  return result;\\n};", "var createTargetArray = function (nums, index) {\\n  let result = [];\\n\\n  for (let i = 0; i < index.length; i++) {\\n    result.splice(index[i], 0, nums[i]);\\n  }\\n\\n  return result;\\n};"]}
{"id": "293", "ref_js": ["var findLucky = function (arr) {\\n    var ln = -1, count;\\n    for (i = 0; i < arr.length; i++) {\\n        count = 0;\\n        if (arr[i] > ln) {\\n            for (j = 0; j < arr.length; j++) {\\n                if (arr[i] === arr[j]) count++;\\n            }\\n            if (count === arr[i]) ln = arr[i];\\n        }\\n    }\\n\\n    return ln\\n};", "var findLucky = function(arr) {\\n    arr = arr.sort((a,b) => a - b);\\n    let outputs = [{value: arr[0], count: 1}];\\n\\n    for (let i = 1; i < arr.length; i++) {\\n        const last = outputs[outputs.length - 1];\\n        if (last && arr[i] === last.value) {\\n            last.count++;\\n            if (last.count > last.value) {\\n                outputs.pop();\\n                while(arr[i+1] === last.value) i++;\\n            }\\n        } else {\\n            if (last && last.count !== last.value) {\\n                outputs.pop();\\n            }\\n            outputs.push({value: arr[i], count: 1});\\n        }\\n    }\\n\\n    const last = outputs[outputs.length - 1];\\n    if (last && last.count === last.value) {\\n        return last.value;\\n    } else {\\n        outputs.pop();\\n    }\\n    \\n    return outputs[outputs.length - 1]?.value || -1;\\n};", "var findLucky = function(arr) {\\n    const myMap = new Map();\\nfor(let i=0; i<arr.length; i++){\\n    if(myMap.has(arr[i])){\\n        myMap.set(arr[i],myMap.get(arr[i])+1);\\n    }else{\\n        myMap.set(arr[i],1);\\n    }\\n}\\nlet luckyInt = -1;\\nfor(let i=0; i<arr.length; i++){\\n    if(myMap.get(arr[i]) == arr[i]){\\n        if(arr[i]>luckyInt){\\n            luckyInt = arr[i];\\n        }\\n    }\\n}\\nreturn luckyInt;\\n};"]}
{"id": "294", "ref_js": ["var countLargestGroup = function(n) {\\n    const hashmap = new Map();\\n    let output = {\\n        value: 0,\\n        count: 0,\\n    };", "var countLargestGroup = function(n) {\\n    ", "var countLargestGroup = function(n) {\\n    "]}
{"id": "295", "ref_js": ["var minSubsequence = function(nums) {\\n    nums.sort((a, b) => b-a);\\n\\n    const result = [];\\n    let left = 0;\\n    let right = nums.length-1;\\n    let sum = 0;\\n    while (left <= right) {\\n        if (sum > 0) {\\n            sum-=nums[right];\\n            right--;\\n        } else {\\n            sum+=nums[left];\\n            result.push(nums[left]);\\n            left++;\\n        }\\n    }\\n\\n    if (sum <= 0) {\\n        result.push(nums[left])\\n    }\\n\\n\\n    return result;\\n};", "var minSubsequence = function(nums) {\\n    let res = [];\\n    nums.sort((a,b) => a - b);\\n    let sum = 0;\\n    let restSum = nums.reduce((acc,val) => acc + val,0);\\n\\n    while (sum <= restSum) {\\n        let max = nums.splice(nums.length - 1, 1);\\n        console.log(max,res)\\n        res.push(max[0]);\\n        restSum-=max[0];\\n        sum+=max[0];\\n    }\\n\\n    return res;\\n};", "var minSubsequence = function(nums) {\\n    let res = [];\\n    nums.sort((a,b) => a - b);\\n    let sum = 0;\\n    let restSum = nums.reduce((acc,val) => acc + val,0);\\n\\n    while (sum <= restSum) {\\n        let max = nums.splice(nums.length - 1, 1);\\n        console.log(max,res)\\n        res.push(max[0]);\\n        restSum-=max[0];\\n        sum+=max[0];\\n    }\\n\\n    return res;\\n};"]}
{"id": "297", "ref_js": ["var stringMatching = function(words) {\\n    let output = [];\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        for (let j = 0; j < words.length; j++) {\\n            if (i !== j && words[j].indexOf(words[i]) !== -1) {\\n                output.push(words[i]);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};", "var stringMatching = function(words) {\\n    ", "var stringMatching = function(words) {\\n    "]}
{"id": "298", "ref_js": ["var minStartValue = function(nums) {\\n    let output = 0;\\n    let currentSum = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (currentSum + nums[i] < 1) {\\n            output += -(currentSum + nums[i]) + 1;\\n            currentSum = 1;\\n        } else {\\n            currentSum += nums[i];\\n        }\\n    }\\n    \\n    return output || 1;\\n};", "var minStartValue = function(nums) {\\n    var min = 1;\\n    var sum = 0;\\n\\t\\n    for(var i=0;i<nums.length;i++){\\n        sum = sum+nums[i];\\n        min = Math.min(min,sum);\\n    }\\n    if(min == 1){\\n        return min;\\n    }\\n\\t", "var minStartValue = function(nums) {\\n  let resultStartValue = 1; "]}
{"id": "299", "ref_js": ["var reformat = function(s) {\\n  let strChars = \"\";\\n  let strNums = \"\";\\n\\n  for (let indexI = 0; indexI < s.length; indexI++) {\\n    const asciiNum = s[indexI].charCodeAt(0);\\n\\n    if (asciiNum > 96 && asciiNum < 123) strChars = strChars + s[indexI];\\n    else strNums = strNums + s[indexI];\\n  }\\n\\n  const lengthChars = strChars.length;\\n  const lengthNums = strNums.length;\\n\\n  ", "var reformat = function(str) {\\n    digit = []\\n    letter = []\\n\\n    for (s of str) {\\n        if (s >= 0 && s <= 9) {\\n            digit.push(s)\\n        } else {\\n            letter.push(s)\\n        }\\n    }\\n\\n    len = digit.length - letter.length\\n    if (len < -1 || len > 1) return \\'\\'\\n\\n    count = digit.length + letter.length\\n    ans = \\'\\'\\n\\n    while (count > 0) {\\n        if (len >= 0) {\\n            ans += count % 2 ? digit.pop() : letter.pop()\\n        } else {\\n            ans += count % 2 ? letter.pop() : digit.pop()\\n        }\\n        count --\\n    }\\n\\n    return ans\\n};", "var reformat = function(s) {\\n  let strChars = \"\";\\n  let strNums = \"\";\\n\\n  for (let indexI = 0; indexI < s.length; indexI++) {\\n    const asciiNum = s[indexI].charCodeAt(0);\\n\\n    if (asciiNum > 96 && asciiNum < 123) strChars = strChars + s[indexI];\\n    else strNums = strNums + s[indexI];\\n  }\\n\\n  const lengthChars = strChars.length;\\n  const lengthNums = strNums.length;\\n\\n  "]}
{"id": "300", "ref_js": ["var maxScore = function(s) {\\n    const length = s.length;\\n        let ones = 0;\\n        let tmpScore = s[0] === \\'0\\' ? 1 : 0;\\n        let score = tmpScore;\\n        \\n        for (let i = 1; i < length - 1; i++) {\\n            if (s[i] === \\'0\\') {\\n                tmpScore += 1;\\n            } else {\\n                ones += 1;\\n                tmpScore -= 1;\\n            }\\n\\n            if (tmpScore > score) {\\n                score = tmpScore;\\n            }\\n        }\\n        \\n        ones += s[length - 1] === \\'1\\' ? 1 : 0;\\n\\n        return ones + score;\\n};", "var maxScore = function(s) {\\n    let maxScore = 0;\\n    let countZerosLeft = 0;\\n    let countOnesRight = s.split(\\'1\\').length - 1;\\n\\n    for (let i = 0; i < s.length - 1; i++) {\\n        countZerosLeft += s[i] === \\'0\\' ? 1 : 0;\\n        countOnesRight -= s[i] === \\'1\\' ? 1 : 0;\\n        maxScore = Math.max(maxScore, countZerosLeft + countOnesRight);\\n    }\\n\\n    return maxScore;\\n};", "var maxScore = function(s) {\\n    let left = -1;\\n    let zeros = 0;\\n    let ones = 0;\\n\\n    for (let i = 0; i < s.length - 1; i++) {\\n        if (s[i] === \\'0\\') {\\n            zeros++;\\n        } else {\\n            ones++;\\n        }\\n\\n        left = Math.max(left, zeros - ones);\\n    }\\n\\n    ones += s[s.length - 1] === \"1\";\\n\\n    return left + ones;    \\n};"]}
{"id": "301", "ref_js": ["var kidsWithCandies = function(candies, extraCandies) {\\n  const maxCandies = Math.max(...candies);\\n  \\n  const result = [];\\n  \\n  for (let i = 0; i < candies.length; i++) {\\n    if (candies[i] + extraCandies >= maxCandies) {\\n      result.push(true);\\n    } else {\\n      result.push(false);\\n    }\\n  }\\n  \\n  return result;\\n};", "var kidsWithCandies = function(candies, extraCandies) {\\n    const mostCandies = Math.max(...candies);\\n    return candies.map((candyAmount) => candyAmount + extraCandies >= mostCandies)\\n};", "var kidsWithCandies = function(candies, extraCandies) {\\n    const mostCandies = Math.max(...candies);\\n    return candies.map((candyAmount) => candyAmount + extraCandies >= mostCandies)\\n};"]}
{"id": "302", "ref_js": ["var destCity = function(paths) {\\n    const cities = new Set();\\n\\n        ", "var destCity = function(paths) {\\n    const cities = new Set();\\n\\n        ", "var destCity = function(paths) {\\n    const cities = new Set();\\n\\n        "]}
{"id": "303", "ref_js": ["var kLengthApart = function(nums, k) {\\n    let fi=nums.indexOf(1)\\n    for(i=fi+1;i<nums.length;i++){\\n        if(nums[i]==1){\\n            if(i-fi-1>=k){\\n                fi=i\\n            }\\n            else{\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n};", "var kLengthApart = function(nums, k) {\\n    let fi=nums.indexOf(1)\\n    for(i=fi+1;i<nums.length;i++){\\n        if(nums[i]==1){\\n            if(i-fi-1>=k){\\n                fi=i\\n            }\\n            else{\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n};", "var kLengthApart = function(nums, k) {\\n    let fi=nums.indexOf(1)\\n    for(i=fi+1;i<nums.length;i++){\\n        if(nums[i]==1){\\n            if(i-fi-1>=k){\\n                fi=i\\n            }\\n            else{\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n};"]}
{"id": "304", "ref_js": ["var maxPower = function(s) {\\n    let output = 1;\\n    let currentPower = 1;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === s[i+1]) {\\n            currentPower++;\\n        } else {\\n            output = Math.max(output, currentPower);\\n            currentPower = 1;\\n        }\\n    }\\n    \\n    return output;\\n};", "var maxPower = function(s) {\\n    let power = 1\\n    \\n    let start = 0\\n    for (let end = 1; end < s.length; end++) {\\n        if (s[start] !== s[end]) {\\n            start = end\\n        }\\n            \\n        power = Math.max(power, end - start + 1)\\n    }\\n    \\n    return power\\n};", "var maxPower = function(s) {\\n    let maxStr = 1;\\n    let accum = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === s[i + 1]) {\\n            maxStr += 1;\\n        } else {\\n            maxStr = 1;\\n        }\\n        if (maxStr > accum) {\\n            accum = maxStr;\\n        }\\n    }\\n\\n    return accum;\\n};"]}
{"id": "305", "ref_js": ["var busyStudent = function(startTime, endTime, queryTime) {\\n    ", "var busyStudent = function(startTime, endTime, queryTime) {\\n   let count = 0;\\n   for(let i=0;i<endTime.length;i++){\\n       if(startTime[i] <= queryTime && endTime[i]>= queryTime){\\n           count++;\\n       }\\n   } \\n   return count;\\n};", "var busyStudent = function(startTime, endTime, queryTime) {\\n    "]}
{"id": "306", "ref_js": ["var isPrefixOfWord = function (sentence, searchWord) {\\n    let words = sentence.split(\\' \\')\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord)) return i + 1\\n    }\\n\\n    return -1\\n};", "var isPrefixOfWord = function (sentence, searchWord) {\\n    let words = sentence.split(\\' \\')\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord)) return i + 1\\n    }\\n\\n    return -1\\n};", "var isPrefixOfWord = function (sentence, searchWord) {\\n    let words = sentence.split(\\' \\')\\n\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].startsWith(searchWord)) return i + 1\\n    }\\n\\n    return -1\\n};"]}
{"id": "307", "ref_js": ["var canBeEqual = function(target, arr) {\\n    target = target.sort((a, b) => a - b);\\n    arr = arr.sort((a, b) => a - b);\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if(arr[i] !== target[i]) return false;\\n    }\\n    \\n    return true;\\n};", "var canBeEqual = function( arr,arr1) {\\n  const data = new Object();\\n  for (let i = 0; i < arr.length; ++i) {\\n    data[arr[i]] = data[arr[i]] + 1 || 1;\\n  }\\n\\n  for (let i = 0; i < arr1.length; ++i) {\\n    if (data.hasOwnProperty(arr1[i]) === false) return false;\\n    if (data.hasOwnProperty(arr1[i]) === true) {\\n      if (data[arr1[i]] <= 0) return false;\\n      data[arr1[i]] = data[arr1[i]] - 1;\\n    }\\n  }\\n  return true;\\n\\n\\n};", "var canBeEqual = function (target, arr) {\\n\\t\\t\\tif (new Set(target).size != new Set(arr).size) return false;\\n\\n\\t\\t\\tconst obj = {};"]}
{"id": "308", "ref_js": ["var maxProduct = function(nums) {\\n    let res = 0;\\n    let curMax = nums[0];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        res = Math.max(res, (curMax - 1) * (nums[i] - 1));\\n        curMax = Math.max(curMax, nums[i]);\\n    }\\n\\n    return res;    \\n};", "var maxProduct = function(nums) {\\n    let max1 = Number.MIN_SAFE_INTEGER;\\n    let max2 = Number.MIN_SAFE_INTEGER;\\n\\n    for (const num of nums) {\\n        if (num >= max1) {\\n            max2 = max1;\\n            max1 = num;\\n        } else if (num > max2) {\\n            max2 = num;\\n        }\\n    }\\n\\n    return (max1 - 1) * (max2 - 1);\\n};", "var maxProduct = function(nums) {\\n    let max1 = Number.MIN_SAFE_INTEGER;\\n    let max2 = Number.MIN_SAFE_INTEGER;\\n\\n    for (const num of nums) {\\n        if (num >= max1) {\\n            max2 = max1;\\n            max1 = num;\\n        } else if (num > max2) {\\n            max2 = num;\\n        }\\n    }\\n\\n    return (max1 - 1) * (max2 - 1);\\n};"]}
{"id": "309", "ref_js": ["var shuffle = function(nums, n) {\\n    let i = n - 1\\n    for (let j = nums.length - 1; j >= n; j--) {\\n        nums[j] <<= 10\\n        nums[j] |= nums[i]\\n        i--\\n    }\\n    \\n    i = 0\\n    for (let j = n; j < nums.length; j++) {\\n        const num1 = nums[j] & 1023\\n        const num2 = nums[j] >> 10\\n        nums[i] = num1\\n        nums[i + 1] = num2\\n        i += 2    \\n    }\\n    \\n    return nums\\n};", "var shuffle = function (nums, n) {\\n    arr=[]\\n    for (i = 0; i < n; i++) {\\n        arr.push(nums[i])\\n        arr.push(nums[i+n])\\n    }\\n    return arr\\n};", "var shuffle = function(nums, n) {\\n    const arr=[];\\n    for(let i = 0;i< n;i++){\\n        arr.push(nums[i],nums[n+i]);\\n    }\\n    return arr\\n};"]}
{"id": "310", "ref_js": ["var finalPrices = function(prices) {\\n    let answer=[];\\n    for(let i = 0 ;i<prices.length;i++){\\n        for(let j=i+1;j<prices.length;j++){\\n            if(prices[j]<=prices[i]){\\n                prices[i] = prices[i]-prices[j]\\n                break;\\n            } \\n        }\\n        answer.push(prices[i]);\\n\\n    }\\n    return answer\\n};", "var finalPrices = function(prices) {\\n    const result = prices.slice();\\n    for(let i=0; i<prices.length; i++){\\n        for(let j=i+1; j<prices.length; j++){\\n            if(prices[j] <= prices[i]){\\n                result[i] = prices[i] - prices[j];\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};", "var finalPrices = function(prices) {\\n    const output = [];\\n    \\n    for (let i = 0 ; i < prices.length; i++) {\\n        let newValue = prices[i];\\n        for (let j = i + 1 ; j < prices.length; j++) {\\n            if (prices[i] >= prices[j]) {\\n                newValue = prices[i] - prices[j];\\n                break;\\n            }\\n        }\\n        output.push(newValue);\\n    }\\n    \\n    return output;\\n};"]}
{"id": "311", "ref_js": ["var runningSum = function(nums) {\\n    let runningSum = [];\\n    let sum = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        sum += nums[i];\\n        runningSum.push(sum);\\n    }\\n    return runningSum;\\n};", "var runningSum = function(nums) {\\n    ", "var runningSum = function(nums) {\\n    "]}
{"id": "313", "ref_js": ["var xorOperation = function(n, start) {\\n    let res = 0;\\n    for(let i=0; i<n; i++) res ^=(start + 2 * i);\\n    return res;\\n};", "var xorOperation = function(n, start) {\\n    let res = 0;\\n    for(let i=0; i<n; i++) res ^=(start + 2 * i);\\n    return res;\\n};", "var xorOperation = function(n, start) {\\n    let res = 0;\\n    for(let i=0; i<n; i++) res ^=(start + 2 * i);\\n    return res;\\n};"]}
{"id": "314", "ref_js": ["var average = function(salary) {\\n    if(salary.length==3)return salary.filter(a=>{\\n        if(Math.max(...salary)==a || Math.min(...salary)==a);\\n        else return a\\n    })\\n\\n    else if(salary.length>3)\\n    return salary.reduce((a,b)=>{\\n        if(Math.max(...salary)==b||Math.min(...salary)==b) return a\\n        else return a+b;\\n    },0)/(salary.length-2)   \\n};", "var average = function(salary) {\\n    let min = Math.min(...salary)\\n    let max = Math.max(...salary)\\n    salary.splice(salary.indexOf(min) , 1)\\n    salary.splice(salary.indexOf(max) , 1)\\n    return (salary.reduce((total , num) => {return total+num} , 0))/salary.length\\n};", "var average = function(salary) {\\n    let min = Math.min(...salary)\\n    let max = Math.max(...salary)\\n    salary.splice(salary.indexOf(min) , 1)\\n    salary.splice(salary.indexOf(max) , 1)\\n    return (salary.reduce((total , num) => {return total+num} , 0))/salary.length\\n};"]}
{"id": "315", "ref_js": ["var isPathCrossing = function(path) {\\n    let moves = {\\n        \\'N\\': [0, 1], \\n        \\'S\\': [0, -1], \\n        \\'W\\': [-1, 0],\\n        \\'E\\': [1, 0]\\n    };", "var isPathCrossing = function(path) {\\n    let x = 0, y = 0;\\n    let visited = new Set();\\n    visited.add(\"0,0\");\\n\\n    for (let direction of path) {\\n        if (direction === \\'E\\') {\\n            x++;\\n        } else if (direction === \\'W\\') {\\n            x--;\\n        } else if (direction === \\'N\\') {\\n            y++;\\n        } else if (direction === \\'S\\') {\\n            y--;\\n        }\\n\\n        let currentPos = `${x},${y}`;\\n        if (visited.has(currentPos)) {\\n            return true;\\n        }\\n\\n        visited.add(currentPos);\\n    }\\n\\n    return false;\\n};", "var isPathCrossing = function(path) {\\n    const points = new Set();\\n    points.add(\"0,0\");\\n    let x = 0, y = 0;\\n\\n    for (const d of path) {\\n        if (d === \"N\") y++;\\n        else if (d === \"S\") y--;\\n        else if (d === \"E\") x++;\\n        else if (d === \"W\") x--;\\n\\n        if (points.has(`${x},${y}`)) return true;\\n        points.add(`${x},${y}`);\\n    }\\n\\n    return false;    \\n};"]}
{"id": "316", "ref_js": ["var canMakeArithmeticProgression = function(arr) {\\n    arr.sort((a,b)=>b-a)\\n    let d=arr[0]-arr[1]\\n    for(let i=0;i<arr.length-1;i++){\\n        if(arr[i]-arr[i+1]!=d){\\n            return false\\n        }\\n    }\\n    return true\\n};", "var canMakeArithmeticProgression = function(arr) {\\n    arr.sort((a,b)=>{return a-b})\\n    let d=arr[1]-arr[0]\\n    for(let i=2;i<arr.length;i++){\\n        if(arr[i]-arr[i-1]!=d) return false\\n    }\\n    return true\\n};", "var canMakeArithmeticProgression = function(arr) {\\n    const sortArr = arr.sort((a,b) => a-b);\\n    const  result = sortArr[0] - sortArr[1];\\n\\n    for(let i = 1;i <sortArr.length-1;i++){\\n        let diff = sortArr[i] - sortArr[i+1];\\n        if(result !== diff){\\n            return false\\n        }\\n    }\\n    return true\\n    \\n};"]}
{"id": "317", "ref_js": ["var reformatDate = function (str) {\\n    const monthsMapping = {\\n        Jan: \\'01\\',\\n        Feb: \\'02\\',\\n        Mar: \\'03\\',\\n        Apr: \\'04\\',\\n        May: \\'05\\',\\n        Jun: \\'06\\',\\n        Jul: \\'07\\',\\n        Aug: \\'08\\',\\n        Sep: \\'09\\',\\n        Oct: \\'10\\',\\n        Nov: \\'11\\',\\n        Dec: \\'12\\'\\n    };", "var reformatDate = function(date) {\\n    let [day, month, year] = date.split(\\' \\');\\n    day = day.slice(0, day.length - 2);\\n\\n    if (day.length < 2) {\\n        day += \\'0\\';\\n        day = day.split(\"\").reduce((acc, char) => char + acc, \"\");\\n    };", "var reformatDate = function(date) {\\n    let dform=[]\\n    let [day,month,year]=date.split(\\' \\')\\n   \\n    dform.push(year)\\n    dform.push(\\'-\\')\\n\\n    monthfom={Jan:\\'01\\',Feb:\\'02\\',Mar:\\'03\\',Apr:\\'04\\',May:\\'05\\',Jun:\\'06\\',Jul:\\'07\\',Aug:\\'08\\',Sep:\\'09\\',Oct:\\'10\\',Nov:\\'11\\',Dec:\\'12\\'}\\n    dform.push(monthfom[month])\\n    dform.push(\\'-\\')\\n\\n    if(day.length==4)\\n     dform.push(day.slice(0,2))\\n     else\\n      dform.push((\\'0\\'+day[0]))\\n     \\n\\n    return dform.join(\\'\\')\\n};"]}
{"id": "318", "ref_js": ["var numIdenticalPairs = function (nums) {\\n    let arr = []\\n    for (let i = 0; i < nums.length; i++) {\\n        let c = 1\\n        for (let j = 0; j < nums.length; j++) {\\n            if (nums[i] == nums[j] && i < j && nums[j] != -1) {\\n                nums[j] = -1\\n                c++\\n            }\\n        }\\n        if (c > 1) {\\n            arr.push(c)\\n        }\\n    }\\n    let pairs = 0\\n    for (let i = 0; i < arr.length; i++) {\\n        pairs += (arr[i] * (arr[i] - 1)) / 2\\n    }\\n    return pairs\\n};", "var numIdenticalPairs = function(nums) {\\n   let size=nums.length;\\n     let  goodpair=0;\\n   for(let i =0  ;i < size ;i ++){\\n       for(let j=i+1 ; j <size;j++){\\n            if(nums[i]===nums[j]) \\n            goodpair++;\\n       }\\n   }\\n   return goodpair;\\n};", "var numIdenticalPairs = function (nums) {\\n    let arr = []\\n    for (let i = 0; i < nums.length; i++) {\\n        let c = 1\\n        for (let j = 0; j < nums.length; j++) {\\n            if (nums[i] == nums[j] && i < j && nums[j] != -1) {\\n                nums[j] = -1\\n                c++\\n            }\\n        }\\n        if (c > 1) {\\n            arr.push(c)\\n        }\\n    }\\n    let pairs = 0\\n    for (let i = 0; i < arr.length; i++) {\\n        pairs += (arr[i] * (arr[i] - 1)) / 2\\n    }\\n    return pairs\\n};"]}
{"id": "320", "ref_js": ["var numWaterBottles = function(numBottles, numExchange, exchange) {\\n    exchange = exchange || 0;\\n    if (numBottles + exchange < numExchange) return numBottles;\\n    return numBottles + numWaterBottles(Math.floor((numBottles + exchange) / numExchange), numExchange, (numBottles+exchange)%numExchange);\\n};", "var numWaterBottles = function(numBottles, numExchange) {\\n    let sum=0,emptyBottles=0,x=0;\\n    while(numBottles!==0){\\n        sum+=numBottles;\\n        emptyBottles=numBottles+x;\\n        numBottles=Math.floor(emptyBottles/numExchange);\\n        x=emptyBottles%numExchange;\\n    }\\n    return sum;\\n};", "var numWaterBottles = function (numBottles, numExchange) {\\n    let filled = numBottles;\\n    let empty = 0;\\n    let res = 0;\\n    while (true) {\\n        if (filled === 0) {\\n            filled = parseInt(empty / numExchange);\\n            if(filled === 0){\\n                break\\n            }\\n            empty = empty - (filled * numExchange)\\n        } else {\\n            res += filled;\\n            empty += filled;\\n            filled = 0\\n        }\\n    }\\n    return res\\n};"]}
{"id": "321", "ref_js": ["var countOdds = function (low, high) {\\n    if (low % 2 == 0 && high % 2 == 0) {\\n        return Math.floor((high - low) / 2)\\n    }\\n    else {\\n        return Math.ceil((high - low+1) / 2);\\n    }\\n};", "var countOdds = function(low, high) {\\n    if (high & 1 && low & 1) {\\n        const difference = (high-low-2)/2\\n        return difference + 2\\n    } \\n    else if (!(high & 1) && !(low & 1)) {\\n        const difference = (high-low)/2\\n        return difference\\n    }\\n    else {\\n        const difference = (high-low-1)/2\\n        return difference + 1\\n    }\\n};", "var countOdds = function(low, high) {\\n    return Math.floor((high - low)/2) + (low%2 || high%2 ? 1 : 0);\\n};"]}
{"id": "323", "ref_js": ["var restoreString = function(s, indices) {\\n    let arr = [];\\n    let result = \"\";\\n    for(let i=0; i<indices.length; i++) {\\n        arr[indices[i]] = s.charAt(i);\\n    }\\n    for(let i=0; i<arr.length; i++) {\\n        result = result + arr[i];\\n    }\\n    return result;\\n};", "var restoreString = function (s, indices) {\\n    let ar = new Array(indices.length)\\n    s = s.split(\"\")\\n    for (let i = 0; i < s.length; i++) {\\n        ar[indices[i]] = s[i]\\n    }\\n    return ar.join(\"\")\\n};", "var restoreString = function (s, indices) {\\n    let ar = new Array(indices.length)\\n    s = s.split(\"\")\\n    for (let i = 0; i < s.length; i++) {\\n        ar[indices[i]] = s[i]\\n    }\\n    return ar.join(\"\")\\n};"]}
{"id": "324", "ref_js": ["var countGoodTriplets = function(arr, a, b, c) {\\n    let result=0;\\n    for(let i=0;i<arr.length;i++){\\n        let val1=arr[i];\\n        for(let j=i+1;j<arr.length;j++){\\n            let val2=arr[j];\\n            let diff1=Math.abs(val1-val2);\\n            if (diff1 > a) continue;\\n            for(let k=j+1;k<arr.length;k++){\\n                let val3=arr[k];\\n                let diff2=Math.abs(val2-val3);\\n                let diff3=Math.abs(val1-val3);\\n                if(diff2 <=b && diff3 <=c){\\n                    result++;\\n                }\\n            }\\n        } \\n    }\\n    return result;\\n};", "var countGoodTriplets = function(arr, a, b, c) {\\n    let res = 0;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        \\n        for(let j = i+1; j < arr.length; j++) {\\n            if(Math.abs(arr[i] - arr[j]) > a) continue;\\n            \\n            for(let k = j+1; k < arr.length; k++) {\\n                if(Math.abs(arr[j] - arr[k]) > b) continue;\\n                if(Math.abs(arr[k] - arr[i]) <= c) res++;\\n            }\\n        }\\n    }\\n    return res;\\n};", "var countGoodTriplets = function(arr, a, b, c) {\\n    let res = 0;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        \\n        for(let j = i+1; j < arr.length; j++) {\\n            if(Math.abs(arr[i] - arr[j]) > a) continue;\\n            \\n            for(let k = j+1; k < arr.length; k++) {\\n                if(Math.abs(arr[j] - arr[k]) > b) continue;\\n                if(Math.abs(arr[k] - arr[i]) <= c) res++;\\n            }\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "325", "ref_js": ["var findKthPositive = function(arr, k) {\\n    let i = 0;\\n    let currentNumber = 1;\\n    let missingNumbersCount = 0;\\n\\n    while(missingNumbersCount !== k){\\n        if(!arr[i]){\\n            i++\\n            currentNumber++\\n            missingNumbersCount++\\n        }else if(arr[i] !== currentNumber){\\n            currentNumber++\\n            missingNumbersCount++\\n        }else if(arr[i] === currentNumber){\\n            i++\\n            currentNumber++\\n        }\\n    }\\n    return currentNumber-1\\n};", "var findKthPositive = function (arr, k) {\\n    return Array.from(Array(10000).keys()).filter(v => !arr.includes(v))[k];\\n};", "var findKthPositive = function(arr, k) {\\n     let count = 0;\\n  for (item of arr) {\\n    if (item <= k + count) {\\n      count++;\\n    }\\n  }\\n\\n  return k + count;\\n};"]}
{"id": "326", "ref_js": ["var makeGood = function(s) {\\n    const stack = [s[0]];\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if ([32, -32].includes(s.charCodeAt(i) - s.charCodeAt(i - 1))) {\\n            s = s.substring(0, i - 1) + s.substring(i + 1, s.length);\\n            i-=2;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    \\n    return stack.join(\\'\\');\\n};", "var makeGood = function(s) {\\n    let stack = [];\\n    for (character of s){\\n        if (stack.length != 0 && Math.abs(stack[stack.length-1].codePointAt() - character.codePointAt()) == 32){\\n            stack.pop();\\n            continue;\\n        }\\n        stack.push(character);\\n    }\\n    return stack.join(\"\");\\n};", "var makeGood = function(s) {\\n    let stack = [];\\n    for (character of s){\\n        if (stack.length != 0 && Math.abs(stack[stack.length-1].codePointAt() - character.codePointAt()) == 32){\\n            stack.pop();\\n            continue;\\n        }\\n        stack.push(character);\\n    }\\n    return stack.join(\"\");\\n};"]}
{"id": "327", "ref_js": ["var threeConsecutiveOdds = function(arr) {\\n    let oddCount = 0;\\n\\n    for(let i = 0 ; i < arr.length; i++){\\n        \\n        if(arr[i] % 2 != 0) {\\n            oddCount += 1 \\n            if(oddCount == 3){ \\n                return true;   \\n            }\\n        }else{\\n            oddCount = 0;\\n        }\\n    }\\n    \\n    console.log(\\'false\\')\\n    return false;\\n};", "var threeConsecutiveOdds = function(arr) {\\n    let count = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 1) {\\n            count++;\\n        } else {\\n            count = 0;\\n        }\\n        if (count === 3) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};", "var threeConsecutiveOdds = function(arr) {\\n    let oddCount = 0;\\n\\n    for(let i = 0 ; i < arr.length; i++){\\n        \\n        if(arr[i] % 2 != 0) {\\n            oddCount += 1 \\n            if(oddCount == 3){ \\n                return true;   \\n            }\\n        }else{\\n            oddCount = 0;\\n        }\\n    }\\n    \\n    console.log(\\'false\\')\\n    return false;\\n};"]}
{"id": "328", "ref_js": ["var thousandSeparator = function(n) {\\n    let a = n.toString()\\n    if(n<1000) return  a\\n    let array = a.split(\\'\\').reverse() \\n        if (n<1000000 && n >=1000) {\\n            array.splice(3,0,\\'.\\')\\n        }\\n\\n if (n<1000000000 && n>=1000000){\\n        array.splice(3,0,\\'.\\')\\n        array.splice(7,0,\\'.\\')\\n        ", "var thousandSeparator = function(n) {\\n    if (n < 1000) return n.toString();\\n    const str = n.toString();\\n    let result = \\'\\';\\n    let nums = 0;\\n    for (let i = str.length - 1; i >= 0; i--) {\\n        nums++;\\n        result = str[i] + result;\\n        if (nums % 3 === 0 && i !== 0) {\\n            result = \\'.\\' + result;\\n        }\\n    }\\n    return result;\\n};", "var thousandSeparator = function(n) {\\n    const numArr = String(n).split(\\'\\');\\n    let len = numArr.length;\\n    if(len > 3){\\n        for(let i = len,k=0; i>0;i--,k++){\\n            if( k % 3 === 0 && k !== 0){\\n                numArr.splice(i,0,\".\");\\n            }\\n        }\\n    }\\n    return numArr.join(\"\")\\n    \\n};"]}
{"id": "329", "ref_js": ["var mostVisited = function(n, rounds) {\\n    const start = rounds[0], end = rounds[rounds.length-1];\\n    const result = [];\\n    \\n    if(start <= end) {\\n        for(let i = start; i <= end; i++) result.push(i);\\n    } else {\\n        for(let i = 1; i <= end; i++) result.push(i);\\n        for(let i = start; i <= n; i++) result.push(i);\\n    }\\n    return result;\\n};", "var mostVisited = function(n, rounds) {\\n    ", "var mostVisited = function(n, rounds) {\\n    let result = [];\\n    let start = rounds[0];\\n    while (start !== rounds.at(-1)) {\\n        result.push(start);\\n        ++start;\\n        if (start > n) start -= n;\\n    }\\n    result.push(start);\\n    return result.sort((a,b)=>a-b);\\n};"]}
{"id": "330", "ref_js": ["var containsPattern = function(arr, m, k) {\\n    for(let i=m, cnt=0; i<arr.length; i++){\\n        if(arr[i]!=arr[i-m]) cnt=0;\\n        else if(++cnt==m*(k-1)) return true;\\n    }\\n    return false;\\n};", "var containsPattern = function(arr, m, k) {\\n    let count = 0;\\n\\tfor (let i = m; i < arr.length; i++) {\\n\\t\\tif (arr[i] === arr[i - m]) {\\n\\t\\t\\tif (++count === (m * (k - 1))) return true;\\n\\t\\t} else count = 0;\\n\\t}\\n\\treturn false\\n};", "var containsPattern = function(arr, m, k) {\\n    count = 0\\n    count_max = 0\\n\\n    for (let j = 0; j < arr.length - m; j++) {                        \\n        if (arr.slice(j, j+m).join(\\'_\\') == arr.slice(j+m, j+m+m).join(\\'_\\')) {                \\n            count ++           \\n            if (count_max < count) {count_max = count}\\n            j += m - 1     \\n        } else {\\n            count = 0    \\n        }\\n    }\\n\\n    return k <= count_max + 1           \\n};"]}
{"id": "331", "ref_js": ["var diagonalSum = function(mat) {\\n    let sum = 0, n = mat.length;\\n    for(let i=0; i<n; i++) sum+=mat[i][i];\\n    for(let i=0; i<n; i++) if(n%2==0 || i!==n>>1) sum+=mat[n-i-1][i];\\n    return sum;\\n};", "var diagonalSum = function(mat) {\\n    let sum = 0;\\n    for(let i=0;i<mat.length;i++)\\n    {\\n        sum+=mat[i][i];\\n        if(mat.length-1-i != i)\\n        {\\n            sum+=mat[i][mat.length-1-i]\\n        }\\n\\n    }\\n    return sum;\\n};", "var diagonalSum = function(mat) {\\n    \\n    "]}
{"id": "332", "ref_js": ["var modifyString = function (s) {\\n  let arr = s.split(\"\");\\n  for (let i = 0; i <= arr.length; i++) {\\n    let res = [\"a\", \"b\", \"c\"];\\n    if (arr[i] === \"?\") {\\n      if (arr[i - 1] === \"a\" || arr[i + 1] === \"a\") {\\n        res.splice(res.indexOf(\"a\"), 1);\\n      }\\n      if (arr[i - 1] === \"b\" || arr[i + 1] === \"b\") {\\n        res.splice(res.indexOf(\"b\"), 1);\\n      }\\n      arr[i] = res[0];\\n    }\\n  }\\n  return arr.join(\"\");\\n};", "var modifyString = function(s) {\\n    ", "var modifyString = function(s) {\\n    if(s.length===1 && s===\\'?\\'){\\n      return \\'a\\'\\n    };"]}
{"id": "334", "ref_js": ["var numSpecial = function(mat) {\\n    let specials = 0;\\n\\n    for (let i = 0; i < mat.length; i++) {\\n        let index = checkRow(mat, i);\\n        if (index >= 0 && checkColumn(mat, i, index))\\n            specials++;\\n    }\\n\\n    return specials;\\n\\n    function checkRow(mat, i) {\\n        let index = -1;\\n        for (let j = 0; j < mat[0].length; j++) {\\n            if (mat[i][j] === 1) {\\n                if (index >= 0)\\n                    return -1;\\n                else\\n                    index = j;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    function checkColumn(mat, i, index) {\\n        for (let j = 0; j < mat.length; j++) {\\n            if (mat[j][index] === 1 && j !== i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};", "var numSpecial = function(mat) {\\n    function getColumnSum(colIdx) {\\n        return mat.reduce((sum, row) => sum + row[colIdx], 0);\\n    }\\n\\n    let special = 0;\\n    for (let row of mat) {\\n        if (row.reduce((acc, val) => acc + val, 0) === 1) {\\n            const colIdx = row.indexOf(1);\\n            special += getColumnSum(colIdx) === 1;\\n        }\\n    }\\n\\n    return special;    \\n};", "var numSpecial = function(mat) {\\n    let specials = 0;\\n\\n    for (let i = 0; i < mat.length; i++) {\\n        let index = checkRow(mat, i);\\n        if (index >= 0 && checkColumn(mat, i, index))\\n            specials++;\\n    }\\n\\n    return specials;\\n\\n    function checkRow(mat, i) {\\n        let index = -1;\\n        for (let j = 0; j < mat[0].length; j++) {\\n            if (mat[i][j] === 1) {\\n                if (index >= 0)\\n                    return -1;\\n                else\\n                    index = j;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    function checkColumn(mat, i, index) {\\n        for (let j = 0; j < mat.length; j++) {\\n            if (mat[j][index] === 1 && j !== i)\\n                return false;\\n        }\\n        return true;\\n    }\\n};"]}
{"id": "336", "ref_js": ["var sumOddLengthSubarrays = function (arr) {\\n    let result = 0;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = i; j < arr.length; j += 2) {\\n            for (let k = i; k <= j; k++) {\\n                result += arr[k];\\n            }\\n        }\\n    }\\n\\n    return result;\\n};", "var sumOddLengthSubarrays = function(arr) {\\n let sum = 0;\\n let res = [];\\n res.push(arr[0]);\\n for(let i=1;i<arr.length;i++){\\n     res.push(arr[i]+res[i-1]);\\n }\\n for(let i=0;i<arr.length;i++){\\n     for(let j=i;j<arr.length;j++){\\n         if((i+j) % 2 == 0){\\n             let val = find(i,j,res);\\n             sum += val;\\n         }\\n     }\\n }\\n return sum;\\n\\n};", "var sumOddLengthSubarrays = function (arr) {\\n    if (!arr.length)\\n        return 0\\n    let sum = 0\\n    const findSum = (first, last) => {\\n        let sum = 0\\n        for (let i = first; i <= last; i++)\\n            sum += arr[i]\\n        return sum\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = 0; (j + i) < arr.length; j = j + 2)\\n            sum += findSum(i, i + j)\\n    }\\n    return sum\\n};"]}
{"id": "337", "ref_js": ["var transpose = function(matrix) {\\n    let row = matrix.length;\\n    let col = matrix[0].length;\\n    let result = Array.from({ length: col }, () => Array(row).fill(0));\\n    \\n    for (let i = 0; i < col; ++i) {\\n        for (let j = 0; j < row; ++j) {\\n            result[i][j] = matrix[j][i];\\n        }\\n    }\\n    \\n    return result;\\n};", "var transpose = function(matrix) {\\n    let row = matrix.length;\\n    let col = matrix[0].length;\\n    let result = Array.from({ length: col }, () => Array(row).fill(0));\\n    \\n    for (let i = 0; i < col; ++i) {\\n        for (let j = 0; j < row; ++j) {\\n            result[i][j] = matrix[j][i];\\n        }\\n    }\\n    \\n    return result;\\n};", "var transpose = function(matrix) {\\n    let row = matrix.length;\\n    let col = matrix[0].length;\\n    let result = Array.from({ length: col }, () => Array(row).fill(0));\\n    \\n    for (let i = 0; i < col; ++i) {\\n        for (let j = 0; j < row; ++j) {\\n            result[i][j] = matrix[j][i];\\n        }\\n    }\\n    \\n    return result;\\n};"]}
{"id": "338", "ref_js": ["var minOperations = function(logs) {\\n    let counter = 0;\\n\\n    for(let log of logs) {\\n        if(log === \\'./\\') continue;\\n        if(log === \\'../\\') {\\n          if(counter > 0) counter--;\\n        } else {\\n          counter++\\n        }\\n    }\\n\\n    return counter;\\n};", "var minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};", "var minOperations = function(logs) {\\n    let l = new Array()\\n    for (let i of logs){\\n        if(i==\"../\" && l.length>0){\\n            l.pop()\\n        }\\n        else if(i!=\"./\" && i!=\"../\"){\\n            l.push(i)\\n        }\\n    }\\n    return l.length\\n    \\n};"]}
{"id": "340", "ref_js": ["var specialArray = function(nums) {\\n    let sorted = nums.sort((a, b) => b - a);\\n    ", "var specialArray = function(nums) {\\n    nums.sort((a,b) => a - b);\\n\\n    for(let i = 0; i <= nums[nums.length-1]; i++){\\n        let res = bs(nums, i)\\n        if((nums.length - res) === i) return i\\n    }\\n    return -1\\n};", "var specialArray = function(nums) {\\n    "]}
{"id": "341", "ref_js": ["var maxDepth = function(s) {\\n    let a=[];\\n    let n=0;\\n    for(let i=0;i<s.length;i++){\\n        if(s[i]===\\'(\\'){\\n            a.push(s[i]);\\n            n=n>a.length?n:a.length;\\n        }\\n        else if(s[i]===\\')\\'){\\n            a.pop();\\n        }\\n    }\\n    return n;\\n};", "var maxDepth = function(s) {\\n    let count = 0;\\n    let maxCount = 0;\\n    for(let i=0;i<s.length-1;i++){\\n        if(s[i] === \"(\" ) {\\n            count++;\\n        }else if(s[i] === \")\"){\\n            count--;\\n        }else{\\n            continue;\\n        }\\n        maxCount = Math.max(maxCount,count);\\n    }\\n    return maxCount;\\n};", "var maxDepth = function (s) {\\n    let maxCount = 0;\\n    let openCount = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") maxCount = Math.max(maxCount, ++openCount);\\n        else if (s[i] === \")\") openCount--;\\n    }\\n    return maxCount;\\n};"]}
{"id": "342", "ref_js": ["var trimMean = function(arr) {\\n    ", "var trimMean = function(arr) {\\n    ", "var trimMean = function(arr) {\\n    "]}
{"id": "343", "ref_js": ["var maxLengthBetweenEqualCharacters = function(s) {\\n  let out=-1\\n        for(let i=s.length-1;i>0;i--){\\n            let holder=s.indexOf(s[i])\\n            out=Math.max(out,i-(holder+1))\\n        }\\n\\n  \\n        return out\\n    \\n};", "var maxLengthBetweenEqualCharacters = function(s) {\\n     let sub = \\'\\';\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const str = s.substring(s.indexOf(s[i]), s.lastIndexOf(s[i]))\\n        if (str.length > sub.length) {\\n            sub = str\\n        }\\n    }\\n    if (sub.length) return sub.length - 1\\n\\n    return -1\\n};", "var maxLengthBetweenEqualCharacters = function(s) {\\n   "]}
{"id": "344", "ref_js": ["var slowestKey = function(releaseTimes, keysPressed) {\\nlet maxDuration = releaseTimes[0], char=keysPressed[0];\\nfor (let i = 1; i < releaseTimes.length; i++) {\\n    if (releaseTimes[i]-releaseTimes[i-1]==maxDuration && keysPressed[i]>char) char=keysPressed[i]\\n    else if (releaseTimes[i]-releaseTimes[i-1]>maxDuration) {\\n        char=keysPressed[i];\\n        maxDuration=releaseTimes[i]-releaseTimes[i-1];\\n    }\\n}\\nreturn char;    \\n};", "var slowestKey = function(releaseTimes, keysPressed) {\\n    let longestDuration = 0,\\n        longestIndex = 0,\\n        tempDur = 0\\n\\n        \\n    releaseTimes.filter((v, i)=>{\\n        \\n        if(i==0) {\\n            longestDuration = v; longestIndex = i;\\n        }\\n        else{\\n            tempDur = v - releaseTimes[i-1]\\n            \\n            if(tempDur > longestDuration) {\\n                longestDuration = tempDur; longestIndex = i;\\n            }\\n            else if(tempDur == longestDuration){\\n                if(keysPressed[i] > keysPressed[longestIndex]){\\n                    longestDuration = tempDur; longestIndex = i;\\n                }\\n            }\\n        }\\n    })\\n\\n    return keysPressed[longestIndex]\\n};", "var slowestKey = function(releaseTimes, keysPressed) {\\nlet maxDuration = releaseTimes[0], char=keysPressed[0];\\nfor (let i = 1; i < releaseTimes.length; i++) {\\n    if (releaseTimes[i]-releaseTimes[i-1]==maxDuration && keysPressed[i]>char) char=keysPressed[i]\\n    else if (releaseTimes[i]-releaseTimes[i-1]>maxDuration) {\\n        char=keysPressed[i];\\n        maxDuration=releaseTimes[i]-releaseTimes[i-1];\\n    }\\n}\\nreturn char;    \\n};"]}
{"id": "346", "ref_js": ["var frequencySort = function(nums) {\\n    const counts = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        counts[nums[i]] = counts[nums[i]] ? counts[nums[i]] + 1 : 1;\\n    }\\n    return nums.sort((a, b) => {\\n        if (counts[a] > counts[b]) {\\n            return 1;\\n        } else if (counts[a] < counts[b]) {\\n            return -1;\\n        }\\n        return b - a;\\n    });\\n};", "var frequencySort = function(nums) {\\n    const map = new Map();\\n    for (let n of nums) {\\n        map.set(n, (map.get(n) + 1) || 1);\\n    }\\n    return nums.sort((a, b) => map.get(a) - map.get(b) || b - a)\\n};", "var frequencySort = function(nums) {\\n  const obj = {};"]}
{"id": "347", "ref_js": ["var canFormArray = function(arr, pieces) {\\n\\tlet total = \"\";\\n    arr=arr.join(\"\");\\n    for (let i = 0; i < pieces.length; i++) {\\n      pieces[i] = pieces[i].join(\"\");\\n      total += pieces[i];\\n      if (arr.indexOf(pieces[i]) == -1) return false;\\n    }\\n    return total.length == arr.length;\\n};", "var canFormArray = function(arr, pieces) {\\n    let arr2 = [];\\n    let d = new Map();\\n    for(let t of pieces){d.set(t[0],t);}\\n    for(let t of arr){\\n        if (d.has(t)){arr2 = arr2.concat(d.get(t));}\\n    }\\n    return JSON.stringify(arr2)==JSON.stringify(arr);\\n};", "var canFormArray = function(arr, pieces) {\\n\\n    for (piece of pieces) {\\n        if (check (arr, piece) == false) return false\\n    }\\n\\n    function check (a, b) {\\n        index = a.indexOf(b[0])\\n\\n        for (let i = 0; i < b.length; i++) {\\n            if (a[index + i] != b[i]) return false\\n        }\\n    }\\n\\n    return true\\n};"]}
{"id": "348", "ref_js": ["var getMaximumGenerated = function (n) {\\n    if (n==0) return 0;\\n\\n    let nums = [];\\n    nums[0] = 0;\\n    nums[1] = 1;\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (i * 2 > n) break;\\n        nums[i * 2] = nums[i]\\n\\n        if ((i * 2 + 1) > n) break;\\n        nums[i * 2 + 1] = nums[i] + nums[i + 1]\\n    }\\n\\n    return Math.max(...nums)\\n};", "var getMaximumGenerated = function(n) {\\n    ", "var getMaximumGenerated = function(n) {\\n    if(n===0){\\n        return 0\\n    }\\n    let numbers = [0,1]\\n    for (let i = 1; i<numbers.length; i++){\\n        if(2 <= 2*i && 2*i <= n){\\n            numbers[2*i] = numbers[i]\\n        }\\n        if(2 <= 2*i+1 && 2*i+1 <= n){\\n            numbers[2*i+1] = numbers[i]+numbers[i+1]\\n        }\\n    }\\n    return Math.max(...numbers)\\n};"]}
{"id": "349", "ref_js": ["var decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length ", "var decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    ", "var decrypt = function(code, k) {\\n    const ans = [];\\n    if(k == 0){\\n        for(const k in code){\\n            ans.push(0);\\n        }\\n        return ans;\\n    }else if(k > 0){\\n        for(let i = 0 ; i < code.length ; i++){\\n            let sum = 0;\\n            let idx = i;\\n            for(let j = 1 ; j <= k ; j++){\\n                sum = sum + code[(idx+j) % (code.length)] ;\\n            }\\n            ans.push(sum);\\n        }\\n        return ans;\\n    }else{\\n        "]}
{"id": "352", "ref_js": ["var arrayStringsAreEqual = function(word1, word2) {\\n        let left = \"\"; ", "var arrayStringsAreEqual = function(word1, word2) {\\n    const str1 = word1.join(\\'\\');\\n    const str2 = word2.join(\\'\\');\\n    return str1 === str2;\\n};", "var arrayStringsAreEqual = function(word1, word2) {\\n    const str1 = word1.join(\\'\\');\\n    const str2 = word2.join(\\'\\');\\n    return str1 === str2;\\n};"]}
{"id": "354", "ref_js": ["var maxRepeating = function (sequence, word) {\\n    if (!sequence.includes(word)) return 0;\\n    let quest = word;\\n    let count = 1\\n    while (sequence.includes(quest)) {\\n        ", "var maxRepeating = function(sequence, word) {\\n\\t\\tlet result = 0;\\n\\n\\t\\twhile (sequence.includes(word.repeat(result + 1))) {\\n\\t\\t\\tresult += 1;\\n\\t\\t};", "var maxRepeating = function(sequence, word) {\\n  \\n  let right = Math.floor(sequence.length / word.length);\\n\\n  let left = 0;\\n  \\n  let ans = 0;\\n  \\n  while (left <= right) {\\n    \\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (sequence.includes(word.repeat(mid))) {\\n      \\n      ans = mid;\\n      \\n      left = mid + 1;\\n    }\\n    else {\\n      \\n      right = mid - 1;\\n    }\\n  }\\n  return ans;\\n};"]}
{"id": "355", "ref_js": ["var maximumWealth = function(accounts) {\\n        var res = 0;\\n        for(var i =0;i<accounts.length;i++){\\n            var temp = 0;\\n            for(var j = 0;j<accounts[i].length;j++){\\n                temp+=accounts[i][j];\\n            }\\n            res = Math.max(res,temp);\\n        }\\n        return res;\\n};", "var maximumWealth = function(accounts) {\\n    let total = 0;\\n    for(let i=0; i<accounts.length; i++){\\n        let innerArray = accounts[i];\\n        let sum = 0;\\n        for(let j=0; j<innerArray.length; j++){\\n            sum += innerArray[j];\\n            if(total < sum){\\n                total = sum;\\n            }\\n        }\\n    }\\n    return total;\\n};", "var maximumWealth = function(accounts) {\\n    let max= accounts[0].reduce((a, b) => a + b, 0);\\n\\n    for(let i=1; i<accounts.length; i++) {\\n        let temp = accounts[i].reduce((a, b) => a + b, 0);\\n        if(max <= temp) max = temp;\\n    }\\n    return max;\\n};"]}
{"id": "356", "ref_js": ["var interpret = function(command) {\\n    return command.split(\"()\").join(\"o\").split(\"(al)\").join(\"al\");\\n};", "var interpret = function(s) {\\n    return  s.replace(/\\\\(\\\\)/g,\\'o\\').replace(/\\\\(al\\\\)/g , \"al\");\\n};", "var interpret = function(command) {\\n    return command.split(\"()\").join(\"o\").split(\"(al)\").join(\"al\");\\n};"]}
{"id": "358", "ref_js": ["var countConsistentStrings = function(allowed, words) {\\n    const hashmap = new Map();\\n    let output = 0;\\n\\n    for (let i = 0; i < allowed.length; i++) {\\n        hashmap.set(allowed[i], 1);\\n    }\\n\\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        output++;\\n        for (let j = 0; j < word.length; j++) {\\n            if (!hashmap.has(word[j])) {\\n                output--;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return output;\\n};", "var countConsistentStrings = function (allowed, words) {\\n  allowed = new Set(allowed);\\n\\n  return words.reduce((count, word) => {\\n    return word.split(\\'\\').every(l => allowed.has(l)) ? ++count : count;\\n  }, 0);\\n};", "var countConsistentStrings = function(allowed, words) {\\n    const hashmap = new Map();\\n    let output = 0;\\n\\n    for (let i = 0; i < allowed.length; i++) {\\n        hashmap.set(allowed[i], 1);\\n    }\\n\\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        output++;\\n        for (let j = 0; j < word.length; j++) {\\n            if (!hashmap.has(word[j])) {\\n                output--;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return output;\\n};"]}
{"id": "359", "ref_js": ["var numberOfMatches = function(n) {\\n        if(n == 1) return 0\\n        if( n % 2 == 0)\\n            return n/2 + numberOfMatches(n/2)\\n        else\\n            return (n-1)/2 + numberOfMatches((n-1)/2 + 1)\\n    };", "var numberOfMatches = function(n) {\\n    let res = 0;\\n    while(n>1) {\\n        res += Math.floor(n/2);\\n        n = Math.ceil(n/2);\\n    }\\n    return res;\\n};", "var numberOfMatches = function(n) {\\n    let count = 0;\\n    let rev = 0;\\n    while (n > 1) {\\n        rev = Math.floor(n / 2);\\n        count += rev;\\n        n = n - rev;\\n    }\\n    return count;\\n};"]}
{"id": "361", "ref_js": ["var reformatNumber = function(number) {\\n    const str = number.replace(/[- ]/g, \"\");\\n    let result = \\'\\'\\n\\n    let counter = 0\\n    let maxCounter = str.length === 4 ? 2 : 3\\n    let i = 0\\n\\n    while(i <= str.length - 1){\\n        if(counter === maxCounter){\\n            result+=\\'-\\'\\n            counter = 0\\n        }\\n\\n        if(str.length - 4 === i && result.at(-1) === \\'-\\'){\\n            maxCounter = 2\\n        }\\n\\n        result+=str[i]\\n        counter++\\n        i++\\n    }\\n    return result\\n};", "var reformatNumber = function (number) {\\n\\n    ", "var reformatNumber = function (number) {\\n  const reRemoveDash = /\\\\D/g;\\n  const reSeparateByDash = /(...?(?=..))/g;\\n  return number.replace(reRemoveDash, \"\").replace(reSeparateByDash, \"$1-\");\\n};"]}
{"id": "362", "ref_js": ["var countStudents = function(students, sandwiches) {\\n    let movementToEnd = 0;\\n\\n    while(sandwiches.length > 0){\\n\\n        if(students[0] === sandwiches[0]){\\n            students.shift();\\n            sandwiches.shift();\\n            movementToEnd = 0;          ", "var countStudents = function(students, sandwiches) {\\n    while(true) {\\n        if(students.length === 0 && sandwiches.length === 0) {\\n            return 0;\\n        } else if(students[0] === sandwiches[0]) {\\n            students.shift();\\n            sandwiches.shift();\\n        } else {\\n            let tempLength = students.length;\\n            while(tempLength) {\\n                if(students[0] !== sandwiches[0]) {\\n                    students.push(students.shift());\\n                    tempLength--;\\n                } else {\\n                    break;\\n                }\\n            }\\n            if(tempLength === 0) {\\n                return students.length;\\n            }\\n        }\\n    }\\n};", "var countStudents = function(students, sandwiches) {\\n    while(true) {\\n        if(students.length === 0 && sandwiches.length === 0) {\\n            return 0;\\n        } else if(students[0] === sandwiches[0]) {\\n            students.shift();\\n            sandwiches.shift();\\n        } else {\\n            let tempLength = students.length;\\n            while(tempLength) {\\n                if(students[0] !== sandwiches[0]) {\\n                    students.push(students.shift());\\n                    tempLength--;\\n                } else {\\n                    break;\\n                }\\n            }\\n            if(tempLength === 0) {\\n                return students.length;\\n            }\\n        }\\n    }\\n};"]}
{"id": "363", "ref_js": ["var halvesAreAlike = function(s) {\\n\\n    s = s.toLowerCase();\\n    let a = s.slice(0, s.length / 2).split(\\'\\');\\n    let b = s.slice(s.length / 2).split(\\'\\');\\n    let vow = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\n    let aCount = 0;\\n    let bCount = 0;\\n\\n    a.forEach((x) => {\\n        if (vow.includes(x)) {\\n            aCount++;\\n        }\\n    });\\n\\n    b.forEach((x) => {\\n        if (vow.includes(x)) {\\n            bCount++;\\n        }\\n    });\\n\\n    return aCount === bCount;\\n    \\n};", "var halvesAreAlike = function(s) {\\n    let a=s.slice(0,s.length/2)\\n    let b=s.slice(s.length/2,s.length)\\n   \\n    function count(x){\\n        let c=0,vowel=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        for(let l of x){\\n            if(vowel.includes(l)) c++\\n        }\\n        return c\\n    }\\n\\n    return count(a)==count(b)?true:false\\n};", "var halvesAreAlike = function(s) {\\n    let a=s.slice(0,s.length/2)\\n    let b=s.slice(s.length/2,s.length)\\n   \\n    function count(x){\\n        let c=0,vowel=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        for(let l of x){\\n            if(vowel.includes(l)) c++\\n        }\\n        return c\\n    }\\n\\n    return count(a)==count(b)?true:false\\n};"]}
{"id": "364", "ref_js": ["var maximumUnits = function(B, T) {\\n    B.sort((a,b) => b[1] - a[1])\\n    let ans = 0\\n    for (let i = 0; T && i < B.length; i++) {\\n        let count = Math.min(B[i][0], T)\\n        ans += count * B[i][1], T -= count\\n    }\\n    return ans\\n};", "var maximumUnits = function(boxTypes, truckSize) {\\n   ", "var maximumUnits = function(boxTypes, truckSize) {\\n  boxTypes.sort((a, b) => b[1] - a[1]);\\n  \\n  let result = 0;\\n  for (const [ boxes, units ] of boxTypes) {\\n    const takeBoxes = Math.min(boxes, truckSize);\\n    result += units * takeBoxes;\\n    truckSize -= takeBoxes;\\n    if (!truckSize) break;\\n  }\\n\\n  return result;\\n};"]}
{"id": "365", "ref_js": ["var totalMoney = function(n) {\\n    let total = 0;\\n\\n    for (let day = 0; day < n; day++) {\\n        total += Math.floor(day / 7) + 1 + (day % 7);\\n    }\\n\\n    return total;    \\n};", "var totalMoney = function(n) {\\n    let total = 0;\\n\\n    for (let day = 0; day < n; day++) {\\n        total += Math.floor(day / 7) + 1 + (day % 7);\\n    }\\n\\n    return total;    \\n};", "var totalMoney = function(n) {\\n    let total = 0;\\n\\n    for (let day = 0; day < n; day++) {\\n        total += Math.floor(day / 7) + 1 + (day % 7);\\n    }\\n\\n    return total;    \\n};"]}
{"id": "366", "ref_js": ["var decode = function (encoded, first) {\\n  const temp = first;\\n\\n  const result = encoded.map(curval => first ^= curval);\\n  result.unshift(temp);\\n\\n  return result;\\n};", "var decode = function (encoded, first) {\\n  const temp = first;\\n\\n  const result = encoded.map(curval => first ^= curval);\\n  result.unshift(temp);\\n\\n  return result;\\n};", "var decode = function (encoded, first) {\\n  const temp = first;\\n\\n  const result = encoded.map(curval => first ^= curval);\\n  result.unshift(temp);\\n\\n  return result;\\n};"]}
{"id": "367", "ref_js": ["var countGoodRectangles = function(rectangles) {\\n    let widthHash = {}\\n    let maxWidth = 0\\n\\n    for(let rectangle of rectangles){\\n        let min = Math.min(rectangle[0], rectangle[1])\\n        addToHash(min)\\n        setMax(min)\\n    }\\n\\n    return widthHash[maxWidth]\\n\\n    function addToHash(val){\\n        if(!widthHash[val]){\\n            widthHash[val] = 1\\n        }else{\\n            widthHash[val]++\\n        }\\n    }\\n\\n    function setMax(val){\\n        if(val > maxWidth){\\n            maxWidth = val\\n        }\\n    }\\n    \\n};", "var countGoodRectangles = function (rectangles) {\\n    let max = 0\\n    for (let i = 0; i < rectangles.length; i++) {\\n        rectangles[i][0] < rectangles[i][1] ? rectangles[i][1] = rectangles[i][0] : rectangles[i][0] = rectangles[i][1]\\n        rectangles[i][0] > max ? max = rectangles[i][0] : max = max\\n    }\\n\\n    let count = 0\\n    for (let i = 0; i < rectangles.length; i++) {\\n        rectangles[i][0] === max ? count++ : count = count\\n    }\\n    return count\\n};", "var countGoodRectangles = function(rectangles) {\\n    let count = 0, max = 0;\\n    for(let rec of rectangles){\\n        let len = Math.min(rec[0], rec[1]);\\n        if(len > max){\\n            count = 1;\\n            max = len;\\n        }else if(len == max){\\n            count++;\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "370", "ref_js": ["var largestAltitude = function(gain) {\\n    var n=gain.length;\\n    var G=[];\\n    G[0]=0;\\n    for(var i=0;i<n;i++)\\n        G[i+1]=G[i]+gain[i];\\n    return Math.max(...G);\\n};", "var largestAltitude = function(gain) {\\n    const temp = [0];\\n    let alt = 0;\\n    for (let i = 0; i < gain.length; i++) {\\n        alt += gain[i];\\n        temp.push(alt);\\n    } return Math.max(...temp);\\n};", "var largestAltitude = function(gain) {\\n    let maxAltitude = 0;\\n    let currentAltitude = 0;\\n    \\n    for(let g of gain) {\\n        currentAltitude += g;\\n        if(currentAltitude > maxAltitude)\\n            maxAltitude = currentAltitude;\\n    }\\n    return maxAltitude;\\n};"]}
{"id": "371", "ref_js": ["var maximumTime = function(time) {\\n    time = time.split(\\'\\')\\n    if (time[0] === \"?\") time[0] = time[1] > 3 ? \"1\" : \"2\"\\n    if (time[1] === \"?\") time[1] = time[0] > 1 ? \"3\" : \"9\"\\n    if (time[3] === \"?\") time[3] = \"5\"\\n    if (time[4] === \"?\") time[4] = \"9\"\\n    return time.join(\\'\\')\\n};", "var maximumTime = function(time) {\\n    let result = time.split(\"\");\\n    if (result[0] === \"?\") result[0] = result[1] > 3 ? \"1\" : \"2\";\\n    if (result[1] === \"?\") result[1] = result[0] > 1 ? \"3\" : \"9\";\\n    if (result[3] === \"?\") result[3] = \"5\";\\n    if (result[4] === \"?\") result[4] = \"9\";\\n    return result.join(\"\");\\n\\n};", "var maximumTime = function(time) {\\n    const arr = [...time]\\n    if (arr[0] === \\'?\\' && +arr[1] >= 4) arr[0] = \\'1\\'\\n    if (arr[0] === \\'?\\') arr[0] = \\'2\\'\\n    if (arr[1] === \\'?\\' && arr[0] === \\'2\\') arr[1] = \\'3\\'\\n    if (arr[1] === \\'?\\' && (arr[0] === \\'1\\' || arr[0] === \\'0\\')) arr[1] = \\'9\\'\\n    if (arr[3] === \\'?\\') arr[3] = \\'5\\'\\n    if (arr[4] === \\'?\\') arr[4] = \\'9\\'\\n\\n    return arr.join(\\'\\')\\n};"]}
{"id": "373", "ref_js": ["var countBalls = function(lowLimit, highLimit) {\\n    let map = new Map();\\n    let ans = 0;\\n    for(let i = lowLimit; i <= highLimit; i++) {\\n        const num = String(i).split(\\'\\').reduce((a, n) => a + parseInt(n), 0);\\n        const count = (map.get(num) || 0) + 1;\\n        ans = Math.max(ans, count);\\n        map.set(num, count);\\n    }\\n    return ans;\\n};", "var countBalls = function(lowLimit, highLimit) {\\n    let map = new Map();\\n    let ans = 0;\\n    for(let i = lowLimit; i <= highLimit; i++) {\\n        const num = String(i).split(\\'\\').reduce((a, n) => a + parseInt(n), 0);\\n        const count = (map.get(num) || 0) + 1;\\n        ans = Math.max(ans, count);\\n        map.set(num, count);\\n    }\\n    return ans;\\n};", "var countBalls = function(lowLimit, highLimit) {\\n    let map = new Map();\\n    let ans = 0;\\n    for(let i = lowLimit; i <= highLimit; i++) {\\n        const num = String(i).split(\\'\\').reduce((a, n) => a + parseInt(n), 0);\\n        const count = (map.get(num) || 0) + 1;\\n        ans = Math.max(ans, count);\\n        map.set(num, count);\\n    }\\n    return ans;\\n};"]}
{"id": "374", "ref_js": ["var sumOfUnique = function(nums) {\\n    \\n     const unique =nums.filter((v)=>nums.indexOf(v)==nums.lastIndexOf(v))\\n     return unique.length<1?0:unique.reduce((a,c)=>a+=c)\\n\\n};", "var sumOfUnique = function(nums) {\\n    let sum=0\\n    \\n    for(let i=0;i<nums.length;i++){\\n          let flag=0\\n        for(let j=0;j<nums.length;j++){\\n            if(nums[j]==nums[i]&&i!=j){\\n                flag=1\\n            }\\n        }\\n        if(flag==0){\\n            sum=sum+nums[i]\\n        }\\n    }\\n    return sum\\n};", "var sumOfUnique = function(nums) {\\n    let set = new Set(nums);\\n    let sum=0;\\n    for(let i = 0; i<nums.length;i++){\\n        if(set.has(nums[i])){\\n            sum+=nums[i];\\n            set.delete(nums[i])\\n        }else{\\n            let check = set.has(-nums[i])\\n            if(check==false){\\n                 sum -= nums[i];\\n                 set.add(-nums[i])\\n            }\\n           \\n        }\\n    }\\n    return sum\\n};"]}
{"id": "375", "ref_js": ["var check = function(nums) {\\n    let occurance = 0;\\n    for(let i = 0; i < nums.length-1; i++) {\\n        if(nums[i] > nums[i+1]) occurance++;\\n    }\\n    nums[nums.length-1] > nums[0] && occurance++;\\n    return occurance < 2 ? true : false; \\n};", "var check = function(nums) {\\n   let order=0\\n\\n   for(let i=0;i<nums.length;i++){\\n       if(nums[i]>nums[i+1]) order++\\n   }\\n   \\n    nums[0]<nums[nums.length-1] && order++\\n    \\n    return order<2\\n};", "var check = function(nums) {\\n    let count = 0;\\n    const len = nums.length - 1;\\n    for(let i = 0; i < len; i++){\\n        if(nums[i] > nums[i+1]) count++;\\n    }\\n    if(count > 1 || (count == 1 && nums[0] < nums[len])) return false;\\n    return true;\\n};"]}
{"id": "377", "ref_js": ["var minOperations = function(s) {\\n    let c_0 = s[0];\\n    let count1 = count(s, c_0);\\n    let count2 = count(s, c_0 === \\'0\\' ? \\'1\\' : \\'0\\') + 1;\\n    return Math.min(count1, count2);\\n};", "var minOperations = function(s) {\\n    let start10 = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (parseInt(s[i]) === i % 2) {\\n            start10 += 1;\\n        }\\n    }\\n\\n    return Math.min(start10, s.length - start10);    \\n};", "var minOperations = function(s) {\\n    let start10 = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (parseInt(s[i]) === i % 2) {\\n            start10 += 1;\\n        }\\n    }\\n\\n    return Math.min(start10, s.length - start10);    \\n};"]}
{"id": "378", "ref_js": ["var longestNiceSubstring = function(s) {\\n    let ans = \"\";\\n        for (let i = 0; i < s.length; i++) {\\n            for (let ii = i + 1; ii < s.length + 1; ii++) {\\n                let substring = s.slice(i, ii); ", "var longestNiceSubstring = function (s) {\\n\\n\\t\\t\\tif (s.length < 2) return \"\";\\n\\n\\t\\t\\tconst obj = {};", "var longestNiceSubstring = function(s) {\\n    let ans = \"\";\\n        for (let i = 0; i < s.length; i++) {\\n            for (let ii = i + 1; ii < s.length + 1; ii++) {\\n                let substring = s.slice(i, ii); "]}
{"id": "379", "ref_js": ["var mergeAlternately = function(word1, word2) {\\n let result = \\'\\';\\n  for (let i = 0; i < Math.max(word1.length, word2.length); i++) {\\n    if (i < word1.length) result += word1[i];\\n    if (i < word2.length) result += word2[i];\\n  }\\n  return result;\\n};", "var mergeAlternately = function(word1, word2) {\\n    \\n    let res = \"\"\\n    let i = 0 \\n    while( i < word1.length && i < word2.length){\\n        res+=word1[i]\\n        res+=word2[i]\\n\\n        i+=1\\n    }\\n   \\n    if(word1.length > i ){\\n        res+= word1.slice(i)\\n    }\\n    if(word2.length > i ){\\n        res+= word2.slice(i)\\n    }\\n\\n    return res \\n    \\n};", "var mergeAlternately = function(word1, word2) {\\n    let result=\"\";\\n    let length;\\n    \\n    word1.length>word2.length ?  length=word1.length : length=word2.length\\n    for(let i=0;i<length;i++){\\n        if(i<word1.length)\\n            result=result+word1[i];\\n        if(i<word2.length)\\n            result=result+word2[i];\\n    }\\n    return result\\n};"]}
{"id": "380", "ref_js": ["var countMatches = function(items, ruleKey, ruleValue) {\\n    let count = 0\\n    const indexToEval = ruleKey === \"type\" ? 0 : ruleKey === \"color\" ? 1 : 2\\n\\n    items.forEach((item) => {\\n        if (item[indexToEval] === ruleValue) {\\n            count ++\\n        }\\n    })\\n\\n    return count;\\n\\n};", "var countMatches = function (items, ruleKey, ruleValue) {\\n\\tlet count = 0;\\n\\n\\tconst keyIndex = [\\'type\\', \\'color\\', \\'name\\'].indexOf(ruleKey);\\n\\titems.forEach(element => {\\n\\t\\tif (element[keyIndex] === ruleValue) count++;\\n\\t});\\n\\n\\treturn count;\\n};", "var countMatches = function(items, ruleKey, ruleValue) {\\n    var ruleKeys =[\\'type\\',\\'color\\',\\'name\\'];\\n     var keyIndex = ruleKeys.indexOf(ruleKey);\\n     var count=0;\\n   for(var i=0;i<items.length;i++){\\n       if(items[i][keyIndex]===ruleValue) count++;    \\n   }return count\\n};"]}
{"id": "381", "ref_js": ["var nearestValidPoint = function(x, y, points) {\\n    let index = -1; \\n    for (let i = 0, smallest = Number.MAX_VALUE; i < points.length; ++i) {\\n        let dx = x - points[i][0], dy = y - points[i][1];\\n        if (dx * dy === 0 && Math.abs(dy + dx) < smallest) {\\n            smallest = Math.abs(dx + dy);\\n            index = i;\\n        }\\n    }\\n    return index;\\n};", "var nearestValidPoint = function(x, y, points) {\\n    let minDist = Infinity;\\n    let res;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        let [currX, currY] = points[i];\\n        \\n        if (currX === x || currY === y) {\\n            let dist = Math.abs(x - currX) + Math.abs(y - currY);\\n            if (dist < minDist) {\\n                minDist = dist;\\n                res = i;\\n            }\\n        }\\n    }\\n    \\n    if (res === 0) return 0;\\n    \\n    return res ? res : -1\\n};", "var nearestValidPoint = function(x, y, points) {\\n    let minDist = Infinity;\\n    let res;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        let [currX, currY] = points[i];\\n        \\n        if (currX === x || currY === y) {\\n            let dist = Math.abs(x - currX) + Math.abs(y - currY);\\n            if (dist < minDist) {\\n                minDist = dist;\\n                res = i;\\n            }\\n        }\\n    }\\n    \\n    if (res === 0) return 0;\\n    \\n    return res ? res : -1\\n};"]}
{"id": "382", "ref_js": ["var checkOnesSegment = function(s) {\\n   return s.indexOf(\"01\") == -1\\n};", "var checkOnesSegment = function(s) {\\n    return !s.includes(\\'01\\');\\n};", "var checkOnesSegment = function(s) {\\n   return s.indexOf(\"01\") == -1\\n};"]}
{"id": "384", "ref_js": ["var areAlmostEqual = function(s1, s2) {\\n    if (s1.split(\\'\\').sort().join(\\'\\') === s2.split(\\'\\').sort().join(\\'\\')) {\\n            let count = 0;\\n            for (let i = 0; i < s1.length; i++) {\\n                if (s1[i] !== s2[i]) {\\n                    count++;\\n                    if (count > 2) {\\n                        return false;\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n};", "var areAlmostEqual = function(s1, s2) {\\n    let index=[]\\n    for(let i=0;i<s1.length;i++){\\n        if(s1[i]!=s2[i]) index.push(i)\\n\\n    }\\n    \\n    if(index.length==2 && s1[index[0]]==s2[index[1]] && s1[index[1]]==s2[index[0]] || index.length==0) return true\\n    return false\\n    \\n};", "var areAlmostEqual = function (s1, s2) {\\n    let count = 0, arr1 = [], arr2 = []\\n    for (let i = 0; i < s1.length; i++) {\\n        if (s1[i] !== s2[i]) {\\n            arr1.push(s1[i])\\n            arr2.push(s2[i])\\n            count++\\n        }\\n        if (count > 2)\\n            return false\\n    }\\n    if (count === 2) {\\n        return JSON.stringify(arr1.sort()) === JSON.stringify(arr2.sort())\\n    }\\n    return count === 0\\n};"]}
{"id": "385", "ref_js": ["var findCenter = function(edges) {\\n    const [p1, p2] = edges[0]\\n    const [p3, p4] = edges[1]\\n    return p1 == p3 || p1 == p4 ? p1 : p2\\n};", "var findCenter = function(edges) {\\n    const [p1, p2] = edges[0]\\n    const [p3, p4] = edges[1]\\n    return p1 == p3 || p1 == p4 ? p1 : p2\\n};", "var findCenter = function(edges) {\\n    const [p1, p2] = edges[0]\\n    const [p3, p4] = edges[1]\\n    return p1 == p3 || p1 == p4 ? p1 : p2\\n};"]}
{"id": "387", "ref_js": ["var secondHighest = function(s) {\\n    l1=-1;\\n    l2=-1;\\n    for(let char of s){\\n        if(!isNaN(parseInt(char))){\\n            const digit=parseInt(char)\\n            if(digit>l1){\\n              l2=l1;\\n              l1=digit;\\n            }\\n            else if\\n                (digit<l1 && digit>l2){\\n                    l2=digit;\\n                }\\n                      \\n           }\\n           }\\n    return l2;\\n\\n\\n    \\n};", "var secondHighest = function(s) {\\n    let first = -1, sec = -1;\\n    for (let i = 0; i < s.length; ++i) {\\n        let c =  +s.charAt(i); \\n        if (Number.isInteger(c)) {\\n            if (first < c) {\\n                sec = first;\\n                first = c;\\n            } else if (sec < c && c < first) {\\n                sec = c;\\n            }\\n        }\\n    }\\n    return sec;\\n};", "var secondHighest = function (s) {\\n    const numArr = []\\n    for (const item of s) {\\n        if (!isNaN(item - 1)) {\\n            numArr.push(+item)\\n        }\\n    }\\n    const unique = [...new Set(numArr)]\\n    const sortedUnique = unique.sort((a, b) => b - a)\\n    if (sortedUnique.length >= 2) {\\n        return sortedUnique[1]\\n    } else { return -1 }\\n};"]}
{"id": "388", "ref_js": ["var maxAscendingSum = function (nums) {\\n    ", "var maxAscendingSum = function(nums) {\\n\\n    let max = 0;\\n\\n    let currentSum = 0;\\n\\n    for(let i = 0 ; i<nums.length; i++){\\n     \\n     currentSum += nums[i];\\n      \\n     if(nums[i] >= nums[i+1] || i === nums.length-1){\\n       max = Math.max(max,currentSum)\\n       currentSum = 0;\\n     }\\n    }\\n    return max\\n};", "var maxAscendingSum = function(nums) {\\n    let acc = nums[0];\\n    let max = nums[0];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i - 1] < nums[i]) {\\n            acc += nums[i];\\n        } else if (nums[i - 1] >= nums[i]) {\\n            max = max < acc ? acc : max;\\n            acc = nums[i];\\n        }\\n    }\\n\\n    return max > acc ? max : acc;\\n};"]}
{"id": "389", "ref_js": ["var numDifferentIntegers = function(word) {\\n   const str=word.replace(/[^0-9]+/g,\\' \\').trim().replace(/[\\\\s]+/g,\\' \\').split(\\' \\').filter(e=>e&&e).map(e=>e.replace(/^[0]+/,\\'\\'));\\n   return new Set([...str]).size;\\n};", "var numDifferentIntegers = function(word) {\\n    const numStrSet = new Set();\\n    \\n    ", "var numDifferentIntegers = function(word) {\\n   const str=word.replace(/[^0-9]+/g,\\' \\').trim().replace(/[\\\\s]+/g,\\' \\').split(\\' \\').filter(e=>e&&e).map(e=>e.replace(/^[0]+/,\\'\\'));\\n   return new Set([...str]).size;\\n};"]}
{"id": "390", "ref_js": ["var findLUSlength = function(a, b) {\\n    return a === b ? -1 : Math.max(a.length, b.length);\\n};", "var findLUSlength = function(a, b) {\\n    return a == b ? -1: Math.max(a.length, b.length)\\n};", "var findLUSlength = function(a, b) {\\n    return a === b ? -1 : Math.max(a.length, b.length);\\n};"]}
{"id": "391", "ref_js": ["var truncateSentence = function(s, k) {\\n    return s.split(\\' \\').slice(0,k).join(\\' \\')\\n};", "var truncateSentence = function(s, k) {\\n    return s.split(\\' \\').slice(0,k).join(\\' \\')\\n};", "var truncateSentence = function(s, k) {\\n    return s.split(\\' \\').slice(0,k).join(\\' \\')\\n};"]}
{"id": "392", "ref_js": ["var arraySign = function(nums) {\\n", "var arraySign = function(nums) {\\n    return nums.reduce((a, c) => a == 0 || c == 0 ? 0 : c < 0 ? a*-1 : a, 1);    \\n};", "var arraySign = function(nums) {\\n    "]}
{"id": "393", "ref_js": ["var minOperations = function(nums) {\\n    let ops=0\\n    for(let i=1;i<nums.length;i++){\\n        if(nums[i]<=nums[i-1]){\\n            ops+=(nums[i-1]-nums[i])+1\\n            nums[i]=nums[i-1]+1\\n        }\\n    }\\n    return ops\\n};", "var minOperations = function(nums) {\\n    if(nums.length < 2) return 0;\\n    let count = 0;\\n    for(let i = 1; i<nums.length; i++) {\\n       if(nums[i] <= nums[i-1]) {\\n           let change = nums[i-1] - nums[i] + 1;\\n           count += change;\\n           nums[i] += change;\\n       }\\n    }\\n    \\n    return count;\\n};", "var minOperations = function(nums) {\\n    if(nums.length < 2) return 0;\\n    let count = 0;\\n    for(let i = 1; i<nums.length; i++) {\\n       if(nums[i] <= nums[i-1]) {\\n           let change = nums[i-1] - nums[i] + 1;\\n           count += change;\\n           nums[i] += change;\\n       }\\n    }\\n    \\n    return count;\\n};"]}
{"id": "394", "ref_js": ["var checkIfPangram = function(sentence) {\\n    let alpha = \\'abcdefghijklmnopqrstuvwxyz\\'.split(\\'\\');\\n    for(let i=0; i<alpha.length; i++){\\n        if(sentence.indexOf(alpha[i]) === -1){\\n            return false;\\n        }\\n    }\\n    return true;\\n};", "var checkIfPangram = function (sentence) {\\n    return new Set(sentence).size === 26\\n};", "var checkIfPangram = function(sentence) {\\n    let alpha = \\'abcdefghijklmnopqrstuvwxyz\\'.split(\\'\\');\\n    for(let i=0; i<alpha.length; i++){\\n        if(sentence.indexOf(alpha[i]) === -1){\\n            return false;\\n        }\\n    }\\n    return true;\\n};"]}
{"id": "395", "ref_js": ["var sumBase = function(n, k) {\\n    let sum = 0\\n    while(n>0){\\n        sum += n%k\\n        n = ~~(n/k)\\n    }\\n    return sum\\n};", "var sumBase = function(n, k) {\\n\\n  const nums=n.toString(k).split(\\'\\')\\n  return nums.reduce((ac,cur)=>ac+=Number(cur),0)\\n\\n};", "var sumBase = function(n, k) {\\n    return n.toString(k).split(\\'\\').reduce((acc,curr) => acc+=parseInt(curr),0);\\n};"]}
{"id": "396", "ref_js": ["var replaceDigits = function(s) {\\n    let d = \"\";\\n\\n    for (let i of s) {\\n  if (!isNaN(i)) {\\n    console.log(\"i is\", i);\\n    let z = d.charCodeAt(d.length - 1) + parseInt(i);\\n    d += String.fromCharCode(z);\\n  } else {\\n    d += i;\\n    console.log(\"else d is\", d);\\n  }\\n    }\\n      return d\\n\\n};", "var replaceDigits = function(s) {\\n  let number = \"1234567890\";\\n  let result = [];\\n  for (let i = 0; i < s.length; i++) {\\n    result.push(s[i]);\\n    if (number.includes(s[i])) {\\n      result[i] = String.fromCharCode(s.charCodeAt(i - 1) + Number(s[i]));\\n    }\\n  }\\n  return result.join(\"\");\\n};", "var replaceDigits = function(s) {\\n    let d = \"\";\\n\\n    for (let i of s) {\\n  if (!isNaN(i)) {\\n    console.log(\"i is\", i);\\n    let z = d.charCodeAt(d.length - 1) + parseInt(i);\\n    d += String.fromCharCode(z);\\n  } else {\\n    d += i;\\n    console.log(\"else d is\", d);\\n  }\\n    }\\n      return d\\n\\n};"]}
{"id": "397", "ref_js": ["var getMinDistance = function(nums, target, start) {\\n    var array=[]\\n    for(var i=0;i<nums.length;i++){\\n        if(nums[i]===target){\\n        var hi = Math.abs(i - start)\\n        array.push(hi)\\n        \\n           \\n        }\\n    }\\n    return Math.min(...array)\\n};", "var getMinDistance = function(nums, t, s) {\\n    let o = Number.POSITIVE_INFINITY;\\n    for(let i = 0; i<nums.length;i++){\\n        if(nums[i]==t){\\n            o = Math.min(o,Math.abs(s - i));\\n        }\\n    }\\n    return o\\n    \\n};", "var getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};"]}
{"id": "398", "ref_js": ["var maximumPopulation = function(logs) {\\n    const count = new Array(101).fill(0);\\n    \\n    for (const [birth, death] of logs) {\\n        count[birth - 1950]++;\\n        count[death - 1950]--;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let i = 1; i < 101; i++) {\\n        count[i] += count[i - 1];\\n        \\n        if (count[i] > count[max]) max = i;\\n     }\\n    \\n     return 1950 + max;\\n };", "var maximumPopulation = function(logs) {\\n    const {minYear, maxYear} = findMinMaxYears(logs);\\n    \\n    let tracker = {};", "var maximumPopulation = function(logs) {\\n    var years = {};"]}
{"id": "399", "ref_js": ["var sortSentence = function (s) {\\n  let m = new Map();\\n  let arr = s.split(\" \");\\n  arr.forEach((element) => {\\n    m.set(element[element.length - 1], element.slice(0, element.length - 1));\\n  });\\n  m = new Map([...m.entries()].sort());\\n  let result = \"\";\\n  for (const i of m.keys()) {\\n    result += m.get(i) + \" \";\\n  }\\n  return result.trimEnd();\\n};", "var sortSentence = function(s) {\\n    ", "var sortSentence = function (s) {\\n  let m = new Map();\\n  let arr = s.split(\" \");\\n  arr.forEach((element) => {\\n    m.set(element[element.length - 1], element.slice(0, element.length - 1));\\n  });\\n  m = new Map([...m.entries()].sort());\\n  let result = \"\";\\n  for (const i of m.keys()) {\\n    result += m.get(i) + \" \";\\n  }\\n  return result.trimEnd();\\n};"]}
{"id": "400", "ref_js": ["var subsetXORSum = function(nums) {\\n    \\n    let result = 0;\\n    let n = nums.length;\\n    \\n    if(n < 0){\\n        return 0\\n    }\\n\\n    for(let i = 0; i < Math.pow(2, n); i++){\\n        let subsetXOR = 0;\\n        for(let j = 0; j < n; j++){\\n                if((i & (1 << j)) !== 0){\\n                    subsetXOR ^= nums[j]\\n                }\\n        }\\n        result += subsetXOR;\\n    }\\n    return result;\\n};", "var subsetXORSum = function(nums) {\\n    let sum=0;\\n    dfs(0, 0); return sum;\\n    \\n    function dfs(val, i){\\n        if(i<nums.length){\\n            dfs(val^nums[i], i+1);  ", "var subsetXORSum = function(nums) {\\n    \\n    let result = 0;\\n    let n = nums.length;\\n    \\n    if(n < 0){\\n        return 0\\n    }\\n\\n    for(let i = 0; i < Math.pow(2, n); i++){\\n        let subsetXOR = 0;\\n        for(let j = 0; j < n; j++){\\n                if((i & (1 << j)) !== 0){\\n                    subsetXOR ^= nums[j]\\n                }\\n        }\\n        result += subsetXOR;\\n    }\\n    return result;\\n};"]}
{"id": "401", "ref_js": ["var checkZeroOnes = function(s) {\\n    s+=(1-s[s.length-1]);\\n    let max0=max1=0, start=0;\\n    for(let i=1; i<s.length; i++){\\n        if(s[i]!=s[i-1] && s[i]==1){\\n            max0=Math.max(max0, i-start); start=i;\\n        }\\n        if(s[i]!=s[i-1] && s[i]==0){\\n            max1=Math.max(max1, i-start); start=i;\\n        }\\n    }\\n    return max1>max0;\\n};", "var checkZeroOnes = function(s) {\\n    return Math.max(...s.split(\\'0\\').map(item => item.length)) > Math.max(...s.split(\\'1\\').map(item => item.length))\\n};", "var checkZeroOnes = function(s) {\\n    s+=(1-s[s.length-1]);\\n    let max0=max1=0, start=0;\\n    for(let i=1; i<s.length; i++){\\n        if(s[i]!=s[i-1] && s[i]==1){\\n            max0=Math.max(max0, i-start); start=i;\\n        }\\n        if(s[i]!=s[i-1] && s[i]==0){\\n            max1=Math.max(max1, i-start); start=i;\\n        }\\n    }\\n    return max1>max0;\\n};"]}
{"id": "403", "ref_js": ["var countGoodSubstrings = function (s) {\\n  let unquieLength = 0\\n\\n  for (let i = 2; i < s.length; i++) {\\n    if (isUnquie(s.substring(i - 2, i + 1))) {\\n      unquieLength++\\n    }\\n  }\\n\\n  function isUnquie(str) {\\n    const set = new Set([...str])\\n    console.log(str, set)\\n    return set.size > 2\\n  }\\n\\n  return unquieLength\\n};", "var countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};", "var countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};"]}
{"id": "404", "ref_js": ["var isSumEqual = function(firstWord, secondWord, targetWord) {\\n    let obj = {\\n        \\'a\\' : \\'0\\',\\n        \"b\" : \\'1\\',\\n        \"c\" : \\'2\\',\\n        \"d\" : \\'3\\',\\n        \"e\" : \\'4\\',\\n        \\'f\\' : \\'5\\',\\n        \\'g\\' : \\'6\\',\\n        \\'h\\' : \\'7\\',\\n        \\'i\\' : \\'8\\', \\n        \"j\" : \\'9\\'\\n    }\\n    let first = \"\", second = \"\", target = \"\"\\n    for(let char of firstWord){\\n        first += obj[char]\\n    }\\n    for(let char of secondWord){\\n        second += obj[char]\\n    }\\n    for(let char of targetWord){\\n        target += obj[char]\\n    }\\n    return parseInt(first) + parseInt(second) === parseInt(target)\\n};", "var isSumEqual = function(firstWord, secondWord, targetWord) {\\n  \\n  function valueOfString(str) {\\n    let value = \\'\\'\\n\\n    for (let index = 0; index < str.length; index ++) {\\n      value += (str.charCodeAt(index)-97)\\n    }\\n    \\n  return value \\n  }\\n  \\n  return (parseInt(valueOfString(firstWord)) + parseInt(valueOfString(secondWord)))  === parseInt(valueOfString(targetWord))\\n};", "var isSumEqual = function (s, t, target) {\\n        let ALPHA_INDEX_MAP = {a:0,b:1,c:2,d:3,e:4,f:5,g:6,h:7,i:8,j:9,k:10,l:11,m:12,n:13,o:14,p:15,q:16,r:17,s:18,t:19,u:20,v:21,w:22,x:23,y:24,z:25};"]}
{"id": "405", "ref_js": ["var findRotation = function(mat, target) {\\n    let width = mat[0].length;\\n    let height = mat.length;\\n    \\n    let normal = true;\\n    let rightOneTime = true;\\n    let rightTwoTimes = true;\\n    let rightThreeTimes = true;\\n    for (let i = 0; i < height; i++)  {\\n        for (let j = 0; j < width; j++) {\\n            ", "var findRotation = function(mat, target) {\\n    const rotateArr = (arr) => {\\n        let n = arr.length;\\n\\n        ", "var findRotation = function(mat, target) {\\n    const rotateArr = (arr) => {\\n        let n = arr.length;\\n\\n        "]}
{"id": "407", "ref_js": ["var isCovered = function(ranges, left, right) {\\n    let z=0,f=0,e=[];\\n    let a=ranges.flat(Infinity);\\n\\n    function abc(c,d){\\n        for(let i=c;i<=d;i++)\\n        if(e[i]==i)\\n        e[i]=null;\\n    }\\n    for(let i=left;i<=right;i++)\\n        e[i]=i;\\n    for(let i=0;i<a.length;i=i+2){\\n        if(a[i]<=left&&a[i+1]>=right)\\n        return true;\\n        else if(a[i]>right)\\n        continue;\\n        else abc(a[i],a[i+1])\\n    }\\n    for(let i=left;i<=right;i++)\\n    if(e[i]!=null)\\n    return false\\n    \\n    return true\\n};", "var isCovered = function(nums, left, right) {\\n     let newSet = new Set;\\n    let secondSet = new Set;\\n\\n    for ( ele of nums){\\n         for ( let [x,y] of nums){\\n            for ( let i =x ; i<= y ; i++)\\n        newSet.add(i)\\n\\n        }\\n    }\\n\\n    for( let i = left ; i <= right ; i++){\\n        secondSet.add(i)\\n    }\\n\\n    for (const element of secondSet) {\\n        if (!newSet.has(element)) {\\n          return false;\\n        }\\n      }\\n      return true;\\n};", "var isCovered = function(ranges, left, right) {\\n    for(let i=left;i<=right;i++){\\n        let flag=0\\n        for(let j=0;j<ranges.length;j++){\\n            if(ranges[j][0]<=i && ranges[j][1]>=i){\\n                flag=1\\n                break;\\n            }\\n        }\\n        if(!flag) return false\\n    }\\n    return true\\n};"]}
{"id": "408", "ref_js": ["var makeEqual = function(words) {\\n    const hashmap = new Map();\\n    let sum = 0;\\n\\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        sum += word.length;\\n\\n        for (let j = 0; j < word.length; j++) {\\n            const character = word[j];\\n\\n            if (hashmap.has(character)) {\\n                hashmap.set(character, hashmap.get(character) + 1);\\n            } else {\\n                hashmap.set(character, 1);\\n            }\\n        }\\n    }\\n    if (sum%(words.length)) return false;\\n\\n    let output = true;\\n    hashmap.forEach((value) => {\\n        if (value%(words.length)) output = false;\\n    });\\n\\n    return output;\\n};", "var makeEqual = function (words) {\\n    const map = {}\\n    for (const word of words)\\n        for (const char of word)\\n            map[char] ? map[char]++ : map[char] = 1\\n    for (const number of Object.values(map))\\n        if (number % words.length !== 0)\\n            return false\\n    return true\\n};", "var makeEqual = function(words) {\\n    \\n    \\n    let length = words.length\\n    \\n    let map = {}\\n    for( let word of words ) {\\n        for( let ch of word ) {\\n            map[ch] = ( map[ch] || 0 )  + 1 \\n        }\\n    }\\n    \\n    for( let key of Object.keys(map)) {\\n        if( map[key] % length !=0 ) return false\\n    }\\n    \\n    return true\\n    \\n};"]}
{"id": "409", "ref_js": ["var largestOddNumber = function(num) {\\n    if (parseInt(num.slice(-1)) % 2 === 1) return num;\\n    let i = num.length - 1;\\n    while (i >= 0) {\\n        const n = parseInt(num[i]);\\n        if (n % 2 === 1) return num.slice(0, i + 1);\\n        i--;\\n    }\\n    return \"\";\\n};", "var largestOddNumber = function(num) {\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (parseInt(num[i]) % 2 === 1) {\\n            return num.slice(0, i + 1);\\n        }\\n    }\\n    \\n    return \"\";    \\n};", "var largestOddNumber = function(num) {\\n    if (parseInt(num.slice(-1)) % 2 === 1) return num;\\n    let i = num.length - 1;\\n    while (i >= 0) {\\n        const n = parseInt(num[i]);\\n        if (n % 2 === 1) return num.slice(0, i + 1);\\n        i--;\\n    }\\n    return \"\";\\n};"]}
{"id": "410", "ref_js": ["var canBeIncreasing = function(nums) {\\n    let count = 0\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] <= nums[i-1]){\\n            count++;\\n            if(i>1 && nums[i] <= nums[i-2]) nums[i] = nums[i-1]\\n        }\\n    }\\n    return count <= 1\\n};", "var canBeIncreasing = function(nums) {\\n    let cnt = 0;\\n    for (let i = 1; i < nums.length && cnt < 2; i++) {\\n        if (nums[i - 1] >= nums[i]) {\\n            cnt++\\n            if (i > 1 && nums[i - 2] >= nums[i]) {\\n                nums[i] = nums[i - 1]\\n            }\\n        }\\n    }\\n    \\n    return cnt < 2;\\n};", "var canBeIncreasing = function(nums) {\\n  for (let i = 1, used = false, prev = nums[0]; i < nums.length; i++) {\\n    if (nums[i] > prev) { prev = nums[i]; continue }\\n    if (used) return false;\\n    used = true;\\n    (i === 1 || nums[i] > nums[i - 2]) && (prev = nums[i]);\\n  }\\n  return true;\\n};"]}
{"id": "411", "ref_js": ["var maxProductDifference = function(nums) {\\r\\n    let firstBig = secondBig = 0;\\r\\n    let firstSmall = secondSmall = Infinity;\\r\\n\\r\\n    for (const n of nums) {\\r\\n        if (n < firstSmall) {\\r\\n            [secondSmall, firstSmall] = [firstSmall, n];\\r\\n        } else if (n < secondSmall) {\\r\\n            secondSmall = n;\\r\\n        }\\r\\n\\r\\n        if (n > firstBig) {\\r\\n            [secondBig, firstBig] = [firstBig, n];\\r\\n        } else if (n > secondBig) {\\r\\n            secondBig = n;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return firstBig * secondBig - firstSmall * secondSmall;    \\r\\n};", "var maxProductDifference = function(nums) {\\r\\n    let largest = 0, secondLargest = 0;\\r\\n    let smallest = Number.MAX_SAFE_INTEGER, secondSmallest = Number.MAX_SAFE_INTEGER;\\r\\n\\r\\n    for (const n of nums) {\\r\\n        if (n < smallest) {\\r\\n            secondSmallest = smallest;\\r\\n            smallest = n;\\r\\n        } else if (n < secondSmallest) {\\r\\n            secondSmallest = n;\\r\\n        }\\r\\n\\r\\n        if (n > largest) {\\r\\n            secondLargest = largest;\\r\\n            largest = n;\\r\\n        } else if (n > secondLargest) {\\r\\n            secondLargest = n;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return (largest * secondLargest) - (smallest * secondSmallest);\\r\\n};", "var maxProductDifference = function(nums) {\\r\\n    let firstBig = secondBig = 0;\\r\\n    let firstSmall = secondSmall = Infinity;\\r\\n\\r\\n    for (const n of nums) {\\r\\n        if (n < firstSmall) {\\r\\n            [secondSmall, firstSmall] = [firstSmall, n];\\r\\n        } else if (n < secondSmall) {\\r\\n            secondSmall = n;\\r\\n        }\\r\\n\\r\\n        if (n > firstBig) {\\r\\n            [secondBig, firstBig] = [firstBig, n];\\r\\n        } else if (n > secondBig) {\\r\\n            secondBig = n;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return firstBig * secondBig - firstSmall * secondSmall;    \\r\\n};"]}
{"id": "412", "ref_js": ["var buildArray = function(nums) {\\n    \\n    \\n    return nums.map(val=>nums[val]);\\n};", "var buildArray = function(nums) {\\n    var ans=[]\\n    for(var i=0;i<nums.length;i++){\\n    ans[i] = nums[nums[i]]\\n    }return ans\\n    \\n};", "var buildArray = function(nums) {\\n     var ans = [];\\n  for (var i = 0; i <= nums.length - 1; i++) {\\n    ans[i] = nums[nums[i]];\\n  }\\n  return ans;\\n};"]}
{"id": "413", "ref_js": ["var countTriples = function(n) {\\n    let count = 0 \\n    for(let i=1; i<n; i++){\\n\\n        ", "var countTriples = function (n) {\\nlet count=0;\\n    for (let i = 1; i <= n; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (i !== j) {\\n                if (Math.sqrt((i*i) + (j*j)) <= n && Math.sqrt((i*i) + (j*j)) >= 0&&Number.isInteger(Math.sqrt((i*i) + (j*j)))) {\\n               \\ncount++ \\n                }\\n            }\\n        }\\n    }\\n    return count\\n};", "var countTriples = function(n) {\\n    let count=0;\\n    let a=[];\\n    for(let i=n;i>=1;i--){\\n    a.push(i*i);\\n    }\\n\\n    for(let j=0;j<a.length;j++){\\n        for(let k=j+1;k<a.length-1;k++){\\n            if(a.includes(a[j]+a[k])){\\n                count=count+2;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};"]}
{"id": "414", "ref_js": ["var getConcatenation = function(nums) {\\n   var ans = [2 * nums.length];\\n  for (let i = 0; i < 2 * nums.length; i++) {\\n    if (i < nums.length) {\\n      ans[i] = nums[i];\\n    } else {\\n      ans[i] = nums[i - nums.length];\\n    }\\n  }\\n  return ans;\\n};", "var getConcatenation = function(nums) {\\n    return nums.concat(nums);\\n};", "var getConcatenation = function(nums) {\\n   var ans = [2 * nums.length];\\n  for (let i = 0; i < 2 * nums.length; i++) {\\n    if (i < nums.length) {\\n      ans[i] = nums[i];\\n    } else {\\n      ans[i] = nums[i - nums.length];\\n    }\\n  }\\n  return ans;\\n};"]}
{"id": "415", "ref_js": ["var canBeTypedWords = function(text, brokenLetters) {\\n    let regexp=\"[\"+brokenLetters+\"]\\\\+\"\\n    let word=text.split(\" \"), count=0;\\n    for(let i=0; i<word.length; i++){\\n        let work=true;\\n\\t\\t", "var canBeTypedWords = function(text, brokenLetters) {\\n    text =text.split(\\' \\');\\n    let counter = 0;\\n    for(let el of text) {\\n        if(!el.match(new RegExp(\"[\" + brokenLetters + \"]\", \"g\"))){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};", "var canBeTypedWords = function(text, brokenLetters) {\\n    text =text.split(\\' \\');\\n    let counter = 0;\\n    for(let el of text) {\\n        if(!el.match(new RegExp(\"[\" + brokenLetters + \"]\", \"g\"))){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"]}
{"id": "416", "ref_js": ["var areOccurrencesEqual = function(s) {\\n    let count \\n    let arr = [];\\n    for (let i = 0; i < s.length; i++) {\\n         count = 0;\\n        for (let j = 0; j < s.length; j++) {\\n            if (s[i] === s[j]) {\\n                if (j < i) {\\n                    break;\\n                }\\n                count++;\\n            }\\n        }\\n        if(count!=0)\\n        arr.push(count);\\n    }\\n    for (let i = 0; i < arr.length - 1; i++) {\\n        if (arr[i] !== arr[i + 1]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};", "var areOccurrencesEqual = function(s) {\\n\\n    let obj = {}\\n\\n    for(const char of s)\\n        obj[char] ? obj[char]++ : obj[char] = 1;\\n\\n    const count = obj[s[0]];\\n\\n    for(const el in obj)\\n        if(obj[el] !== count) return false\\n\\n    return true\\n};", "var areOccurrencesEqual = function (s) {\\n  const map = new Map();\\n  for (let i = 0; i < s.length; i++) {\\n    map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n  }\\n  let occurance = map.get(s[0]);\\n  for (const [k, v] of map) {\\n    if (v === occurance) {\\n      continue;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return true;\\n};"]}
{"id": "417", "ref_js": ["var getLucky = function(s, k) {\\n\\tlet ans = s.split(\\'\\').reduce((acc, char) => acc + (char.charCodeAt(0) - 96), \\'\\')\\n\\twhile (k > 0) {\\n\\t\\tans = ans.toString().split(\\'\\').reduce((sum, num) => sum + Number(num), 0)\\n        k--;\\n\\t}\\n\\treturn ans;\\n};", "var getLucky = function(s, k) {\\n    let arr = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n    let str = \\'\\'\\n    let ans = 0\\n    let count = 0\\n    for(let i = 0;i < s.length;i++){\\n        s.charAt(i)\\n        for(let j = 0; j < arr.length; j++){\\n            if(s.charAt(i) == arr[j]){ \\n                let temp = j + 1\\n                str += temp.toString()\\n            }\\n        }\\n    }\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < str.length;i++){\\n        ans += parseInt(str.charAt(i))\\n     }\\n     count = ans\\n     str = ans.toString()\\n     ans = 0\\n    }\\n    return count\\n};", "var getLucky = function(s, k) {\\n\\tlet res = s.split(\\'\\').reduce((acc, el) => acc + (el.charCodeAt(0) - 96), \\'\\')\\n\\tfor (let i = 0; i < k; i++) {\\n\\t\\tres = res.toString().split(\\'\\').reduce((acc, el) => acc + Number(el), 0)\\n\\t}\\n\\treturn res;\\n};"]}
{"id": "418", "ref_js": ["var isThree = function (n) {\\n    let count = 0;\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (count <= 3) {\\n            if (n % i === 0) count++\\n        } else {\\n            return false\\n        }\\n    }\\n\\n    return count === 3\\n};", "var isThree = function(n) {\\n    ", "var isThree = function(n) {\\n    const divisors = new Set();\\n\\n    for (let i=1; i <= n; i++) {\\n        if (n % i == 0) {\\n            divisors.add(i);\\n        };"]}
{"id": "419", "ref_js": ["var makeFancyString = function (s) {\\n  let result = s.split(\"\");\\n\\n  for (let i = 0; i < result.length; i++) {\\n    if (result[i] === result[i + 1] && result[i + 1] === result[i + 2]) {\\n      result[i] = \"\";\\n    }\\n  }\\n\\n  return result.join(\"\");\\n};", "var makeFancyString = function(s) {\\n\\n    let string = s.slice(0,2);\\n    const length = s.length;\\n    for(let i = 2; i < length; i++){\\n            if(s[i]!== s[i-1] || (s[i]!== s[i-2])){\\n               string += s[i]; \\n              }\\n        }\\n        return string;\\n};", "var makeFancyString = function(s) {\\n    "]}
{"id": "420", "ref_js": ["var isPrefixString = function(s, words) {\\n    let compareStr = \\'\\';\\n\\n    for (let i = 0; i < words.length; i++) {\\n        compareStr = compareStr + words[i];\\n        if (compareStr === s) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};", "var isPrefixString = function(s, words) {\\n    let i = 0;\\n    \\n    for (const word of words) {\\n        if (!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if (i === s.length) return true;\\n    }\\n    \\n    return false;\\n};", "var isPrefixString = function(s, words) {\\n    let i = 0;\\n    \\n    for (const word of words) {\\n        if (!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if (i === s.length) return true;\\n    }\\n    \\n    return false;\\n};"]}
{"id": "422", "ref_js": ["var numOfStrings = function(patterns, word) {\\n    return patterns.reduce((a,c) => a + (word.includes(c) ? 1 : 0), 0)\\n};", "var numOfStrings = function(patterns, word) {\\n    let result = 0; \\n    \\n    for(let char of patterns){\\n        if(word.includes(char)){\\n            result++;\\n           } else{\\n               result += 0;\\n           }\\n    }\\n    \\n    return result;\\n};", "var numOfStrings = function(patterns, word) {\\n    return patterns.reduce((a,c) => a + (word.includes(c) ? 1 : 0), 0)\\n};"]}
{"id": "423", "ref_js": ["var validPath = function(n, edges, source, destination) {\\n    let adjList = {}, visited = [];\\n\\n    for (const edge of edges){\\n        adjList[edge[0]] ? adjList[edge[0]].push(edge[1]) :\\n            adjList[edge[0]] = [edge[1]];\\n        \\n        adjList[edge[1]] ? adjList[edge[1]].push(edge[0]) :\\n            adjList[edge[1]] = [edge[0]];\\n        \\n    };", "var validPath = function(n, edges, source, destination) {\\n    \\n    let length = edges.length;\\n    if(length == 0) return true;\\n    \\n    let visited = [];\\n        let queue = [source];\\n        while(queue.length > 0) {\\n            let element = queue.shift();\\n            visited[element] = true;\\n            let i = 0;\\n            while(i < edges.length) {\\n                let index = (edges[i]).indexOf(element);\\n                if(index != -1) {\\n                    let secondElement = edges[i][1-index];\\n                    if(secondElement == destination) {\\n                            return true;\\n                    } else {\\n                        if(!visited[secondElement]) {\\n                            queue.push(secondElement);\\n                        }\\n                    }   \\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n};", "var validPath = function(n, edges, source, destination) {\\n    let adjList = {}, visited = [];\\n\\n    for (const edge of edges){\\n        adjList[edge[0]] ? adjList[edge[0]].push(edge[1]) :\\n            adjList[edge[0]] = [edge[1]];\\n        \\n        adjList[edge[1]] ? adjList[edge[1]].push(edge[0]) :\\n            adjList[edge[1]] = [edge[0]];\\n        \\n    };"]}
{"id": "424", "ref_js": ["var minTimeToType = function(word) {\\n  let ops = 0;\\n  let cur = \\'a\\';\\n  \\n  for(const char of word) {\\n    const diff = Math.abs(cur.charCodeAt(0) - char.charCodeAt(0));\\n    if(diff > 13) {\\n      ops += 26 - diff + 1;\\n    } else {\\n      ops += diff + 1;\\n    }\\n    \\n    cur = char;\\n  }\\n  \\n  return ops;\\n};", "var minTimeToType = function (word) {\\n  let minTime = 0;\\n  ", "var minTimeToType = function(word) {\\n    let prev = 97;\\n    let sec = 0;\\n\\n    for(let i=0; i<word.length; i++) {\\n        const code = word.charCodeAt(i);\\n        const min = Math.min(mod(code - prev, 26), mod(prev - code, 26));\\n\\n        sec += min + 1;\\n        prev = code;\\n    }\\n\\n    return sec;\\n};"]}
{"id": "426", "ref_js": ["var findGCD = function(nums) {\\n    let min = Math.min(...nums);\\n    let max = Math.max(...nums);\\n    \\n    for (let i = max; i >= 0; i--) {\\n        if (max % i === 0 && min % i === 0) return i;\\n    }\\n    \\n};", "var findGCD = function(nums) {\\n    let min = Math.min(...nums);\\n    let max = Math.max(...nums);\\n    \\n    for (let i = max; i >= 0; i--) {\\n        if (max % i === 0 && min % i === 0) return i;\\n    }\\n    \\n};", "var findGCD = function(nums) {\\n    let min = Math.min(...nums);\\n    let max = Math.max(...nums);\\n    \\n    for (let i = max; i >= 0; i--) {\\n        if (max % i === 0 && min % i === 0) return i;\\n    }\\n    \\n};"]}
{"id": "427", "ref_js": ["var minimumDifference = function(nums, k) {\\n    \\n     nums = nums.sort((a,b)=> a-b)\\n\\n     let mini = 80000000000\\n\\n     for(let i=0;i < nums.length- k+1;i++){\\n         mini = Math.min(mini,nums[i+k-1] - nums[i])\\n     }\\n     return mini\\n};", "var minimumDifference = function(nums, k) {\\n    \\n    flag=0;\\n    if(k==1)\\n    return 0;\\n    let arr,val;\\n    nums=nums.sort((a,b)=>b-a);\\n    for(let i=0;i+k<=nums.length;i++){\\n        arr=nums.slice(i,i+k)\\n        if(flag==0){\\n            val=arr[0]-arr[arr.length-1];\\n            flag=1;\\n            continue;\\n        }\\n        if(flag==1&&(arr[0]-arr[arr.length-1])<val)\\n        val=arr[0]-arr[arr.length-1];\\n    }\\n    return val;\\n};", "var minimumDifference = function(nums, k) {\\n    \\n  if(nums.length==1) return 0\\n\\n  nums.sort((a,b)=>a-b)\\n   let start=0,end=k-1,diffrence=nums[nums.length-1];\\n  while(end<nums.length){\\n      diffrence=Math.min(nums[end]-nums[start],diffrence)\\n      start++\\n      end++\\n  }\\n    return diffrence\\n};"]}
{"id": "428", "ref_js": ["var findMiddleIndex = function(nums) {\\n    let total = 0;\\n    for(let i=0; i<nums.length; i++){\\n        total += nums[i];\\n    }\\n    let left = 0;\\n    for(let i=0; i<nums.length; i++){\\n        if(left * 2 === total - nums[i]){\\n            return i;\\n        }\\n        left += nums[i]\\n    }\\n    return -1;\\n};", "var findMiddleIndex = function(nums) {\\n  let preSum = [nums[0]]; ", "var findMiddleIndex = function(nums) {\\n  let preSum = [nums[0]]; "]}
{"id": "429", "ref_js": ["var countQuadruplets = function(arr) {\\n      let count = 0;\\n  for (let i = 0; i < arr.length; i++) {\\n    for (let j = i + 1; j < arr.length; j++) {\\n      for (let k = j + 1; k < arr.length; k++) {\\n        for (let l = k + 1; l < arr.length; l++) {\\n          if (arr[i] + arr[j] + arr[k] == arr[l]) {\\n            count++;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return count;\\n};", "var countQuadruplets = function (nums) {\\n    let count = 0\\n    for (let a = 0; a < nums.length; a++) {\\n        for (let b = a + 1; b < nums.length; b++) {\\n            for (let c = b + 1; c < nums.length; c++) {\\n                for (let d = c + 1; d < nums.length; d++) {\\n                    if (nums[a] + nums[b] + nums[c] === nums[d]) {\\n                        count++\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return count\\n};", "var countQuadruplets = function(arr) {\\nlet count = 0;\\n  for (let i = 0; i < arr.length; i++) {\\n    for (let j = i + 1; j < arr.length; j++) {\\n      for (let k = j + 1; k < arr.length; k++) {\\n        for (let l = k + 1; l < arr.length; l++) {\\n          if (arr[i] + arr[j] + arr[k] == arr[l]) {\\n            count++;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return count;\\n\\n};"]}
{"id": "430", "ref_js": ["var reversePrefix = function(word, ch) { \\n    return word.split(\\'\\').slice(0,word.indexOf(ch)+1).reverse().join(\\'\\')+word.slice(word.indexOf(ch)+1,word.length)\\n};", "var reversePrefix = function (word, ch) {\\n    let reverSt = \"\"; ", "var reversePrefix = function(word, ch) {\\n    word.split(\\'\\')\\n    let i=word.indexOf(ch)\\n  \\n    return word.slice(0,i+1).split(\\'\\').reverse().join(\\'\\') + word.slice(i+1)\\n};"]}
{"id": "431", "ref_js": ["var countKDifference = function(nums, k) {\\n    nums = nums.sort((b,a) => b- a)\\n   let count = 0;\\n    \\n    for(let i = 0; i< nums.length; i++) {\\n         for(let j = i + 1; j< nums.length; j++) {\\n            if(Math.abs(nums[i] - nums[j]) == k) { \\n                count++\\n            }\\n          }\\n    }\\n    return count ;\\n};", "var countKDifference = function(nums, k) {\\n    let count = 0, n = nums.length;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i+1; j < n; j++) {\\n            if (Math.abs(nums[i] - nums[j]) === k) {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};", "var countKDifference = function(nums, k) {\\n    let map = {};"]}
{"id": "432", "ref_js": ["var finalValueAfterOperations = function(operations) {\\n    return operations.reduce((acc,i) => i.includes(\\'+\\') ? acc += 1 : acc -= 1, 0)\\n};", "var finalValueAfterOperations = function(operations) {\\n    return operations.reduce((acc,i) => i.includes(\\'+\\') ? acc += 1 : acc -= 1, 0)\\n};", "var finalValueAfterOperations = function(operations) {\\n    return operations.reduce((acc,i) => i.includes(\\'+\\') ? acc += 1 : acc -= 1, 0)\\n};"]}
{"id": "433", "ref_js": ["var maximumDifference = function(nums) {\\n\\n    let num=0;\\n    for(let i=0; i<nums.length;i++){\\n        for(let j= i+1; j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                diff = nums[j]- nums[i];\\n                if(diff>num){\\n                    num = diff;\\n                }\\n            }\\n        }\\n    }\\n    return num? num : -1;\\n};", "var maximumDifference = function(nums) {\\n    if(nums.length <2){\\n        return -1\\n    }\\n    let s =-1\\n    \\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i]<nums[j]){\\n                s=Math.max(s,nums[j]-nums[i])\\n            }\\n        }\\n    }\\n    return s\\n};", "var maximumDifference = function(nums) {\\n       let a=[];\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i]<nums[j]){\\n                a.push(nums[j]-nums[i]);\\n            }\\n        }\\n    }\\n    \\n    let b=Math.max(...a);\\n\\n    if(b==-Infinity){\\n        return -1;\\n    }else{\\n         return b;\\n    }\\n   \\n\\n};"]}
{"id": "434", "ref_js": ["var construct2DArray = function(original, m, n) {\\n    var arr = []\\n    var l = 0\\n    if(m*n == original.length){\\n        for(i=0;i<m;i++){\\n            arr[i] = []\\n            for(j=0;j<n;j++){\\n                arr[i][j] = original[l++]\\n            }\\n        }\\n        return arr\\n    }else{\\n        return []\\n    }\\n};", "var construct2DArray = function (or, m, n) {\\n    if (m * n !== or.length) {\\n        return [];\\n    }\\n    let arr = [];\\n    for (let i = 0, x = 0; i < m; i++) {\\n        arr[i] = [];\\n        for (let j = 0; j < n; j++) {\\n            arr[i][j] = or[x++];\\n        }\\n    }\\n    return arr;\\n};", "var construct2DArray = function(original, m, n) {\\n    const len = original.length;\\n    const ans = [];\\n    if (m * n !== len) return ans;\\n    let v = [];\\n    let cnt = 0;\\n    for (let i = 0; i < len; i++) {\\n        v.push(original[i]);\\n        cnt++;\\n        if (cnt % n === 0 && v.length !== 0) {\\n            ans.push(v); \\n            v = [];\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "435", "ref_js": ["var minimumMoves = function(s) {\\n    let count = 0;\\n\\n    for(let i=0; i<s.length;i++){\\n        if(s[i] === \\'X\\'){\\n            count++;\\n            i += 2;\\n        }\\n    }\\n\\n    return count;\\n    \\n};", "var minimumMoves = function(s) {\\n    let count = 0;\\n  for(let i=0; i<s.length; i++){\\n      if(s[i] === \\'X\\'){\\n         count++;\\n         i+=2; \\n      }\\n  } \\n  return count; \\n};", "var minimumMoves = function(s) {\\n    let res = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"X\") {\\n            res++;\\n            i += 2;\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "436", "ref_js": ["var twoOutOfThree = function(nums1, nums2, nums3) {\\n    const result = [];\\n\\n    const addToResult = (num) => {\\n        if (!result.includes(num)) {\\n            result.push(num);\\n        }\\n    };", "var twoOutOfThree = function(nums1, nums2, nums3) {\\n    let arr=[]\\n    for(i=0;i<nums1.length;i++){\\nif(nums2.includes(nums1[i])||nums3.includes(nums1[i])){\\n    arr.push(nums1[i])\\n    }\\n    }\\n    for(i=0;i<nums2.length;i++){\\n        if(nums1.includes(nums2[i])||nums3.includes(nums2[i])){\\n            arr.push(nums2[i])\\n        }\\n    }\\narr = new Set(arr)\\narr = Array.from(arr)\\n    return arr\\n};", "var twoOutOfThree = function(nums1, nums2, nums3) {\\n\\t\\n    let num = [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)];\\n\\t\\n    let arr = [];\\n\\t\\n    let freq = _.countBy(num);\\n    \\n\\t\\n    let keys = Object.keys(freq);\\n\\t\\n\\t\\n    keys.forEach(key => {\\n        if(freq[key] >= 2){\\n            arr.push(key)\\n        }\\n    })\\n    return arr;\\n};"]}
{"id": "437", "ref_js": ["var minMovesToSeat = function(seats, students) {\\n   ", "var minMovesToSeat = function(seats, students) {\\n    let sum = 0\\n    seats=seats.sort((a,b)=>a-b)    \\n    students=students.sort((a,b)=>a-b)\\n    for(let i=0;i<seats.length;i++)\\n        sum+=Math.abs(seats[i]-students[i])\\n    return sum\\n};", "var minMovesToSeat = function(seats, students) {\\n    seats.sort((a, b) => { return a - b})\\n    students.sort((a, b) => { return a - b})\\n    return seats.reduce((a, b, i) => a += Math.abs(seats[i] - students[i]), 0)\\n};"]}
{"id": "438", "ref_js": ["var areNumbersAscending = function(s) {\\n    let numberOfArray = s.match(/\\\\d{1,2}/ig);\\n    let output;\\n    for(let i=0; i<numberOfArray.length; i++) {\\n        if(numberOfArray[i+1] - numberOfArray[i] <= 0){\\n            output = false;\\n            break;\\n        }\\n        else\\n            output = true;\\n    }\\n    return output;\\n};", "var areNumbersAscending = function(s) {\\n    let numberOfArray = s.match(/\\\\d{1,2}/ig);\\n    let output;\\n    for(let i=0; i<numberOfArray.length; i++) {\\n        if(numberOfArray[i+1] - numberOfArray[i] <= 0){\\n            output = false;\\n            break;\\n        }\\n        else\\n            output = true;\\n    }\\n    return output;\\n};", "var areNumbersAscending = function(s) {\\n    let numberOfArray = s.match(/\\\\d{1,2}/ig);\\n    let output;\\n    for(let i=0; i<numberOfArray.length; i++) {\\n        if(numberOfArray[i+1] - numberOfArray[i] <= 0){\\n            output = false;\\n            break;\\n        }\\n        else\\n            output = true;\\n    }\\n    return output;\\n};"]}
{"id": "439", "ref_js": ["var countValidWords = function(sentence) {\\n    let list = sentence.split(\\' \\')\\n    let filtered = list.filter(s => {\\n        if (/\\\\d/.test(s) || s === \\'\\') return false   ", "var countValidWords = function(sentence) {\\n    return sentence\\n                .split(/\\\\s+/)\\n                .filter(word=> word.match(/^[a-z]+(-[a-z]+)?[\\\\.!,]?$/) || word.match(/^[\\\\.!,]$/))\\n                .length \\n};", "var countValidWords = function(sentence) {\\n    return sentence\\n                .split(/\\\\s+/)\\n                .filter(word=> word.match(/^[a-z]+(-[a-z]+)?[\\\\.!,]?$/) || word.match(/^[\\\\.!,]$/))\\n                .length \\n};"]}
{"id": "440", "ref_js": ["var kthDistinct = function(arr, k) {\\n    return Object.entries(\\n                arr.reduce((acc, str) => {\\n                    acc[str] = acc[str] === undefined;\\n                    return acc;\\n                }, {})\\n            )\\n            .filter(([, isDistinct]) => isDistinct)[k - 1]?.[0] ?? \\'\\';\\n};", "var kthDistinct = function(arr, k) {\\n    const map = {} ", "var kthDistinct = function(arr, k) {\\n    let obj = {};"]}
{"id": "441", "ref_js": ["var smallestEqual = function(nums) {\\n    for(let i=0; i<nums.length; i++) {\\n        if(i%10 === nums[i]) return i\\n    }\\n    return -1\\n};", "var smallestEqual = function(nums) {\\n    for(let i=0;i<nums.length;i++){\\n        if(i%10==nums[i]) return i\\n    }\\n    return -1\\n};", "var smallestEqual = function(nums) {\\n    return nums.findIndex((n, i) => i % 10 === n)\\n};"]}
{"id": "442", "ref_js": ["var countVowelSubstrings = function(word) {\\n    ", "var isVowel = function(c) {\\n    return (c === \\'a\\' || c === \\'e\\' || c === \\'i\\' || c === \\'o\\' || c === \\'u\\');\\n}\\n\\nvar countVowelSubstrings = function(word) {\\n    let vowelMap = new Map();\\n    let total = 0;\\n    let totalLen = word.length - 1;\\n    for(let i = 0 ; i <= totalLen; i++){\\n        vowelMap.clear();\\n        for(let j = i; j <= totalLen && isVowel(word[j]); j++){\\n            vowelMap.set(word[j], (vowelMap.get(word[j]) ?? 0) + 1);\\n            if(vowelMap.size == 5)\\n                total++;\\n        }\\n    }\\n    return total;\\n};", "var countVowelSubstrings = function(word) {\\n    "]}
{"id": "443", "ref_js": ["var checkAlmostEquivalent = function(word1, word2) {\\n    const hash = {}\\n    for (let i = 0; i < word1.length; i++) {\\n        hash[word1[i]] = hash[word1[i]] ? hash[word1[i]] + 1 : 1 \\n        hash[word2[i]] = hash[word2[i]] ? hash[word2[i]] - 1: -1\\n    }\\n    for (const char in hash) {\\n        if (Math.abs(hash[char]) > 3) return false \\n    }\\n    return true\\n};", "var checkAlmostEquivalent = function(word1, word2) {\\n    const hm = new Map()\\n    const addToHm = (ch, add) => {\\n        if (hm.has(ch)) \\n            hm.set(ch, hm.get(ch) + (add ? +1 : -1))\\n        else \\n            hm.set(ch, (add ? +1 : -1))  \\n    }\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        addToHm(word1[i], true) \\n        addToHm(word2[i], false) \\n    }\\n    \\n    for (const val of hm.values())\\n        if (Math.abs(val) > 3)\\n\\t\\t\\treturn false\\n    \\n    return true\\n};", "var checkAlmostEquivalent = function(word1, word2) {\\n    const hash = {}\\n    for (let i = 0; i < word1.length; i++) {\\n        hash[word1[i]] = hash[word1[i]] ? hash[word1[i]] + 1 : 1 \\n        hash[word2[i]] = hash[word2[i]] ? hash[word2[i]] - 1: -1\\n    }\\n    for (const char in hash) {\\n        if (Math.abs(hash[char]) > 3) return false \\n    }\\n    return true\\n};"]}
{"id": "444", "ref_js": ["var timeRequiredToBuy = function(tickets, k) {\\n    ", "var timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};", "var timeRequiredToBuy = function(tickets, k) {\\n    "]}
{"id": "445", "ref_js": ["var maxDistance = function(colors) {\\n    let n = colors.length;\\n    let ans = 1;\\n    for(let i =0 ; i<colors.length; i++){\\n        if(colors[i] != colors[0])\\n            ans = Math.max(ans, i);\\n        if(colors[i] != colors[n-1])\\n            ans = Math.max(ans, n-1-i);\\n    }\\n    return ans;\\n};", "var maxDistance = function(colors) {\\n    ", "var maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (colors[i] !== colors[j]) {\\n                max = Math.max(max, j - i);\\n            }\\n        }\\n    }\\n    return max;\\n};"]}
{"id": "447", "ref_js": ["var countWords = function(words1, words2) {\\n    let count=0;\\n    for(let i=0;i<words1.length;i++){\\n        if(words1.indexOf(words1[i])==words1.lastIndexOf(words1[i]) && words2.indexOf(words1[i]) >=0 && words2.indexOf(words1[i])==words2.lastIndexOf(words1[i])){\\n            count++\\n        }\\n    }\\n    return count\\n};", "var countWords = function(words1, words2) {\\n    const map1 = new Map();\\n    const map2 = new Map();\\n    let count = 0;\\n    \\n    for (const word of words1) {\\n        map1.set(word, map1.get(word) + 1 || 1);\\n    }\\n    for (const word of words2) {\\n        map2.set(word, map2.get(word) + 1 || 1);\\n    }\\n    for (const word of words1) {\\n        if (map1.get(word) === 1 && map2.get(word) === 1) count++;\\n    }\\n    \\n    return count;\\n};", "var countWords = function (words1, words2) {\\n  "]}
{"id": "448", "ref_js": ["var targetIndices = function(nums, target) {\\n    let result = [];\\n\\n    nums.sort((a,b) => a-b).forEach((item, idx) => {\\n        if(item === target){\\n            result.push(idx);\\n        }\\n    })\\n    return result\\n};", "var targetIndices = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let ans = [];\\n        \\n    for (let i=0;i < nums.length;i++) {\\n        if (nums[i] === target) {\\n            ans.push(i);\\n        }\\n    }\\n    return ans;  \\n};", "var targetIndices = function(nums, target) {\\n    \\n    let res = []\\n    let minus = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i]<target){\\n            minus++;\\n        }\\n        if(nums[i]===target){\\n            res.push(0)\\n        }\\n    }\\n    return res.map((e, i)=>minus+i)\\n};"]}
{"id": "449", "ref_js": ["var findEvenNumbers = function(digits) {\\n    return Array.from(digits.reduce((acc, digit, i) => {\\n        if (digit % 2 === 0) {\\n            for (let j = 0; j < digits.length; j++) {\\n                if (j === i) {\\n                    continue;\\n                }\\n                for (let k = 0; k < digits.length; k++) {\\n                    if (k === i || k === j || digits[k] === 0) {\\n                        continue;\\n                    }\\n                    acc.add(Number(\\'\\' + digits[k] + digits[j] + digits[i]));\\n                }\\n            }\\n        }\\n        return acc;\\n    }, new Set())).sort((a, b) => a - b);\\n};", "var findEvenNumbers = function(digits) {\\n    let output = []\\n    let count = _.countBy(digits);\\n\\n    let aCompute, bCompute;\\n\\n    for (let a = 1; a < 10; a++) {\\n        aCompute = a*100;\\n        for (let b = 0; b < 10; b++) {\\n            bCompute = b*10;\\n            for (let c = 0; c < 9; c+=2) {\\n                if (count[a] && count[b] > (b==a) && count[c] > (c==a) + (c==b)) {\\n                    output.push(aCompute + bCompute + c)\\n                }\\n            }\\n        }\\n    }\\n                    \\n    return output\\n};", "var findEvenNumbers = function(digits) {\\n    arr = []\\n\\n    for (let i = 100; i <= 999; i++)       \\n        if (check_digits(i)) arr.push(i)    \\n\\n    return arr\\n\\n    function check_digits(n) {\\n        if (n % 2 != 0) return false\\n\\n        n = n.toString()\\n\\n        temp = digits.slice()\\n\\n        if (temp.indexOf(parseInt(n[0])) == -1) return false\\n        else temp.splice(temp.indexOf(parseInt(n[0])), 1)\\n        if (temp.indexOf(parseInt(n[1])) == -1) return false\\n        else temp.splice(temp.indexOf(parseInt(n[1])), 1)\\n        if (temp.indexOf(parseInt(n[2])) == -1) return false\\n        else temp.splice(temp.indexOf(parseInt(n[2])), 1)\\n        \\n        return true\\n    }\\n};"]}
{"id": "450", "ref_js": ["var maxSubsequence = function(nums, k) {\\n    let arr=[...nums]\\n    arr.sort((a,b)=>b-a)\\n    arr=arr.slice(0,k)\\n\\n    let subar=[] \\n   \\n    for(let i=0;i<nums.length && arr.length >0;i++){\\n        let index=arr.lastIndexOf(nums[i])\\n        \\n        if(index>=0){\\n            subar.push(nums[i])\\n            arr.splice(index,1)\\n        }\\n    }\\n    return subar\\n};", "var maxSubsequence = function(nums, k) {\\n    return nums.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]).slice(-k).sort((a,b)=>a[1]-b[1]).map(x=>x[0]);\\n};", "var maxSubsequence = function(nums, k) {\\n    return nums\\n        .map((num, i) => ({ index: i, num }))\\n        .sort(({ num: n1 }, { num: n2 }) => n2 - n1)\\n        .slice(0, k)\\n        .sort(({ index: i1 }, { index: i2 }) => i1 - i2)\\n        .map(({ num }) => num);\\n};"]}
{"id": "451", "ref_js": ["var countPoints = function(rings) {\\n    let hash = {};", "var countPoints = function(rings) {\\n    let rods = \\'0123456789\\';\\n    let count = 0;\\n    for (let rod of rods) { ", "var countPoints = function (rings) {\\n    let n = rings.length;\\n\\n    let map = new Map(); "]}
{"id": "452", "ref_js": ["var firstPalindrome = function(words) {\\n    for(let i=0;i<words.length;i++){\\n        let w=words[i]\\n        let n=w.slice(0,Math.floor(w.length/2))\\n        let j=w.slice(Math.ceil(w.length/2),w.length)\\n        if(n==j.split(\\'\\').reverse().join(\\'\\'))return w\\n    }\\n    return \\'\\'\\n};", "var firstPalindrome = function(words) {\\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        let isPalindromic = true;\\n        for (let j = 0; j < word.length/2; j++) {\\n            if (word[j] !== word[word.length - j - 1]) {\\n                isPalindromic = false;\\n                break;\\n            }\\n        }\\n        if (isPalindromic) return word;\\n    }\\n    return \\'\\';\\n};", "var firstPalindrome = function(words) {\\n    for(let i = 0; i < words.length; i++){\\n        let left = 0;\\n        let right = words[i].length-1;\\n        \\n        while(left <= right+1){\\n            if(words[i][left] !== words[i][right]){\\n                break\\n            }else if(left >= right){\\n                return words[i]\\n            }else{\\n                left++\\n                right--\\n            }\\n        }\\n    }\\n    return \"\"\\n};"]}
{"id": "453", "ref_js": ["var mostWordsFound = function(sentences) {\\n    let max = 0;\\n    let temp = 0;\\n    for (let i = 0; i < sentences.length; i++) {\\n        temp = sentences[i].split(\" \").length;\\n        if (temp > max) {\\n            max = temp;\\n        }\\n    }\\n    \\n    return max;\\n};", "var mostWordsFound = function(sentences) {\\n    let max = 0;\\n    let temp = 0;\\n    for (let i = 0; i < sentences.length; i++) {\\n        temp = sentences[i].split(\" \").length;\\n        if (temp > max) {\\n            max = temp;\\n        }\\n    }\\n    \\n    return max;\\n};", "var mostWordsFound = function(sentences) {\\n    let max = 0;\\n    let temp = 0;\\n    for (let i = 0; i < sentences.length; i++) {\\n        temp = sentences[i].split(\" \").length;\\n        if (temp > max) {\\n            max = temp;\\n        }\\n    }\\n    \\n    return max;\\n};"]}
{"id": "454", "ref_js": ["var isSameAfterReversals = function(num) {\\n     if(num == 0) return true;\\n    if(num % 10 == 0) return false;\\n     return true\\n};", "var isSameAfterReversals = function(num) {\\n    if(num == 0)    return true;\\n    if(num % 10 == 0)   return false;\\n    return true;\\n};", "var isSameAfterReversals = function(num) {\\n     if(num == 0) return true;\\n    if(num % 10 == 0) return false;\\n     return true\\n};"]}
{"id": "455", "ref_js": ["var checkString = function(s) {\\n    let ss=s.split(\\'\\').sort().join(\\'\\')\\n    return ss==s\\n};", "var checkString = function(s) {\\n    let flag=0;\\n    let res=0;\\n    for(let i=0;i<s.length;i++){\\n        if(s[i] == \"a\" && res==1){\\n            return false;\\n        }\\n        if(s[i]==\\'b\\'){\\n            flag=1;\\n            res=1;\\n        }\\n    }\\n    return true;\\n};", "var checkString = function(s) {\\n    let flag=0;\\n    let res=0;\\n    for(let i=0;i<s.length;i++){\\n        if(s[i] == \"a\" && res==1){\\n            return false;\\n        }\\n        if(s[i]==\\'b\\'){\\n            flag=1;\\n            res=1;\\n        }\\n    }\\n    return true;\\n};"]}
{"id": "456", "ref_js": ["var capitalizeTitle = function(title) {\\n    return title.split(\\' \\').map(item => item.length <= 2 ? item.toLowerCase() : `${item[0].toUpperCase()}${item.slice(1).toLowerCase()}`).join(\\' \\');\\n};", "var capitalizeTitle = function(title) {\\n    const data = title.split(\" \")\\n    \\n    data.map( (item, index) => {\\n       if(item.length > 2) {\\n           const value = item.toLowerCase()\\n           data[index] = value.charAt(0).toUpperCase() + value.slice(1);\\n       }else {\\n           data[index] = item.toLowerCase();\\n       }\\n    })\\n    \\n    return data.join(\" \")\\n};", "var capitalizeTitle = function(title) {\\n    const words = title.toLowerCase().split(\\' \\');\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].length > 2) {\\n            words[i] = words[i][0].toUpperCase() + words[i].slice(1);\\n        }\\n    }\\n    \\n    return words.join(\\' \\');\\n};"]}
{"id": "457", "ref_js": ["var checkValid = function(matrix) {\\n    if (!matrix.every(isValidArray)) return false;\\n\\n    for (let c = 0; c < matrix.length; c++) {\\n        const column = [];\\n        for (let r = 0; r < matrix.length; r++) {\\n            column.push(matrix[r][c]);\\n        }\\n        if (!isValidArray(column)) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};", "var checkValid = function (mat) {\\n    let R = mat.length;                                               ", "var checkValid = function(matrix) {\\n    if (!matrix.every(isValidArray)) return false;\\n\\n    for (let c = 0; c < matrix.length; c++) {\\n        const column = [];\\n        for (let r = 0; r < matrix.length; r++) {\\n            column.push(matrix[r][c]);\\n        }\\n        if (!isValidArray(column)) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};"]}
{"id": "458", "ref_js": ["var divideString = function(s, k, fill) {\\n    let arr=[]\\n    for(let i=0;i<s.length;i++){\\n        if(i+k<=s.length){\\n            arr.push(s.slice(i,i+k))\\n            i=i+k-1\\n        }\\n        else{\\n            let n=[]\\n            let temp=new Array(k-(s.length-i))\\n            n=[...s.slice(i,s.length),temp.fill(fill).join(\\'\\')]\\n            let m=n.join(\\'\\')\\n            arr.push(m)\\n            i=s.length\\n        }\\n    }\\n    return arr\\n};", "var divideString = function(s, k, fill) {\\n    const res = []\\n     let temp = \\'\\'\\n     let len = 0\\n     if(s.length % k === 0){\\n         len = s.length\\n    }else{\\n         len = s.length + k-(s.length%k)\\n     }\\n     for(let i= 0; i<len; i++){\\n         temp += s[i] || fill\\n         if(temp.length === k){\\n             res.push(temp)\\n             temp= \"\"\\n         }\\n     }\\n     return res\\n };", "var divideString = function(s, k, fill) \\n{\\n  var ans=[];\\n  for(let i=0;i<s.length;i+=k)\\n    {\\n      ans.push(s.substring(i,i+k));\\n    }\\n  let str=ans[ans.length-1];\\n  if(str.length==k)\\n    {\\n      return ans;\\n    }\\n  for(let i=str.length;i<k;i++)\\n    {\\n      ans[ans.length-1]+=fill;\\n    }\\n  return ans;\\n};"]}
{"id": "459", "ref_js": ["var minimumCost = function(cost) {\\n    cost.sort((a, b) => b - a);\\n\\n    let sum = 0;\\n\\n    for (let i = 0; i < cost.length; i += 3) {\\n        ", "var minimumCost = function(cost) {\\n    if (cost.length < 3) {\\n        return cost.reduce((prev, cur) => prev + cur);\\n    }\\n    \\n    cost.sort((a, b) => b - a);\\n    let count = 0;\\n    let sum = 0;\\n    \\n    for (const num of cost) {\\n        if (count === 2) {\\n            count = 0;\\n            continue;\\n        }\\n        sum += num;\\n        count++;\\n    }\\n    \\n    return sum;\\n};", "var minimumCost = function(cost) {\\n    if (cost.length < 3) {\\n        return cost.reduce((prev, cur) => prev + cur);\\n    }\\n    \\n    cost.sort((a, b) => b - a);\\n    let count = 0;\\n    let sum = 0;\\n    \\n    for (const num of cost) {\\n        if (count === 2) {\\n            count = 0;\\n            continue;\\n        }\\n        sum += num;\\n        count++;\\n    }\\n    \\n    return sum;\\n};"]}
{"id": "460", "ref_js": ["var countElements = function(nums) {\\n\\n  let min = Math.min(...nums)\\n  let max = Math.max(...nums)\\n  let count = 0;\\n  nums.forEach((item, index) => {\\n      if(item > min && item < max){\\n          count++;\\n      }\\n   })\\n  return count;\\n};", "var countElements = function(nums) {\\n   const max = Math.max(...nums);\\n   const min = Math.min(...nums);\\n   let count = 0;\\n   for(let i = 0 ; i< nums.length ; i++){\\n       if(nums[i] !== max && nums[i] !== min){\\n           count ++; \\n       }\\n   }\\n   return count;\\n};", "var countElements = function(nums) {\\n    const min = Math.min(...nums);\\n    const max = Math.max(...nums);\\n\\n    return nums.reduce((acc, num) => {\\n        if (num > min && num < max) {\\n            return acc + 1;\\n        }\\n        return acc;\\n    }, 0);\\n};"]}
{"id": "461", "ref_js": ["var findFinalValue = function(nums, original) {\\n    while (nums.includes(original)) {\\n        original *= 2;\\n    }\\n    return original;\\n};", "var findFinalValue = function(nums, original) {\\n    for(let i = 0;i<nums.length;i++){\\n        if(nums.includes(original)){\\n            original *= 2\\n        }else{\\n            return original\\n        }\\n    }\\n    return original\\n};", "var findFinalValue = function(nums, original) {\\n    for(let i = 0;i<nums.length;i++){\\n        if(nums.includes(original)){\\n            original *= 2\\n        }else{\\n            return original\\n        }\\n    }\\n    return original\\n};"]}
{"id": "462", "ref_js": ["var minimumSum = function (num) {\\n  let str = num.toString().split(\"\").sort();\\n  return parseInt(str[0] + str[2]) + parseInt(str[1] + str[3]);\\n};", "var minimumSum = function(num) {\\n    const temp=num.toString().split(\\'\\').sort();\\nreturn (parseInt(temp[0]+temp[2])+parseInt(temp[1]+temp[3]));\\n    \\n};", "var minimumSum = function(num) {\\n   let numbers = []\\n    for(let i = 0; i<4; i++){\\n        numbers.push(~~num % 10)\\n        num /= 10\\n    }\\n    const sorted = numbers.sort((a,b) => b - a)\\n    return sorted[0] + sorted[1] + (10 *( sorted[2] + sorted[3]))\\n};"]}
{"id": "463", "ref_js": ["var sortEvenOdd = function (nums) {\\nlet oddArr =[]\\nlet evenArr =[]\\nlet fianlArr =[]\\nfor(let j=0;j<nums.length;j++){\\n    \\n    if(j%2===0){\\n        evenArr.push(nums[j])\\n    }else{\\n        oddArr.push(nums[j])\\n    }\\n}\\n evenArr.sort((f, s) => f - s);\\n oddArr.sort((f, s) => s - f);\\n\\nfor(let i=0;i<nums.length/2;i++){\\nif (evenArr[i]) {\\nfianlArr.push(evenArr[i])\\n}\\nif (oddArr[i]) {\\n    fianlArr.push(oddArr[i])\\n}\\n\\n}\\nreturn fianlArr\\n};", "var sortEvenOdd = function(nums) {\\n\\nlet odd= nums.filter((num,i,arr)=> i%2!=0).sort((a,b)=> b-a);  ", "var sortEvenOdd = function (nums) {\\n    let odd = []\\n    let even = []\\n    let res = []\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2 === 1) {\\n            odd.push(nums[i])\\n        } else {\\n            even.push(nums[i])\\n        }\\n    }\\n\\n    odd = odd.sort((a, b) => b - a)\\n    even = even.sort((a, b) => a - b)\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2 === 1) {\\n            res.push(odd.shift())\\n        } else {\\n            res.push(even.shift())\\n        }\\n    }\\n\\n    return res\\n};"]}
{"id": "464", "ref_js": ["var countOperations = function(num1, num2) {\\n    let operations = 0;\\n    let reminder = null;\\n    let factorial = null;\\n    while (num1 !== 0 && num2 !== 0) {\\n        if (num1 < num2) {\\n            reminder = num2 % num1;\\n            factorial = parseInt(num2 / num1);\\n            operations += factorial;\\n            num2 = reminder;\\n        } else {\\n            reminder = num1 % num2;\\n            factorial = parseInt(num1 / num2);\\n            operations += factorial;\\n            num1 = reminder;\\n        }\\n    }\\n    return operations;\\n};", "var countOperations = function(num1, num2) {\\n  let count = 0;\\n  while (num1 && num2 !== 0) {\\n    num1 > num2 ? (num1 -= num2) : (num2 -= num1);\\n    count++;\\n  }\\n  return count;\\n};", "var countOperations = function(num1, num2) {\\n    let count = 0\\n    \\n    while(num1 !== 0 && num2 !== 0){\\n        if(num1 > num2) num1 -= num2 \\n        else num2 -= num1\\n        count++\\n    }\\n    \\n    return count\\n};"]}
{"id": "465", "ref_js": ["var countPairs = function(nums, k) {\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i]==nums[j]&&(i*j%k==0)){\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};", "var countPairs = function(nums, k) {\\nlet count = 0;\\n  const n = nums.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i + 1; j < n; j++) {\\n      if (nums[i] === nums[j] && (i * j) % k === 0) {\\n        count++;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};", "var countPairs = function(nums, k) {\\n    let count=0\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if((nums[i]==nums[j])&&((i*j)%k==0)&&(i!==j)){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};"]}
{"id": "466", "ref_js": ["var countEven = function(num) {\\n  let count = 0;\\n\\n  for(let i=2; i<=num; i++) {\\n    let temp = 0;\\n    let number = i\\n\\n    ", "var countEven = function (num) {\\n    let count = 0;\\n    for (let n = 1; n <= num; n++) {\\n        count += digitSum(n) % 2 === 0;\\n    }\\n    return count;\\n};", "var countEven = function(n) \\n{\\n  \\t  return n-(n/10&1^n/100&1^n/1000)>>1;  \\n};"]}
{"id": "467", "ref_js": ["var prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};", "var prefixCount = function(words, pref) {\\n  return(words.filter(e => e.startsWith(pref)).length);\\n};", "var prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};"]}
{"id": "468", "ref_js": ["var mostFrequent = function(nums, key) {\\n    res = {}, max = 0, ans = 0\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        target = nums[i+1]\\n        if (nums[i] == key) {\\n            res[target] = res[target] ? res[target] + 1 : 1\\n            if (res[target] > max) {\\n                max = res[target], ans = target\\n            }\\n        }\\n    }\\n\\n    return ans\\n\\n};", "var mostFrequent = function(nums, key) {\\n    let obj = {};", "var mostFrequent = function(nums, key) {\\n    let obj = {};"]}
{"id": "469", "ref_js": ["var cellsInRange = function (s) {\\n\\tlet parserResult = parser(s);\\n\\tlet firstLetter = parserResult[0];\\n\\tlet firstNum = parserResult[1];\\n\\tlet secondLetter = parserResult[2];\\n\\tlet secondNum = parserResult[3];\\n\\tlet alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'.toUpperCase();\\n\\tlet letters = alphabet.slice(alphabet.indexOf(firstLetter), alphabet.indexOf(secondLetter) + 1).split(\\'\\');\\n\\tlet result = [];\\n\\tletters.forEach(letter => {\\n\\t\\tfor (let num = firstNum; num < secondNum + 1; num++) {\\n\\t\\t\\tresult.push(letter + num);\\n\\t\\t}\\n\\t});\\n\\treturn result;\\n};", "var cellsInRange = function(s) {\\n    ", "var cellsInRange = function(s) {\\n    "]}
{"id": "470", "ref_js": ["var findKDistantIndices = function(nums, key, k) {\\n    const keyIndicies = nums.reduce((acc, num, i) => num === key ? [...acc, i] : acc, []);\\n    const res = [];\\n\\n    let lastIndex = 0;\\n    for (const index of keyIndicies) {\\n        const startIndex = Math.max(lastIndex, index - k);\\n        lastIndex = Math.min(index + k, nums.length - 1) + 1;\\n\\n        for (let i = startIndex; i < lastIndex; i++) {\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};", "var findKDistantIndices = function(nums, key, k) {\\n    let arr = [] ; \\n    for(let i = 0 ; i < nums.length ; ++i){\\n        for(let j = 0 ; j < nums.length ; ++j){\\n            if(Math.abs(i - j) <= k && nums[j] == key){\\n                arr.push(i) ; \\n            }\\n        }\\n    }\\n    arr = Array.from(new Set(arr)) ; \\n    return arr ; \\n};", "var findKDistantIndices = function(nums, key, k) {\\n    const indices = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) {\\n            indices.push(i);\\n        }\\n    }\\n\\n    const results = [];\\n\\n    "]}
{"id": "471", "ref_js": ["var divideArray = function(nums) {\\n  const numMap = new Map();\\n  for (const num of nums) {\\n    numMap.has(num) ? numMap.delete(num) : numMap.set(num, true);\\n  }\\n  return numMap.size === 0;\\n};", "var divideArray = function (nums) {\\n    nums = nums.sort((a, b) => a - b)\\n    console.log(nums)\\n    for (let i = 0; i < nums.length - 1; i = i + 2) {\\n        if (nums[i] !== nums[i + 1]) return false\\n    }\\n    return true\\n};", "var divideArray = function(nums) {\\n  return !nums.reduce((acc, cur) => (acc[cur]++, acc), new Uint16Array(501)).some(n => n % 2);\\n};"]}
{"id": "472", "ref_js": ["var countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};", "var countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); ", "var countHillValley = function(num) {\\n    let count=0;\\n        let nums = num.filter((value, index, self) => {\\n            return value !== self[index\\xA0+\\xA01];\\n        });\\n\\n        \\n      for(let i=1;i<nums.length;i++){\\n        nums[i]>nums[i-1] && nums[i]>nums[i+1] || nums[i]<nums[i-1] && nums[i]<nums[i+1]?count++:null\\n \\n        }\\n    return count\\n};"]}
{"id": "473", "ref_js": ["var findDifference = function(nums1, nums2) {\\n        let set1 = new Set(nums1);\\n        let set2 = new Set(nums2);\\n\\n        let diff1 = [...set1].filter(x => !set2.has(x));\\n        let diff2 = [...set2].filter(x => !set1.has(x));\\n\\n        return [diff1, diff2];\\n};", "var findDifference = function(nums1, nums2) {\\n    \\n    nums1 = new Set(nums1)\\n    nums2 = new Set(nums2)\\n\\n    for (let item of nums1){\\n        if (nums2.has(item)) {\\n            nums1.delete(item)\\n            nums2.delete(item)\\n        }\\n    }\\n    return [Array.from(nums1),Array.from(nums2)]\\n   \\n};", "var findDifference = function(nums1, nums2) {\\n        let set1 = new Set(nums1);\\n        let set2 = new Set(nums2);\\n\\n        let diff1 = [...set1].filter(x => !set2.has(x));\\n        let diff2 = [...set2].filter(x => !set1.has(x));\\n\\n        return [diff1, diff2];\\n};"]}
{"id": "474", "ref_js": ["var minBitFlips = function(start, goal) {\\n\\n    return (start^goal).toString(2).replace(/0/g,\"\").length\\n};", "var minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};", "var minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};"]}
{"id": "475", "ref_js": ["var convertTime = function(current, correct) {\\n    ", "var convertTime = function(current, correct) {\\n    ", "var convertTime = function(current, correct) {\\n    "]}
{"id": "476", "ref_js": ["var largestInteger = function(num) {\\n\\n    let answer = \\'\\';\\n    const sorted = [...String(num)].sort((a, b) => a - b);\\n\\n    const odd = sorted.filter((i) => i % 2 === 1);\\n    const even = sorted.filter((i) => i % 2 === 0);\\n    \\n    for (let i = 0; i < sorted.length; i++) {\\n        if (String(num)[i] % 2 === 0) {\\n            answer += even.pop();\\n        } else {\\n            answer += odd.pop();\\n        }\\n    }\\n\\n    return answer;\\n};", "var largestInteger = function(num) {\\n  let numArr = num.toString().split(\\'\\').map(d => Number(d))\\n\\n  let oddQ = new MaxPriorityQueue({\\n    compare: (a, b) => (a < b)\\n  })\\n  \\n  let evenQ = new MaxPriorityQueue({\\n    compare: (a, b) => (a < b)\\n  })\\n\\n  numArr.forEach(value => {\\n    if (value % 2 === 0) {\\n      evenQ.enqueue(value)\\n    } else {\\n      oddQ.enqueue(value)\\n    }\\n  })\\n  \\n  let resArr = []\\n\\n  for (let n of numArr) {\\n    if (n % 2 === 0) {\\n      resArr.push(evenQ.dequeue())\\n    } else {\\n      resArr.push(oddQ.dequeue())\\n    }\\n  }\\n\\n  return resArr.reduce((prev, curr) => \\'\\' + prev + curr)\\n};", "var largestInteger = function(num) {\\n    const odd = [];\\n    const even = [];\\n    const nums = String(num).split(\\'\\')\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0) even.push(parseInt(nums[i]))\\n        else odd.push(parseInt(nums[i]))\\n    }\\n    \\n    odd.sort((a,b) => a-b)\\n    even.sort((a,b) => a-b)\\n    \\n    const largestNum = [];\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0) largestNum.push(even.pop())\\n        else largestNum.push(odd.pop())\\n    }\\n\\n    return largestNum.join(\\'\\')\\n};"]}
{"id": "477", "ref_js": ["var sum = function(num1, num2) {\\n    return num1+num2\\n    \\n};", "var sum = function(num1, num2) {\\n    return num1+num2;\\n};", "var sum = function(num1, num2) {\\n    return num1+num2\\n    \\n};"]}
{"id": "478", "ref_js": ["var gcdOfStrings = function(str1, str2) {\\n    \\n  if(str1 + str2 != str2 + str1){\\n      return \"\";\\n  } else if(str1 == str2){\\n      return str1;\\n  } else if(str1.length > str2.length){\\n      return gcdOfStrings(str1.substring(str2.length), str2);\\n  } else{\\n          return gcdOfStrings(str2.substring(str1.length), str1)\\n      }  \\n};", "var gcdOfStrings = function(str1, str2) {\\n    \\n    if (str1 + str2 !== str2 + str1) {\\n\\n        return \"\";\\n    }\\n\\n    let n = str1.length;\\n\\n    let k = str2.length;\\n\\n    let gcds = function (x, y) {\\n        \\n        if (!y) {\\n            return x;\\n        }\\n        return gcds(y, x % y);\\n    }\\n\\n    let div = gcds (n, k);\\n\\n    return str1.slice(0, div);\\n};", "var gcdOfStrings = function(str1, str2) {\\n    if(str1 + str2 != str2 + str1) return \\'\\';\\n \\n    let isValidate = (w,str) =>{\\n        if(str.length == 0) return true;\\n        if(!str.startsWith(w)) return false;\\n        return isValidate(w,str.slice(w.length))\\n    }\\n\\n    let res = \\'\\'\\n\\n    for(let i = 1; i<=str1.length; i++){\\n        let curV = str1.slice(0,i)\\n        if(isValidate(curV,str2) && isValidate(curV,str1)) res = curV;\\n    }\\n\\n    return res;\\n};"]}
{"id": "479", "ref_js": ["var findClosestNumber = function(nums) {\\n    let res = Number.MAX_VALUE;\\n    for (let i of nums) {\\n        if (Math.abs(i) < Math.abs(res) || i === Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n};", "var findClosestNumber = function(nums) {\\n    return nums.reduce((acc, num) => Math.abs(num) < Math.abs(acc)\\n        ? num\\n        : Math.abs(num) === Math.abs(acc)\\n            ? Math.max(num, acc)\\n            : acc,\\n    );\\n};", "var findClosestNumber = function(nums) {\\n    \\n    let closest = nums[0];\\n    let closestAbs = Math.abs(nums[0]);\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        \\n        let number = nums[i];\\n        let absNumber = Math.abs(number);\\n        \\n        if (number == 0)\\n            return 0;\\n        \\n        if (absNumber <= closestAbs) {\\n            \\n            if (absNumber < closestAbs) {\\n                \\n                closest = number;\\n                closestAbs = absNumber\\n                \\n            } else {\\n                \\n                if (closest < number) {\\n                    \\n                    closest = number;\\n                    closestAbs = absNumber\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return closest;\\n    \\n};"]}
{"id": "480", "ref_js": ["var digitSum = function(s, k) {\\n    while (s.length > k) {\\n        let newString = \"\";\\n        for (let i = 0; i < s.length; i += k)\\n            newString += s.substring(i, i + k).split(\"\").reduce((acc, val) => acc + (+val), 0);\\n        \\n        s = newString;\\n    }\\n    \\n    return s;\\n};", "var digitSum = function(s, k) {\\n    while (s.length > k) {\\n        let newString = \"\";\\n        for (let i = 0; i < s.length; i += k)\\n            newString += s.substring(i, i + k).split(\"\").reduce((acc, val) => acc + (+val), 0);\\n        \\n        s = newString;\\n    }\\n    \\n    return s;\\n};", "var digitSum = function(s, k) {\\n    while (s.length > k) {\\n        let newString = \"\";\\n        for (let i = 0; i < s.length; i += k)\\n            newString += s.substring(i, i + k).split(\"\").reduce((acc, val) => acc + (+val), 0);\\n        \\n        s = newString;\\n    }\\n    \\n    return s;\\n};"]}
{"id": "481", "ref_js": ["var intersection = function (nums) {\\n  const result = [];\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    if (nums.every((x) => x.includes(nums[0][i]))) {\\n      result.push(nums[0][i]);\\n    }\\n  }\\n\\n  return result.sort((a, b) => a - b);\\n};", "var intersection = function (nums) {\\n  const result = [];\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    if (nums.every((x) => x.includes(nums[0][i]))) {\\n      result.push(nums[0][i]);\\n    }\\n  }\\n\\n  return result.sort((a, b) => a - b);\\n};", "var intersection = function (nums) {\\n  const result = [];\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    if (nums.every((x) => x.includes(nums[0][i]))) {\\n      result.push(nums[0][i]);\\n    }\\n  }\\n\\n  return result.sort((a, b) => a - b);\\n};"]}
{"id": "482", "ref_js": ["var countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};", "var countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};", "var countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};"]}
{"id": "483", "ref_js": ["var removeDigit = function(number, digit) {\\n  let largestNum = 0n; \\n\\n  for (let ind = 0; ind < number.length; ind++) {\\n    if (number[ind] === digit) {\\n      const numString = number.substring(0, ind) + number.substring(ind + 1); \\n      const num = BigInt(numString); \\n      if (num > largestNum) largestNum = num; \\n    }\\n  }\\n\\n  return largestNum.toString();\\n};", "var removeDigit = function(number, digit) {\\n    \\n    let str = [];\\n    let flag = 0;\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] == digit ) {\\n            let temp = number.substring(0, i) + number.substring(i+1);\\n            str.push(temp);\\n        }\\n    }\\n    \\n    str.sort();\\n    return str[str.length-1];\\n};", "var removeDigit = function (number, digit) {\\n    let max = 0n;\\n\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] === digit) {\\n            let jukto = number.substring(0, i) + number.substring(i + 1);         \\n            if(max < BigInt(jukto)){\\n                max = jukto\\n            }\\n        }\\n    }\\n    return max.toString();\\n};"]}
{"id": "484", "ref_js": ["var largestGoodInteger = function(num) {\\n    let com;\\n    let left = 0;\\n    let right = 0;\\n\\n    for (let i = 0; i < num.length - 2; i++) {\\n        if (num[i] === num[i + 1] && num[i + 1] === num[i + 2]) {\\n            if (!com || com <= num[i]) {\\n                left = i;\\n                right = i + 2;\\n                com = num[i];\\n            }\\n        }\\n    }\\n\\n    if (com !== undefined) {\\n        return num.substring(left, right + 1);\\n    }\\n\\n    return \"\";\\n};", "var largestGoodInteger = function(num) {\\n    ", "var largestGoodInteger = function(num) {\\n    let result = -1;\\n    for (let i = 0; i + 2 < num.length; i++) {\\n        if (num[i] === num[i + 1] && num[i] === num[i + 2]) {\\n            result = Math.max(result, parseInt(num[i]));\\n        }\\n    }\\n    return (result === -1) ? \"\" : String(result).repeat(3);\\n};"]}
{"id": "485", "ref_js": ["var divisorSubstrings = function(num, k) {\\n\\n    let numArray =  num.toString().split(\"\")\\n    let k_interval = \"\";\\n    let ris = 0;\\n\\n    for (i = 0; i < numArray.length; i++) {\\n      k_interval = k_interval + numArray[i]\\n      if (i >= k - 1) {\\n        if (num % parseInt(k_interval) === 0){ris++}\\n        k_interval = k_interval.slice(1);\\n      }\\n\\n    }\\n    \\n    return ris;\\n  };", "var divisorSubstrings = function(num, k) {\\n\\n    num = num.toString();\\n    let subStr, ctr=0; \\n    for(let p=0; p<= num.length-k ; p++){\\n        subStr = num.slice(p, p+k);\\n        if(num%subStr === 0 ){\\n            ctr++;\\n        }\\n    }\\n\\n    return ctr;\\n};", "var divisorSubstrings = function(num, k) {\\n    let count = 0;\\n    "]}
{"id": "486", "ref_js": ["var removeAnagrams = function (words) {\\n  for (let i = 1; i < words.length;) {\\n    const countWord = words[i].split(\\'\\').sort().join()\\n    const prevWord = words[i - 1].split(\\'\\').sort().join()\\n\\n    countWord === prevWord ? words.splice(i, 1) : i++\\n  }\\n\\n  return words\\n};", "var removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};", "var removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};"]}
{"id": "487", "ref_js": ["var percentageLetter = function(s, letter) {\\n    let reg = new RegExp(letter, \"g\");\\n    let countReg = s.match(reg);\\n\\n    if(countReg === null) \\n        return(0);\\n    else\\n        return(Math.floor((countReg.length / s.length) * 100));\\n};", "var percentageLetter = function(s, letter) {\\n    const count= s.split(\\'\\').reduce((a,c)=>{\\n        if(c==letter) a++\\n        return a\\n    },0)\\n    return Math.floor((count/s.length)*100)\\n};", "var percentageLetter = function(s, letter) {\\n    let reg = new RegExp(letter, \"g\");\\n    let countReg = s.match(reg);\\n\\n    if(countReg === null) \\n        return(0);\\n    else\\n        return(Math.floor((countReg.length / s.length) * 100));\\n};"]}
{"id": "488", "ref_js": ["var digitCount = function(num) {\\n\\n    if(num==0){\\n        return false\\n    }else if(num==21200||num==2020){\\n        return true\\n    }\\n\\n    for(let i=0;i<num.length;i++){\\n            let count=0;\\n        for(let j=0;j<num.length;j++){\\n            if(i==num[j]&&i!=j){\\n                count++\\n            }\\n        }\\n        if(count!=num[i]){\\n            return false\\n        }\\n        \\n    }\\n    return true\\n    \\n};", "var digitCount = function(num) {\\n    let map = new Map();\\n    \\n  \\n    for( let i = 0; i < num.length; i++) {\\n    let count = 0\\n     for(let j = 0; j < num.length; j++) {\\n         if(i.toString() === num[j]){\\n             count++\\n            }\\n        }\\n        map.set(i,count)\\n        \\n        if(map.get(i) != num[i]) {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};", "var digitCount = function(num) {\\n    const arr= Array(num.length).fill(0)\\n    for(let elem of num){\\n        arr[elem]++\\n    }\\n    return arr.join(\\'\\') == num\\n};"]}
{"id": "489", "ref_js": ["var rearrangeCharacters = function(s, target) {\\n    let cnt = Number.MAX_VALUE;\\n\\n    let m1 = new Map();\\n    for(const x of target) m1.set(x , m1.get(x)+1 || 1);\\n\\n    let m2 = new Map();\\n    for(const x of s) m2.set(x , m2.get(x)+1 || 1);\\n\\n    for(let it of m1){\\n        let ch = it[0];\\n        let x = it[1];\\n        let y = m2.get(ch);\\n        if(y === undefined) y=0;\\n        cnt = Math.min(cnt,Math.floor(y/x));\\n    }\\n    return cnt;\\n};", "var rearrangeCharacters = function(s, target) {\\n    let min=s.length\\n    for(let l of target){\\n        let re = new RegExp(l, \\'g\\')\\n        min=Math.min(min,Math.trunc((s.match(re)?.length || 0)/target.match(re).length))\\n    }\\n    return min\\n};", "var rearrangeCharacters = function(s, target) {\\n    let min = 0 ;\\n    const sourceHash = {}\\n    const targetHash = {}\\n    for(let i = 0; i< target.length; i++) {\\n        targetHash[target[i]] = targetHash[target[i]] ?? 0\\n        targetHash[target[i]]++\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n        if(target.includes(s[i])) {\\n            sourceHash[s[i]] = sourceHash[s[i]] ?? 0\\n            sourceHash[s[i]]++\\n        }\\n    }\\n        \\n     for(let i = 0; i< target.length; i++) {\\n        const charNeed = targetHash[target[i]];\\n        const charHad = sourceHash[target[i]];\\n        if(charHad === undefined) {\\n            min = 0;\\n            break;\\n        }\\n        const canHas = Math.floor(charHad / charNeed)\\n        if(min === 0 || canHas < min) {\\n            min = canHas\\n        }\\n     }\\n    return min;\\n};"]}
{"id": "490", "ref_js": ["var minMaxGame = function(nums) {\\n  if(nums.length===1) return nums;\\n  let newNums = [];\\n  let flag = true;\\n  for(let i=0;i<nums.length;i=i+2){ ", "var minMaxGame = function(nums) {\\n    while (nums.length > 1) {\\n        let half = nums.length / 2;\\n        for (let i = 0; i < half; i++)\\n            nums[i] = i % 2 === 0 ? Math.min(nums[2 * i], nums[2 * i + 1]) : Math.max(nums[2 * i], nums[2 * i + 1]);\\n        \\n        nums.length = half;\\n    }\\n    \\n    return nums[0];\\n};", "var minMaxGame = function(nums) {\\n  if(nums.length===1) return nums;\\n  let newNums = [];\\n  let flag = true;\\n  for(let i=0;i<nums.length;i=i+2){ "]}
{"id": "491", "ref_js": ["var strongPasswordCheckerII = function(password) {\\n    const regex = /^(?=.*[0-9])(?!.*(.)\\\\1+)(?=.*[!-\\\\/:-@[-`{-~])(?=.*[A-Z])(?=.*[a-z])[a-zA-Z\\\\d!-\\\\/:-@[-`{-~]{8,}/g\\n    return regex.test(password)\\n};", "var strongPasswordCheckerII = function(password) {\\n    const strong = /^(?=.*\\\\d)(?=.*[!@#$%^&*)(+-])(?=.*[a-z])(?=.*[A-Z])(?!.*([A-Za-z0-9!@#$%^&*)(+-])\\\\1).{8,}$/;\\n    return strong.test(password);\\n};", "var strongPasswordCheckerII = function(password) {\\n    const strong = /^(?=.*\\\\d)(?=.*[!@#$%^&*)(+-])(?=.*[a-z])(?=.*[A-Z])(?!.*([A-Za-z0-9!@#$%^&*)(+-])\\\\1).{8,}$/;\\n    return strong.test(password);\\n};"]}
{"id": "492", "ref_js": ["var calculateTax = function(brackets, income) {\\n  let totalTax = 0;\\n  let previous = 0;\\n  for(let [upper, percent] of brackets) {\\n    if (upper > income) {\\n      upper = income;\\n    }\\n    const taxableIncome = upper - previous;\\n    previous = upper;\\n    if (taxableIncome > 0) {\\n      const tax = (taxableIncome * (percent / 100));\\n      totalTax += tax;\\n    }\\n  }\\n  return totalTax;\\n};", "var calculateTax = function(brackets, income) {\\n    let tax=0,lower=0;\\n    for(let i=0;i<brackets.length;i++){\\n        let [upper,percent] = brackets[i];\\n        if (income<=upper-lower){\\n            tax += income*percent/100;\\n            break;\\n        }\\n        tax += (upper-lower)*percent/100;\\n        income -= upper-lower;\\n        lower = upper;\\n    }\\n    return tax;\\n};", "var calculateTax = function(brackets, income) {\\n  let totalTax = 0;\\n  let previous = 0;\\n  for(let [upper, percent] of brackets) {\\n    if (upper > income) {\\n      upper = income;\\n    }\\n    const taxableIncome = upper - previous;\\n    previous = upper;\\n    if (taxableIncome > 0) {\\n      const tax = (taxableIncome * (percent / 100));\\n      totalTax += tax;\\n    }\\n  }\\n  return totalTax;\\n};"]}
{"id": "493", "ref_js": ["var greatestLetter = function (s) {\\n  let uc = { ...Array(26).fill(0) }, lc = { ...Array(26).fill(0) };", "var greatestLetter = function(s) {\\n    let set=new Set(s.split(\"\"));\\n\\t", "var greatestLetter = function(s) {\\n    let sorted = s.split(\"\").sort();\\n    let i = sorted.length-1\\n    console.log(i)\\n    while (i>=0 && sorted[i].toLowerCase()==sorted[i]) {\\n        let char = sorted[i].toUpperCase()\\n        if (sorted.includes(char)) {\\n            return char.toString()\\n        }\\n        console.log(i)\\n        i--\\n    } return \"\"\\n};"]}
{"id": "494", "ref_js": ["var countAsterisks = function(s) {\\n    let green=true, count=0;\\n    for(let i=0; i<s.length; i++){\\n        if(green && s[i]==\"*\"){count++};", "var countAsterisks = function(s) {\\n    let pair=0, count=0;\\n    for(let c of s){\\n        if(c == \\'|\\')    pair++;\\n        if(pair % 2 == 0 && c == \\'*\\')    count++;\\n    }\\n    return count;\\n};", "var countAsterisks = function(s) {\\n    let pair=0, count=0;\\n    for(let c of s){\\n        if(c == \\'|\\')    pair++;\\n        if(pair % 2 == 0 && c == \\'*\\')    count++;\\n    }\\n    return count;\\n};"]}
{"id": "495", "ref_js": ["var checkXMatrix = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        if (grid[i][i] === 0 || grid[i][grid[i].length - i - 1] === 0) {\\n            return false;\\n        }\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] !== 0 && j !== i && j !== (grid[i].length - i - 1)) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n\\n};", "var checkXMatrix = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        if (grid[i][i] === 0 || grid[i][grid[i].length - i - 1] === 0) {\\n            return false;\\n        }\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] !== 0 && j !== i && j !== (grid[i].length - i - 1)) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n\\n};", "var checkXMatrix = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        if (grid[i][i] === 0 || grid[i][grid[i].length - i - 1] === 0) {\\n            return false;\\n        }\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] !== 0 && j !== i && j !== (grid[i].length - i - 1)) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n\\n};"]}
{"id": "496", "ref_js": ["var decodeMessage = function (key, message) {\\n\\tkey = convertKey(key);\\n\\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n\\tlet result = \"\";\\n\\tfor (const letter of message) {\\n\\t\\tlet index = key.indexOf(letter);\\n\\t\\tif (index === -1) result += \\' \\';\\n\\t\\telse result += alphabet[index];\\n\\t}\\n\\treturn result;\\n};", "var decodeMessage = function(key, message) {\\n  let result = \\'\\'\\n  key = Array.from(new Set(key.split(\\' \\').join(\\'\\')))\\n  const hash = new Map()\\n  const alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n  \\n  for (let i = 0; i < alpha.length; i++) {\\n    hash.set(key[i], alpha[i])\\n  }\\n\\n  for (let chr of message) {\\n    result += hash.get(chr) || \\' \\'\\n  }\\n    \\n  return result\\n};", "var decodeMessage = function (key, message) {\\n\\tkey = convertKey(key);\\n\\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n\\tlet result = \"\";\\n\\tfor (const letter of message) {\\n\\t\\tlet index = key.indexOf(letter);\\n\\t\\tif (index === -1) result += \\' \\';\\n\\t\\telse result += alphabet[index];\\n\\t}\\n\\treturn result;\\n};"]}
{"id": "497", "ref_js": ["var evaluateTree = function (root) {\\n  const dfs = (node) => {\\n    if (!node) return;\\n    if (node.val === 0) return false;\\n    if (node.val === 1) return true;\\n\\n    if (node.val === 2) {\\n      return dfs(node.left) || dfs(node.right);\\n    } else if (node.val === 3) {\\n      return dfs(node.left) && dfs(node.right);\\n    }\\n  };", "var evaluateTree = function (root) {\\n  const dfs = (node) => {\\n    if (!node) return;\\n    if (node.val === 0) return false;\\n    if (node.val === 1) return true;\\n\\n    if (node.val === 2) {\\n      return dfs(node.left) || dfs(node.right);\\n    } else if (node.val === 3) {\\n      return dfs(node.left) && dfs(node.right);\\n    }\\n  };", "var evaluateTree = function (root) {\\n  const dfs = (node) => {\\n    if (!node) return;\\n    if (node.val === 0) return false;\\n    if (node.val === 1) return true;\\n\\n    if (node.val === 2) {\\n      return dfs(node.left) || dfs(node.right);\\n    } else if (node.val === 3) {\\n      return dfs(node.left) && dfs(node.right);\\n    }\\n  };"]}
{"id": "498", "ref_js": ["var fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    amount.push(Math.floor((sum + 1) / 2));\\n    return Math.max.apply(Math, amount);\\n};", "var fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    amount.push(Math.floor((sum + 1) / 2));\\n    return Math.max.apply(Math, amount);\\n};", "var fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    amount.push(Math.floor((sum + 1) / 2));\\n    return Math.max.apply(Math, amount);\\n};"]}
{"id": "499", "ref_js": ["var numberOfPairs = function(nums) {\\n    const map = {};", "var numberOfPairs = function (nums) {\\n    let numsMap = new Map()\\n    let pairCount = 0;\\n    let leftover = 0\\n\\n    ", "var numberOfPairs = function(nums) {\\n    let pairs = 0\\n    \\n    let map = {};"]}
{"id": "500", "ref_js": ["var bestHand = function(rank, st) \\n{\\n    let list={};", "var bestHand = function(ranks, suits) {\\n  if (new Set(suits).size === 1) return \"Flush\";\\n  const counts = ranks.reduce((acc, cur) => (acc[cur]++, acc), new Uint8Array(14));\\n  const max = Math.max(...counts);\\n  return max > 2 ? \"Three of a Kind\" : max > 1 ? \"Pair\" : \"High Card\";\\n};", "var bestHand = function(ranks, suits) {\\n    if (suits.every(suit => suit === suits[0])) {\\n        return \"Flush\";\\n    }\\n    const ranksMap = ranks.reduce((acc, rank) => {\\n        acc[rank] = (acc[rank] ?? 0) + 1;\\n        return acc;\\n    }, {});\\n    const maxTheSameRank = Math.max(...Object.values(ranksMap));\\n    if (maxTheSameRank >= 3) {\\n        return \"Three of a Kind\";\\n    }\\n    if (maxTheSameRank >= 2) {\\n        return \"Pair\";\\n    }\\n    return \"High Card\";\\n};"]}
{"id": "501", "ref_js": ["var repeatedCharacter = function(s) {\\n    let seen = new Set();\\n    for (let a of s) {\\n        if (seen.has(a)) return a;\\n        else seen.add(a);\\n    }\\n    return \\'\\';\\n};", "var repeatedCharacter = function(s) {\\n    let seen = new Set();\\n    for (let a of s) {\\n        if (seen.has(a)) return a;\\n        else seen.add(a);\\n    }\\n    return \\'\\';\\n};", "var repeatedCharacter = function(s) {\\n    let seen = new Set();\\n    for (let a of s) {\\n        if (seen.has(a)) return a;\\n        else seen.add(a);\\n    }\\n    return \\'\\';\\n};"]}
{"id": "503", "ref_js": ["var minimumOperations = function(nums) {\\n    nums.sort((a,b)=>a-b);\\n    let count = 0;\\n    let sum = 0;\\n    for(let i=0;i<nums.length;i++){\\n        ", "var minimumOperations = function(nums) {\\n    ", "var minimumOperations = function(nums) {\\n    let count=0\\n    while(nums.find(v=>v>0)){\\n    const small =nums.reduce((a,c)=>{if(c<=a && c>0)a=c;return a},Math.max(...nums))\\n    nums=nums.map(v=>{if(v>0) v-=small ; return v})\\n    count++\\n    }\\n    return count\\n};"]}
{"id": "504", "ref_js": ["var mergeSimilarItems = function(items1, items2) {\\n    const m1 = new Map(items1.map(([value, weight]) => [value, weight]));\\n    const ret = [];\\n\\n    for (const [value, weight] of items2) {\\n        if (!m1.has(value)) {\\n        m1.set(value, weight);\\n        } else {\\n        m1.set(value, m1.get(value) + weight);\\n        }\\n    }\\n\\n    for (const [value, weight] of m1.entries()) {\\n        ret.push([value, weight]);\\n    }\\n\\n    ret.sort((a, b) => a[0] - b[0]); ", "var mergeSimilarItems = function(items1, items2) {\\n    items1.sort(([v1], [v2]) => v1 - v2);\\n    items2.sort(([v1], [v2]) => v1 - v2);\\n\\n    let i = 0;\\n    let j = 0;\\n    const res = [];\\n\\n    while (i < items1.length && j < items2.length) {\\n        const [v1, w1] = items1[i];\\n        const [v2, w2] = items2[j];\\n\\n        if (v1 === v2) {\\n            res.push([v1, w1 + w2]);\\n            i++;\\n            j++;\\n        } else if (v1 < v2) {\\n            res.push([v1, w1]);\\n            i++;\\n        } else {\\n            res.push([v2, w2]);\\n            j++;\\n        }\\n    }\\n    while (i < items1.length) {\\n        res.push(items1[i]);\\n        i++;\\n    }\\n    while (j < items2.length) {\\n        res.push(items2[j]);\\n        j++;\\n    }\\n\\n    return res;\\n};", "var mergeSimilarItems = function(items1, items2) {\\n    map = new Map()\\n\\n    for (item of items1) {\\n        map.set(item[0], item[1])\\n    }\\n\\n    for (item of items2) {\\n        if (map.get(item[0]) != undefined) \\n            map.set(item[0], item[1] + map.get(item[0]))\\n        else \\n            map.set(item[0], item[1])\\n    }    \\n\\n    return [...map].sort((a, b) => a[0] - b[0])    \\n};"]}
{"id": "505", "ref_js": ["var arithmeticTriplets = function (nums, diff) {\\n  let count = 0;\\n\\n  for (let j = 1; j < nums.length - 1; j++) {\\n    for (let i = 0; i < j; i++) {\\n      for (let k = j + 1; k < nums.length; k++) {\\n        if (nums[j] - nums[i] === diff && nums[k] - nums[j] === diff) count++;\\n      }\\n    }\\n  }\\n  \\n  return count++;\\n};", "var arithmeticTriplets = function (nums, diff) {\\n  let count = 0;\\n\\n  for (let j = 1; j < nums.length - 1; j++) {\\n    for (let i = 0; i < j; i++) {\\n      for (let k = j + 1; k < nums.length; k++) {\\n        if (nums[j] - nums[i] === diff && nums[k] - nums[j] === diff) count++;\\n      }\\n    }\\n  }\\n  \\n  return count++;\\n};", "var arithmeticTriplets = function (nums, diff) {\\n  let count = 0;\\n\\n  for (let j = 1; j < nums.length - 1; j++) {\\n    for (let i = 0; i < j; i++) {\\n      for (let k = j + 1; k < nums.length; k++) {\\n        if (nums[j] - nums[i] === diff && nums[k] - nums[j] === diff) count++;\\n      }\\n    }\\n  }\\n  \\n  return count++;\\n};"]}
{"id": "506", "ref_js": ["var largestLocal = function(grid) {\\n    const len = grid.length;\\n    const res = [];\\n\\n    for (let i = 1; i < len - 1; i++) {\\n        const row = [];\\n        for (let j = 1; j < len - 1; j++) {\\n            ", "var largestLocal = function(grid) {\\n    ", "var largestLocal = function(grid, count = 2) {\\n    let n = grid.length\\n    let arr = []\\n    for(let i=0; i<n-1; i++)    arr[i] = []\\n    for(let i=0; i<arr.length; i++){\\n        for(let j=0; j<arr.length; j++){\\n            arr[i][j] = Math.max(grid[i][j], Math.max(grid[i][j+1], Math.max(grid[i+1][j], grid[i+1][j+1])))\\n        }\\n    }\\n    return --count == 0 ? arr : largestLocal(arr, count)\\n};"]}
{"id": "507", "ref_js": ["var minimumRecolors = function (blocks, k) {\\n    let min = Infinity;\\n    let start = 0;\\n    let currentMin = 0;\\n    for (let end = 0; end < blocks.length; end++) {\\n        if (blocks[end] === \\'W\\') currentMin++;\\n        if (end - start + 1 == k) {\\n            min = Math.min(currentMin, min);\\n            if (blocks[start++] === \\'W\\') {\\n                currentMin--\\n            }\\n        }\\n    }\\n\\n    return min;\\n};", "var minimumRecolors = function(blocks, k) {\\n    let min_count = Number.MAX_VALUE\\n    for(let i=0; i<blocks.length; i++){\\n        let black_count = 0, count = 0\\n        for(let j=i; j<blocks.length; j++){\\n            if(blocks.charAt(j) == \\'B\\') black_count++\\n            else{\\n                black_count++\\n                count++\\n            }\\n            if(black_count == k){\\n                min_count = Math.min(min_count, count)\\n                break\\n            }\\n        }\\n    }\\n    return min_count\\n};", "var minimumRecolors = function(blocks, k) {\\n    const WHITE = \\'W\\';\\n    let min = k;\\n    let current = 0;\\n    let start = 0;\\n\\n    for (let end = 0; end < blocks.length; end++) {\\n        if (blocks[end] === WHITE) {\\n            current++;\\n        }\\n\\n        if (end + 1 >= k) {\\n            min = Math.min(min, current);\\n\\n            if (blocks[start++] === WHITE) {\\n                current--;\\n            }\\n        }\\n    }\\n\\n    return min;\\n};"]}
{"id": "508", "ref_js": ["var minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let count = 0\\n    for (let i=0; i<energy.length; i++) {\\n        if (energy[i]>=initialEnergy) {\\n            count+=energy[i]-initialEnergy+1\\n            initialEnergy = 1\\n        } else {\\n            initialEnergy -= energy[i]\\n        } \\n        if (experience[i]<initialExperience) {\\n            initialExperience += experience[i]\\n        } else {\\n            count+=experience[i]-initialExperience+1\\n            initialExperience += experience[i]+experience[i]-initialExperience+1       \\n        }\\n       \\n    }\\n    return count\\n};", "var minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    var hours = 0\\n    for(let i =0;i<energy.length;i++){\\n        \\n        while(initialEnergy<=energy[i]){\\n            initialEnergy++\\n            hours++\\n        }\\n        while(initialExperience<=experience[i]){\\n            initialExperience++\\n            hours++\\n        }\\n        initialEnergy -= energy[i]\\n        initialExperience += experience[i]\\n    }\\n    return hours\\n};", "var minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let trainingHours = 0;\\n    let currentEnergy = initialEnergy;\\n    let currentExperience = initialExperience;\\n\\n    for (let i = 0; i < energy.length; i++) {\\n        while (currentEnergy <= energy[i] || currentExperience <= experience[i]) {\\n            "]}
{"id": "509", "ref_js": ["var answerQueries = function(nums, queries) {\\n    nums.sort((a,b) => a-b)\\n    let arr = []\\n    for(let query of queries){\\n        let count = 0, sum=0\\n        for(let i=0; i<nums.length; i++){\\n            if(sum + nums[i] <= query){\\n                sum += nums[i]\\n                count++\\n            }\\n        }\\n        arr.push(count)\\n    }\\n    return arr\\n};", "var answerQueries = function(nums, queries) {\\n    nums = nums.sort((a, b) => a-b);\\n    const output = [];\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        const target = queries[i];\\n        let sum = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            sum += nums[j];\\n            if (sum > target) {\\n                output.push(j)\\n                break;\\n            }\\n        }\\n        if (output[i] === undefined) output.push(nums.length);\\n    }\\n\\n    return output;\\n};", "var answerQueries = function(nums, queries) {\\n    nums.sort((a, b) => a - b); "]}
{"id": "510", "ref_js": ["var findSubarrays = function(nums) {\\n    const sumSet = new Set();\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const sum = nums[i] + nums[i + 1];\\n\\n        if (sumSet.has(sum)) {\\n            return true;\\n        }\\n\\n        sumSet.add(sum);\\n    }\\n\\n    return false;\\n};", "var findSubarrays = function (nums) {\\n  const set = new Set();\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (set.has(nums[i] + nums[i + 1])) {\\n      return true;\\n    }\\n    set.add(nums[i] + nums[i + 1]);\\n  }\\n\\n  return false;\\n};", "var findSubarrays = function(nums) {\\n    const sumSet = new Set();\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const sum = nums[i] + nums[i + 1];\\n\\n        if (sumSet.has(sum)) {\\n            return true;\\n        }\\n\\n        sumSet.add(sum);\\n    }\\n\\n    return false;\\n};"]}
{"id": "511", "ref_js": ["var checkDistances = function(s, distance) {\\n    let arr = Array(26).fill(0)\\n    for(let i=0; i<s.length; i++){\\n        if(arr[s.charCodeAt(i) - 97] != 0 && i - arr[s.charCodeAt(i) - 97] != distance[s.charCodeAt(i) - 97])    \\n            return false\\n        arr[s.charCodeAt(i) - 97] = i+1\\n    }\\n    return true\\n};", "var checkDistances = function(s, distance) {\\n    const firstIndex = Array(26).fill(-1);\\n\\t\\n\\tfor(let index = 0; index < s.length; index++) {\\n\\t\\tconst charCode = s[index].charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\t\\t\\n\\t\\tif(firstIndex[charCode] !== -1)\\n\\t\\t\\tif(index - firstIndex[charCode] - 1 !== distance[charCode])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tfirstIndex[charCode] = index;\\n\\t}\\n\\t\\n\\treturn true;\\n};", "var checkDistances = function(s, distance) {\\n    const firstIndex = Array(26).fill(-1);\\n\\t\\n\\tfor(let index = 0; index < s.length; index++) {\\n\\t\\tconst charCode = s[index].charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\t\\t\\n\\t\\tif(firstIndex[charCode] !== -1)\\n\\t\\t\\tif(index - firstIndex[charCode] - 1 !== distance[charCode])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tfirstIndex[charCode] = index;\\n\\t}\\n\\t\\n\\treturn true;\\n};"]}
{"id": "512", "ref_js": ["var mostFrequentEven = function(nums) {\\n    return Number(\\n        Object.entries(\\n            nums.reduce((acc, num) => {\\n                if (num % 2 === 0) {\\n                    acc[num] = (acc[num] ?? 0) + 1;\\n                }\\n\\n                return acc;\\n            }, {}),\\n        ).sort(([num1, fr1], [num2, fr2]) => {\\n            if (fr1 !== fr2) {\\n                return fr2 - fr1;\\n            }\\n\\n            return num1 - num2;\\n        })[0]?.[0] ?? -1,\\n    );\\n};", "var mostFrequentEven = function(nums) {\\n    let map = {};", "var mostFrequentEven = function(nums) {\\n    let map = {};"]}
{"id": "513", "ref_js": ["var countDaysTogether = function(aa, la, ab, lb) {\\n    let arr = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        let sa = parseInt(aa.slice(0,2)) , sb = parseInt(ab.slice(0,2));\\n        let sda=parseInt(aa.slice(3)) , sdb = parseInt(ab.slice(3));\\n        \\n        let ea = parseInt(la.slice(0,2)) , eb = parseInt(lb.slice(0,2));\\n        let eda=parseInt(la.slice(3)) , edb = parseInt(lb.slice(3));\\n        let ans = 0;\\n        if(sa > eb || sb > eb || (eb == sa && sda > edb) || (ea == sb && sdb > eda)){\\n            return 0;\\n        }\\n        if(Math.max(sa,sb) == Math.min(ea,eb)){\\n            if(sb>sa || (sb==sa && sdb >= sda)){\\n                if(ea < eb || (ea==eb && eda <= edb)){\\n                    ans = eda - sdb + 1;\\n                }else{\\n                    ans = edb - sdb + 1;\\n                }\\n            }else{\\n                if(ea < eb || (ea==eb && eda <= edb)){\\n                    ans = eda - sda + 1;\\n                }else{\\n                    ans = edb - sda + 1;\\n                }\\n            }\\n        }\\n        else if(Math.max(sa,sb) > Math.min(ea,eb)){\\n            return 0;\\n        }\\n        else{\\n            for(let i = Math.max(sa,sb)+1 ; i < Math.min(ea,eb) ;i++){\\n                ans += arr[i];\\n                \\n            }\\n            \\n            if(sb>sa  || (sb==sa && sdb >= sda)){\\n                ans += arr[sb] - sdb+1;\\n            }else{\\n                ans += arr[sa] - sda+1;\\n            }\\n            \\n            if(ea < eb || (ea == eb && eda <= edb)){\\n                ans += eda;\\n            }else {\\n                ans += edb;\\n            }\\n        }\\n        return ans;\\n};", "var countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    let startDate = new Date(arriveBob);\\n    let endDate = new Date(leaveBob);\\n    if(new Date(arriveAlice)>new Date(arriveBob)) startDate = new Date(arriveAlice);\\n    if(new Date(leaveBob)>new Date(leaveAlice)) endDate = new Date(leaveAlice);\\n    if(endDate<startDate) return 0;\\n    const diffTime = Math.abs(endDate - startDate);\\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); \\n    return diffDays+1;\\n};", "var countDaysTogether = function(aa, la, ab, lb) {\\n    let arr = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        let sa = parseInt(aa.slice(0,2)) , sb = parseInt(ab.slice(0,2));\\n        let sda=parseInt(aa.slice(3)) , sdb = parseInt(ab.slice(3));\\n        \\n        let ea = parseInt(la.slice(0,2)) , eb = parseInt(lb.slice(0,2));\\n        let eda=parseInt(la.slice(3)) , edb = parseInt(lb.slice(3));\\n        let ans = 0;\\n        if(sa > eb || sb > eb || (eb == sa && sda > edb) || (ea == sb && sdb > eda)){\\n            return 0;\\n        }\\n        if(Math.max(sa,sb) == Math.min(ea,eb)){\\n            if(sb>sa || (sb==sa && sdb >= sda)){\\n                if(ea < eb || (ea==eb && eda <= edb)){\\n                    ans = eda - sdb + 1;\\n                }else{\\n                    ans = edb - sdb + 1;\\n                }\\n            }else{\\n                if(ea < eb || (ea==eb && eda <= edb)){\\n                    ans = eda - sda + 1;\\n                }else{\\n                    ans = edb - sda + 1;\\n                }\\n            }\\n        }\\n        else if(Math.max(sa,sb) > Math.min(ea,eb)){\\n            return 0;\\n        }\\n        else{\\n            for(let i = Math.max(sa,sb)+1 ; i < Math.min(ea,eb) ;i++){\\n                ans += arr[i];\\n                \\n            }\\n            \\n            if(sb>sa  || (sb==sa && sdb >= sda)){\\n                ans += arr[sb] - sdb+1;\\n            }else{\\n                ans += arr[sa] - sda+1;\\n            }\\n            \\n            if(ea < eb || (ea == eb && eda <= edb)){\\n                ans += eda;\\n            }else {\\n                ans += edb;\\n            }\\n        }\\n        return ans;\\n};"]}
{"id": "514", "ref_js": ["var smallestEvenMultiple = function(n) {\\n    return n%2 == 0 ? n: n*2;\\n};", "var smallestEvenMultiple = function(n) {\\n   \\n    return n%2==0 ?n:n*2\\n\\n};", "var smallestEvenMultiple = function(n) {\\n\\n    if (n%2 !== 0 )\\n    {\\n        return n*2;\\n    }\\n    else\\n    {\\n        return n;\\n    }\\n    \\n};"]}
{"id": "515", "ref_js": ["var sortPeople = function (names, heights) {\\n  return names.map((item, i) => [item, heights[i]])\\n    .sort((a, b) => b[1] - a[1])\\n    .map(item => item[0])\\n};", "var sortPeople = function (names, heights) {\\n    const heightArray = [...heights];\\n    const newArr = heights.slice().sort((a, b) => b - a);\\n    let res = [];\\n    \\n    for (let i = 0; i < names.length; i++) {\\n        res[i] = names[heightArray.indexOf(newArr[i])];\\n    }\\n\\n    return res;\\n};", "var sortPeople = function(names, heights) {\\n    const heightMap=new Map()\\n    for(let i=0; i<names.length ;i++){\\n        heightMap.set(heights[i],names[i])\\n    }\\n    \\n    return [...heightMap.entries()].sort((a,b)=>b[0]-a[0]).map(v=>v[1])\\n};"]}
{"id": "516", "ref_js": ["var equalFrequency = function (word, cnt = {}) {\\n  for (let w of word) {cnt[w] = (cnt[w] || 0) + 1;}\\n  for (let k in cnt) {\\n    const newCnt = Object.assign({}, cnt);\\n    if (--newCnt[k] === 0) delete newCnt[k];\\n    if (new Set([...Object.values(newCnt)]).size === 1) return true;}\\n  return false;\\n};", "var equalFrequency = function(word) {\\n  let test = false;\\n  let tab=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n  let tab2=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n  let alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n  let min = -1;\\n  let max = -1;\\n  let x=0;\\n  let y=0;\\n\\n  let testmin = true;\\n  let testmax = true;\\n\\n\\n\\n  for(let i=0 ; i<alpha.length;i++)\\n  {\\n    tab[i] = word.split(alpha[i]).length - 1\\n    tab2[i] = word.split(alpha[i]).length - 1\\n    if (tab[i] != 0)\\n    {\\nmin=tab[i];\\nmax = tab[i];\\n    }\\n  }\\n\\n\\n  for(let i=0 ; i<tab.length;i++)\\n  {\\n     \\n   if (min>tab[i] && tab[i]>0)\\n   {\\n     min = tab[i]\\n   }\\n    if (max<tab[i] && tab[i]>0)\\n   {\\n     max = tab[i]\\n   }\\n  }\\n\\n\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n    if(tab[i]==min)\\n    {\\n      tab[i]--\\n      \\n      break;\\n    }\\n  }\\n\\n  for(let i=0 ; i<tab2.length;i++)\\n  {\\n    if(tab2[i]==max)\\n    {\\n      tab2[i]--\\n     \\n      break;\\n    }\\n  }\\n\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n    if(tab[i]!=0)\\n    {\\n     x=tab[i]\\n     \\n     break;\\n    }\\n  }\\n\\n  for(let i=0 ; i<tab2.length;i++)\\n  {\\n    if(tab2[i]==min)\\n    {\\n     y=tab2[i];\\n    \\n     break;\\n    }\\n  }\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n\\n    \\n    if(tab[i]!=x && tab[i]!=0)\\n    {\\n      \\n     testmin = false;\\n    }\\n  }\\n\\nfor(let i=0 ; i<tab2.length;i++)\\n  {\\n    \\n    if(tab2[i]!=y  && tab2[i]!=0)\\n    {\\n     \\n     testmax = false;\\n    }\\n  }\\n\\n\\nreturn testmin || testmax\\n};", "var equalFrequency = function(word) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        const character = word[i];\\n        if (hashmap.has(character)) {\\n            hashmap.set(character, hashmap.get(character) + 1);\\n        } else {\\n            hashmap.set(character, 1);\\n        }\\n    }\\n    let output = false;\\n    hashmap.forEach((value, key) => {\\n        const newMap = new Map(hashmap);\\n        if (value === 1) {\\n            newMap.delete(key)\\n        } else {\\n            newMap.set(key, newMap.get(key) - 1);\\n        }\\n        if (new Set([...newMap.values()]).size === 1) output = true;\\n    })\\n    return output;\\n};"]}
{"id": "517", "ref_js": ["var commonFactors = function (a, b) {\\n    let aFactors = new Set()\\n    let count = 0\\n\\n    for (let i = 1; i <= a; i++) {\\n        if (a % i === 0) aFactors.add(i)\\n    }\\n    for (let j = 1; j <= b; j++) {\\n        if (aFactors.has(b / j)) count++\\n    }\\n\\n    return count\\n};", "var commonFactors = function (a, b) {\\n  let count = 0;\\n  if (a !== b) { ", "var commonFactors = function (a, b) {\\n    let aFactors = new Set()\\n    let count = 0\\n\\n    for (let i = 1; i <= a; i++) {\\n        if (a % i === 0) aFactors.add(i)\\n    }\\n    for (let j = 1; j <= b; j++) {\\n        if (aFactors.has(b / j)) count++\\n    }\\n\\n    return count\\n};"]}
{"id": "518", "ref_js": ["var hardestWorker = function(n, logs) {\\n    let max_val = logs[0][1], id = logs[0][0];\\n    for(let i=1; i<logs.length; i++){\\n        let time_req = logs[i][1] - logs[i-1][1];\\n        if(time_req >= max_val){\\n            if(time_req == max_val){\\n                id = Math.min(id, logs[i][0]);\\n            }else{\\n                max_val = time_req;\\n                id = logs[i][0];\\n            }\\n        }\\n    }\\n    return id;\\n};", "var hardestWorker = function(n, logs) {\\n    let tempI = -1;\\n    let tempTime = 0;\\n\\n    let prevStart = 0;\\n    for (const [i, start] of logs) {\\n        const length = start - prevStart;\\n        if (length === tempTime) {\\n            tempI = Math.min(tempI, i);\\n        } else if (length > tempTime) {\\n            tempI = i;\\n            tempTime = length;\\n        }\\n        prevStart = start;\\n    }\\n\\n    return tempI;\\n};", "var hardestWorker = function(n, logs) {\\n    let highestTaskCompletionTime = 0\\n    let employeeId = 0\\n    \\n    let previousTaskCompletion = 0\\n    \\n    for ( task of logs) {\\n        const taskCompletionTime = task[1] - previousTaskCompletion\\n        \\n        if(taskCompletionTime > highestTaskCompletionTime) {\\n            highestTaskCompletionTime = taskCompletionTime\\n            employeeId = task[0]\\n        }\\n        \\n        if(taskCompletionTime === highestTaskCompletionTime && task[0] < employeeId) {\\n            employeeId = task[0]\\n        }\\n        \\n        previousTaskCompletion = task[1]\\n    }\\n    \\n    return employeeId\\n};"]}
{"id": "519", "ref_js": ["var countTime = function(time) {\\n    let arr = time.split(\":\").join(\"\");\\n    let base = [2, 10, 6, 10];\\n    let valid = 1;\\n    let i = 0;\\n    \\n    ", "var countTime = function(time) {\\n  let hrChoices = 1;\\n  if (time[0] == \\'?\\' && time[1] == \\'?\\') {\\n    hrChoices = 24;\\n  } else if (time[0] == \\'?\\') {\\n    hrChoices = time[1] <= \\'3\\' ? 3 : 2;\\n  } else if (time[1] == \\'?\\') {\\n    hrChoices = time[0] == \\'2\\' ? 4 : 10;\\n  }\\n\\n  let minChoices = 1\\n\\n  if (time[3] == \\'?\\' && time[4] == \\'?\\') {\\n    minChoices = 60;\\n  } else if (time[3] == \\'?\\') {\\n    minChoices = 6;\\n  } else if (time[4] == \\'?\\') {\\n    minChoices = 10;\\n  }\\n\\n  return hrChoices * minChoices;\\n};", "var countTime = function(time) {\\n    let [hours,minutes] = time.split(\\':\\');\\n    let result = [];\\n    if(hours == \\'??\\') result.push(24);\\n    else{\\n        if(hours[0] == \\'?\\'){\\n            hours[1]>3?result.push(2):result.push(3)\\n        } \\n        if(hours[1] == \\'?\\'){\\n            hours[0]==2?result.push(4):result.push(10) \\n        }   \\n    }\\n    if(minutes[0] == \\'?\\'){\\n        result.push(6)\\n    } \\n    if(minutes[1] == \\'?\\'){\\n        result.push(10) \\n    }\\n    return result.reduce((a,b)=>a*b,1);\\n};"]}
{"id": "520", "ref_js": ["var findMaxK = function(nums) {\\n\\n    let arr = [-1];\\n\\n    for(let i=0; i<nums.length; i++){\\n        for(let j=i+1 ; j<nums.length; j++){\\n            if(nums[i]===-nums[j]) arr.push(Math.abs(nums[j]))\\n        }\\n    }\\n    \\n    return Math.max(...arr);\\n};", "var findMaxK = function(nums) {\\n\\n    const max = Math.max(...nums)\\n    const negMax = -max\\n\\n    if(max < 0){\\n        return -1\\n    }\\n\\n    if(nums.includes(negMax)){\\n        return max\\n    }else{\\n        for(let i=0; i<nums.length; i++){\\n            if(nums[i] === max){\\n                nums.splice(i,1);\\n                return findMaxK(nums)\\n            }\\n        }\\n    }\\n     \\n};", "var findMaxK = function(nums) {\\n    res=-1\\n    let seen=new Set()\\n    for(const num of nums){\\n        if(seen.has(-num)){\\n            res=Math.max(res,Math.abs(num))\\n        }\\n        seen.add(num)\\n    }\\n   \\n    return res\\n    \\n};"]}
{"id": "521", "ref_js": ["var haveConflict = function(event1, event2) {\\n    if(event1[1] < event2[0]) return false;\\n    if(event2[0] <= event1[1] && event2[1] >= event1[0]) return true;\\n    return false;\\n};", "var haveConflict = function(event1, event2) {\\n    return (event1[0] <= event2[0] && event2[0] <= event1[1])\\n        || (event1[0] <= event2[1] && event2[1] <= event1[1])\\n        || (event2[0] <= event1[0] && event1[0] <= event2[1])\\n        || (event2[0] <= event1[1] && event1[1] <= event2[1]);\\n};", "var haveConflict = function(event1, event2) {\\n    return (event1[0] <= event2[0] && event2[0] <= event1[1])\\n        || (event1[0] <= event2[1] && event2[1] <= event1[1])\\n        || (event2[0] <= event1[0] && event1[0] <= event2[1])\\n        || (event2[0] <= event1[1] && event1[1] <= event2[1]);\\n};"]}
{"id": "522", "ref_js": ["var oddString = function(words) {\\n    const map = {};", "var oddString = function(words) {\\n    let hash = {}\\n    for(let i=0 ; i<words.length ; i++){\\n        let diff = \"\"\\n        for(let j=0; j<words[i].length-1 ; j++ ){\\n            diff = diff + \".\" + String(words[i].charCodeAt(j+1)- words[i].charCodeAt(j))\\n        }\\n        if(hash[diff]) hash[diff].push(i)\\n        else hash[diff]=  [i]\\n    }\\n   for (const [key, value] of Object.entries(hash)) {\\n    if(value.length ===1) return words[value[0]]\\n}\\n};", "var oddString = function(words) {\\n    let hashMap = {};"]}
{"id": "523", "ref_js": ["var averageValue = function(nums) {\\n    \\n    ", "var averageValue = function(nums) {\\nnums = nums.filter(a => a % 6 ===0)\\nreturn nums.length ? parseInt(nums.reduce((a,b) => a + b )/ nums.length) : 0\\n};", "var averageValue = function(nums) {\\n    \\n    "]}
{"id": "524", "ref_js": ["var applyOperations = function(nums) {\\n        for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] == nums[i + 1]) {\\n            nums[i] = nums[i] * 2;\\n            nums[i + 1] = 0\\n        }\\n    }\\n    let lastNonZeroAt = 0; \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] != 0) {\\n            nums[lastNonZeroAt++] = nums[i];\\n        }\\n    }\\n    for (let i = lastNonZeroAt; i < nums.length; i++) {\\n        nums[i] = 0;\\n    }\\n    return nums\\n};", "var applyOperations = function(nums) {\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i + 1] && nums[i] == nums[i + 1]) {\\n            nums[i] = nums[i] * 2;\\n            nums[i + 1] = 0;\\n        }\\n    }\\n\\n    const zeros = nums.filter((el) => el === 0);\\n    const notZeros = nums.filter((el) => el !== 0);\\n\\n    return notZeros.concat(zeros);\\n};", "var applyOperations = function(nums) {\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i + 1] && nums[i] == nums[i + 1]) {\\n            nums[i] = nums[i] * 2;\\n            nums[i + 1] = 0;\\n        }\\n    }\\n\\n    const zeros = nums.filter((el) => el === 0);\\n    const notZeros = nums.filter((el) => el !== 0);\\n\\n    return notZeros.concat(zeros);\\n};"]}
{"id": "525", "ref_js": ["var distinctAverages = function(nums) {\\n    nums = nums.sort((a, b) => a - b);\\n    let s = new Set();\\n    let len = nums.length, i = 0;\\n    while(i < len) {\\n        let del = (nums[i] + nums[len - 1 - i]) / 2;\\n        s.add(del);\\n        ++i;\\n    }\\n    return s.size;\\n};", "var distinctAverages = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    const set = new Set();\\n    for (let i = 0; i < nums.length / 2; i++) {\\n        set.add(nums[i] + nums.at(-(i + 1)));\\n    }\\n    return set.size;\\n};", "var distinctAverages = function(nums) {\\n    "]}
{"id": "526", "ref_js": ["var convertTemperature = function(celsius) {\\n    return [(celsius + 273.15),(celsius * 1.80 + 32.00)]\\n};", "var convertTemperature = function(celsius) {\\n    const k = celsius + 273.15;\\n    const f = celsius * 1.8 + 32;\\n    return [k.toFixed(5), f.toFixed (5)];\\n};", "var convertTemperature = function(celsius) {\\n    return [(celsius + 273.15),(celsius * 1.80 + 32.00)]\\n};"]}
{"id": "527", "ref_js": ["var unequalTriplets = function(nums) {\\n    n = nums.length\\n    res = 0\\n    \\n    for (let i = 0; i < n - 2; i++)\\n        for (let j = i + 1; j < n - 1; j++)\\n            for (let k = j + 1; k < n; k++)\\n                if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    res++\\n    \\n    return res\\n};", "var unequalTriplets = function(nums) {\\n    let count = 0;\\n    for(let i=0;i<nums.length ;i++){\\n       for(let j=i+1 ;j<nums.length ;j++){\\n           for(let k=j+1;k<nums.length;k++){\\n             if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                 count++;\\n             }\\n           }\\n       }\\n    }\\n    return count;\\n};", "var unequalTriplets = function(nums) {\\n    let count = 0,\\n        prev = 0,\\n        nxt = nums.length;\\n    let frequencies = nums.reduce((count, currentValue) => {\\n        return (count[currentValue] ? ++count[currentValue] : (count[currentValue] = 1), count);\\n    }, {});\\n    \\n    for (freq of Object.values(frequencies)) {\\n        nxt -= freq;\\n        count += (prev * freq * nxt);\\n        prev += freq\\n    }\\n    return count\\n};"]}
{"id": "528", "ref_js": ["var numberOfCuts = function (n) {\\n    return n == 1 ? 0 : n % 2 == 0 ? n / 2 : n;\\n};", "var numberOfCuts = function(n) {\\n    \\n    if(n==1){\\n        return 0;\\n    }\\n    \\n    if(n%2==0){\\n        return n/2;\\n    }\\n    else{\\n        return n;\\n    }\\n};", "var numberOfCuts = function(n) {\\n    if(n===1){\\n        return 0\\n    }\\n    if(n%2!==0){\\n        return n\\n    }else{\\n        return n/2\\n    }\\n\\n    \\n};"]}
{"id": "529", "ref_js": ["var pivotInteger = function(n) {\\n    let son = Math.sqrt((n*n+n)/2)\\n    if (parseInt(son) == son)\\n        return son;\\n    return -1;\\n};", "var pivotInteger = function (n) {\\n    ", "var pivotInteger = function (n) {\\n    "]}
{"id": "530", "ref_js": ["var isCircularSentence = function(sentence) {\\n\\tfor(let i = 0; i < sentence.length; i++){\\n        if(sentence[i] === \\' \\'){\\n            if(sentence[i - 1] !== sentence[i + 1])\\n                return false;\\n        }\\n    }\\n    return sentence[0] === sentence[sentence.length - 1]\\n}\\n", "var isCircularSentence = function(sentence) {\\n    for (let i = 0; i < sentence.length; i++) {\\n        if (sentence[i] === \\' \\') {\\n            if (sentence[i - 1] !== sentence[i + 1]) {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return sentence[0] === sentence[sentence.length - 1];\\n};", "var isCircularSentence = function(sentence) {\\n    return sentence.match(/(\\\\w)( \\\\1)+/g)?.length === sentence.match(/ (\\\\w )*/g)?.length && sentence[0] === sentence[sentence.length - 1]\\n};"]}
{"id": "531", "ref_js": ["var maximumValue = function(strs) {\\n    let result = 0;\\n    const regex = /^\\\\d+$/;\\n\\n    for (let i = 0; i < strs.length; ++i) {\\n        result = Math.max(result, regex.test(strs[i]) ? +strs[i] : strs[i].length);\\n    }\\n\\n    return result;\\n};", "var maximumValue = function(strs) {\\n    return Math.max(...strs.map((str) => Number.isInteger(+str) ? +str : str.length))\\n};", "var maximumValue = function (strs) {\\n  return Math.max(...strs.map((x) => (isNaN(+x) ? x.length : +x)));\\n};"]}
{"id": "532", "ref_js": ["var deleteGreatestValue = function (grid) {\\n    answer = 0\\n    for (var i = 0; grid[0].length !== 0; i++) {\\n        let rowArr = []\\n        for (var i = 0; i < grid.length; i++) {\\n            var maxInRow = Math.max(...grid[i])\\n            var index = grid[i].indexOf(maxInRow)\\n            rowArr.push(maxInRow)\\n\\n            grid[i].splice(index, 1)\\n        }\\n\\n        let max = Math.max(...rowArr)\\n        answer += max\\n    }\\n    return answer\\n};", "var deleteGreatestValue = function (grid) {\\n    grid.forEach(row => row.sort((a, b) => a - b))\\n    let sum = 0\\n\\n    while (grid[0].length) {\\n        let column = []\\n        for (let row of grid) column.push(row.pop())\\n        sum += Math.max(...column)\\n    }\\n\\n    return sum\\n};", "var deleteGreatestValue = function(grid) {\\n  let sum = 0, idx = 0  \\n  for (let i = 0; i < grid.length; i++) {\\n    grid[i].sort((a,b) => b - a)\\n  }\\n\\n  while (idx < grid[0].length) {\\n    let max = -Infinity\\n    for (let i = 0; i < grid.length; i++) {      \\n        max = Math.max(grid[i][idx], max)\\n    }\\n\\n    idx++\\n    sum+=max\\n  } \\n\\n  return sum\\n};"]}
{"id": "533", "ref_js": ["var similarPairs = function(words) {\\n  let count = new Map(), ans = 0;\\n  for (let word of words) {\\n    let mask = getMask(word);\\n    let occurances = count.get(mask) || 0;\\n    ans += occurances;\\n    count.set(mask, occurances + 1);\\n  }\\n  return ans;\\n};", "var similarPairs = function (words) {\\n  let result = 0;\\n\\n  for (let i = 0; i < words.length; i++) {\\n    for (let j = 0; j < words.length; j++) {\\n      let firstWord = [...new Set(words[i])]\\n        .sort((a, b) => (a > b ? 1 : -1))\\n        .join(\"\");\\n      let secondWord = [...new Set(words[j])]\\n        .sort((a, b) => (a > b ? 1 : -1))\\n        .join(\"\");\\n      if (i !== j && firstWord === secondWord) {\\n        result++;\\n      }\\n    }\\n  }\\n\\n  return result / 2;\\n};", "var similarPairs = function(words) {\\n  let count = 0;\\n  for (let i = 0; i < words.length; i++) {\\n    for (let j = i + 1; j < words.length; j++) {\\n      if (sameCharacters(words[i], words[j]) && i !== j) {\\n        count++;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};"]}
{"id": "534", "ref_js": ["var captureForts = function (forts) {\\n  ", "var captureForts = function(forts) {\\n    let max = 0, prev = 0;\\n    forts.forEach((fort, idx) => {\\n        if (fort) {\\n            if (forts[prev] &&  fort != forts[prev]) {\\n                max = Math.max(max, (idx - prev - 1))\\n            }\\n            prev = idx;\\n        }\\n    })\\n    return max;\\n};", "var captureForts = function(forts) {\\n    a = -1, b = -1, max = 1\\n\\n    for (let i = 0; i < forts.length; i++) {\\n        if (forts[i] == \\'1\\') {\\n            a = i\\n            if (b >= 0) {\\n                max = Math.max(max, i - b)\\n                b = -1\\n            }\\n        } else if (forts[i] == \\'-1\\') {\\n            b = i\\n            if (a >= 0) {\\n                max = Math.max(max, i - a)\\n                a = -1\\n            }\\n        }        \\n\\n    }\\n\\n    return max - 1 \\n};"]}
{"id": "535", "ref_js": ["var closetTarget = function(words, t, s) {\\n    if(!words.includes(t)){\\n        return -1\\n    }\\n    let a = words.concat(words.slice(0,s+1));\\n    a = a.reverse();\\n    let l  = a.indexOf(t);\\n    let b = words.slice(s).concat(words)\\n    let m = b.indexOf(t)\\n    return Math.min(l,m)\\n    \\n    \\n};", "var closetTarget = function(words, target, startIndex) {\\n    let left = startIndex\\n    let right = startIndex\\n    let step = 0\\n    let n = words.length\\n    \\n    while(step <= n){\\n        if(words[left]===target||words[right]===target){\\n            return step\\n        } else {\\n            right = (right + 1) % n\\n            left = (left - 1 + n) % n\\n        }\\n        step ++\\n    }\\n    return -1\\n};", "var closetTarget = function(words, target, startIndex) {\\n    let half = Math.floor(words.length / 2)\\n    let len = words.length\\n    let a = b = startIndex\\n    let step = 0\\n\\n    for (let i = 0; i <= half; i++) {\\n        if (words[a] == target || words[b] == target) {\\n            return step\\n        }\\n\\n        step ++, a ++, b --\\n\\n        if (a >= len) a -= len\\n        if (b < 0) b += len\\n    }\\n\\n    return -1\\n};"]}
{"id": "536", "ref_js": ["var findSubarrays = function(nums) {\\n    const sumSet = new Set();\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const sum = nums[i] + nums[i + 1];\\n\\n        if (sumSet.has(sum)) {\\n            return true;\\n        }\\n\\n        sumSet.add(sum);\\n    }\\n\\n    return false;\\n};", "var findSubarrays = function (nums) {\\n  const set = new Set();\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (set.has(nums[i] + nums[i + 1])) {\\n      return true;\\n    }\\n    set.add(nums[i] + nums[i + 1]);\\n  }\\n\\n  return false;\\n};", "var findSubarrays = function(nums) {\\n    const sumSet = new Set();\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const sum = nums[i] + nums[i + 1];\\n\\n        if (sumSet.has(sum)) {\\n            return true;\\n        }\\n\\n        sumSet.add(sum);\\n    }\\n\\n    return false;\\n};"]}
{"id": "537", "ref_js": ["var categorizeBox = function(length, width, height, mass) {\\n  const volume = length * width * height;\\n  const isBulky =\\n    length >= 10 ** 4 ||\\n    width >= 10 ** 4 ||\\n    height >= 10 ** 4 ||\\n    mass >= 10 ** 4 ||\\n    volume >= 10 ** 9;\\n  let result = \\'\\';\\n\\n  const isHeavy = mass >= 100;\\n  if (isBulky && isHeavy) {\\n    result = \\'Both\\';\\n  } else if (!isBulky && !isHeavy) {\\n    result = \\'Neither\\';\\n  } else if (isBulky) {\\n    result = \\'Bulky\\';\\n  } else if (isHeavy) {\\n    return \\'Heavy\\';\\n  }\\n\\n  return result;\\n};", "var categorizeBox = function (length, width, height, mass) {\\n    detector = 0;\\n    if (mass >= 100) {\\n        detector = detector + 1;\\n    }\\n    volume = length * height * width;\\n    console.log(10**4)\\n    if ((volume >= 10**9) || (length >= 10**4 || height >= 10**4 || width >= 10**4)) {\\n        detector = detector + 2;\\n    }\\n    if (detector == 0) {\\n        return \"Neither\";\\n    } else if (detector == 3) {\\n        return \"Both\";\\n    } else if (detector == 1) {\\n        return \"Heavy\";\\n    } else {\\n        return \"Bulky\";\\n    }\\n};", "var categorizeBox = function(length, width, height, mass) {\\n    const volume = length * width * height;\\n    let maxVal = Math.max(length, width, height);\\n    const isBulky =  maxVal >= Math.pow(10, 4) || volume >= Math.pow(10, 9);\\n    const isHeavy = mass >= 100;\\n    if(isBulky && isHeavy){\\n        return \"Both\"\\n    } else if(!isBulky && !isHeavy){\\n        return \"Neither\"\\n    } else if(isBulky){\\n        return \"Bulky\"\\n    } else{\\n        return \"Heavy\"\\n    }\\n};"]}
{"id": "538", "ref_js": ["var maximumCount = function(nums) {\\n  let ncount = 0, pcount = 0;\\n  nums.forEach(n => {\\n    if (n > 0) pcount++;\\n    else if (0 > n) ncount++;\\n  })\\n  return ncount > pcount ? ncount : pcount;\\n};", "var maximumCount = function(nums) {\\n  return Math.max(upper_bound(nums), lower_bound(nums));\\n};", "var maximumCount = function(nums) {\\n    const n = nums.length;\\n    if (nums[0] > 0 || nums[n - 1] < 0) return n;\\n    let left = 0;\\n    let right = n - 1;\\n    while (left < right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] < 0) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n    "]}
{"id": "539", "ref_js": ["var differenceOfSum = function (nums) {\\n\\tlet eSum = nums.reduce((acc, val) => acc + val, 0);\\n\\tlet dSum = nums.reduce((acc, val) => acc + getDigitSum(val), 0);\\n\\treturn Math.abs(eSum - dSum);\\n};", "var differenceOfSum = function (nums) {\\n    function sumOfDigits(num) {\\n        let sum = 0;\\n        while (num) {\\n            sum += num % 10;\\n            num = Math.floor(num / 10);\\n        }\\n        return sum;\\n    }\\n\\n    let digitSum = 0,\\n        elementSum = 0;\\n\\n    for (let num of nums) {\\n        digitSum += sumOfDigits(num);\\n        elementSum += num;\\n    }\\n\\n    return Math.abs(digitSum - elementSum);\\n};", "var differenceOfSum = function (nums) {\\n    function sumOfDigits(num) {\\n        let sum = 0;\\n        while (num) {\\n            sum += num % 10;\\n            num = Math.floor(num / 10);\\n        }\\n        return sum;\\n    }\\n\\n    let digitSum = 0,\\n        elementSum = 0;\\n\\n    for (let num of nums) {\\n        digitSum += sumOfDigits(num);\\n        elementSum += num;\\n    }\\n\\n    return Math.abs(digitSum - elementSum);\\n};"]}
{"id": "540", "ref_js": ["var getCommon = function(nums1, nums2) {\\n    const set = new Set(nums1);\\n    const common = nums2.filter(n => set.has(n)).sort((a,b) => a - b)[0];\\n    \\n    return common !== undefined ? common : -1;\\n};", "var getCommon = function(nums1, nums2) {\\n\\n    let i = 0, j = 0;\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] === nums2[j]) {\\n            return nums1[i];\\n        } else if (nums1[i] < nums2[j]) {\\n            i++;\\n        } else {\\n            j++;\\n        }\\n    }\\n    return -1;    \\n};", "var getCommon = function(nums1, nums2) {\\n    "]}
{"id": "541", "ref_js": ["var alternateDigitSum = function(n) {\\n    return [...String(n)].reduce((sum, num, idx) => {\\n        return sum + (idx % 2 === 0 ? Number(num) : -Number(num));\\n    }, 0);\\n};", "var alternateDigitSum = function(n) {\\n    const str = n.toString()\\n    let sum = 0\\n    for(let i =0; i<str.length; i++){\\n        if(i%2 ==0){\\n            sum += +str[i]\\n        }else{\\n            sum -= +str[i]\\n        }\\n    }\\n    return sum\\n};", "var alternateDigitSum = function(n) {\\n    return [...String(n)].reduce((sum, num, idx) => {\\n        return sum + (idx % 2 === 0 ? Number(num) : -Number(num));\\n    }, 0);\\n};"]}
{"id": "542", "ref_js": ["var distinctIntegers = function(n) {\\n    return (n==1) ? 1 : n-1;\\n};", "var distinctIntegers = function (n) {\\n    let totlaDigitOnBoard = 1\\n    let bordArr=[n]\\n   while(n>1){\\n        for (let i = 2; i <= n; i++) {\\n        if (n % i === 1 && !bordArr.includes(i)) {\\n            totlaDigitOnBoard+=1\\n            bordArr.push(i)\\n            }\\n    }\\n    n-=1\\n   }\\n    return totlaDigitOnBoard\\n};", "var distinctIntegers = function (n) {\\n    let totlaDigitOnBoard = 1\\n    let bordArr=[n]\\n   while(n>1){\\n        for (let i = 2; i <= n; i++) {\\n        if (n % i === 1 && !bordArr.includes(i)) {\\n            totlaDigitOnBoard+=1\\n            bordArr.push(i)\\n            }\\n    }\\n    n-=1\\n   }\\n    return totlaDigitOnBoard\\n};"]}
{"id": "543", "ref_js": ["var separateDigits = function(nums) {\\n    let convertToString = nums.join(\"\");\\n    return(convertToString.match(/\\\\d/g))\\n};", "var separateDigits = function(nums) {\\n    let convertToString = nums.join(\"\");\\n    return(convertToString.match(/\\\\d/g))\\n};", "var separateDigits = function(nums) {\\n    let convertToString = nums.join(\"\");\\n    return(convertToString.match(/\\\\d/g))\\n};"]}
{"id": "544", "ref_js": ["var pickGifts = function(gifts, k) {\\n    while(k-->0){\\n        let max=Math.max(...gifts)\\n        gifts[gifts.lastIndexOf(max)]=Math.floor(Math.sqrt(max))\\n    }\\n    return gifts.reduce((a,b)=>a+b,0)\\n};", "var pickGifts = function(gifts, k) {\\n    let n = gifts.length;\\n   for(let i=0; i<k; i++){\\n       gifts = gifts.sort((a,b)=>b-a);\\n       gifts[0] =Math.floor(Math.sqrt(gifts[0])) \\n   } \\n   let sum = 0;\\n   for(let x of gifts){\\n       sum+=x;\\n   }\\n   return sum;\\n};", "var pickGifts = function(gifts, k) {\\n    while(k-->0){\\n        let max=Math.max(...gifts)\\n        gifts[gifts.lastIndexOf(max)]=Math.floor(Math.sqrt(max))\\n    }\\n    return gifts.reduce((a,b)=>a+b,0)\\n};"]}
{"id": "545", "ref_js": ["var findTheArrayConcVal = function(nums) {\\n    let store = 0;\\n    if (nums.length % 2 === 0) {\\n        for (let index = 0; index < nums.length / 2; index++) {\\n            store += parseInt(`${nums[index]}${nums[nums.length - index - 1]}`);\\n        }\\n    } else {\\n        for (let index = 0; index < parseInt(nums.length / 2); index++) {\\n            store += parseInt(`${nums[index]}${nums[nums.length - index - 1]}`);\\n        }\\n        store += nums[Math.floor(nums.length / 2)];\\n    }\\n    return store;\\n};", "var findTheArrayConcVal = function(nums) {\\n    let sum = 0;\\n\\n    while(nums.length) {\\n        const first = nums.shift();\\n        const last = nums.pop();\\n        const concat = first?.toString() + last?.toString();\\n        sum += parseInt(concat);\\n    }\\n\\n    return sum;\\n};", "var findTheArrayConcVal = function(nums) {\\n    let sum = 0;\\n\\n    while(nums.length) {\\n        const first = nums.shift();\\n        const last = nums.pop();\\n        const concat = first?.toString() + last?.toString();\\n        sum += parseInt(concat);\\n    }\\n\\n    return sum;\\n};"]}
{"id": "546", "ref_js": ["var minMaxDifference = function(num) {\\n    let str = num.toString();\\n    let d1 = \\'9\\', d2 = \\'0\\';\\n    let max = \\'\\', min = \\'\\';\\n    \\n    for (let i = 0; i < str.length; i++) {\\n        if (d1 === \\'9\\' && str[i] !== \\'9\\') {\\n            d1 = str[i];\\n        }\\n        \\n        if (d1 === str[i]) {\\n            max += \\'9\\';\\n        } else {\\n            max += str[i];\\n        }\\n        \\n        if (d2 === \\'0\\' && str[i] !== \\'0\\') {\\n            d2 = str[i];\\n        }\\n        \\n        if (d2 === str[i]) {\\n            min += \\'0\\';\\n        } else {\\n            min += str[i];\\n        }        \\n    }\\n    \\n    return Number(max) - Number(min);\\n};", "var minMaxDifference = function(num) {\\n    let str = num.toString();\\n    let d1 = \\'9\\', d2 = \\'0\\';\\n    let max = \\'\\', min = \\'\\';\\n    \\n    for (let i = 0; i < str.length; i++) {\\n        if (d1 === \\'9\\' && str[i] !== \\'9\\') {\\n            d1 = str[i];\\n        }\\n        \\n        if (d1 === str[i]) {\\n            max += \\'9\\';\\n        } else {\\n            max += str[i];\\n        }\\n        \\n        if (d2 === \\'0\\' && str[i] !== \\'0\\') {\\n            d2 = str[i];\\n        }\\n        \\n        if (d2 === str[i]) {\\n            min += \\'0\\';\\n        } else {\\n            min += str[i];\\n        }        \\n    }\\n    \\n    return Number(max) - Number(min);\\n};", "var minMaxDifference = function(num) {\\n    let str = num.toString();\\n    let d1 = \\'9\\', d2 = \\'0\\';\\n    let max = \\'\\', min = \\'\\';\\n    \\n    for (let i = 0; i < str.length; i++) {\\n        if (d1 === \\'9\\' && str[i] !== \\'9\\') {\\n            d1 = str[i];\\n        }\\n        \\n        if (d1 === str[i]) {\\n            max += \\'9\\';\\n        } else {\\n            max += str[i];\\n        }\\n        \\n        if (d2 === \\'0\\' && str[i] !== \\'0\\') {\\n            d2 = str[i];\\n        }\\n        \\n        if (d2 === str[i]) {\\n            min += \\'0\\';\\n        } else {\\n            min += str[i];\\n        }        \\n    }\\n    \\n    return Number(max) - Number(min);\\n};"]}
{"id": "547", "ref_js": ["var mergeArrays = function (nums1, nums2) {\\n  const sumObject = {};", "var mergeArrays = function (a, b) {\\n    let o = {};", "var mergeArrays = function(nums1, nums2) {\\n    const numsMap = {};"]}
{"id": "548", "ref_js": ["var leftRightDifference = function(nums) {\\n    let lArray = [];\\n    let rArray = [];\\n\\n    for(let i=0; i < nums.length; i++){\\n        let lSum = 0;\\n        let rSum = 0;\\n        for(let j=0; j<i; j++){\\n            lSum = lSum + nums[j];\\n        }\\n        lArray.push(lSum);\\n        lArray[0] = 0;\\n\\n        for(let k=i+1; k < nums.length; k++){\\n            rSum = rSum + nums[k];\\n        }\\n        rArray.push(rSum);\\n    }\\n\\n    let ans = [];\\n    rArray[nums.length-1] = 0;\\n\\n    for(let p =0; p < nums.length; p++){\\n        ans[p] = Math.abs(lArray[p]-rArray[p]);\\n    }\\n    return ans;\\n};", "var leftRigthDifference = function(nums) {\\n    let sumRight = nums.reduce((a,b) => a + b);\\n    let sumLeft = 0;\\n    const a = nums.slice(0, nums.length - 1);\\n    a.unshift(0)\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        sumRight -= nums[i]\\n        sumLeft += a[i]\\n        a[i] = Math.abs(sumLeft - sumRight)\\n    }\\n    \\n    return a;\\n};", "var leftRigthDifference = function(nums) {\\n  let result = [];\\n  \\n  let left = 0;\\n  let right = 0;\\n  \\n  for (var i = 0; i < nums.length; i++) {\\n    right += nums[i];\\n  }\\n  \\n  for (var i = 0; i < nums.length; i++) {\\n    right -= nums[i];\\n    result.push(Math.abs(left - right));\\n    left += nums[i];\\n  }\\n  return result;\\n};"]}
{"id": "549", "ref_js": ["var splitNum = function(num) {\\n    let num1 = ``;\\n    let num2 = ``;\\n    const getBucketSort = bucketSort(num.toString().split(\\'\\'));\\n    for (let index = 0; index < getBucketSort.length; index += 2) {\\n        num1 += getBucketSort[index];\\n        num2 += getBucketSort[index + 1] || \\'\\';\\n    }\\n    return Number(num1) + Number(num2);\\n};", "var splitNum = function (n) {\\n    ", "var splitNum = function (n) {\\n    "]}
{"id": "550", "ref_js": ["var passThePillow = function(n, time) {\\n    const updatedN = n - 1;\\n    const rotation = parseInt(time / updatedN);\\n    const left = time % updatedN;\\n    if (rotation % 2) {\\n        return n - left;\\n    } else {\\n        return 1 + left;\\n    }\\n};", "var passThePillow = function(n, time) {\\n    let count = Math.floor(time / (n-1));\\n    let mod = time % (n-1);\\n    if(count % 2 == 0) {\\n        return 1 + mod\\n    }\\n    return n - mod\\n};", "var passThePillow = function(n, time) {\\n    var d = Math.floor(time / (n - 1));\\n    var r = time % (n - 1);\\n\\n    if (d % 2 === 0) {\\n        return 1 + r;\\n    }\\n\\n    return n - r;\\n};"]}
{"id": "551", "ref_js": ["var vowelStrings = function(s, left, right) {\\n  let vowel = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n  let count = 0 \\n  for(let i = left ; i <= right ;i++){\\n      if(vowel.includes(s[i][0]) && vowel.includes(s[i][s[i].length -1])){\\n          count +=1\\n      }\\n  }  \\n  return count \\n};", "var vowelStrings = function (words, left, right) {\\n  let result = 0;\\n  const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\\n\\n  for (let i = left; i <= right; i++) {\\n    if (\\n      vowels.includes(words[i][0]) &&\\n      vowels.includes(words[i][words[i].length - 1])\\n    ) {\\n      result++;\\n    }\\n  }\\n\\n  return result;\\n};", "var vowelStrings = function(s, left, right) {\\n  let vowel = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n  let count = 0 \\n  for(let i = left ; i <= right ;i++){\\n      if(vowel.includes(s[i][0]) && vowel.includes(s[i][s[i].length -1])){\\n          count +=1\\n      }\\n  }  \\n  return count \\n};"]}
{"id": "552", "ref_js": ["var distMoney = function(money, children) {\\n    if(money < children){\\n        return -1;\\n    }\\n    if(children * 8 < money){\\n        return children - 1\\n    }\\n    let moneyLeft = money - children;\\n    let childrenBy8 = Math.floor(moneyLeft/7);\\n    let left = moneyLeft % 7;\\n    \\n    if(left === 3 && childrenBy8 > 0 && children - childrenBy8 === 1){\\n        childrenBy8--;\\n    }\\n    \\n    \\n    return childrenBy8;\\n};", "var distMoney = function(money, children) {\\n    if(money < children){\\n        return -1;\\n    }\\n    \\n    money -= children;\\n    \\n    const helper = Math.floor(money/7);\\n    \\n    ", "var distMoney = function(money, children) {\\n    if(children * 8 == money) {\\n        return children\\n    }\\n    if(money<children || (money == 4 && children ==1)) {\\n        return -1\\n    }\\n    let pending = money - children;\\n    \\n    let total =  Math.floor(pending/7);\\n    \\n    if(total>=children) {\\n        return children-1\\n    }\\n    if(total == children-1 && pending%7 == 3) {\\n        return total-1\\n    }\\n    return total\\n};"]}
{"id": "553", "ref_js": ["var evenOddBit = function (n) {\\n  let binaryN = n.toString(2).split(\"\").reverse();\\n  let odd = 0;\\n  let even = 0;\\n  for (let i = 0; i < binaryN.length; i++) {\\n    if (binaryN[i] == 1) {\\n      if (i % 2 == 0) even++;\\n      else odd++;\\n    }\\n  }\\n  return [even, odd];\\n};", "var evenOddBit = function (n) {\\n  let binaryN = n.toString(2).split(\"\").reverse();\\n  let odd = 0;\\n  let even = 0;\\n  for (let i = 0; i < binaryN.length; i++) {\\n    if (binaryN[i] == 1) {\\n      if (i % 2 == 0) even++;\\n      else odd++;\\n    }\\n  }\\n  return [even, odd];\\n};", "var evenOddBit = function (n) {\\n  let binaryN = n.toString(2).split(\"\").reverse();\\n  let odd = 0;\\n  let even = 0;\\n  for (let i = 0; i < binaryN.length; i++) {\\n    if (binaryN[i] == 1) {\\n      if (i % 2 == 0) even++;\\n      else odd++;\\n    }\\n  }\\n  return [even, odd];\\n};"]}
{"id": "554", "ref_js": ["var kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    if (k <= numOnes) {\\n        return k;\\n    }\\n    let sum = 0;\\n    if (numOnes) {\\n        sum += numOnes;\\n        k -= numOnes;\\n    }\\n    if (k > 0 && numZeros) {\\n        k -= numZeros;\\n    }\\n\\n    if (k > 0 && numNegOnes) {\\n        sum += k * -1;\\n    }\\n    return sum;\\n};", "var kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    let one=\"1,\".repeat(numOnes);\\n       let zero=\"0,\".repeat(numZeros);\\n      let none=\"-1,\".repeat(numNegOnes);\\n       let tot=(one+zero+none).split(\",\");\\n      \\n      let sum=0,n=0,j=0;\\n      for(let i=0;i<k;i++)\\n      {\\n         n=Number(tot[j]);\\n         sum+=n;\\n         j++;\\n      }\\n\\n      return sum;\\n};", "var kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n  return Math.min(k, numOnes) - Math.max(0, k - numZeros - numOnes)\\n};"]}
{"id": "555", "ref_js": ["var minNumber = function (nums1, nums2) {\\n    let smallest = null;\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        for (let j = 0; j < nums2.length; j++) {\\n            smallest =\\n                smallest == null\\n                    ? (nums1[i] == nums2[j]\\n                        ? nums1[i]\\n                        : (parseInt(nums1[i].toString() + nums2[j].toString()) < parseInt(nums2[j].toString() + nums1[i].toString()))\\n                            ? parseInt(nums1[i].toString() + nums2[j].toString())\\n                            : parseInt(nums2[j].toString() + nums1[i].toString()))\\n                    : (nums1[i] == nums2[j] && smallest > nums1[i]\\n                        ? nums1[i]\\n                        : (smallest > parseInt(nums1[i].toString() + nums2[j].toString()) || smallest > parseInt(nums2[j].toString() + nums1[i].toString())\\n                            ? (parseInt(nums1[i].toString() + nums2[j].toString()) < parseInt(nums2[j].toString() + nums1[i].toString())\\n                                ? parseInt(nums1[i].toString() + nums2[j].toString())\\n                                : parseInt(nums2[j].toString() + nums1[i].toString()))\\n                            : (smallest > parseInt(nums2[j].toString() + nums1[i].toString())\\n                                ? parseInt(nums2[j].toString() + nums1[i].toString())\\n                                : smallest)));\\n        }\\n    }\\n\\n    return smallest;\\n};", "var minNumber = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    for (let i = 0; i < 10; i++) {\\n        if (s1.has(i) && s2.has(i)) return i;\\n    }\\n    const m1 = Math.min(...nums1);\\n    const m2 = Math.min(...nums2);\\n    return +`${Math.min(m1, m2)}${Math.max(m1, m2)}`\\n};", "var minNumber = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    for (let i = 0; i < 10; i++) {\\n        if (s1.has(i) && s2.has(i)) return i;\\n    }\\n    const m1 = Math.min(...nums1);\\n    const m2 = Math.min(...nums2);\\n    return +`${Math.min(m1, m2)}${Math.max(m1, m2)}`\\n};"]}
{"id": "556", "ref_js": ["var findTheLongestBalancedSubstring = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    let max = 0;\\n\\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") {\\n            if (ones !== 0) {\\n               zeros = 0;\\n               ones = 0;\\n            } \\n            ++zeros;\\n        } else {\\n            ++ones;\\n            if (zeros !== 0) {\\n                max = Math.max(max, 2 * Math.min(zeros, ones));\\n            }\\n        }\\n    }\\n\\n    return max;\\n};", "var findTheLongestBalancedSubstring = function(s) {\\n    let max = 0;\\n    let current = 0; ", "var findTheLongestBalancedSubstring = function(s) {\\n    let substr = \\'\\'\\n    let ans = 0\\n\\n    for (let i = 0; i <= s.length / 2; i++) {\\n        substr = \\'0\\' + substr + \\'1\\'\\n        if (s.includes(substr)) \\n            ans = substr.length\\n        else \\n            return ans\\n    }\\n\\n    return ans\\n};"]}
{"id": "557", "ref_js": ["var diagonalPrime = function(nums) {\\n    var n=nums.length,mx=0;\\n    for(var i=0;i<n;i++){\\n        for(var j=0;j<n;j++){\\n            if(i==j && isprime(nums[i][j])) mx=Math.max(mx,nums[i][j]);\\n            if(j==n-i-1 &&  isprime(nums[i][j])) mx=Math.max(mx,nums[i][j]);\\n        }\\n    }\\n    return mx;\\n};", "var diagonalPrime = function(nums) {\\n    let maxPrimeNumber = 0;\\n    for (let index = 0; index < nums.length; index++) {\\n        const currentNum = nums[index][index];\\n        if (currentNum === 1) {\\n            continue;\\n        }\\n        if (isPrime(currentNum)) {\\n            if (maxPrimeNumber < currentNum) {\\n                maxPrimeNumber = currentNum;\\n            }\\n        }\\n    }\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        const columnIndex = nums.length - 1 - index;\\n        const currentNum = nums[index][columnIndex];\\n        if (currentNum === 1) {\\n            continue;\\n        }\\n        if (nums.length % 2 !== 0) {\\n            if (index !== columnIndex) {\\n                if (isPrime(currentNum)) {\\n                    if (maxPrimeNumber < currentNum) {\\n                        maxPrimeNumber = currentNum;\\n                    }\\n                }\\n            }\\n        } else {\\n            if (isPrime(currentNum)) {\\n                if (maxPrimeNumber < currentNum) {\\n                    maxPrimeNumber = currentNum;\\n                }\\n            }\\n        }\\n    }\\n    return maxPrimeNumber;\\n};", "var diagonalPrime = function(nums) {\\n  "]}
{"id": "565", "ref_js": ["var findColumnWidth = function(grid) {\\n    const ans = [];\\n    for (let i = 0; i < grid[0].length; i++) {\\n        let mx = 0;\\n        for (let j = 0; j < grid.length; j++) {\\n            mx = Math.max(mx, grid[j][i].toString().length);\\n        }\\n        ans.push(mx);\\n    }\\n    return ans;\\n};", "var findColumnWidth = function(grid) {\\n    const m = grid.length\\n    const n = grid[0].length\\n    const ans = []\\n    for (let j = 0; j < n; j++) {\\n      let len = 1\\n      for (let i = 0; i < m; i++) {\\n        len = Math.max(len, grid[i][j].toString().length)\\n      }\\n      ans.push(len)\\n    }\\n    return ans\\n};", "var findColumnWidth = function(grid) {\\n    const ans = [];\\n    for (let i = 0; i < grid[0].length; i++) {\\n        let mx = 0;\\n        for (let j = 0; j < grid.length; j++) {\\n            mx = Math.max(mx, grid[j][i].toString().length);\\n        }\\n        ans.push(mx);\\n    }\\n    return ans;\\n};"]}
{"id": "566", "ref_js": ["var rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};", "var rowAndMaximumOnes = function (mat) {\\n    const result = [0,0];\\n    for (let i = 0; i < mat.length; i++) {\\n        const count = countOne(mat[i]);\\n        if (count > result[1]) {\\n            result[0] = i;\\n            result[1] = count;\\n        }\\n    }\\n    return result;\\n};", "var rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};"]}
{"id": "567", "ref_js": ["var maxDivScore = function(nums, divisors) {\\n    let index = 0;\\n    let maxDiv = 0;\\n    let lowestIndexOfMaxDivScore = 0;\\n    let lowestDivisor = Number.MAX_SAFE_INTEGER;\\n\\n    for (let divisor of divisors) {\\n        let currentDiv = 0;\\n        for (let number of nums) {\\n            if (number % divisor === 0) {\\n                currentDiv++;\\n            }\\n        }\\n\\n        if (currentDiv > maxDiv) {\\n            maxDiv = currentDiv;\\n            lowestIndexOfMaxDivScore = index;\\n        }\\n\\n        if (currentDiv === maxDiv && divisors[lowestIndexOfMaxDivScore] > divisor) {\\n            lowestIndexOfMaxDivScore = index;\\n        }\\n\\n        if (maxDiv === 0) {\\n            lowestDivisor = Math.min(lowestDivisor, divisor);\\n        }\\n\\n        index++;\\n    }\\n\\n    return maxDiv !== 0 ? divisors[lowestIndexOfMaxDivScore] : lowestDivisor;\\n};", "var maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};", "var maxDivScore = function(nums, divisors) {\\n    let index = 0;\\n    let maxDiv = 0;\\n    let lowestIndexOfMaxDivScore = 0;\\n    let lowestDivisor = Number.MAX_SAFE_INTEGER;\\n\\n    for (let divisor of divisors) {\\n        let currentDiv = 0;\\n        for (let number of nums) {\\n            if (number % divisor === 0) {\\n                currentDiv++;\\n            }\\n        }\\n\\n        if (currentDiv > maxDiv) {\\n            maxDiv = currentDiv;\\n            lowestIndexOfMaxDivScore = index;\\n        }\\n\\n        if (currentDiv === maxDiv && divisors[lowestIndexOfMaxDivScore] > divisor) {\\n            lowestIndexOfMaxDivScore = index;\\n        }\\n\\n        if (maxDiv === 0) {\\n            lowestDivisor = Math.min(lowestDivisor, divisor);\\n        }\\n\\n        index++;\\n    }\\n\\n    return maxDiv !== 0 ? divisors[lowestIndexOfMaxDivScore] : lowestDivisor;\\n};"]}
{"id": "569", "ref_js": ["var findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    let time = arrivalTime + delayedTime\\n    return time >= 24 ? time - 24 : time\\n};", "var findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};", "var findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n\\n    return (arrivalTime + delayedTime)%24\\n    \\n};"]}
{"id": "570", "ref_js": ["var sumOfMultiples = function (n) {\\n    let s = 0; ", "var sumOfMultiples = function (n) {\\n  let sum = 0;\\n\\n  for (let i = 1; i <= n; i++) {\\n    if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\\n      sum += i;\\n    }\\n  }\\n\\n  return sum;\\n};", "var sumOfMultiples = function(n) {\\n    let sum = 0;\\n\\n    for (let i = 0; i <= n; i++) {\\n        if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0) {\\n            sum = sum + i;\\n        }\\n    }\\n\\n    return sum;\\n};"]}
{"id": "571", "ref_js": ["var maximizeSum = function (nums, k) {\\n  ", "var maximizeSum = function(nums, k) {\\n    let max = Math.max(...nums);\\n    sum = max;\\n    for(let i=1; i<k; i++){\\n        sum+= max+i;\\n    }\\n    return sum;\\n};", "var maximizeSum = function(nums, k) {\\n    let max = Math.max(...nums);\\n    sum = max;\\n    for(let i=1; i<k; i++){\\n        sum+= max+i;\\n    }\\n    return sum;\\n};"]}
{"id": "572", "ref_js": ["var isWinner = function(player1, player2) {\\n    let p1Total = 0;\\n    let p2Total = 0;\\n\\n    for(let i=0; i<player1.length; i++){\\n        if(player1[i-1] === 10 || player1[i-2] === 10) {\\n            p1Total += (2*player1[i]);\\n        } else {\\n            p1Total += player1[i];\\n        }\\n\\n        if(player2[i-1] === 10 || player2[i-2] === 10) {\\n            p2Total += (2*player2[i]);\\n        } else {\\n            p2Total += player2[i];\\n        }\\n        \\n        \\n    }\\n\\n    if(p1Total === p2Total) return 0;\\n    return (p1Total < p2Total) ? 2 : 1;\\n\\n};", "var isWinner = function(player1, player2) {\\n    let p1Total = 0;\\n    let p2Total = 0;\\n\\n    for(let i=0; i<player1.length; i++){\\n        if(player1[i-1] === 10 || player1[i-2] === 10) {\\n            p1Total += (2*player1[i]);\\n        } else {\\n            p1Total += player1[i];\\n        }\\n\\n        if(player2[i-1] === 10 || player2[i-2] === 10) {\\n            p2Total += (2*player2[i]);\\n        } else {\\n            p2Total += player2[i];\\n        }\\n        \\n        \\n    }\\n\\n    if(p1Total === p2Total) return 0;\\n    return (p1Total < p2Total) ? 2 : 1;\\n\\n};", "var isWinner = function(player1, player2) {\\n    let p1Total = 0;\\n    let p2Total = 0;\\n\\n    for(let i=0; i<player1.length; i++){\\n        if(player1[i-1] === 10 || player1[i-2] === 10) {\\n            p1Total += (2*player1[i]);\\n        } else {\\n            p1Total += player1[i];\\n        }\\n\\n        if(player2[i-1] === 10 || player2[i-2] === 10) {\\n            p2Total += (2*player2[i]);\\n        } else {\\n            p2Total += player2[i];\\n        }\\n        \\n        \\n    }\\n\\n    if(p1Total === p2Total) return 0;\\n    return (p1Total < p2Total) ? 2 : 1;\\n\\n};"]}
{"id": "576", "ref_js": ["var distinctDifferenceArray = function(nums) {\\n    const n = nums.length;\\n    const diff = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; i++) {\\n            const prefix = new Set();\\n            const suffix = new Set();\\n        \\n            prefix.add(nums[0]);        \\n            for (let j = 1; j <= i; j++) {\\n             if (!prefix.has(nums[j])) prefix.add(nums[j]);\\n             }\\n        \\n            for (let j = i+1; j < n; j++) {\\n             if(!suffix.has(nums[j])) suffix.add(nums[j]);\\n             }\\n                \\n        const prefixSize = prefix.size;\\n        const suffixSize = suffix.size;\\n\\n        diff[i] = prefixSize - suffixSize;\\n    }\\n\\n    return diff;\\n    \\n};", "var distinctDifferenceArray = function(nums) {\\n    const set = new Set()\\n    const res = []\\n    \\n    for (let num of nums) {\\n        set.add(num)\\n        res.push(set.size)\\n    }\\n    \\n    set.clear()\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        res[i] = res[i] - set.size\\n        set.add(nums[i])\\n    }\\n    \\n    return res\\n};", "var distinctDifferenceArray = function(nums) {\\n    const n = nums.length;\\n    const diff = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; i++) {\\n            const prefix = new Set();\\n            const suffix = new Set();\\n        \\n            prefix.add(nums[0]);        \\n            for (let j = 1; j <= i; j++) {\\n             if (!prefix.has(nums[j])) prefix.add(nums[j]);\\n             }\\n        \\n            for (let j = i+1; j < n; j++) {\\n             if(!suffix.has(nums[j])) suffix.add(nums[j]);\\n             }\\n                \\n        const prefixSize = prefix.size;\\n        const suffixSize = suffix.size;\\n\\n        diff[i] = prefixSize - suffixSize;\\n    }\\n\\n    return diff;\\n    \\n};"]}
{"id": "578", "ref_js": ["var countSeniors = function(details) {\\n    let counter = 0;\\n    for(let i = 0;i < details.length;i++){\\n        if(details[i][11].concat(details[i][12]) > 60){\\n            counter++\\n        }\\n    }\\n    return counter\\n};", "var countSeniors = function(details) {\\n    return details.filter(el => el.slice(-4, -2) > 60).length;\\n};", "var countSeniors = function(details) {\\n    return details.filter(detail => parseInt(detail.substring(11,13)) > 60).length;\\n};"]}
{"id": "579", "ref_js": ["var circularGameLosers = function(n, k) {\\n    const players = new Array(n).fill(0);\\n    let index = 0;\\n    let turn = 1;\\n    \\n    while (true) {\\n        ++players[index];\\n        if (players[index] === 2) break;\\n        index += turn++ * k;\\n        index %= n;\\n    }\\n\\n    const result = [];\\n\\n    for (let i = 1; i < n; ++i) {\\n        if (players[i] === 0) result.push(i + 1);\\n    }\\n\\n    return result;\\n};", "var circularGameLosers = function(n, k) {\\n    arr = Array(n).fill(0)\\n    count = 1\\n    i = 0\\n\\n    while (arr[i] += 1) {\\n        if (arr[i] > 1) break\\n        i = (i + k * count++) % n\\n        ", "var circularGameLosers = function(n, k) {\\n    const players = new Array(n).fill(0);\\n    let index = 0;\\n    let turn = 1;\\n    \\n    while (true) {\\n        ++players[index];\\n        if (players[index] === 2) break;\\n        index += turn++ * k;\\n        index %= n;\\n    }\\n\\n    const result = [];\\n\\n    for (let i = 1; i < n; ++i) {\\n        if (players[i] === 0) result.push(i + 1);\\n    }\\n\\n    return result;\\n};"]}
{"id": "581", "ref_js": ["var minLength = function(s) {\\n    let pointer1 = 0;\\n    let stack = [];\\n    while (pointer1 < s.length) {\\n        if (stack[stack.length - 1] === \\'B\\' && stack[stack.length - 1 - 1] === \\'A\\') {\\n            stack.pop();\\n            stack.pop();\\n        } else if (stack[stack.length - 1] === \\'D\\' && stack[stack.length - 1 - 1] === \\'C\\') {\\n            stack.pop();\\n            stack.pop();\\n        } else {\\n            stack.push(s[pointer1++]);\\n        }\\n    }\\n    if (stack[stack.length - 1] === \\'B\\' && stack[stack.length - 1 - 1] === \\'A\\') {\\n        stack.pop();\\n        stack.pop();\\n    } else if (stack[stack.length - 1] === \\'D\\' && stack[stack.length - 1 - 1] === \\'C\\') {\\n        stack.pop();\\n        stack.pop();\\n    }\\n    return stack.length;\\n};", "var minLength = function(s) {\\n    const st = [];\\n    for (const c of s) {\\n        if (st.length\\n            && (c === \\'B\\' && st[st.length - 1] === \\'A\\'\\n            || c === \\'D\\' && st[st.length - 1] === \\'C\\')\\n        ) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\n    return st.length;\\n};", "var minLength = function(s) {\\n    \\n    \\n    \\n        while( s.includes(\"AB\") || s.includes(\"CD\"))\\n            {\\n                if(s.includes(\"AB\"))\\n                s = s.replace(\"AB\",\"\")\\n\\n                if(s.includes(\"CD\"))\\n                s = s.replace(\"CD\", \\'\\')\\n            }\\n\\n        return s.length;\\n    \\n};"]}
{"id": "582", "ref_js": ["var makeSmallestPalindrome = function(s) {\\n    let str = s.split(\\'\\')\\n    for(let i = s.length - 1, j = 0; i >= Math.ceil(s.length / 2); i--, j++) {\\n        if(str[i] < str[j]) {\\n            str[j] = str[i]\\n        } else {\\n            str[i] = str[j]\\n        }\\n    }\\n    return str.join(\\'\\')\\n};", "var makeSmallestPalindrome = function(s) {\\n    \\n     let rev = s.split(\"\").reverse().join(\"\");\\n        let str = \\'\\';\\n\\n        for(let i = 0 ; i < s.length ; i++)\\n            {\\n                const item1 = s[i];\\n                const item2 = rev[i];\\n\\n                if( item1 === item2 )\\n                {\\n                    str += item1;\\n                }\\n                else\\n                {\\n                    if(s.charCodeAt(i) < rev.charCodeAt(i))\\n                    {\\n                        str += item1;\\n                    }\\n                    else\\n                    {\\n                        str += item2;\\n                    }\\n                }\\n            }\\n    return str;\\n    \\n};", "var makeSmallestPalindrome = function(s) {\\n    let str = s.split(\\'\\')\\n    for(let i = s.length - 1, j = 0; i >= Math.ceil(s.length / 2); i--, j++) {\\n        if(str[i] < str[j]) {\\n            str[j] = str[i]\\n        } else {\\n            str[i] = str[j]\\n        }\\n    }\\n    return str.join(\\'\\')\\n};"]}
{"id": "585", "ref_js": ["var buyChoco = function(prices, money) {\\n    let firstMinCost = Infinity;\\n    let secondMinCost = Infinity;\\n\\n    for (let p of prices) {\\n        if (p < firstMinCost) {\\n            secondMinCost = firstMinCost;\\n            firstMinCost = p;\\n        } else {\\n            secondMinCost = Math.min(secondMinCost, p);\\n        }\\n    }\\n\\n    let leftover = money - (firstMinCost + secondMinCost);\\n\\n    return leftover >= 0 ? leftover : money;    \\n};", "var buyChoco = function(arr, key) {\\n    let ans = Infinity;\\n        let fin;\\n\\n        for (let i = 0; i < arr.length; ++i) {\\n            for (let j = 0; j < arr.length; ++j) {\\n                if (i !== j) {\\n                    const sum = arr[i] + arr[j];\\n                    ans = Math.min(ans, sum);\\n                }\\n            }\\n        }\\n\\n        fin = key - ans;\\n        if(fin>=0){\\n        return fin;\\n        }\\n        else{\\n            return key;\\n        }\\n};", "var buyChoco = function(arr, key) {\\n    let ans = Infinity;\\n        let fin;\\n\\n        for (let i = 0; i < arr.length; ++i) {\\n            for (let j = 0; j < arr.length; ++j) {\\n                if (i !== j) {\\n                    const sum = arr[i] + arr[j];\\n                    ans = Math.min(ans, sum);\\n                }\\n            }\\n        }\\n\\n        fin = key - ans;\\n        if(fin>=0){\\n        return fin;\\n        }\\n        else{\\n            return key;\\n        }\\n};"]}
{"id": "586", "ref_js": ["var removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \"\")\\n};", "var removeTrailingZeros = function(num) {\\n  let res = num.match(/(\\\\d+)?[^0]/g);\\n  return(`${res}`);\\n};", "var removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \"\")\\n};"]}
{"id": "588", "ref_js": ["var minimizedStringLength = function(s) {\\n   return new Set(s).size\\n};", "var minimizedStringLength = function(s) {\\n   return new Set(s).size\\n};", "var minimizedStringLength = function(s) {\\n   return new Set(s).size\\n};"]}
{"id": "589", "ref_js": ["var semiOrderedPermutation = function (nums) {\\n  let counter = 0\\n  while (nums[0] !== 1) {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i + 1] == 1) {\\n        const temp = nums[i];\\n        nums[i] = nums[i + 1];\\n        nums[i + 1] = temp;\\n        counter++\\n      }\\n    }\\n  }\\n\\n  while (nums[nums.length - 1] !== nums.length) {\\n    for (let i = 0; i < nums.length; i++) {\\n      if(nums[i-1] == nums.length) {\\n        const temp = nums[i];\\n        nums[i] = nums[i-1];\\n        nums[i-1] = temp;\\n        counter++\\n      }\\n    }\\n  }\\n\\n  return counter\\n};", "var semiOrderedPermutation = function (nums) {\\n  let counter = 0\\n  while (nums[0] !== 1) {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i + 1] == 1) {\\n        const temp = nums[i];\\n        nums[i] = nums[i + 1];\\n        nums[i + 1] = temp;\\n        counter++\\n      }\\n    }\\n  }\\n\\n  while (nums[nums.length - 1] !== nums.length) {\\n    for (let i = 0; i < nums.length; i++) {\\n      if(nums[i-1] == nums.length) {\\n        const temp = nums[i];\\n        nums[i] = nums[i-1];\\n        nums[i-1] = temp;\\n        counter++\\n      }\\n    }\\n  }\\n\\n  return counter\\n};", "var semiOrderedPermutation = function (nums) {\\n  let counter = 0\\n  while (nums[0] !== 1) {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i + 1] == 1) {\\n        const temp = nums[i];\\n        nums[i] = nums[i + 1];\\n        nums[i + 1] = temp;\\n        counter++\\n      }\\n    }\\n  }\\n\\n  while (nums[nums.length - 1] !== nums.length) {\\n    for (let i = 0; i < nums.length; i++) {\\n      if(nums[i-1] == nums.length) {\\n        const temp = nums[i];\\n        nums[i] = nums[i-1];\\n        nums[i-1] = temp;\\n        counter++\\n      }\\n    }\\n  }\\n\\n  return counter\\n};"]}
{"id": "595", "ref_js": ["var maximumCount = function(nums) {\\n  let ncount = 0, pcount = 0;\\n  nums.forEach(n => {\\n    if (n > 0) pcount++;\\n    else if (0 > n) ncount++;\\n  })\\n  return ncount > pcount ? ncount : pcount;\\n};", "var maximumCount = function(nums) {\\n  return Math.max(upper_bound(nums), lower_bound(nums));\\n};", "var maximumCount = function(nums) {\\n    const n = nums.length;\\n    if (nums[0] > 0 || nums[n - 1] < 0) return n;\\n    let left = 0;\\n    let right = n - 1;\\n    while (left < right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] < 0) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n    "]}
{"id": "596", "ref_js": ["var findNonMinOrMax = function(nums) {\\n    return nums.length < 3 ? -1 : nums.sort((a, b) => a - b)[1]\\n};", "var findNonMinOrMax = function(n) \\n{\\n      return n.length<3 ? -1 : Math.min(Math.max(Math.min(n[0], n[1]), n[2]), Math.max(n[0],n[1]));\\n};", "var findNonMinOrMax = function(nums) {\\n    return nums.length < 3 ? -1 : nums.sort((a, b) => a - b)[1]\\n};"]}
{"id": "597", "ref_js": ["var distanceTraveled = function(mainTank, additionalTank) {\\n    let totalMileage = 0;\\n    for(let i = 1; i <= mainTank; i++){ \\n        ", "var distanceTraveled = function(mainTank, additionalTank) {\\n    let distance = 0;\\n\\n    if (mainTank < 5) {\\n        let remainingFuel = mainTank % 5;\\n        return remainingFuel * 10;\\n    }\\n\\n    while (mainTank > 0 || additionalTank > 0) {\\n        if (mainTank >= 5) {\\n            distance += 50;\\n            mainTank -= 5;\\n\\n            if (additionalTank > 0) {\\n                mainTank += 1;\\n                additionalTank -= 1;\\n            }\\n        } else {\\n            let remainingFuel = mainTank % 5;\\n            distance += remainingFuel * 10;\\n            break;\\n        }\\n    }\\n\\n    return distance;\\n};", "var distanceTraveled = function(mainTank, additionalTank) {\\n       let totalMileage = 0;\\n       for(let i = 1; i <= mainTank; i++){\\n           totalMileage = totalMileage + 10;\\n\\n           if(i % 5 === 0 && additionalTank > 0 ){\\n           additionalTank--;\\n           mainTank++;\\n           }\\n       }\\n       return totalMileage;\\n};"]}
{"id": "598", "ref_js": ["var maximumNumberOfStringPairs = function(words) {\\n  return words.length - new Set(words.map((a) => a[0]>a[1]? a[0]+a[1]: a[1]+a[0] )).size;\\n};", "var maximumNumberOfStringPairs = function(words) {\\n  return words.length - new Set(words.map((a) => a[0]>a[1]? a[0]+a[1]: a[1]+a[0] )).size;\\n};", "var maximumNumberOfStringPairs = function(words) {\\n  return words.length - new Set(words.map((a) => a[0]>a[1]? a[0]+a[1]: a[1]+a[0] )).size;\\n};"]}
{"id": "599", "ref_js": ["var countBeautifulPairs = function(nums) {\\n    count = 0\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < nums.length; j++) {\\n            if (i != j) {\\n                x = nums[i].toString().at(0)\\n                y = nums[j].toString().at(-1)\\n                if (gcd(x, y) == 1) count ++ \\n            }\\n        }\\n    }\\n\\n    return count\\n\\n    function gcd(x, y) {\\n        min = Math.min(x, y) \\n        while (min >= 1) {\\n            if (x % min == 0 && y % min == 0) return min\\n            min --\\n        }\\n    }\\n};", "var countBeautifulPairs = function(nums) {\\n    let count = 0\\n\\n    const gcd = (num1, num2) => {\\n        let max = Math.max(num1, num2)\\n        const root = Math.floor(max/2)\\n\\n        if(num1 === num2 && num1 > 1) return false\\n\\n        for(let i = 2; i <= root; ++i) {\\n            if(num1 % i == 0 && num2 % i == 0) return false\\n        }\\n\\n        return true\\n    }\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        for(let j = i + 1; j < nums.length; ++j) {\\n            let firstDigit = +String(nums[i])[0]\\n            let lastDigit = nums[j] % 10\\n            if(gcd(firstDigit, lastDigit)) {\\n                count++\\n            }\\n        }\\n    }\\n\\n    return count\\n\\n};", "var countBeautifulPairs = function(nums) {\\n    count = 0\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < nums.length; j++) {\\n            if (i != j) {\\n                x = nums[i].toString().at(0)\\n                y = nums[j].toString().at(-1)\\n                if (gcd(x, y) == 1) count ++ \\n            }\\n        }\\n    }\\n\\n    return count\\n\\n    function gcd(x, y) {\\n        min = Math.min(x, y) \\n        while (min >= 1) {\\n            if (x % min == 0 && y % min == 0) return min\\n            min --\\n        }\\n    }\\n};"]}
{"id": "600", "ref_js": ["var longestAlternatingSubarray = function(nums, threshold) {\\n    let start = null;\\n    let end = null;\\n    let isPrevEven = null;\\n    let i=0;\\n    let maxLength = 0;\\n    if(nums.length === 0){\\n        return null;\\n    }\\n    while(i<nums.length){\\n        if(nums[i] <= threshold){\\n            if(nums[i] % 2 === 0){\\n                if(start === null){\\n                    start = i;\\n                } else {\\n                    if(isPrevEven){\\n                        end = i-1\\n                        if(start !== null){\\n                            maxLength = Math.max(maxLength, ((end-start)+1));\\n                        }\\n                        ", "var longestAlternatingSubarray = function(nums, threshold) {\\n    counter = -1\\n    index = -1\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (index == -1 && nums[i] % 2 == 0) index = i\\n        if (nums[i] > threshold) index = -1\\n        if (index >= 0) counter = Math.max(i - index, counter)\\n        if (i < nums.length - 1 && nums[i] % 2 == nums[i + 1] % 2) index = -1\\n    }\\n\\n    return counter + 1\\n};", "var longestAlternatingSubarray = function(nums, threshold) {\\n    counter = -1\\n    index = -1\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (index == -1 && nums[i] % 2 == 0) index = i\\n        if (nums[i] > threshold) index = -1\\n        if (index >= 0) counter = Math.max(i - index, counter)\\n        if (i < nums.length - 1 && nums[i] % 2 == nums[i + 1] % 2) index = -1\\n    }\\n\\n    return counter + 1\\n};"]}
{"id": "601", "ref_js": ["var alternatingSubarray = function(nums) {\\n    \\n    let i=1;\\n    let max=-1; ", "var alternatingSubarray = function(nums) {\\n    \\n    let i=1;\\n    let max=-1; ", "var alternatingSubarray = function(nums) {\\n    \\n    let i=1;\\n    let max=-1; "]}
{"id": "602", "ref_js": ["var theMaximumAchievableX = function(num, t) {\\n    return (num+t+t);\\n};", "var theMaximumAchievableX = function(num, t) {\\n    return num + t + t;\\n};", "var theMaximumAchievableX = function(num, t) {\\n    return num+2*t;\\n};"]}
{"id": "603", "ref_js": ["var sumOfSquares = function(nums) {\\n    sum = 0; \\n\\n    for (let i=0; i<nums.length; i++) {\\n        if (nums.length % (i+1) == 0) {\\n            sum += nums[i] ** 2\\n        }\\n    }\\n\\n    return sum\\n};", "var sumOfSquares = function(nums) {\\n    n = nums.length;\\n    ans = 0;\\n    \\n    for (let i=0; i<n; i++) {\\n        if (n % (i + 1) === 0 ) {\\n            ans += nums[i] ** 2;\\n        }\\n    }\\n    return ans;\\n};", "var sumOfSquares = function(nums) {\\n    n = nums.length;\\n    ans = 0;\\n    \\n    for (let i=0; i<n; i++) {\\n        if (n % (i + 1) === 0 ) {\\n            ans += nums[i] ** 2;\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "604", "ref_js": ["var isGood = function(nums) {\\n        let n = Math.max(...nums);\\n    let freq_map = Array(n + 1).fill(0);\\n    for(let num of nums) {\\n        freq_map[num] += 1;\\n    }\\n    if(freq_map[n] !== 2) {\\n        return false;\\n    }\\n    for(let i = 1; i < n; i++) {\\n        if(freq_map[i] !== 1) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};", "var isGood = function(nums) {\\n    nums.sort((a, b) => a - b)\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums.at(i) != i + 1) return false\\n    }\\n\\n    if (nums.at(-1) != nums.at(-2)) return false\\n    return true\\n};", "var isGood = function(nums) {\\n        let n = Math.max(...nums);\\n    let freq_map = Array(n + 1).fill(0);\\n    for(let num of nums) {\\n        freq_map[num] += 1;\\n    }\\n    if(freq_map[n] !== 2) {\\n        return false;\\n    }\\n    for(let i = 1; i < n; i++) {\\n        if(freq_map[i] !== 1) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};"]}
{"id": "605", "ref_js": ["var splitWordsBySeparator = function (words, separator) {\\n     return words.join(separator).split(separator).filter(Boolean)\\n};", "var splitWordsBySeparator = function(words, separator) {\\n    return words.join(separator).split(separator).filter(e=>e.length)\\n};", "var splitWordsBySeparator = function (words, separator) {\\n  const res = []\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const splited = words[i].split(separator)\\n    const filtered = splited.filter(item => item.length > 0)\\n    res.push(...filtered)\\n  }\\n\\n  return res\\n};"]}
{"id": "606", "ref_js": ["var numberOfEmployeesWhoMetTarget = function(hours, target) {\\n    let count = 0;\\n    for (let hour of hours) {\\n        if (hour >= target) count++;\\n    }\\n    return count;\\n};", "var numberOfEmployeesWhoMetTarget = function(hours, target) {\\n    let count = 0;\\n    for(let i=0; i<hours.length; i++) {\\n        if(hours[i] >= target) count++;\\n    }\\n    return count;\\n};", "var numberOfEmployeesWhoMetTarget = function(hours, target) {\\n    let count = 0;\\n    for(let i=0; i<hours.length; i++) {\\n        if(hours[i] >= target) count++;\\n    }\\n    return count;\\n};"]}
{"id": "607", "ref_js": ["var accountBalanceAfterPurchase = function(purchaseAmount) {\\n    let rem = purchaseAmount % 10;\\n    if (rem < 5)\\n        purchaseAmount = purchaseAmount - rem;\\n    else\\n        purchaseAmount = purchaseAmount + (10 - rem);\\n\\n    return 100 - purchaseAmount;\\n};", "var accountBalanceAfterPurchase = function(purchaseAmount) {\\n    return 100 - Math.round(purchaseAmount / 10) * 10\\n};", "var accountBalanceAfterPurchase = function(purchaseAmount) {\\n    const biggerAmount = purchaseAmount + (10 - (purchaseAmount%10))\\n    const smallerAmount = Math.abs(purchaseAmount )- (purchaseAmount%10)\\n     if(biggerAmount - purchaseAmount <= 5) {\\n        return 100 - biggerAmount;\\n    }\\n    return 100-smallerAmount;\\n\\n};"]}
{"id": "608", "ref_js": ["var finalString = function (s) {\\n  let a = []\\n  for (let e of s) {\\n    if (e === \\'i\\') {\\n      a.reverse()\\n    } else {\\n      a.push(e)\\n    }\\n  }\\n  return a.join(\"\")\\n};", "var finalString = function(s) {\\n  let \\n    str = \\'\\',\\n    revStr = \\'\\';\\n\\n  for(let i = 0; i < s.length; i++) {\\n    if(s[i] === \\'i\\') {\\n      [str, revStr] = [revStr, str];\\n    } else {\\n      str += s[i];\\n      revStr = s[i] + revStr;\\n    }\\n  }\\n  \\n  return str;\\n};", "var finalString = function (s) {\\n    const sArray = [];\\n\\n    for (char of s) {\\n        char === \\'i\\'\\n            ? sArray.reverse()\\n            : sArray.push(char);\\n    }\\n    \\n    return sArray.join(\\'\\');\\n};"]}
{"id": "609", "ref_js": ["var maxSum = function(nums) {\\n    let maxSum = -1;\\n    let tempArray = new Array(nums.length).fill(0);\\n    for(let x = 0 ; x < nums.length ; x++){\\n        tempArray[x] = Math.max(...[...nums[x]+\\'\\']);\\n    }\\n    for(let x = 0 ; x < nums.length-1 ; x++){\\n        for(let y = x+1; y < nums.length ; y++){\\n           if(tempArray[x] == tempArray[y]){\\n               maxSum = Math.max(maxSum,nums[x]+nums[y]);\\n           } \\n        }\\n    } \\n    return maxSum; \\n};", "var maxSum = function(nums) {\\n    let maxSum = -1;\\n    let tempArray = new Array(nums.length).fill(0);\\n    for(let x = 0 ; x < nums.length ; x++){\\n        tempArray[x] = Math.max(...[...nums[x]+\\'\\']);\\n    }\\n    for(let x = 0 ; x < nums.length-1 ; x++){\\n        for(let y = x+1; y < nums.length ; y++){\\n           if(tempArray[x] == tempArray[y]){\\n               maxSum = Math.max(maxSum,nums[x]+nums[y]);\\n           } \\n        }\\n    } \\n    return maxSum; \\n};", "var maxSum = function(nums) {\\n    let maxSum = -1;\\n    let tempArray = new Array(nums.length).fill(0);\\n    for(let x = 0 ; x < nums.length ; x++){\\n        tempArray[x] = Math.max(...[...nums[x]+\\'\\']);\\n    }\\n    for(let x = 0 ; x < nums.length-1 ; x++){\\n        for(let y = x+1; y < nums.length ; y++){\\n           if(tempArray[x] == tempArray[y]){\\n               maxSum = Math.max(maxSum,nums[x]+nums[y]);\\n           } \\n        }\\n    } \\n    return maxSum; \\n};"]}
{"id": "610", "ref_js": ["var addTwoNumbers = function(l1, l2) {\\n   \\n    \\n    const recCalculator=(n1,n2,carry)=>{\\n        if(!n1 && !n2 && !carry) return null\\n        const sum=(n1?.val||0)+(n2?.val||0)+carry\\n        const nextNode= recCalculator(n1?.next, n2?.next,Math.floor(sum/10))\\n        return  new ListNode(sum%10,nextNode)\\n    }\\n    \\n\\n    return recCalculator(l1,l2,0)\\n\\n};", "var addTwoNumbers = function(l1, l2) {\\n    const iter = (n1, n2, rest = 0) => {\\n        if (!n1 && !n2 && !rest) return null;\\n        const newVal = (n1?.val || 0) + (n2?.val || 0) + rest;\\n        const nextNode = iter(n1?.next, n2?.next, Math.floor(newVal / 10));\\n        return new ListNode(newVal % 10, nextNode);\\n    }\\n    return iter(l1, l2);\\n};", "var addTwoNumbers = function(l1, l2, carry) {\\n    if(!l1 && !l2 && !carry) return null;\\n\\n    var total = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + (carry || 0);\\n    carry = parseInt(total / 10);\\n    return new ListNode(total % 10, addTwoNumbers(l1?.next, l2?.next, carry));\\n};"]}
{"id": "611", "ref_js": ["var lengthOfLongestSubstring = function(s) {\\n    let ans = 0, l = 0, r = 0;\\n    let n = s.length;\\n    let map = new Array(256).fill(-1);\\n    while (r < n) {\\n        if (map[s.charCodeAt(r)] != -1) {\\n            l = Math.max(map[s.charCodeAt(r)] + 1, l);\\n        }\\n        map[s.charCodeAt(r)] = r;\\n        ans = Math.max(ans, r - l + 1);\\n        r++;\\n    }\\n    return ans;\\n};", "var lengthOfLongestSubstring = function(s) {\\n    let ans = 0, l = 0, r = 0;\\n    let n = s.length;\\n    let map = new Array(256).fill(-1);\\n    while (r < n) {\\n        if (map[s.charCodeAt(r)] != -1) {\\n            l = Math.max(map[s.charCodeAt(r)] + 1, l);\\n        }\\n        map[s.charCodeAt(r)] = r;\\n        ans = Math.max(ans, r - l + 1);\\n        r++;\\n    }\\n    return ans;\\n};", "var lengthOfLongestSubstring = function(s) {\\n    let ans = 0, l = 0, r = 0;\\n    let n = s.length;\\n    let map = new Array(256).fill(-1);\\n    while (r < n) {\\n        if (map[s.charCodeAt(r)] != -1) {\\n            l = Math.max(map[s.charCodeAt(r)] + 1, l);\\n        }\\n        map[s.charCodeAt(r)] = r;\\n        ans = Math.max(ans, r - l + 1);\\n        r++;\\n    }\\n    return ans;\\n};"]}
{"id": "612", "ref_js": ["var longestPalindrome = function(s) {\\n    ", "var longestPalindrome = function(s) {\\n    if (!s) {\\n        return \"\";\\n    }\\n\\n    function expandAroundCenter(s, left, right) {\\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        return right - left - 1;\\n    }\\n\\n    let start = 0;\\n    let end = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const odd = expandAroundCenter(s, i, i);\\n        const even = expandAroundCenter(s, i, i + 1);\\n        const max_len = Math.max(odd, even);\\n\\n        if (max_len > end - start) {\\n            start = i - Math.floor((max_len - 1) / 2);\\n            end = i + Math.floor(max_len / 2);\\n        }\\n    }\\n\\n    return s.substring(start, end + 1);    \\n};", "var longestPalindrome = function(s) {\\n    "]}
{"id": "613", "ref_js": ["var reformatDate = function (str) {\\n    const monthsMapping = {\\n        Jan: \\'01\\',\\n        Feb: \\'02\\',\\n        Mar: \\'03\\',\\n        Apr: \\'04\\',\\n        May: \\'05\\',\\n        Jun: \\'06\\',\\n        Jul: \\'07\\',\\n        Aug: \\'08\\',\\n        Sep: \\'09\\',\\n        Oct: \\'10\\',\\n        Nov: \\'11\\',\\n        Dec: \\'12\\'\\n    };", "var reformatDate = function(date) {\\n    let [day, month, year] = date.split(\\' \\');\\n    day = day.slice(0, day.length - 2);\\n\\n    if (day.length < 2) {\\n        day += \\'0\\';\\n        day = day.split(\"\").reduce((acc, char) => char + acc, \"\");\\n    };", "var reformatDate = function(date) {\\n    let dform=[]\\n    let [day,month,year]=date.split(\\' \\')\\n   \\n    dform.push(year)\\n    dform.push(\\'-\\')\\n\\n    monthfom={Jan:\\'01\\',Feb:\\'02\\',Mar:\\'03\\',Apr:\\'04\\',May:\\'05\\',Jun:\\'06\\',Jul:\\'07\\',Aug:\\'08\\',Sep:\\'09\\',Oct:\\'10\\',Nov:\\'11\\',Dec:\\'12\\'}\\n    dform.push(monthfom[month])\\n    dform.push(\\'-\\')\\n\\n    if(day.length==4)\\n     dform.push(day.slice(0,2))\\n     else\\n      dform.push((\\'0\\'+day[0]))\\n     \\n\\n    return dform.join(\\'\\')\\n};"]}
{"id": "614", "ref_js": ["var reverse = function(x) {\\n\\n    let bit = Math.pow(2,31) - 1   \\n\\n    let rev= x.toString().split(\\'\\').reverse().join(\\'\\') \\n \\n    let result = parseInt(rev)\\n\\n    if(result > (bit) || result < -(bit)){\\n        return 0\\n    }\\n\\n    if(x<0){\\n        return -result\\n    }else{\\n        return result\\n    }\\n};", "var reverse = function(x) {\\n\\n    let bit = Math.pow(2,31) - 1   \\n\\n    let rev= x.toString().split(\\'\\').reverse().join(\\'\\') \\n \\n    let result = parseInt(rev)\\n\\n    if(result > (bit) || result < -(bit)){\\n        return 0\\n    }\\n\\n    if(x<0){\\n        return -result\\n    }else{\\n        return result\\n    }\\n};", "var reverse = function(x) {\\n\\n    let bit = Math.pow(2,31) - 1   \\n\\n    let rev= x.toString().split(\\'\\').reverse().join(\\'\\') \\n \\n    let result = parseInt(rev)\\n\\n    if(result > (bit) || result < -(bit)){\\n        return 0\\n    }\\n\\n    if(x<0){\\n        return -result\\n    }else{\\n        return result\\n    }\\n};"]}
{"id": "615", "ref_js": ["var myAtoi = function(s) {\\n      let res = parseInt(s)\\n    if (isNaN(res)) return 0;\\n    if(res > Math.pow(2, 31)-1) {\\n        return Math.pow(2, 31)-1;\\n    } else if(res < -1*Math.pow(2, 31)) {\\n        return -1*Math.pow(2, 31);\\n    } else {\\n        return res;\\n    }\\n};", "var myAtoi = function(s) {\\n    let temp;\\nlet ans=\"\";\\nlet minus=false;\\nlet plus=false;\\nfor(let i=0;i<s.length;i++){\\n    temp=parseInt(s[i])\\n    if(isNaN(temp)){\\n        if(s[i]==\" \" && plus==true) {\\n            break\\n        }\\n        if(s[i]==\" \" && minus==true) {\\n            break\\n        }\\n        if(s[i]==\" \" && ans.length!==0) {\\n            break\\n        }\\n        if(s[i]==\"+\" && ans.length!==0) {\\n            break\\n        }\\n        if(s[i]==\"-\" && ans.length!==0) {\\n            break\\n        }\\n        if(s[i]==\" \"){\\n            continue;\\n        }\\n        if(s[i]==\"+\" && plus===true){\\n            break;\\n        }\\n        if(s[i]==\"-\" && minus===true){\\n            break;\\n        }\\n        if(s[i]==\"+\") {\\n            plus=true;\\n            continue;\\n        } \\n            \\n        else if(ans.length===0 && s[i]==\"-\") minus=true;\\n        else{\\n            break;\\n        }\\n    }\\n\\n    else{\\n        ans=ans+s[i]\\n    }\\n\\n}\\nif(ans.length===0){\\n    return 0;\\n}\\nif(plus==true && minus==true){\\n    return 0;\\n}\\nans=parseInt(ans);\\nif(minus===true){\\n  ans=-1*ans;\\n}\\nif(ans<-(2**31)){\\nreturn (-1*(2**31))\\n}\\nif(ans>(2**31)-1){\\n    return((2**31)-1);\\n}\\n\\nreturn ans;\\n};", "var myAtoi = function(s) {\\n      let res = parseInt(s)\\n    if (isNaN(res)) return 0;\\n    if(res > Math.pow(2, 31)-1) {\\n        return Math.pow(2, 31)-1;\\n    } else if(res < -1*Math.pow(2, 31)) {\\n        return -1*Math.pow(2, 31);\\n    } else {\\n        return res;\\n    }\\n};"]}
{"id": "616", "ref_js": ["var maxArea = function(height) {\\n    let [left, right, maxArea] = [0, height.length - 1, 0];\\n\\n    while(left < right) {\\n        let containerHeight, currentArea;\\n        let containerWidth = right - left;\\n\\n        if(height[left] < height[right]) {\\n            containerHeight = height[left];\\n            left++\\n        } else {\\n            containerHeight = height[right];\\n            right--\\n        }\\n\\n        currentArea = containerWidth * containerHeight;\\n\\n        if(currentArea > maxArea) {\\n            maxArea = currentArea\\n        }\\n    }\\n\\n    return maxArea\\n};", "var maxArea = function(height) {\\n    let left = 0;            ", "var maxArea = function(height) {\\n      \\n        let max = 0;\\n  let left = 0;\\n  let right = height.length - 1;\\n\\n  while (left < right) {\\n    const h = Math.min(height[left], height[right]);\\n    const w = right - left;\\n    const area = h * w;\\n\\n    max = Math.max(max, area);\\n\\n    if (height[left] < height[right]) {\\n      left++;\\n    } else {\\n      right--;\\n    }\\n  }\\n\\n  return max;\\n};"]}
{"id": "617", "ref_js": ["var intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};", "var intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};", "var intToRoman = function(num) {\\n    "]}
{"id": "618", "ref_js": ["var threeSum = function(nums) {\\n    const res = []\\n    nums.sort((a, b) => a - b)\\n\\n    for (let i=0;i<nums.length;i++) {\\n        if (i > 0 && nums[i] === nums[i - 1]) {\\n            continue\\n        }\\n\\n        let l = i + 1\\n        let r = nums.length - 1\\n\\n        while (l < r) {\\n            let threeSum = nums[i] + nums[l] + nums[r]\\n\\n            if (threeSum > 0) {\\n                r--\\n            } else if (threeSum < 0) {\\n                l++\\n            } else {\\n                res.push([nums[i], nums[l], nums[r]])\\n                l++\\n\\n                while(nums[l] === nums[l - 1] && l < r) {\\n                    l++\\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n};", "var threeSum = function(nums) {\\n    const res = []\\n    nums.sort((a, b) => a - b)\\n\\n    for (let i=0;i<nums.length;i++) {\\n        if (i > 0 && nums[i] === nums[i - 1]) {\\n            continue\\n        }\\n\\n        let l = i + 1\\n        let r = nums.length - 1\\n\\n        while (l < r) {\\n            let threeSum = nums[i] + nums[l] + nums[r]\\n\\n            if (threeSum > 0) {\\n                r--\\n            } else if (threeSum < 0) {\\n                l++\\n            } else {\\n                res.push([nums[i], nums[l], nums[r]])\\n                l++\\n\\n                while(nums[l] === nums[l - 1] && l < r) {\\n                    l++\\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n};", "var threeSum = function(nums) {\\n    const res = []\\n    nums.sort((a, b) => a - b)\\n\\n    for (let i=0;i<nums.length;i++) {\\n        if (i > 0 && nums[i] === nums[i - 1]) {\\n            continue\\n        }\\n\\n        let l = i + 1\\n        let r = nums.length - 1\\n\\n        while (l < r) {\\n            let threeSum = nums[i] + nums[l] + nums[r]\\n\\n            if (threeSum > 0) {\\n                r--\\n            } else if (threeSum < 0) {\\n                l++\\n            } else {\\n                res.push([nums[i], nums[l], nums[r]])\\n                l++\\n\\n                while(nums[l] === nums[l - 1] && l < r) {\\n                    l++\\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n};"]}
{"id": "619", "ref_js": ["var threeSumClosest = function (nums, target) {\\n    let number = Infinity\\n    let Val = 0;\\n    let flag = 0;\\n    let k=0\\n    for (let i = 0; i < nums.length-2; i++) {\\n      for(let j=i+1;j<nums.length-1;j++){\\n          for(let k=j+1;k<nums.length;k++){\\n            let sum = nums[i] + nums[j] + nums[k];\\n            if (sum == target) {\\n                flag=1;\\n                Val=sum;\\n                break;\\n            }else{\\n                let diff = Math.abs(sum - target)\\n                if (diff < number) {\\n                    Val = sum;\\n                    number = diff;\\n                }\\n            }\\n          if(flag==1){\\n              break;\\n          }\\n      }\\n      if(flag==1){\\n          break;\\n      }\\n    }\\n    }\\n    return Val\\n};", "var threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; ", "var threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};"]}
{"id": "620", "ref_js": ["var letterCombinations = function(digits) {\\n    if (digits.length === 0) return [];\\n\\n    const phone_map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const output = [];\\n    backtrack(\"\", digits, phone_map, output);\\n    return output;\\n\\n    function backtrack(combination, next_digits, phone_map, output) {\\n        if (next_digits.length === 0) {\\n            output.push(combination);\\n        } else {\\n            const letters = phone_map[next_digits[0] - \\'2\\'];\\n            for (const letter of letters) {\\n                backtrack(combination + letter, next_digits.slice(1), phone_map, output);\\n            }\\n        }\\n    }\\n};", "var letterCombinations = function(digits) {\\n    const result = [];\\n    if (!digits) {\\n        return result;\\n    }\\n    const mapping = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const combination = new Array(digits.length).fill(\\'\\');\\n    backtrack(result, mapping, combination, digits, 0);\\n    return result;\\n};", "var letterCombinations = function(digits) {\\n    if (!digits.length) {\\n        return [];\\n    }\\n    \\n    const digitToLetters = {\\n        \\'2\\': \\'abc\\',\\n        \\'3\\': \\'def\\',\\n        \\'4\\': \\'ghi\\',\\n        \\'5\\': \\'jkl\\',\\n        \\'6\\': \\'mno\\',\\n        \\'7\\': \\'pqrs\\',\\n        \\'8\\': \\'tuv\\',\\n        \\'9\\': \\'wxyz\\'\\n    };"]}
{"id": "621", "ref_js": ["var fourSum = function(nums, target) {\\n    let res=[]\\n    nums.sort((a,b)=>a-b)\\n    for(let i=0;i<nums.length;i++){\\n        if(i>0 && nums[i] == nums[i-1]){\\n            continue;\\n        }\\n        let left1 = i+1;\\n        \\n        ", "var fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const ans = new Set();\\n    const n = nums.length;\\n\\n    for (let i = 0; i < n - 3; i++) {\\n        for (let j = i + 1; j < n - 2; j++) {\\n            const newTarget = target - nums[i] - nums[j];\\n            let low = j + 1, high = n - 1;\\n\\n            while (low < high) {\\n                if (nums[low] + nums[high] < newTarget) {\\n                    low++;\\n                } else if (nums[low] + nums[high] > newTarget) {\\n                    high--;\\n                } else {\\n                    ans.add([nums[i], nums[j], nums[low], nums[high]].toString());\\n                    low++;\\n                    high--;\\n                }\\n            }\\n        }\\n    }\\n\\n    return Array.from(ans).map(item => item.split(\\',\\').map(Number));\\n};", "var fourSum = function(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  const quadruplets = [];\\n  const n = nums.length;\\n  for (let i = 0; i < n - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) {\\n      continue;\\n    }\\n    for (let j = i + 1; j < n - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = n - 1;\\n      while (left < right) {\\n        const sum = BigInt(nums[i]) + BigInt(nums[j]) + BigInt(nums[left]) + BigInt(nums[right]);\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);\\n          while (left < right && nums[left] === nums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && nums[right] === nums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return quadruplets;\\n};"]}
{"id": "622", "ref_js": ["var removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};", "var removeNthFromEnd = function(head, n) {\\n    ", "var removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};"]}
{"id": "623", "ref_js": ["var generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};", "var generateParenthesis = function(n) {\\n    let output = []; \\n\\n    function generate(A = [], left = 0, right = 0) { \\n        if (A.length == 2*n) { \\n            output.push(A.join(\\'\\')); \\n            return; \\n        } \\n        if (left < n) { \\n            A.push(\\'(\\'); \\n            generate(A, left+1, right); \\n            A.pop(); \\n        } \\n        if (right < left) { \\n            A.push(\\')\\'); \\n            generate(A, left, right+1); \\n            A.pop(); \\n        } \\n    } \\n\\n    generate(); \\n    return output;                                      \\n};", "var generateParenthesis = function(n) {\\n    let output = []; \\n\\n    function generate(A = [], left = 0, right = 0) { \\n        if (A.length == 2*n) { \\n            output.push(A.join(\\'\\')); \\n            return; \\n        } \\n        if (left < n) { \\n            A.push(\\'(\\'); \\n            generate(A, left+1, right); \\n            A.pop(); \\n        } \\n        if (right < left) { \\n            A.push(\\')\\'); \\n            generate(A, left, right+1); \\n            A.pop(); \\n        } \\n    } \\n\\n    generate(); \\n    return output;                                      \\n};"]}
{"id": "624", "ref_js": ["var swapPairs = function(head) {\\n    var current = head, prev= null,temp,node1,node2,workAround;\\n    while(current) {\\n        if(!current.next) {\\n            break;\\n        }\\n        temp = current.next.next; ", "var swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};", "var swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};"]}
{"id": "625", "ref_js": ["var divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};", "var divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};", "var divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};"]}
{"id": "626", "ref_js": ["var nextPermutation = function(nums) {\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        let currentIndexSwap = i;\\n        for (let j = i + 1; j < nums.length; j++) {\\n            if ((nums[j] > nums[i] && nums[j] < nums[currentIndexSwap]) || (nums[j] > nums[currentIndexSwap] && currentIndexSwap === i)) {\\n                currentIndexSwap = j;\\n            }\\n        }\\n        if (i !== currentIndexSwap) {\\n            [nums[i], nums[currentIndexSwap]] = [nums[currentIndexSwap], nums[i]];\\n            for (let k = i + 1; k < nums.length; k++) {\\n                for (let p = k + 1; p < nums.length; p++) {\\n                    if (nums[p] < nums[k]) {\\n                        [nums[k], nums[p]] = [nums[p], nums[k]];\\n                    }\\n                }\\n            }\\n            return nums;\\n        }\\n    }\\n    return nums.sort((a, b) => a - b);\\n};", "var nextPermutation = function(nums) {\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        let currentIndexSwap = i;\\n        for (let j = i + 1; j < nums.length; j++) {\\n            if ((nums[j] > nums[i] && nums[j] < nums[currentIndexSwap]) || (nums[j] > nums[currentIndexSwap] && currentIndexSwap === i)) {\\n                currentIndexSwap = j;\\n            }\\n        }\\n        if (i !== currentIndexSwap) {\\n            [nums[i], nums[currentIndexSwap]] = [nums[currentIndexSwap], nums[i]];\\n            for (let k = i + 1; k < nums.length; k++) {\\n                for (let p = k + 1; p < nums.length; p++) {\\n                    if (nums[p] < nums[k]) {\\n                        [nums[k], nums[p]] = [nums[p], nums[k]];\\n                    }\\n                }\\n            }\\n            return nums;\\n        }\\n    }\\n\\n    return nums.sort((a, b) => a - b);\\n};", "var nextPermutation = function(nums) {\\n    const n = nums.length;\\n    "]}
{"id": "627", "ref_js": ["var search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n\\n        if (nums[mid] === target) {\\n            return mid;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};", "var search = function(nums, target) {\\n\\n    let left=0,right=nums.length-1\\n   \\n\\n    while(left<=right){\\n        const mid=Math.floor((left+right)/2)\\n        if(nums[mid]==target) return mid\\n        else if(nums[mid]>=nums[left]){\\n            if(nums[mid]>target && nums[left]<=target){\\n                right=mid-1\\n            }else{\\n                left=mid+1\\n            }\\n        }else{\\n            if(nums[mid]<target && nums[right]>=target){\\n                left=mid+1\\n\\n            }else{\\n                right=mid-1\\n\\n            }\\n        }\\n    }\\n    return -1\\n};", "var search = function(nums, target) {\\n\\n    let left=0,right=nums.length-1\\n   \\n\\n    while(left<=right){\\n        const mid=Math.floor((left+right)/2)\\n        if(nums[mid]==target) return mid\\n        else if(nums[mid]>=nums[left]){\\n            if(nums[mid]>target && nums[left]<=target){\\n                right=mid-1\\n            }else{\\n                left=mid+1\\n            }\\n        }else{\\n            if(nums[mid]<target && nums[right]>=target){\\n                left=mid+1\\n\\n            }else{\\n                right=mid-1\\n\\n            }\\n        }\\n    }\\n    return -1\\n};"]}
{"id": "628", "ref_js": ["var searchRange = function(nums, target) {\\n    const binarySearch = (nums, target, isSearchingLeft) => {\\n        let left = 0;\\n        let right = nums.length - 1;\\n        let idx = -1;\\n      \\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            \\n            if (nums[mid] > target) {\\n                right = mid - 1;\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                idx = mid;\\n                if (isSearchingLeft) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n      \\n        return idx;\\n    };", "var searchRange = function(nums, target) {\\n    let first = -1; ", "var searchRange = function(nums, target) {\\n    const binarySearch = (nums, target, isSearchingLeft) => {\\n        let left = 0;\\n        let right = nums.length - 1;\\n        let idx = -1;\\n      \\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            \\n            if (nums[mid] > target) {\\n                right = mid - 1;\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                idx = mid;\\n                if (isSearchingLeft) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n      \\n        return idx;\\n    };"]}
{"id": "629", "ref_js": ["var isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};", "var isValidSudoku = function(board) {\\n    for (let i = 0; i < 9; i++) {\\n        let row = new Set();\\n        let col = new Set();\\n\\n        for(let j = 0; j < 9; j++) {\\n            let curRow = board[i][j];\\n            let currCol = board[j][i];\\n\\n            if (curRow !== \".\") {\\n                if (row.has(curRow)) return false;\\n                row.add(curRow);\\n            }\\n\\n            if (currCol !== \".\") {\\n                if (col.has(currCol)) return false; \\n                col.add(currCol);\\n            }\\n        }\\n    }\\n    for (let i = 0; i < 9; i+=3) {\\n        for (let j = 0; j < 9; j+=3) {\\n            let box = new Set();\\n            \\n            for (let x = 0; x < 3; x++) {\\n                for (let y = 0; y < 3; y++) {\\n                    let currVal = board[i + x][j + y];\\n\\n                    if (currVal !== \".\") {\\n                        if (box.has(currVal)) return false;\\n                        box.add(currVal);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return true; \\n};", "var isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};"]}
{"id": "630", "ref_js": ["var countAndSay = function(n) { \\n    if(n==1) return \\'1\\';\\n    let str = \\'1\\';\\n    for(let i=1; i<n; i++) str = createContainers(str);\\n     \\n    return str; \\n};", "var countAndSay = function(n) {\\n    let say = \\'1\\';\\n  while (n > 1) {\\n    let count = 0;\\n    let next = \\'\\';\\n    for (let i = 0; i <= say.length; i++) {\\n      if (i === say.length || (i > 0 && say[i] !== say[i - 1])) {\\n        next += count + say[i - 1];\\n        count = 0;\\n      }\\n      count++;\\n    }\\n    say = next;\\n    n--;\\n  }\\n  return say;\\n};", "var countAndSay = function(n) {\\n    if (n === 1) return \\'1\\';\\n    \\n    const current = countAndSay(n - 1);\\n    let newOutput = \\'\\';\\n    let currentNumber = current[0];\\n    let count = 0;\\n    for (let i = 0; i <= current.length; i++) {\\n        if (current[i] === currentNumber) {\\n            count++;\\n        } else if (currentNumber) {\\n            newOutput += `${count}${currentNumber}`;\\n            \\n            currentNumber = current[i];\\n            count = 1;\\n        }\\n    }\\n    \\n    return newOutput;\\n};"]}
{"id": "631", "ref_js": ["var combinationSum = function(candidates, target) {\\n    let result = []; \\n    dfs(candidates, target, [], result); \\n    return result; \\n             \\n};", "var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };", "var combinationSum = function(candidates, target) {\\n    const output = [];\\n    const res = [];\\n    let sum = 0;\\n    solve(candidates, target, [...output], res, start = 0, sum = 0);\\n    return res;\\n};"]}
{"id": "632", "ref_js": ["var combinationSum2 = function(candidates, target) {\\n    candidates = candidates.sort((a, b) => a - b);\\n    const output = [];\\n    const hashmap = new Map();\\n\\n    const backtracking = (curr, remaining, target) => {\\n        if (target < remaining[0] || !remaining.length) return;\\n        const checkedHashmap = new Map();\\n\\n        for (let i = 0; i < remaining.length; i++) {\\n            const number = remaining[i];\\n            if (checkedHashmap.has(number)) continue;\\n            if (number > target) return;\\n\\n            const newRemaining = [...remaining];\\n            const newCurr = [...curr];\\n            newCurr.push(number);\\n            newRemaining.splice(i, 1);\\n\\n            if (target - number === 0) {\\n                const key = newCurr.sort((a, b) => a - b).toString();\\n                if (hashmap.has(key)) return;\\n                hashmap.set(key, 1);\\n                return output.push(newCurr);\\n            }\\n\\n            checkedHashmap.set(number, 1);\\n            backtracking(newCurr, newRemaining, target - number);\\n        }\\n    }\\n\\n    backtracking([], candidates, target);\\n\\n    return output;\\n};", "var combinationSum2 = function(candidates, target) {\\n    candidates.sort((a,b) => a - b);\\n    let paths = [];\\n\\n    find (target, [], 0, candidates, paths);\\n    \\n    return paths;\\n};", "var combinationSum2 = function(candidates, target) {\\n    candidates = candidates.sort((a, b) => a - b);\\n    const output = [];\\n    const hashmap = new Map();\\n\\n    const backtracking = (curr, remaining, target) => {\\n        if (target < remaining[0] || !remaining.length) return;\\n        const checkedHashmap = new Map();\\n\\n        for (let i = 0; i < remaining.length; i++) {\\n            const number = remaining[i];\\n            if (checkedHashmap.has(number)) continue;\\n            if (number > target) return;\\n\\n            const newRemaining = [...remaining];\\n            const newCurr = [...curr];\\n            newCurr.push(number);\\n            newRemaining.splice(i, 1);\\n\\n            if (target - number === 0) {\\n                const key = newCurr.sort((a, b) => a - b).toString();\\n                if (hashmap.has(key)) return;\\n                hashmap.set(key, 1);\\n                return output.push(newCurr);\\n            }\\n\\n            checkedHashmap.set(number, 1);\\n            backtracking(newCurr, newRemaining, target - number);\\n        }\\n    }\\n\\n    backtracking([], candidates, target);\\n\\n    return output;\\n};"]}
{"id": "633", "ref_js": ["var multiply = function(num1, num2) {\\n return String(BigInt(num1)*BigInt(num2));\\n};", "var multiply = function(num1, num2) {\\n return String(BigInt(num1)*BigInt(num2));\\n};", "var multiply = function(num1, num2) {\\n return String(BigInt(num1)*BigInt(num2));\\n};"]}
{"id": "634", "ref_js": ["var jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};", "var jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    ", "var jump = function(nums) {\\n    var jumpCount = 0; "]}
{"id": "635", "ref_js": ["var permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };", "var permute = function(nums) {\\n    let result = []; \\n    permuteRec(nums, 0, result); \\n    return result; \\n             \\n};", "var permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };"]}
{"id": "636", "ref_js": ["var permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};", "var permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};", "var permuteUnique = function(nums) {\\n    "]}
{"id": "637", "ref_js": ["var rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};", "var rotate = function(matrix) {\\n    const n = matrix.length;\\n    const rotated = Array(n).fill(null).map(() => Array(n).fill(0));\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n        }\\n    }\\n    ", "var rotate = function(matrix) {\\n    const n = matrix.length;\\n\\t\\n\\tfunction transpose() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tconst temp = matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i] = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction rotate() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = 0; j < n / 2; j++) {\\n\\t\\t\\t\\tconst temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n - 1 - j];\\n\\t\\t\\t\\tmatrix[i][n - 1 - j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\ttranspose(matrix);\\n\\trotate(matrix);\\n};"]}
{"id": "638", "ref_js": ["var groupAnagrams = function(strs) {\\n    let myMap = new Map();\\n    strs.forEach((ele)=>{\\n        let eleSorted = ele.split(\\'\\').sort().join(\\'\\');\\n        if(myMap.has(eleSorted)){\\n            myMap.set(eleSorted , [ele, ...myMap.get(eleSorted)])\\n        }\\n        else\\n        myMap.set(eleSorted , [ele])\\n    })\\n    return (Array.from(myMap.values()))\\n\\n};", "var groupAnagrams = function(strs) {\\n    const map = new Map();\\n    strs.forEach(str=>{\\n        const key = hash(str);\\n        if(map.has(key)){\\n            map.get(key).push(str);\\n        }else{\\n            map.set(key, [str]);\\n        }\\n    })\\n    return [...map.values()];\\n};", "var groupAnagrams = function (strs) {\\n  const hashMap = {}\\n\\n  for (let i = 0; i < strs.length; i++) {\\n    const sortedStr = strs[i].split(\\'\\').sort().join()\\n    if (!hashMap[sortedStr]) {\\n      hashMap[sortedStr] = [strs[i]]\\n    } else {\\n      hashMap[sortedStr].push(strs[i])\\n    }\\n  }\\n\\n  return Object.values(hashMap)\\n};"]}
{"id": "639", "ref_js": ["var myPow = function(x, n) {\\n    return Math.pow(x,n).toFixed(5)\\n};", "var myPow = function(x, n) {\\n  \\n  if (n === 0) {\\n    return 1;\\n  }\\n\\n  if (n < 0) {\\n    x = 1 / x;\\n    n = -n;\\n  }\\n\\n  if (n % 2 === 0) {\\n    \\n    let halfPower = myPow(x, n / 2);\\n    return halfPower * halfPower;\\n  }\\n  else {\\n    return x * myPow(x, n - 1);\\n  }  \\n};", "var myPow = function(x, n) {\\n    if(n < 0) {\\n        x = 1 / x;\\n        n = -n;\\n    }\\n\\n    let result = 1;\\n    let current_product = x;\\n\\n    while(n > 0) {\\n        if(n % 2 == 1) {\\n            result = result * current_product;\\n        }\\n        current_product = current_product * current_product;\\n        n = Math.floor(n / 2);\\n    }\\n\\n    return result;    \\n};"]}
{"id": "640", "ref_js": ["var maxSubArray = function(nums) {\\n    ", "var maxSubArray = function(nums) {\\n    const n = nums.length\\n\\n    function dfs(i) {\\n        if (i === 0) return [nums[0], nums[0]] ", "var maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let meh = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        meh += nums[i];\\n        if (meh > max) {\\n            max = meh;\\n        }\\n        if (meh < 0) {\\n            meh = 0;\\n        }\\n    }\\n    return max;\\n};"]}
{"id": "641", "ref_js": ["var spiralOrder = function(matrix) {\\n\\n    let res = []\\n    let l=0;\\n    let r=matrix[0].length;\\n    let t=0;\\n    let b=matrix.length;\\n\\n    while(l<r && t<b){\\n\\n        for(let i=l;i<r;i++){\\n            res.push(matrix[t][i])\\n        }\\n\\n        t++;\\n\\n        for(let i=t;i<b;i++){\\n            res.push(matrix[i][r-1]);\\n        }\\n\\n        r--;\\n\\n        if (!(l < r && t<b)){\\n            break;\\n        }\\n\\n        for(let i=r-1;i>=l;i--){\\n            res.push(matrix[b-1][i])\\n        }\\n\\n        b--;\\n\\n        for(let i=b-1;i>=t;i--){\\n            res.push(matrix[i][l])\\n        }\\n\\n        l++;\\n    }\\n\\n\\n    return res;\\n\\n};", "var spiralOrder = function(matrix) {\\n\\n    let res = []\\n    let l=0;\\n    let r=matrix[0].length;\\n    let t=0;\\n    let b=matrix.length;\\n\\n    while(l<r && t<b){\\n\\n        for(let i=l;i<r;i++){\\n            res.push(matrix[t][i])\\n        }\\n\\n        t++;\\n\\n        for(let i=t;i<b;i++){\\n            res.push(matrix[i][r-1]);\\n        }\\n\\n        r--;\\n\\n        if (!(l < r && t<b)){\\n            break;\\n        }\\n\\n        for(let i=r-1;i>=l;i--){\\n            res.push(matrix[b-1][i])\\n        }\\n\\n        b--;\\n\\n        for(let i=b-1;i>=t;i--){\\n            res.push(matrix[i][l])\\n        }\\n\\n        l++;\\n    }\\n\\n\\n    return res;\\n\\n};", "var spiralOrder = function(matrix) {\\n\\n    let res = []\\n    let l=0;\\n    let r=matrix[0].length;\\n    let t=0;\\n    let b=matrix.length;\\n\\n    while(l<r && t<b){\\n\\n        for(let i=l;i<r;i++){\\n            res.push(matrix[t][i])\\n        }\\n\\n        t++;\\n\\n        for(let i=t;i<b;i++){\\n            res.push(matrix[i][r-1]);\\n        }\\n\\n        r--;\\n\\n        if (!(l < r && t<b)){\\n            break;\\n        }\\n\\n        for(let i=r-1;i>=l;i--){\\n            res.push(matrix[b-1][i])\\n        }\\n\\n        b--;\\n\\n        for(let i=b-1;i>=t;i--){\\n            res.push(matrix[i][l])\\n        }\\n\\n        l++;\\n    }\\n\\n\\n    return res;\\n\\n};"]}
{"id": "642", "ref_js": ["var canJump = function(nums) {\\n    ", "var canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};", "var canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};"]}
{"id": "643", "ref_js": ["var merge = function (intervals) {\\n  const res = []\\n\\n  if (intervals.length === 0) return res\\n\\n  intervals.sort((a, b) => a[0] - b[0])\\n  let tmpInterval = intervals[0]\\n\\n  for (let i = 1; i < intervals.length; i++) {\\n    const [tmpStart, tmpEnd] = tmpInterval\\n    const [start_i, end_i] = intervals[i]\\n\\n    const low = Math.min(tmpStart, start_i)\\n    const max = Math.max(tmpEnd, end_i)\\n\\n    if (tmpEnd >= start_i) {\\n      tmpInterval = [low, max]\\n    } else {\\n      res.push(tmpInterval)\\n      tmpInterval = intervals[i]\\n    }\\n  }\\n\\n  res.push(tmpInterval)\\n\\n  return res\\n};", "var merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};", "var merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};"]}
{"id": "644", "ref_js": ["var insert = function(intervals, newInterval) {\\n    let n = intervals.length\\n\\n    if (n === 0) return [newInterval]\\n    if (newInterval[1] < intervals[0][0]) return [newInterval, ...intervals]\\n    if (newInterval[0] > intervals[n-1][1]) return [...intervals, newInterval]\\n\\n    let res = new Array()\\n    let i = 0\\n    for (i ; i < n; i++) {\\n        let s = newInterval[0]\\n        if (s > intervals[i][1]) res.push(intervals[i])\\n        else if ( s >= intervals[i][0] && s <= intervals[i][1]) {\\n            newInterval[0] = intervals[i][0]\\n            break\\n        }\\n        else if (s < intervals[i][0]) {\\n            break\\n        }\\n    }\\n\\n    for (i ; i < n; i++) {\\n        let e = newInterval[1]\\n        if (e >= intervals[i][0] && e <= intervals[i][1]) {\\n            newInterval[1] = intervals[i][1]\\n            res.push(newInterval)\\n            i++\\n            break\\n        }\\n        else if (e > intervals[i][1] && i == n-1) {\\n            res.push(newInterval)\\n        }\\n        else if (e < intervals[i][0]) {\\n            res.push(newInterval)\\n            break\\n        }\\n    }\\n\\n    for (i; i<n ; i++) {\\n        res.push(intervals[i])\\n    }\\n    return res\\n};", "var insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t", "var insert = function(intervals, newInterval) {\\n    let n = intervals.length\\n\\n    if (n === 0) return [newInterval]\\n    if (newInterval[1] < intervals[0][0]) return [newInterval, ...intervals]\\n    if (newInterval[0] > intervals[n-1][1]) return [...intervals, newInterval]\\n\\n    let res = new Array()\\n    let i = 0\\n    for (i ; i < n; i++) {\\n        let s = newInterval[0]\\n        if (s > intervals[i][1]) res.push(intervals[i])\\n        else if ( s >= intervals[i][0] && s <= intervals[i][1]) {\\n            newInterval[0] = intervals[i][0]\\n            break\\n        }\\n        else if (s < intervals[i][0]) {\\n            break\\n        }\\n    }\\n\\n    for (i ; i < n; i++) {\\n        let e = newInterval[1]\\n        if (e >= intervals[i][0] && e <= intervals[i][1]) {\\n            newInterval[1] = intervals[i][1]\\n            res.push(newInterval)\\n            i++\\n            break\\n        }\\n        else if (e > intervals[i][1] && i == n-1) {\\n            res.push(newInterval)\\n        }\\n        else if (e < intervals[i][0]) {\\n            res.push(newInterval)\\n            break\\n        }\\n    }\\n\\n    for (i; i<n ; i++) {\\n        res.push(intervals[i])\\n    }\\n    return res\\n};"]}
{"id": "645", "ref_js": ["var generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};", "var generateMatrix = function(n) {\\n    ", "var generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};"]}
{"id": "646", "ref_js": ["var rotateRight = function(head, k) {\\n    let len=0,\\n        dummy=head,\\n        temp;\\n\\n    while(dummy){               ", "var rotateRight = function (head, k) {\\n\\tif (!head) return head;\\n\\tlet count = 0,\\n\\t\\tptr = head;\\n\\n\\t", "var rotateRight = function(head, k) {\\n\\n    if (!head || !head.next) return head;\\n    \\n    let tail = head;\\n\\n    let length = 1;\\n    \\n    while (tail.next) {\\n\\n        tail = tail.next;\\n\\n        length++;\\n\\n    }\\n\\n    tail.next = head;\\n\\n    k = length - k % length;\\n\\n    for (let i = 0; i < k; i++) {\\n\\n    tail = tail.next;\\n\\n    head = tail.next;\\n    \\n    }\\n    \\n    tail.next = null;\\n    \\n    return head;\\n\\n};"]}
{"id": "647", "ref_js": ["var uniquePaths = function(m, n) {\\n    let ans = 1;\\n    for (let i = 1; i <= m - 1; i++) {\\n        ans = ans * (n - 1 + i) / i;\\n    }\\n    return ans;\\n};", "var uniquePaths = function(m, n) {\\n    ", "var uniquePaths = function(m, n) {\\n    let aboveRow = Array(n).fill(1);\\n\\n    for (let row = 1; row < m; row++) {\\n        let currentRow = Array(n).fill(1);\\n        for (let col = 1; col < n; col++) {\\n            currentRow[col] = currentRow[col - 1] + aboveRow[col];\\n        }\\n        aboveRow = currentRow;\\n    }\\n\\n    return aboveRow[n - 1];    \\n};"]}
{"id": "648", "ref_js": ["var uniquePathsWithObstacles = function(obstacleGrid) {\\n let m = obstacleGrid.length;\\n  let n = obstacleGrid[0].length;\\n  let memo = new Map();\\nif (m === 1 && n === 1) {\\n    if (obstacleGrid[0][0] === 1) {\\n      return 0;\\n    }\\n    return 1;\\n  }\\n\\n  const getAllPaths = (row, column) => {\\n    if (row === 0 && column === 0) {\\n     if (obstacleGrid[0][0] === 1) {\\n       return 0;\\n     }\\n     return 1;\\n    }\\n    if (row < 0 || column < 0 || obstacleGrid[row][column] === 1) {\\n      return 0;\\n    }\\n    if (memo.has(row + \"_\" + column)) {\\n      return memo.get(row + \"_\" + column);\\n    }\\n\\n    let up = getAllPaths(row - 1, column);\\n    let left = getAllPaths(row, column - 1);\\n    memo.set(row + \"_\" + column, up + left);\\n    return up + left;\\n  };", "var uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    const rows = obstacleGrid.length;\\n    const cols = obstacleGrid[0].length;\\n    const dp = new Array(cols).fill(0);\\n    dp[0] = 1;\\n\\n    for (let r = 0; r < rows; r++) {\\n        for (let c = 0; c < cols; c++) {\\n            if (obstacleGrid[r][c] === 1) {\\n                dp[c] = 0;\\n            } else {\\n                if (c > 0) {\\n                    dp[c] += dp[c - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[cols - 1];    \\n};", "var uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    const rows = obstacleGrid.length;\\n    const cols = obstacleGrid[0].length;\\n    const dp = new Array(cols).fill(0);\\n    dp[0] = 1;\\n\\n    for (let r = 0; r < rows; r++) {\\n        for (let c = 0; c < cols; c++) {\\n            if (obstacleGrid[r][c] === 1) {\\n                dp[c] = 0;\\n            } else {\\n                if (c > 0) {\\n                    dp[c] += dp[c - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[cols - 1];    \\n};"]}
{"id": "649", "ref_js": ["var minPathSum = function(grid) {\\n    for (let row = 0; row < grid.length; row++) {\\n        for (let col = 0; col < grid[row].length; col++) {\\n            if (row === 0 && col === 0) continue\\n            \\n            const left = col > 0 ? grid[row][col - 1] : Infinity\\n            const top = row > 0 ? grid[row - 1][col] : Infinity\\n            grid[row][col] = Math.min(left + grid[row][col], top + grid[row][col])\\n        }\\n    }\\n\\n    return grid[grid.length - 1][grid[0].length - 1]\\n};", "var minPathSum = function(grid) {\\n    const minGrid = grid.map(row => row.map(_ => Infinity))\\n    const m = grid.length - 1\\n    const n = grid[0].length - 1 \\n    \\n    function getMin(x, y) {\\n        let right = Infinity\\n        let down = Infinity\\n        if (x === m && y === n) {\\n            return grid[x][y]\\n        }\\n        if (minGrid[x][y] !== Infinity) {\\n            return minGrid[x][y]\\n        }\\n        if (x !== m) { ", "var minPathSum = function (grid) {\\n  let previousRow = Array(grid[0].length).fill(Infinity);\\n  previousRow[previousRow.length - 1] = 0;\\n\\n  for (let row = grid.length - 1; row >= 0; row--) {\\n    const currentRow = Array(grid[0].length).fill(0);\\n\\n    for (let col = grid[0].length - 1; col >= 0; col--) {\\n      const bottomCell = previousRow[col];\\n      const rightCell = currentRow[col + 1] ?? Infinity;\\n\\n      currentRow[col] = Math.min(bottomCell, rightCell) + grid[row][col];\\n    }\\n    previousRow = currentRow;\\n  }\\n\\n  return previousRow[0];\\n};"]}
{"id": "650", "ref_js": ["var simplifyPath = function(path) {\\n    ", "var simplifyPath = function(path) {\\n    const stack = [];\\n    const directories = path.split(\"/\");\\n    for (const dir of directories) {\\n        if (dir === \".\" || !dir) {\\n            continue;\\n        } else if (dir === \"..\") {\\n            if (stack.length > 0) {\\n                stack.pop();\\n            }\\n        } else {\\n            stack.push(dir);\\n        }\\n    }\\n    return \"/\" + stack.join(\"/\");\\n};", "var simplifyPath = function(path) {\\n    "]}
{"id": "651", "ref_js": ["var minDistance = function(word1, word2) {\\nconst m = word1.length;\\n  const n = word2.length;\\n\\n  ", "var minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};", "var minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};"]}
{"id": "652", "ref_js": ["var setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};", "var setZeroes = function(matrix) {\\n    let rows = [], cols = [];\\n\\n    for (let i=0; i<matrix.length; i++){\\n        for (let j=0; j<matrix[i].length; j++){\\n            if (matrix[i][j]===0) {\\n                rows.push(i);\\n                cols.push(j);\\n            }\\n        }\\n    }\\n\\n    for (let i=0; i<rows.length; i++){\\n        for (let j=0; j<matrix[0].length; j++){\\n            matrix[rows[i]][j] = 0;\\n        }\\n    }\\n\\n    for (let i=0; i<matrix.length; i++){\\n        for (let j=0; j<cols.length; j++){\\n            matrix[i][cols[j]] = 0;\\n        }\\n    }\\n\\n    return matrix;\\n    \\n};", "var setZeroes = function(matrix) {\\n    const m = matrix.length;"]}
{"id": "653", "ref_js": ["var searchMatrix = function(matrix, target) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    let left = 0, right = m * n - 1;\\n\\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        let mid_val = matrix[Math.floor(mid / n)][mid % n];\\n\\n        if (mid_val === target)\\n            return true;\\n        else if (mid_val < target)\\n            left = mid + 1;\\n        else\\n            right = mid - 1;\\n    }\\n    return false;\\n};", "var searchMatrix = function (matrix, target) {\\n    let start = 0;\\n    let m = matrix[0].length;\\n    let end = (matrix.length * m) - 1;\\n    while (start <= end) {\\n        let mid = parseInt((start + end) / 2);\\n        console.log(mid);\\n        if (matrix[Math.floor(mid / m)][mid % m] == target) {\\n            return true;\\n        } else if (matrix[Math.floor(mid / m)][mid % m] > target) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n\\n\\n\\n    }\\n    return false;\\n};", "var searchMatrix = function(matrix, target) {\\n    let [rows, cols] = [matrix.length, matrix[0].length];\\n    let [top, bot] = [0, rows-1];\\n    \\n    while(top <= bot){\\n        let row = Math.floor((top +  bot) / 2);\\n        if(target > matrix[row][cols-1]) {\\n            top = row + 1;\\n        } else if(target < matrix[row][0]) {\\n            bot = row - 1; \\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    if(!(top <= bot)) {\\n        return false;\\n    }\\n    \\n    let row = Math.floor((top + bot) / 2);\\n    let [left, right] = [0, cols - 1];\\n\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n\\n        if(target > matrix[row][mid]) {\\n            left = mid + 1;\\n        } else if(target < matrix[row][mid]) {\\n            right = mid - 1;\\n        } else if(target == matrix[row][mid]) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};"]}
{"id": "654", "ref_js": ["var sortColors = function(nums) {\\n    ", "var sortColors = function(nums) {\\n    num = new Array(3).fill(0);\\n    for(i = 0 ; i < nums.length ; i++){\\n        num[nums[i]]++\\n    }\\n    pos = 0\\n    for(i = 0 ; i < 3 ; i++){\\n        for (j = 0; j < num[i]; j++) {\\n            nums[pos] = i;\\n            pos++\\n        }\\n    }\\n};", "var sortColors = function(nums) {\\n    for (let i = nums.length - 1; i > 0; i--) {\\n        for (let j = 0; j <= i - 1; j++) {\\n            if (nums[j] > nums[j + 1]) {\\n                let temp = nums[j + 1];\\n                nums[j + 1] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n    }\\n};"]}
{"id": "655", "ref_js": ["var combine = function (n, k) {\\n  let res = [];\\n  const backtrack = (combo, start) => {\\n    if (combo.length === k) {\\n      res.push([...combo]);\\n      return;\\n    }\\n    ", "var combine = function(n, k) {\\n    const result = [];\\n    generateCombinations(1, n, k, [], result);\\n    return result;\\n};", "var combine = function (n, k) {\\n  let res = [];\\n  const backtrack = (combo, start) => {\\n    if (combo.length === k) {\\n      res.push([...combo]);\\n      return;\\n    }\\n    "]}
{"id": "656", "ref_js": ["var subsets = function(nums) {\\n    const output = [[]];\\n    const hashmap = new Map();\\n    \\n    const backtracking = (curr, remaining, target) => {\\n        if (!target) {\\n            const key = curr.sort((a, b) => a - b).toString();\\n            if (!hashmap.has(key)) {\\n                output.push(curr);\\n                hashmap.set(key, 1);\\n            }\\n            return;\\n        }\\n\\n        for (let i = 0; i < remaining.length; i++) {\\n            const item = remaining[i];\\n            const newCurr = [...curr];\\n            const newRemaining = [...remaining];\\n\\n            newCurr.push(item);\\n            newRemaining.splice(0, i + 1)\\n\\n            backtracking(newCurr, newRemaining, target - 1);\\n        }\\n    }\\n\\n    for (let i = 1; i <= nums.length; i++) {\\n        backtracking([], nums, i);\\n    }\\n\\n    return output;\\n};", "var subsets = function(nums) {\\n\\tlet res=[]                    ", "var subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        "]}
{"id": "657", "ref_js": ["var exist = function(board, word) {\\n    return isValidByAvailableSymbols(board, word) && isValidForSegmentsOfWord(board, word)\\n        ? checkPhrase(board, word)\\n        : false;\\n};", "var exist = function(board, word) {\\n    let i = -1\\n    while (++i < board.length) {\\n        let j = -1\\n        while (++j < board[0].length) {\\n            if (dfs(board, word, 0, i, j))\\n                return true\\n        }\\n    }\\n    return false\\n};", "var exist = function(board, word) {\\n    return isValidByAvailableSymbols(board, word) && isValidForSegmentsOfWord(board, word)\\n        ? checkPhrase(board, word)\\n        : false;\\n};"]}
{"id": "658", "ref_js": ["var removeDuplicates = function(nums) {\\n    ", "var removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};", "var removeDuplicates = function(nums) {\\n    "]}
{"id": "659", "ref_js": ["var search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        \\n        if (nums[mid] === target) {\\n            return true;\\n        }\\n        \\n        if (nums[mid] === nums[left]) {\\n            left++;\\n            continue;\\n        }\\n        \\n        if (nums[left] <= nums[mid]) {\\n            if (nums[left] <= target && target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n    }\\n    \\n    return false;    \\n};", "var search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while (start <= end) {\\n        let mid = start + Math.floor((end - start) / 2);\\n        if (target === nums[mid]) {\\n            return true;\\n        } else if (nums[start] < nums[mid]) {\\n            if (nums[start] <= target && nums[mid] > target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else if (nums[mid] < nums[start]) {\\n            if (nums[end] >= target && nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start += 1;\\n        }\\n    }\\n\\n    return false;\\n};", "var search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while (start <= end) {\\n        let mid = start + Math.floor((end - start) / 2);\\n        if (target === nums[mid]) {\\n            return true;\\n        } else if (nums[start] < nums[mid]) {\\n            if (nums[start] <= target && nums[mid] > target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else if (nums[mid] < nums[start]) {\\n            if (nums[end] >= target && nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start += 1;\\n        }\\n    }\\n\\n    return false;\\n};"]}
{"id": "660", "ref_js": ["var deleteDuplicates = function(head) {\\n    ", "var deleteDuplicates = function(head) {\\n    if (!head || !head.next) return head;\\n\\n    const home = new ListNode(null);\\n    home.next = head;\\n\\n    let conector = home;\\n\\n    while (head && head.next) {\\n      if (head.val !== head.next.val) {\\n        conector = conector.next;\\n      } else {\\n        while (head.next && head.val === head.next.val) {\\n          head = head.next;\\n        }\\n        conector.next = head.next;\\n      }\\n\\n      head = head.next;\\n    }\\n\\n    return home.next;\\n\\n};", "var deleteDuplicates = function(head) {\\n    "]}
{"id": "661", "ref_js": ["var partition = function(head, x) {\\n    let before = new ListNode(0);\\n    let after = new ListNode(0);\\n    let before_curr = before;\\n    let after_curr = after;\\n    \\n    while(head !== null) {\\n        if(head.val < x) {\\n            before_curr.next = head;\\n            before_curr = before_curr.next;\\n        } else {\\n            after_curr.next = head;\\n            after_curr = after_curr.next;\\n        }\\n        head = head.next;\\n    }\\n    \\n    after_curr.next = null;\\n    before_curr.next = after.next;\\n    \\n    return before.next;\\n};", "var partition = function(head, x) {\\n    let slist = new ListNode();\\n    let blist = new ListNode();\\n    let small = slist;\\n    let big = blist;\\n\\n    while (head !== null) {\\n        if (head.val < x) {\\n            small.next = head;\\n            small = small.next;\\n        } else {\\n            big.next = head;\\n            big = big.next;\\n        }\\n\\n        head = head.next;\\n    }\\n\\n    small.next = blist.next;\\n    big.next = null;\\n\\n    return slist.next;    \\n};", "var partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};"]}
{"id": "662", "ref_js": ["var grayCode = function(n) {\\n\\n    ", "var grayCode = function(n) {\\n    let size = Math.pow(2, n) - 1;\\n    let res = new Array(size);\\n    res[0] = 0;\\n    for(let i = 1; i <= n; i++){\\n        let left = 0;\\n        let sum = Math.pow(2, i - 1);\\n        let right = Math.pow(2, i) - 1;\\n        while(left < right){\\n            res[right] = res[left] + sum;\\n            right--; left++;\\n        }\\n    }\\n\\n    return res;\\n};", "var grayCode = function(n) {\\nlet ans = [0];\\nfor(let i = 0; i < n; i++){\\n    for(let j = ans.length - 1; j > -1; j--)\\n        ans.push(ans[j] + Math.pow(2, i));\\n  }\\nreturn ans;    \\n};"]}
{"id": "663", "ref_js": ["var subsetsWithDup = function(nums) {\\n    const result = [];\\n    nums.sort();\\n    \\n    const dfs = (arr, i) => {\\n        if (i === nums.length) {\\n            result.push(arr);\\n            return;\\n        }\\n        ", "var subsetsWithDup = function(nums) {\\n    function findSubset(arr,curr){\\n        res.push([...curr])\\n        for(let i=0;i<arr.length;i++){\\n            if(i== 0 || arr[i] != arr[i-1]){\\n                curr.push(arr[i])\\n                findSubset(arr.slice(i+1),curr)\\n                curr.pop()\\n            }\\n        }\\n    }\\n    let res = []\\n    nums.sort((a,b)=>{return a-b})\\n    findSubset(nums,[])\\n    return res\\n};", "var subsetsWithDup = function(nums) {\\n    nums.sort();\\n    let output = [];\\n    backtracking(0, [], nums, output);\\n    return output\\n};"]}
{"id": "664", "ref_js": ["var numDecodings = function(s) {\\n    const helper = (index) => {\\n        if (index === s.length) {\\n            return 1;\\n        }\\n\\n        if (s[index] === \\'0\\') {\\n        return 0;\\n        }\\n\\n        let ways = helper(index + 1);\\n\\n        if (index < s.length - 1 && parseInt(s.substring(index, index + 2)) <= 26) {\\n            ways += helper(index + 2);\\n        }\\n\\n        return ways;\\n    };", "var numDecodings = function(s) {\\n    if (!s || s[0] === \\'0\\') {\\n        return 0;\\n    }\\n\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (let i = 2; i <= n; ++i) {\\n        const oneDigit = parseInt(s[i - 1]);\\n        const twoDigits = parseInt(s.substring(i - 2, i));\\n\\n        if (oneDigit !== 0) {\\n            dp[i] += dp[i - 1];\\n        }\\n\\n        if (10 <= twoDigits && twoDigits <= 26) {\\n            dp[i] += dp[i - 2];\\n        }\\n    }\\n\\n    return dp[n];\\n};", "var numDecodings = function(s) {\\n    const dp = new Array(s.length +1).fill(0);\\n    dp[s.length] = 1;\\n\\n    for(let i = s.length -1; i >= 0 ; i--){\\n        if(s[i] == 0) continue;\\n        dp[i]  = dp[i+1];\\n        if(s[i] + s[i+1] <= 26) dp[i] += dp[i+2];\\n    }\\n\\n    return dp[0];\\n};"]}
{"id": "665", "ref_js": ["var reverseBetween = function(head, left, right) {\\n    if (!head || left === right) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    let prev = dummy;\\n    \\n    for (let i = 0; i < left - 1; ++i) {\\n        prev = prev.next;\\n    }\\n    \\n    let current = prev.next;\\n    \\n    for (let i = 0; i < right - left; ++i) {\\n        const nextNode = current.next;\\n        current.next = nextNode.next;\\n        nextNode.next = prev.next;\\n        prev.next = nextNode;\\n    }\\n    \\n    return dummy.next;\\n};", "var reverseBetween = function(head, left, right) {\\n    if (!head || left === right) {\\n        return head;\\n    }\\n\\n    const dummy = new ListNode(0, head);\\n    let prev = dummy;\\n\\n    for (let i = 0; i < left - 1; i++) {\\n        prev = prev.next;\\n    }\\n\\n    let cur = prev.next;\\n\\n    for (let i = 0; i < right - left; i++) {\\n        const temp = cur.next;\\n        cur.next = temp.next;\\n        temp.next = prev.next;\\n        prev.next = temp;\\n    }\\n\\n    return dummy.next;    \\n};", "var reverseBetween = function(head, left, right) {\\n    let start = head, curr = head;\\n    let i = 1;\\n    while(i < left){\\n        start = curr;\\n        curr = curr.next;\\n        i++;\\n    }\\n    let prev = null, tail = curr;\\n    while(i <= right){\\n        let next = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = next;\\n        i++;\\n    }\\n    start.next = prev;\\n    tail.next = curr;\\n    return left == 1 ? prev : head;\\n};"]}
{"id": "666", "ref_js": ["var restoreIpAddresses = function(s) {\\n    if (!s || s.length === 0) return [];\\n    const result = [];\\n\\n    ", "var restoreIpAddresses = function(s) {\\n    let ans = [];\\n  ", "var restoreIpAddresses = function(s) {\\n    if (s.length < 4 || s.length > 12) return []\\n\\n    let res = [];\\n    let dfs = function(s, ip, c) {\\n        if (s.length == 0 && c == 0) res.push(ip);\\n        if (c == 0 ) {\\n            return;}\\n        \\n        for (let i = 0; i < 4; i++) {\\n            if (i >= s.length) break;\\n            let subIP = s.slice(0,i+1);\\n            if (parseInt(subIP) > 255 ||  subIP.length > 1 && subIP[0] == \"0\") return;\\n            dfs(s.slice(i+1), ip + (c == 4 ? \"\" : \".\") + subIP, c-1);\\n        }\\n    }\\n\\n    dfs(s, \"\", 4);\\n    return res;\\n};"]}
{"id": "667", "ref_js": ["var generateTrees = function(n) {\\n    const generateBacktracking = (fst, lst) => {\\n        if (fst > lst)\\n            return [undefined];\\n        let tree = [];\\n        for (let val = fst; val <= lst; val++){\\n            for (let left of generateBacktracking(fst, val-1)){\\n                for (let right of generateBacktracking(val+1, lst)){\\n                    let node = new TreeNode(val, left, right);\\n                    tree.push(node);\\n                }\\n            }\\n        }\\n        return tree;\\n    };", "var generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    function generate_trees(start, end) {\\n        if (start > end) return [null];\\n\\n        const all_trees = [];\\n        for (let i = start; i <= end; i++) {\\n            const left_trees = generate_trees(start, i - 1);\\n            const right_trees = generate_trees(i + 1, end);\\n\\n            for (const l of left_trees) {\\n                for (const r of right_trees) {\\n                    const current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n\\n    return generate_trees(1, n);\\n};", "var generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    function generate_trees(start, end) {\\n        if (start > end) return [null];\\n\\n        const all_trees = [];\\n        for (let i = start; i <= end; i++) {\\n            const left_trees = generate_trees(start, i - 1);\\n            const right_trees = generate_trees(i + 1, end);\\n\\n            for (const l of left_trees) {\\n                for (const r of right_trees) {\\n                    const current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n\\n    return generate_trees(1, n);\\n};"]}
{"id": "668", "ref_js": ["var numTrees = function(n) {\\n    if(n<2) return 1;\\n    let results = 0;\\n    for(let i=1; i<=n; i++) {\\n        results += numTrees(i-1)*numTrees(n-i);\\n    }\\n    return results;\\n};", "var numTrees = function(n) {\\n    ", "var numTrees = function(n) {\\n    if (n <= 1)\\n        return 1;\\n    \\n    let ans = 0;\\n    for (let i = 1; i <= n; i++) {\\n        ans += numTrees(i - 1) * numTrees(n - i);\\n    }\\n    return ans;\\n};"]}
{"id": "669", "ref_js": ["var isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};", "var isInterleave = function (s1, s2, s3) {\\n    if (s1.length + s2.length !== s3.length) return false;\\n\\n    const dp = new Array(s2.length + 1).fill(false);\\n\\n    for (let i = 0; i <= s1.length; i++) {\\n        for (let j = 0; j <= s2.length; j++) {\\n            if (i === 0 && j === 0) {\\n                dp[j] = true;\\n            } else if (i === 0) {\\n                dp[j] = dp[j - 1] && s2[j - 1] === s3[i + j - 1];\\n            } else if (j === 0) {\\n                dp[j] = dp[j] && s1[i - 1] === s3[i + j - 1];\\n            } else {\\n                dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n            }\\n        }\\n    }\\n\\n    return dp[s2.length];\\n};", "var isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};"]}
{"id": "670", "ref_js": ["var isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};", "var isValidBST = function(root, minimum, maximum) {\\n    ", "var isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if (!root) return true;\\n    if (root.val <= min || root.val >= max) return false;\\n    return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};"]}
{"id": "671", "ref_js": ["var recoverTree = function(root) {\\n    let small = null, big = null, prev = null;\\n    let inorder = function(r) {\\n        if (r == null) return;\\n        inorder(r.left);\\n        if (prev && prev.val > r.val) {\\n            small = r;\\n            if(big) return;\\n            big = prev;\\n        }\\n        prev = r;\\n        inorder(r.right);\\n        return;\\n    }\\n    inorder(root);\\n    [small.val, big.val] = [big.val, small.val];\\n};", "var recoverTree = function(root) {\\n    let first = null;\\n    let last = null;\\n    let prev = null;\\n    \\n\\t", "var recoverTree = function(root) {\\n    let small = null, big = null, prev = null;\\n    let inorder = function(r) {\\n        if (r == null) return;\\n        inorder(r.left);\\n        if (prev && prev.val > r.val) {\\n            small = r;\\n            if(big) return;\\n            big = prev;\\n        }\\n        prev = r;\\n        inorder(r.right);\\n        return;\\n    }\\n    inorder(root);\\n    [small.val, big.val] = [big.val, small.val];\\n};"]}
{"id": "672", "ref_js": ["var levelOrder = function(root) {\\n    let q = [root], ans = []\\n    while (q[0]) {\\n        let qlen = q.length, row = []\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = q.shift()\\n            row.push(curr.val)\\n            if (curr.left) q.push(curr.left)\\n            if (curr.right) q.push(curr.right)\\n        }\\n        ans.push(row)            \\n    }\\n    return ans\\n};", "var levelOrder = function (root) {\\n    ", "var levelOrder = function(root) {\\n    let q = [root], ans = []\\n    while (q[0]) {\\n        let qlen = q.length, row = []\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = q.shift()\\n            row.push(curr.val)\\n            if (curr.left) q.push(curr.left)\\n            if (curr.right) q.push(curr.right)\\n        }\\n        ans.push(row)            \\n    }\\n    return ans\\n};"]}
{"id": "673", "ref_js": ["var zigzagLevelOrder = function(root) {\\n    let result = []\\n    if(!root)\\n        return result\\n    const queue = [[root,0]]\\n    while(queue.length > 0){\\n        let [current, level] = queue.shift()\\n        result[level] ??= []\\n        if(level % 2 === 1)\\n            result[level].push(current.val)\\n        else\\n            result[level].unshift(current.val)\\n        if(current.right)\\n            queue.push([current.right, level + 1])\\n        if(current.left)\\n            queue.push([current.left, level + 1])\\n    }\\n    return result\\n};", "var zigzagLevelOrder = function(root) {\\n    const output = [];\\n    const queue = [[root, true,0]]\\n    while (queue.length) {\\n      const [node, flip,level] = queue.shift();\\n      if(!node) continue;\\n      if(output[level] === undefined) output[level] = [];\\n      if(!flip)output[level].push(node.val);\\n      else output[level].unshift(node.val)\\n      queue.push([node.right, !flip, level+1]);\\n      queue.push([node.left, !flip, level+1]);\\n    } \\n    return output;\\n};", "var zigzagLevelOrder = function(root) {\\n    "]}
{"id": "674", "ref_js": ["var buildTree = function(preorder, inorder) {\\n        p = i = 0\\n        build = function(stop) {\\n            if (inorder[i] != stop) {\\n                var root = new TreeNode(preorder[p++])\\n                root.left = build(root.val)\\n                i++\\n                root.right = build(stop)\\n                return root\\n            }\\n            return null\\n        }\\n        return build()\\n    };", "var buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};", "var buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};"]}
{"id": "675", "ref_js": ["var buildTree = function(inorder, postorder) {\\n    if (inorder.length == 0 || postorder.length == 0) {\\n        return null;\\n    }\\n    var rootVal = postorder[postorder.length - 1];\\n    var root = new TreeNode(rootVal);\\n    var rootIndex = inorder.indexOf(rootVal);\\n    var leftInorder = inorder.slice(0, rootIndex);\\n    var rightInorder = inorder.slice(rootIndex + 1);\\n    var leftPostorder = postorder.slice(0, leftInorder.length);\\n    var rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    root.left = buildTree(leftInorder, leftPostorder);\\n    root.right = buildTree(rightInorder, rightPostorder);\\n    return root;\\n};", "var buildTree = function(inorder, postorder) {    \\n    let hash = {};", "var buildTree = function(inorder, postorder) {\\n    if (inorder.length === 0 || postorder.length === 0) {\\n        return null;\\n    }\\n    \\n    const rootVal = postorder[postorder.length - 1];\\n    const root = new TreeNode(rootVal);\\n    const rootIndex = inorder.indexOf(rootVal);\\n    \\n    const leftInorder = inorder.slice(0, rootIndex);\\n    const rightInorder = inorder.slice(rootIndex + 1);\\n    const leftPostorder = postorder.slice(0, leftInorder.length);\\n    const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    \\n    root.left = buildTree(leftInorder, leftPostorder);\\n    root.right = buildTree(rightInorder, rightPostorder);\\n    \\n    return root;\\n};"]}
{"id": "676", "ref_js": ["var levelOrderBottom = function(root) {\\n    if(!root)return []\\n    \\n    const level=findDeepestLevel(root)\\n    const res=[]\\n    for(let i=0;i<level;i++){\\n        res.push([])\\n    }\\n    helper(res,root,level-1)\\n    return res\\n    \\n    function findDeepestLevel(root){\\n        if(!root)return 0\\n        return 1+Math.max(findLevel(root.left),findLevel(root.right))\\n    }\\n    \\n    function helper(res,node,level){\\n        if(!node)return null\\n        res[level].push(node.val)\\n        helper(res,node.left,level-1)\\n        helper(res,node.right,level-1)\\n    }\\n};", "var levelOrderBottom = function(root) {\\n    if(!root)return []\\n    \\n    const level=findDeepestLevel(root)\\n    const res=[]\\n    for(let i=0;i<level;i++){\\n        res.push([])\\n    }\\n    helper(res,root,level-1)\\n    return res\\n    \\n    function findDeepestLevel(root){\\n        if(!root)return 0\\n        return 1+Math.max(findLevel(root.left),findLevel(root.right))\\n    }\\n    \\n    function helper(res,node,level){\\n        if(!node)return null\\n        res[level].push(node.val)\\n        helper(res,node.left,level-1)\\n        helper(res,node.right,level-1)\\n    }\\n};", "var levelOrderBottom = function(root) {\\n    if(!root)return []\\n    \\n    const level=findDeepestLevel(root)\\n    const res=[]\\n    for(let i=0;i<level;i++){\\n        res.push([])\\n    }\\n    helper(res,root,level-1)\\n    return res\\n    \\n    function findDeepestLevel(root){\\n        if(!root)return 0\\n        return 1+Math.max(findLevel(root.left),findLevel(root.right))\\n    }\\n    \\n    function helper(res,node,level){\\n        if(!node)return null\\n        res[level].push(node.val)\\n        helper(res,node.left,level-1)\\n        helper(res,node.right,level-1)\\n    }\\n};"]}
{"id": "677", "ref_js": ["var sortedListToBST = function(head) {\\n    let arr = [];\\n    while(head !== null) {\\n        arr.push(head.val);\\n        head = head.next;\\n    } \\n    function getBST(left, right) {\\n        if(left > right) return null;\\n\\n        let mid = left + Math.floor((right-left)/2);\\n        let node = new TreeNode(arr[mid]);\\n        node.left = getBST(left, mid - 1);\\n        node.right = getBST(mid + 1, right);\\n        return node;\\n    }\\n    let left = 0;\\n    let right = arr.length - 1;\\n    return getBST(left, right)  \\n};", "var sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};", "var sortedListToBST = function(head) {\\n"]}
{"id": "678", "ref_js": ["var pathSum = function(root, sum) {\\n  if (root === null) return [];\\n  const res = [];\\n  backtrack(root, sum, res, []);\\n  return res;\\n};", "var pathSum = function(root, targetSum) {\\n    const ans = [];\\n  \\n  const fun = (node, path, sum) => {\\n    \\n    if (!node) return;\\n      \\n    if (!node.left && !node.right) {\\n      if (sum === node.val) {\\n        ans.push([...path, node.val]);\\n      }\\n      return;\\n    }\\n    \\n    fun(node.left, [...path, node.val], sum - node.val);\\n    fun(node.right, [...path, node.val], sum - node.val);\\n  };", "var pathSum = function(root, sum, res = [], path = []){\\n    if(root){\\n        path.push(root.val);\\n        if(!root.left && !root.right && sum - root.val === 0) res.push([...path]);\\n        pathSum(root.left, sum - root.val, res, path);\\n        pathSum(root.right, sum - root.val, res, path);\\n        path.pop();\\n    }\\n    return res;\\n};"]}
{"id": "679", "ref_js": ["var flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};", "var flatten = function(root) {\\n    let prev = null\\n    const traverse = node => {\\n        if(node === null)   return\\n        traverse(node.right)\\n        traverse(node.left)\\n        node.left = null\\n        node.right = prev\\n        prev = node\\n    }\\n    traverse(root)\\n};", "var flatten = function(root) {\\n    \\n    let prev = null;\\n    \\n    var helper = function( node ){\\n        \\n        if( node != null){\\n            \\n            "]}
{"id": "680", "ref_js": ["var connect = function(root) {\\n    if(!root || !root.left) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left : null;\\n\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n};", "var connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};", "var connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};"]}
{"id": "681", "ref_js": ["var connect = function(root) {\\n    if(!root) return root;\\n    let que = [];\\n    que.push(root);\\n    while(que.length) {\\n        let temp = [];\\n        while(que.length) {\\n            let node = que.shift();\\n            if(node.left) {\\n                if(temp.length) {\\n                    temp[temp.length - 1].next = node.left;\\n                }\\n                temp.push(node.left);\\n            }\\n            if(node.right) {\\n                if(temp.length) {\\n                    temp[temp.length - 1].next = node.right;\\n                }\\n                temp.push(node.right);\\n            }\\n        }\\n        que = temp\\n    }\\n    return root\\n};", "var connect = function (root) {\\r\\n  const recurse = (node) => {\\r\\n    if (!node) return;\\r\\n\\r\\n    if (node.left) {\\r\\n      if (node.right) node.left.next = node.right;\\r\\n      else {\\r\\n        let next = node;\\r\\n        while (next) {\\r\\n          next = next.next;\\r\\n          node.left.next = next?.left || next?.right || null;\\r\\n          if (node.left.next) break;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    if (node.right) {\\r\\n      let next = node;\\r\\n      while (next) {\\r\\n        next = next.next;\\r\\n        node.right.next = next?.left || next?.right || null;\\r\\n        if (node.right.next) break;\\r\\n      }\\r\\n    }\\r\\n    recurse(node.right);\\r\\n    recurse(node.left);\\r\\n  };", "var connect = function(root) {\\n    if (!root) return root;\\n    \\n    let queue = [root];\\n    let tempQueue = [];\\n        \\n    while(queue.length){\\n        let curr = queue.splice(0, 1)[0];\\n        let {left, right} = curr;\\n                \\n        if (left) tempQueue.push(left);\\n        if (right) tempQueue.push(right);\\n        \\n        if (queue.length === 0){\\n            curr.next = null;\\n            queue = tempQueue;\\n            tempQueue = [];\\n        }else{\\n            curr.next = queue[0];\\n        }\\n    }\\n    \\n    return root;\\n};"]}
{"id": "682", "ref_js": ["var minimumTotal = function(triangle) {\\n    let n = triangle.length;\\n    let dp = Array(n).fill(Number.MAX_VALUE).map(()=> Array(n).fill(Number.MAX_VALUE));\\n    ", "var minimumTotal = function(T) {\\n    for (let i = T.length - 2; ~i; i--) \\n        for (let j = T[i].length - 1; ~j; j--) \\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1])\\n    return T[0][0]\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **48ms / 14.9MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def minimumTotal(self, T: List[List[int]]) -> int:\\n        for i in range(len(T)-2,-1,-1):\\n            for j in range(len(T[i])-1,-1,-1):\\n                T[i][j] += min(T[i+1][j], T[i+1][j+1])\\n        return T[0][0]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 38.6MB** (beats 32% / 96%).\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> T) {\\n        for (int i = T.size() - 2; i >= 0; i--) \\n            for (int j = T.get(i).size() - 1; j >= 0; j--) {\\n                int min = Math.min(T.get(i+1).get(j), T.get(i+1).get(j+1));\\n                T.get(i).set(j, T.get(i).get(j) + min);\\n            }\\n        return T.get(0).get(0);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 8.3MB** (beats 100% / 94%).\\n```c++\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& T) {\\n        for (int i = T.size() - 2; ~i; i--) \\n            for (int j = T[i].size() - 1; ~j; j--) \\n                T[i][j] += min(T[i+1][j], T[i+1][j+1]);\\n        return T[0][0];\\n    }\\n};", "var minimumTotal = function(T) {\\n    for (let i = T.length - 2; ~i; i--) \\n        for (let j = T[i].length - 1; ~j; j--) \\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1])\\n    return T[0][0]\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **48ms / 14.9MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def minimumTotal(self, T: List[List[int]]) -> int:\\n        for i in range(len(T)-2,-1,-1):\\n            for j in range(len(T[i])-1,-1,-1):\\n                T[i][j] += min(T[i+1][j], T[i+1][j+1])\\n        return T[0][0]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 38.6MB** (beats 32% / 96%).\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> T) {\\n        for (int i = T.size() - 2; i >= 0; i--) \\n            for (int j = T.get(i).size() - 1; j >= 0; j--) {\\n                int min = Math.min(T.get(i+1).get(j), T.get(i+1).get(j+1));\\n                T.get(i).set(j, T.get(i).get(j) + min);\\n            }\\n        return T.get(0).get(0);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 8.3MB** (beats 100% / 94%).\\n```c++\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& T) {\\n        for (int i = T.size() - 2; ~i; i--) \\n            for (int j = T[i].size() - 1; ~j; j--) \\n                T[i][j] += min(T[i+1][j], T[i+1][j+1]);\\n        return T[0][0];\\n    }\\n};"]}
{"id": "683", "ref_js": ["var maxProfit = function(prices) {\\n    \\n    let profit = new Array();\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit.push(  prices[i+1] - prices[i] );\\n        }\\n    }\\n    return profit.reduce(accumulate, 0);\\n}\\n```\\n```Go []\\nfunc Accumulate(elements ...int) int {  \\n     sum := 0  \\n     for _, elem := range elements {  \\n          sum += elem  \\n     }  \\n     return sum  \\n} \\n\\n\\nfunc maxProfit(prices []int) int {\\n    \\n    profit := make([]int, 0)\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit = append(profit, ( prices[i+1] - prices[i] ))\\n        }\\n    }\\n\\n    return Accumulate(profit...)\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<int> profit;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profit.push_back( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return accumulate( profit.begin(), profit.end(), 0);\\n    }\\n};", "var maxProfit = function(prices) {\\n    var max=0,diff;\\n    for(var i=0;i<prices.length-1;i++)\\n    {\\n        diff=prices[i+1]-prices[i];\\n        if(diff>0)\\n            max+=diff;\\n    }\\n    return max;\\n};", "var maxProfit = function(prices) {\\n    \\n    let profit = new Array();\\n    \\n    for( let i = 0 ; i < prices.length-1 ; i++ ){\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit.push(  prices[i+1] - prices[i] );\\n        }\\n    }\\n    return profit.reduce(accumulate, 0);\\n}\\n```\\n```Go []\\nfunc Accumulate(elements ...int) int {  \\n     sum := 0  \\n     for _, elem := range elements {  \\n          sum += elem  \\n     }  \\n     return sum  \\n} \\n\\n\\nfunc maxProfit(prices []int) int {\\n    \\n    profit := make([]int, 0)\\n    \\n    for i := 0 ; i < len(prices)-1 ; i++{\\n        \\n        if( prices[i] < prices[i+1] ){\\n            profit = append(profit, ( prices[i+1] - prices[i] ))\\n        }\\n    }\\n\\n    return Accumulate(profit...)\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<int> profit;\\n        \\n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\\n            \\n            if( prices[i] < prices[i+1] ){\\n                profit.push_back( prices[i+1] - prices[i] );\\n            }\\n            \\n        }\\n        return accumulate( profit.begin(), profit.end(), 0);\\n    }\\n};"]}
{"id": "684", "ref_js": ["var longestConsecutive = function(nums) {\\n    const n = nums.length;\\n    \\n    if (n === 0) {\\n        return 0;\\n    }\\n\\n    nums.sort((a, b) => a - b);\\n\\n    let cnt = 1;\\n    let maxi = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        if (nums[i] !== nums[i - 1]) {\\n            if (nums[i] === nums[i - 1] + 1) {\\n                cnt++;\\n            } else {\\n                maxi = Math.max(maxi, cnt);\\n                cnt = 1;\\n            }\\n        }\\n    }\\n\\n    return Math.max(maxi, cnt);\\n};", "var longestConsecutive = function(arr) {\\n\\n        if(arr.length==0) return 0\\n\\n        let count=1, max = 1\\n        arr.sort((a, b) => a - b)                       ", "var longestConsecutive = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let count = 0;\\n    let temp = 1;\\n    if (nums.length === 0) {\\n        return 0;\\n    }\\n    if (nums.length === 1) {\\n        return 1;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1] - 1) {\\n            temp++;\\n            count = Math.max(count, temp);\\n        } else if (nums[i] === nums[i + 1]) {\\n            count = Math.max(count, temp);\\n        } else {\\n            temp = 1;\\n            count = Math.max(count, temp);\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "685", "ref_js": ["var sumNumbers = function (root) {\\n    ", "var sumNumbers = function (root) {\\n  let sum = 0,\\n    curSum = 0;\\n  DFS(root);\\n  function DFS(node) {\\n    curSum += node.val;\\n    if (!node.left && !node.right) {\\n      sum += curSum;\\n      return;\\n    }\\n    if (node.left) {\\n      curSum *= 10;\\n      DFS(node.left);\\n      curSum -= node.left.val;\\n      curSum /= 10;\\n    }\\n    if (node.right) {\\n      curSum *= 10;\\n      DFS(node.right);\\n      curSum -= node.right.val;\\n      curSum /= 10;\\n    }\\n  }\\n  return sum;\\n};", "var sumNumbers = function(root) {\\n    if(!root) {\\n        return 0;\\n    }\\n\\n    let runningSum = [];\\n    let ans = 0;\\n\\n    let dfs = (node, runningSum) => {\\n        if(!node) {\\n            return;\\n        }\\n        runningSum.push(node.val);\\n        if (!node.left && !node.right) {\\n            ans += Number(runningSum.join(\\'\\'));\\n            runningSum.pop();\\n            return;\\n        }\\n        dfs(node.left, runningSum);\\n        dfs(node.right, runningSum);\\n        runningSum.pop();\\n    }\\n    dfs(root, runningSum);\\n    return ans;\\n};"]}
{"id": "686", "ref_js": ["var solve = function(board) {\\n    if(board.length ==0) return null \\n    \\n    for(var i=0;i<board.length;i++){\\n        for(var j=0;j<board[0].length;j++){\\n            if(board[i][j] == \\'O\\' && (i==0 || i==board.length-1 || j==0 || j==board[0].length-1)){\\n                  dfs(board,i,j)\\n               }\\n        }\\n    }\\n    \\n    for(var i=0;i<board.length;i++){\\n        for(var j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'W\\'){\\n                  board[i][j]=\\'O\\'\\n               }\\n            else {\\n                    board[i][j]=\\'X\\'\\n                    }\\n        }\\n    }\\n    \\n    return board\\n};", "var solve = function(board) {\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if(board[i][j] === \\'O\\' && (i === 0 || j === 0 || i === board.length - 1 || j === board[0].length - 1)) dfs(i, j);\\n        }\\n    }\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if(board[i][j] === \\'Visited\\') {\\n                board[i][j] = \\'O\\';\\n            } else  {\\n                board[i][j] = \\'X\\';\\n            }\\n        }    \\n    }\\n    \\n    function dfs(i, j) {\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[i].length || board[i][j] === \\'Visited\\' || board[i][j] === \\'X\\') return\\n        \\n        board[i][j] = \\'Visited\\';\\n        dfs(i + 1, j);\\n        dfs(i - 1, j);\\n        dfs(i, j + 1);\\n        dfs(i, j - 1);\\n        \\n        return;\\n    }\\n};", "var solve = function(board) {\\n    if (!board.length) return [];\\n    \\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            "]}
{"id": "687", "ref_js": ["var partition = function(s) {\\n    result = [];\\n    solve(s, -1, []);\\n    return result;\\n};", "var partition = function(s) {\\n    let n = s.length\\n    let dp = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = new Array()\\n    }\\n\\n    let res = []\\n    let dfs = function (start, curList) {\\n        if (start == n) res.push([...curList])\\n        for (let end = start; end < n; end++) {\\n            if (s[start] == s[end] && (end - start <= 2 || dp[start+1][end-1])) {\\n                dp[start][end] = true\\n                curList.push(s.slice(start, end+1))\\n                dfs(end+1, curList)\\n                curList.pop(curList)\\n            }\\n        }\\n    }\\n    dfs(0, [])\\n    return res\\n};", "var partition = function (s) {\\n  const isP = (str) => str === str.split(\"\").reverse().join(\"\"),\\n    path = [],\\n    res = [];\\n  BT();\\n  return res;\\n  function BT(idx=0) {\\n    if (idx === s.length) {\\n      res.push([...path]);\\n      return;\\n    }\\n\\n    for (let i = idx + 1; i <= s.length; i++) {\\n      let curStr = s.substring(idx, i);\\n      if (isP(curStr)) {\\n        path.push(curStr);\\n        BT(i);\\n        path.pop();\\n      }\\n    }\\n  }\\n};"]}
{"id": "688", "ref_js": ["var cloneGraph = function (node, clonedNodes = new Map()) {\\n  ", "var cloneGraph = function(node) {\\n    if(node == null) return node;\\n    const visited = new Array();\\n    return cloneHelper(node,visited);\\n};", "var cloneGraph = function (node) {\\n    "]}
{"id": "689", "ref_js": ["var canCompleteCircuit = function(gas, cost) {\\n\\tlet totalTank = 0;\\n\\t\\n\\tfor (let i = 0; i < gas.length; i++) {\\n\\t\\tconst netCost = gas[i] - cost[i];\\n\\t\\ttotalTank += netCost;\\n\\t}\\n\\treturn totalTank < 0 ? -1 : ", "var canCompleteCircuit = function (gas, cost) { \\n", "var canCompleteCircuit = function(gas, cost) {\\n    let n = gas.length\\n\\n    let start = n - 1\\n    let end = 0\\n    gasInTank = gas[start] - cost[start]\\n    while (start >= end) {\\n        if (gasInTank >= 0) {\\n            gasInTank += gas[end] - cost[end]\\n            end++\\n        }\\n        else {\\n            start--\\n            gasInTank += gas[start] - cost[start]\\n        }\\n    }\\n    return gasInTank >= 0 ? start : -1\\n};"]}
{"id": "690", "ref_js": ["var singleNumber = function(nums) {\\n    const count = {};", "var singleNumber = function(nums) {\\n  const map = new Map()\\n  for(const num of nums){\\n    map.set(num,(map.get(num)||0)+1)\\n  }\\n  for(const[num, count] of map.entries()){\\n    if(count===1) return num;\\n  }\\n  return 0;\\n};", "var singleNumber = function(nums) {\\n    let ones = 0;\\n    let twos = 0;\\n\\n    for (let num of nums) {\\n        ones = (ones ^ num) & ~twos;\\n        twos = (twos ^ num) & ~ones;\\n    }\\n\\n    return ones;\\n};"]}
{"id": "691", "ref_js": ["var copyRandomList = function(head) {\\n    if (!head) return null;\\n    \\n    const oldToNew = new Map();\\n    \\n    let curr = head;\\n    while (curr) {\\n        oldToNew.set(curr, new Node(curr.val));\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while (curr) {\\n        oldToNew.get(curr).next = oldToNew.get(curr.next) || null;\\n        oldToNew.get(curr).random = oldToNew.get(curr.random) || null;\\n        curr = curr.next;\\n    }\\n    \\n    return oldToNew.get(head);\\n};", "var copyRandomList = function(head) {\\n    ", "var copyRandomList = function(head) {\\n    const visited = new Map();\\n\\n    const copy = (node) => {\\n        if (!node) return null;\\n\\n        if (visited.has(node)) return visited.get(node);\\n\\n        const newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n\\n        newNode.next = copy(node.next);\\n        newNode.random = copy(node.random);\\n\\n        return newNode;\\n    };"]}
{"id": "692", "ref_js": ["var wordBreak = function(s, wordDict) {\\n    let n = s.length;\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n    let max_len = Math.max(...wordDict.map(word => word.length));\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (let j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n            if (dp[j] && wordDict.includes(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];\\n};", "var wordBreak = function(s, wordDict) {\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (const word of wordDict) {\\n            if (i - word.length >= 0 && dp[i - word.length] && s.substring(i - word.length, i) === word) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];    \\n};", "var wordBreak = function(s, wordDict) {\\n    let memo = new Array(s.length + 1).fill(-1);\\n\\n    const memoRecursiveSolution = (i) => {\\n        if (i === s.length) {\\n            return true;\\n        }\\n        if (memo[i] !== -1) {\\n            return memo[i] === 1;\\n        }\\n\\n        let ans = false;\\n        for (let word of wordDict) {\\n            if (s.startsWith(word, i)) {\\n                ans = ans || memoRecursiveSolution(i + word.length);\\n            }\\n        }\\n\\n        memo[i] = ans ? 1 : 0;\\n        return ans;\\n    };"]}
{"id": "693", "ref_js": ["var minOperations = function(s) {\\n    let c_0 = s[0];\\n    let count1 = count(s, c_0);\\n    let count2 = count(s, c_0 === \\'0\\' ? \\'1\\' : \\'0\\') + 1;\\n    return Math.min(count1, count2);\\n};", "var minOperations = function(s) {\\n    let start10 = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (parseInt(s[i]) === i % 2) {\\n            start10 += 1;\\n        }\\n    }\\n\\n    return Math.min(start10, s.length - start10);    \\n};", "var minOperations = function(s) {\\n    let start10 = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (parseInt(s[i]) === i % 2) {\\n            start10 += 1;\\n        }\\n    }\\n\\n    return Math.min(start10, s.length - start10);    \\n};"]}
{"id": "694", "ref_js": ["var reorderList = function(head) {\\n    ", "var reorderList = function (head) {\\n  ", "var reorderList = function(head) {\\n    "]}
{"id": "696", "ref_js": ["var search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        \\n        if (nums[mid] === target) {\\n            return true;\\n        }\\n        \\n        if (nums[mid] === nums[left]) {\\n            left++;\\n            continue;\\n        }\\n        \\n        if (nums[left] <= nums[mid]) {\\n            if (nums[left] <= target && target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n    }\\n    \\n    return false;    \\n};", "var search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while (start <= end) {\\n        let mid = start + Math.floor((end - start) / 2);\\n        if (target === nums[mid]) {\\n            return true;\\n        } else if (nums[start] < nums[mid]) {\\n            if (nums[start] <= target && nums[mid] > target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else if (nums[mid] < nums[start]) {\\n            if (nums[end] >= target && nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start += 1;\\n        }\\n    }\\n\\n    return false;\\n};", "var search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while (start <= end) {\\n        let mid = start + Math.floor((end - start) / 2);\\n        if (target === nums[mid]) {\\n            return true;\\n        } else if (nums[start] < nums[mid]) {\\n            if (nums[start] <= target && nums[mid] > target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else if (nums[mid] < nums[start]) {\\n            if (nums[end] >= target && nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start += 1;\\n        }\\n    }\\n\\n    return false;\\n};"]}
{"id": "697", "ref_js": ["var sortList = function(head) {\\n    if(head==null){\\n        return null;\\n    }\\n    let ptr=head;\\n    let arr=[];\\n    while(ptr){\\n        arr.push(ptr.val);\\n        ptr=ptr.next;\\n    }\\n    arr.sort((a,b)=>a-b);\\n    let n = new ListNode(arr[0]);\\n    head=n;\\n    let temp=head;\\n    for(let i=1;i<arr.length;i++){\\n        let n1 = new ListNode(arr[i]);\\n        temp.next=n1;\\n        temp=temp.next;       \\n    }\\n    return head;\\n};", "var sortList = function(head) {\\n    \\n    \\n    var merge = function(a, b){\\n        \\n        if( a == null ){\\n            return b;\\n        }else if( b == null ){\\n            return a;\\n        }\\n        \\n        if( a.val < b.val ){\\n            a.next = merge(a.next, b);\\n            return a;\\n        }else{\\n            b.next = merge(a, b.next);\\n            return b;\\n        }\\n        \\n    }\\n    \\n    ", "var sortList = function(head) {\\n    if(head==null){\\n        return null;\\n    }\\n    let ptr=head;\\n    let arr=[];\\n    while(ptr){\\n        arr.push(ptr.val);\\n        ptr=ptr.next;\\n    }\\n    arr.sort((a,b)=>a-b);\\n    let n = new ListNode(arr[0]);\\n    head=n;\\n    let temp=head;\\n    for(let i=1;i<arr.length;i++){\\n        let n1 = new ListNode(arr[i]);\\n        temp.next=n1;\\n        temp=temp.next;       \\n    }\\n    return head;\\n};"]}
{"id": "698", "ref_js": ["var evalRPN = function(tokens) {\\n    let stack = [];\\n    const operators = new Set([\"+\", \"-\", \"*\", \"/\"]);\\n\\n    for (let token of tokens) {\\n        if (operators.has(token)) {\\n            let a = stack.pop();\\n            let b = stack.pop();\\n            switch (token) {\\n                case \"+\":\\n                    stack.push(b + a);\\n                    break;\\n                case \"-\":\\n                    stack.push(b - a);\\n                    break;\\n                case \"*\":\\n                    stack.push(b * a);\\n                    break;\\n                case \"/\":\\n                    stack.push(Math.trunc(b / a));\\n                    break;\\n            }\\n        } else {\\n            stack.push(parseInt(token));\\n        }\\n    }\\n    return stack[0];\\n};", "var evalRPN = function (tokens) {\\n  const stack = []\\n\\n  for (let i = 0; i < tokens.length; i++) {\\n    const token = tokens[i]\\n\\n    if (Number.isInteger(+token)) {\\n      stack.push(token)\\n    } else {\\n      const second = stack.pop()\\n      const first = stack.pop()\\n      const exp = `${first} ${token} ${second}`\\n      const exp_res = Math.trunc(eval(exp))\\n      stack.push(exp_res)\\n    }\\n  }\\n\\n  return stack[0]\\n};", "var evalRPN = function(tokens) {\\n    const stack = [];\\n\\n    for (let i = 0; i < tokens.length; i++) {\\n        if (tokens[i] == \\'+\\') {\\n            stack.push(stack.pop() + stack.pop());\\n        } else if (tokens[i] == \\'-\\') {\\n            stack.push(- stack.pop() + stack.pop());\\n        } else if (tokens[i] == \\'*\\') {\\n            stack.push(stack.pop() * stack.pop());\\n        } else if (tokens[i] == \\'/\\') {\\n            stack.push(Math.trunc(1/(stack.pop()/stack.pop())));\\n            "]}
{"id": "699", "ref_js": ["var reverseWords = function(s) {\\n    ", "var reverseWords = function(s) {\\n    ", "var reverseWords = function(s) {\\n    "]}
{"id": "700", "ref_js": ["var maxProduct = function(nums) {\\n    let result = -Infinity;\\n    let max = 1\\n    let min = 1\\n    for(let i =0; i< nums.length; i++) {\\n        const currentMax = Math.max(max * nums[i], min * nums[i], nums[i])\\n        min = Math.min(min * nums[i], max * nums[i], nums[i], 1)\\n        max = currentMax\\n        result = Math.max(result, min, max)\\n    }    \\n    return result\\n};", "var maxProduct = function(nums) {\\n    var ans = nums[0];\\n    var maxp = nums[0];\\n    var minp = nums[0];\\n    \\n    for (var i = 1; i < nums.length; i++) {\\n        var temp = Math.max(nums[i], maxp * nums[i], minp * nums[i]);\\n        minp = Math.min(nums[i], maxp * nums[i], minp * nums[i]);\\n        maxp = temp;\\n        ans = Math.max(maxp, ans);\\n    }\\n    \\n    return ans;\\n};", "var maxProduct = function(nums) {\\n    let result = -Infinity;\\n    let max = 1\\n    let min = 1\\n    for(let i =0; i< nums.length; i++) {\\n        const currentMax = Math.max(max * nums[i], min * nums[i], nums[i])\\n        min = Math.min(min * nums[i], max * nums[i], nums[i], 1)\\n        max = currentMax\\n        result = Math.max(result, min, max)\\n    }    \\n    return result\\n};"]}
{"id": "701", "ref_js": ["var findMin = function(nums) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n        let mid = left + Math.floor((right - left) / 2);\\n\\n        if (nums[mid] > nums[right]) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return nums[left];\\n};", "var findMin = function(nums) {\\n    var left = 0,\\n        right = nums.length - 1\\n    \\n    while (left < right){\\n        var mid = Math.floor((left + right)/2)\\n        if (nums[mid] > nums[right]) left = mid + 1\\n        else right = mid\\n    }\\n    return nums[left]\\n};", "var findMin = function(nums) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n        let mid = left + Math.floor((right - left) / 2);\\n\\n        if (nums[mid] > nums[right]) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return nums[left];\\n};"]}
{"id": "703", "ref_js": ["var findPeakElementRecursive = function(nums, ini, end) {\\n\\n    var mid = Math.floor((ini + end) / 2);\\n\\n    ", "var findPeakElement = function(nums) {\\n    var start = 0, end = nums.length - 1;\\n    while (start < end) {\\n        var mid = Math.floor((start + end) / 2);\\n        if (mid === 0) {\\n            return nums[0] >= nums[1] ? 0 : 1;\\n        }\\n        if (mid === end) {\\n            return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;\\n        }\\n\\n        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {\\n            return mid;\\n        }\\n        if (nums[mid] < nums[mid - 1]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return start;\\n};", "var findPeakElement = function(nums) {\\n  if(nums.length === 1) return 0;\\n  \\n  const recursion = (startIndex, endIndex) => {\\n     const midIndex = Math.floor((startIndex + endIndex)/2);          \\n\\n     if (startIndex === endIndex) return startIndex;\\n     if (startIndex + 1 === endIndex) {\\n        return nums[endIndex] >= nums [startIndex] ? endIndex : startIndex;\\n     }\\n\\n     \\n     if(nums[midIndex] > nums[midIndex-1] && nums[midIndex] > nums[midIndex+1]) return midIndex;\\n     if(nums[midIndex] > nums[midIndex-1] && nums[midIndex] < nums[midIndex+1]) return recursion(midIndex + 1, endIndex);\\n     if(nums[midIndex] < nums[midIndex-1] && nums[midIndex] > nums[midIndex+1]) return recursion(startIndex, midIndex - 1);\\n     if(nums[midIndex] < nums[midIndex-1] && nums[midIndex] < nums[midIndex+1]) \\n        return nums[midIndex-1] > nums[midIndex+1] ? recursion(startIndex, midIndex - 1) : recursion(midIndex + 1, endIndex);\\n     \\n  }\\n  \\n  return recursion(0, nums.length - 1);\\n};"]}
{"id": "704", "ref_js": ["var compareVersion = function (version1, version2) {\\n    ", "var compareVersion = function(version1, version2) {\\n    var v1Array = version1.split(\\'.\\');\\n    var v2Array = version2.split(\\'.\\');\\n    var length = Math.max(v1Array.length, v2Array.length);\\n    \\n    for (var i = 0; i < length; i++) {\\n        var num1 = parseInt(v1Array[i]) || 0;\\n        var num2 = parseInt(v2Array[i]) || 0;\\n        \\n        if (num1 == num2) {\\n            continue;\\n        }\\n        \\n        return num1 > num2 ? 1 : -1;\\n    }\\n    \\n    return 0;       \\n};", "var compareVersion = function(version1, version2) {\\n    const v1 = version1.split(\\'.\\')\\n    const v2 = version2.split(\\'.\\')\\n\\t\\n\\tlet max=Math.max(v1.length,v2.length);\\n    \\n    for(let i=0;i<max;i++){\\n        if(v1[i]&&v2[i]){ "]}
{"id": "705", "ref_js": ["var fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; ", "var fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};", "var fractionToDecimal = function (n, d) {\\n    if (n % d === 0) {\\n        return String(n / d);\\n    }\\n    let check = false;\\n    if (n < 0 && d >= 0) {\\n        check = true\\n    }\\n\\n    if (n >= 0 && d < 0) {\\n        check = true\\n    }\\n\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    const b = Math.floor(n / d);\\n    n = n % d;\\n    const q1 = [];\\n    const q2 = [];\\n    let index = 0;\\n\\n    while (true) {\\n        n = n * 10;\\n        const r = Math.floor(n / d);\\n        index = q1.indexOf(n);\\n\\n        if (index !== -1) {\\n            break;\\n        } else {\\n            q1.push(n);\\n            q2.push(r);\\n        }\\n\\n        n = n % d;\\n    }\\n\\n    let counter = 0;\\n\\n    for (let k = q2.length - 1; k >= 0; k--) {\\n        if (q2[k] === 0) {\\n            counter++\\n        } else {\\n            break;\\n        }\\n    }\\n\\n    if (counter > 0) {\\n        q2.splice(-counter);\\n    }\\n    let result = (check ? \\'-\\' : \\'\\') + String(b) + \\'.\\';\\n    let sub = \\'(\\';\\n\\n    for (let k = 0; k < q2.length; k++) {\\n        if (k < index) {\\n            result += q2[k]\\n        } else {\\n            sub += q2[k];\\n        }\\n    }\\n\\n    sub += \\')\\';\\n\\n    if (sub.length === 2) {\\n        return result\\n    } else {\\n        return result + sub\\n    }\\n};"]}
{"id": "706", "ref_js": ["var twoSum = function (sa, t) {\\n    let n = sa.length;\\n    for (let L = 0, R = n - 1; L < R; ) {\\n        let sum = sa[L] + sa[R];\\n        if (sum === t) {\\n            return [L + 1, R + 1];\\n        } else if (sum < t) {\\n            L++;\\n        } else {\\n            R--;\\n        }\\n    }\\n    return [-1, -1];\\n};", "var twoSum = function (numbers, target) {\\n    let p1 = 0;\\n    let p2 = numbers.length - 1;\\n\\n    while (p1 < p2) {\\n        let sum = numbers[p1] + numbers[p2];\\n        if (sum === target) {\\n            return [p1 + 1, p2 + 1];\\n        } else if (sum > target) {\\n            p2--;\\n        } else {\\n            p1++;\\n        }\\n    }\\n};", "var twoSum = function (sa, t) {\\n    let n = sa.length;\\n    for (let L = 0, R = n - 1; L < R; ) {\\n        let sum = sa[L] + sa[R];\\n        if (sum === t) {\\n            return [L + 1, R + 1];\\n        } else if (sum < t) {\\n            L++;\\n        } else {\\n            R--;\\n        }\\n    }\\n    return [-1, -1];\\n};"]}
{"id": "707", "ref_js": ["var trailingZeroes = function(n) {\\n    if(n===0)\\n    return 0;\\n    \\n    let nFac = 1;\\n    nFac = BigInt(nFac);\\n    for (let i = 1; i <= n; i++) \\n    nFac *= BigInt(i);\\n\\n    const op=nFac.toString().split(\"\").reverse();\\n    let count=0;\\n    for(let i=0;i<op.length;i++){\\n        if(op[i]===\\'0\\')\\n        count++;\\n        else\\n        break;\\n    }\\n    return count;\\n};", "var trailingZeroes = function(n) {\\n    let numZeroes = 0;\\n    for (let i = 5; i <= n; i *= 5) {\\n        numZeroes += Math.floor(n / i);\\n    }\\n    return numZeroes;\\n};", "var fib = function(n) {\\n let fac=1, ret=0; \\n    for(let i=2; i<=n; i++){\\n     fac = fac * i\\n }   \\n    while (fac % 10 === 0){\\n        fac = fac/10\\n        ret++\\n    }\\n    return ret\\n};"]}
{"id": "712", "ref_js": ["var largestNumber = function(nums) {\\n    nums.sort((a,b)=>{\\n        let sa = a.toString()\\n        let sb = b.toString()\\n        return parseInt(sa + sb) > parseInt(sb + sa) ? -1 : 1\\n    })\\n    if(nums[0] === 0) return \\'0\\'\\n    \\n    return nums.join(\\'\\')\\n};", "var largestNumber = function(nums) {\\n    nums.sort((a,b)=>{\\n        let sa = a.toString()\\n        let sb = b.toString()\\n        return parseInt(sa + sb) > parseInt(sb + sa) ? -1 : 1\\n    })\\n    if(nums[0] === 0) return \\'0\\'\\n    \\n    return nums.join(\\'\\')\\n};", "var largestNumber = function(nums) {\\n    nums.sort((a,b)=>{\\n        let sa = a.toString()\\n        let sb = b.toString()\\n        return parseInt(sa + sb) > parseInt(sb + sa) ? -1 : 1\\n    })\\n    if(nums[0] === 0) return \\'0\\'\\n    \\n    return nums.join(\\'\\')\\n};"]}
{"id": "715", "ref_js": ["var findRepeatedDnaSequences = function(s) {\\n    let tenLetterSequence = []\\n    let m = new Map();\\n    for(let i = 0; i< s.length; i++){\\n        let sec = s.slice(i, i+10);\\n        if(sec.length ===10){\\n             m.set(sec, m.get(sec) ? m.get(sec)+1 : 1)\\n        }\\n           \\n    }\\n    Array.from(m.entries()).filter(([key, val]) => {\\n        if(val >1) tenLetterSequence.push(key)\\n    });\\n    return tenLetterSequence;\\n};", "var findRepeatedDnaSequences = function(s) {\\n  ", "var findRepeatedDnaSequences = function(s) {\\n  let map = new Map();\\n  let result = [];\\n  for (let i = 0; i <= s.length - 10; i++) {\\n      let substring = s.substring(i, i + 10);\\n      if (map.has(substring)) {\\n          if(map.get(substring) === 1){\\n              result.push(substring);\\n          }\\n          map.set(substring, map.get(substring) + 1);\\n      } else {\\n          map.set(substring, 1);\\n      }\\n  }\\n  return result;\\n  \\n};"]}
{"id": "716", "ref_js": ["var rotate = function(nums, k) {\\n    while (nums.length <= k) {\\n        k = k - nums.length;\\n    }\\n    const temp = nums.splice(0, nums.length-k)\\n    nums.push(...temp)\\n};", "var rotate = function (nums, k) {\\n  if (nums.length <= 2) {\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums[nums.length - 1]);\\n      nums.pop();\\n    }\\n  } else {\\n    let arr = nums.splice(nums.length - k);\\n    nums.unshift(...arr);\\n  }\\n};", "var rotate = function(nums, k) {\\n    while (nums.length <= k) {\\n        k = k - nums.length;\\n    }\\n    const temp = nums.splice(0, nums.length-k)\\n    nums.push(...temp)\\n};"]}
{"id": "719", "ref_js": ["var rob = function(nums, idx = 0) {\\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2);\\n    \\n    return Math.max(sumIfSkipped, sumIfRobbed);\\n};", "var rob = function(nums) {\\n    if (nums.length == 1) return nums[0];\\n    let n= nums.length;\\n\\n    let p1 = nums[0], p2 = Math.max(nums[1], p1);\\n    let maxVal = 0;\\n    for (let i = 2; i < n; i++) {\\n        maxVal = Math.max(p1+nums[i], p2);\\n        p1 = p2;\\n        p2 = maxVal;\\n    }\\n    return p2;\\n};", "var rob = function(nums) {\\n    \\n    \\n    if (!nums.length) return 0;\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.max(nums[0], nums[1]);\\n    \\n    let maxAtTwoBefore = nums[0];\\n    let maxAtOneBefore = Math.max(nums[0], nums[1]);\\n    \\n    for (let i = 2; i < nums.length; i++) {\\n        const maxAtCurrent = Math.max(nums[i] + maxAtTwoBefore, maxAtOneBefore);\\n        \\n        maxAtTwoBefore = maxAtOneBefore;\\n        maxAtOneBefore = maxAtCurrent;\\n    }\\n    \\n    return maxAtOneBefore;\\n};"]}
{"id": "720", "ref_js": ["var rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};", "var rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};", "var rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};"]}
{"id": "721", "ref_js": ["var numIslands = function(grid) {\\n\\tlet count = 0;\\n\\t\\n\\tfunction callDFS(grid, i, j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\n\\t\\tcallDFS(grid, i + 1, j); ", "var numIslands = function(grid) {\\n    if (grid == null || grid.length == 0)\\n        return 0;\\n\\n    nr = grid.length;\\n    nc = grid[0].length;\\n    let counter = 0;\\n    \\n    for(let r=0; r < nr; r++) {\\n        for(let c=0; c < nc; c++) {\\n            if(grid[r][c] == \\'1\\') {\\n                counter++;\\n                ", "var numIslands = function(grid) {\\n    if (grid == null || grid.length == 0)\\n        return 0;\\n\\n    nr = grid.length;\\n    nc = grid[0].length;\\n    let counter = 0;\\n    \\n    for(let r=0; r < nr; r++) {\\n        for(let c=0; c < nc; c++) {\\n            if(grid[r][c] == \\'1\\') {\\n                counter++;\\n                "]}
{"id": "722", "ref_js": ["var rangeBitwiseAnd = function(left, right) {\\n    const p = Math.log2(left ^ right);\\n    return left >> p << p; \\n};", "var rangeBitwiseAnd = function(left, right) {\\n\\n   let count=0;\\n   while(left!=right){\\n       left>>=1;\\n       right>>=1;\\n       count++;\\n   }\\n   return left<< count;\\n};", "var rangeBitwiseAnd = function(left, right) {\\n    var i = 0\\n    while(left != right){\\n        i++\\n        left >>= 1\\n        right >>= 1\\n\\n    }\\n    return left << i\\n};"]}
{"id": "723", "ref_js": ["var countPrimes = function(n) {\\n    let seen = new Uint8Array(n), ans = 0\\n    for (let num = 2; num < n; num++) {\\n        if (seen[num]) continue\\n        ans++\\n        for (let mult = num * num; mult < n; mult += num)\\n            seen[mult] = 1\\n    }\\n    return ans\\n};", "var countPrimes = function(n) {\\n    let hash = new Array(n).fill(true).fill(false, 0,2);\\n    for (let i=2;i*i<n;i++) {\\n        if (hash[i]) {\\n            for(let j=i*i;j<n;j+=i){\\n                hash[j] = false;\\n            }\\n        }\\n    }\\n    return hash.filter((val)=>val).length;\\n};", "var countPrimes = function (n) {\\n\\t"]}
{"id": "724", "ref_js": ["var dfs = function(s, adj, vis){\\n    vis[s] = 2;\\n    for(let i = 0; i < adj[s].length; ++i){\\n        if(vis[adj[s][i]] == 0){\\n            if(dfs(adj[s][i], adj, vis)) \\n                return true;\\n        }\\n        else if(vis[adj[s][i]] == 2) return true;\\n    }\\n    vis[s] = 1;\\n    return false;\\n};", "var canFinish = function(numCourses, prerequisites) {\\n    let graph = Array(numCourses).fill(0).map(() => [])\\n    let inDegree = Array(numCourses).fill(0)\\n    let q = []\\n\\n    for (let[course, prereq] of prerequisites){\\n        graph[prereq].push(course)\\n        inDegree[course] += 1\\n    }\\n\\n    for (let course = 0; course< numCourses; course++){\\n        if(inDegree[course] === 0) q.push(course)\\n    }\\n\\n    while (q.length){\\n        let prereq = q.shift()\\n        numCourses -= 1\\n        for(let course of graph[prereq]){\\n            inDegree[course] -= 1\\n            if(inDegree[course] === 0) q.push(course)\\n        }\\n    }\\n\\n    return numCourses === 0\\n\\n};", "var dfs = function(s, adj, vis){\\n    vis[s] = 2;\\n    for(let i = 0; i < adj[s].length; ++i){\\n        if(vis[adj[s][i]] == 0){\\n            if(dfs(adj[s][i], adj, vis)) \\n                return true;\\n        }\\n        else if(vis[adj[s][i]] == 2) return true;\\n    }\\n    vis[s] = 1;\\n    return false;\\n};"]}
{"id": "726", "ref_js": ["var minSubArrayLen = function(target, nums) {\\n    \\n    let minLength = Infinity; ", "var minSubArrayLen = function(target, nums) {\\n    \\n    let minLength = Infinity; ", "var minSubArrayLen = function(target, nums) {\\n    \\n    let minLength = Infinity; "]}
{"id": "727", "ref_js": ["var findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    ", "var findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    ", "var findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    "]}
{"id": "729", "ref_js": ["var rob = function(nums) {\\n    const len = nums.length;\\n    if (len < 4) return Math.max(...nums);\\n    \\n    function robberHelper(start, end) {\\n        let prev=0, beforePrev=0;\\n        for (let i=start;i<end;i++) {\\n            let tmp = prev;\\n            prev = Math.max(nums[i] + beforePrev, prev);\\n            beforePrev= tmp;\\n        }\\n        return prev;\\n    }\\n    return Math.max(robberHelper(0, len-1), robberHelper(1, len));\\n};", "var rob = function(nums) {\\n  if (nums.length === 1) return nums[0];\\n  \\n  const includeFirst = robHouses(nums, 0, nums.length-1);\\n  const excludeFirst = robHouses(nums, 1, nums.length)\\n  return Math.max(includeFirst, excludeFirst);\\n};", "var rob = function(nums) {\\n    if (nums.length < 2) {\\n        return nums[0] || 0;\\n    }\\n    \\n    const memo1 = [nums[0]];\\n    const memo2 = [0, nums[1]];\\n    \\n    for (let i=1; i<nums.length - 1; i++) {\\n        memo1[i] = Math.max(nums[i] + (memo1[i - 2] || 0), memo1[i - 1]);\\n    }\\n    \\n    for (let i=2; i<nums.length; i++) {\\n        memo2[i] = Math.max(nums[i] + memo2[i - 2], memo2[i - 1]);\\n    }\\n    \\n    return Math.max(memo1.pop(), memo2.pop());\\n};"]}
{"id": "730", "ref_js": ["var findKthLargest = function(nums, k) {\\n    nums.sort((a, b) => b - a);\\n    return nums[k-1];\\n};", "var findKthLargest = function(nums, k) {\\n    ", "var findKthLargest = function(nums, k) {\\n    "]}
{"id": "731", "ref_js": ["var combinationSum3 = function(k, n) {\\n    let results = [];\\n    \\n    if (k > n) {\\n        return [];\\n    }\\n    \\n    backtrack(n, k, [], 0, results);\\n    return results;\\n};", "var combinationSum3 = function(k, n) {\\n    const res = []\\n    \\n    function permute(arr, sum, start) {\\n        if(sum > n) return;\\n        \\n        if(arr.length === k) {\\n            if(sum === n) res.push(arr);\\n            return;\\n        }\\n        \\n        for(let i = start; i < 10; i++) {\\n            permute([...arr, i], sum+i, i+1);\\n        }\\n    }\\n    permute([], 0, 1);\\n    return res;\\n};", "var combinationSum3 = function(k, n) {\\n    const res = []\\n    \\n    function permute(arr, sum, start) {\\n        if(sum > n) return;\\n        \\n        if(arr.length === k) {\\n            if(sum === n) res.push(arr);\\n            return;\\n        }\\n        \\n        for(let i = start; i < 10; i++) {\\n            permute([...arr, i], sum+i, i+1);\\n        }\\n    }\\n    permute([], 0, 1);\\n    return res;\\n};"]}
{"id": "732", "ref_js": ["var maximalSquare = function(matrix) {\\n    ", "var maximalSquare = function(matrix) {\\n    if (!matrix.length) return 0;\\n    let dp = new Array(matrix.length+1).fill(0).map(()=>new Array(matrix[0].length+1).fill(0));\\n    let max = 0;\\n    for (let r=1;r<dp.length;r++) { \\n        for (let c=1;c<dp[0].length;c++) {\\n            if (matrix[r-1][c-1]!=0) {\\n                dp[r][c] = Math.min(dp[r][c-1], dp[r-1][c], dp[r-1][c-1])+1;\\n                max = Math.max(dp[r][c], max);\\n            }\\n        }\\n    }\\n    return max**2;\\n};", "var maximalSquare = function(matrix) {\\n    "]}
{"id": "733", "ref_js": ["var computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\\n    const area2 = (bx2 - bx1) * (by2 - by1);    \\n    \\n    let dx = 0, dy = 0;\\n    dx = getOverlappingSegmentLength([ax1, ax2], [bx1, bx2]);\\n    if (dx != 0) {\\n        ", "var computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\\n    const area2 = (bx2 - bx1) * (by2 - by1);    \\n    \\n    let dx = 0, dy = 0;\\n    dx = getOverlappingSegmentLength([ax1, ax2], [bx1, bx2]);\\n    if (dx != 0) {\\n        ", "var computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\\n    const area2 = (bx2 - bx1) * (by2 - by1);    \\n    \\n    let dx = 0, dy = 0;\\n    dx = getOverlappingSegmentLength([ax1, ax2], [bx1, bx2]);\\n    if (dx != 0) {\\n        "]}
{"id": "734", "ref_js": ["var calculate = function(s) {\\n  let stack = [];\\n  let num = \\'\\';\\n  let sign = null\\n  ", "var calculate = function(s) {\\n\\t\\tconst calculator = s.match(/(\\\\d+)|[+-/*]/g);\\n\\t\\tconst addition = [+calculator.shift()];\\n\\t\\tconst operator = {\\n\\t\\t\\t\\'+\\': (num) => addition.push(num),\\n\\t\\t\\t\\'-\\': (num) => addition.push(-num),\\n\\t\\t\\t\\'*\\': (num) => addition.push(addition.pop() * num),\\n\\t\\t\\t\\'/\\': (num) => addition.push(addition.pop() / num | 0),\\n\\t\\t};", "var calculate = function(s) {\\n  let stack = [];\\n  let num = \\'\\';\\n  let sign = null\\n  "]}
{"id": "735", "ref_js": ["var majorityElement = function(nums) {\\n    let candidate1 = null, candidate2 = null, count1 = 0, count2 = 0;\\n    \\n    for (let num of nums) {\\n        if (num === candidate1) {\\n            count1++;\\n        } else if (num === candidate2) {\\n            count2++;\\n        } else if (count1 === 0) {\\n            candidate1 = num;\\n            count1 = 1;\\n        } else if (count2 === 0) {\\n            candidate2 = num;\\n            count2 = 1;\\n        } else {\\n            count1--;\\n            count2--;\\n        }\\n    }\\n    \\n    count1 = count2 = 0;\\n    \\n    for (let num of nums) {\\n        if (num === candidate1) count1++;\\n        else if (num === candidate2) count2++;\\n    }\\n    \\n    const threshold = Math.floor(nums.length / 3);\\n    const result = [];\\n    \\n    if (count1 > threshold) result.push(candidate1);\\n    if (count2 > threshold) result.push(candidate2);\\n    \\n    return result;\\n};", "var majorityElement = function(nums) {\\n    let candidate1 = 0, candidate2 = 1, count1 = 0, count2 = 0;\\n\\n    for (let num of nums) {\\n        if (num === candidate1) {\\n            count1++;\\n        } else if (num === candidate2) {\\n            count2++;\\n        } else if (count1 === 0) {\\n            candidate1 = num;\\n            count1 = 1;\\n        } else if (count2 === 0) {\\n            candidate2 = num;\\n            count2 = 1;\\n        } else {\\n            count1--;\\n            count2--;\\n        }\\n    }\\n\\n    let result = [];\\n    if (nums.filter(n => n === candidate1).length > nums.length / 3) result.push(candidate1);\\n    if (nums.filter(n => n === candidate2).length > nums.length / 3) result.push(candidate2);\\n    return result;\\n};", "var majorityElement = function(nums) {\\n    let candidate1 = null, candidate2 = null, count1 = 0, count2 = 0;\\n    \\n    for (let num of nums) {\\n        if (num === candidate1) {\\n            count1++;\\n        } else if (num === candidate2) {\\n            count2++;\\n        } else if (count1 === 0) {\\n            candidate1 = num;\\n            count1 = 1;\\n        } else if (count2 === 0) {\\n            candidate2 = num;\\n            count2 = 1;\\n        } else {\\n            count1--;\\n            count2--;\\n        }\\n    }\\n    \\n    count1 = count2 = 0;\\n    \\n    for (let num of nums) {\\n        if (num === candidate1) count1++;\\n        else if (num === candidate2) count2++;\\n    }\\n    \\n    const threshold = Math.floor(nums.length / 3);\\n    const result = [];\\n    \\n    if (count1 > threshold) result.push(candidate1);\\n    if (count2 > threshold) result.push(candidate2);\\n    \\n    return result;\\n};"]}
{"id": "736", "ref_js": ["var kthSmallest = function(root, k) {\\n    let n = 0\\n    let stack = []\\n    let current = root\\n    while (current || stack.length > 0) {\\n        while (current) {\\n            stack.push(current)\\n            current = current.left\\n        }\\n        current = stack.pop()\\n        n += 1\\n        if (n === k) return current.val\\n        current = current.right\\n    }\\n};", "var kthSmallest = function(root, k) {\\n    let count = 0;\\n    let curr = root;\\n    let stack = [];\\n    while (curr || stack.length > 0) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        count++;\\n        if (count == k) return curr.val;\\n        curr = curr.right;\\n    }\\n    return -1;    \\n};", "var kthSmallest = function(root, k) {\\n    let n = 0\\n    let stack = []\\n    let current = root\\n    while (current || stack.length > 0) {\\n        while (current) {\\n            stack.push(current)\\n            current = current.left\\n        }\\n        current = stack.pop()\\n        n += 1\\n        if (n === k) return current.val\\n        current = current.right\\n    }\\n};"]}
{"id": "737", "ref_js": ["var lowestCommonAncestor = function(root, p, q) {\\n    while (root) {\\n        if (root.val < p.val && root.val < q.val) {\\n            root = root.right;\\n        }\\n        else if (root.val > p.val && root.val > q.val) {\\n            root = root.left;\\n        } else {\\n            break;\\n        }\\n    }\\n    return root;\\n};", "var lowestCommonAncestor = function(root, p, q) {\\n    ", "var lowestCommonAncestor = function(root, p, q) {\\n    let max = Math.max(p.val, q.val), min = Math.min(p.val, q.val)\\n    if(root.val == min || root.val == max)    return root\\n    if(root.val < max && root.val > min)  return root\\n    return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q)\\n};"]}
{"id": "738", "ref_js": ["var reverseWords = function(s) {\\n        return s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n    }\\n```\\n``` PHP []\\nclass Solution {\\n    function reverseWords($s) {\\n        return implode(\\' \\', array_map(function($word) {\\n            return strrev($word);\\n        }, explode(\\' \\', $s)));\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        return String.Join(\" \", s.Split(\\' \\').Select(word => new string(word.Reverse().ToArray())));\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::string reverseWords(std::string s) {\\n        std::istringstream stream(s);\\n        std::string word, result;\\n        \\n        while (stream >> word) {\\n            std::reverse(word.begin(), word.end());\\n            result += word + \" \";\\n        }\\n        \\n        if (!result.empty()) {\\n            result.pop_back();  ", "var reverseWords = function(s) {\\n    const words = s.split(\\' \\'); \\n    for (let i = 0; i < words.length; i++) {\\n        words[i] = words[i].split(\\'\\').reverse().join(\\'\\');\\n    }\\n    return words.join(\\' \\');\\n};", "var reverseWords = function(s) {\\n    const words = s.split(\\' \\'); \\n    for (let i = 0; i < words.length; i++) {\\n        words[i] = words[i].split(\\'\\').reverse().join(\\'\\');\\n    }\\n    return words.join(\\' \\');\\n};"]}
{"id": "739", "ref_js": ["var deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};", "var deleteNode = function(node) {\\n    node.val = node.next.val;\\n    node.next = node.next.next;\\n};", "var deleteNode = function(node) {\\n    \\n    if(node ===  null) return;\\n    \\n       else{\\n           if(node.next!==null){\\n                node.val = node.next.val;\\n                node.next =  node.next.next;\\n           }\\n       }\\n};"]}
{"id": "740", "ref_js": ["var productExceptSelf = function(nums) {\\n    const n = nums.length;\\n    const result = new Array(n).fill(1);\\n\\n    let leftProduct = 1;\\n    let rightProduct = 1;\\n\\n    for (let i = 0; i < n; i++) {\\n        result[i] *= leftProduct;\\n        leftProduct *= nums[i];\\n    }\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        result[i] *= rightProduct;\\n        rightProduct *= nums[i];\\n    }\\n\\n    return result;\\n};", "var productExceptSelf = function(nums) {\\n    ", "var productExceptSelf = function(nums) {\\n    const resultArr = []\\n    for(let i=0; i<nums.length; i++){\\n        let productVal = nums[i]\\n        if(resultArr.length !== 0)\\n            productVal = productVal * resultArr[i-1]\\n        resultArr.push(productVal)\\n    }\\n    let productVal = 1\\n    let i=nums.length-1\\n    for(i; i > 0; i--){\\n        resultArr[i] = resultArr[i-1] * productVal\\n        productVal = nums[i] * productVal\\n    }\\n    resultArr[i] = productVal\\n    return resultArr\\n};"]}
{"id": "741", "ref_js": ["var searchMatrix = function(matrix, target) {\\n    for(let ele of matrix){\\n        if(ele[0]<=target&&ele[ele.length-1]>=target){\\n            for(let i=0;i<ele.length;i++){\\n                if(ele[i]==target){\\n                    return true\\n                }\\n            }\\n        }\\n    }\\n    return false\\n};", "var searchMatrix = function(matrix, target) {\\n    for(let ele of matrix){\\n        if(ele[0]<=target&&ele[ele.length-1]>=target){\\n            for(let i=0;i<ele.length;i++){\\n                if(ele[i]==target){\\n                    return true\\n                }\\n            }\\n        }\\n    }\\n    return false\\n};", "var searchMatrix = function(matrix, target) {\\n    for(let ele of matrix){\\n        if(ele[0]<=target&&ele[ele.length-1]>=target){\\n            for(let i=0;i<ele.length;i++){\\n                if(ele[i]==target){\\n                    return true\\n                }\\n            }\\n        }\\n    }\\n    return false\\n};"]}
{"id": "742", "ref_js": ["var diffWaysToCompute = function(expression) {\\n", "var diffWaysToCompute = function(input) {    \\n    let res = [];\\n    for (let i = 0; i < input.length; i++) {\\n        if (isNaN(input[i])) {\\n            let left = diffWaysToCompute(input.slice(0, i));\\n            let right = diffWaysToCompute(input.slice(i+1));\\n            for (let l of left) {\\n                for (let r of right) {\\n                    l = Number(l);\\n                    r = Number(r);\\n                    \\n                    if (input[i]==\\'+\\') {\\n                        res.push(l + r);       \\n                    } else if (input[i]==\\'-\\') {\\n                        res.push(l - r);\\n                    } else {\\n                        res.push(l * r);\\n                    }\\n\\n                }\\n            }\\n        }\\n    }\\n    \\n    if (res.length!=0) return res;\\n    return [input];\\n};", "var diffWaysToCompute = function(expression) {\\n    function calculate (num1, num2, operator) {\\n        switch(operator){\\n            case \\'+\\' : \\n               return num1 + num2;\\n            case \\'-\\' :\\n               return num1 - num2;\\n            case \\'*\\' :\\n               return num1 * num2;\\n        }\\n    }\\n   if(!expression.includes(\\'+\\') && !expression.includes(\\'-\\') && !expression.includes(\\'*\\')){\\n       return [parseInt(expression)];\\n   }\\n\\n   let result = [];\\n   for(let i = 0; i < expression.length; i++){\\n       let curr = expression[i];\\n       if(curr === \\'+\\' || curr === \\'-\\' || curr === \\'*\\'){\\n           let leftPart = expression.substring(0, i);\\n           let rightPart = expression.substring(i + 1);\\n\\n           let leftResult = diffWaysToCompute(leftPart);\\n           let rightResult = diffWaysToCompute(rightPart);\\n\\n           for(let left of leftResult){\\n               for(let right of rightResult){\\n                   result.push(calculate(left, right, curr));\\n               }\\n           }\\n       }\\n   }\\n  return result;\\n};"]}
{"id": "743", "ref_js": ["var singleNumber = function (nums) {\\n\\nconst count = {};", "var singleNumber = function(nums) {\\n    const numCount = new Map();\\n    const result = [];\\n\\n    ", "var singleNumber = function(nums) {\\n    const numCount = new Map();\\n    const result = [];\\n\\n    "]}
{"id": "744", "ref_js": ["var nthUglyNumber = function(n) {\\n    let dp = [1]\\n    let c2 = c3 = c5 = 0\\n    for (let i = 1; i < n; i++) {\\n        dp[i] = Math.min(2 * dp[c2], 3 * dp[c3], 5 * dp[c5])\\n        if (2 * dp[c2] === dp[i]) c2++\\n        if (3 * dp[c3] === dp[i]) c3++\\n        if (5 * dp[c5] === dp[i]) c5++\\n    }\\n    return dp[n - 1]\\n};", "var nthUglyNumber = function(n) {\\n    \\n    if (!n) {\\n        return 0;\\n    }\\n    \\n    ", "var nthUglyNumber = function(n) {\\n    let dp = [1]\\n    let c2 = c3 = c5 = 0\\n    for (let i = 1; i < n; i++) {\\n        dp[i] = Math.min(2 * dp[c2], 3 * dp[c3], 5 * dp[c5])\\n        if (2 * dp[c2] === dp[i]) c2++\\n        if (3 * dp[c3] === dp[i]) c3++\\n        if (5 * dp[c5] === dp[i]) c5++\\n    }\\n    return dp[n - 1]\\n};"]}
{"id": "745", "ref_js": ["var hIndex = function(citations) {\\n    const h = citations.length;\\n  citations.sort ((a,b)=>(a-b));\\n         let i;\\n    for(i=0;i<h;i++){\\n        if(h-i<=citations[i]){\\n            break;\\n        }\\n    }\\n    return h-i;\\n};", "var hIndex = function(citations) {\\n    citations.sort((a, b) => a - b)\\n    let result = 0;\\n    let n = citations.length;\\n    for(let i = 0; i < n; i++){\\n        result = Math.max(result, Math.min(citations[i], n-i))\\n    }\\n    return result;\\n};", "var hIndex = function(citations) {    \\n    citations.sort((a, b) => b - a)    \\n    i = 0\\n\\n    while (citations[i] > i) {        \\n        i ++        \\n    }\\n    \\n    return i \\n};"]}
{"id": "746", "ref_js": ["var hIndex = function(citations) {\\n    let hIndex = 0;\\n    function binarySearch(left, right, arr){\\n        if(left > right) return;\\n        let mid = Math.floor((left + right) / 2);\\n        let noOfCitations = arr.length - mid;\\n        if(arr[mid] >= noOfCitations){\\n            hIndex = Math.max(hIndex, noOfCitations);\\n            binarySearch(left, mid-1, arr);\\n        } else {\\n            binarySearch(mid+1, right, arr)\\n        }\\n    }\\n    binarySearch(0, citations.length-1, citations);\\n    return hIndex;\\n};", "var hIndex = function(citations) {\\n    let hIndex = 0;\\n    let index = citations.length - 1;\\n    for(let i = 1; i <= citations.length; i++){\\n        if(citations[index] >= i) hIndex = i;\\n        else break;\\n        index--;\\n    } \\n   return hIndex;\\n};", "var hIndex = function(citations) {\\n    let hIndex = 0;\\n    function binarySearch(left, right, arr){\\n        if(left > right) return;\\n        let mid = Math.floor((left + right) / 2);\\n        let noOfCitations = arr.length - mid;\\n        if(arr[mid] >= noOfCitations){\\n            hIndex = Math.max(hIndex, noOfCitations);\\n            binarySearch(left, mid-1, arr);\\n        } else {\\n            binarySearch(mid+1, right, arr)\\n        }\\n    }\\n    binarySearch(0, citations.length-1, citations);\\n    return hIndex;\\n};"]}
{"id": "747", "ref_js": ["var numSquares = function(n) {\\n    \\n    ", "var numSquares = function(n) {\\n    \\n    ", "var numSquares = function(n) {\\n    \\n    "]}
{"id": "749", "ref_js": ["var findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  ", "var findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  ", "var findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  "]}
{"id": "750", "ref_js": ["var gameOfLife = function(board) {\\n    ", "var gameOfLife = function(board) {\\n    ", "var gameOfLife = function(board) {\\n    "]}
{"id": "751", "ref_js": ["var getHint = function(secret, guess) {\\n    let bulls = 0, cows = 0;\\n    let secretMap = new Map(), guessMap = new Map();\\n\\n    for (let i = 0; i < secret.length; i++) {\\n        if (secret[i] === guess[i]){\\n            bulls++;\\n        } else {\\n            secretMap.set(secret[i], (secretMap.get(secret[i]) || 0) + 1);\\n            guessMap.set(guess[i], (guessMap.get(guess[i]) || 0) + 1);\\n        }\\n    }\\n\\n    for (let key of guessMap.keys()) {\\n        if (secretMap.has(key)) {\\n            cows += Math.min(secretMap.get(key), guessMap.get(key));\\n        }\\n    }\\n\\n    return `${bulls}A${cows}B`;\\n};", "var getHint = function(secret, guess) {\\n  let map = {}\\n  let bulls = 0, cows = 0\\n\\n  ", "var getHint = function(secret, guess) {\\n  let map = {}\\n  let bulls = 0, cows = 0\\n\\n  "]}
{"id": "752", "ref_js": ["var lengthOfLIS = function(nums) {\\n    const lis = [nums[0]];\\n    for(let i = 1; i < nums.length; i++) {\\n        const curr = nums[i];\\n        if (lis.at(-1) < curr) { ", "var lengthOfLIS = function(nums) {\\n    const lis = [nums[0]];\\n    for(let i = 1; i < nums.length; i++) {\\n        const curr = nums[i];\\n        if (lis.at(-1) < curr) { ", "var lengthOfLIS = function(nums) {\\n    const lis = [nums[0]];\\n    for(let i = 1; i < nums.length; i++) {\\n        const curr = nums[i];\\n        if (lis.at(-1) < curr) { "]}
{"id": "754", "ref_js": ["var isAdditiveNumber = function(num) {\\n    return backtrack(num);\\n};", "var isAdditiveNumber = function(num) {\\n       return backtrack(num);\\n};", "var isAdditiveNumber = function(num) {\\n    const n = num.length; "]}
{"id": "756", "ref_js": ["var maxProfit = function(prices) {\\n     let hash = {};", "var maxProfit = function(prices) {\\n    const n = prices.length\\n    const dp = Array(n*2).fill().map(() => [])\\n    const dfs = function(idx, buying){\\n\\n        if (idx >= prices.length) return 0;\\n        \\n        if (dp[idx][buying] != null) {\\n            return dp[idx][buying];\\n        }\\n        const cooldown = dfs(idx + 1, buying);\\n        if (buying) {\\n            const buy = dfs(idx + 1, !buying) - prices[idx];\\n            dp[idx][buying] = Math.max(buy, cooldown);\\n        } else {\\n            const sell = dfs(idx + 2, !buying) + prices[idx];\\n            dp[idx][buying] = Math.max(sell, cooldown);\\n        }\\n\\n        return dp[idx][buying];\\n    }\\n\\n    return dfs(0, true);\\n};", "var maxProfit = function(prices) {\\n     let hash = {};"]}
{"id": "757", "ref_js": ["var findMinHeightTrees = function(n, edges) {\\n    if (!edges || n < 2) return [0];\\n    let graph = [];\\n\\t", "var findMinHeightTrees = function(n, edges) {\\n    ", "var findMinHeightTrees = function(n, edges) {\\n    if (!edges || n < 2) return [0];\\n    let graph = [];\\n\\t"]}
{"id": "758", "ref_js": ["var nthSuperUglyNumber = function(n, primes) {\\n    const dp = new Array(n); ", "var nthSuperUglyNumber = function(n, primes) {\\n  let index = new Array(primes.length).fill(0);\\n  let dp = new Array(n);\\n  dp[0] = 1;\\n\\n  for(let i = 1; i < n; i++){\\n      let minPrime = Infinity;\\n      for(let j = 0; j < primes.length; j++)\\n      minPrime = Math.min(minPrime, dp[index[j]] * primes[j]);\\n\\n      dp[i] = minPrime;\\n      for(let j = 0; j < primes.length; j++){\\n          if(minPrime === dp[index[j]] * primes[j])\\n          index[j]++;\\n      }\\n  }    \\n return dp[n - 1];\\n};", "var nthSuperUglyNumber = function(n, primes) {\\n    const dp = new Array(n); "]}
{"id": "759", "ref_js": ["var removeDuplicateLetters = function(s) {\\n        let stack = [];\\n        let seen = new Set();\\n        let lastOcc = {};", "var removeDuplicateLetters = function(s) {\\n        let stack = [];\\n        let seen = new Set();\\n        let lastOcc = {};", "var removeDuplicateLetters = function(s) {\\n        let stack = [];\\n        let seen = new Set();\\n        let lastOcc = {};"]}
{"id": "760", "ref_js": ["var maxProduct = function(words) {\\n    words.sort((a,b) => b.length - a.length)\\n    let best = 0, bitsets = new Uint32Array(words.length)\\n    for (let i = 0; i < words.length; i++) {\\n        let word = words[i], wlen = word.length, bitset = 0\\n        if (wlen * words[0].length < best)\\n            return best\\n        for (let j = 0; j < wlen; j++)\\n            bitset |= 1 << (word.charCodeAt(j) - 97)\\n        for (let j = 0; j < i; j++)\\n            if ((bitsets[j] & bitset) === 0)\\n                best = Math.max(best, wlen * words[j].length)\\n        bitsets[i] = bitset\\n    }\\n    return best\\n};", "var maxProduct = function (W) {\\n        const n = W.length;\\n        let ALPHA_SMALL_STR = \"abcdefghijklmnopqrstuvwxyz\";\\n\\n        ", "var maxProduct = function(words) {\\n    words.sort((a,b) => b.length - a.length)\\n    let best = 0, bitsets = new Uint32Array(words.length)\\n    for (let i = 0; i < words.length; i++) {\\n        let word = words[i], wlen = word.length, bitset = 0\\n        if (wlen * words[0].length < best)\\n            return best\\n        for (let j = 0; j < wlen; j++)\\n            bitset |= 1 << (word.charCodeAt(j) - 97)\\n        for (let j = 0; j < i; j++)\\n            if ((bitsets[j] & bitset) === 0)\\n                best = Math.max(best, wlen * words[j].length)\\n        bitsets[i] = bitset\\n    }\\n    return best\\n};"]}
{"id": "761", "ref_js": ["var bulbSwitch = function(n) {\\n    var res=1;\\n    while(res*res<=n){\\n        res++;\\n    }\\n    while(res*res>n){\\n        res--;\\n    }\\n    return res;\\n};", "var bulbSwitch = function(n) {\\n     return Math.floor(Math.sqrt(n));\\n};", "var bulbSwitch = function(n) {\\n     return Math.floor(Math.sqrt(n));\\n};"]}
{"id": "762", "ref_js": ["var coinChange = function(coins, amount) {\\n    if(amount === 0) return 0;\\n    coins = coins.sort((a,b) => a - b);\\n    ", "var coinChange = function(coins, amount) {\\n    const dp = Array(amount+1).fill(amount+1);\\n    dp[0] = 0;\\n    for( let coin of coins ){\\n        for( let i = coin ; i <= amount ; i++ ){\\n            dp[i] = Math.min(dp[i] , dp[i-coin] + 1);\\n        }\\n    }\\n    const ans = dp[dp.length - 1];\\n    return ans == amount+1 ? -1 : ans;\\n};", "var coinChange = function(coins, amount) {\\n    const dp = Array(amount+1).fill(amount+1);\\n    dp[0] = 0;\\n    for( let coin of coins ){\\n        for( let i = coin ; i <= amount ; i++ ){\\n            dp[i] = Math.min(dp[i] , dp[i-coin] + 1);\\n        }\\n    }\\n    const ans = dp[dp.length - 1];\\n    return ans == amount+1 ? -1 : ans;\\n};"]}
{"id": "763", "ref_js": ["var wiggleSort = function(nums) {\\n    let copyNums = [...nums]; ", "var wiggleSort = function(nums) {\\n    nums.sort((a , b) => a - b);\\n    const tmp = [...nums];\\n    let mid = Math.floor((nums.length - 1)/2);\\n    let right = nums.length -1;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(i % 2 === 0) {\\n            nums[i] = tmp[mid];\\n            mid--;\\n        } else {\\n            nums[i] = tmp[right];\\n            right--;\\n        }\\n    }\\n    return nums;\\n};", "var wiggleSort = function(nums) {\\n    let copyNums = nums.slice(0,nums.length);\\n    copyNums.sort((a,b)=>a-b);\\n    let id = copyNums.length-1;\\n\\n    for(let i=1; i<copyNums.length; i+=2){\\n        nums[i] = copyNums[id];\\n        id--;\\n    }\\n        "]}
{"id": "764", "ref_js": ["var oddEvenList = function(head) {\\n    if(!head || !head.next){\\n        return head\\n    }\\n    let flag = true\\n    let odd = head\\n    let even = head.next\\n    let headofEven= head.next\\n    let temp = head.next.next\\n    while(temp){\\n        if(flag){\\n            odd.next=temp\\n            odd=odd.next\\n        }\\n        else{\\n            even.next=temp\\n            even=even.next\\n        }\\n        temp=temp.next\\n        flag=!flag\\n    }\\n    odd.next = headofEven\\n    even.next=null\\n    return head\\n};", "var oddEvenList = function(head) {\\n    if(head == null || head.next == null || head.next.next == null){\\n        return head;\\n    }\\n    let odd = new ListNode(head.val);\\n    let even = new ListNode(head.next.val);\\n    let oddPtr = odd;\\n    let evenPtr = even;\\n    let ptr = head.next.next;\\n    let count = 2;\\n    while(ptr != null){\\n        count++;\\n        if(count % 2 == 0){\\n            let n = new ListNode(ptr.val);\\n            evenPtr.next = n;\\n            evenPtr = evenPtr.next;\\n        }\\n        else{\\n            let n = new ListNode(ptr.val);\\n            oddPtr.next = n;\\n            oddPtr = oddPtr.next;\\n        }\\n        if(ptr.next == null){\\n            oddPtr.next = even;\\n        }\\n        ptr = ptr.next;\\n    }\\n    return odd;\\n};", "var oddEvenList = function(head) {\\n    if (!head) return null;\\n    let odd = head;\\n    let even = head.next;\\n    let evenHead = even;\\n\\n    while (even && even.next) {\\n        odd.next = even.next;\\n        odd = odd.next;\\n        even.next = odd.next;\\n        even = even.next;\\n    }\\n\\n    odd.next = evenHead;\\n    return head;\\n};"]}
{"id": "765", "ref_js": ["var isValidSerialization = function (preorder) {\\n    ", "var isValidSerialization = function(preorder) {\\n   let count = 1;\\n   for(let node of preorder.split(\",\"))\\n   if(count > 0)\\n   if(node === \"#\") --count;\\n   else ++count;\\n   else return false;\\n   return count < 1;    \\n};", "var isValidSerialization = function(preorder) {\\n   let count = 1;\\n   for(let node of preorder.split(\",\"))\\n   if(count > 0)\\n   if(node === \"#\") --count;\\n   else ++count;\\n   else return false;\\n   return count < 1;    \\n};"]}
{"id": "766", "ref_js": ["var increasingTriplet = function(nums) {\\n    let i = null;\\n    let j = null;\\n\\n    for(const num of nums) {\\n        \\n        if(i == null || i >= num) {\\n            i = num;\\n            continue;\\n        }\\n\\n        if(j == null || j >= num) {\\n            j = num;\\n            continue;\\n        }\\n\\n        return true;\\n    }\\n\\n    return false;\\n};", "var increasingTriplet = function(nums) {\\n\\nlet firstNum = Infinity;\\nlet secoundNum = Infinity;\\n\\nfor(let currentNum of nums){\\n\\n    if(currentNum > secoundNum){\\n        return true;\\n    }\\n\\n    if(currentNum > firstNum){\\n        secoundNum = currentNum;\\n    }else{\\n        firstNum = currentNum\\n    }\\n}\\n\\nreturn false;\\n   \\n};", "var increasingTriplet = function(nums) {\\n    let first = Infinity\\n    let second = Infinity\\n    for(let third of nums) {\\n        "]}
{"id": "767", "ref_js": ["var rob = function(root) {\\n    const dfs =(root)=>{\\n        ", "var rob = function(root) {\\n    function helper(node){\\n        if(!node) return [0,0];\\n        const [lr,ln] = helper(node.left);\\n        const [rr, rn] = helper(node.right);\\n        return [node.val + ln + rn, Math.max(lr+rr, ln+rn, lr+rn, ln+rr)];\\n    }\\n    \\n    return Math.max(...helper(root));\\n};", "var rob = function(root) {\\n   const option = travel(root); "]}
{"id": "769", "ref_js": ["var integerBreak = function(n) {\\n    if (n === 2) return 1;\\n    if (n === 3) return 2;\\n\\n    let count_of_3s = Math.floor(n / 3);\\n    let remainder = n % 3;\\n\\n    if (remainder === 0) {\\n        return 3 ** count_of_3s;\\n    } else if (remainder === 1) {\\n        return 3 ** (count_of_3s - 1) * 4;\\n    } else {\\n        return 3 ** count_of_3s * 2;\\n    }\\n};", "var integerBreak = function(n) {\\n    if (n === 2) {\\n        return 1;\\n    }\\n    if (n === 3) {\\n        return 2;\\n    }\\n\\n    ", "var integerBreak = function(n) {\\n    if (n === 2) {\\n        return 1;\\n    }\\n    if (n === 3) {\\n        return 2;\\n    }\\n\\n    "]}
{"id": "770", "ref_js": ["var topKFrequent = function(nums, k) {\\n    const freqMap = new Map();\\n    const bucket = [];\\n    const result = [];\\n    \\n    for(let num of nums) {\\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\\n    }\\n    \\n    for(let [num, freq] of freqMap) {\\n        bucket[freq] = (bucket[freq] || new Set()).add(num);\\n    }\\n    \\n    for(let i = bucket.length-1; i >= 0; i--) {\\n        if(bucket[i]) result.push(...bucket[i]);\\n        if(result.length === k) break;\\n    }\\n    return result;\\n};", "var topKFrequent = function(nums, k) {\\n    const map = new Map(), res = []\\n    nums.forEach(e => map.set(e, (map.get(e) || 0) + 1))\\n    const store = [...map.entries()].sort((a,b) => b[1] - a[1])\\n\\n    for( let i = 0 ; i < k && i < store.length ; i++ )\\n        res.push(store[i][0])\\n\\n    return res\\n};", "var topKFrequent = function(nums, k) {\\n    "]}
{"id": "772", "ref_js": ["var countNumbersWithUniqueDigits = function(n) {\\n    return [1,10,91,739,5275,32491,168571,712891,2345851][n]\\n};", "var countNumbersWithUniqueDigits = function(n) {\\n    let ans = 0;\\n    let bit = 0;\\n\\n    for (;n>=0;n--)\\n    {\\n        let dp = new Array(n+1).fill().map(()=>{\\n            return new Array(Math.pow(2,10)).fill(-1);\\n        })\\n        \\n        ans += fun(n,bit,dp);\\n    }\\n\\n    return ans;\\n};", "var countNumbersWithUniqueDigits = function(n) {\\n    return [1,10,91,739,5275,32491,168571,712891,2345851][n]\\n};"]}
{"id": "773", "ref_js": ["var canMeasureWater = function(a, b, c) {\\n    let set = new Set();\\n    let recur = (value) => {\\n        if(value === c) return true;\\n        if(set.has(value) || value < 0 || value > a + b){\\n            return false;\\n        }\\n        set.add(value);\\n        return recur(value + a) ||\\n               recur(value + b) ||\\n               recur(value - a) ||\\n               recur(value - a); \\n    }\\n  return recur(0);\\n};", "var canMeasureWater = function(x, y, z) {\\n    const set = new Set();\\n    const go = (val) => {\\n        if (val === z) return true;\\n        if (set.has(val) || val < 0 || val > x + y) {\\n            return false;\\n        }\\n        set.add(val);\\n        return go(val + x) ||\\n            go(val + y) ||\\n            go(val - x) ||\\n            go(val - x);\\n    }\\n    return go(0);\\n};", "var canMeasureWater = function(x, y, z) {\\n    const set = new Set();\\n    const go = (val) => {\\n        if (val === z) return true;\\n        if (set.has(val) || val < 0 || val > x + y) {\\n            return false;\\n        }\\n        set.add(val);\\n        return go(val + x) ||\\n            go(val + y) ||\\n            go(val - x) ||\\n            go(val - x);\\n    }\\n    return go(0);\\n};"]}
{"id": "774", "ref_js": ["var largestDivisibleSubset = function(nums) {\\n    const dfs=(i,prev,dp)=>{\\n        const key=prev+\\'_\\'+i;\\n        if(dp.has(key)) return dp.get(key);\\n\\n        if(i===nums.length) return [];\\n        let pick=[];\\n        if(nums[i]%nums[prev]===0 || nums[prev]%nums[i]===0){\\n            pick = [...dfs(i+1,i,dp)];\\n            pick.push(nums[i]);\\n        }\\n        const skip = [...dfs(i+1,prev,dp)];\\n        return dp.set(key, pick.length>skip.length?pick:skip).get(key);\\n    };", "var largestDivisibleSubset = function(nums) {\\n    let n = nums.length, max = 1, lastIdx = 0;\\n    let dp = new Array(n).fill(1);\\n    let hash = new Array(n);\\n    nums.sort((a,b)=>a-b);\\n    for(let idx = 0; idx < n; idx++) {\\n        hash[idx] = idx;\\n        for(let prev = 0; prev < idx; prev++) {\\n            if(nums[idx] % nums[prev] == 0 && dp[idx] < dp[prev] + 1) {\\n                dp[idx] = dp[prev] + 1;\\n                hash[idx] = prev;\\n            }\\n        }\\n        if(max < dp[idx]) {\\n            max = dp[idx];\\n            lastIdx = idx;\\n        }\\n    }\\n    let lds = new Array(max);\\n    lds[--max] = nums[lastIdx];\\n    while(hash[lastIdx] != lastIdx) {\\n        lastIdx = hash[lastIdx];\\n        max--;\\n        lds[max] = nums[lastIdx];\\n    }\\n    return lds;\\n};", "var largestDivisibleSubset = function(nums) {\\n  if(!nums.length) return [];\\n  nums.sort((a, b) => a - b);\\n  let dp = Array.from({length: nums.length}, (_,i) => [nums[i]]);\\n\\n  for(let i = nums.length - 1; i >= 0; i--){\\n      for(let j = i + 1; j < nums.length; j++){\\n          if(dp[i].length <= dp[j].length && dp[j][0] % nums[i] === 0){\\n              dp[i] = [nums[i], ...dp[j]]\\n          }\\n      }\\n  }\\n  return dp.reduce((a, x) => a.length > x.length ? a : x);\\n};"]}
{"id": "775", "ref_js": ["var getSum = function(a, b) {\\n    while (b !== 0) {\\n        const carry = a & b;\\n        a ^= b;\\n        b = carry << 1;\\n        if (b === 0 && carry === 0) break;\\n    }\\n    return a;\\n};", "var getSum = function(a, b) {\\n      let carry;\\n      while((a & b) !== 0){\\n          carry = (a & b) << 1;\\n          a = a ^ b;\\n          b = carry;\\n      }\\n      return a ^ b;\\n};", "var getSum = function(a, b) {\\n    let tb = b;\\n    let res = a;\\n\\n    while (tb) {\\n        let temp = (res & tb) << 1;\\n        res = res ^ tb;\\n        tb = temp;\\n    }\\n\\n    return res;\\n};"]}
{"id": "776", "ref_js": ["var superPow = function(a, b) {\\n\\t\\tconst MOD = 1337;\\n\\t\\tconst pow = (num, n) => {\\n\\t\\t\\tlet result = 1;\\n\\t\\t\\tfor (let index = 0; index < n; index++) {\\n\\t\\t\\t\\tresult = result * num % MOD;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t};", "var superPow = function(a, b) {\\n    let biggy = BigInt(b.join(\"\")), m = 1337, res = 1;\\n    a = a % m;\\n    while(biggy > 0){\\n        if(biggy % 2n == 1) res = (res * a) % m;\\n        a = (a * a) % m;\\n        biggy = biggy >> 1n\\n    }\\n   return res;\\n};", "var superPow = function(a, b) {\\n    let bInt = BigInt(b.join(\"\")), m = 1337, res = 1;\\n    a = a % m;\\n    while (bInt > 0){\\n        if (bInt % 2n == 1) res = (res * a) % m;\\n        a = (a * a) % m;\\n        bInt = bInt >> 1n;\\n    }\\n    return res;\\n};"]}
{"id": "777", "ref_js": ["var kSmallestPairs = function(nums1, nums2, k) {\\n   const m = nums1.length;\\n   const n = nums2.length;\\n   const resultPairs = new Array();\\n   const myHeap = new MinHeap(k);\\n   const visited = new Set();\\n   let currCount = 0;\\n\\n   myHeap.add({indexes: [0,0], sum: nums1[0] + nums2[0]});\\n   visited.add(`0.0`);\\n   while(currCount < k && myHeap.size() > 0){\\n     let newPair = myHeap.pop();\\n     currCount += 1;\\n     let [i, j] = newPair.indexes;\\n     resultPairs.push([nums1[i], nums2[j]]);\\n     if(i + 1 < m && !visited.has(`${i+1}.${j}`)){\\n        myHeap.add({indexes: [i+1, j], sum: nums1[i+1] + nums2[j] });\\n        visited.add(`${i+1}.${j}`);\\n     }\\n\\n     if(j + 1 < n && !visited.has(`${i}.${j+1}`)){\\n        myHeap.add({indexes: [i, j+1], sum: nums1[i] + nums2[j+1] });\\n        visited.add(`${i}.${j+1}`);\\n     }\\n\\n   }\\n   return resultPairs\\n};", "var kSmallestPairs = function(nums1, nums2, k) {\\n    const minHeap = new MinPriorityQueue({ priority: x => x[0] });\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        const num1 = nums1[i];\\n        const num2 = nums2[0];\\n        \\n        minHeap.enqueue([num1 + num2, i, 0]);\\n    }\\n    \\n    const n = nums2.length;\\n    const res = [];\\n    \\n    while (k > 0 && !minHeap.isEmpty()) {\\n        const [sum, idx1, idx2] = minHeap.dequeue().element;\\n        \\n        res.push([nums1[idx1], nums2[idx2]]);\\n        \\n        if (res.length === k) return res;\\n        \\n        if (idx2 < n - 1) {\\n            minHeap.enqueue([nums1[idx1] + nums2[idx2 + 1], idx1, idx2 + 1]);\\n        } \\n    }\\n    \\n    return res;\\n};", "var kSmallestPairs = function(nums1, nums2, k) {\\n    const minHeap = new MinPriorityQueue({ priority: x => x[0] });\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        const num1 = nums1[i];\\n        const num2 = nums2[0];\\n        \\n        minHeap.enqueue([num1 + num2, i, 0]);\\n    }\\n    \\n    const n = nums2.length;\\n    const res = [];\\n    \\n    while (k > 0 && !minHeap.isEmpty()) {\\n        const [sum, idx1, idx2] = minHeap.dequeue().element;\\n        \\n        res.push([nums1[idx1], nums2[idx2]]);\\n        \\n        if (res.length === k) return res;\\n        \\n        if (idx2 < n - 1) {\\n            minHeap.enqueue([nums1[idx1] + nums2[idx2 + 1], idx1, idx2 + 1]);\\n        } \\n    }\\n    \\n    return res;\\n};"]}
{"id": "778", "ref_js": ["var getMoneyAmount = function(n) {\\n  \\n  let dp = Array(n + 1).fill(0).map(() => Array(n + 1).fill(0));\\n  \\n  function calculateCost(start, end) {\\n    \\n    if (start >= end) {\\n      return 0;\\n    }\\n\\n    if (dp[start][end] !== 0) {\\n      return dp[start][end];\\n    }\\n    \\n    let minCost = Infinity;\\n    \\n    for (let guess = Math.floor((start + end) / 2); guess <= end; guess++) {\\n      \\n      let cost = guess + Math.max(calculateCost(start, guess - 1), calculateCost(guess + 1, end));\\n      \\n      minCost = Math.min(minCost, cost);\\n    }\\n\\n    dp[start][end] = minCost;\\n    return minCost;\\n  }\\n  \\n  return calculateCost(1, n);  \\n};", "var getMoneyAmount = function(n) {\\n   let dpArr = Array.from({ length: n + 1}, () => new Array(n + 1).fill(0));\\nfunction dp(i, j){\\n       if(i >= j) return 0;\\n       return dpArr[i][j];\\n   } \\n\\n   for(let dis = 1; dis <= n - 1; dis++){\\n       for(let i = 1; i <=n - dis; i++){\\n           let minCost = 200 * 200;\\n           for(let k = i; k <= i + dis; k++){\\n               minCost = Math.min(minCost, Math.max(dp(i, k - 1) + k, dp(k + 1, i + dis) + k));\\n           }\\n        dpArr[i][i + dis] = minCost;\\n       }\\n   }\\n  return dp(1, n)\\n};", "var getMoneyAmount = function(n) {\\n   let dpArr = Array.from({ length: n + 1}, () => new Array(n + 1).fill(0));\\nfunction dp(i, j){\\n       if(i >= j) return 0;\\n       return dpArr[i][j];\\n   } \\n\\n   for(let dis = 1; dis <= n - 1; dis++){\\n       for(let i = 1; i <=n - dis; i++){\\n           let minCost = 200 * 200;\\n           for(let k = i; k <= i + dis; k++){\\n               minCost = Math.min(minCost, Math.max(dp(i, k - 1) + k, dp(k + 1, i + dis) + k));\\n           }\\n        dpArr[i][i + dis] = minCost;\\n       }\\n   }\\n  return dp(1, n)\\n};"]}
{"id": "779", "ref_js": ["var wiggleMaxLength = function(N) {\\n    let len = N.length, i = 1\\n    while (N[i] === N[i-1]) i++\\n    let up = N[i-1] > N[i], ans = 1\\n    for (; i < len; i++)\\n        if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1]))\\n            up = !up, ans++\\n    return ans\\n};", "var wiggleMaxLength = function(nums) {\\n  \\n    let n = nums.length;\\n    \\n    ", "var wiggleMaxLength = function(nums) {\\n    if( nums.length < 2 ) return nums.length;\\n    var i, last=nums[0];\\n    var state = ( nums[1] > last ) ? 1 : 0;\\n    \\n    return 1+dfs(nums, 1, 2, {});\\n};"]}
{"id": "780", "ref_js": ["var combinationSum4 = function(nums, target) {\\n    const dp = new Array(target + 1).fill(0);\\n    dp[0] = 1;\\n\\n    for (let i = 1; i <= target; i++) {\\n        for (const n of nums) {\\n            if (n <= i) {\\n                dp[i] += dp[i - n];\\n            }\\n        }\\n    }\\n\\n    return dp[target];    \\n};", "var combinationSum4 = function(nums, target) {\\n    const dp = Array(target + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (let i = 1; i <= target; i++) {\\n        for (const num of nums) {\\n            if (i - num >= 0) {\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n    }\\n    \\n    return dp[target];\\n};", "var combinationSum4 = function(nums, target) {\\n    const dp = Array(target + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (let i = 1; i <= target; i++) {\\n        for (const num of nums) {\\n            if (i - num >= 0) {\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n    }\\n    \\n    return dp[target];\\n};"]}
{"id": "781", "ref_js": ["var kthSmallest = function(matrix, k) {\\n     return matrix.flat().sort((a, b) => a - b)[k - 1];  \\n};", "var kthSmallest = function(matrix, k) {\\n     return matrix.flat().sort((a, b) => a - b)[k - 1];  \\n};", "var kthSmallest = function(matrix, k) {\\n     return matrix.flat().sort((a, b) => a - b)[k - 1];  \\n};"]}
{"id": "785", "ref_js": ["var deserialize = function(s) {\\n   let helperFunc = (input) => {\\n       if(Number.isInteger(input)) return new NestedInteger(input);\\n       let x = new NestedInteger();\\n       for(let e of input) x.add(helperFunc(e));\\n       return x;\\n   }    \\n   let y = JSON.parse(s);\\n   return helperFunc(y);\\n};", "var deserialize = function(s) {\\n    const helper = (input) => {\\n        if (Number.isInteger(input)) return new NestedInteger(input); \\n        let l = new NestedInteger();\\n        for (const e of input) l.add(helper(e));\\n        return l;\\n    };", "var deserialize = function(s) {\\n    const helper = (input) => {\\n        if (Number.isInteger(input)) return new NestedInteger(input); \\n        let l = new NestedInteger();\\n        for (const e of input) l.add(helper(e));\\n        return l;\\n    };"]}
{"id": "786", "ref_js": ["var lexicalOrder = function(n) {\\n  const a = new Array(n)\\n  for(let i = 0; i < n; i++){\\n    a[i] = i + 1;\\n  }\\n  return a.sort()\\n};", "var lexicalOrder = function(n) {\\n\\n        function pushFromTo( start, end ) {\\n            \\n            while( start<=end && start<=n ){ \\n                result.push(start);   \\n\\n                \\n\\t\\t\\t\\tpushFromTo(start*10, start*10+9)\\n\\n                start++   \\n            }\\n\\n        }\\n\\n   var result = [];\\n\\n    \\n   pushFromTo( 1, 9);\\n\\n   return result;\\n };", "var lexicalOrder = function(n) {\\n    const arr = [];\\n    \\n    function dfs(baseIndex) {\\n        if (baseIndex * 10 > n) {\\n            return;\\n        }\\n        \\n        for(let i = baseIndex * 10; i < baseIndex * 10 + 10 && i <= n; i++)  {\\n           arr.push(i);\\n           dfs(i);\\n        }\\n    }\\n    \\n    let stack = [];\\n    \\n    for(let i = 1; i <= 9 && i <= n; i++) {\\n        arr.push(i);        \\n        dfs(i);\\n    }\\n    \\n    return arr;\\n};"]}
{"id": "787", "ref_js": ["var lengthLongestPath = function(input) {\\n    let dir = input.split(\\'\\\\n\\');\\n    let max = 0;\\n    let length = [];\\n    let depth= 0;\\n    for (let i=0;i<dir.length;i++) {\\n        depth = dir[i].lastIndexOf(\\'\\\\t\\')+1;\\n        if (dir[i].includes(\\'.\\')) {\\n            let fileLength = dir[i].length-depth;\\n            max = Math.max((length[depth-1]+1||0) + fileLength , max);\\n        } else {\\n            length[depth] = dir[i].length - depth + (length[depth-1]+1||0);\\n        }\\n    }\\n    return max;\\n};", "var lengthLongestPath = function(input) {\\n    const segments = input.split(\\'\\\\n\\');\\n    \\n    let max = 0;\\n    let path = [];\\n    for (const segment of segments) {\\n        if (segment.startsWith(\\'\\\\t\\')) {\\n            const nesting = segment.match(/\\\\t/g).length;\\n            \\n            while (nesting < path.length) {\\n                path.pop();\\n            }\\n            \\n            path.push(segment.replace(/\\\\t/g, \\'\\'))\\n        } else {\\n            path = [segment]\\n        }\\n        \\n        if (isFile(path.at(-1))) {\\n            const filePath = path.join(\\'/\\');\\n            if (filePath.length > max) {\\n                max = filePath.length;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n};", "var lengthLongestPath = function(input) {\\n    let map = {};"]}
{"id": "788", "ref_js": ["var lastRemaining = function(n) {\\n    let head=1,left=true,step=1,remain=n\\n\\n    while(remain>1){\\n        if(left || remain%2){\\n            head+=step\\n        }\\n\\n        step*=2\\n        left=!left\\n        remain=Math.floor(remain/2)\\n    }\\n\\n    return head\\n};", "var lastRemaining = function(n) {\\n    let head = 1;\\n    let left = 1;\\n    let step = 1;\\n    let remain = n;\\n\\n    while(remain > 1){\\n        if(left || remain % 2){\\n            head += step;\\n        }\\n        step *= 2;\\n        left =! left;\\n        remain = ~~(remain / 2);\\n    }\\n   return head;\\n};", "var lastRemaining = function(n) {\\n    \\n    "]}
{"id": "789", "ref_js": ["var validUtf8 = function(data) {\\n    \\n    let binary = data.map(d => { ", "var validUtf8 = function(data) {\\n    let j = 0, count = 0;\\n    \\n    while(j < data.length){\\n        let ele = data[j].toString(2);\\n        ele = \"00000000\".substring(ele.length) + ele;\\n        if(ele.substring(0,2) === \"10\")\\n            return false;\\n    \\n        for(key in myObj){\\n            if(ele.startsWith(key))\\n                count = myObj[key];\\n        }\\n        if(count > 4)\\n            return false;\\n        \\n        for(var i = j+1;i<j+count;i++){\\n            let elem = data[i];\\n            if(elem === undefined) return false;\\n            let val = elem.toString(2);\\n            val = \"00000000\".substring(val.length) + val;\\n            if(val.substring(0,2) !== \"10\") return false;\\n        }\\n        j  =  i;\\n    }\\n    return true;\\n};", "var validUtf8 = function(data) {\\n    \\n    let binary = data.map(d => { "]}
{"id": "790", "ref_js": ["var decodeString = function (s) {\\n    return decode(s, 0, s.length - 1, composeBracketsDictionary(s));\\n};", "var decodeString = function (s) {\\n    return decode(s, 0, s.length - 1, composeBracketsDictionary(s));\\n};", "var decodeString = function (s) {\\n    return decode(s, 0, s.length - 1, composeBracketsDictionary(s));\\n};"]}
{"id": "791", "ref_js": ["var longestSubstring = function(s, k) {\\n    let maxUnique = new Set(s).size;\\n    ", "var longestSubstring = function(s, k) {\\n  \\n    let uniqueLetterMax = new Set(s).size;\\n    let max = 0;\\n   \\n    ", "var longestSubstring = function (s, k) {\\n    const totalUnique = new Set(s).size\\n    let longest = 0\\n\\n    "]}
{"id": "792", "ref_js": ["var maxRotateFunction = function(nums) {\\n    const n = nums.length;\\n    let totalSum = 0;\\n    let perRoundSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        totalSum += nums[i];\\n        perRoundSum += i * nums[i];\\n    }\\n\\n    let answer = perRoundSum;\\n\\n    for (let i = 1; i < n; i++) {\\n        const rotatedNum = nums[n - i];\\n        perRoundSum = perRoundSum - (rotatedNum * (n - 1)) + (totalSum - rotatedNum);\\n        answer = Math.max(answer, perRoundSum);\\n    }\\n\\n    return answer;\\n};", "var maxRotateFunction = function(nums) {\\n    const sum = nums.reduce((acc, cur) => acc + cur);\\n    let fx = nums.reduce((acc, cur, idx) => acc + cur * idx, 0), maxF = fx;\\n\\n    for (let i = nums.length - 1; i > 0; i--) {\\n        fx += sum - nums.length * nums[i];\\n        maxF = Math.max(maxF, fx);\\n    }\\n\\n    return maxF;\\n};", "var maxRotateFunction = function(nums) {\\n    let n = nums.length;\\n    let dp = 0;\\n    let sum = 0;\\n    for(let i = 0; i < n; i++){\\n        sum += nums[i];\\n        dp += i * nums[i];\\n    }\\n    let max = dp;\\n    for(let i = 1; i < n; i++){\\n        dp += sum - nums[n - i] * n;\\n        max = Math.max(max, dp);\\n    }\\n   return max;\\n};"]}
{"id": "793", "ref_js": ["var integerReplacement = function(n) {\\n    let count =0;\\n    \\n    while(n > 1){\\n        if(n ===3) return count + 2\\n        if(n % 2 ===0){\\n            n /= 2;\\n        }else{\\n            if(((n+1)/2)%2 === 0) n += 1;\\n            else n -= 1\\n        }\\n        count += 1 \\n    }\\n    return count\\n};", "var integerReplacement = function(n) {\\n let count = 0;\\n  while (n != 1) {\\n    if (n === 3) {\\n      n = n + 1;\\n    }\\n\\n    if (n % 2 == 0) {\\n      n = n / 2;\\n    } else {\\n      if (((n + 1) / 2) % 2 === 0) {\\n        n = n + 1;\\n      } else {\\n        n = n - 1;\\n      }\\n    }\\n    count++;\\n  }\\n  return count;\\n};", "var integerReplacement = function(n) {\\n let count = 0;\\n  while (n != 1) {\\n    if (n === 3) {\\n      n = n + 1;\\n    }\\n\\n    if (n % 2 == 0) {\\n      n = n / 2;\\n    } else {\\n      if (((n + 1) / 2) % 2 === 0) {\\n        n = n + 1;\\n      } else {\\n        n = n - 1;\\n      }\\n    }\\n    count++;\\n  }\\n  return count;\\n};"]}
{"id": "795", "ref_js": ["var calcEquation = function(equations, values, queries) {\\n  \\n  ", "var calcEquation = function(equations, values, queries) {\\n  \\n  ", "var calcEquation = function(equations, values, queries) {\\n  \\n  "]}
{"id": "796", "ref_js": ["var findNthDigit = function(n) {\\n    var len = 1;\\n    var range = 9;\\n    var base = 1;\\n    while(n>len*range)\\n    {\\n        n -= len *range;\\n        range *= 10;\\n        base *= 10;\\n        len++;\\n    }\\n    ", "var findNthDigit = function(n) {\\n  n -= 1;\\n  for(let digits = 1; digits < 11; digits++){\\n      let first = Math.pow(10, digits - 1);\\n      let nums = 9 * first * digits;\\n      if(n < nums){\\n          return ((first + n/digits) + \\'\\')[n % digits] - 0;\\n      }\\n    n -= nums;\\n  }    \\n  return 0;\\n};", "var findNthDigit = function(n) {\\n    var len = 1;\\n    var range = 9;\\n    var base = 1;\\n    while(n>len*range)\\n    {\\n        n -= len *range;\\n        range *= 10;\\n        base *= 10;\\n        len++;\\n    }\\n    "]}
{"id": "797", "ref_js": ["var removeKdigits = function(num, k) {\\n   var stack = []\\n    for(let c of num){\\n        while(stack.length && k>0 && stack[stack.length-1] > c){\\n            stack.pop()\\n            k--\\n        }\\n        stack.push(c)\\n    }\\n    while(stack.length && k>0){\\n        stack.pop()\\n        k--\\n    } \\n    while(stack.length && stack[0] == \\'0\\'){\\n        stack.shift()\\n    }\\n    return stack.join(\\'\\') || \"0\"    \\n};", "var removeKdigits = function(num, k) {\\n    const stack = [];\\n    let removed = 0;\\n    for(let n of num) {\\n        while(stack.length && n < stack[stack.length-1] && removed < k) {\\n            stack.pop();\\n            removed += 1;\\n        }\\n        stack.push(n);\\n    }\\n    \\n    ", "var removeKdigits = function(num, k) {\\n    const stack = [];\\n    let removed = 0;\\n    for(let n of num) {\\n        while(stack.length && n < stack[stack.length-1] && removed < k) {\\n            stack.pop();\\n            removed += 1;\\n        }\\n        stack.push(n);\\n    }\\n    \\n    "]}
{"id": "798", "ref_js": ["var reconstructQueue = function(people) {\\n    let res = []\\n    people.sort((a, b) => a[0] == b[0] ? a[1] - b[1] : b[0] - a[0])\\n    people.forEach(val => {\\n        res.splice(val[1], 0, val)\\n    })\\n    return res\\n};", "var reconstructQueue = function(people) {\\n    var queue = new Array(people.length);\\n    people = people.sort((a,b) => (a[0]-b[0]));\\n    for(let i =0;i<people.length;i++){\\n        let count = 0;\\n        for(let j= 0;j<queue.length;j++){\\n            if(!queue[j]){\\n                if(count == people[i][1]){\\n                    queue[j] = people[i];\\n                    break;\\n                }\\n                count++;\\n            }\\n            else if( queue[j][0] >= people[i][0]){\\n                count++;\\n            }\\n        }\\n    }\\n    return queue;\\n};", "var reconstructQueue = function(people) {\\n    let res = []\\n    people.sort((a, b) => a[0] == b[0] ? a[1] - b[1] : b[0] - a[0])\\n    people.forEach(val => {\\n        res.splice(val[1], 0, val)\\n    })\\n    return res\\n};"]}
{"id": "799", "ref_js": ["var numberOfArithmeticSlices = function (A) {\\n\\tlet sum = 0,\\n\\t\\tdp = Array(A.length).fill(0);\\n\\n\\tfor (var i = 2; i <= dp.length - 1; i++) {\\n\\t\\tif (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {\\n\\t\\t\\tdp[i] = 1 + dp[i - 1];\\n\\t\\t\\tsum += dp[i];\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n};", "var numberOfArithmeticSlices = function (A) {\\n\\tlet sum = 0,\\n\\t\\tdp = Array(A.length).fill(0);\\n\\n\\tfor (var i = 2; i <= dp.length - 1; i++) {\\n\\t\\tif (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {\\n\\t\\t\\tdp[i] = 1 + dp[i - 1];\\n\\t\\t\\tsum += dp[i];\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n};", "var numberOfArithmeticSlices = function (A) {\\n\\tlet sum = 0,\\n\\t\\tdp = Array(A.length).fill(0);\\n\\n\\tfor (var i = 2; i <= dp.length - 1; i++) {\\n\\t\\tif (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {\\n\\t\\t\\tdp[i] = 1 + dp[i - 1];\\n\\t\\t\\tsum += dp[i];\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n};"]}
{"id": "800", "ref_js": ["var canPartition = function (nums) {\\n    const totalSum = nums.reduce((acc, item) => acc + item, 0);\\n    if (totalSum % 2) return false;\\n    const target = totalSum / 2;\\n    const dp = new Array(nums.length).fill(-1).map(() => new Array(target + 1).fill(-1));\\n\\n    function dfs(idx, target) {\\n        if (target === 0) return true;\\n        if (target < 0) return false;\\n        if (dp[idx][target] !== -1) return dp[idx][target];\\n\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (dfs(i, target - nums[idx]) || dfs(i, target)) return true;\\n        }\\n        return dp[idx][target] = false;\\n    }\\n    return dfs(0, target);\\n};", "var canPartition = function (nums) {\\n    const totalSum = nums.reduce((acc, item) => acc + item, 0);\\n    if (totalSum % 2) return false;\\n    const target = totalSum / 2;\\n    const dp = new Array(nums.length).fill(-1).map(() => new Array(target + 1).fill(-1));\\n\\n    function dfs(idx, target) {\\n        if (target === 0) return true;\\n        if (target < 0) return false;\\n        if (dp[idx][target] !== -1) return dp[idx][target];\\n\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (dfs(i, target - nums[idx]) || dfs(i, target)) return true;\\n        }\\n        return dp[idx][target] = false;\\n    }\\n    return dfs(0, target);\\n};", "var canPartition = function (nums) {\\n    const totalSum = nums.reduce((acc, item) => acc + item, 0);\\n    if (totalSum % 2) return false;\\n    const target = totalSum / 2;\\n    const dp = new Array(nums.length).fill(-1).map(() => new Array(target + 1).fill(-1));\\n\\n    function dfs(idx, target) {\\n        if (target === 0) return true;\\n        if (target < 0) return false;\\n        if (dp[idx][target] !== -1) return dp[idx][target];\\n\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (dfs(i, target - nums[idx]) || dfs(i, target)) return true;\\n        }\\n        return dp[idx][target] = false;\\n    }\\n    return dfs(0, target);\\n};"]}
{"id": "801", "ref_js": ["var pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};", "var pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};", "var pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};"]}
{"id": "802", "ref_js": ["var countBattleships = function (board) {\\n  ", "var countBattleships = function(board) {\\n    let count = 0;\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[i].length; j++) {\\n            if (board[i][j] === \\'X\\'\\n                && board[i][j-1] !== \\'X\\'\\n                && (!board[i-1] || board[i-1][j] !== \\'X\\')) count++;\\n        }\\n    }\\n    return count;\\n};", "var countBattleships = function(board) {\\n    let count= 0 ; \\n    let rows = board.length ; \\n    let cols = board[0].length ; \\n    let visited = new Set() ; \\n    for(let r = 0 ; r < rows ; ++r){\\n        for(let c = 0 ; c < cols ; ++c){\\n            if(explorer(board , r , c , visited) == true){\\n                ++count; \\n            } \\n        }\\n    }\\n    if(count == 105) return 100 ; \\n    if(count == 344) return 331 ; \\n    if(count == 487) return 457 ; \\n    return count ; \\n};"]}
{"id": "803", "ref_js": ["var findMaximumXOR = function (nums) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let res = 0;\\n\\n  let m = 0;\\n  let p = 0;\\n  let ll = 0;\\n  let rr = 0;\\n  let bsl = 0;\\n  let bsr = 0;\\n  let b = 0;\\n\\n  for (let r = 0; r < n; r++) {\\n    m = (nums[r] + 1) >> 1;\\n    b = Math.ceil(Math.log2(nums[r] + 1));\\n\\n    ll = 0;\\n    rr = r;\\n\\n    while (nums[rr] != nums[ll]) {\\n      if (getBit(nums[rr], b) != getBit(nums[ll], b)) {\\n        p = ll;\\n        bsl = ll;\\n        bsr = rr;\\n        while (bsl <= bsr) {\\n          m = (bsl + bsr) >> 1;\\n          if (getBit(nums[m], b)) bsr = m - 1;\\n          else {\\n            bsl = m + 1;\\n            p = m;\\n          }\\n        }\\n        if (getBit(nums[r], b)) rr = p;\\n        else ll = p + 1;\\n      }\\n\\n      b--;\\n    }\\n\\n    res = Math.max(res, nums[r] ^ nums[rr]);\\n  }\\n\\n  return res;\\n};", "var findMaximumXOR = function(nums) {\\n  let trie = new Trie();\\n  let root = trie.root;\\n  \\n  ", "var findMaximumXOR = function (nums) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let res = 0;\\n\\n  let m = 0;\\n  let p = 0;\\n  let ll = 0;\\n  let rr = 0;\\n  let bsl = 0;\\n  let bsr = 0;\\n  let b = 0;\\n\\n  for (let r = 0; r < n; r++) {\\n    m = (nums[r] + 1) >> 1;\\n    b = Math.ceil(Math.log2(nums[r] + 1));\\n\\n    ll = 0;\\n    rr = r;\\n\\n    while (nums[rr] != nums[ll]) {\\n      if (getBit(nums[rr], b) != getBit(nums[ll], b)) {\\n        p = ll;\\n        bsl = ll;\\n        bsr = rr;\\n        while (bsl <= bsr) {\\n          m = (bsl + bsr) >> 1;\\n          if (getBit(nums[m], b)) bsr = m - 1;\\n          else {\\n            bsl = m + 1;\\n            p = m;\\n          }\\n        }\\n        if (getBit(nums[r], b)) rr = p;\\n        else ll = p + 1;\\n      }\\n\\n      b--;\\n    }\\n\\n    res = Math.max(res, nums[r] ^ nums[rr]);\\n  }\\n\\n  return res;\\n};"]}
{"id": "804", "ref_js": ["var originalDigits = function (s) {\\n  let arr = [\\n    ", "var originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};", "var originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};"]}
{"id": "805", "ref_js": ["var characterReplacement = function(s, k) {\\n    ", "var characterReplacement = function(s, k) {\\n    ", "var characterReplacement = function(s, k) {\\n    "]}
{"id": "807", "ref_js": ["var levelOrder = function(root) {\\n    if (!root) return [];\\n\\n    let queue = [[root, 0]];\\n    let currentLevel = 0;\\n    let out = [[]];\\n\\n    while (queue.length != 0) {\\n\\n        let [elem, level] = queue.shift();\\n        if (level == currentLevel) {\\n            out[currentLevel].push(elem.val);\\n        } else {\\n            currentLevel++;\\n            out.push([elem.val]);\\n        }\\n        elem.left != null ? queue.push([elem.left, level + 1]): null;\\n        elem.right != null ? queue.push([elem.right, level + 1]): null;\\n\\n        \\n        for (let i = 0; i < elem.children.length; i++) {\\n            queue.push([elem.children[i], level + 1]);\\n        }\\n    }\\n    return out;\\n};", "var levelOrder = function(root) {\\n    let list = []\\n    function lvls(root, level){\\n        if (!root) return\\n        if (level === list.length)  list.push([])\\n        list[level].push(root.val)\\n        root.children.forEach(child => lvls(child, level+1))\\n    }\\n    lvls(root, 0)\\n    return list\\n};", "var levelOrder = function(root) {\\n    "]}
{"id": "809", "ref_js": ["var minMutation = function(start, end, bank) {\\n    if (bank.filter(item => item === end)?.length < 1) return -1;\\n        \\n    const loop = (current, currentBank) => {\\n        let output = Infinity;\\n        if (getDifferent(end, current) === 1) return 1;\\n\\n        for (let i = 0; i < currentBank.length; i++) {\\n            if (getDifferent(current, currentBank[i]) === 1) {\\n                const newBank = currentBank.filter(item => item !== currentBank[i]);\\n                const newCount = loop(currentBank[i], newBank);\\n                if (newCount !== - 1) output = Math.min(output, newCount);\\n            }\\n        }\\n\\n        return output !== Infinity ? output + 1 : -1;\\n    }\\n    return loop(start, bank);\\n};", "var minMutation = function(start, end, bank) {\\n    let tempBanks = new Set(bank);  \\n    let strChars = [\\'A\\', \\'T\\', \\'C\\', \\'G\\'];        \\n    let Q = [[start,0]];\\n    let item, dist, i, j;\\n    if( !tempBanks.has(end) ) return -1;\\n    \\n    while( Q.length > 0 ) {\\n        [item,dist] = Q.shift();\\n        if( item == end ) return dist;\\n        \\n        for( i=0; i<8; i++ ) {\\n            for( j=0; j<4; j++ ) {\\n                if( item[i] == strChars[j] ) continue;\\n                var node = item.slice(0,i) + strChars[j] + item.slice(i+1);\\n                if( tempBanks.has(node) ) {\\n                    Q.push([node,dist+1]);\\n                    tempBanks.delete(node);\\n                }\\n            }\\n        }\\n    }   \\n    return -1;\\n};", "var minMutation = function(start, end, bank) {\\n    let tempBanks = new Set(bank);  \\n    let strChars = [\\'A\\', \\'T\\', \\'C\\', \\'G\\'];        \\n    let Q = [[start,0]];\\n    let item, dist, i, j;\\n    if( !tempBanks.has(end) ) return -1;\\n    \\n    while( Q.length > 0 ) {\\n        [item,dist] = Q.shift();\\n        if( item == end ) return dist;\\n        \\n        for( i=0; i<8; i++ ) {\\n            for( j=0; j<4; j++ ) {\\n                if( item[i] == strChars[j] ) continue;\\n                var node = item.slice(0,i) + strChars[j] + item.slice(i+1);\\n                if( tempBanks.has(node) ) {\\n                    Q.push([node,dist+1]);\\n                    tempBanks.delete(node);\\n                }\\n            }\\n        }\\n    }   \\n    return -1;\\n};"]}
{"id": "810", "ref_js": ["var eraseOverlapIntervals = function(intervals) {\\n    let res = 0;\\n    intervals.sort((a, b) => a[1] - b[1]);\\n    let prev_end = intervals[0][1];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        if (prev_end > intervals[i][0]) {\\n            res++;\\n        } else {\\n            prev_end = intervals[i][1];\\n        }\\n    }\\n\\n    return res;    \\n};", "var eraseOverlapIntervals = function(intervals) {\\n   if(intervals.length < 2) return 0;\\n        intervals.sort((a,b)=>a[0] - b[0]);\\n        let count = 0 , last_included = 0;\\n        for(let i =1; i <intervals.length; ++i){\\n            if(intervals[i][0] < intervals[last_included][1]){\\n                count++;\\n            if(intervals[i][1] < intervals[last_included][1])\\n            last_included = i;\\n            }\\n            else\\n            last_included = i;\\n        }\\n        return count; \\n};", "var eraseOverlapIntervals = function(intervals) {\\n\\t"]}
{"id": "811", "ref_js": ["var findRightInterval = function(intervals) {\\n    let begin = [];\\n    for(let i = 0; i < intervals.length; i++){\\n        begin[i] = [intervals[i][0], i];\\n    }\\n\\n    begin.sort((item1, item2) => item1[0] - item2[0]);\\n\\n    let answer = [];\\n    for(let i = 0; i < intervals.length; i++){\\n        let end = intervals[i][1];\\n        let low = 0;\\n        let high = begin.length - 1;\\n        let leftMost = -1;\\n        while(low <= high){\\n            let mid = ~~((low + high) / 2);\\n            if(begin[mid][0] >= end){\\n                leftMost = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n       answer.push(leftMost === -1 ? -1 : begin[leftMost][1]);\\n    }\\n    return answer;\\n};", "var findRightInterval = function(intervals) {\\n    const n = intervals.length;\\n    const res = new Array(n).fill(-1);\\n    const minHeap = new MinPriorityQueue({compare: (a, b) => a[0] - b[0]});\\n\\n    const indexedIntervals = intervals\\n        .map((int, idx) => [int, idx])\\n        .sort((a, b) => a[0][0] - b[0][0]);\\n\\n    for (let i = 0; i < n; i++) {\\n        const [interval, index] = indexedIntervals[i]; \\n        const [start, end] = interval;\\n\\n        if (start === end) {\\n            res[index] = index\\n            continue\\n        }\\n\\n        while (!minHeap.isEmpty() && minHeap.front()[0] <= start) {\\n            const [, origIdx] = minHeap.dequeue();\\n            res[origIdx] = index; \\n        }\\n\\n        minHeap.enqueue([end, index]); \\n    }\\n\\n    return res;\\n};", "var findRightInterval = function(intervals) {\\n    let result = [];\\n    let n = intervals.length;\\n    let startIntervals = [];\\n    let startIndexes = [];\\n\\n    for(let i = 0; i < n; i++){\\n        startIntervals.push(intervals[i][0]);\\n        startIndexes[intervals[i][0]] = i;\\n        result[i] = -1;\\n    }\\n\\n    startIntervals.sort((a,b) => a - b);\\n\\n    for(let i = 0; i < n; i++){\\n        let left = 0;\\n        let right = n - 1;\\n\\n        let target = intervals[i][1];\\n        let currentIntervalStartIndex = startIndexes[intervals[i][0]];\\n\\n        while(left <= right){\\n\\n            let mid = Math.floor((left + right)/2);\\n            let startIntervalMid = startIntervals[mid];\\n\\n            if(startIntervalMid >= target){\\n                result[currentIntervalStartIndex] = startIndexes[startIntervalMid];\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n            }\\n\\n        }\\n    }\\n\\n    return result;\\n};"]}
{"id": "812", "ref_js": ["var pathSum = function(root, targetSum) {\\n    if(!root) return 0;\\n    let count = 0;\\n    \\n    function helper(node, sum){\\n        if(!node) return;\\n\\t\\t", "var pathSum = function(root, targetSum) {\\n    if(!root) return 0;\\n    let count = 0;\\n    \\n    function helper(node, sum){\\n        if(!node) return;\\n\\t\\t", "var pathSum = function(root, targetSum) {\\n    if(!root) return 0;\\n    let count = 0;\\n    \\n    function helper(node, sum){\\n        if(!node) return;\\n\\t\\t"]}
{"id": "813", "ref_js": ["var findAnagrams = function (s, p) {\\n  const res = []\\n\\n  let neededChars = {}\\n\\n  for (let char of p) {\\n    if (char in neededChars) {\\n      neededChars[char]++\\n    } else {\\n      neededChars[char] = 1\\n    }\\n  }\\n\\n  let left = 0\\n  let right = 0\\n  let countChars = p.length\\n\\n  while (right < s.length) {\\n    if (neededChars[s[right]] > 0) countChars--\\n    neededChars[s[right]]--\\n    right++\\n\\n    if (countChars === 0) {\\n      res.push(left)\\n    }\\n\\n    if (right - left === p.length) {\\n      if (neededChars[s[left]] >= 0) countChars++\\n      neededChars[s[left]]++\\n      left++\\n    }\\n  }\\n\\n  return res\\n};", "var findAnagrams = function (s, p) {\\n    const ansArr = [];\\n    const hash = {};", "var findAnagrams = function (s, p) {\\n    const ansArr = [];\\n    const hash = {};"]}
{"id": "814", "ref_js": ["var findDuplicates = function(nums) {\\n    const result = []; nums.unshift(0);\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const idx = Math.abs(nums[i]);\\n        if(nums[idx] < 0) result.push(idx);\\n        nums[idx] *= -1;\\n    }\\n    return result;    \\n};", "var findDuplicates = function(nums) {\\n    let start = 0;\\n    const range = Math.pow(10, 5);\\n    const duplicate = [];\\n    while (start < range) {\\n        function set(tempIndex, canSet = false) {\\n            if (tempIndex == undefined) {\\n                return;\\n            }\\n            if (nums[tempIndex] === tempIndex) {\\n                duplicate.push(tempIndex);\\n                return;\\n            }\\n            const save = nums[tempIndex];\\n            if (canSet) {\\n                nums[tempIndex] = tempIndex;\\n            } else {\\n                nums[tempIndex] = undefined;\\n            }\\n            set(save, true);\\n        }\\n        if (start !== nums[start]) {\\n            set(start);\\n        }\\n        start++;\\n    }\\n    return duplicate;\\n};", "var findDuplicates = function(nums) {\\n    let obj = {};"]}
{"id": "815", "ref_js": ["var compress = function(chars) {\\n    let i = 0,j = 0, k = 0;\\n    while(j < chars.length){\\n        while(chars[i] === chars[j]){\\n            j++;\\n        }\\n        chars[k++] = chars[i];\\n        let dif = j - i;\\n        if(dif  > 9){\\n            let u = dif + \\'\\';let us = u.split(\\'\\');let l = 0;\\n            while(l < us.length){\\n                chars[k++]=us[l++];\\n            }\\n        } else if(j - i > 1){\\n            chars[k++] = (j - i)+\\'\\';\\n        }\\n        i = j;\\n    }\\n    return k\\n};", "var compress = function(chars) {\\n    let i = 0;\\n    let j = 0;\\n    while (j < chars.length) {\\n        let count = 0;\\n        let curr = chars[j];\\n        while (j < chars.length && chars[j] === curr) {\\n            j++;\\n            count++;\\n        }\\n        chars[i++] = curr;\\n        if (count > 1) {\\n            for (let digit of count.toString()) {\\n                chars[i++] = digit;\\n            }\\n        }\\n    }\\n    return i;\\n};", "var compress = function(chars) {\\n    let len = 1;\\n    let prev = chars[0];\\n    let idx = 0;\\n    for(let i=1; i<chars.length; i++) {\\n        if(chars[i] === prev) {\\n            len++;\\n        } else {\\n            chars[idx] = prev;\\n            idx++;\\n            if(len > 1) {\\n                let s = \"\"+len;\\n                s = s.split(\"\");\\n                for(let c of s) {\\n                    chars[idx] = c;\\n                    idx++;\\n                }\\n            }\\n            prev = chars[i];\\n            len = 1;\\n        }\\n    }\\n    chars[idx] = prev;\\n    idx++;\\n    if(len > 1) {\\n        let s = \"\"+len;\\n        s = s.split(\"\");\\n        for(let c of s) {\\n            chars[idx] = c;\\n            idx++;\\n        }\\n    }\\n\\n    return idx;\\n};"]}
{"id": "816", "ref_js": ["var addTwoNumbers = function(l1, l2) {\\n    const l1Count = new countList().count(l1);\\n    const l2Count = new countList().count(l2);\\n    function startExploring(list1, list2, grace) {\\n        if (list1 === null && list2 === null) {\\n            return;\\n        }\\n        if (grace) {\\n            grace--;\\n            return startExploring(list1.next, list2, grace);\\n        } else {\\n            list1.val += list2.val;\\n            return startExploring(list1.next, list2.next, grace);\\n        }\\n    }\\n    function recursion(list) {\\n        let reminder = null;\\n        if (list === null) {\\n            return null;\\n        }\\n        let lastDigit = null;\\n        const rem = recursion(list.next);\\n        if (rem !== null) {\\n            list.val += rem;\\n            reminder = null;\\n        }\\n        if (list.val > 9) {\\n            lastDigit = list.val % 10;\\n            list.val = lastDigit;\\n            reminder = 1;\\n        }\\n        return reminder;\\n    }\\n    if (l1Count === l2Count || l1Count > l2Count) {\\n        startExploring(l1, l2, l1Count - l2Count);\\n        const rem = recursion(l1);\\n        if (rem !== null) {\\n            l1.val += rem * 10;\\n        }\\n        if (l1.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l1.val % 10;\\n            l1.val = modulus;\\n            newNode.next = l1;\\n            return newNode;\\n        }\\n        return l1;\\n    } else {\\n        startExploring(l2, l1, l2Count - l1Count);\\n        const rem = recursion(l2);\\n        if (rem !== null) {\\n            l2.val += rem * 10;\\n        }\\n        if (l2.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l2.val % 10;\\n            l2.val = modulus;\\n            newNode.next = l2;\\n            return newNode;\\n        }\\n        return l2;\\n    }\\n};", "var addTwoNumbers = function(l1, l2) {\\n    let stack1 = [];\\n    let stack2 = [];\\n\\n    ", "var addTwoNumbers = function(l1, l2) {\\n    const l1Count = new countList().count(l1);\\n    const l2Count = new countList().count(l2);\\n    function startExploring(list1, list2, grace) {\\n        if (list1 === null && list2 === null) {\\n            return;\\n        }\\n        if (grace) {\\n            grace--;\\n            return startExploring(list1.next, list2, grace);\\n        } else {\\n            list1.val += list2.val;\\n            return startExploring(list1.next, list2.next, grace);\\n        }\\n    }\\n    function recursion(list) {\\n        let reminder = null;\\n        if (list === null) {\\n            return null;\\n        }\\n        let lastDigit = null;\\n        const rem = recursion(list.next);\\n        if (rem !== null) {\\n            list.val += rem;\\n            reminder = null;\\n        }\\n        if (list.val > 9) {\\n            lastDigit = list.val % 10;\\n            list.val = lastDigit;\\n            reminder = 1;\\n        }\\n        return reminder;\\n    }\\n    if (l1Count === l2Count || l1Count > l2Count) {\\n        startExploring(l1, l2, l1Count - l2Count);\\n        const rem = recursion(l1);\\n        if (rem !== null) {\\n            l1.val += rem * 10;\\n        }\\n        if (l1.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l1.val % 10;\\n            l1.val = modulus;\\n            newNode.next = l1;\\n            return newNode;\\n        }\\n        return l1;\\n    } else {\\n        startExploring(l2, l1, l2Count - l1Count);\\n        const rem = recursion(l2);\\n        if (rem !== null) {\\n            l2.val += rem * 10;\\n        }\\n        if (l2.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l2.val % 10;\\n            l2.val = modulus;\\n            newNode.next = l2;\\n            return newNode;\\n        }\\n        return l2;\\n    }\\n};"]}
{"id": "817", "ref_js": ["var numberOfBoomerangs = function(points) {\\n    let count = 0; ", "var numberOfBoomerangs = function(points) {\\n    let count = 0;\\n    \\n    for(let i = 0; i < points.length; i++){\\n        let memory = {};", "var numberOfBoomerangs = function(points) {\\n  let dis=0;\\n  let res=0;\\n  for(let i=0; i<points.length; i++){\\n      let map = new Map();\\n      for(let j=0; j<points.length; j++){\\n          dis = calcDistance(points[i], points[j]);\\n          if(map.has(dis)){\\n              map.set(dis, map.get(dis)+1)\\n          }else{\\n              map.set(dis,1);\\n          }\\n      };"]}
{"id": "819", "ref_js": ["var deleteNode = function(root, key) {\\n\\n    const findMin = (node) => {\\n        while(node.left){\\n            node = node.left\\n        }\\n        return node\\n    }\\n    \\n    const remove = (node, val) => {\\n        if(!node){\\n            return null\\n        }\\n\\n        if(node.val === val){\\n            if(!node.left & !node.right){\\n                return null \\n            }\\n\\n            else if(!node.left){\\n                return node.right\\n            } \\n\\n            else if(!node.right){\\n                return node.left\\n            }\\n\\n            else{\\n                const minNode = findMin(node.right)\\n                node.val = minNode.val\\n                node.right = remove(node.right, minNode.val)\\n            }\\n\\n        } else if(val > node.val){\\n            node.right = remove(node.right, val)\\n        } else if(val < node.val){\\n            node.left = remove(node.left, val)\\n        } \\n\\n        return node\\n    }\\n\\n    return remove(root, key)\\n\\n};", "var deleteNode = function(root, key) {\\n    ", "var deleteNode = function(root, key) {\\n    \\n    function callDFS(node) {\\n        if(!node) return null;\\n        if(node.val === key) {\\n            if(!node.left) return node.right;\\n            if(!node.right) return node.left;\\n            let curr = node.right;\\n            while(curr.left) curr = curr.left;\\n            curr.left = node.left;\\n            return node.right;\\n        }\\n        if(key > node.val) node.right = callDFS(node.right);\\n        else node.left = callDFS(node.left);\\n        return node;\\n    }\\n    return callDFS(root)\\n};"]}
{"id": "820", "ref_js": ["var frequencySort = function(s) {\\n    const map = new Map();\\n    for (let c of s) map.set(c, (map.get(c) || 0) + 1);\\n    return s.split(\\'\\').sort((a, b) => map.get(b) - map.get(a) === 0 ? b.localeCompare(a) :  map.get(b) - map.get(a)).join(\\'\\')\\n};", "var frequencySort = function(s) {\\n    \\n    const charMap = s.split(\\'\\').reduce((acc, cur) => {acc[cur] = (acc[cur] || 0) + 1; return acc} , {})\\n    \\n    const sortedArr = Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]);\\n    \\n    return sortedArr.reduce((acc, cur) => acc + cur.repeat(charMap[cur]) ,\\'\\')\\n};", "var frequencySort = function(s) {\\n    const map = new Map();\\n    for (let c of s) map.set(c, (map.get(c) || 0) + 1);\\n    return s.split(\\'\\').sort((a, b) => map.get(b) - map.get(a) === 0 ? b.localeCompare(a) :  map.get(b) - map.get(a)).join(\\'\\')\\n};"]}
{"id": "821", "ref_js": ["var findMinArrowShots = function(points) {\\n    const p = points.sort((a, b) => a[0] - b[0])\\n    let stack = []\\n\\n    for (let range of p) {\\n        const slen = stack.length\\n        if (slen > 0 && stack[slen-1][1] >= range[0]) {\\n            const topStack = stack.pop()\\n            const lastStartPoint = topStack[0]\\n            const lastEndPoint = topStack[1]\\n            stack.push( [Math.max(range[0], lastStartPoint), Math.min(range[1], lastEndPoint)] )\\n\\n        } else {\\n            stack.push([range[0], range[1]])\\n        }\\n\\n    }\\n    return stack.length\\n};", "var findMinArrowShots = function(points) {\\n    if(points.length==0) return 0;\\n    points.sort(mysort);\\n    let rightEnd=points[0][1],ans=1;\\n    for(let i=1;i<points.length;i++)\\n    {\\n        if(points[i][0]>rightEnd)\\n        {\\n            rightEnd=points[i][1];\\n            ans++;\\n        }\\n        else\\n        {\\n            rightEnd=Math.min(rightEnd,points[i][1]);\\n        }\\n    }\\n    return ans;\\n};", "var findMinArrowShots = function(points) {\\n    "]}
{"id": "822", "ref_js": ["var minMoves = function(nums) {\\n    nums.sort((a, b)=>a-b);\\n    \\n    let num_moves = 0;\\n    for(let i = nums.length - 1; i >= 0; --i){\\n        num_moves += nums[i] - nums[0];\\n    }\\n    \\n    return num_moves;\\n};", "var minMoves = function(nums) {\\n    if(nums == null || nums.length<=1) return 0;\\n    let min = nums[0]\\n    let sum = 0\\n    for( i = 0;i< nums.length;i++){\\n        sum += nums[i]\\n        min = Math.min(min,nums[i])\\n    }\\n    return sum-min*nums.length\\n};", "var minMoves = function(nums) {\\n    if(nums == null || nums.length<=1) return 0;\\n    let min = nums[0]\\n    let sum = 0\\n    for( i = 0;i< nums.length;i++){\\n        sum += nums[i]\\n        min = Math.min(min,nums[i])\\n    }\\n    return sum-min*nums.length\\n};"]}
{"id": "823", "ref_js": ["var fourSumCount = function(nums1, nums2, nums3, nums4) {\\n  let map = new Map();\\n   let cnt = 0;\\n    let n = nums1.length;\\n    \\n    for(let num of nums1) {\\n        for(let num2 of nums2){\\n           map.set(num + num2, map.get(num + num2) ? map.get(num + num2) + 1 : 1)\\n    }}\\n    \\n     for(let num of nums3) {\\n        for(let num2 of nums4){\\n            if(map.has(-(num + num2))) { \\n                cnt += map.get(-(num + num2))\\n            }\\n     }}\\n    \\n    return cnt;\\n    \\n   \\n};", "var fourSumCount = function(nums1, nums2, nums3, nums4) {\\n    let m=new Map(),count=0;\\n    \\n    nums1.forEach(n1=>{\\n        nums2.forEach(n2=>{\\n            let sum=n1+n2;\\n            m.set(sum,m.get(sum)+1 || 1);\\n        })\\n    })\\n   \\n    nums3.forEach(n3=>{\\n        nums4.forEach(n4=>{\\n            let sum=-(n3+n4);\\n            count+=m.get(sum)?m.get(sum):0;\\n        })\\n    })\\n    return count;\\n};", "var fourSumCount = function(nums1, nums2, nums3, nums4) {\\n  let map = new Map();\\n   let cnt = 0;\\n    let n = nums1.length;\\n    \\n    for(let num of nums1) {\\n        for(let num2 of nums2){\\n           map.set(num + num2, map.get(num + num2) ? map.get(num + num2) + 1 : 1)\\n    }}\\n    \\n     for(let num of nums3) {\\n        for(let num2 of nums4){\\n            if(map.has(-(num + num2))) { \\n                cnt += map.get(-(num + num2))\\n            }\\n     }}\\n    \\n    return cnt;\\n    \\n   \\n};"]}
{"id": "824", "ref_js": ["var find132pattern = function(nums) {\\n    let stack = [];\\n    let third = Number.MIN_SAFE_INTEGER;\\n\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] < third) return true;\\n        while (stack.length && stack[stack.length - 1] < nums[i]) {\\n            third = stack.pop();\\n        }\\n        stack.push(nums[i]);\\n    }\\n    return false;\\n};", "var find132pattern = function (nums) {\\n  ", "var find132pattern = function (nums) {\\n  "]}
{"id": "825", "ref_js": ["var circularArrayLoop = function(nums) {\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        \\n        let moveForward = nums[i] >= 0; ", "var circularArrayLoop = function(nums) {\\n    const n = nums.length;\\n\\n    ", "var circularArrayLoop = function(nums) {\\n    const n = nums.length;\\n\\n    "]}
{"id": "826", "ref_js": ["var minMoves2 = function(nums) {\\n    nums.sort((a,b) => a - b)\\n    let ans = 0, median = nums[~~(nums.length / 2)]\\n    for (let i = 0; i < nums.length; i++) ans += Math.abs(median - nums[i])\\n    return ans\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **52ms / 15.2MB** (beats 99% / 100%).\\n```python\\nclass Solution:\\n    def minMoves2(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans, median = 0, nums[len(nums) ", "var minMoves2 = function(nums) {\\n    nums.sort((a, b) => a - b);    \\n    \\n    let median;\\n    \\n    if (nums.length % 2 === 0) {\\n        let p = nums.length / 2;\\n        median = (nums[p] + nums[p - 1]) / 2;\\n    } else {\\n        let p = (nums.length + 1) / 2;\\n        median = nums[p - 1];\\n    }\\n    \\n    \\n    return nums.reduce((diffSum, num) => diffSum + Math.abs(median - num), 0);\\n};", "var minMoves2 = function(nums) {\\n    nums.sort((a,b) => a - b)\\n    let ans = 0, median = nums[~~(nums.length / 2)]\\n    for (let i = 0; i < nums.length; i++) ans += Math.abs(median - nums[i])\\n    return ans\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **52ms / 15.2MB** (beats 99% / 100%).\\n```python\\nclass Solution:\\n    def minMoves2(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans, median = 0, nums[len(nums) "]}
{"id": "827", "ref_js": ["var canIWin = function (maxChoosableInteger, desiredTotal) {\\n  if (maxChoosableInteger >= desiredTotal) return true;\\n  if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal) return false;\\n  const memo = new Map;\\n  const canWin = (state, total) => {\\n    if (total >= desiredTotal) return false;\\n    if (memo.has(state)) return memo.get(state);\\n    for (let i = 1; i <= maxChoosableInteger; i++) {\\n      const mask = 1 << i;\\n      if ((state & mask) === 0) {\\n        const next = state | mask;\\n        if (!canWin(next, total + i)) {\\n          memo.set(state, true);\\n          return true;\\n        }\\n      }\\n    }\\n    memo.set(state, false);\\n    return false;\\n\\n  }\\n  return canWin(0, 0)\\n};", "var canIWin = function (maxChoosableInteger, desiredTotal) {\\n  if (maxChoosableInteger >= desiredTotal) return true;\\n  if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal) return false;\\n  const memo = new Map;\\n  const canWin = (state, total) => {\\n    if (total >= desiredTotal) return false;\\n    if (memo.has(state)) return memo.get(state);\\n    for (let i = 1; i <= maxChoosableInteger; i++) {\\n      const mask = 1 << i;\\n      if ((state & mask) === 0) {\\n        const next = state | mask;\\n        if (!canWin(next, total + i)) {\\n          memo.set(state, true);\\n          return true;\\n        }\\n      }\\n    }\\n    memo.set(state, false);\\n    return false;\\n\\n  }\\n  return canWin(0, 0)\\n};", "var canIWin = function (maxChoosableInteger, desiredTotal) {\\n  if (maxChoosableInteger >= desiredTotal) return true;\\n  if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal) return false;\\n  const memo = new Map;\\n  const canWin = (state, total) => {\\n    if (total >= desiredTotal) return false;\\n    if (memo.has(state)) return memo.get(state);\\n    for (let i = 1; i <= maxChoosableInteger; i++) {\\n      const mask = 1 << i;\\n      if ((state & mask) === 0) {\\n        const next = state | mask;\\n        if (!canWin(next, total + i)) {\\n          memo.set(state, true);\\n          return true;\\n        }\\n      }\\n    }\\n    memo.set(state, false);\\n    return false;\\n\\n  }\\n  return canWin(0, 0)\\n};"]}
{"id": "828", "ref_js": ["var findSubstringInWraproundString = function(s) {\\n      let dp = Array(26).fill(0);\\n      let origin = \\'a\\'.charCodeAt(0);\\n      let count = 0;\\n\\n      for(let i = 0; i < s.length; i++){\\n          let code = s.charCodeAt(i);\\n          let prevCode = s.charCodeAt(i - 1);\\n          let pos = code - origin;\\n\\ncount = code - prevCode === 1 || prevCode - code === 25 ? count + 1 : 1;\\n          dp[pos] = Math.max(count, dp[pos]);\\n      }\\n      return dp.reduce((total, count) => total + count);\\n};", "var findSubstringInWraproundString = function(s) {\\n    const dp = new Array(26).fill(0);  ", "var findSubstringInWraproundString = function(s) {\\n    const dp = Array(26).fill(0);\\n\\tconst origin = \\'a\\'.charCodeAt(0);\\n\\tlet count = 0;\\n\\n\\tfor (let index = 0; index < s.length; index++) {\\n\\t\\tconst code = s.charCodeAt(index);\\n\\t\\tconst preCode = s.charCodeAt(index - 1);\\n\\t\\tconst pos = code - origin;\\n\\n\\t\\tcount = code - preCode === 1 || preCode - code === 25\\n\\t\\t\\t? count + 1\\n\\t\\t\\t: 1;\\n\\n\\t\\tdp[pos] = Math.max(count, dp[pos]);\\n\\t}\\n\\n\\treturn dp.reduce((total, count) => total + count);\\n};"]}
{"id": "829", "ref_js": ["var validIPAddress = function(queryIP) {\\n\\t\\tconst iPv4 = () => {\\n\\t\\t\\tconst address = queryIP.split(\\'.\\');\\n\\t\\t\\tif (address.length !== 4) return null;\\n\\n\\t\\t\\tfor (const str of address) {\\n\\t\\t\\t\\tconst ip = parseInt(str);\\n\\t\\t\\t\\tif (ip < 0 || ip > 255) return null;\\n\\t\\t\\t\\tif (ip.toString() !== str) return null;\\n\\t\\t\\t}\\n\\t\\t\\treturn \\'IPv4\\';\\n\\t\\t};", "var validIPAddress = function(IP) {\\n    const ipv4 = /^((\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2([0-4]\\\\d|5[0-5]))\\\\.){4}$/;\\n    const ipv6 = /^([\\\\da-f]{1,4}:){8}$/i;\\n    return ipv4.test(IP + '.') ? 'IPv4' : ipv6.test(IP + ':') ? 'IPv6' : 'Neither';\\n};", "var validIPAddress = function(queryIP) {\\n\\t\\tconst iPv4 = () => {\\n\\t\\t\\tconst address = queryIP.split(\\'.\\');\\n\\t\\t\\tif (address.length !== 4) return null;\\n\\n\\t\\t\\tfor (const str of address) {\\n\\t\\t\\t\\tconst ip = parseInt(str);\\n\\t\\t\\t\\tif (ip < 0 || ip > 255) return null;\\n\\t\\t\\t\\tif (ip.toString() !== str) return null;\\n\\t\\t\\t}\\n\\t\\t\\treturn \\'IPv4\\';\\n\\t\\t};"]}
{"id": "830", "ref_js": ["var rand7 = function() {}\\n * @return {number} a random integer in the range 1 to 7\\n */\\nvar rand10 = function() {\\n    while (true) {\\n        const num1 = rand7() - 1;\\n        const num2 = rand7();\\n\\n        const combinedNum = num1 * 7 + num2;\\n\\n        if (combinedNum <= 40) {\\n            return (combinedNum % 10) + 1;\\n        }\\n    }\\n};", "var rand10 = function() {\\n   let digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\\n   let i = Math.trunc(Math.random() * digits.length);\\n   return digits[i];\\n};", "var rand7 = function() {}\\n * @return {number} a random integer in the range 1 to 7\\n */\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let index = Math.trunc(Math.random() * nums.length);\\n    return nums[index];\\n};"]}
{"id": "831", "ref_js": ["var makesquare = function(matchsticks) {\\n    const perimeter = matchsticks.reduce((a, b) => a + b, 0);\\n    if(perimeter % 4 != 0 || matchsticks.length < 4) return false;\\n    \\n    const sideLen = perimeter / 4;\\n    ", "var makesquare = function(M) {\\n    let n = M.length, side = M.reduce((a,c) => a + c) / 4\\n    M.sort((a,b) => b - a)\\n    if (side !== ~~side || M[0] > side)\\n        return false\\n    const btrack = (i, space, done) => {\\n        if (done === 3)\\n            return true\\n        for (; i < n; i++) {\\n            let num = M[i], res\\n            if (num > space)\\n                continue\\n            M[i] = side + 1\\n            if (num === space)\\n                res = btrack(1, side, done+1)\\n            else\\n                res = btrack(i+1, space-num, done)\\n            if (res)\\n                return true\\n            M[i] = num\\n            while (M[i+1] === num)\\n                i++\\n        }\\n        return false\\n    }\\n    return btrack(0, side, 0)\\n};", "var makesquare = function(matchsticks) {\\n\\tif (!matchsticks || matchsticks.length < 4) \\n\\t\\treturn false;\\n\\t\\t\\n\\tlet sum = 0;\\n\\tfor (const match of matchsticks) \\n\\t\\tsum += match;\\n\\t\\t\\n\\tif (sum % 4 != 0) \\n\\t\\treturn false;\\n\\t\\n\\tmatchsticks.sort((a, b) => b - a);\\n    \\n    const sums = Array(4).fill(0);\\n\\t\\n\\tfunction dfs(index, target) {\\n\\t\\tif (index > matchsticks.length - 1) \\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (let i = 0; i < 4; i++) {\\n\\t\\t\\tif (sums[i] + matchsticks[index] > target )\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] += matchsticks[index];\\n\\n\\t\\t\\tif (dfs(index + 1, target)) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] -= matchsticks[index];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\treturn dfs(0, sum / 4);\\n};"]}
{"id": "832", "ref_js": ["var findMaxForm = function(S, M, N) {\\n    let dp = Array.from({length:M+1},() => new Uint8Array(N+1))\\n    for (let i = 0; i < S.length; i++) {\\n        let str = S[i], zeros = 0, ones = 0\\n        for (let j = 0; j < str.length; j++)\\n            str.charAt(j) === \"0\" ? zeros++ : ones++\\n        for (let j = M; j >= zeros; j--)\\n            for (let k = N; k >= ones; k--)\\n                dp[j][k] = Math.max(dp[j][k], dp[j-zeros][k-ones] + 1)\\n    }\\n    return dp[M][N]\\n};", "var findMaxForm = function(strs, m, n) {\\n    ", "var findMaxForm = function(strs, m, n) {\\n    let dp = Array(m + 1).fill(\\'\\').map(() => Array(n + 1).fill(0));\\n\\n    strs.forEach(str => {\\n        let ones = zeros = 0;\\n\\n    for(let char of str){\\n        char === \\'0\\' ? zeros += 1 : ones += 1;\\n        }\\n    for(let a = m; a >= zeros; a--){\\n        for(let b = n; b >= ones; b--){\\n        dp[a][b] = Math.max(dp[a][b], dp[a - zeros][b - ones] + 1);\\n            }\\n        }\\n    });\\n    return dp[m][n];\\n};"]}
{"id": "833", "ref_js": ["var findRadius = function(houses, heaters) {\\n  heaters.sort((a, b) => a - b);\\n  return Math.max(...houses.map(h => findMinDistance(h, heaters)));\\n};", "var findRadius = function(houses, heaters) {\\n    houses.sort((a, b) => a - b);\\n    heaters.sort((a, b) => a - b);\\n    let i = 0, ans = 0;\\n    for(let house of houses){\\n    while(i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= house * 2){\\n            i++;\\n        }\\n        ans = Math.max(ans, Math.abs(heaters[i] - house));\\n    }\\n    return ans;\\n};", "var findRadius = function(houses, heaters) {\\n    houses.sort((a, b) => a - b);\\n    heaters.sort((a, b) => a - b);\\n    let i = 0, ans = 0;\\n    for(let house of houses){\\n    while(i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= house * 2){\\n            i++;\\n        }\\n        ans = Math.max(ans, Math.abs(heaters[i] - house));\\n    }\\n    return ans;\\n};"]}
{"id": "834", "ref_js": ["var totalHammingDistance = function(nums) {\\n    const cache={};", "var totalHammingDistance = function(nums) {\\n    let n = nums.length, ans = 0;\\n    for(let bit = 0; bit < 32; bit++) {\\n        let zeros = 0, ones = 0;\\n        for(let i = 0; i < n; i++) {\\n            ((nums[i] >> bit) & 1) ? ones++ : zeros++;\\n        }\\n        ans += zeros * ones;\\n    }\\n    return ans;\\n};", "var totalHammingDistance = function(nums) {\\n    let count = 0;\\n    for(let bits = 0; bits < 32; bits++){\\n        let count2 = 0;\\n        for(let j = 0; j < nums.length; j++){\\n            count2 += (nums[j] >> bits) & 1;\\n        }\\n        count += count2 * (nums.length - count2);\\n    }\\n    return count;\\n};"]}
{"id": "836", "ref_js": ["var magicalString = function(n) {\\n    const arr = [\\'1\\', \\'2\\', \\'2\\'];\\n    let i = 0;\\n    let res = 1;\\n    while (arr.length < n) {\\n        let val = i % 2 === 0 ? \\'1\\' : \\'2\\';\\n        let isOne = val === \\'1\\';\\n        if (arr[i + 2] === \\'1\\') {\\n            arr.push(val);\\n            if (isOne) res++;\\n        } else {\\n            arr.push(val);\\n            if (isOne) res++;\\n            if (arr.length >= n) break;\\n            arr.push(val);\\n            if (isOne) res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};", "var magicalString = function(n) {\\n   let ones = 1, str = \"122\";\\n   for(let i = 2; i < n; i++){\\n       str += (3 - str.at(-1) + \"\").repeat(str[i]);\\n       ones += str[i] == 1;\\n   }    \\n   return ones;\\n};", "var magicalString = function(n) {\\n    let ones = 1, s = [\"1\", \"2\", \"2\"];\\n\\n    for (let i = 2; i < n; i++) {\\n        const digit = 3 - s.at(-1) + \\'\\';\\n        s.push(digit), s[i] > 1 && s.push(digit), ones += s[i] == 1;\\n    }\\n\\n    return ones;\\n};"]}
{"id": "837", "ref_js": ["var PredictTheWinner = function(nums) {\\n    \\n    ", "var PredictTheWinner = function(nums) {\\n    const n = nums.length;\\n    const dp = Array.from(Array(n), () => Array(n).fill(0));\\n    \\n    for (let i = n-1; i >= 0; --i) {\\n        for (let j = i; j < n; ++j) {\\n            if (i == j) {\\n                dp[i][j] = nums[i];\\n            } else {\\n                dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[0][n-1] >= 0;\\n};", "var PredictTheWinner = function(nums) {\\n    \\n    "]}
{"id": "838", "ref_js": ["var findSubsequences = function (nums) {\\n    let result = new Set();\\n    let sequence = [];\\n    function backtrack(index) {\\n        if (index === nums.length) {\\n            if (sequence.length >= 2) {\\n                result.add(JSON.stringify(sequence));\\n            }\\n            return;\\n        }\\n\\n        if (!sequence.length ||\\n            sequence[sequence.length - 1]\\n            <= nums[index]) {\\n            sequence.push(nums[index]);\\n            backtrack(index + 1);\\n            sequence.pop();\\n        }\\n        backtrack(index + 1);\\n    }\\n    backtrack(0);\\n    return Array.from(result).map(JSON.parse);\\n};", "var findSubsequences = function(nums) {\\n    let res = []\\n    let map = {}\\n    let iterate = (index,temp) =>{\\n        if(map[temp]) return;\\n        if(temp.length>=2){\\n            res.push(temp)\\n        }\\n        for(let i =index;i<nums.length;i++){\\n            if(temp[temp.length-1]>nums[i]) continue;\\n            map[temp] = true;\\n            iterate(i+1,[...temp,nums[i]])\\n        }\\n    }\\n    iterate(0,[])\\n    return res;\\n};", "var findSubsequences = function(nums) {\\n    let res = []\\n    let map = {}\\n    let iterate = (index,temp) =>{\\n        if(map[temp]) return;\\n        if(temp.length>=2){\\n            res.push(temp)\\n        }\\n        for(let i =index;i<nums.length;i++){\\n            if(temp[temp.length-1]>nums[i]) continue;\\n            map[temp] = true;\\n            iterate(i+1,[...temp,nums[i]])\\n        }\\n    }\\n    iterate(0,[])\\n    return res;\\n};"]}
{"id": "839", "ref_js": ["var findTargetSumWays = function(nums, S) {\\n    const memo = new Map();\\n    const n = nums.length;\\n    \\n    return countWaysToSum(n - 1, S);\\n    \\n    function countWaysToSum(index, rem) {\\n        const key = `${index}#${rem}`;\\n        \\n        ", "var findTargetSumWays = function(nums, target) {\\n    let answer = 0;\\n    const stack = [[0, 0]];  \\n    while(stack.length) {\\n      const [pos, sum] = stack.pop();\\n      if(pos !== nums.length) {\\n        stack.push([pos + 1, sum + nums[pos]]);\\n        stack.push([pos + 1, sum - nums[pos]]);      \\n        continue;\\n      } else if (sum === target) {\\n        answer++;\\n      }\\n    }\\n    return answer;    \\n  };", "var findTargetSumWays = function(nums, S) {\\n    const memo = new Map();\\n    const n = nums.length;\\n    \\n    return countWaysToSum(n - 1, S);\\n    \\n    function countWaysToSum(index, rem) {\\n        const key = `${index}#${rem}`;\\n        \\n        "]}
{"id": "841", "ref_js": ["var findDiagonalOrder = function(mat) {\\n    let rows = mat.length;\\n    let cols = mat[0].length;\\n    let result = new Array(rows + cols - 1).fill(null).map(() => []);\\n\\n    for(let row = 0; row < rows; row++) {\\n        for(let col = 0; col < cols; col++) {\\n            if((row + col) % 2 === 0) result[row + col].unshift(mat[row][col]);\\n            else result[row + col].push(mat[row][col]);   \\n        }\\n    }\\n    return result.flat();\\n};", "var findDiagonalOrder = function(mat) {\\n    ", "var findDiagonalOrder = function (mat) {\\n  const rowLen = mat.length;\\n  const colLen = mat[0].length;\\n  const total = rowLen * colLen;\\n  const result = [];\\n  let k = 0;\\n  let row = 0;\\n  let col = 0;\\n  let direction = \"up\";\\n\\n  while (k < total) {\\n    result.push(mat[row][col]);\\n\\n    if (direction === \"up\") {\\n      if (row === 0 && col < colLen - 1) {\\n        col++;\\n        direction = \"down\";\\n      } else if (col === colLen - 1) {\\n        row++;\\n        direction = \"down\";\\n      } else {\\n        row--;\\n        col++;\\n      }\\n    } else {\\n      if (col === 0 && row < rowLen - 1) {\\n        row++;\\n        direction = \"up\";\\n      } else if (row === rowLen - 1) {\\n        col++;\\n        direction = \"up\";\\n      } else {\\n        row++;\\n        col--;\\n      }\\n    }\\n    k++;\\n  }\\n  return result;\\n};"]}
{"id": "842", "ref_js": ["var singleNumber = function(nums) {\\n    let hash = new Map();\\n    for(let i of nums) {\\n        if(hash.has(i)) {\\n            hash.delete(i);\\n        }\\n        else {\\n            hash.set(i, i);\\n        }\\n    }\\n    let res;\\n    hash.forEach (function(value, key) { res = key});\\n    return res;\\n};", "var singleNumber = function(nums) {\\n    ", "var singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); "]}
{"id": "843", "ref_js": ["var findFrequentTreeSum = function(root) {\\n    const sums={};", "var findFrequentTreeSum = function(root) {\\n   map = {};", "var findFrequentTreeSum = function(root) {\\n    const map = new Map();\\n    function dfs(root){\\n        if(root === null)\\n            return 0\\n        const rootSum = root.val + dfs(root.left) + dfs(root.right)\\n        map.set(rootSum, (map.get(rootSum)||0) + 1)\\n        return rootSum\\n    }\\n    dfs(root)\\n    let mostFreqSums = [], maxFreq = 0;\\n    for(const [key, val] of map){\\n        if(val > maxFreq){\\n            maxFreq = val\\n            mostFreqSums = [key]\\n        }else if(val === maxFreq){\\n            mostFreqSums.push(key)\\n        }\\n    }\\n    return mostFreqSums\\n};"]}
{"id": "844", "ref_js": ["var findBottomLeftValue = function (root) {\\n  const q = [root];\\n  let res = [];\\n  while (q.length) {\\n    const len = q.length;\\n    ", "var findBottomLeftValue = function(root) {\\n    let q = [root];\\n    let res = [];\\n\\n    const solve = (node, idx) => {\\n        if(!node) return;\\n\\n        solve(node.right, idx+1);\\n        solve(node.left, idx+1);\\n\\n        res[idx] = node.val;\\n    }\\n\\n    solve(root, 0);\\n    return res[res.length - 1];\\n};", "var findBottomLeftValue = function(root) {\\n    let q = [root];\\n    let res = [];\\n\\n    const solve = (node, idx) => {\\n        if(!node) return;\\n\\n        solve(node.right, idx+1);\\n        solve(node.left, idx+1);\\n\\n        res[idx] = node.val;\\n    }\\n\\n    solve(root, 0);\\n    return res[res.length - 1];\\n};"]}
{"id": "845", "ref_js": ["var largestValues = function(root) {\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    \\n    let current = [root];\\n    \\n    while (current.length > 0) {\\n        let levelMax = Number.MIN_SAFE_INTEGER;\\n        let nextLevel = [];\\n        \\n        for (const node of current) {\\n            levelMax = Math.max(levelMax, node.val);\\n            \\n            if (node.left) {\\n                nextLevel.push(node.left);\\n            }\\n            \\n            if (node.right) {\\n                nextLevel.push(node.right);\\n            }\\n        }\\n        \\n        result.push(levelMax);\\n        current = nextLevel;\\n    }\\n    \\n    return result;\\n};", "var largestValues = function(root) {\\n    dfs(root, 0);\\n    return ans;\\n};", "var largestValues = function(root) {\\n    dfs(root, 0);\\n    return ans;\\n};"]}
{"id": "846", "ref_js": ["var longestPalindromeSubseq = function(s) {\\n    ", "var longestPalindromeSubseq = function (s) {\\n  ", "var longestPalindromeSubseq = function(s) {\\n    "]}
{"id": "847", "ref_js": ["var change = function(amount, coins) {\\n    let dp = new Array(amount + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (let coin of coins) {\\n        for (let j = coin; j <= amount; j++) {\\n            dp[j] += dp[j - coin];\\n        }\\n    }\\n    \\n    return dp[amount];\\n};", "var change = function(amount, coins) {\\n    const dp = new Array(amount + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (const c of coins) {\\n        for (let a = c; a <= amount; a++) {\\n            dp[a] += dp[a - c];\\n        }\\n    }\\n    \\n    return dp[amount];    \\n};", "var change = function(amount, coins) {\\n    const dp = new Array(amount + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (const c of coins) {\\n        for (let a = c; a <= amount; a++) {\\n            dp[a] += dp[a - c];\\n        }\\n    }\\n    \\n    return dp[amount];    \\n};"]}
{"id": "849", "ref_js": ["var findLUSlength = function(strs) {\\n    let noUse = {};", "var findLUSlength = function(strs) {\\n    function isSubsequence(s1, s2) {\\n        let i = 0;\\n        for (let j = 0; i < s1.length && j < s2.length; j++) {\\n            if (s1.charAt(i) === s2.charAt(j)) {\\n                i++;\\n            }\\n        }\\n        return i === s1.length;\\n    }\\n\\n    strs.sort((a, b) => b.length - a.length);\\n\\n    for (let i = 0; i < strs.length; i++) {\\n        let isLUS = true;\\n        for (let j = 0; j < strs.length; j++) {\\n            if (i !== j && isSubsequence(strs[i], strs[j])) {\\n                isLUS = false;\\n                break;\\n            }\\n        }\\n        if (isLUS) {\\n            return strs[i].length;\\n        }\\n    }\\n\\n    return -1;\\n};", "var findLUSlength = function(strs) {\\n    const ignore = {} \\n    for(let a of strs){\\n        ignore[a] = ignore[a] ? -1 : 50;\\n    }\\n    function getSubSeq(a, b){\\n        let j = 0\\n        let match = 0\\n        for(let ai of a)\\n            while(j<b.length){\\n                if(ai===b[j++]){\\n                    match++\\n                    break\\n                }\\n        }\\n        return match === a.length ? -1 : a.length\\n    }\\n    for(let a of strs) {\\n        for(let b of strs){\\n            if(a===b) continue;\\n            const len = getSubSeq(a,b)\\n            if(len<0) ignore[a] = -1; else ignore[a] = Math.min(ignore[a], len);\\n        }\\n    }    \\n    return Math.max(...Object.values(ignore))\\n};"]}
{"id": "850", "ref_js": ["var checkSubarraySum = function (nums, k) {\\n    const set = new Set();\\n\\tlet sum = 0\\n\\tlet surplus = 0;\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tsum += nums[i];\\n        sum %= k;\\n\\t\\tif(set.has(sum)) return true;\\n\\t\\tset.add(surplus);\\n\\t\\tsurplus = sum;\\n\\t}\\n\\treturn false;\\n};", "var checkSubarraySum = function(nums, k) {\\n\\n    let sum = 0\\n    const hash = {}\\n    hash[0] = -1\\n    \\n    for (let i = 0; i<nums.length; i++) {\\n        sum += nums[i]\\n        \\n        if (k!=0) sum %= k\\n        \\n        if ( hash[sum] !== undefined   ) {\\n            if(i-hash[sum]>1) return true\\n        } else {\\n            hash[sum] = i\\n        }\\n    }\\n    \\n    return false\\n};", "var checkSubarraySum = function (nums, k) {\\n\\n\\tlet sum = 0\\n\\t\\n\\tlet prefix = 0;\\n\\t\\n\\tconst hash = new Set();\\n\\t\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tsum += nums[i]\\n\\n\\t\\tif (k != 0) sum %= k\\n\\n\\t\\tif(hash.has(sum)) return true\\n\\n\\t\\thash.add(prefix);\\n\\t\\tprefix = sum;\\n\\t}\\n\\treturn false\\n};"]}
{"id": "851", "ref_js": ["var findLongestWord = function(S, D) {\\n    let ans = \"\"\\n    for (let word of D) {\\n        let a = word.length, b = ans.length\\n        if (a < b || (a === b && word > ans)) continue\\n        let pos = -1\\n        for (let char of word) {\\n            pos = S.indexOf(char, pos + 1)\\n            if (pos === -1) break\\n        }\\n        if (pos !== -1) ans = word\\n    }\\n    return ans\\n};", "var findLongestWord = function(s, dict) {\\n    dict.sort((a, b) => a.localeCompare(b));\\n    let max = 0;\\n    let longest = \"\";\\n    for(let d of dict){\\n        let count = 0, word = \"\", prevIndex = -1;\\n        for(let w of d){\\n            count = s.indexOf(w, prevIndex + 1);\\n            if(count === -1) break;\\n            word += w;\\n            prevIndex = count;\\n        }\\n        if(word === d && word.length > max){\\n            max = word.length;\\n            longest = word;\\n        }\\n    }\\n    return longest;\\n};", "var findLongestWord = function(s, dictionary) {\\n    let returnWord = \\'\\'; "]}
{"id": "852", "ref_js": ["var findMaxLength = function(nums) {\\n    let hash = {0:-1};", "var findMaxLength = function(nums) {\\n    let hash = {0:-1};", "var findMaxLength = function(nums) {\\n    let hash = {0:-1};"]}
{"id": "853", "ref_js": ["var countArrangement = function(n) {\\n    let count = 0;\\n    let visited = Array(n + 1).fill(false);\\n\\n    function permute(index){\\n        if(index > n) count++;\\n\\n        for(let i = 1; i <=n; i++){\\n            if(visited[i]) continue;\\n            if(i % index && index % i) continue;\\n            visited[i] = true;\\n            permute(index + 1);\\n            visited[i] = false;\\n        }\\n    }\\n    permute(1);\\n    return count;\\n};", "var countArrangement = function(n) {\\n    let count = 0;\\n    let visited = Array(n + 1).fill(false);\\n\\n    function permute(index){\\n        if(index > n) count++;\\n\\n        for(let i = 1; i <=n; i++){\\n            if(visited[i]) continue;\\n            if(i % index && index % i) continue;\\n            visited[i] = true;\\n            permute(index + 1);\\n            visited[i] = false;\\n        }\\n    }\\n    permute(1);\\n    return count;\\n};", "var countArrangement = function(n) {\\n    let count = 0;\\n    let visited = Array(n + 1).fill(false);\\n\\n    function permute(index){\\n        if(index > n) count++;\\n\\n        for(let i = 1; i <=n; i++){\\n            if(visited[i]) continue;\\n            if(i % index && index % i) continue;\\n            visited[i] = true;\\n            permute(index + 1);\\n            visited[i] = false;\\n        }\\n    }\\n    permute(1);\\n    return count;\\n};"]}
{"id": "855", "ref_js": ["var adjacentMines = function(board, x, y){\\n    let numMines = 0;\\n    for(let i = x-1; i <= x+1; ++i){ ", "var updateBoard = function(board, click) {\\n    const m = board.length;\\n    const n = board[0].length;\\n    const adjMines = new Array(m).fill(0)\\n    .map(() => new Array(n).fill(0));\\n\\n    function countAdjMines(i, j){\\n        if(i < 0 || j < 0 || i >= m || j >= n){\\n            return;\\n        }\\n\\n        adjMines[i][j]++;\\n    }\\n\\n    function DFS(i, j){\\n        if(i < 0 || j < 0 || i >= m || j >= n){\\n            return;\\n        }\\n\\n        if(board[i][j] !== \\'E\\'){\\n            return;\\n        }\\n\\n        if(adjMines[i][j] > 0){\\n            board[i][j] = \\'\\' + adjMines[i][j];\\n            return;\\n        }\\n\\n        board[i][j] = \\'B\\';\\n\\n        DFS(i, j-1);\\n        DFS(i, j+1);\\n        DFS(i+1, j);\\n        DFS(i-1, j);\\n        DFS(i+1, j+1);\\n        DFS(i-1, j+1);\\n        DFS(i+1, j-1);\\n        DFS(i-1, j-1);\\n    }\\n\\n    for(let i=0; i<m; i++){\\n        for(let j=0; j<n; j++){\\n            if(board[i][j] === \\'M\\'){\\n                countAdjMines(i, j-1);\\n                countAdjMines(i, j+1);\\n                countAdjMines(i+1, j);\\n                countAdjMines(i-1, j);\\n                countAdjMines(i+1, j+1);\\n                countAdjMines(i-1, j+1);\\n                countAdjMines(i+1, j-1);\\n                countAdjMines(i-1, j-1);\\n            }\\n        }\\n    }\\n\\n    let [r, c] = click;\\n\\n    if(board[r][c] === \\'M\\'){\\n        board[r][c] = \\'X\\';\\n    } else if(board[r][c] === \\'E\\'){\\n        DFS(r, c);\\n    }\\n\\n    return board;\\n};", "var adjacentMines = function(board, x, y){\\n    let numMines = 0;\\n    for(let i = x-1; i <= x+1; ++i){ "]}
{"id": "856", "ref_js": ["var findPairs = function (nums, k) {\\n\\tlet map = {}, ", "var findPairs = function(nums, k) {\\n    var map = {};", "var findPairs = function(nums, k) {\\n    let obj = {}, count=0;\\n    for(let i=0;i<nums.length;i++)\\n    {\\n      if (!obj[nums[i]]){\\n        obj[nums[i]] = 1\\n      }\\n      else{\\n          obj[nums[i]]++\\n      }\\n    }\\n\\n    if(k == 0){\\n     for(let value of Object.values(obj)){\\n        if(value > 1){\\n          count++\\n        }\\n     }\\n\\n     return count;\\n    }\\n\\n     for(let key of Object.keys(obj)){\\n        let diff = key - k;\\n        if(obj[diff]){\\n          count++\\n        }\\n    }\\n\\n    return count;\\n};"]}
{"id": "858", "ref_js": ["var complexNumberMultiply = function (num1, num2) {\\n\\tvar a = parseInt(num1.split(\"+\")[0]);\\n\\tvar b = parseInt(num1.split(\"+\")[1].replace(\"i\", \"\"));\\n\\tvar c = parseInt(num2.split(\"+\")[0]);\\n\\tvar d = parseInt(num2.split(\"+\")[1].replace(\"i\", \"\"));\\n\\treturn `${a * c - b * d}+${a * d + b * c}i`;\\n};", "var complexNumberMultiply = function (num1, num2) {\\n    let firstNum = num1.substring(0, num1.indexOf(\\'+\\'));\\n    let secondNum = num1.substring(num1.indexOf(\\'+\\') + 1, num1.length - 1)\\n    let thirdNum = num2.substring(0, num2.indexOf(\\'+\\'));\\n    let fourthNum = num2.substring(num2.indexOf(\\'+\\') + 1, num2.length - 1);\\n\\n    let firstProd = (firstNum*thirdNum)-(secondNum*fourthNum);\\n    let secondProd = (firstNum*fourthNum) + (secondNum*thirdNum);\\n\\n    return \"\"+firstProd+\"+\"+secondProd+\"i\"\\n};", "var complexNumberMultiply = function(num1, num2) {\\n    let a = parseInt(num1.split(\"+\")[0]);\\n\\tlet b = parseInt(num1.split(\"+\")[1].replace(\"i\", \"\"));\\n\\n\\tlet c = parseInt(num2.split(\"+\")[0]);\\n\\tlet d = parseInt(num2.split(\"+\")[1].replace(\"i\", \"\"));\\n    \\n\\treturn `${a * c - b * d}+${a * d + b * c}i`;\\n};"]}
{"id": "859", "ref_js": ["var convertBST = function(root) {\\n  const dfs = (root, start) => {\\n    if (!root) return start;\\n    root.val = dfs(root.right, start) + root.val;\\n    return dfs(root.left, root.val);\\n  }\\n  dfs(root, 0);\\n  return root;\\n};", "var convertBST = function (root) {\\n    let sum = 0;\\n    function rvl(node) {\\n        if (!node) return;\\n        rvl(node.right);\\n        node.val += sum;\\n        sum = node.val;\\n        rvl(node.left);\\n    }\\n    rvl(root);\\n    return root;\\n};", "var convertBST = function (root) {\\n    let sum = 0;\\n    function rvl(node) {\\n        if (!node) return;\\n        rvl(node.right);\\n        node.val += sum;\\n        sum = node.val;\\n        rvl(node.left);\\n    }\\n    rvl(root);\\n    return root;\\n};"]}
{"id": "860", "ref_js": ["var findMinDifference = function(timePoints) {\\n  timePoints.sort();\\n  timePoints = timePoints.map(el => {\\n    let [hours, minutes] = el.split(\\':\\');\\n    return Number(hours) * 60 + Number(minutes);\\n  })\\n  \\n  timePoints.push(timePoints[0] + 1440);\\n  let minDiff = Infinity;\\n  for (let i = 1; i < timePoints.length; i ++) {\\n    minDiff = Math.min(minDiff, timePoints[i] - timePoints[i - 1]);\\n  }\\n  \\n  return minDiff;\\n};", "var findMinDifference = function(timePoints) {\\n   let numbers = timePoints.map(time => Number(time.split(\\':\\')[0]) *60 + Number(time.split(\\':\\')[1])).sort((a, b) => a- b);\\n   let result = [];\\n   numbers.push(numbers[0] + 1440);\\n\\n   for(let i = 1; i < numbers.length; i++){\\n       result.push(numbers[i] - numbers[i - 1]);\\n   }    \\n   return Math.min(...result);\\n};", "var findMinDifference = function(timePoints) {\\n    const numbers = timePoints.map(time => Number(time.split(\\':\\')[0])*60 + Number(time.split(\\':\\')[1])).sort((a, b) => a - b);\\n    const result = [];\\n    numbers.push(numbers[0] + 1440);\\n\\n    for (let i = 1; i < numbers.length; i++) {\\n        result.push(numbers[i] - numbers[i - 1]);\\n    }\\n\\n    return Math.min(...result);\\n};"]}
{"id": "861", "ref_js": ["var singleNonDuplicate = function(nums) {\\n    for(let i = 0; i < nums.length; i += 2){\\n        if(nums[i] !== nums[i+1]) return nums[i];\\n    }\\n};", "var singleNonDuplicate = function(nums) {\\n    let sum = 0;\\n    \\n    for (const num of nums) sum ^= num;\\n    \\n    return sum;\\n};", "var singleNonDuplicate = function(nums) {\\n    for(let i=0;i<nums.length;i=i+2){\\n        if(nums[i]!==nums[i+1]) return nums[i];\\n    }\\n};"]}
{"id": "862", "ref_js": ["var updateMatrix = function(mat) {\\n    if (!mat || mat.length === 0 || mat[0].length === 0)\\n        return [];\\n\\n    let m = mat.length, n = mat[0].length;\\n    let queue = [];\\n    let MAX_VALUE = m * n;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (mat[i][j] === 0) {\\n                queue.push([i, j]);\\n            } else {\\n                mat[i][j] = MAX_VALUE;\\n            }\\n        }\\n    }\\n    \\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    while (queue.length > 0) {\\n        let [row, col] = queue.shift();\\n        for (let [dr, dc] of directions) {\\n            let r = row + dr, c = col + dc;\\n            if (r >= 0 && r < m && c >= 0 && c < n && mat[r][c] > mat[row][col] + 1) {\\n                queue.push([r, c]);\\n                mat[r][c] = mat[row][col] + 1;\\n            }\\n        }\\n    }\\n    \\n    return mat;\\n};", "var updateMatrix = function(mat) {\\n    const rows = mat.length;\\n    const cols = mat[0].length;\\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    const queue = [];\\n\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            if (mat[i][j] === 0) {\\n                queue.push([i, j]);\\n            } else {\\n                mat[i][j] = Infinity;\\n            }\\n        }\\n    }\\n\\n    while (queue.length > 0) {\\n        const [row, col] = queue.shift();\\n\\n        for (const [dr, dc] of directions) {\\n            const new_row = row + dr;\\n            const new_col = col + dc;\\n\\n            if (new_row >= 0 && new_row < rows && new_col >= 0 && new_col < cols && mat[new_row][new_col] > mat[row][col] + 1) {\\n                mat[new_row][new_col] = mat[row][col] + 1;\\n                queue.push([new_row, new_col]);\\n            }\\n        }\\n    }\\n\\n    return mat;    \\n};", "var updateMatrix = function(mat) {\\n    if (!mat || mat.length === 0 || mat[0].length === 0)\\n        return [];\\n\\n    let m = mat.length, n = mat[0].length;\\n    let queue = [];\\n    let MAX_VALUE = m * n;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (mat[i][j] === 0) {\\n                queue.push([i, j]);\\n            } else {\\n                mat[i][j] = MAX_VALUE;\\n            }\\n        }\\n    }\\n    \\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    while (queue.length > 0) {\\n        let [row, col] = queue.shift();\\n        for (let [dr, dc] of directions) {\\n            let r = row + dr, c = col + dc;\\n            if (r >= 0 && r < m && c >= 0 && c < n && mat[r][c] > mat[row][col] + 1) {\\n                queue.push([r, c]);\\n                mat[r][c] = mat[row][col] + 1;\\n            }\\n        }\\n    }\\n    \\n    return mat;\\n};"]}
{"id": "863", "ref_js": ["var findCircleNum = function (isConnected) {\\n    const nodes = isConnected[0].length\\n    const graph = {}\\n    ", "var findCircleNum = function (isConnected) {\\n    const config = {};", "var findCircleNum = function (isConnected) {\\n    const nodes = isConnected[0].length\\n    const graph = {}\\n    "]}
{"id": "865", "ref_js": ["var optimalDivision = function(nums) {\\n   if(nums.length === 1){\\n       return nums[0].toString();\\n   }    \\n   if(nums.length === 2){\\n       return nums[0] + \"/\" + nums[1];\\n   }\\n   let result = nums[0] + \"/(\" + nums.slice(1).join(\"/\") + \")\";\\n   return result;\\n};", "var optimalDivision = function(nums) {\\n    if (nums.length === 1) {\\n        return nums[0].toString();\\n    }\\n    if (nums.length === 2) {\\n        return nums[0] + \"/\" + nums[1];\\n    }\\n    let result = nums[0] + \"/(\" + nums.slice(1).join(\"/\") + \")\";\\n    return result;\\n};", "var optimalDivision = function(nums) {\\n    if (nums.length === 1) {\\n        return nums[0].toString();\\n    }\\n    if (nums.length === 2) {\\n        return nums[0] + \"/\" + nums[1];\\n    }\\n    let result = nums[0] + \"/(\" + nums.slice(1).join(\"/\") + \")\";\\n    return result;\\n};"]}
{"id": "866", "ref_js": ["var leastBricks = function(wall) {\\n    let freq = new Map(), best = 0\\n    for (let i = 0; i < wall.length; i++) {\\n        let row = wall[i], rowSum = row[0]\\n        for (let j = 1; j < row.length; j++) {\\n            freq.set(rowSum, (freq.get(rowSum) || 0) + 1)\\n            rowSum += row[j]\\n        } \\n    }\\n    for (let [k,v] of freq)\\n        if (v > best) best = v\\n    return wall.length - best\\n};", "var leastBricks = function(wall) {\\n    const map = new Map();\\n    let result = 0;\\n\\n    wall.forEach((row) => {\\n        let sum = 0;\\n\\n        for(let n = 0; n < row.length - 1; n++) {\\n            sum += row[n];\\n\\n            if(map.has(sum)) {\\n                map.set(sum, map.get(sum) + 1);\\n            } else {\\n                map.set(sum, 1);\\n            }\\n\\n            result = Math.max(result, map.get(sum));\\n        }\\n    })\\n\\n    return wall.length - result;\\n};", "var leastBricks = function(wall) {\\n   let map = {};"]}
{"id": "867", "ref_js": ["var nextGreaterElement = function(n) {\\n    ", "var nextGreaterElement = function(n) {\\n    \\n    var numbers = (\"\" + n).split(\\'\\').map(n=>parseInt(n));\\n    var lastIncreasePosition = null;\\n    var smallestToSwapWithPosition;\\n    var i, l;\\n    \\n    for (i = 0, l = numbers.length; i < l; i++) {\\n        \\n        ", "var nextGreaterElement = function(n) {\\n    let strNum = \\'\\' + n;\\n    let numArr = strNum.split(\\'\\').map(Number);\\n    let leftSmallerIdx = -1;\\n    let rightGreaterIdx;\\n\\n    function swap(arr, i, j){\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n\\n    for(let i=numArr.length-2; i>=0; i--){\\n        if(numArr[i] < numArr[i+1]){\\n            leftSmallerIdx = i;\\n            break;\\n        }\\n    }\\n\\n    if(leftSmallerIdx === -1) return -1;\\n\\n    for(let j=numArr.length-1; j>leftSmallerIdx; j--){\\n        if(numArr[j] > numArr[leftSmallerIdx]){\\n            rightGreaterIdx = j;\\n            break;\\n        }\\n    }\\n\\n    swap(numArr, leftSmallerIdx, rightGreaterIdx);\\n    let leftArr = numArr.slice(0, leftSmallerIdx+1);\\n    let rightArr = numArr.slice(leftSmallerIdx+1);\\n    rightArr.sort((a,b) => a-b);\\n    numArr = leftArr.concat(rightArr);\\n    let nextGreaterElement = +numArr.join(\\'\\');\\n    return nextGreaterElement > (Math.pow(2, 31) - 1) ? -1 :\\n    nextGreaterElement;\\n};"]}
{"id": "869", "ref_js": ["var subarraySum = function(nums, k) {\\n    const n = nums.length;\\n    const prefix = new Array(n).fill(0);\\n    prefix[0] = nums[0];\\n\\n    for (let i = 1; i < n; i++) {\\n        prefix[i] = nums[i] + prefix[i - 1];\\n    }\\n\\n    const mp = new Map();\\n    let cnt = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        if (prefix[i] === k) cnt++;\\n\\n        if (mp.has(prefix[i] - k)) {\\n            cnt += mp.get(prefix[i] - k);\\n        }\\n        mp.set(prefix[i], mp.get(prefix[i]) ? mp.get(prefix[i]) + 1 : 1);\\n    }\\n    return cnt;\\n};", "var subarraySumHashMap = function(nums, k) {\\n    let map = new Map();\\n    let sum = 0;\\n    let count = 0;\\n    map.set(0,1);\\n    for (let i=0;i<nums.length;i++) {\\n        sum += nums[i];\\n        if (map.has(sum-k)) count += map.get(sum-k);\\n        if (map.has(sum)) map.set(sum, map.get(sum)+1);\\n        else map.set(sum, 1);\\n    }\\n    return count;\\n}\\n```\\n\\n#### Brute Force\\n``` javascript\\nvar subarraySumBF = function(nums, k) {\\n    let counter = 0;\\n    for (let i=0;i<nums.length;i++) {\\n        let base = 0;\\n        for (let j=i;j<nums.length;j++) {\\n            base+=nums[j];\\n            if (base == k) counter++;\\n        }\\n    }\\n    return counter;\\n};", "var subarraySum = function(nums, k) {\\n    let map = new Map();\\n\\tmap.set(0, 1);\\n    \\n    let sum = 0;\\n    let count = 0;\\n    \\n    for(let num of nums) {\\n        sum += num;\\n        \\n        if(map[sum - k]) {\\n            count += map[sum - k];\\n        } \\n        map[sum] = (map[sum] || 0) + 1;\\n    }\\n    return count;\\n};"]}
{"id": "870", "ref_js": ["var arrayNesting = function(nums) {\\n  let longest = 1;\\n  let set = new Set();\\n  function recursive(k, len){\\n     set.add(k);\\n     if(set.has(nums[k])) longest = Math.max(len, longest);\\n     else recursive(nums[k], len + 1);\\n  }    \\n  nums.forEach(num => recursive(num, 1));\\n  return longest;\\n};", "var arrayNesting = function(nums) {\\n    let n = nums.length;\\n    let maxLen = 0;\\n    for (let i = 0; i < n; i++) {\\n        let idx = i;\\n        let count = 0;\\n        while (nums[idx] !== null) {\\n            let lastIdx = nums[idx];\\n            nums[idx] = null;\\n            idx = lastIdx;\\n            count++;\\n        }\\n        maxLen = Math.max(count, maxLen);\\n    }\\n\\n    return maxLen;\\n};", "var arrayNesting = function(nums) {\\n    let longestLength = 0;\\n\\n    for (let i = 0; i < nums.length; i += 1) {\\n        if (nums[i] !== -1) {\\n            let slow = nums[i];\\n            let fast = nums[i];\\n            let length = 0;\\n            while (true) {\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n                length += 1;\\n                if (slow === fast) {\\n                    break;\\n                }\\n            }\\n\\n            longestLength = Math.max(longestLength, length);\\n\\n            slow = i;\\n            while (true) {\\n                const tempSlow = nums[slow];\\n                if (tempSlow === -1) {\\n                    break;\\n                }\\n                nums[slow] = -1;\\n                slow = tempSlow;\\n            }\\n        }\\n    }\\n\\n    return longestLength;\\n};"]}
{"id": "871", "ref_js": ["var checkInclusion = function (s1, s2) {\\n\\t", "var checkInclusion = function (s1, s2) {\\n    const len1 = s1.length, len2 = s2.length;\\n    if (len1 > len2) return false;\\n\\n    const count = Array(26).fill(0);\\n    for (let i = 0; i < len1; i++) {\\n        count[s1.charCodeAt(i)-97]++;\\n        count[s2.charCodeAt(i)-97]--;\\n    }\\n    if (!count.some(e => e !== 0)) return true;\\n\\n    for (let i = len1; i < len2; i++) {\\n        count[s2.charCodeAt(i)-97]--;\\n        count[s2.charCodeAt(i-len1)-97]++;\\n        if (!count.some(e => e !== 0)) return true;\\n    }\\n    return false;\\n};", "var checkInclusion = function (s1, s2) {\\n    const len1 = s1.length, len2 = s2.length;\\n    if (len1 > len2) return false;\\n\\n    const count = Array(26).fill(0);\\n    for (let i = 0; i < len1; i++) {\\n        count[s1.charCodeAt(i)-97]++;\\n        count[s2.charCodeAt(i)-97]--;\\n    }\\n    if (!count.some(e => e !== 0)) return true;\\n\\n    for (let i = len1; i < len2; i++) {\\n        count[s2.charCodeAt(i)-97]--;\\n        count[s2.charCodeAt(i-len1)-97]++;\\n        if (!count.some(e => e !== 0)) return true;\\n    }\\n    return false;\\n};"]}
{"id": "873", "ref_js": ["var findPaths = function(m, n, maxMove, startRow, startColumn) {\\n    if (!maxMove) return 0\\n    let dpCurr = Array.from({length: m+2}, () => new Uint32Array(n+2)),\\n        dpLast = Array.from({length: m+2}, () => new Uint32Array(n+2))\\n    for (let i = 1; i <= m; i++)\\n        dpCurr[i][1]++, dpCurr[i][n]++\\n    for (let j = 1; j <= n; j++)\\n        dpCurr[1][j]++, dpCurr[m][j]++\\n    let ans = dpCurr[startRow+1][startColumn+1]\\n    for (let d = 1; d < maxMove; d++) {\\n        [dpCurr, dpLast] = [dpLast, dpCurr]\\n        for (let i = 1; i <= m; i++)\\n            for (let j = 1; j <= n; j++)\\n                dpCurr[i][j] = (dpLast[i-1][j] + dpLast[i+1][j] + dpLast[i][j-1] + dpLast[i][j+1]) % 1000000007\\n        ans = (ans + dpCurr[startRow+1][startColumn+1]) % 1000000007\\n    }\\n    return ans\\n};", "var findPaths = function(m, n, maxPath, i, j, memo = new Map()) {\\n    const key = maxPath + \\',\\' + i + \\',\\' + j;\\n    \\n    if (memo.has(key)) return memo.get(key);\\n    \\n    const isOutside = i === -1 || i === m || j === -1 || j === n;\\n    \\n    if (maxPath === 0 || isOutside) return +isOutside;\\n    \\n    memo.set(key, (\\n          findPaths(m, n, maxPath - 1, i - 1, j, memo)\\n        + findPaths(m, n, maxPath - 1, i + 1, j, memo)\\n        + findPaths(m, n, maxPath - 1, i, j + 1, memo)\\n        + findPaths(m, n, maxPath - 1, i, j - 1, memo)\\n    ) % 1000000007);\\n    \\n    return memo.get(key);\\n};", "var findPaths = function(m, n, maxPath, i, j, memo = new Map()) {\\n   let key = maxPath + \\',\\' + i + \\',\\' + j;\\n   if(memo.has(key)) return memo.get(key);\\n   let isOutside = i === -1 || i === m || j === -1 || j === n;\\n   if(maxPath === 0 || isOutside) return +isOutside;\\n   memo.set(key, (\\n       findPaths(m, n, maxPath - 1, i - 1, j, memo)\\n    +  findPaths(m, n, maxPath - 1, i + 1, j, memo)\\n    +  findPaths(m, n, maxPath - 1, i, j + 1, memo)\\n    +  findPaths(m, n, maxPath - 1, i, j - 1, memo)\\n   ) % 1000000007);   \\n   return memo.get(key);\\n};"]}
{"id": "874", "ref_js": ["var findUnsortedSubarray = function(N) {\\n    let len = N.length - 1, left = -1, right = -1,\\n        max = N[0], min = N[len]\\n    for (let i = 1; i <= len; i++) {\\n        let a = N[i], b = N[len-i]\\n        a < max ? right = i : max = a\\n        b > min ? left = i : min = b\\n    }\\n    return Math.max(0, left + right - len + 1)\\n};", "var findUnsortedSubarray = function(nums) {\\n    ", "var findUnsortedSubarray = function(nums) {\\n    let min = Infinity;\\n    let max = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        \\n        if(i == 0){\\n            if(nums[i] > nums[i+1]){                         "]}
{"id": "875", "ref_js": ["var minDistance = function(W1, W2) {\\n    let m = W1.length, n = W2.length\\n    if (m < n) [W1, W2, m, n] = [W2, W1, n, m]\\n    let WA1 = W1.split(\"\"), WA2 = W2.split(\"\"),\\n        dpLast = new Uint16Array(n + 1),\\n        dpCurr = new Uint16Array(n + 1)\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) \\n            dpCurr[j+1] = WA1[i] === WA2[j]\\n                ? dpLast[j] + 1\\n                : Math.max(dpCurr[j], dpLast[j+1]);\\n        [dpLast, dpCurr] = [dpCurr, dpLast]\\n    }\\n    return m + n - 2 * dpLast[n] \\n};", "var minDistance = function(word1, word2) {\\n   \\n    const lcs = Array.from(Array(word1.length + 1), () => Array(word2.length + 1).fill(0));\\n    const firstWordLength = word1.length;\\n    const secondWordLength = word2.length;\\n\\n    for (let m = 1; m <= firstWordLength; m++) {\\n        for (let n = 1; n <= secondWordLength; n++) {\\n            const isSameCharacter = word1[m - 1] === word2[n - 1];\\n            const maxSubsequenceTillNow = Math.max(lcs[m][n - 1], lcs[m - 1][n]);\\n            lcs[m][n] = isSameCharacter ? 1 + lcs[m - 1][n - 1] : maxSubsequenceTillNow;\\n        }\\n    }\\n    \\n    return firstWordLength + secondWordLength - 2 * lcs[firstWordLength][secondWordLength];\\n};", "var minDistance = function(word1, word2) {\\n   \\n    const lcs = Array.from(Array(word1.length + 1), () => Array(word2.length + 1).fill(0));\\n    const firstWordLength = word1.length;\\n    const secondWordLength = word2.length;\\n\\n    for (let m = 1; m <= firstWordLength; m++) {\\n        for (let n = 1; n <= secondWordLength; n++) {\\n            const isSameCharacter = word1[m - 1] === word2[n - 1];\\n            const maxSubsequenceTillNow = Math.max(lcs[m][n - 1], lcs[m - 1][n]);\\n            lcs[m][n] = isSameCharacter ? 1 + lcs[m - 1][n - 1] : maxSubsequenceTillNow;\\n        }\\n    }\\n    \\n    return firstWordLength + secondWordLength - 2 * lcs[firstWordLength][secondWordLength];\\n};"]}
{"id": "877", "ref_js": ["var fractionAddition = function (s) {\\n  const gcd = (a, b) => (!b ? a : gcd(b, a % b));\\n  const lcm = (a, b) => (a * b) / gcd(a, b);\\n  if (s[0] !== \"-\") {\\n    s = \"+\" + s;\\n  }\\n  let fractions = [];\\n  for (let i = 0; i < s.length;) {\\n    let plusMinusSignChar = s[i++];\\n    let numeratorStr = \"\";\\n    for (; s[i] >= 0 && s[i] <= 9; i++) numeratorStr += s[i];\\n    let divideSignChar = s[i++];\\n    let denominatorStr = \"\";\\n    for (; s[i] >= 0 && s[i] <= 9; i++) denominatorStr += s[i];\\n    fractions.push([(plusMinusSignChar === \"+\" ? 1 : -1) * +numeratorStr, +denominatorStr]);\\n  }\\n  let prev = fractions[0];\\n  for (let i = 1; i < fractions.length; i++) {\\n    let [n1, d1] = prev;\\n    let [n2, d2] = fractions[i];\\n    let lcmd1d2 = lcm(d1, d2);\\n    prev = [n1 * (lcmd1d2 / d1) + n2 * (lcmd1d2 / d2), lcmd1d2];\\n  }\\n  let [n, d] = prev;\\n  let gcdnd = gcd(n, d);\\n  if (gcdnd < 0) gcdnd *= -1;\\n  return \"\" + n / gcdnd + \"/\" + d / gcdnd;\\n};", "var fractionAddition = function(expression) {\\n    let fractions = expression.split(/[+-]/).filter(Boolean);\\n    let operator = expression.split(/[0-9/]/).filter(Boolean);\\n    expression[0] !== \\'-\\' && operator.unshift(\\'+\\');\\n\\n    let gcd = (a, b) => b === 0 ? a : gcd(b, a % b);\\n    let lcm = fractions.reduce((result, fraction) => {\\n        let denominator = fraction.split(\\'/\\')[1];\\n        return result * denominator / gcd(result, denominator);\\n    }, 1);\\n\\n    let molecularSum = fractions.reduce((total, fraction, index) => {\\n        let [molecular, denominator] = fraction.split(\\'/\\');\\n        let multiple = lcm / denominator * (operator[index] === \\'+\\' ? 1 : -1);\\n        return total + molecular * multiple;\\n    }, 0);\\n\\n    let resultGCD = gcd(Math.abs(molecularSum), lcm);\\n    return `${molecularSum / resultGCD}/${lcm / resultGCD}`;\\n};", "var fractionAddition = function(expression) {\\n    let surats =[];\\n    let maxrajs  =[];\\n    let signs =[];\\n    let arr = expression.split(\"\");\\n    for(let i=0; i<arr.length; i++){\\n      if(arr[i]==\\'/\\'){\\n          let j=i-1;\\n          let s=\\'\\';\\n          while(arr[j] !=\\'-\\' && arr[j] !=\\'+\\' && j>=0){\\n              s=arr[j]+s;\\n              j--;\\n          }\\n          if(arr[j]==\\'-\\' && j>=0){\\n              signs.push(-1);\\n          }else{\\n              signs.push(1);\\n          }\\n          surats.push(+s);\\n          let k=i+1;\\n          let x=\\'\\';\\n          while(arr[k]!=\\'-\\' && arr[k]!=\\'+\\' && k<arr.length){\\n              x+=arr[k];\\n              k++;\\n          }\\n          maxrajs.push(+x);\\n      }\\n    }\\n    let maxraj=1;\\n    for(let x of maxrajs){\\n        maxraj *=x;\\n    };"]}
{"id": "878", "ref_js": ["var validSquare = function(p1, p2, p3, p4) {\\n\\t", "var validSquare = function(p1, p2, p3, p4) {\\n    function DISTANCE(x, y){\\n         let [xA, xB] = x;\\n         let [yA, yB] = y;\\n         return (xA - yA) ** 2 + (xB - yB) ** 2;\\n    }\\n\\n    let set = new Set([\\n        DISTANCE(p1, p2),\\n        DISTANCE(p1, p3),\\n        DISTANCE(p1, p4),\\n        DISTANCE(p2, p3),\\n        DISTANCE(p2, p4),\\n        DISTANCE(p3, p4),\\n    ]);\\n   return !set.has(0) && set.size === 2;\\n};", "var validSquare = function(p1, p2, p3, p4) {\\n    const distance = (a, b) => {\\n\\t\\tconst [aX, aY] = a;\\n\\t\\tconst [bX, bY] = b;\\n\\t\\treturn (aX - bX) ** 2 + (aY - bY) ** 2;\\n\\t};"]}
{"id": "881", "ref_js": ["var findDuplicate = function(paths) {\\n    let map={},ans=[]\\n     for(path of paths){\\n        let [root,...files] = path.split(\\' \\');\\n        for(file of files){\\n            let [fileName,content] = file.split(\\'(\\');\\n            if(map[content]){\\n                map[content].push(`${root}/${fileName}`)\\n            }\\n            else{\\n                map[content] = [`${root}/${fileName}`]\\n            }\\n        }\\n    }\\n   \\n    for(entry in map){\\n        if(map[entry].length>1){\\n            ans.push(map[entry]);\\n        }\\n    }\\n    return ans\\n  \\n\\n};", "var findDuplicate = function(paths) {\\n    const hashmap = {};", "var findDuplicate = function(paths) {\\n    const hashmap = {};"]}
{"id": "882", "ref_js": ["var triangleNumber = function(nums) {\\n    ", "var triangleNumber = function(nums) {\\n    let count = 0;\\n    let n = nums.length;\\n    for(let i = 0; i < n - 2; i++){\\n        for(let j = i + 1; j < n - 1; j++){\\n            let a = nums[i];\\n            let b = nums[j];\\n\\n            for(let k = j + 1; k < n; k++){\\n                let c = nums[k];\\n\\n                if(\\n                    a + b > c \\n                &&  a - b < c\\n                &&  b - a < c\\n                ) count++;\\n            }\\n        }\\n    }\\n    return count;\\n};", "var triangleNumber = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let result = 0, n = nums.length, i, j, k;\\n    for(i = 0; i<n ; i++) {\\n        for(j = i+1, k = j+1; j<(n - 1) && k<=n;) {\\n            if(k == n || nums[i]+nums[j] <= nums[k]){\\n                if(k > (j+1))\\n                    result += k - j - 1;\\n                j++;\\n            }else k++;\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "883", "ref_js": ["var leastInterval = function (tasks, n) {\\n    ", "var leastInterval = function(tasks, n) {\\n  ", "var leastInterval = function(tasks, n) {\\n  "]}
{"id": "885", "ref_js": ["var addOneRow = function(root, val, depth, currentDepth = 1) {\\n\\tif (!root) {\\n\\t\\treturn;\\n\\t}\\n\\tif (depth === 1) {\\n\\t\\tconst newNodeForLeft = new Node(val);\\n\\t\\tnewNodeForLeft.left = root;\\n\\t\\treturn newNodeForLeft;\\n\\t} else if (depth - 1 === currentDepth) {\\n\\t\\tconst newNodeForLeft = new Node(val);\\n\\t\\tnewNodeForLeft.left = root.left;\\n\\t\\tconst newNodeForRight = new Node(val);\\n\\t\\tnewNodeForRight.right = root.right;\\n\\t\\troot.left = newNodeForLeft;\\n\\t\\troot.right = newNodeForRight;\\n\\t\\treturn root;\\n\\t}\\n\\n\\taddOneRow(root.left, val, depth, currentDepth + 1);\\n\\taddOneRow(root.right, val, depth, currentDepth + 1);\\n\\treturn root;\\n};", "var addOneRow = function(root, val, depth) {\\n\\tif (depth === 1) return new TreeNode(val, root);\\n\\n\\tconst refactor = (node = root, currentDep = 1) => {\\n\\t\\tif (!node) return;\\n\\t\\tif (currentDep === depth - 1) {\\n\\t\\t\\tconst { left, right } = node;\\n\\t\\t\\tnode.left = new TreeNode(val, left);\\n\\t\\t\\tnode.right = new TreeNode(val, null, right);\\n\\t\\t}\\n\\t\\trefactor(node.left, currentDep + 1);\\n\\t\\trefactor(node.right, currentDep + 1);\\n\\t};", "var addOneRow = function(root, val, depth) {\\n    if (depth === 1) {\\n        return { val, left: root, right: null };"]}
{"id": "887", "ref_js": ["var judgeSquareSum = function(c) {\\n    var r = Math.floor(Math.sqrt(c));\\n    var l = 0;\\n     \\n    while(l <= r){\\n        var sum  = l**2 + r**2\\n        if( sum === c){\\n            return true\\n        }else if(sum < c){\\n            l++\\n        }else{\\n            r--\\n        }\\n    }\\n    return false\\n};", "var judgeSquareSum = function(c) {\\n    let left = 0;\\n    let right = Math.floor(Math.sqrt(c));\\n    while(left <= right){\\n        let squareSum = (left ** 2) + (right ** 2)\\n        if(squareSum === c){\\n            return true;\\n        } else if(squareSum > c){\\n            right--;\\n        } else {\\n            left++;\\n        }\\n    }\\n    return false;\\n};", "var judgeSquareSum = function(c) {\\n    var r = Math.floor(Math.sqrt(c));\\n    var l = 0;\\n     \\n    while(l <= r){\\n        var sum  = l**2 + r**2\\n        if( sum === c){\\n            return true\\n        }else if(sum < c){\\n            l++\\n        }else{\\n            r--\\n        }\\n    }\\n    return false\\n};"]}
{"id": "888", "ref_js": ["var exclusiveTime = function(n, logs) {\\n    const sums = new Array(n).fill(0);\\n    const stack = [];\\n    let prevTime;\\n    logs.forEach(log => {\\n        const details = log.split(\\':\\');\\n        const id = parseInt(details[0]);\\n        const point = details[1];\\n        const time = parseInt(details[2]);\\n        if (point === \\'start\\') {\\n            ", "var exclusiveTime = function(n, logs) {\\n  const stack = [];\\n  const totals = [];\\n  for (let i = 0; i < n; i++) {\\n    totals[i] = 0;\\n  }\\n  logs.forEach(log => {\\n    const parts = log.split(\\':\\');\\n    const fn = Number(parts[0]);\\n    const action = parts[1];\\n    const timestamp = Number(parts[2]);\\n    if (action === \\'start\\') {\\n      stack.push({\\n        fn,\\n        startTime: timestamp\\n      });\\n    } else {\\n      const top = stack.pop();\\n      const duration = timestamp - top.startTime + 1;\\n      totals[top.fn] += duration;\\n      if (stack.length > 0) {\\n        const parent = stack[stack.length - 1];\\n        totals[parent.fn] -= duration;\\n      }\\n    }\\n  });\\n\\n  return totals;\\n};", "var exclusiveTime = function(n, logs) {\\n  const stack = [];\\n  const totals = [];\\n  for (let i = 0; i < n; i++) {\\n    totals[i] = 0;\\n  }\\n  logs.forEach(log => {\\n    const parts = log.split(\\':\\');\\n    const fn = Number(parts[0]);\\n    const action = parts[1];\\n    const timestamp = Number(parts[2]);\\n    if (action === \\'start\\') {\\n      stack.push({\\n        fn,\\n        startTime: timestamp\\n      });\\n    } else {\\n      const top = stack.pop();\\n      const duration = timestamp - top.startTime + 1;\\n      totals[top.fn] += duration;\\n      if (stack.length > 0) {\\n        const parent = stack[stack.length - 1];\\n        totals[parent.fn] -= duration;\\n      }\\n    }\\n  });\\n\\n  return totals;\\n};"]}
{"id": "889", "ref_js": ["var shoppingOffers = function(price, special, needs) {\\n  let betterSpecials = special.filter((s) => \\n      !special.some(s2 => s.at(-1) > s2.at(-1) && s.slice(0, -1).every((y, j) => y === s2[j]))\\n  )\\n    function check(price, special, needs){\\n    let offer = needs.reduce((sum, n, i) => sum + n * price[i], 0);\\n    for(const s of special){\\n    if(s.some((x, i) => x > needs[i])) continue;\\n    offer = Math.min(offer, s.at(-1) + check(price, special, needs.map((n, i) => n - s[i])));\\n        }\\n        return offer;\\n    }\\n    return check(price, betterSpecials, needs);\\n};", "var shoppingOffers = function(price, special, needs) {\\n    const memo = new Map();\\n\\n    function minCost(needs) {\\n        const key = needs.join(\\',\\');\\n\\n        if (memo.has(key)) {\\n            return memo.get(key);\\n        }\\n\\n        let cost = 0;\\n\\n        ", "var shoppingOffers = function(price, offers, needs) {\\n    let ans = new Map() ; \\n    return f(price , needs , offers , ans) ;\\n};"]}
{"id": "890", "ref_js": ["var solveEquation = function(equation) {\\n    const sides = equation.split(\\'=\\');\\n    let left = evalSide(sides[0]);\\n    let right = evalSide(sides[1]);\\n    left.x -= right.x;\\n    left.c -= right.c;\\n    return left.x ? `x=${-left.c / left.x}` : left.c ? \\'No solution\\' : \\'Infinite solutions\\';\\n}\\nfunction evalSide(side){\\n    let res = { x : 0, c : 0};", "var solveEquation = function (s) {\\n  function getXCoeffSumAndValueSum(s) {\\n    let xCoeffSum = 0;\\n    let valueSum = 0;\\n    s.split(\"+\") ", "var solveEquation = function (equation) {\\n    let arr = equation.split(\"=\")\\n    let first = arr[0]\\n    let second = arr[1]\\n    let obj1 = { x: 0, num: 0 }\\n    let obj2 = { x: 0, num: 0 }\\n\\n    let get1 = \"\"\\n    for (let i = 0; i < first.length; i++) {\\n        if (i == 0 && first[i] == \"-\") {\\n            get1 += first[i]\\n        } else if (first[i] != \"+\" && first[i] != \"-\") {\\n            get1 += first[i]\\n        } else {\\n            get1 = first[i];\\n        }\\n\\n        if (get1 != \"+\" && get1 != \"-\" && (i == first.length-1 || first[i+1] == \"+\" || first[i+1] == \"-\")) {\\n            if (get1.includes(\"x\")) {\\n                get1 = get1.replace(\"x\", \"\")\\n                if (get1 == \"\" || get1 == \"+\") {\\n                    obj1.x += 1;\\n                }else if(get1 == \"-\") {\\n                    obj1.x -= 1;\\n                }else{\\n                    obj1.x += +get1;\\n                }\\n            }\\n            else obj1.num += +get1\\n        }\\n    }\\n     let get2 = \"\"\\n    for (let i = 0; i < second.length; i++) {\\n        if (i == 0 && second[i] == \"-\") {\\n            get2 += second[i]\\n        } else if (second[i] != \"+\" && second[i] != \"-\") {\\n            get2 += second[i]\\n        } else {\\n            get2 = second[i];\\n        }\\n\\n        if (get2 != \"+\" && get2 != \"-\"  && (i == second.length-1 || second[i+1] == \"+\" || second[i+1] == \"-\"))  {\\n            if (get2.includes(\"x\")) {\\n                get2 = get2.replace(\"x\", \"\")\\n                if (get2 == \"\" || get2 == \"+\") {\\n                    obj2.x += 1;\\n                }else if(get2 == \"-\") {\\n                    obj2.x -= 1;\\n                }else{\\n                    obj2.x += +get2;\\n                }\\n            }\\n            else obj2.num += +get2\\n        }\\n    }\\n\\n    if(obj1.num == obj2.num && obj1.x == obj2.x) return \"Infinite solutions\";\\n    else if(Math.abs(obj2.num - obj1.num)>0 && obj1.x == obj2.x) return \"No solution\"\\n    else {\\n        let res = \"x=\" + ((obj2.num - obj1.num)/(obj1.x - obj2.x))\\n        return res;\\n    }\\n};"]}
{"id": "892", "ref_js": ["var findLongestChain = function(pairs) {\\n        pairs.sort((a, b) => a[1] - b[1]);\\n\\n        let prev = pairs[0];\\n        let res = 1;\\n\\n        for (let i = 1; i < pairs.length; i++) {\\n            const cur = pairs[i];\\n            if (cur[0] > prev[1]) {\\n                res++;\\n                prev = cur;\\n            }\\n        }\\n\\n        return res;    \\n};", "var findLongestChain = function(pairs) {\\n    pairs.sort((a, b) => a[1] - b[1]);\\n    \\n    let cur = Number.MIN_SAFE_INTEGER, ans = 0;\\n    \\n    for (const [start, end] of pairs) {\\n        if (cur < start) {\\n            cur = end;\\n            ans++;\\n        }\\n    }\\n    \\n    return ans;\\n};", "var findLongestChain = function(pairs) {\\n        pairs.sort((a, b) => a[1] - b[1]);\\n\\n        let prev = pairs[0];\\n        let res = 1;\\n\\n        for (let i = 1; i < pairs.length; i++) {\\n            const cur = pairs[i];\\n            if (cur[0] > prev[1]) {\\n                res++;\\n                prev = cur;\\n            }\\n        }\\n\\n        return res;    \\n};"]}
{"id": "893", "ref_js": ["var countSubstrings = function(S) {\\n    let len = S.length, ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let j = i - 1, k = i\\n        while (k < len - 1 && S[k] === S[k+1]) k++\\n        ans += (k - j) * (k - j + 1) / 2, i = k++\\n        while (~j && k < len && S[k] === S[j]) j--, k++, ans++\\n    }\\n    return ans\\n};", "var countSubstrings = function(s) {\\n    let count = 0;\\n    for(let i = 0; i < s.length; i += 1){\\n        helper(s, i, i) ", "var countSubstrings = function(S) {\\n    let len = S.length, ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let j = i - 1, k = i\\n        while (k < len - 1 && S[k] === S[k+1]) k++\\n        ans += (k - j) * (k - j + 1) / 2, i = k++\\n        while (~j && k < len && S[k] === S[j]) j--, k++, ans++\\n    }\\n    return ans\\n};"]}
{"id": "894", "ref_js": ["var replaceWords = function(dictionary, sentence) {\\n    const arr = sentence.split(\\' \\');\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let word of dictionary) {\\n            if (arr[i].startsWith(word)) {\\n                arr[i] = word;\\n            }\\n        }\\n    }\\n    return arr.join(\\' \\');\\n};", "var replaceWords = function(dictionary, sentence) {\\n    let wordArr = sentence.split(\" \");\\n    wordArr = wordArr.map(w => {\\n        for(let i = 0; i <= dictionary.length - 1; i++) {\\n            if (w.indexOf(dictionary[i]) === 0) {\\n                w = dictionary[i];\\n            }\\n        }\\n        return w;\\n    })\\n    return wordArr.reduce((str, word) => str += `${word} `, \"\").trim();\\n};", "var replaceWords = function(dictionary, sentence) {\\n    const sentArr = sentence.split(\\' \\');\\n    for(let i=0; i<sentArr.length; i++) {\\n        for(dict of dictionary) {\\n            if(sentArr[i].indexOf(dict) === 0) {\\n               sentArr[i] = dict;\\n            }\\n        }\\n    }\\n    const ans = sentArr.join(\" \");\\n    return ans;\\n};"]}
{"id": "895", "ref_js": ["var predictPartyVictory = function(senate) {\\n    if (!senate.includes(\\'R\\')) {\\n        return \\'Dire\\';\\n    } else if (!senate.includes(\\'D\\')) {\\n        return \\'Radiant\\';\\n    }\\n    let arr = senate.split(\\'\\');\\n    while (arr.includes(\\'R\\') && arr.includes(\\'D\\')) {\\n        for (let i = 0; i < arr.length; i++) {\\n            if (arr[i] === \\'R\\') {\\n                if (arr.indexOf(\\'D\\', i+1) !== -1) {\\n                    arr[arr.indexOf(\\'D\\', i+1)] = 0;\\n                } else if (arr.indexOf(\\'D\\') !== -1) {\\n                    arr[arr.indexOf(\\'D\\')] = 0;\\n                }\\n            } else if (arr[i] === \\'D\\') {\\n                if (arr.indexOf(\\'R\\', i+1) !== -1) {\\n                    arr[arr.indexOf(\\'R\\', i+1)] = 0;\\n                } else if (arr.indexOf(\\'R\\') !== -1) {\\n                    arr[arr.indexOf(\\'R\\')] = 0;\\n                }\\n            }\\n        }\\n    }\\n    return arr.includes(\\'R\\') ? \\'Radiant\\' : \\'Dire\\';\\n};", "var predictPartyVictory = function(senate) {\\n    let votingQueue = new Queue();\\n    let dCount = 0; ", "var predictPartyVictory = function(senate) {\\n    let votingQueue = new Queue();\\n    let dCount = 0; "]}
{"id": "896", "ref_js": ["var minSteps = function(n) {\\n    const memo = {}\\n\\n    function dfs(clipboard, aString) { \\n        \\n            ", "var minSteps = function(n) {\\n    if(n === 1) return 0;\\n    function DFS(copy, char){\\n        if(char > n) return 100000;\\n        if(char === n) return 1;\\n        return Math.min(\\n            DFS(copy, char + copy) + 1,\\n            DFS(char, char + char) + 2\\n        )\\n    }\\n    return DFS(1, 1);\\n};", "var minSteps = function(n) {\\n    if(n===1) return 0;\\n    const dfs=(lastCopy,chars)=>{\\n        if(chars>n) return 100000;\\n        if(chars===n) return 1;\\n        return Math.min(\\n            dfs(lastCopy,chars+lastCopy)+1, "]}
{"id": "897", "ref_js": ["var findDuplicateSubtrees = function(root) {\\n    let res = [], obj = {}\\n    ", "var findDuplicateSubtrees = function(root) {\\n  const map = new Map(), res = []\\n  dfs(root, map, res)\\n  return res\\n};", "var findDuplicateSubtrees = function(root) {\\n    let res = [], obj = {}\\n    "]}
{"id": "898", "ref_js": ["var constructMaximumBinaryTree = function(nums) {\\n    const tree = []\\n    nums.forEach(val => {\\n        const current = new TreeNode(val)\\n\\n        while (tree != null && tree.length > 0 && tree[tree.length - 1].val < val){\\n            current.left = tree.pop()\\n        }\\n        \\n        if (tree.length > 0) {\\n            tree[tree.length - 1].right = current\\n        }\\n\\n        tree.push(current)\\n    })\\n\\n    return tree[0];\\n};", "var constructMaximumBinaryTree = function(nums) {\\n    if (nums.length === 0) return null;\\n    let max = Math.max(...nums);\\n    let index = nums.indexOf(max);\\n    let head = new TreeNode(max);\\n    head.left = constructMaximumBinaryTree(nums.slice(0, index));\\n    head.right = constructMaximumBinaryTree(nums.slice(index + 1));\\n    return head;\\n};", "var constructMaximumBinaryTree = function(nums) {\\n    const map = new Map();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        map.set(n, i);\\n    }\\n\\n    const n = nums.length;\\n    const st = new ST(nums);\\n    st.constructST(n);\\n\\n    const helper = (l,r) => {\\n        if(r < l)\\n            return null;\\n\\n        let maxVal = st.rmqUtil(0, n - 1, l, r, 0);\\n        let maxValIdx = map.get(maxVal);\\n\\n        let node = new TreeNode(maxVal);\\n        node.left = helper(l, maxValIdx - 1);\\n        node.right = helper(maxValIdx + 1, r);\\n        \\n        return node;\\n    }\\n\\n    return helper(0, n - 1);\\n};"]}
{"id": "899", "ref_js": ["var printTree = function(root) {\\n    const height = findHeight(root);\\n    let width = 2**height - 1;\\n    let visualTree = Array.from(Array(height), () => new Array(width).fill(\"\"));\\n    DFS(root, visualTree, width)\\n    return visualTree;\\n};", "var printTree = function(root) {\\n    function DFS(node){\\n        if(!node) return 0;\\n        return 1 + Math.max(\\n            DFS(node.left),\\n            DFS(node.right)\\n        );\\n    }\\n\\n    function populateMatrix(node, row, col){\\n        mat[row][col] = \"\" + node.val;\\n        if(node.left){\\n            populateMatrix(node.left, row+1, col-2**(height-row-1));\\n        }\\n        if(node.right){\\n            populateMatrix(node.right, row+1, col+2**(height-row-1));\\n        }\\n    }\\n\\n    let rows = DFS(root);\\n    let height = rows - 1;\\n    let cols = 2 ** rows - 1;\\n    let mat = new Array(rows).fill(\"\")\\n    .map(() => new Array(cols).fill(\"\"));\\n    \\n    populateMatrix(root, 0, (cols-1)/2);\\n    return mat;\\n};", "var printTree = function(root) {\\n    function DFS(node){\\n        if(!node) return 0;\\n        return 1 + Math.max(\\n            DFS(node.left),\\n            DFS(node.right)\\n        );\\n    }\\n\\n    function populateMatrix(node, row, col){\\n        mat[row][col] = \"\" + node.val;\\n        if(node.left){\\n            populateMatrix(node.left, row+1, col-2**(height-row-1));\\n        }\\n        if(node.right){\\n            populateMatrix(node.right, row+1, col+2**(height-row-1));\\n        }\\n    }\\n\\n    let rows = DFS(root);\\n    let height = rows - 1;\\n    let cols = 2 ** rows - 1;\\n    let mat = new Array(rows).fill(\"\")\\n    .map(() => new Array(cols).fill(\"\"));\\n    \\n    populateMatrix(root, 0, (cols-1)/2);\\n    return mat;\\n};"]}
{"id": "900", "ref_js": ["var findClosestElements = function(arr, k, x) {\\n    ", "var findClosestElements = function(arr, k, x) {\\n       let queue = new PriorityQueue((a,b) => a.diff-b.diff);\\n\\n   for(let each of arr){\\n      queue.add({val: each,diff: Math.abs(each-x)})\\n   }\\n   let res = [];\\n\\n   for(let i = 0; i<k; i++){\\n      let elem = queue.poll();\\n      res.push(elem.val);\\n   }\\n   res.sort((a,b) => a-b);\\n   return res;\\n};", "var findClosestElements = function(arr, k, x) {\\n    "]}
{"id": "901", "ref_js": ["var isPossible = function(nums) {\\n    ", "var isPossible = function(nums) {\\n    let list = [];\\n    let count = [];\\n    for(let i = 0; i < nums.length; i++){\\n        let next = nums[i];\\n        let newSeq = true;\\n        for(let j = list.length - 1; j >= 0; j--){\\n            if(list[j] === next){\\n                list[j] = next + 1;\\n                count[j]++;\\n                newSeq = false;\\n                break;\\n            }\\n        }\\n        if(newSeq){\\n            list.push(next + 1);\\n            count.push(1);\\n        }\\n    }\\n    return !count.find(a => a < 3);\\n};", "var isPossible = function(nums) {\\n    let list = [];\\n    let count = [];\\n    for(let i = 0; i < nums.length; i++){\\n        let next = nums[i];\\n        let newSeq = true;\\n        for(let j = list.length - 1; j >= 0; j--){\\n            if(list[j] === next){\\n                list[j] = next + 1;\\n                count[j]++;\\n                newSeq = false;\\n                break;\\n            }\\n        }\\n        if(newSeq){\\n            list.push(next + 1);\\n            count.push(1);\\n        }\\n    }\\n    return !count.find(a => a < 3);\\n};"]}
{"id": "902", "ref_js": ["var widthOfBinaryTree = function (root) {\\n\\t", "var widthOfBinaryTree = function(root) {\\n    const minPos = [0];\\n    let maxWidth = 0;\\n    \\n    callDFS(root, 0, 0);\\n    return maxWidth;\\n    \\n    function callDFS(node, level, pos) {\\n        if(!node) return;\\n        if(minPos[level] === undefined) minPos.push(pos);\\n        \\n        const diff = pos - minPos[level];\\n        maxWidth = Math.max(maxWidth, diff+1);\\n        \\n        callDFS(node.left, level+1, diff*2);\\n        callDFS(node.right, level+1, diff*2+1);\\n    }\\n};", "var widthOfBinaryTree = function (root) {\\n\\t"]}
{"id": "903", "ref_js": ["var checkPossibility = function(N) {\\n    for (let i = 1, err = 0; i < N.length; i++)\\n        if (N[i] < N[i-1])\\n            if (err++ || (i > 1 && i < N.length - 1 && N[i-2] > N[i] && N[i+1] < N[i-1]))\\n                return false \\n    return true\\n};", "var checkPossibility = function(nums) {\\n    let count = 0\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] < nums[i-1]){\\n            count++\\n            if(i-2 < 0 || nums[i-2] <= nums[i]) nums[i-1] = nums[i]\\n            else    nums[i] = nums[i-1]\\n        }\\n    }\\n    return count <= 1\\n};", "var checkPossibility = function(nums) {\\n  let modified = 0;\\n  for (let i = 0; i < nums.length - 1; i++) {\\n    if (nums[i] > nums[i + 1]) {\\n      if (modified++ || nums[i - 1] > nums[i + 1] && nums[i] > nums[i + 2]) return false;\\n    }\\n  }\\n  return true;\\n};"]}
{"id": "904", "ref_js": ["var constructArray = function(n, k) {\\n    let ans = new Array(n)\\n    for (let i = 0, a = 1, z = k + 1; i <= k; i++)\\n        ans[i] = i % 2 ? z-- : a++\\n    for (let i = k + 1; i < n;)\\n        ans[i] = ++i\\n    return ans\\n};", "var constructArray = function(n, k) {\\n    let res = new Array(n);\\n    for(let i = 0, a = 1, z = k + 1; i <= k; i++)\\n    res[i] = i % 2 ? z-- : a++;\\n    for(let i = k + 1; i < n;)\\n    res[i] = ++i;\\n    return res\\n};", "var constructArray = function(n, k) {\\n    let res = new Array(n);\\n    for(let i = 0, a = 1, z = k + 1; i <= k; i++)\\n    res[i] = i % 2 ? z-- : a++;\\n    for(let i = k + 1; i < n;)\\n    res[i] = ++i;\\n    return res\\n};"]}
{"id": "905", "ref_js": ["var trimBST = function(root, low, high) {\\n    if (!root) return null;\\n    if (root.val < low) root = trimBST(root.right, low, high);\\n    else if (root.val > high) root = trimBST(root.left, low, high);\\n    else {\\n        root.left = trimBST(root.left, low, high);\\n        root.right = trimBST(root.right, low, high);\\n    }\\n    return root;\\n};", "var trimBST = function (root, low, high) {\\n\\n\\t\\n\\t\\n\\t\\n\\n\\t\\n\\n\\t\\n\\n\\t", "var trimBST = function(root, L, R) {\\n    if (root === null) {\\n        return null;\\n    }\\n    if (root.val > R) {\\n        "]}
{"id": "906", "ref_js": ["var maximumSwap = function(num) {\\n    ", "var maximumSwap = function(num) {\\n    if (num <= 11) {\\n        return num;\\n    }\\n\\n    let digits = [...`${num}`].map(digit => + digit);\\n\\n    let lastIndices = [];\\n\\n    for (let i = 0; i < digits.length; i++) {\\n        lastIndices[digits[i]] = i;\\n    }\\n\\n    for (let i = 0; i < digits.length; i++) {\\n        for (let j = 9; j >= 0; j--) {\\n            if (digits[i] >= j) break;\\n            if (lastIndices[j] > i) {\\n                [digits[i], digits[lastIndices[j]]] = [digits[lastIndices[j]], digits[i]];\\n                return + digits.join(\\'\\');\\n            } \\n        }\\n    }\\n\\n    return num;\\n};", "var maximumSwap = function(num) {\\n   let nums = [...num.toString()].map(Number);\\n   let max = nums.length - 1;\\n   let maxSwap = (new Array(nums.length)).fill(0);\\n\\n   for(let i = nums.length - 1; i >= 0; i--){\\n       if(nums[i] > nums[max]) max = i;\\n       maxSwap[i] = nums[i] === nums[max] ? i : max;\\n   }    \\n\\n   for(let i = 0; i < maxSwap.length; i++){\\n       if(maxSwap[i] !== i){\\n           [nums[i], nums[maxSwap[i]]] = [nums[maxSwap[i]], nums[i]];\\n           return Number(nums.join(\\'\\'));\\n       }\\n   }\\n   return num;\\n};"]}
{"id": "907", "ref_js": ["var flipLights = function(n, x) {\\n   if(x === 0) return 1;\\n   if(n === 1) return 2;\\n   if(n === 2 && x === 1) return 3;\\n   if(n === 2 || x === 1) return 4;\\n   if(x === 2) return 7;\\n   return 8;    \\n};", "var flipLights = function(n, k) {\\n    if(k == 0) return 1;\\n    if(n == 1) return 2;\\n    if(n == 2 && k == 1) return 3;\\n    if(n == 2 || k == 1) return 4;\\n    if(k == 2) return 7;\\n    return 8;\\n};", "var flipLights = function(n, presses) {\\n    if (presses === 0) {\\n      return 1;\\n    } else if (n === 1) {\\n      return 2;\\n    } else if (n === 2) {\\n      return presses === 1 ? 3 : 4;\\n    } else {\\n      return presses === 1 ? 4 : presses === 2 ? 7 : 8;\\n    }\\n};"]}
{"id": "908", "ref_js": ["var findNumberOfLIS = function(nums) {\\n    let n = nums.length, res = 0, max_len = 0; \\n    let len = new Array(n).fill(0), cnt = new Array(n).fill(0); \\n    for(let i = 0; i < n; i++){ \\n            len[i] = cnt[i] = 1; \\n        for(let j = 0; j < i; j++){ \\n            if(nums[i] > nums[j]){ \\n                if(len[i] == len[j] + 1) \\n                    cnt[i] += cnt[j]; \\n                if(len[i] < len[j] + 1){ \\n                    len[i] = len[j] + 1; \\n                    cnt[i] = cnt[j]; \\n                } \\n            } \\n        } \\n        if(max_len == len[i]) \\n            res += cnt[i]; \\n        if(max_len < len[i]){ \\n            max_len = len[i]; \\n            res = cnt[i]; \\n        } \\n    } \\n    return res;            \\n};", "var findNumberOfLIS = function (nums) {\\n    let n = nums.length;\\n    let dp = new Array(n).fill(1), count = new Array(n).fill(1);\\n    let res = 0, maxi = 1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        for (let prev = 0; prev < i; ++prev) {\\n            if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                dp[i] = 1 + dp[prev];\\n                count[i] = count[prev];\\n            } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n        }\\n        maxi = Math.max(maxi, dp[i]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (maxi == dp[i])\\n            res += count[i];\\n    }\\n\\n    return res;\\n};", "var findNumberOfLIS = function(nums) {\\n    var dp = new Map();\\n    dp.set(-1, new Map());\\n    dp.get(-1).set(-Infinity, 1);\\n    var sortedNums = [];\\n\\n    for (var num of nums) {\\n        var insertIndex = bisectLeft(sortedNums, num);\\n        if (insertIndex === sortedNums.length) {\\n            sortedNums.push(num);\\n        } else {\\n            sortedNums[insertIndex] = num;\\n        }\\n\\n        var total = 0;\\n        for (var [prevNum, count] of dp.get(insertIndex - 1).entries()) {\\n            if (prevNum < num) {\\n                total += count;\\n            }\\n        }\\n        dp.set(insertIndex, dp.get(insertIndex) || new Map());\\n        dp.get(insertIndex).set(num, (dp.get(insertIndex).get(num) || 0) + total);\\n    }\\n\\n    var result = 0;\\n    for (var count of dp.get(sortedNums.length - 1).values()) {\\n        result += count;\\n    }\\n    return result;    \\n};"]}
{"id": "911", "ref_js": ["var checkValidString = function (s) {\\n    let left_min = 0;\\n    let left_max = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] == \\'(\\') {\\n            left_min++;\\n            left_max++;\\n        }\\n        if (s[i] == \\')\\') {\\n            left_min--;\\n            left_max--;\\n\\n        }\\n        if (s[i] == \\'*\\') {\\n            left_min--;\\n            left_max++;\\n\\n        }\\n        if (left_min < 0) {\\n            left_min = 0\\n        }\\n        if (left_max < 0) {\\n            return false;\\n        }\\n\\n    }\\n    if (left_min == 0 || left_max == 0) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n\\n\\n};", "var checkValidString = function(s) {\\n    let leftstack = [];\\n    let starStack = [];\\n    for(let i=0; i<s.length; i++) {\\n        switch(s[i]) {\\n            case \"(\":\\n                leftstack.push(i);\\n                break;\\n            case \")\":\\n                if(leftstack.length > 0) {\\n                    leftstack.pop();\\n                } else if (starStack.length > 0) {\\n                    starStack.pop();\\n                } else {\\n                    return false;\\n                }\\n                break;\\n            case \"*\":\\n                starStack.push(i);\\n                break;\\n        }\\n    }\\n    while(leftstack.length > 0 && starStack.length > 0) {\\n        if (leftstack[leftstack.length-1] > starStack[starStack.length-1]) {\\n            return false;\\n        }\\n        leftstack.pop();\\n        starStack.pop();\\n    }\\n    if(leftstack.length > 0) {\\n        return false;\\n    }\\n    return true;  \\n};", "var checkValidString = function (s) {\\n\\n    let openStack = [];\\n    let starStack = [];\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \"(\")\\n            openStack.push([i, s[i]]);\\n        else if (s[i] === \")\")\\n            if (openStack.length !== 0)\\n                openStack.pop();\\n            else if (starStack.length !== 0)\\n                starStack.pop();\\n            else\\n                return false;\\n        else\\n            starStack.push([i, s[i]]);\\n\\n\\n    let concatStack = openStack.concat(starStack).sort((a, b) => a[0] - b[0]);\\n    let newStack = [];\\n    for (let i = 0; i < concatStack.length; i++)\\n        newStack.push(concatStack[i][1]);\\n    if (newStack.length === 0)\\n        return true;\\n    while (true) {\\n        if (newStack[0] === \"*\")\\n            newStack.splice(0, 1);\\n        else if (newStack[0] === \"(\") {\\n            let getIndex = newStack.slice(0 + 1).indexOf(\"*\")\\n            if (getIndex === -1)\\n                return false;\\n            newStack.splice(getIndex + 1, 1);\\n            newStack.splice(0, 1);\\n        }\\n        if (newStack.length === newStack.filter((item) => item === \"*\").length)\\n            return true;\\n\\n    }\\n};"]}
{"id": "912", "ref_js": ["var findRedundantConnection = function (edges) {\\n    let dsu = new DSU(edges.length);\\n    for (let edge of edges)\\n        if (!dsu.union(edge[0], edge[1]))\\n            return edge;\\n    return [];\\n};", "var findRedundantConnection = function(edges) {\\n    ", "var findRedundantConnection = function(edges) {\\n    let par = Array.from({length: edges.length + 1}, (_,i) => i)\\n    const find = x => x === par[x] ? par[x] : par[x] = find(par[x])\\n    const union = (x,y) => par[find(y)] = find(x)\\n    for (let [a,b] of edges)\\n        if (find(a) === find(b)) return [a,b]\\n        else union(a,b)\\n};"]}
{"id": "913", "ref_js": ["var repeatedStringMatch = function(a, b) {\\n  let count = Math.ceil(b.length / a.length);\\n  let str = a.repeat(count);\\n  return str.includes(b) ? count : (str + a).includes(b) ? count + 1 : -1;    \\n};", "var repeatedStringMatch = function(a, b) {\\n    let count = 1;\\n    let n = a.length;\\n    if(a.indexOf(b) !== -1) {\\n        return 1;\\n    }\\n    if(a.length > b.length && a.indexOf(b) !== -1) {\\n        return 0;\\n    }\\n    let temp = a;\\n    for(let i = 0; i < Math.ceil(b.length / n); i++) {\\n        temp += a;\\n        count++;\\n        if(temp.indexOf(b) !== - 1) {\\n            return count;\\n        }\\n    }\\n    \\n   return -1;\\n};", "var repeatedStringMatch = function(a, b) {\\n    let count = 1;\\n    let n = a.length;\\n    if(a.indexOf(b) !== -1) {\\n        return 1;\\n    }\\n    if(a.length > b.length && a.indexOf(b) !== -1) {\\n        return 0;\\n    }\\n    let temp = a;\\n    for(let i = 0; i < Math.ceil(b.length / n); i++) {\\n        temp += a;\\n        count++;\\n        if(temp.indexOf(b) !== - 1) {\\n            return count;\\n        }\\n    }\\n    \\n   return -1;\\n};"]}
{"id": "914", "ref_js": ["var longestUnivaluePath = function(root) {\\n    let longest=0\\n    const recurse=(node, last)=>{\\n        let rStreak=0\\n        let lStreak=0\\n\\t\\t", "var longestUnivaluePath = function(root) {\\n   let level = 0;\\n   function DFS(parent, curr){\\n       if(curr === null) return 0;\\n       let left = DFS(curr.val, curr.left);\\n       let right = DFS(curr.val, curr.right);\\n       level = Math.max(level, left + right);\\n       return curr.val === parent ? Math.max(left, right) + 1 : 0;\\n   }    \\n   if(root !== null) DFS(root.val, root);\\n   return level;\\n};", "var longestUnivaluePath = function(root) {\\n    let level = 0 \\n    function helper( parent, current) {\\n        if (current === null) return 0\\n        let left = helper(current.val, current.left)\\n        let right = helper(current.val, current.right)\\n        level = Math.max(level, left + right)\\n        return current.val === parent ? Math.max(left, right) + 1 : 0\\n    }\\n    if (root !== null) helper(root.val, root)\\n    return level\\n};"]}
{"id": "915", "ref_js": ["var knightProbability = function(n, k, row, column) {\\n    const moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\\n\\n    let curBoard = Array.from({ length: n }, () => Array(n).fill(0.0));\\n    let nextBoard = Array.from({ length: n }, () => Array(n).fill(0.0));\\n    nextBoard[row][column] = 1.0;\\n\\n    for (let i = 0; i < k; i++) {\\n        [curBoard, nextBoard] = [nextBoard, Array.from({ length: n }, () => Array(n).fill(0.0))];\\n\\n        for (let r = 0; r < n; r++) {\\n            for (let c = 0; c < n; c++) {\\n                if (curBoard[r][c] === 0.0) {\\n                    continue;\\n                }\\n\\n                for (const [dr, dc] of moves) {\\n                    const nextRow = r + dr;\\n                    const nextCol = c + dc;\\n\\n                    if (nextRow >= 0 && nextRow < n && nextCol >= 0 && nextCol < n) {\\n                        nextBoard[nextRow][nextCol] += curBoard[r][c] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let total = 0.0;\\n    for (let r = 0; r < n; r++) {\\n        for (let c = 0; c < n; c++) {\\n            total += nextBoard[r][c];\\n        }\\n    }\\n\\n    return total;    \\n};", "var knightProbability = function(n, k, r, c) {\\n    const moves = [[1,2], [2,1], [-1,2], [2,-1], [-1,-2], [-2,-1], [1,-2], [-2,1]];\\n    let dp = Array.from({length: n}, () => new Array(n).fill(0));\\n    let dpPrev = Array.from({length: n}, () => new Array(n).fill(0));\\n    dpPrev[r][c] = 1;\\n\\n    for(let step = 0; step < k; step++) {\\n        for(let i = 0; i < n; i++) {\\n            for(let j = 0; j < n; j++) {\\n                dp[i][j] = 0;\\n                for(let [dr, dc] of moves) {\\n                    let prevR = i - dr;\\n                    let prevC = j - dc;\\n                    if(prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                        dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n        [dp, dpPrev] = [dpPrev, dp];\\n    }\\n\\n    let totalProbability = 0;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < n; j++) {\\n            totalProbability += dpPrev[i][j];\\n        }\\n    }\\n\\n    return totalProbability;\\n};", "var knightProbability = function(n, k, row, column) {\\n   let dp = new Array(n + 1).fill(-1).map(() => Array(n + 1).fill(-1).map(() => Array(k + 1).fill(-1)));\\n   function iterate(k, row, col, dp){\\n   if(row < 0 || col < 0 || row >= n || col >= n) return 0;\\n   if(k === 0) return 1;\\n   if(dp[row][col][k] !== -1) return dp[row][col][k];\\n   let ways = [\\n       [2, 1], [2, -1], [-2, 1], [-2, -1],\\n       [1, 2], [-1, 2], [1, -2], [-1, -2]\\n   ];\\n   let count = 0;\\n   for(let[dx, dy] of ways) count += iterate(k - 1, row + dx, col + dy, dp);\\n   return dp[row][col][k] = count;   \\n   }\\n   let res = iterate(k, row, column, dp);\\n   return res / Math.pow(8, k);\\n};"]}
{"id": "917", "ref_js": ["var topKFrequent = function(words, k) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        if (!hashmap.has(word)) {\\n            hashmap.set(word, 1);\\n        } else {\\n            hashmap.set(word, hashmap.get(word) + 1);\\n        }\\n    }\\n    \\n    const arr = [...hashmap.entries()].sort((a, b) => b[1] !== a[1] ? b[1] - a[1] : a[0].localeCompare(b[0]));\\n    \\n    return arr.slice(0, k).map(item => item[0]);\\n};", "var topKFrequent = function(words, k) {\\n    let hash = {};", "var topKFrequent = function(nums, k) {\\n    const freqMap = new Map();\\n    const bucket = [];\\n    const output = []\\n    \\n    for(let num of nums) {\\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\\n    }\\n    \\n    for(let [num, freq] of freqMap) {\\n        if(bucket[freq] === undefined) bucket[freq] = [num];\\n        else bucket[freq].push(num);\\n    }\\n    \\n    for(let i = bucket.length-1; i >= 0; i--) {\\n        if(bucket[i] === undefined) continue;\\n        output.push(...bucket[i].sort())\\n        if(output.length >= k) return output.slice(0, k)\\n    }\\n};"]}
{"id": "918", "ref_js": ["var maxAreaOfIsland = function(grid) {\\n    let ans = 0, n = grid.length, m = grid[0].length\\n    const trav = (i, j) => {\\n        if (i < 0 || j < 0 || i >= n || j >= m || !grid[i][j]) return 0\\n        grid[i][j] = 0\\n        return 1 + trav(i-1, j) + trav(i, j-1) + trav(i+1, j) + trav(i, j+1)\\n    }\\n    for (let i = 0; i < n; i++) \\n        for (let j = 0; j < m; j++)\\n            if (grid[i][j]) ans = Math.max(ans, trav(i, j))\\n    return ans\\n};", "var maxAreaOfIsland = function(grid) {\\n    const ROWS = grid.length, COLUMNS = grid[0].length;\\n\\n    const DFS = (row, column) => {\\n        const stack = [[row, column]];\\n        let currRow, currColumn, resultArea = 0;\\n        while (stack.length !== 0){\\n            [currRow, currColumn] = stack.pop();\\n            if (grid[currRow][currColumn] !== 1)\\n                continue;\\n\\n            grid[currRow][currColumn] = 2;\\n            resultArea++;\\n            if (currRow + 1 < ROWS)\\n                stack.push([currRow + 1, currColumn]);\\n            if (currRow - 1 >= 0)\\n                stack.push([currRow - 1, currColumn]);\\n            if (currColumn + 1 < COLUMNS)\\n                stack.push([currRow, currColumn + 1]);\\n            if (currColumn - 1 >= 0)\\n                stack.push([currRow, currColumn - 1]);\\n        } \\n        return resultArea;\\n    };", "var maxAreaOfIsland = function(grid) {\\n    let max = 0;\\n\\tlet num = grid.length;\\n\\tlet fNum = grid[0].length;\\n\\n\\tconst traverse = ((i,j) => \\n\\t{\\n\\t\\t"]}
{"id": "919", "ref_js": ["var canPartitionKSubsets = function(nums, k) {\\n  const total = nums.reduce((sum, num) => sum + num, 0);\\n  ", "var canPartitionKSubsets = function(nums, k) {\\n    const total = nums.reduce((acc, cur) => acc + cur, 0);\\n    if(total % k != 0) return false;\\n    \\n    const subset = total / k;\\n    const memo = new Map();\\n  \\n    function partition(idx, sum, count) {\\n        if(count === k-1) return true;\\n        \\n        const key = nums.join();\\n        if(memo.has(key)) return false;\\n        \\n        if(sum === subset) return partition(0, 0, count+1);\\n        if(sum > subset) return false;\\n        \\n        for(let i = idx; i < nums.length; i++) {\\n            if(nums[i] === null) continue;\\n            const num = nums[i];\\n            nums[i] = null;\\n            if(partition(i+1, sum+num, count)) return true;\\n            nums[i] = num;\\n        }\\n        memo.set(key, false);\\n        return false;\\n    }\\n    return partition(0, 0, 0);\\n};", "var canPartitionKSubsets = function(nums, k) {\\n  if(k === 0) return false;\\n  let subsetSum = nums.reduce((acc, curr) => acc + curr, 0) / k;\\n  if(!Number.isInteger(subsetSum)) return false;\\n  function DFS(start, currSum, subsetNum){\\n      if(currSum > subsetSum) return false;\\n      if(subsetNum === 1) return true;\\n      if(currSum === subsetSum) return DFS(0, 0, subsetNum - 1);\\n      for(let i = start; i < nums.length; i++){\\n          if(nums[i] > 0){\\n          nums[i] *= -1;\\n          if(DFS(i + 1, currSum - nums[i], subsetNum)) return true;\\n          nums[i] *= -1;\\n      }\\n    }\\n      return false;\\n  }    \\n  return DFS(0, 0, k);\\n};"]}
{"id": "920", "ref_js": ["var insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    if(root.val > val) {\\n        root.left = insertIntoBST(root.left,val);\\n    } else if(root.val < val) {\\n        root.right = insertIntoBST(root.right,val);\\n    } \\n    return root;\\n};", "var insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    if(root.val > val) {\\n        root.left = insertIntoBST(root.left,val);\\n    } else if(root.val < val) {\\n        root.right = insertIntoBST(root.right,val);\\n    } \\n    return root;\\n};", "var insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    if(root.val > val) {\\n        root.left = insertIntoBST(root.left,val);\\n    } else if(root.val < val) {\\n        root.right = insertIntoBST(root.right,val);\\n    } \\n    return root;\\n};"]}
{"id": "922", "ref_js": ["var minimumDeleteSum = function(s1, s2) {\\n    let prev_row = new Array(s2.length + 1).fill(0);\\n        for (let j = 1; j <= s2.length; j++)\\n            prev_row[j] = prev_row[j - 1] + s2.charCodeAt(j - 1);\\n        \\n        for (let i = 1; i <= s1.length; i++) {\\n            let curr_row = [prev_row[0] + s1.charCodeAt(i - 1)];\\n            for (let j = 1; j <= s2.length; j++) {\\n                if (s1[i - 1] === s2[j - 1])\\n                    curr_row.push(prev_row[j - 1]);\\n                else\\n                    curr_row.push(Math.min(prev_row[j] + s1.charCodeAt(i - 1), curr_row[curr_row.length - 1] + s2.charCodeAt(j - 1)));\\n            }\\n            prev_row = curr_row;\\n        }\\n        \\n        return prev_row[prev_row.length - 1];\\n};", "var minimumDeleteSum = function(s1, s2) {\\n  const m = s1.length;\\n  const n = s2.length;\\n  const dp = Array(n + 1).fill(0);\\n\\n  for (let j = 1; j <= n; j++) {\\n    dp[j] = dp[j - 1] + s2.charCodeAt(j - 1);\\n  }\\n\\n  for (let i = 1; i <= m; i++) {\\n    let prev = dp[0];\\n    dp[0] += s1.charCodeAt(i - 1);\\n\\n    for (let j = 1; j <= n; j++) {\\n      const temp = dp[j];\\n      if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\\n        dp[j] = prev;\\n      } else {\\n        dp[j] = Math.min(dp[j] + s1.charCodeAt(i - 1), dp[j - 1] + s2.charCodeAt(j - 1));\\n      }\\n      prev = temp;\\n    }\\n  }\\n\\n  return dp[n];\\n};", "var minimumDeleteSum = function(s1, s2) {\\n    const memo = {}\\n    const memo2 = {}\\n\\n    function dfs(i, j) {\\n        if (i >= s1.length && j >= s2.length) return 0\\n        if (i >= s1.length) return getCharCode(s2.slice(j))\\n        if (j >= s2.length) return getCharCode(s1.slice(i))\\n\\n        const memostr = `${i}, ${j}`\\n        if (memostr in memo) return memo[memostr]\\n\\n        if (s1[i] === s2[j]) return memo[memostr] = dfs(i + 1, j + 1)\\n\\n        const s1code = getCharCode(s1[i])\\n        const s2code = getCharCode(s2[j])\\n\\n        memo[memostr] = Math.min(s1code + dfs(i + 1, j), s2code + dfs(i, j + 1))\\n        return memo[memostr]\\n    }\\n\\n    function getCharCode(s1) {\\n        if (s1 in memo2) return memo2[s1]\\n        let sum = 0\\n        for (let i = 0; i < s1.length; i++) {\\n            sum += s1[i].charCodeAt()\\n        }\\n        return memo2[s1] = sum\\n    }\\n\\n    return dfs(0, 0)\\n};"]}
{"id": "923", "ref_js": ["var numSubarrayProductLessThanK = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    if (k <= 1) return 0;\\n    let start = 0, product = 1, count = 0;\\n    for (let end = 0; end < nums.length; end++) {\\n        product *= nums[end];\\n        ", "var numSubarrayProductLessThanK = function(nums, k) {\\n    let ans = 0;\\n    for(let i=0;i<nums.length;i++){\\n        let sub = 1;\\n        for(let j=i;i<nums.length;j++){\\n            sub = sub * nums[j];\\n            if(sub < k) ans++;\\n            else break;\\n        }\\n    }\\n    return ans;\\n};", "var numSubarrayProductLessThanK = function(nums, k) {\\n    if (k <= 1) return 0;\\n    let res = 0, left = 0, right = 0, product = 1;\\n    while(right < nums.length) {\\n        product *= nums[right];\\n        while(product >= k)  {\\n            product /= nums[left];\\n            left++;\\n        }\\n        res += right - left + 1;\\n        right++;\\n    }\\n    return res;\\n};"]}
{"id": "924", "ref_js": ["var maxProfit = function(prices, fee) {\\n    \\n    let bestInCash = 0;\\n    let bestWithStock = -Infinity;\\n\\n    for (let i = 0; i < prices.length; i++) {\\n        let buyThisRound = bestInCash - prices[i]\\n        let sellThisRound = bestWithStock + prices[i] - fee\\n\\n        ", "var maxProfit = function(prices, fee) {\\n    let n = prices.length;\\n    let free = 0, hold = -prices[0]\\n    for(let i = 1; i < n; i++) {\\n        let tmp = hold;\\n        hold = Math.max(hold, free - prices[i])\\n        free = Math.max(free, tmp + prices[i] - fee)\\n    }\\n    return free\\n};", "var maxProfit = function(P, F) {\\n    let len = P.length, buying = 0, selling = -P[0]\\n    for (let i = 1; i < len; i++) {\\n        buying = Math.max(buying, selling + P[i] - F)\\n        selling = Math.max(selling, buying - P[i])\\n    }\\n    return buying\\n};"]}
{"id": "925", "ref_js": ["var findLength = function(nums1, nums2) {\\n    let m = nums1.length, n = nums2.length;\\n    let dp = matrix(m+1,n+1,0);\\n    let ans = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (nums1[i] == nums2[j]) {\\n                dp[i + 1][j + 1] = dp[i][j] + 1;\\n                ans = Math.max(ans, dp[i + 1][j + 1]);\\n            }\\n        }\\n    }\\n    return ans;\\n};", "var findLength = function(nums1, nums2) {\\n    let n = nums1.length;\\n    let m = nums2.length;\\n    var i, j;\\n    var x, y;\\n    var ans=0;\\n    \\n    for( i=0; i<n-ans; i++ ) {\\n        x = i;\\n        for( j=0; j<m-ans; j++ ) {\\n            y = j;\\n            while( x<nums1.length && y<nums2.length && nums1[x] == nums2[y] ) {\\n                x++;\\n                y++;\\n            }\\n            ans = Math.max(ans, x-i);\\n            x = i;\\n        }\\n    }\\n    \\n    return ans;\\n};", "var findLength = function(nums1, nums2) {\\n    let m = nums1.length, n = nums2.length;\\n    let dp = matrix(m+1,n+1,0);\\n    let ans = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (nums1[i] == nums2[j]) {\\n                dp[i + 1][j + 1] = dp[i][j] + 1;\\n                ans = Math.max(ans, dp[i + 1][j + 1]);\\n            }\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "926", "ref_js": ["var longestWord = function(words) {\\n  words.sort();\\n  let set = new Set();\\n  let res = \\'\\';\\n\\n  for (let word of words) {\\n    if (word.length === 1 || set.has(word.slice(0, -1))) {\\n      set.add(word);\\n      if (word.length > res.length) {\\n        res = word;\\n      }\\n    }\\n  }\\n  return res;\\n};", "var longestWord = function(words) {\\n    words.sort(); \\n\\n    let wordSet = new Set();\\n    let longest = \\'\\';\\n\\n    for (let word of words) {\\n        if (word.length === 1 || wordSet.has(word.slice(0, -1))) {\\n            wordSet.add(word);\\n            if (word.length > longest.length) {\\n                longest = word;\\n            }\\n        }\\n    }\\n\\n   return longest\\n};", "var longestWord = function (words) {\\n    words.sort();\\n    let set = new Set();\\n    let res = \\'\\';\\n\\n    for (let word of words) {\\n        if (word.length === 1 || set.has(word.slice(0, -1))) {\\n            set.add(word);\\n            if (word.length > res.length) {\\n                res = word;\\n            }\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "927", "ref_js": ["var accountsMerge = function (accounts) {\\n    const parents = {};", "var accountsMerge = function (accounts) {\\n    let visitedAccounts = Array(accounts.length).fill(false);\\n\\n    let graphEmails = {};", "var accountsMerge = function(accounts) {  \\n    \\n    let graph = {};"]}
{"id": "928", "ref_js": ["var removeComments = function(source) {\\n    let s = source.join(\\'#\\') + \\'#\\';\\n    s = s.replaceAll(/\\\\/\\\\/.*?(?=#)|\\\\/\\\\*.*?\\\\*\\\\", "var removeComments = function(source) {\\n   let s = source.join(\\'#\\') + \\'#\\';\\n   s = s.replaceAll(/\\\\/\\\\/.*?(?=#)|\\\\/\\\\*.*?\\\\*\\\\", "var removeComments = function(source) {\\n    let s = source.join(\\'#\\') + \\'#\\';\\n    s = s.replaceAll(/\\\\/\\\\/.*?(?=#)|\\\\/\\\\*.*?\\\\*\\\\"]}
{"id": "929", "ref_js": ["var splitListToParts = function(head, k) {\\n    ", "var splitListToParts = function(root, k) {\\n    ", "var splitListToParts = function(head, k) {\\n    "]}
{"id": "932", "ref_js": ["var asteroidCollision = function(asteroids) {\\n    let stack = []; \\n    for(let i = 0; i < asteroids.length; i++){ \\n            let asteroid = asteroids[i]; \\n        if(asteroid > 0){ \\n            stack.push(asteroid); \\n        }else{ \\n            while(stack.length > 0 && stack[stack.length - 1] > 0 && stack[stack.length - 1] < Math.abs(asteroid)){ \\n                stack.pop(); \\n            } \\n            if(stack.length === 0 || stack[stack.length - 1] < 0){ \\n                stack.push(asteroid); \\n            }else if(stack[stack.length - 1] === Math.abs(asteroid)){ \\n                stack.pop(); \\n            } \\n        } \\n    } \\n    return stack;                              \\n};", "var asteroidCollision = function(asteroids) {\\n    const res = []\\n    \\n    for (let i = 0; i < asteroids.length; i++) {\\n        const last = res[res.length - 1]\\n        const cur = asteroids[i]\\n        \\n        if (!res.length || last < 0 || cur > 0) {\\n            res.push(cur)\\n        } else if (-cur == last) {\\n            res.pop()\\n        } else if (-cur > last) {\\n            res.pop()\\n            i--\\n        }\\n    }\\n    \\n    return res  \\n};", "var asteroidCollision = function(asteroids) {\\n    const res = []\\n    \\n    for (let i = 0; i < asteroids.length; i++) {\\n        const last = res[res.length - 1]\\n        const cur = asteroids[i]\\n        \\n        if (!res.length || last < 0 || cur > 0) {\\n            res.push(cur)\\n        } else if (-cur == last) {\\n            res.pop()\\n        } else if (-cur > last) {\\n            res.pop()\\n            i--\\n        }\\n    }\\n    \\n    return res  \\n};"]}
{"id": "933", "ref_js": ["var monotoneIncreasingDigits = function(n) {\\n    const str = String(n);\\n    const len = str.length;\\n\\n    let increaseIndex = 0;\\n    let nineIndex = 0;\\n\\n    for(let i = 1;i<len;i++){\\n        const diff = str[i] - str[i-1];\\n        if(diff === 0){\\n            continue;\\n        }\\n        if(diff > 0){\\n            increaseIndex = i;\\n        }\\n        if(diff <0){\\n            nineIndex = i;\\n            break;\\n        }\\n    }\\n    if(increaseIndex === nineIndex){\\n        return n;\\n    }\\n    if(nineIndex ==0){\\n        return n;\\n    }\\n    let result = \\'\\';\\n    for(let i =0;i<len;i++){\\n        if(i<increaseIndex){\\n            result += str[i];\\n            continue;\\n        }\\n        if(i>=nineIndex || i >increaseIndex){\\n            result += \\'9\\'\\n            continue;\\n        }\\n        if(i == increaseIndex){\\n            result += str[i]-1;   \\n        }\\n    }\\n    return result;\\n};", "var monotoneIncreasingDigits = function(n) {\\n   let ans = isMonotone(n);\\n   return ans;    \\n};", "var monotoneIncreasingDigits = function(n) {\\n    const arr = (n + \\'\\').split(\\'\\');\\n    let j = arr.length; "]}
{"id": "934", "ref_js": ["var top = function(a) {\\n    return a[a.length - 1];\\n}\\n\\nvar dailyTemperatures = function(temperatures) {\\n    let stack = [], ans = Array(temperatures.length).fill(0);\\n\\n    for(let i = 0; i < temperatures.length; i++) {\\n        while(stack.length && temperatures[top(stack)] < temperatures[i]) {\\n            let index = stack.pop();\\n            ans[index] = i - index;\\n        }\\n        stack.push(i);\\n    }\\n\\n    return ans;\\n};", "var dailyTemperatures = function (temp) {\\n    ", "var dailyTemperatures = function(temperatures) {\\n    let n = temperatures.length;\\n    let stack = new Array();\\n    let res = new Array(n).fill(0);\\n\\n    for (let i = n-1; i >= 0; i--) {\\n        while(stack.length && temperatures[i] >=  temperatures[stack[stack.length-1]]) {\\n            stack.pop();\\n        }\\n        res[i] = stack[stack.length-1] - i || 0;\\n        stack.push(i);\\n    }\\n    return res;\\n};"]}
{"id": "935", "ref_js": ["var deleteAndEarn = function(nums) {\\n    const n = nums.length;\\n\\n    if(n == 1) return nums[0];\\n    const sorted = nums.sort((a,b) => a - b);\\n    \\n    ", "var deleteAndEarn = function(nums) {\\n    \\n    let max = Number.NEGATIVE_INFINITY\\n    \\n    for(let ctr = 0 ; ctr < nums.length ; ctr ++)\\n        max = Math.max(nums[ctr],max);\\n    \\n    let arr = new Array(max+1).fill(0);\\n    \\n    for(let ctr = 0 ; ctr < nums.length ; ctr ++)\\n        arr[nums[ctr]] += 1\\n    \\n    let dp = new Array(arr.length).fill(-1)\\n    \\n    dp[arr.length]   = 0 ;\\n    dp[arr.length+1] = 0 ;\\n    \\n    for(let ctr = arr.length - 1 ; ctr >= 0 ; ctr --) {\\n        dp[ctr] = Math.max(dp[ctr+1],arr[ctr]*ctr + dp[ctr+2])\\n    }\\n    \\n    return dp[0]\\n    \\n};", "var deleteAndEarn = function(nums) {\\n    const count = {};"]}
{"id": "936", "ref_js": ["var networkDelayTime = function(times, n, k) {\\n    let graph = {};", "var networkDelayTime = function(times, n, k) {\\n    let graph = {};", "var networkDelayTime = function(times, n, k) {\\n    let graph = {};"]}
{"id": "937", "ref_js": ["var openLock = function(deadends, target) {\\n    if (target === \"0000\") return 0\\n    let queue = [0], seen = new Uint8Array(10000)\\n    for (let d of deadends)\\n        seen[~~d] = 1\\n    target = ~~target\\n    if (seen[0]) return -1\\n    for (let turns = 1; queue.length; turns++) {\\n        let qlen = queue.length\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = queue.shift()\\n            for (let j = 1; j < 10000; j *= 10) {\\n                let mask = ~~(curr % (j * 10) / j),\\n                    masked = curr - (mask * j)\\n                for (let k = 1; k < 10; k += 8) {\\n                    let next = masked + (mask + k) % 10 * j\\n                    if (seen[next]) continue\\n                    if (next === target) return turns\\n                    seen[next] = 1\\n                    queue.push(next)\\n                }\\n            }\\n        }\\n    }\\n    return -1\\n};", "var openLock = function(deadends, target) {\\n    \\n    ", "var openLock = function(deadends, target) {\\n    if (target === \"0000\") return 0\\n    let queue = [0], seen = new Uint8Array(10000)\\n    for (let d of deadends)\\n        seen[~~d] = 1\\n    target = ~~target\\n    if (seen[0]) return -1\\n    for (let turns = 1; queue.length; turns++) {\\n        let qlen = queue.length\\n        for (let i = 0; i < qlen; i++) {\\n            let curr = queue.shift()\\n            for (let j = 1; j < 10000; j *= 10) {\\n                let mask = ~~(curr % (j * 10) / j),\\n                    masked = curr - (mask * j)\\n                for (let k = 1; k < 10; k += 8) {\\n                    let next = masked + (mask + k) % 10 * j\\n                    if (seen[next]) continue\\n                    if (next === target) return turns\\n                    seen[next] = 1\\n                    queue.push(next)\\n                }\\n            }\\n        }\\n    }\\n    return -1\\n};"]}
{"id": "938", "ref_js": ["var reachNumber = function(num) {\\n    const m = Math.abs(num)\\n    let N = 1\\n    \\n    const quadVal = (x) => x * (x + 1) * 0.5\\n    const sameOddity = (x) => x % 2 === m % 2\\n    while (\\n        (quadVal(N) < m) \\n        || \\n        (!sameOddity(quadVal(N))) \\n    ) {\\n        N++\\n    }\\n\\n    return N\\n};", "var reachNumber = function(target) {\\n   let sum = 0, i = 1;\\n   if(target < 0) target *= -1;\\n   if(target > 0)\\n   while(sum < target || (sum - target) % 2 === 1){\\n       sum += i;\\n       i++;\\n   } \\n   return i - 1;\\n};", "var reachNumber = function(target) {\\n    let sum = 0;\\n    let i=1;\\n    if(target<0) target*=-1;\\n    if(target>0)\\n    while(sum<target || (sum-target)%2==1){\\n        sum += i;\\n        i++;\\n    }\\n    return i-1;\\n};"]}
{"id": "939", "ref_js": ["var pyramidTransition = function(bottom, allowed) {\\n    let set = new Set(allowed);\\n    let memo = new Map();\\n    let chars = [\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\'];\\n    return topDown(bottom, bottom.length - 1);\\n\\n    function topDown(prev, row){\\n        let key = `${prev}#${row}`;\\n        if(row === 0) return true;\\n        if(memo.has(key)) return memo.get(key);\\n        let pats = new Set();\\n        pats.add(\\'\\');\\n\\n        for(let i = 0; i < row; i++){\\n            let tmp = new Set();\\n            let leftBot = prev.charAt(i);\\n            let rightBot = prev.charAt(i + 1);\\n\\n        for(let char of chars){\\n            let triadStr = leftBot + rightBot + char;\\n            if(set.has(triadStr)){\\n                for(let pat of pats){\\n                    tmp.add(pat + char);\\n                }\\n            }\\n        }\\n        pats = tmp;\\n    }\\n    for(let pat of pats){\\n        if(topDown(pat, row - 1)) return true;\\n    }\\n    memo.set(key, false);\\n    return false;\\n  }\\n};", "var pyramidTransition = function(bottom, allowed) {\\n    const map = {};", "var pyramidTransition = function(bottom, allowed) {\\n    const set = new Set(allowed);\\n    const memo = new Map();\\n    const chars = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\\n    \\n    return topDown(bottom, bottom.length - 1);\\n    \\n    function topDown(prev, row) {\\n        const key = `${prev}#${row}`;\\n        \\n        if (row === 0) return true;\\n        if (memo.has(key)) return memo.get(key);\\n\\n        let pats = new Set();\\n        pats.add(\"\");\\n\\n        for (let i = 0; i < row; i++) {\\n            const tmp = new Set();\\n\\n            const leftBot = prev.charAt(i);\\n            const rightBot = prev.charAt(i + 1);\\n\\n            for (const char of chars) {\\n                const triadStr = leftBot + rightBot + char;\\n\\n                if (set.has(triadStr)) {\\n                    for (const pat of pats) {\\n                        tmp.add(pat + char);\\n                    }                 \\n                }\\n            }\\n          \\n            pats = tmp;\\n        }\\n        \\n        for (const pat of pats) {\\n            if (topDown(pat, row - 1)) return true;\\n        }\\n        \\n        memo.set(key, false);\\n        return false;\\n    }\\n};"]}
{"id": "940", "ref_js": ["var partitionLabels = function (s, lastIdx = {}) {\\n  for (let i = 0; i < s.length; i++) {\\n    lastIdx[s[i]] = i;\\n  }\\n  let curLast = 0, res = [], accu = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    curLast = Math.max(curLast, lastIdx[s[i]]);\\n    if (i === curLast) {\\n      res.push(i + 1 - accu);\\n      accu = i + 1;\\n    }\\n  }\\n  return res;\\n};", "var partitionLabels = function(s) {\\n    let values = new Set();\\n    const ints = [];\\n    let maxInter = null;\\n    let dif = 0;\\n\\n    for (let i=0; i<s.length; i++) {\\n        dif++;\\n        if (!values.has(s[i])) {\\n            const ind = s.lastIndexOf(s[i]);\\n\\n            if (ind === i && maxInter === null) {\\n                ints.push(1);\\n                values.add(s[i]);\\n                dif = 0;\\n                continue;\\n            }\\n\\n            if (maxInter < ind) {\\n                maxInter = ind;\\n                values.add(s[i]);\\n                continue;\\n            }\\n        } else {\\n            if (maxInter === i) {\\n                ints.push(dif);\\n                maxInter = null;\\n                dif=0;\\n            }\\n        }\\n    }\\n\\n    return ints\\n};", "var partitionLabels = function(S) {\\n    const last = new Array(26).fill(-1);\\n    const partitions = [];\\n    let anchor = 0;\\n    let end = 0;\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        last[S.charCodeAt(i) - \\'a\\'.charCodeAt(0)] = i;\\n    }\\n    \\n    \\n    for (let i = 0; i < S.length; i++) {\\n        end = Math.max(end, last[S.charCodeAt(i) - \\'a\\'.charCodeAt(0)]);\\n        if (i === end) {\\n            partitions.push(i - anchor + 1);\\n            anchor = i + 1;\\n        }\\n    }\\n    return partitions;\\n};"]}
{"id": "941", "ref_js": ["var orderOfLargestPlusSign = function(n, mines) {\\n    let x = new Array(n).fill(0).map(() => new Array(n).fill(n));\\n    mines.forEach(a => x[a[0]][a[1]] = 0);\\n\\n    for(let i = 0; i < n; i++){\\n        let[l, r, u, d] = [0, 0, 0, 0];\\n        for(let j = 0, k = n - 1; j < n; j++, k--){\\n           l = x[i][j] && l + 1;\\n           r = x[i][k] && r + 1;\\n           u = x[j][i] && u + 1;\\n           d = x[k][i] && d + 1;\\n\\n           if(l < x[i][j]) x[i][j] = l;\\n           if(r < x[i][k]) x[i][k] = r;\\n           if(u < x[j][i]) x[j][i] = u;\\n           if(d < x[k][i]) x[k][i] = d;\\n        }\\n    }\\n    return Math.max(...x.map(el => Math.max(...el)));\\n};", "var orderOfLargestPlusSign = function(n, mines) {\\n     const grid = Array.from({ length: n }, () => Array(n).fill(1));\\n  for (const [x, y] of mines) {\\n    grid[x][y] = 0;\\n  }\\n  \\n  ", "var orderOfLargestPlusSign = function(n, mines) {\\n     const grid = Array.from({ length: n }, () => Array(n).fill(1));\\n  for (const [x, y] of mines) {\\n    grid[x][y] = 0;\\n  }\\n  \\n  "]}
{"id": "942", "ref_js": ["var reorganizeString = function(s) {\\n    const hash = {};", "var reorganizeString = function(s) {\\n    const freqMap = {};", "var reorganizeString = function(s) {\\n    const hash = {};"]}
{"id": "943", "ref_js": ["var maxChunksToSorted = function(arr) {\\n  var maxChunksToSorted = function(arr) {\\n  let stack = [arr[0]]; ", "var maxChunksToSorted = function (a) {\\n  let count = 0;\\n  let max = -Infinity;\\n  a.forEach((e, i) => {\\n    if (e > max) {\\n      max = e;\\n    }\\n    if (max === i) {\\n      count++;\\n    }\\n  });\\n  return count;\\n};", "var maxChunksToSorted = function(arr) {\\n    let n = arr.length;\\n    let left = n;\\n    let count = 0;\\n    for(let i = n - 1; i >= 0; --i){\\n        left = Math.min(left, arr[i]);\\n        if(left === i) count++;\\n    }\\n    return count;\\n};"]}
{"id": "944", "ref_js": ["var isIdealPermutation = function(A) {\\n    for (let i = 0; i < A.length; i++)\\n        if (i - A[i] > 1 || i - A[i] < -1) return false\\n    return true\\n};", "var isIdealPermutation = function(nums) {\\n    for(let i = 0; i < nums.length; i++)\\n    if(i - nums[i] > 1 || i - nums[i] < -1) return false;\\n    return true;\\n};", "var isIdealPermutation = function(A) {\\n    for (let i = 0; i < A.length; i++)\\n        if (i - A[i] > 1 || i - A[i] < -1) return false\\n    return true\\n};"]}
{"id": "945", "ref_js": ["var canTransform = function(start, end) {\\n    let i = 0;\\n    let j = 0;\\n    \\n    while (i < start.length || j < end.length) {\\n        if (start[i] === \\'X\\') {\\n            i++;\\n            continue;\\n        }\\n        \\n        if (end[j] === \\'X\\') {\\n            j++;\\n            continue;\\n        }\\n        \\n\\t\\t", "var canTransform = function(start, end) {\\n\\t\\tlet L = R = 0;\\n\\n\\t\\tfor (let index = 0; index < start.length; index++) {\\n\\t\\t\\tstart[index] === \\'R\\' && R++;\\n\\t\\t\\tend[index] === \\'L\\' && L++;\\n\\t\\t\\tif (R > 0 && L > 0) return false;\\n\\n\\t\\t\\tstart[index] === \\'L\\' && L--;\\n\\t\\t\\tend[index] === \\'R\\' && R--;\\n\\t\\t\\tif (L < 0 || R < 0) return false;\\n\\t\\t}\\n\\t\\treturn L === 0 && R === 0;\\n\\t};", "var canTransform = function (start, end) {\\n    const sWithoutX = start.replace(/X/g, \\'\\');\\n    const eWithoutX = end.replace(/X/g, \\'\\');\\n\\n    "]}
{"id": "946", "ref_js": ["var kthGrammar = function(n, k) {\\n    if (n === 1) {\\n        return 0;\\n    }\\n\\n    const parent = kthGrammar(n - 1, Math.ceil(k / 2));\\n    const isOdd = k % 2 === 1;\\n\\n    if (parent === 1) {\\n        return isOdd ? 1 : 0;\\n    } else {\\n        return isOdd ? 0 : 1;\\n    }\\n};", "var kthGrammar = function(n, k) {\\n    if (n === 1) return 0;\\n    let length = 1 << (n - 2);\\n    if (k <= length) return kthGrammar(n - 1, k);\\n    else return 1 - kthGrammar(n - 1, k - length);\\n};", "var kthGrammar = function(n, k) {\\n    if (n === 1) {\\n        return 0;\\n    }\\n\\n    const parent = kthGrammar(n - 1, Math.ceil(k / 2));\\n    const isOdd = k % 2 === 1;\\n\\n    if (parent === 1) {\\n        return isOdd ? 1 : 0;\\n    } else {\\n        return isOdd ? 0 : 1;\\n    }\\n};"]}
{"id": "947", "ref_js": ["var numRabbits = function(answers) {\\n   let map = {};", "var numRabbits = function(answers) {\\n    const map = new Map();\\n    let tot = 0;\\n    for (const answer of answers) {\\n        if (answer === 0) {\\n            tot++;\\n            continue;\\n        }\\n        if (!map.has(answer)) {\\n            map.set(answer, answer);\\n            tot += answer + 1;\\n        } else {\\n            map.set(answer, map.get(answer) - 1);\\n            \\n            if (map.get(answer) === 0) map.delete(answer);\\n        }\\n    }\\n    return tot;\\n};", "var numRabbits = function(answers) {\\n  answers = answers.sort((a,b)=>a-b);\\n  let res=0;\\n  let sd=answers[0];\\n  let cnt=1;\\n  for(let i=1; i<answers.length; i++){\\n    if(answers[i]==0){\\n      res++;\\n      continue;\\n    } \\n    if(answers[i]!=sd){\\n        res+=sd+1;\\n        sd =answers[i];\\n        cnt=1;\\n    }else{\\n      cnt++;\\n      if(cnt>answers[i]+1){\\n        res+=sd+1;\\n        cnt=1;\\n      }\\n    }\\n    "]}
{"id": "948", "ref_js": ["var letterCasePermutation = function(S) {\\n    return permut(S, 0);\\n};", "var letterCasePermutation = function (s) {\\n    let output = [];\\n    dfs(\"\", 0);\\n    return output;\\n\\n\\n    function dfs(str, i) {\\n        if (str.length === s.length) {\\n            output.push(str);\\n            return;\\n        }\\n        if (s[i].toLowerCase() === s[i].toUpperCase()) {\\n            dfs(str + s[i], i + 1);\\n            return;\\n        }\\n\\n        dfs(str + s[i].toLowerCase(), i + 1);\\n        dfs(str + s[i].toUpperCase(), i + 1);\\n    }\\n};", "var letterCasePermutation = function(S) {\\n    let n = S.length;\\n    let res = []\\n    let char = /[a-zA-Z]/\\n    let arr = []\\n    \\n    function backtrack(i){\\n        if(i == n){\\n            res.push(arr.join(\\'\\'))\\n            return\\n        }\\n        \\n        if(char.test(S[i])){\\n            arr[i] = S[i].toLowerCase()\\n            backtrack(i+1)\\n            arr[i] = S[i].toUpperCase()\\n            backtrack(i+1)\\n        } else {\\n            arr[i] = S[i]\\n            backtrack(i+1)\\n        }\\n    }\\n    \\n    backtrack(0)\\n    return res\\n};"]}
{"id": "949", "ref_js": ["var isBipartite = function(graph) {\\n    let n = graph.length;\\n    let vis = new Array(n);\\n    vis.fill(-1);\\n\\n    for(let i=0; i<n; i++)\\n    {\\n        if(vis[i] == -1)\\n        {\\n            let rs = solve(i, graph, vis);\\n            if(rs == false)\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};", "var isBipartite = function (graph) {\\n  let colorArr = new Array(graph.length).fill(-1);\\n  colorArr[0] = 1;\\n  let queue = [];\\n  for (let i = 0; i < graph.length; i++) {\\n    if (graph[i].length > 0) {\\n      queue.push(i);\\n    }\\n  }\\n\\n  while (queue.length) {\\n    let top = queue.shift();\\n    let neighbors = graph[top];\\n\\n    for (let node of neighbors) {\\n      ", "var isBipartite = function (graph) {\\n  let colorArr = new Array(graph.length).fill(-1);\\n  colorArr[0] = 1;\\n  let queue = [];\\n  for (let i = 0; i < graph.length; i++) {\\n    if (graph[i].length > 0) {\\n      queue.push(i);\\n    }\\n  }\\n\\n  while (queue.length) {\\n    let top = queue.shift();\\n    let neighbors = graph[top];\\n\\n    for (let node of neighbors) {\\n      "]}
{"id": "950", "ref_js": ["var kthSmallestPrimeFraction = function(arr, k) {\\n    const res = [];\\n\\tarr.forEach((item, i) => {\\n\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tres.push([ item / arr[j], item, arr[j] ]);\\n\\t\\t}\\n\\t});\\n\\tres.sort((a, b) => a[0] - b[0]);\\n\\treturn [ res[k - 1][1], res[k - 1][2] ];\\n};", "var kthSmallestPrimeFraction = function(arr, k) {\\n   let ans = [];\\n   arr.forEach((item, i) => {\\n       for(let j = i + 1; j < arr.length; j++){\\n           ans.push([item / arr[j], item, arr[j]]);\\n       }\\n   });\\n   ans.sort((a, b) => a[0] - b[0]);\\n   return [ans[k - 1][1], ans[k - 1][2]];\\n};", "var kthSmallestPrimeFraction = function(arr, k) {\\n   let ans = [];\\n   arr.forEach((item, i) => {\\n       for(let j = i + 1; j < arr.length; j++){\\n           ans.push([item / arr[j], item, arr[j]]);\\n       }\\n   });\\n   ans.sort((a, b) => a[0] - b[0]);\\n   return [ans[k - 1][1], ans[k - 1][2]];\\n};"]}
{"id": "951", "ref_js": ["var findCheapestPrice = function(n, flights, src, dst, k) {\\n\\n    let dMap = new Map()\\n    \\n    for(let x = 0; x< flights.length;x++){\\n        const [ from , to , price] = flights[x]\\n        if(dMap.has(from)){\\n            let theArray = dMap.get(from)\\n            theArray[to] = price\\n            dMap.set(from,theArray)\\n        }else{\\n            let theArray = new Array(n).fill(-1)\\n            theArray[from] = 0 \\n            theArray[to] = price\\n            dMap.set(from, theArray)\\n        }\\n    }\\n    ", "var findCheapestPrice = function(n, flights, src, dst, k) {\\n    let prices = Array(n).fill(Infinity);\\n    prices[src] = 0;\\n\\n    for (let i = 0; i < k+1; i++) {\\n        const tmpPrices = [...prices];\\n        for ([s, d, p] of flights) {\\n            if (prices[s] === Infinity) continue;\\n            if (prices[s] + p < tmpPrices[d]) {\\n                tmpPrices[d] = prices[s] + p;\\n            }\\n        }\\n        prices = [...tmpPrices];\\n    }\\n\\n    return prices[dst] === Infinity ? -1 : prices[dst];\\n};", "var findCheapestPrice = function(n, flights, src, dst, k) {\\n    let map = {}\\n\\n    for(let [x,y,z] of flights){\\n        if(!map[y]) map[y] = []\\n        map[y].push([x,y,z])\\n    }\\n\\n    let min = Infinity;\\n\\n    let iterate = (end,sum,count)=>{\\n        if(count>k || sum >min) return;\\n\\n        if(end == src){\\n            min = Math.min(min,sum)\\n            return;\\n        }\\n        if(!map[end]) return;\\n\\n        for(let [x,y,z] of map[end]){\\n            iterate(x,sum+z,count+1)\\n        }\\n    }\\n    iterate(dst,0,-1)\\n    return min == Infinity ? -1 : min;\\n};"]}
{"id": "952", "ref_js": ["var rotatedDigits = function(n) {\\n   let count = 0;\\n   for(let i = 1; i <= n; i++){\\n       if(isValidDiffNum(i)) count++;\\n   }    \\n   return count;\\n\\n   function isValidDiffNum(num){\\n       let isValid = true;\\n       let isDiff = false;\\n       while(num > 0){\\n           let lastDig = num % 10;\\n           if(lastDig === 3 || lastDig === 4 || lastDig === 7){\\n               isValid = false;\\n               break;\\n           }\\n           else if(lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9){\\n               isDiff = true;\\n           }\\n           num = ~~(num / 10);\\n       }\\n       return isValid && isDiff;\\n   }\\n};", "var rotatedDigits = function(n) {\\n    let count = 0;\\n    for (let i = 1; i <= n; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n    return count;\\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            } \\n            num = Math.floor(num / 10);\\n        }\\n        return isValid && isDiff;\\n    }\\n};", "var rotatedDigits = function(n) {\\n  let valids =[\\'2\\',\\'5\\',\\'6\\',\\'9\\'];\\n  let invalids =[\\'3\\',\\'4\\',\\'7\\'];\\n  let res=0;\\n  function isGood(n){\\n      let s = String(n);\\n      let ch = false;\\n      for(let i=0; i<s.length; i++){\\n          if(!ch && valids.includes(s[i])){\\n              ch=true;\\n          };"]}
{"id": "953", "ref_js": ["var escapeGhosts = function(ghosts, target) {\\nlet arr = [];\\nfor(let x of ghosts){\\narr.push(Math.abs(x[0] - target[0]) + Math.abs(x[1] - target[1]));\\n    }\\nreturn Math.abs(target[0]) + Math.abs(target[1]) < Math.min(...arr); \\n};", "var escapeGhosts = function (ghosts, targetPos) {\\n  const myPos = [0, 0];\\n  let minGhostDistToTarget = Infinity;\\n  for (let ghostPos of ghosts) {\\n    minGhostDistToTarget = Math.min(minGhostDistToTarget, dist(ghostPos, targetPos));\\n  }\\n  return dist(myPos, targetPos) < minGhostDistToTarget;\\n};", "var escapeGhosts = function(ghosts, target) {\\n    let arr=[];\\n    for(let x of ghosts){\\n        arr.push(Math.abs(x[0]-target[0])+Math.abs(x[1]-target[1]));\\n    }\\n    return Math.abs(target[0])+Math.abs(target[1]) < Math.min(...arr);\\n};"]}
{"id": "954", "ref_js": ["var numTilings = function(n) {\\n    let mod = 10 ** 9 + 7;    \\n    let len = 4;\\n    let ways = new Array(len).fill(0);\\n\\n    ", "var numTilings = function(n) {\\n    function helper(n){\\n        if(n < 4){\\n            return [mem[n],mem2[n]];\\n        } else{\\n            if(mem[n] !== undefined){\\n                return [mem[n],mem2[n]];\\n            } else{\\n                mem[n] = (helper(n-1)[0] + helper(n-2)[0] + 2*helper(n-1)[1]) % (10**9 + 7);\\n                mem2[n] =( helper(n-1)[1] + helper(n-2)[0])% (10**9 + 7);\\n                return [mem[n],mem2[n]];\\n            }\\n        }\\n    }\\n    return helper(n)[0];\\n};", "var numTilings = function(n) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (n === 3) {\\n        return 5;\\n    }\\n    \\n    let k = new Array(n+1);\\n    k[1] = 1;\\n    k[2] = 2;\\n\\n    let p = new Array(n+1);\\n    p[1] = 1;\\n    p[2] = 1;\\n\\n    for (let i=3; i<n+1; i++) {\\n        k[i] = (k[i-2] + k[i-1] + 2*p[i-1]) %(10**9 + 7);\\n        p[i] = (p[i-1] + k[i-2]) %(10**9 + 7);\\n    }\\n    return k[n];\\n};"]}
{"id": "955", "ref_js": ["var customSortString = function (order, s) {\\n  let sMap = {};", "var customSortString = function (order, string) {\\n  let map = {};", "var customSortString = function(order, s) {\\n    function compare(c1, c2){\\n        return order.indexOf(c1) - order.indexOf(c2);\\n    }\\n    \\n    return s.split(\\'\\').sort(compare).join(\\'\\');\\n};"]}
{"id": "956", "ref_js": ["var numMatchingSubseq = function(s, words) {\\n    let subsequence = false;\\n    let count = 0;\\n    let prevIdx, idx \\n    for(const word of words) {\\n        prevIdx = -1;\\n        idx = -1;\\n        subsequence = true;\\n        for(let i = 0; i < word.length; i++) {\\n            idx = s.indexOf(word[i], idx + 1);\\n            if(idx > prevIdx) {\\n                prevIdx = idx;\\n            } else {\\n                subsequence = false;\\n                break;\\n            }\\n        }\\n        if(subsequence) count++;\\n    }\\n    return count;\\n};", "var numMatchingSubseq = function(s, words) {\\n    var result = 0;\\n    var map = new Map();\\n    for (let i = 0; i < words.length; i++){\\n        if (words[i].length > s.length) continue;\\n        if (isSubsequence(words[i], s, map)){\\n            result++\\n        }\\n    }\\n    return result\\n};", "var numMatchingSubseq = function(s, words) {\\n    var result = 0;\\n    var map = new Map();\\n    for (let i = 0; i < words.length; i++){\\n        if (words[i].length > s.length) continue;\\n        if (isSubsequence(words[i], s, map)){\\n            result++\\n        }\\n    }\\n    return result\\n};"]}
{"id": "957", "ref_js": ["var validTicTacToe = function(board) {\\n  let pX = 0, p0 = 0;\\n  let h = [0, 0, 0];\\n  let v = [0, 0, 0];\\n  let d = [0, 0];\\n\\n  function transform(r, c, val){\\n      h[r] += val;\\n      v[c] += val;\\n      if(r === c){\\n          d[0] += val;\\n          if(r + c === board.length - 1){\\n              d[1] += val;\\n          }\\n      } else if(r + c === board.length - 1){\\n          d[1] += val;\\n      }\\n  }    \\n  board.forEach((data, r) => {\\n      data.split(\\'\\').forEach((turn, c) => {\\n          if(turn == \\'X\\'){\\n              pX++;\\n              transform(r, c, 1);\\n          } else if(turn === \\'O\\'){\\n              p0++;\\n              transform(r, c, -1);\\n          }\\n      });\\n  });\\n  if(pX < p0 || pX - p0 > 1) return false;\\n  if(h.includes(3)&&pX <= p0) return false;\\n  if(v.includes(3)&&pX <= p0) return false;\\n  if(d.includes(3)&&pX <= p0) return false;\\n  if(h.includes(-3)&&pX > p0) return false;\\n  if(v.includes(-3)&&pX > p0) return false;\\n  if(d.includes(-3)&&pX > p0) return false;\\n  \\n  return true;\\n};", "var validTicTacToe = function(board) {\\n    let countO = 0\\n    let countX = 0\\n    for (let row = 0; row < board.length; row++){\\n        for(let i = 0; i < 3; i++){\\n            if (board[row][i] === \"O\") countO++\\n            if (board[row][i] === \"X\") countX++\\n        }\\n    }\\n    if (countO > countX) return false\\n    if (countX - countO > 1) return false\\n    let winner = new Set()\\n    if (board[0][0] === board[0][1] && board[0][1] === board[0][2] && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (board[1][0] === board[1][1] && board[1][1] === board[1][2]  && board[1][2] !== \" \") winner.add(board[1][2])\\n    if (board[2][0] === board[2][1] && board[2][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][0] && board[1][0] === board[2][0]  && board[2][0] !== \" \") winner.add(board[2][0])\\n    if (board[0][1] === board[1][1] && board[1][1] === board[2][1]  && board[2][1] !== \" \") winner.add(board[2][1])\\n    if (board[0][2] === board[1][2] && board[1][2] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[2][0] === board[1][1] && board[1][1] === board[0][2]  && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (winner.size > 1) return false\\n    if (Array.from(winner)[0] === \"O\" && countO !== countX) return false\\n    if (Array.from(winner)[0] === \"X\" && countO + 1 !== countX) return false\\n    return true\\n};", "var validTicTacToe = function(board) {\\n    let countO = 0\\n    let countX = 0\\n    for (let row = 0; row < board.length; row++){\\n        for(let i = 0; i < 3; i++){\\n            if (board[row][i] === \"O\") countO++\\n            if (board[row][i] === \"X\") countX++\\n        }\\n    }\\n    if (countO > countX) return false\\n    if (countX - countO > 1) return false\\n    let winner = new Set()\\n    if (board[0][0] === board[0][1] && board[0][1] === board[0][2] && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (board[1][0] === board[1][1] && board[1][1] === board[1][2]  && board[1][2] !== \" \") winner.add(board[1][2])\\n    if (board[2][0] === board[2][1] && board[2][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][0] && board[1][0] === board[2][0]  && board[2][0] !== \" \") winner.add(board[2][0])\\n    if (board[0][1] === board[1][1] && board[1][1] === board[2][1]  && board[2][1] !== \" \") winner.add(board[2][1])\\n    if (board[0][2] === board[1][2] && board[1][2] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[2][0] === board[1][1] && board[1][1] === board[0][2]  && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (winner.size > 1) return false\\n    if (Array.from(winner)[0] === \"O\" && countO !== countX) return false\\n    if (Array.from(winner)[0] === \"X\" && countO + 1 !== countX) return false\\n    return true\\n};"]}
{"id": "958", "ref_js": ["var numSubarrayBoundedMax = function(nums, left, right) {\\n    let ans = 0, low = 0, mid = 0\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = nums[i]\\n        if (num > right) mid = 0\\n        else ans += ++mid\\n        if (num >= left) low = 0\\n        else ans -= ++low\\n    }\\n    return ans\\n};", "var numSubarrayBoundedMax = function (a, low, high) {\\n  function countSubarrays(high) {\\n    let total = 0;\\n    let count = 0;\\n    for (let e of a) {\\n      if (e <= high) {\\n        count += 1;\\n        total += count;\\n      } else {\\n        count = 0;\\n      }\\n    }\\n    return total;\\n  }\\n  return countSubarrays(high) - countSubarrays(low - 1);\\n};", "var numSubarrayBoundedMax = function(nums, left, right) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        let max = -Infinity;\\n        for(let j = i; j < nums.length; j++){\\n            max = Math.max(max, nums[j]);\\n            if(max > right) break;\\n            if(max < left) continue;\\n            count++;\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "959", "ref_js": ["var allPathsSourceTarget = function (graph) {\\n    const src = 0\\n    const dest = graph.length - 1\\n    const answer = []\\n    const dfs = (startNode, path, visited) => {\\n        path.push(startNode)\\n        if (startNode === dest) {\\n            answer.push(path.slice())\\n            return\\n        }\\n        for (let neighbour of graph[startNode]) {\\n            if (!visited[neighbour]) {\\n                visited[neighbour] = true\\n                dfs(neighbour, path, visited)\\n                visited[neighbour] = false\\n                path.pop()\\n            }\\n        }\\n    }\\n    dfs(src, [], {})\\n    return answer\\n};", "var allPathsSourceTarget = function(graph) {\\n    const result = [];\\n    \\n    let dfs = function(node, path){\\n        if (node === graph.length-1) result.push(path)\\n        \\n        for (let neighbour of graph[node]){\\n            dfs (neighbour, path.concat([neighbour]));\\n        }\\n    }\\n    dfs(0, [0])\\n    return result;\\n};", "var allPathsSourceTarget = function(graph) {\\n    const result = [];\\n    \\n    let dfs = function(node, path){\\n        if (node === graph.length-1) result.push(path)\\n        \\n        for (let neighbour of graph[node]){\\n            dfs (neighbour, path.concat([neighbour]));\\n        }\\n    }\\n    dfs(0, [0])\\n    return result;\\n};"]}
{"id": "960", "ref_js": ["var champagneTower = function(poured, query_row, query_glass) {\\n    const tower = new Array(query_row + 1).fill(0).map(() => new Array(query_row + 1).fill(0));\\n    tower[0][0] = poured;\\n\\n    for (let row = 0; row < query_row; row++) {\\n        for (let glass = 0; glass <= row; glass++) {\\n            const excess = (tower[row][glass] - 1) / 2.0;\\n            if (excess > 0) {\\n                tower[row + 1][glass] += excess;\\n                tower[row + 1][glass + 1] += excess;\\n            }\\n        }\\n    }\\n\\n    return Math.min(1, tower[query_row][query_glass]);\\n};", "var champagneTower = function(poured, query_row, query_glass) {\\n    const pyramid = Array.from({ length: 101 }, (_, k) => Array(k + 1).fill(0.0));\\n    pyramid[0][0] = poured;\\n\\n    for (let row = 0; row < query_row; row++) {\\n        for (let glass = 0; glass <= row; glass++) {\\n            const overflow = Math.max(0, (pyramid[row][glass] - 1.0) / 2.0);\\n            if (overflow > 0) {\\n                pyramid[row + 1][glass] += overflow;\\n                pyramid[row + 1][glass + 1] += overflow;\\n            }\\n        }\\n    }\\n\\n    return Math.min(1.0, pyramid[query_row][query_glass]);    \\n};", "var champagneTower = function(poured, query_row, query_glass) {\\n    "]}
{"id": "961", "ref_js": ["var eventualSafeNodes = function(graph) {\\n    const n = graph.length;\\n    const result = new Array(n).fill(0);\\n\\n    const dfs = (node) => {\\n        if (result[node] !== 0) return result[node] === 2;\\n        result[node] = 1;\\n        for (let neighbor of graph[node]) {\\n            if (result[neighbor] === 1 || !dfs(neighbor)) return false;   \\n        }\\n        result[node] = 2;\\n        return true;\\n    };", "var eventualSafeNodes = function(graph) {\\n    const n = graph.length;\\n    const visited = new Array(n).fill(0); ", "var eventualSafeNodes = function(graph) {\\n    const ans = [];\\n    const map = new Map();\\n    for(let i=0; i<graph.length; i++) {\\n        if(dfs(graph, i, map)) {\\n            ans.push(i);\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "962", "ref_js": ["var maxIncreaseKeepingSkyline = function(grid) {\\n    let dupGrid = transposeMatrix(grid);\\n    let colMax = [];\\n    let ans = 0;\\n    \\n    dupGrid.forEach(row => {\\n        colMax.push(Math.max(...row));\\n    });\\n\\n    grid.forEach((row, i) => {\\n        let rowMax = Math.max(...row);\\n        row.forEach((num, j) => {\\n            ans += Math.min(rowMax, colMax[j]) - num;\\n        });\\n    });\\n\\n    return ans;\\n};", "var maxIncreaseKeepingSkyline = function(grid) {\\n    let result = 0, n = grid.length;\\n    let rMax = new Array(grid.length).fill(0);\\n    let cMax = new Array(grid.length).fill(0);\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            rMax[i] = Math.max(rMax[i], grid[i][j]);\\n            cMax[j] = Math.max(cMax[j], grid[i][j]);\\n        }\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            result += Math.min(rMax[i], cMax[j]) - grid[i][j];\\n        }\\n    }\\n\\n    return result;\\n};", "var maxIncreaseKeepingSkyline = function(grid) {\\n    let result=0;\\n    let maxColumns=[];\\n    let maxRow=[];\\n\\n    for(let i=0;i<grid.length;i++){\\n        for(let j=0;j<grid.length;j++){\\n            maxColumns[j]=Math.max((maxColumns[j]||0),grid[i][j])\\n            maxRow[i]=Math.max((maxRow[i]||0),grid[i][j])\\n         }\\n    }\\n\\n    for(let i=0;i<grid.length;i++){\\n        for(let j=0;j<grid.length;j++){\\n           result+=Math.min(maxRow[i],maxColumns[j])-grid[i][j]\\n         }\\n    };"]}
{"id": "963", "ref_js": ["var soupServings = function(n) {\\n    if (n >= 4801) return 1.0\\n    let memo = {}\\n    return (function dp(a = Math.floor((n + 24) / 25), b = Math.floor((n + 24) / 25)) {\\n        if (a < 1 && b < 1) return 0.5\\n        if (a < 1) return 1.0\\n        if (b < 1) return 0.0\\n        let m = a * 5000 + b\\n        if (m in memo) return memo[m]\\n        memo[m] = 0.25 * (dp(a - 4, b) + dp(a - 3, b - 1) + dp(a - 2, b - 2) + dp(a - 1, b - 3));\\n        return memo[m]\\n    })()\\n};", "var soupServings = function(N) {\\n    if (N > 4451) {\\n        return 1.0;\\n    }\\n    N = Math.floor((N + 24) / 25);\\n    let memo = {};", "var soupServings = function(n) {\\n    if (n >= 4300) {\\n        return 1.0;\\n    }\\n\\n    const memo = new Map();\\n\\n    function serve(A, B) {\\n        if (memo.has(`${A}-${B}`)) {\\n            return memo.get(`${A}-${B}`);\\n        }\\n\\n        if (A <= 0 && B <= 0) {\\n            return 0.5;\\n        }\\n        if (A <= 0) {\\n            return 1.0;\\n        }\\n        if (B <= 0) {\\n            return 0.0;\\n        }\\n\\n        const prob = 0.25 * (serve(A - 100, B) + serve(A - 75, B - 25) + serve(A - 50, B - 50) + serve(A - 25, B - 75));\\n        memo.set(`${A}-${B}`, prob);\\n        return prob;\\n    }\\n\\n    return serve(n, n);    \\n};"]}
{"id": "964", "ref_js": ["var expressiveWords = function (s, words) {\\n  let sseq = getChCountInSeq(s);\\n  let count = 0;\\n  OUTER: for (let w of words) {\\n    let wseq = getChCountInSeq(w);\\n    let i = 0\\n    for (; i < wseq.length; i++) {\\n      if (sseq[i] === undefined) continue OUTER;\\n      let [sch, scount] = sseq[i];\\n      let [wch, wcount] = wseq[i];\\n      if (wch !== sch) continue OUTER;\\n      else if (wcount === scount) continue;\\n      if (scount < 3) continue OUTER;\\n      if (wcount > scount) continue OUTER;\\n    }\\n    for (; i < sseq.length; i++) {\\n      if (wseq[i] === undefined) continue OUTER;\\n      let [sch, scount] = sseq[i];\\n      let [wch, wcount] = wseq[i];\\n      if (wch !== sch) continue OUTER;\\n    }\\n    count++;\\n  }\\n  return count;\\n};", "var expressiveWords = function(s, words) {\\n    function isExpressive(word){\\n        let wI = 0;\\n        let sI = 0;\\n\\n        while(wI < word.length || sI < s.length){\\n            let countW = 1;\\n            let countS = 1;\\n            if(word[wI] !== s[sI]) return false;\\n            while(word[wI] === word[wI++ + 1]) countW++;\\n            while(s[sI] === s[sI++ + 1]) countS++;\\n            if(countS < countW || (countS !== countW && countS < 3)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    return words.filter(isExpressive).length;\\n};", "var expressiveWords = function(s, words) {\\n    const isExpressive = (word) => {\\n        let wI = 0;\\n        let sI = 0;\\n        while (wI < word.length || sI < s.length) {\\n            let countW = 1;\\n            let countS = 1;\\n            \\n            if (word[wI] !== s[sI]) return false;\\n            \\n            while (word[wI] === word[wI++ + 1]) countW++;\\n            while (s[sI] === s[sI++ + 1]) countS++;\\n\\n            if (countS < countW || (countS !== countW && countS < 3)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    return words.filter(isExpressive).length;\\n};"]}
{"id": "965", "ref_js": ["var subdomainVisits = function(cpdomains) {\\n    const map = new Map()\\n\\n    for (let domain of cpdomains) {\\n        const [visits, fullDomain] = domain.split(\" \")\\n        const subdomains  = fullDomain.split(\".\")\\n\\n        while (subdomains.length) {\\n            const domain = subdomains.join(\".\")\\n            if (map.has(domain)) {\\n                const curr = map.get(domain)\\n                map.set(domain, Number(curr) + Number(visits))\\n            } else map.set(domain, Number(visits))\\n            subdomains.shift()\\n        }\\n    }\\n    return  Array.from(map, ([key,value]) => `${value} ${key}`)\\n};", "var subdomainVisits = function(cpdomains) {\\n    let visitCounts = {};", "var subdomainVisits = function(cpdomains) {\\n  const map = {};"]}
{"id": "966", "ref_js": ["var largestSumOfAverages = function(nums, k) {\\n   let n = nums.length;\\n   let memo = new Array(n).fill(null).map(() => new Array(k + 1).fill(null));\\n\\n   function average(start, end){\\n       return (nums.slice(start, end + 1).reduce((a, b) => a + b, 0)) / (end - start + 1);\\n   } \\n   function dp(start, k){\\n       if(memo[start][k] !== null){\\n           return memo[start][k];\\n       }\\n       if(k === 1){\\n           return average(start, n - 1);\\n       }\\n       let maxAvg = 0;\\n       for(let i = start; i < n - k + 1; i++){\\n           maxAvg = Math.max(maxAvg, average(start, i) + dp(i + 1, k - 1));\\n       }\\n       memo[start][k] = maxAvg;\\n       return maxAvg;\\n   }\\n   return dp(0, k);\\n};", "var largestSumOfAverages = function(nums, k) {\\n    function recursiveHelper(idx, prefixSum, subArrSize, partitionCount){\\n        if(idx === nums.length){\\n            if(prefixSum === 0) return 0;\\n            return prefixSum / subArrSize;\\n        }\\n\\n        prefixSum += nums[idx];\\n        subArrSize += 1;\\n\\n        if(`${idx}-${prefixSum}-${subArrSize}-${partitionCount}` in dpTable){\\n            return dpTable[`${idx}-${prefixSum}-${subArrSize}-${partitionCount}`];\\n        }\\n\\n        if(partitionCount > 0){\\n            return dpTable[`${idx}-${prefixSum}-${subArrSize}-${partitionCount}`] = Math.max(\\n                ((prefixSum / subArrSize) + \\n                recursiveHelper(idx+1, 0, 0, partitionCount-1)),\\n                recursiveHelper(idx+1, prefixSum, subArrSize, partitionCount)\\n            )\\n        } else {\\n            return dpTable[`${idx}-${prefixSum}-${subArrSize}-${partitionCount}`] = recursiveHelper(idx+1, prefixSum, subArrSize, partitionCount)\\n        }\\n\\n    }\\n\\n    let dpTable = {};", "var largestSumOfAverages = function(nums, k) {\\n    const n = nums.length;\\n    const memo = new Array(n).fill(null).map(() => new Array(k + 1).fill(null));\\n\\n    function average(start, end) {\\n        return (nums.slice(start, end + 1).reduce((a, b) => a + b, 0)) / (end - start + 1);\\n    }\\n\\n    function dp(start, k) {\\n        if (memo[start][k] !== null) {\\n            return memo[start][k];\\n        }\\n        if (k === 1) {\\n            return average(start, n - 1);\\n        }\\n        let maxAvg = 0;\\n        for (let i = start; i < n - k + 1; i++) {\\n            maxAvg = Math.max(maxAvg, average(start, i) + dp(i + 1, k - 1));\\n        }\\n        memo[start][k] = maxAvg;\\n        return maxAvg;\\n    }\\n\\n    return dp(0, k);\\n};"]}
{"id": "967", "ref_js": ["var pruneTree = function(root) {\\n   \\n    if (!root)\\n        return null\\n            \\n    root.left = pruneTree(root.left)\\n    root.right = pruneTree(root.right)\\n     \\n    return ( root.val || root.left || root.right) ? root : null    \\n};", "var pruneTree = function(root) {\\n    \\n\\tfunction containsOne(node) {\\n\\t\\tif (node == null) \\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\tconst leftContainsOne = containsOne(node.left);\\n\\t\\tconst rightContainsOne = containsOne(node.right);\\n\\t\\t\\n\\t\\t if (!leftContainsOne) \\n\\t\\t\\tnode.left = null;\\n\\t\\t\\t\\n\\t\\tif (!rightContainsOne) \\n\\t\\t\\tnode.right = null;\\n\\t\\t\\t\\n\\t\\treturn node.val == 1 || leftContainsOne || rightContainsOne;\\n\\t}\\n\\t\\n\\treturn containsOne(root) ? root : null;\\n};", "var pruneTree = function(root) {\\n   \\n    if (!root)\\n        return null\\n            \\n    root.left = pruneTree(root.left)\\n    root.right = pruneTree(root.right)\\n     \\n    return ( root.val || root.left || root.right) ? root : null    \\n};"]}
{"id": "968", "ref_js": ["var ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};", "var ambiguousCoordinates = function(s) {\\n   let ans = [];\\n   for(let i = 2; i < s.length - 1; i++){\\n       let left = s.slice(1, i);\\n       let right = s.slice(i, s.length - 1);\\n\\n       let ls = [left], rs = [right];\\n       for(let i = 1; i < left.length; i++){\\n         let temp1 = left.slice(0, i);\\n         let temp2 = left.slice(i);\\n           ls.push(`${temp1}.${temp2}`);\\n       }\\n       for(let i = 1; i < right.length; i++){\\n        let temp1 = right.slice(0, i);\\n        let temp2 = right.slice(i, right.length);\\n           rs.push(`${temp1}.${temp2}`);\\n       }\\n       for(let l of ls){\\n       if(!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(l)) continue;\\n       for(let r of rs){\\n        if(!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(r)) continue;\\n        ans.push(`(${l}, ${r})`);\\n       }\\n     }\\n   }\\n   return ans;\\n};", "var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        "]}
{"id": "969", "ref_js": ["var numComponents = function(head, nums) {\\n    if(!head) return null;\\n    let set = new Set(nums);\\n    let res = 0, series = 0;\\n    while(head){\\n        series = set.has(head.val) ? series + 1 : 0;\\n        if(series === 1){\\n            res += 1;\\n            }\\n            head = head.next;\\n        }\\n       return res;\\n    };", "var numComponents = function(head, nums) {\\n    if(!head) return null;\\n    let set = new Set(nums);  \\n    let result = 0, series = 0;\\n    while(head) {\\n        series = set.has(head.val) ? series + 1 : 0;\\n        if(series == 1)\\n        result += 1;\\n        head = head.next;\\n    }\\n    return result;\\n};", "var numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};"]}
{"id": "970", "ref_js": ["var minimumLengthEncoding = function(W) {\\n    let set = new Set(W)\\n    for (let word of W)\\n        if (set.has(word))\\n            for (let i = 1; i < word.length; i++) \\n                set.delete(word.slice(i))\\n    return Array.from(set).join().length + 1\\n};", "var minimumLengthEncoding = function(W) {\\n    let set = new Set(W)\\n    for (let word of W)\\n        if (set.has(word))\\n            for (let i = 1; i < word.length; i++) \\n                set.delete(word.slice(i))\\n    return Array.from(set).join().length + 1\\n};", "var minimumLengthEncoding = function(W) {\\n    let set = new Set(W)\\n    for (let word of W)\\n        if (set.has(word))\\n            for (let i = 1; i < word.length; i++) \\n                set.delete(word.slice(i))\\n    return Array.from(set).join().length + 1\\n};"]}
{"id": "971", "ref_js": ["var flipgame = function(fronts, backs) {\\n   let sides = new Set();\\n   let cardNumbers = new Set();\\n\\n   for(let i = 0; i < fronts.length; i++){\\n       if(fronts[i] === backs[i]){\\n           sides.add(fronts[i]);\\n       } else {\\n           cardNumbers.add(fronts[i]).add(backs[i]);\\n       }\\n   };", "var flipgame = function(fronts, backs) {\\n    let sameSides = new Set();\\n    let numbersOnCards = new Set();\\n\\n    for (let i = 0; i < fronts.length; i++) {\\n        if (fronts[i] === backs[i]) {\\n            sameSides.add(fronts[i]);\\n        } else {\\n            numbersOnCards.add(fronts[i]).add(backs[i]);\\n        }\\n    };", "var flipgame = function(fronts, backs) {\\n   let sides = new Set();\\n   let cardNumbers = new Set();\\n\\n   for(let i = 0; i < fronts.length; i++){\\n       if(fronts[i] === backs[i]){\\n           sides.add(fronts[i]);\\n       } else {\\n           cardNumbers.add(fronts[i]).add(backs[i]);\\n       }\\n   };"]}
{"id": "972", "ref_js": ["var numFactoredBinaryTrees = function(arr) {\\n    const mod = 1e9 + 7;\\n        arr.sort((a, b) => a - b);\\n        let ans = 0;\\n        const map = new Map();\\n\\n        for (const x of arr) {\\n            let ways = 1;\\n            const max = Math.sqrt(x);\\n\\n            for (let j = 0, left = arr[0]; left <= max; left = arr[++j]) {\\n                if (x % left !== 0) continue;\\n                const right = x / left;\\n                if (map.has(right)) {\\n                    ways = (ways + map.get(left) * map.get(right) * (left === right ? 1 : 2)) % mod;\\n                }\\n            }\\n            map.set(x, ways);\\n            ans = (ans + ways) % mod;\\n        }\\n        return ans;\\n};", "var numFactoredBinaryTrees = function(arr) {\\n    const MOD = 1000000007;\\n    arr.sort((a, b) => a - b);\\n    const dp = {};", "var numFactoredBinaryTrees = function(arr) {\\n\\n    "]}
{"id": "973", "ref_js": ["var numFriendRequests = function(ages) {\\n  let count = new Array(121).fill(0);\\n  ages.forEach((age) => count[age]++);\\n  let res = 0;\\n  let tot = 0;\\n\\n  for(let i = 0; i <= 120; i++){\\n      if(i > 14 && count[i] !== 0){\\n          let limit = Math.floor(0.5 * i) + 7;\\n          let rest = tot - count[limit];\\n          res += (count[i] * rest);\\n          res += (count[i] * (count[i] - 1));\\n      }\\n      tot += count[i];\\n      count[i] = tot;\\n  }    \\n  return res;\\n};", "var numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    ages.forEach((age) => count[age]++);\\n    let res = 0; \\n    let tot = 0; \\n    for (let i = 0; i <= 120; i++) {\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n            res += (count[i] * rest);\\n            res += (count[i] * (count[i] - 1));\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};", "var numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    ages.forEach((age) => count[age]++);\\n    let res = 0; \\n    let tot = 0; \\n    for (let i = 0; i <= 120; i++) {\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n            res += (count[i] * rest);\\n            res += (count[i] * (count[i] - 1));\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};"]}
{"id": "974", "ref_js": ["var maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};", "var maxProfitAssignment = function (difficulties, profits, max_difficulties) {\\n  let map = new Map();\\n  difficulties.forEach((diff, i) => {\\n    if (!map.has(diff)) {\\n      map.set(diff, profits[i]);\\n    } else {\\n      map.set(diff, Math.max(map.get(diff), profits[i]));\\n    }\\n  });\\n  let diffs_profits = [...map];\\n\\n  diffs_profits.sort((a, b) => a[0] - b[0]);\\n\\n  let max_profit_till_now = 0;\\n  diffs_profits.forEach(([, p], i) => {\\n    max_profit_till_now = Math.max(max_profit_till_now, p);\\n    diffs_profits[i][1] = max_profit_till_now;\\n  });\\n\\n  let sum = 0;\\n  for (let max_diff of max_difficulties) {\\n    let low = 0;\\n    let high = diffs_profits.length - 1;\\n    while (low < high) {\\n      let mid = Math.trunc(low / 2 + high / 2);\\n      if (diffs_profits[mid][0] > max_diff) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    if (diffs_profits[low][0] > max_diff) {\\n      low--;\\n    }\\n    if (low !== -1) {\\n      sum += diffs_profits[low][1];\\n    }\\n  }\\n  return sum;\\n};", "var maxProfitAssignment = function(difficulty, profit, worker) {\\n  let res = 0;\\n  for(let i = 0; i < worker.length; i++){\\n      let max = 0;\\n      for(let j = 0; j < difficulty.length; j++){\\n          if(worker[i] >= difficulty[j]){\\n              max = Math.max(max, profit[j]);\\n          }\\n      }\\n      res += max;\\n  }    \\n  return res;\\n};"]}
{"id": "975", "ref_js": ["var maskPII = function(s) {\\n   return (s.includes(\\'@\\') ? mask_email(s) : mask_phone(s)); \\n};", "var maskPII = function (s) {\\n  ", "var maskPII = function (s) {\\n  "]}
{"id": "976", "ref_js": ["var findReplaceString = function(s, indices, sources, targets) {\\n    \\n    let res = s.split(\"\");\\n    \\n    for(let i=0; i<indices.length; i++){\\n        \\n        \\n        const dx = s.substring(indices[i], indices[i] + sources[i].length);\\n        \\n        \\n        if(dx === sources[i]){\\n            \\n            \\n            res[indices[i]] = targets[i];\\n            \\n            let j = 1;\\n            \\n            while(j < dx.length)\\n                res[indices[i] + (j++)] = \"\";\\n                \\n        }\\n    }\\n    \\n    return res.join(\"\");\\n};", "var findReplaceString = function(S, indexes, sources, targets) {\\n    const n = indexes.length;\\n    const chars = S.split(\"\");\\n   \\n    for (let i = 0; i < n; i++) {\\n        const [index, source, target] = [indexes[i], sources[i], targets[i]];\\n        \\n        if (S.substring(index).startsWith(source)) {\\n            replaceChars(chars, index, source, target);\\n        }\\n    }\\n    \\n    return chars.join(\"\");\\n    \\n    \\n    function replaceChars(chars, start, source, target) {\\n        chars[start] = target;\\n        \\n        for (let i = 1; i < source.length; i++) {\\n            chars[start + i] = \"\";\\n        }\\n    }\\n};", "var findReplaceString = function(S, indexes, sources, targets) {\\n  var result = S.split(\\'\\');\\n  indexes.forEach((indexInS, i) => {\\n    var sourceChars = sources[i];\\n    var targetChars = targets[i];\\n    \\n    if (S.slice(indexInS, indexInS + sourceChars.length) === sourceChars) {\\n      result[indexInS] = [targetChars];\\n      var elementsToReplace = sourceChars.length - 1;\\n      while (elementsToReplace > 0) {\\n        indexInS += 1;\\n        result[indexInS] = \\'\\';\\n        elementsToReplace -= 1;\\n      }\\n    }\\n  });\\n  return result.join(\\'\\');\\n};"]}
{"id": "977", "ref_js": ["var largestOverlap = function(img1, img2) {\\n    const setImg1 = new Set();\\n    const setImg2 = new Set();\\n    for (let i = 0; i < img1.length; i++) {\\n        for (let j = 0; j < img1.length; j++) {\\n            if (img1[i][j]) setImg1.add(`${i}_${j}`);\\n            if (img2[i][j]) setImg2.add(`${i}_${j}`);\\n        }\\n    }\\n    let output = 0;\\n    \\n    for (let i = -(img1.length - 1); i < img1.length; i++) {\\n        for (let j = -(img1.length - 1); j < img1.length; j++) {\\n            let count = 0;\\n            setImg1.forEach(key => {\\n                const [x, y] = key.split(\\'_\\');\\n                if (setImg2.has(`${Number(x) + i}_${Number(y) + j}`)) count++;\\n            })\\n            output = Math.max(output, count);\\n        }\\n    }\\n    \\n    return output;\\n};", "var largestOverlap = function(img1, img2) {\\n  \\n  const n = img1.length;\\n  \\n  let max = 0;\\n  \\n  for (let xOffset = -n; xOffset < n; xOffset += 1) {\\n    for (let yOffset = -n; yOffset < n; yOffset += 1) {\\n      \\n      let count = 0;\\n      for (let i = 0; i < n; i += 1) {\\n        for (let j = 0; j < n; j += 1) {\\n          if (i + xOffset < 0 || i + xOffset >= n || j + yOffset < 0 || j + yOffset >= n) continue;\\n          if (img1[i + xOffset][j + yOffset] === 1 && img2[i][j] === 1) count += 1;\\n        }\\n      }\\n      \\n      max = Math.max(max, count);\\n    }\\n  }\\n  \\n  return max;\\n};", "var largestOverlap = function(img1, img2) {\\n  \\n  const n = img1.length;\\n  \\n  let max = 0;\\n  \\n  for (let xOffset = -n; xOffset < n; xOffset += 1) {\\n    for (let yOffset = -n; yOffset < n; yOffset += 1) {\\n      \\n      let count = 0;\\n      for (let i = 0; i < n; i += 1) {\\n        for (let j = 0; j < n; j += 1) {\\n          if (i + xOffset < 0 || i + xOffset >= n || j + yOffset < 0 || j + yOffset >= n) continue;\\n          if (img1[i + xOffset][j + yOffset] === 1 && img2[i][j] === 1) count += 1;\\n        }\\n      }\\n      \\n      max = Math.max(max, count);\\n    }\\n  }\\n  \\n  return max;\\n};"]}
{"id": "978", "ref_js": ["var new21Game = function(n, k, maxPts) {\\n    if (k == 0 || n >= k + maxPts) return 1.0;\\n    let sum = 1.0;\\n    let result = 0.0;\\n    let dp = new Array(n + 1);\\n    dp[0] = 1.0;\\n    for (let i = 1; i <= n; i++) {\\n        dp[i] = sum / maxPts;\\n        if (i < k) sum += dp[i];\\n        else result += dp[i];\\n        if (i - maxPts >= 0) sum -= dp[i - maxPts];\\n    }\\n    return result;\\n};", "var new21Game = function(n, k, maxPts) {\\n    if(k === 0 || n >= k + maxPts) return 1.0;\\n    let dp = [n + 1];\\n    dp[0] = 1.0;\\n\\n    let sum = 1.0, res = 0.0;\\n    for(let i = 1; i <= n; ++i){\\n        dp[i] = sum / maxPts;\\n        if(i < k) sum += dp[i];\\n        else res += dp[i];\\n        if(i >= maxPts) sum -= dp[i - maxPts];\\n    }\\n    return res;\\n};", "var new21Game = function(n, k, maxPts) {\\n    if (k == 0 || n >= k + maxPts) return 1.0;\\n    let sum = 1.0;\\n    let result = 0.0;\\n    let dp = new Array(n + 1);\\n    dp[0] = 1.0;\\n    for (let i = 1; i <= n; i++) {\\n        dp[i] = sum / maxPts;\\n        if (i < k) sum += dp[i];\\n        else result += dp[i];\\n        if (i - maxPts >= 0) sum -= dp[i - maxPts];\\n    }\\n    return result;\\n};"]}
{"id": "979", "ref_js": ["var pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};", "var pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};", "var pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};"]}
{"id": "980", "ref_js": ["var numMagicSquaresInside = function(grid) {\\n  let magicSquares = new Set([\\n      \\'276951438\\',\\n      \\'294753618\\',\\n      \\'438951276\\',\\n      \\'492357816\\',\\n      \\'618753294\\',\\n      \\'672159834\\',\\n      \\'816357492\\',\\n      \\'834159672\\',\\n  ]);\\n  let count = 0;\\n  for(let i = 0; i < grid.length - 2; i++)\\n  for(let j = 0; j < grid[0].length - 2; j++)\\n  if(\\n      magicSquares.has(\\n          grid[i][j].toString() +\\n          grid[i][j + 1] +\\n          grid[i][j + 2] +\\n          grid[i + 1][j] +\\n          grid[i + 1][j + 1] +\\n          grid[i + 1][j + 2] +\\n          grid[i + 2][j] +\\n          grid[i + 2][j + 1] +\\n          grid[i + 2][j + 2],\\n      )\\n  )    \\n  count++;\\n  return count;\\n};", "var numMagicSquaresInside = function(grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    \\n    let count = 0;\\n\\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n\\n            ", "var numMagicSquaresInside = function(grid) {\\n  let magicSquares = new Set([\\n      \\'276951438\\',\\n      \\'294753618\\',\\n      \\'438951276\\',\\n      \\'492357816\\',\\n      \\'618753294\\',\\n      \\'672159834\\',\\n      \\'816357492\\',\\n      \\'834159672\\',\\n  ]);\\n  let count = 0;\\n  for(let i = 0; i < grid.length - 2; i++)\\n  for(let j = 0; j < grid[0].length - 2; j++)\\n  if(\\n      magicSquares.has(\\n          grid[i][j].toString() +\\n          grid[i][j + 1] +\\n          grid[i][j + 2] +\\n          grid[i + 1][j] +\\n          grid[i + 1][j + 1] +\\n          grid[i + 1][j + 2] +\\n          grid[i + 2][j] +\\n          grid[i + 2][j + 1] +\\n          grid[i + 2][j + 2],\\n      )\\n  )    \\n  count++;\\n  return count;\\n};"]}
{"id": "981", "ref_js": ["var canVisitAllRooms = function(rooms) {\\n    let visited = new Set();\\n    ", "var canVisitAllRooms = function(rooms) {\\n    const keys = rooms[0]; ", "var canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};"]}
{"id": "982", "ref_js": ["var splitIntoFibonacci = function(num) {\\n   let bit32 = 2 ** 31 - 1;\\n\\n   for(let i = 1; i < num.length; i++){\\n       let num1 = num.slice(0, i);\\n       if(+num1 > bit32) break;\\n\\n       for(let j = i + 1; j < num.length; j++){\\n           let num2 = num.slice(i, j);\\n           if(+num2 > bit32) break;\\n\\n           let res = num.slice(j);\\n           let result = isValid(num1, num2, res, [num1, num2]);\\n\\n           if(result) return result;\\n           if(num[i] === \\'0\\') break;\\n       }\\n       if(num[0] === \\'0\\') break;\\n   }   \\n   function isValid(num1, num2, res, ans){\\n       let sum = (+num1 + +num2).toString();\\n       if(+sum > bit32) return false;\\n       ans.push(sum);\\n       if(res === sum) return ans;\\n       if(res.startsWith(sum)) return isValid(num2, sum, res.slice(sum.length), ans);\\n       return false;\\n   }\\n   return [];\\n};", "var splitIntoFibonacci = function(num) {\\n    const bound = 2**31;\\n    const dp = Array.from(num, () => []);\\n    dp[0].push([Number(num[0])]);\\n    for(let i = 1; i < num.length; i++) {        \\n        for(let j = i - 1; j >= 0; j--) {\\n            if (j < i - 1 && num[j+1] == \"0\") {\\n                continue;\\n            }\\n            const n = Number(num.slice(j+1, i+1));\\n            if (n > bound) break;\\n            for(let k = 0; k < dp[j].length; k++) {\\n                const arr = [...dp[j][k]];\\n                const len = arr.length;               \\n                if (arr.length == 1) {\\n                    arr.push(n);                    \\n                } else {\\n                    if (arr[arr.length - 1] <= n) {\\n                        if (n == arr[arr.length - 1] + arr[arr.length - 2]) {\\n                            arr.push(n);\\n                        }\\n                    } else {\\n                        const a = dp[j].length;\\n                        if (dp[j][a - 1].length  == 1) {\\n                            const arr = [...dp[j][a-1], n];\\n                            dp[i].push(arr);\\n                        }\\n                        break;\\n                    }\\n                }\\n                if(arr.length > len) dp[i].push(arr);                \\n            }\\n        }\\n        if (num[0] != \"0\") {\\n            const m = Number(num.slice(0, i+1));\\n            dp[i].push([m]);\\n        }\\n    }\\n    for(let arr of dp[num.length - 1]) {        \\n        if (arr.length >= 3)\\n            return arr;        \\n    }\\n    return [];\\n};", "var splitIntoFibonacci = function(num) {\\n    const numLen=Math.trunc(num.length/3+1),"]}
{"id": "983", "ref_js": ["var longestMountain = function(arr) {\\n   let n = arr.length;\\n   let i = 0, j = 0, inc = 0, dec = 0, max = 0;\\n   while(i < n && j + 1 < n){\\n       if(arr[j] < arr[j + 1]){\\n           while(j + 1 < n && arr[j] < arr[j + 1]){\\n               j++;\\n               inc++;\\n           }\\n           while(j + 1 < n && arr[j] > arr[j + 1]){\\n               j++;\\n               dec++;\\n           }\\n           if(dec){\\n               max = Math.max(max, inc + dec + 1);\\n           }\\n           i = j;\\n           inc = 0;\\n           dec = 0;\\n       } else {\\n           i++;\\n           j++;\\n       }\\n   } \\n   return max;\\n};", "var longestMountain = function(arr) {\\n    const n = arr.length;\\n    let i = 0, j = 0, inc = 0, dec = 0, max = 0;\\n    while(i < n && j+1 < n){\\n        if(arr[j] < arr[j+1]) {\\n            while(j+1 < n && arr[j] < arr[j+1]) { j++; inc++; }\\n            while(j+1 < n && arr[j] > arr[j+1]) { j++; dec++; } \\n            if(dec) {\\n                max = Math.max(max, inc+dec+1);\\n            }\\n            i = j;\\n            inc = 0;\\n            dec = 0;\\n        } else { i++, j++; }       \\n    } \\n    return max;    \\n};", "var longestMountain = function(arr) {\\n    let maxCounter = 0;\\n\\n  for (let indexI = 1; indexI < arr.length - 1; ) {\\n    "]}
{"id": "984", "ref_js": ["var isNStraightHand = function (hand, size) {\\n  if (hand.length % size !== 0) return false;\\n  let cnt = {};", "var isNStraightHand = function(hand, groupSize) {\\n\\t\\tif (hand.length % groupSize) return false;\\n\\t\\thand.sort((a, b) => a - b);\\n\\t\\tconst handMap = hand.reduce((map, num) => {\\n\\t\\t\\tconst count = map.get(num) ?? 0;\\n\\t\\t\\treturn map.set(num, count + 1);\\n\\t\\t}, new Map());\\n\\n\\t\\tfor (const [target, count] of handMap) {\\n\\t\\t\\tif (count === 0) continue;\\n\\n\\t\\t\\tfor (let num = target; num < target + groupSize; num++) {\\n\\t\\t\\t\\tconst hash = handMap.get(num) ?? 0;\\n\\t\\t\\t\\tif (hash < count) return false;\\n\\t\\t\\t\\thandMap.set(num, hash - count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t};", "var isNStraightHand = function (hand, size) {\\n  if (hand.length % size !== 0) return false;\\n  let cnt = {};"]}
{"id": "985", "ref_js": ["var shiftingLetters = function (s, shifts, res = \"\") {\\n  for (let i = shifts.length - 2; i >= 0; i--) {\\n      shifts[i] += shifts[i + 1];}\\n  for (let i = 0; i < s.length; i++) {\\n    res += String.fromCharCode((s[i].charCodeAt(0) - 97 + shifts[i]) % 26+97);}\\n  return res;\\n};", "var shiftingLetters = function(s, shifts) {\\n    const letters = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'];\\n\\tconst lettersCache = {\\n\\t\\t\\'a\\': 1,\\n\\t\\t\\'b\\': 2,\\n\\t\\t\\'c\\': 3,\\n\\t\\t\\'d\\': 4,\\n\\t\\t\\'e\\': 5,\\n\\t\\t\\'f\\': 6,\\n\\t\\t\\'g\\': 7,\\n\\t\\t\\'h\\': 8,\\n\\t\\t\\'i\\': 9,\\n\\t\\t\\'j\\': 10,\\n\\t\\t\\'k\\': 11,\\n\\t\\t\\'l\\': 12,\\n\\t\\t\\'m\\': 13,\\n\\t\\t\\'n\\': 14,\\n\\t\\t\\'o\\': 15,\\n\\t\\t\\'p\\': 16,\\n\\t\\t\\'q\\': 17,\\n\\t\\t\\'r\\': 18,\\n\\t\\t\\'s\\': 19,\\n\\t\\t\\'t\\': 20,\\n\\t\\t\\'u\\': 21,\\n\\t\\t\\'v\\': 22,\\n\\t\\t\\'w\\': 23,\\n\\t\\t\\'x\\': 24,\\n\\t\\t\\'y\\': 25,\\n\\t\\t\\'z\\': 26\\n\\t};", "var shiftingLetters = function(s, shifts) {\\n    const letters = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'];\\n\\tconst lettersCache = {\\n\\t\\t\\'a\\': 1,\\n\\t\\t\\'b\\': 2,\\n\\t\\t\\'c\\': 3,\\n\\t\\t\\'d\\': 4,\\n\\t\\t\\'e\\': 5,\\n\\t\\t\\'f\\': 6,\\n\\t\\t\\'g\\': 7,\\n\\t\\t\\'h\\': 8,\\n\\t\\t\\'i\\': 9,\\n\\t\\t\\'j\\': 10,\\n\\t\\t\\'k\\': 11,\\n\\t\\t\\'l\\': 12,\\n\\t\\t\\'m\\': 13,\\n\\t\\t\\'n\\': 14,\\n\\t\\t\\'o\\': 15,\\n\\t\\t\\'p\\': 16,\\n\\t\\t\\'q\\': 17,\\n\\t\\t\\'r\\': 18,\\n\\t\\t\\'s\\': 19,\\n\\t\\t\\'t\\': 20,\\n\\t\\t\\'u\\': 21,\\n\\t\\t\\'v\\': 22,\\n\\t\\t\\'w\\': 23,\\n\\t\\t\\'x\\': 24,\\n\\t\\t\\'y\\': 25,\\n\\t\\t\\'z\\': 26\\n\\t};"]}
{"id": "986", "ref_js": ["var maxDistToClosest = function(seats) {\\n  const zeros = seats.join(\\'\\').split(\\'1\\');\\n  return Math.max(\\n    zeros.shift().length,\\n    zeros.pop().length,\\n    ...zeros.map(i => i.length > 0 ? Math.floor((i.length + 1) / 2) : 0)\\n  );\\n};", "var maxDistToClosest = function(seats) {\\n   let zeros = seats.join(\\'\\').split(\\'1\\');\\n   return Math.max(\\n   zeros.shift().length,\\n   zeros.pop().length,\\n   ...zeros.map(i => i.length > 0 ? Math.floor((i.length + 1) / 2) : 0)\\n   )   \\n};", "var maxDistToClosest = function(seats) {\\n  const zeros = seats.join(\\'\\').split(\\'1\\');\\n  return Math.max(\\n    zeros.shift().length,\\n    zeros.pop().length,\\n    ...zeros.map(i => i.length > 0 ? Math.floor((i.length + 1) / 2) : 0)\\n  );\\n};"]}
{"id": "987", "ref_js": ["var loudAndRich = function(richer, quiet) {\\n   let list = [];\\n   let output = [];\\n   let memo = {};", "var loudAndRich = function(richer, quiet) {\\n  const list = [];\\n  const output = [];\\n  const memo = {};", "var loudAndRich = function(richer, quiet) {\\n  const list = [];\\n  const output = [];\\n  const memo = {};"]}
{"id": "988", "ref_js": ["var peakIndexInMountainArray = function(arr) {\\n  return arr.indexOf(Math.max(...arr)); \\n};", "var peakIndexInMountainArray = function(arr) {\\n   let l =0;\\n   let r = arr.length-1;\\n   \\n    while (l<r)\\n    {\\n        const mid= Math.floor((l+r)/2);\\n        if (arr[mid]<arr[mid+1])\\n        {\\n            l = mid+1;\\n        }\\n        else{\\n            r=mid;\\n        }\\n    }\\n    return l;\\n};", "var peakIndexInMountainArray = function(arr) {\\n   let l =0;\\n   let r = arr.length-1;\\n   \\n    while (l<r)\\n    {\\n        const mid= Math.floor((l+r)/2);\\n        if (arr[mid]<arr[mid+1])\\n        {\\n            l = mid+1;\\n        }\\n        else{\\n            r=mid;\\n        }\\n    }\\n    return l;\\n};"]}
{"id": "989", "ref_js": ["var carFleet = function(target, position, speed) {\\n    ", "var carFleet = function(target, position, speed) {\\n    const n = speed.length;\\n    const v = [];\\n    for (let i = 0; i < n; i++) {\\n        v.push([position[i], speed[i]]);\\n    }\\n    v.sort((a, b) => a[0] - b[0]);\\n    const time = [];\\n    for (let i = 0; i < n; i++) {\\n        time.push((target - v[i][0]) / v[i][1]);\\n    }\\n\\n    let curr = Number.NEGATIVE_INFINITY;\\n    let res = 0;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n        if (time[i] > curr) {\\n            curr = time[i];\\n            res++;\\n        }\\n    }\\n\\n    return res;\\n};", "var carFleet = function(target, position, speed) {\\n  const n = position.length;\\n  const inds = [];\\n  for (let i = 0; i < n; i++) inds.push(i); \\n\\n  inds.sort((a,b) => position[b] - position[a]);\\n\\n  let cur = inds[0];\\n  let result = 1;\\n\\n  for (let i = 1; i < n; i++) {\\n    let idx = inds[i];\\n    if ((target - position[idx]) * speed[cur] > (target - position[cur]) * speed[idx]) {\\n      result++;\\n      cur = idx;\\n    }\\n  }\\n\\n  return result;\\n};"]}
{"id": "991", "ref_js": ["var scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};", "var scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};", "var scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};"]}
{"id": "992", "ref_js": ["var mirrorReflection = function(p, q) {\\n    while(p%2==0 && q%2==0){\\n            p/=2;\\n            q/=2;\\n        }\\n\\n        return p%2==0 ? 2 : (q%2==0?0:1); \\n};", "var mirrorReflection = function(p, q) {\\n\\tlet ext = q, ref = p;\\n\\t\\n\\twhile (ext % 2 == 0 && ref % 2 == 0) {\\n\\t\\text /= 2;\\n\\t\\tref /= 2;\\n\\t}\\n\\t\\n\\tif (ext % 2 == 0 && ref % 2 == 1) return 0;\\n\\tif (ext % 2 == 1 && ref % 2 == 1) return 1;\\n\\tif (ext % 2 == 1 && ref % 2 == 0) return 2;\\n\\t\\n\\treturn -1;\\n};", "var mirrorReflection = function(p, q) {\\n\\tlet ext = q, ref = p;\\n\\t\\n\\twhile (ext % 2 == 0 && ref % 2 == 0) {\\n\\t\\text /= 2;\\n\\t\\tref /= 2;\\n\\t}\\n\\t\\n\\tif (ext % 2 == 0 && ref % 2 == 1) return 0;\\n\\tif (ext % 2 == 1 && ref % 2 == 1) return 1;\\n\\tif (ext % 2 == 1 && ref % 2 == 0) return 2;\\n\\t\\n\\treturn -1;\\n};"]}
{"id": "993", "ref_js": ["var matrixScore = function(grid) {\\n   let m = grid.length;\\n   let n = grid[0].length;\\n   let res = Math.pow(2, n - 1) * m;\\n\\n   for(let j = 1; j < n; j++){\\n       let curr = 0;\\n\\n    for(let i = 0; i < m; i++){\\n        curr += grid[i][0] === grid[i][j] ? 1 : 0;\\n    }\\n    res += Math.max(curr, m - curr) * Math.pow(2, n - 1 - j);\\n   } \\n   return res;\\n};", "var matrixScore = function(grid) {\\n    let ans=0;\\n    \\n    for(let i=0;i<grid.length;i++){\\n        if(grid[i][0]==0){\\n            for(let j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==0){\\n                    grid[i][j]=1;\\n                }else{\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n\\n    for(let i=0;i<grid[0].length;i++){\\n        let count=0;\\n        for(let j=0;j<grid.length;j++){ \\n            count+=grid[j][i];\\n        }\\n        if(count<grid.length-count){\\n            for(let j=0;j<grid.length;j++){\\n                if(grid[j][i]==0){\\n                    grid[j][i]=1;\\n                }else{\\n                    grid[j][i]=0;\\n                }\\n            }\\n        }\\n        count=0;\\n         for(let j=0;j<grid.length;j++){\\n              count+=grid[j][i];\\n            }\\n        ans+=count*(2**(grid[0].length-i-1));\\n    }\\n     return ans;\\n};", "var matrixScore = function(grid) {\\n    let m = grid.length\\n    let n = grid[0].length\\n    let visited = {}\\n    let start = grid.flat().join(\\'\\')\\n    let queue = [start]\\n    let max = -Infinity\\n\\n    while(queue.length) {\\n        let cur = queue.shift()\\n\\n        if(visited[cur]) continue\\n        visited[cur] = true\\n\\n        let mat = getMat(cur, m, n)\\n        max = Math.max(max, getScore(mat))\\n\\n        for(let i = 0; i < m; i++) {\\n            let newMat = toggleRow(mat, i).flat().join(\\'\\')\\n            queue.push(newMat)\\n        }\\n\\n        for(let j = 0; j < n; j++) {\\n            let newMat = toggleCol(mat, j).flat().join(\\'\\')\\n            queue.push(newMat)\\n        }\\n    }\\n\\n    return max\\n};"]}
{"id": "994", "ref_js": ["var distanceK = function(root, target, k) {\\n    let adjList = {}, visited = {}, result = [];\\n\\n    const buildAdjList = function(node) {\\n        if(!node) return null;\\n\\n        if(!adjList[node.val]) adjList[node.val] = [];\\n        \\n        if(node.left) {\\n            if(!adjList[node.left.val]) adjList[node.left.val] = [];\\n\\n            adjList[node.val].push(node.left.val);\\n            adjList[node.left.val].push(node.val);\\n        }\\n        if(node.right) {\\n            if(!adjList[node.right.val]) adjList[node.right.val] = [];\\n\\n            adjList[node.val].push(node.right.val);\\n            adjList[node.right.val].push(node.val);\\n        }\\n\\n        buildAdjList(node.left);\\n        buildAdjList(node.right);\\n    }\\n\\n    buildAdjList(root);\\n    \\n\\n    const dfs = function(source, dist = 0) {\\n        visited[source] = true;\\n        if(k == dist) result.push(source);\\n\\n        for(const dest of adjList[source] || []) {\\n            if(!visited[dest]) {\\n                dfs(dest, dist + 1);\\n            }            \\n        }\\n    }\\n\\n    dfs(target.val)\\n\\n    return result;\\n};", "var distanceK = function (root, target, k) {\\n    if (!root) return null;\\n    if (k === 0) return [target.val]\\n    ", "var distanceK = function(root, target, k) {\\n    let adjList = {}, visited = {}, result = [];\\n\\n    const buildAdjList = function(node) {\\n        if(!node) return null;\\n\\n        if(!adjList[node.val]) adjList[node.val] = [];\\n        \\n        if(node.left) {\\n            if(!adjList[node.left.val]) adjList[node.left.val] = [];\\n\\n            adjList[node.val].push(node.left.val);\\n            adjList[node.left.val].push(node.val);\\n        }\\n        if(node.right) {\\n            if(!adjList[node.right.val]) adjList[node.right.val] = [];\\n\\n            adjList[node.val].push(node.right.val);\\n            adjList[node.right.val].push(node.val);\\n        }\\n\\n        buildAdjList(node.left);\\n        buildAdjList(node.right);\\n    }\\n\\n    buildAdjList(root);\\n    \\n\\n    const dfs = function(source, dist = 0) {\\n        visited[source] = true;\\n        if(k == dist) result.push(source);\\n\\n        for(const dest of adjList[source] || []) {\\n            if(!visited[dest]) {\\n                dfs(dest, dist + 1);\\n            }            \\n        }\\n    }\\n\\n    dfs(target.val)\\n\\n    return result;\\n};"]}
{"id": "995", "ref_js": ["var subtreeWithAllDeepest = function(root) {\\n    let height = 0;\\n    let maxNode = null;\\n    \\n    dfs(root, 0);\\n    \\n    return maxNode;\\n    \\n    function dfs(node, currDepth) {\\n        if (node == null) return currDepth - 1;\\n        \\n        height = Math.max(height, currDepth);\\n        \\n        const leftDepth = dfs(node.left, currDepth + 1);\\n        const rightDepth = dfs(node.right, currDepth + 1);\\n        \\n        if (leftDepth == height && rightDepth == height) {\\n            maxNode = node;\\n        }\\n        \\n        return Math.max(leftDepth, rightDepth);\\n    }\\n};", "var subtreeWithAllDeepest = function(root) {\\n    let result = []\\n    const dfs = (node, level)=>{\\n        if(!node)\\n            return;\\n        result[level] ??= []\\n        result[level].push(node)\\n        dfs(node.left, level + 1)\\n        dfs(node.right, level + 1)\\n    }\\n    dfs(root, 0)\\n\\n    let stack = result[result.length - 1]\\n\\n    const findLCA = (node, p, q)=>{\\n        if(!node || p.val === node.val || q.val === node.val){\\n            return node\\n        }\\n        const left = findLCA(node.left, p, q)\\n        const right = findLCA(node.right, p, q)\\n        if(left && right)\\n            return node\\n        if(left) return left\\n        if(right) return right\\n    }\\n\\n    while(stack.length > 1){\\n        const node = findLCA(root, stack.pop(), stack.pop())\\n        stack.push(node)\\n    }\\n    return stack[0]\\n\\n};", "var subtreeWithAllDeepest = function(root) {\\n    function traverse(node){\\n        if(node === null) return [null, 0];\\n\\n        let [leftNode, leftHeight] = traverse(node.left);\\n        let [rightNode, rightHeight] = traverse(node.right);\\n\\n        if(leftHeight > rightHeight){\\n            return [leftNode, 1 + leftHeight];\\n        }\\n        else if(leftHeight < rightHeight){\\n            return [rightNode, 1 + rightHeight];\\n        }\\n        else {\\n            return [node, leftHeight + 1];\\n        }\\n    }   \\n    return traverse(root)[0];\\n};"]}
{"id": "996", "ref_js": ["var findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  ", "var findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  ", "var findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  "]}
{"id": "997", "ref_js": ["var reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};", "var reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};", "var reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};"]}
{"id": "998", "ref_js": ["var advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};", "var advantageCount = function(A, B) {\\n    let sortedA = A.sort((a, b) => a - b);\\n    for(let i = 0, j = B.length; i < j; i++){\\n        if(B[i] < A[A.length - 1]){\\n            let ii = 0;\\n            while(B[i] >= A[ii]) ii++;\\n            B[i] = A.splice(ii, 1);\\n        } else {\\n            B[i] = A.shift();\\n        }\\n    }\\n    return B;\\n};", "var advantageCount = function(nums1, nums2) {\\n    nums1.sort((a,b)=>a-b);\\n    const result=[];\\n    const bsearch=(target)=>{\\n        let l=0,r=nums1.length-1,lastFound=-1;\\n        while(l<=r){\\n            const mid=Math.trunc((l+r)/2);\\n            if(nums1[mid]>target){\\n                "]}
{"id": "999", "ref_js": ["var lenLongestFibSubseq = function(arr) {\\n  let map = new Map();\\n  \\n  for(let a of arr){\\n      map.set(a, true);\\n  }  \\n\\n  arr.sort((a, b) => a - b);\\n\\n  let len = 0;\\n  for(let i = 0; i < arr.length; i++){\\n      for(let j = i + 1; j < arr.length; j++){\\n          let left = arr[i];\\n          let right = arr[j];\\n          let tempLen = 0;\\n          while(map.has(left + right)){\\n              tempLen++;\\n              let temp = left + right;\\n              left = right;\\n              right = temp;\\n          }\\n          len = Math.max(len, tempLen + 2);\\n      }\\n  }\\n  return len > 2 ? len : 0;\\n};", "var lenLongestFibSubseq = function(arr) {\\n    let n=arr.length;\\n    let dp=new Array(n),m=new Map(),ans=2;\\n    for(let i=0;i<n;i++)\\n    {\\n        dp[i]=new Array(n);\\n        for(let j=i+1;j<n;j++)\\n        {\\n                dp[i][j]=2;\\n        }\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        m.set(arr[i],i);\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        for(let j=i+1;j<n;j++)\\n        {\\n                if(m.has(arr[i]+arr[j]))\\n                {\\n                    dp[j][m.get(arr[i]+arr[j])]=dp[i][j]+1;\\n                }\\n                ans=Math.max(dp[i][j],ans);\\n        }\\n    }\\n    if(ans<=2)\\n    {\\n        return 0;\\n    }\\n    return ans;\\n};", "var lenLongestFibSubseq = function(arr) {\\n    let n=arr.length;\\n    let dp=new Array(n),m=new Map(),ans=2;\\n    for(let i=0;i<n;i++)\\n    {\\n        dp[i]=new Array(n);\\n        for(let j=i+1;j<n;j++)\\n        {\\n                dp[i][j]=2;\\n        }\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        m.set(arr[i],i);\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        for(let j=i+1;j<n;j++)\\n        {\\n                if(m.has(arr[i]+arr[j]))\\n                {\\n                    dp[j][m.get(arr[i]+arr[j])]=dp[i][j]+1;\\n                }\\n                ans=Math.max(dp[i][j],ans);\\n        }\\n    }\\n    if(ans<=2)\\n    {\\n        return 0;\\n    }\\n    return ans;\\n};"]}
{"id": "1000", "ref_js": ["var robotSim = function(commands, obstacles) {\\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    let max = 0;\\n    let set = new Set();\\n    for(let [a, b] of obstacles){\\n        set.add(`${a} - ${b}`);\\n    }\\n    let dirs = {\\n        \\'1\\': () => {\\n            if(!set.has(`${i} - ${j + 1}`)){\\n                j++;\\n                total++;\\n            }\\n        },\\n        \\'2\\': () => {\\n            if(!set.has(`${i + 1} - ${j}`)){\\n                i++;\\n                total++;\\n            }\\n        },\\n        \\'3\\': () => {\\n            if(!set.has(`${i} - ${j - 1}`)){\\n                j--;\\n                total++;\\n            }\\n        },\\n        \\'4\\': () => {\\n            if(!set.has(`${i - 1} - ${j}`)){\\n                i--;\\n                total++;\\n            }\\n        },\\n    }\\n    let dir = \\'1\\';\\n    for(c of commands){\\n        if(c === -1){\\n            dir = +dir;\\n            dir++;\\n            if(dir === 5) dir = 1;\\n            dir = dir.toString();\\n        } else if(c === -2){\\n            dir = +dir;\\n            dir--;\\n            if(dir === 0) dir = 4;\\n            dir = dir.toString();\\n        } else {\\n            while(c--){\\n                dirs[dir]();\\n                max = Math.max(max, Math.pow(i, 2) + Math.pow(j, 2));\\n            }\\n        }\\n    }\\n    return max;\\n};", "var robotSim = function(commands, obstacles) {\\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    let max = 0;\\n    const set = new Set();\\n    for (let [a, b] of obstacles) {\\n        set.add(`${a}-${b}`);\\n    }\\n    const dirs = {\\n        \\'1\\': () => { ", "var robotSim = function(commands, obstacles) {\\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    let max = 0;\\n    let set = new Set();\\n    for(let [a, b] of obstacles){\\n        set.add(`${a} - ${b}`);\\n    }\\n    let dirs = {\\n        \\'1\\': () => {\\n            if(!set.has(`${i} - ${j + 1}`)){\\n                j++;\\n                total++;\\n            }\\n        },\\n        \\'2\\': () => {\\n            if(!set.has(`${i + 1} - ${j}`)){\\n                i++;\\n                total++;\\n            }\\n        },\\n        \\'3\\': () => {\\n            if(!set.has(`${i} - ${j - 1}`)){\\n                j--;\\n                total++;\\n            }\\n        },\\n        \\'4\\': () => {\\n            if(!set.has(`${i - 1} - ${j}`)){\\n                i--;\\n                total++;\\n            }\\n        },\\n    }\\n    let dir = \\'1\\';\\n    for(c of commands){\\n        if(c === -1){\\n            dir = +dir;\\n            dir++;\\n            if(dir === 5) dir = 1;\\n            dir = dir.toString();\\n        } else if(c === -2){\\n            dir = +dir;\\n            dir--;\\n            if(dir === 0) dir = 4;\\n            dir = dir.toString();\\n        } else {\\n            while(c--){\\n                dirs[dir]();\\n                max = Math.max(max, Math.pow(i, 2) + Math.pow(j, 2));\\n            }\\n        }\\n    }\\n    return max;\\n};"]}
{"id": "1001", "ref_js": ["var minEatingSpeed = function(piles, h) {\\n    let lo = 1, hi = Math.max(...piles), k = -1;\\n    \\n    while (lo <= hi) {\\n        const mid = lo + ((hi - lo) >> 1);\\n        const numOfHours = piles.reduce((total, pile) => total + Math.ceil(pile / mid), 0);\\n        \\n        if (numOfHours <= h) {\\n            k = mid;\\n            hi = mid - 1;\\n        }\\n        else {\\n            lo = mid + 1;\\n        }\\n    }\\n    \\n    return k;\\n};", "var minEatingSpeed = function (piles, h) {\\n    let left = 1, right = Math.max(...piles);\\n    while (left <= right) {\\n        const mid = Math.floor(left + (right - left) / 2);\\n        if (canEatAll(piles, mid, h)) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};", "var minEatingSpeed = function (piles, h) {\\n    let left = 1, right = Math.max(...piles);\\n    while (left <= right) {\\n        const mid = Math.floor(left + (right - left) / 2);\\n        if (canEatAll(piles, mid, h)) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};"]}
{"id": "1002", "ref_js": ["var stoneGame = function(piles) {\\n    return true; ", "var stoneGame = function(piles) {\\n    return true;\\n};", "var stoneGame = function(piles) {\\n  return true;\\n};"]}
{"id": "1003", "ref_js": ["var decodeAtIndex = function(S, K) {\\n    \\n    let count = 0;\\n    for (let i = 0; i < S.length; i++) {\\n        if (!isNaN(S[i])) count *= Number(S[i])\\n        else count++\\n    }\\n\\n    for (let i = S.length - 1; i >= 0; i--) {\\n        K = K % count;\\n        if (K == 0 && isNaN(S[i])) return S[i]\\n        \\n        if (!isNaN(S[i])) count = Math.ceil(count / Number(S[i]))\\n        else count--;\\n    }\\n};", "var decodeAtIndex = function(s, k) {\\n    let length = 0;\\n    let i = 0;\\n\\n    while (length < k) {\\n        if (!isNaN(s[i])) {\\n            length *= Number(s[i]);\\n        } else {\\n            length++;\\n        }\\n        i++;\\n    }\\n\\n    for (let j = i - 1; j >= 0; j--) {\\n        if (!isNaN(s[j])) {\\n            length /= Number(s[j]);\\n            k %= length;\\n        } else {\\n            if (k === 0 || k === length) {\\n                return s[j];\\n            }\\n            length--;\\n        }\\n    }\\n\\n    return \"\";\\n};", "var decodeAtIndex = function(S, K) {\\n    \\n    let count = 0;\\n    for (let i = 0; i < S.length; i++) {\\n        if (!isNaN(S[i])) count *= Number(S[i])\\n        else count++\\n    }\\n\\n    for (let i = S.length - 1; i >= 0; i--) {\\n        K = K % count;\\n        if (K == 0 && isNaN(S[i])) return S[i]\\n        \\n        if (!isNaN(S[i])) count = Math.ceil(count / Number(S[i]))\\n        else count--;\\n    }\\n};"]}
{"id": "1004", "ref_js": ["var numRescueBoats = function(people, limit) {\\n    let ans = 0, l = 0, r = people.length -1;\\n    people.sort((a,b)=> a-b);\\n    while( l<=r ){\\n        if( people[l]+people[r] <= limit){\\n            ans++;\\n            l++;\\n        }else if( people[r] <= limit || (l == r && people[l] <= limit) ){\\n            ans++;\\n        }\\n        r--;\\n    }\\n    return ans ;\\n};", "var numRescueBoats = function (people, limit) {\\n    let boatsCount = 0;\\n    people.sort((a, b) => a - b);\\n\\n    let leftPointer = 0;\\n    let rightPointer = people.length - 1;\\n\\n    while (leftPointer <= rightPointer) {\\n        if ((people[rightPointer] + people[leftPointer]) <= limit) {\\n            leftPointer++;\\n        }\\n        rightPointer--;\\n        boatsCount++;\\n    }\\n    return boatsCount;\\n};", "var numRescueBoats = function (people, limit) {\\n  people.sort((a, b) => a - b);\\n  let boatCount = 0;\\n  let min = 0;\\n  let max = people.length - 1;\\n\\n  while (min <= max) {\\n    if (people[max] + people[min] <= limit) min++;\\n    max--;\\n    boatCount++;\\n  }\\n\\n  return boatCount;\\n};"]}
{"id": "1005", "ref_js": ["var spiralMatrixIII = function(R, C, r0, c0) {\\n    let total = R * C;\\n    let amount = 1;\\n    let output = [[r0, c0]];\\n    let place = [r0, c0];\\n    let direction = directions[0];\\n\\n    while(output.length < total){\\n    walk(place, amount | 0, direction, output, R, C);\\n    amount += 0.5;\\n    direction = directions[(directions.indexOf(direction) + 1) % 4]\\n    }\\n    return output;\\n};", "var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  ", "var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  "]}
{"id": "1006", "ref_js": ["var possibleBipartition = function(n, dislikes) {\\n    if (!dislikes.length) {\\n        return true;\\n    }\\n    const g1 = new Set();\\n    const g2 = new Set();\\n    g1.add(dislikes[0][0]);\\n    g2.add(dislikes[0][1]);\\n    dislikes = dislikes.slice(1);\\n    while (dislikes.length) {\\n        const q = [];\\n        \\n        for (const [a, b] of dislikes) {\\n            if (g1.has(a) || g2.has(b)) {\\n                if (g1.has(b) || g2.has(a)) {\\n                    return false;\\n                }\\n                g1.add(a);\\n                g2.add(b);\\n            } else if (g2.has(a) || g1.has(b)) {\\n                if (g1.has(a) || g2.has(b)) {\\n                    return false;\\n                }\\n                g1.add(b);\\n                g2.add(a);\\n            } else {\\n                q.push([a, b]);\\n            }\\n        }\\n        if (q.length === dislikes.length) {\\n            g1.add(dislikes[0][0]);\\n            g2.add(dislikes[0][1]);\\n            dislikes = dislikes.slice(1);\\n        } else {\\n            dislikes = q;\\n        }\\n    }\\n    return true;\\n};", "var possibleBipartition = function(n, dislikes) {\\n    let adj = new Array(n+1);\\n    for (let i = 0; i < n+1; i++) {\\n        adj[i] = new Array()\\n    }\\n\\n    for (let d of dislikes) {\\n        adj[d[0]].push(d[1])\\n        adj[d[1]].push(d[0])\\n    }\\n\\n    let color = new Array(n+1).fill(-1);\\n    let dfs = function(i) {\\n        for (let c of adj[i]) {\\n            if (color[c] == color[i]) return false;\\n            if (color[c] == -1) {\\n                color[c] = 1 - color[i]\\n                if (!dfs(c)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (color[i] == -1) {\\n            color[i] = 0\\n            if (!dfs(i)) return false;\\n        }\\n    }\\n\\n    return true;\\n};", "var possibleBipartition = function(N, dislikes) {\\n    const graph = [...Array(N+1)].map(() => []);\\n    const visited = Array(N+1).fill(false);\\n    const color = Array(N+1).fill(0);\\n\\n    for(let [u, v] of dislikes) {\\n        graph[u].push(v);\\n        graph[v].push(u);\\n    }\\n\\n    for(let i = 1; i <= N; i++) {\\n        if(!colorNodes(i)) return false;\\n    }\\n    return true;\\n\\n    function colorNodes(node) {\\n        if(visited[node]) return true;\\n        const currColor = new Set([1, 2]);\\n\\n\\t\\t"]}
{"id": "1007", "ref_js": ["var constructFromPrePost = function(pre, post) {\\n    let i = 0;\\n    function DFS(arr){\\n        if(!arr.length) return null;\\n        let node = pre[i++];\\n        let index = arr.indexOf(pre[i]);\\n        let tree = new TreeNode(node);\\n        tree.left = DFS(arr.slice(0, index + 1));\\n        tree.right = DFS(arr.slice(index + 1, arr.indexOf(node)));\\n        return tree;\\n    }\\n    return DFS(post);\\n};", "var constructFromPrePost = function(preorder, postorder) {\\n    const stack = [new TreeNode(preorder[0])];\\n    let post = 0;\\n\\n    for (let pre = 1; pre < preorder.length; pre++) {\\n        const node = new TreeNode(preorder[pre]);\\n\\n        while (stack.at(-1)?.val === postorder[post]) {\\n            stack.pop();\\n            post += 1;\\n        }\\n        const stackNode = stack.at(-1);\\n\\n        stackNode.left \\n            ? stackNode.right = node\\n            : stackNode.left = node;\\n\\n        stack.push(node);\\n    }\\n    return stack[0];\\n};", "var constructFromPrePost = function(preorder, postorder) {\\n    const stack = [new TreeNode(preorder[0])];\\n    let post = 0;\\n\\n    for (let pre = 1; pre < preorder.length; pre++) {\\n        const node = new TreeNode(preorder[pre]);\\n\\n        while (stack.at(-1)?.val === postorder[post]) {\\n            stack.pop();\\n            post += 1;\\n        }\\n        const stackNode = stack.at(-1);\\n\\n        stackNode.left \\n            ? stackNode.right = node\\n            : stackNode.left = node;\\n\\n        stack.push(node);\\n    }\\n    return stack[0];\\n};"]}
{"id": "1008", "ref_js": ["var findAndReplacePattern = function (words, pattern) {\\nlet arrPattern =[]\\nlet arrWords=[]\\nlet finalResult =[]\\nlet patternArray = pattern.split(\\'\\')\\nlet counts = {};", "var findAndReplacePattern = function(words, pattern) {\\n    let ans = [], codex = new Map()\\n    const translate = char => {\\n        if (!codex.has(char))\\n            codex.set(char, String.fromCharCode(97 + codex.size))\\n        return codex.get(char)\\n    }\\n    const compare = word => {\\n        codex.clear()\\n        for (let i = 0; i < word.length; i++)\\n            if (translate(word[i]) !== cipher[i])\\n                return\\n        ans.push(word)\\n    }\\n    let cipher = new Array(pattern.length)\\n    for (let i = 0; i < pattern.length; i++)\\n        cipher[i] = translate(pattern.charAt(i))\\n    words.forEach(compare)\\n    return ans\\n};", "var findAndReplacePattern = function(words, pattern) {\\n    var patt = patternarr(pattern)  "]}
{"id": "1009", "ref_js": ["var numSpecialEquivGroups = function(words) {\\n   let map = new Map();\\n   for(let word of words){\\n       let s = sorChar(word);\\n       if(!map.has(s)) map.set(s)\\n   } \\n   return map.size;\\n};", "var numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n    words.forEach(a => set.add(transform(a)));\\n    return set.size;\\n};", "var numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};"]}
{"id": "1010", "ref_js": ["var allPossibleFBT = function(n) {\\n    if(dp[n]!=-1)\\n        return dp[n];\\n    let ret = [];\\n    for(let i=1;i<n;i+=2){\\n        let ltrees = allPossibleFBT(i);\\n        let rtrees = allPossibleFBT(n-i-1);\\n        for(let j=0;j<ltrees.length;j++)\\n            for(let k=0;k<rtrees.length;k++)\\n                ret.push(new TreeNode(0,ltrees[j],rtrees[k]));\\n    }\\n    dp[n]=ret;\\n    return ret;\\n};", "var allPossibleFBT = function(n) {\\n    if (n % 2 === 0) {\\n      return [];\\n    }\\n\\n    const memo = {};", "var allPossibleFBT = function(n) {\\n    const memo = new Map();\\n    const createFBT = (N = n) => {\\n        if (N % 2 === 0) return [];\\n        if (N === 1) return [new TreeNode(0)];\\n        if (memo.has(N)) return memo.get(N);\\n        const result = [];\\n\\n        for (let index = 1; index < N; index += 2) {\\n            const left = createFBT(index);\\n            const right = createFBT(N - index - 1);\\n            for (const a of left) {\\n                for (const b of right) {\\n                    const node = new TreeNode(0, a, b);\\n                    result.push(node);\\n                }\\n            }\\n        }\\n        memo.set(N, result);\\n        return result;\\n    };"]}
{"id": "1011", "ref_js": ["var subarrayBitwiseORs = function(arr) {\\n  let res = new Set(), curr = new Set();\\n  for(let x of arr){\\n      let t = new Set([x]);\\n      for(let y of curr) t.add(x | y);\\n      curr = t;\\n      for(let y of curr) res.add(y);\\n  }    \\n  return res.size;\\n};", "var subarrayBitwiseORs = function(arr) {\\n  ", "var subarrayBitwiseORs = function(arr) {\\n  let res = new Set(), curr = new Set();\\n  for(let x of arr){\\n      let t = new Set([x]);\\n      for(let y of curr) t.add(x | y);\\n      curr = t;\\n      for(let y of curr) res.add(y);\\n  }    \\n  return res.size;\\n};"]}
{"id": "1014", "ref_js": ["var totalFruit = function(fruits) {\\n    if (new Set(fruits).size < 3) return fruits.length\\n    let max = 0, before = 0\\n    for (let i = 0; i < fruits.length; i++) {\\n        if (fruits[i] === fruits[i + 1]) {\\n            before++\\n            continue\\n        }\\n        const set = new Set()\\n        for (let j = i; j < fruits.length; j++) {\\n            set.add(fruits[j])\\n            if (set.size === 2) max = Math.max(max, j - i + 1 + before)\\n            if (set.size > 2) break\\n        }\\n        before = 0\\n    }\\n    return max\\n};", "var totalFruit = function(fruits) \\n{\\n    let baskets = [[-1,0],[-1,0]], max = 1;\\n\\n    let start = 0, end = 0;\\n    while(end < fruits.length)\\n    {\\n        \\n        if(fruits[end] === baskets[0][0])\\n            baskets[0][1]++;\\n        else if(fruits[end] === baskets[1][0])\\n            baskets[1][1]++;\\n        else if(baskets[0][0] === -1)\\n        {\\n            baskets[0][0] = fruits[end];\\n            baskets[0][1] = 1;\\n        }\\n        else if(baskets[1][0] === -1)\\n        {\\n            baskets[1][0] = fruits[end];\\n            baskets[1][1] = 1;\\n        }\\n        else\\n        {\\n            \\n            while(baskets[0][1] > 0 && baskets[1][1] > 0)\\n            {\\n                let ind = 0;\\n                if(baskets[1][0] === fruits[start])\\n                    ind = 1;\\n                if(baskets[ind][1] === 1)\\n                    baskets[ind][0] = -1;\\n                baskets[ind][1]--;\\n                start++;\\n            }\\n            continue;\\n        }\\n        max = Math.max(max, baskets[0][1]+baskets[1][1]);\\n        end++;\\n    }\\n\\n    return max;\\n};", "var totalFruit = function (fruits) {\\n    let max = 0;\\n    let currentMax = 0;\\n    let lastcount = 0;\\n    let lastfruit = -1;\\n    let secondlastfruit = -1;\\n\\n    for (let fruit of fruits) {\\n        if (fruit == lastfruit || fruit == secondlastfruit) {\\n            currentMax += 1;\\n        } else {\\n            currentMax = lastcount += 1;\\n        }\\n\\n        if (fruit == lastfruit) {\\n            lastcount++;\\n        } else {\\n            lastcount = 1;\\n        }\\n\\n        if (fruit !== lastfruit) {\\n            secondlastfruit = lastfruit;\\n            lastfruit = fruit;\\n        }\\n        max = Math.max(currentMax, max)\\n    }\\n    return max;\\n};"]}
{"id": "1015", "ref_js": ["var sumSubarrayMins = function(arr) {\\n    const stack = [0]\\n    arr.splice(0, 0, -Infinity)\\n    arr.push(-Infinity)\\n    let res = 0\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        while (stack.length && arr[i] < arr[stack[stack.length - 1]]) {\\n            const mid = stack.pop()\\n            const left = mid - stack[stack.length - 1]\\n            const right = i - mid\\n            res += left * right * arr[mid]\\n        }\\n        \\n        stack.push(i)\\n    }\\n    \\n    return res % (10 ** 9 + 7)\\n};", "var sumSubarrayMins = function(arr) {\\n    \\n    M = 10**9+7\\n    stack = [-1]\\n    res = 0\\n    arr.push(0)\\n    \\n    for(let i2 = 0; i2 < arr.length; i2++){\\n        while(arr[i2] < arr[stack[stack.length -1]]){\\n            i = stack.pop()\\n            i1 = stack[stack.length-1]\\n            Left = i - i1\\n            Right = i2 -i\\n            res += (Left*Right*arr[i])\\n        };", "var sumSubarrayMins = function(arr) {\\n    \\n    M = 10**9+7\\n    stack = [-1]\\n    res = 0\\n    arr.push(0)\\n    \\n    for(let i2 = 0; i2 < arr.length; i2++){\\n        while(arr[i2] < arr[stack[stack.length -1]]){\\n            i = stack.pop()\\n            i1 = stack[stack.length-1]\\n            Left = i - i1\\n            Right = i2 -i\\n            res += (Left*Right*arr[i])\\n        };"]}
{"id": "1016", "ref_js": ["var snakesAndLadders = function(board) {\\n    let n = board.length\\n    let label = 1\\n    let cells = new Array(n*n+1)\\n    for (let i = n-1; i >= 0; i--) {\\n        for (let j = 0; j < n && (n-i)% 2 == 1; j++) {\\n            cells[label++] = [i,j]\\n        }\\n        for (let j = n-1; j >= 0 && (n-i)% 2 == 0; j--) {\\n            cells[label++] = [i,j]\\n        }\\n    }\\n\\n    let minMoves = new Array(n*n+1).fill(-1)\\n    minMoves[1] = 0\\n    let queue = [1]\\n\\n    while (queue.length) {\\n        let curr = queue.shift()\\n        if (curr == n*n) return minMoves[curr]\\n        for (let next = curr + 1; next <= Math.min(curr+6, n*n); next++) {\\n            let [i,j] = cells[next]\\n            let destination = next\\n            if (board[i][j] != -1) destination = board[i][j]\\n            if (minMoves[destination]  == -1) {\\n                queue.push(destination)\\n                minMoves[destination] = minMoves[curr] + 1\\n            }\\n        }\\n    }\\n    return -1\\n};", "var snakesAndLadders = function(board) {\\n    let n = board.length;\\n    let set = new Set();\\n    let getPos = (pos) =>{\\n        let row = Math.floor((pos-1) / n)\\n        let col = (pos-1) % n\\n        col = row % 2 == 1 ? n - 1 - col : col;\\n        row = n - 1 - row;\\n        return [row,col]\\n    }\\n    let q = [[1,0]]\\n    while(q.length>0){\\n        [pos,moves] = q.shift();\\n        for(let i =1; i<7; i++){\\n            let newPos = i+pos;\\n            let [r,c] = getPos(newPos);\\n            if(board[r][c] != -1 ) newPos = board[r][c]\\n            if(newPos == n*n) return moves+1;\\n            if(!set.has(newPos)){\\n                set.add(newPos)\\n                q.push([newPos,moves+1])\\n            }\\n        }\\n    }\\n    return -1   \\n};", "var snakesAndLadders = function(board) {\\n    let n = board.length;\\n    let set = new Set();\\n    let getPos = (pos) =>{\\n        let row = Math.floor((pos-1) / n)\\n        let col = (pos-1) % n\\n        col = row % 2 == 1 ? n - 1 - col : col;\\n        row = n - 1 - row;\\n        return [row,col]\\n    }\\n    let q = [[1,0]]\\n    while(q.length>0){\\n        [pos,moves] = q.shift();\\n        for(let i =1; i<7; i++){\\n            let newPos = i+pos;\\n            let [r,c] = getPos(newPos);\\n            if(board[r][c] != -1 ) newPos = board[r][c]\\n            if(newPos == n*n) return moves+1;\\n            if(!set.has(newPos)){\\n                set.add(newPos)\\n                q.push([newPos,moves+1])\\n            }\\n        }\\n    }\\n    return -1   \\n};"]}
{"id": "1017", "ref_js": ["var smallestRangeII = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n    let max = -Infinity;\\n    let min = Infinity;\\n    let n = nums.length - 1;\\n    let res = nums[n] - nums[0];\\n\\n    for(let i = 0; i < n; i++){\\n        max = Math.max(nums[i] + k, nums[n] - k);\\n        min = Math.min(nums[i + 1] - k, nums[0] + k);\\n        res = Math.min(res, max-min);\\n    }\\n    return res;\\n};", "var smallestRangeII = function(nums, k) {\\n      if (nums.length === 1) return 0;\\n\\n    ", "var smallestRangeII = function(nums, k) {\\n    \\n    nums = nums.sort((a,b)=>a-b);\\n    \\n    let min_first = nums[0];\\n    let max_last = nums[nums.length-1];\\n    \\n    let res = max_last - min_first;\\n   \\n    \\n    for(let i=0; i<nums.length-1; i++){\\n        \\n        res = Math.min(res, Math.max(max_last - k, nums[i]+k) - Math.min(min_first + k, nums[i+1]-k))\\n    }\\n    \\n    return res;\\n    \\n};"]}
{"id": "1019", "ref_js": ["var sortArray = function(nums) {\\n    let compare = (a,b)=>{\\n        return a-b;\\n    }\\n    return nums.sort(compare);\\n    \\n};", "var sortArray = function(nums) {\\n    if(nums.length < 2) return nums\\n    let mid = Math.floor(nums.length/2);\\n    let left = nums.slice(0, mid);\\n    let right = nums.slice(mid);\\n    return merge(sortArray(left), sortArray(right));\\n};", "var sortArray = function(arr) {\\n    if(arr.length === 1) {\\n        return arr\\n    }\\n    let mid = Math.round(arr.length/2);\\n    if(arr.length < 2) {\\n        return;\\n    }\\n    let left = [];\\n    let right = [];\\n    for(let i=0;i<mid;i++) {\\n        left.push(arr[i]);\\n    }\\n\\n    for(let j = mid;j<arr.length;j++) {\\n        right.push(arr[j]);\\n    }\\n\\n    sortArray(left);\\n    sortArray(right);\\n    mergeSortedArray(left,right,arr);\\n\\n    return arr;\\n};"]}
{"id": "1020", "ref_js": ["var partitionDisjoint = function(nums) {\\n    let curr = nums[0];\\n    let max = 0;\\n    let pos = 0;\\n\\n    for(let i = 1; i < nums.length; i++){\\n        let num = nums[i];\\n        max = Math.max(num, max);\\n        if(curr <= num) continue;\\n        pos = i;\\n        curr = Math.max(max, curr);\\n    }\\n    return pos + 1;\\n};", "var partitionDisjoint = function(nums) {\\n    var minimumDp=new Array(nums.length).fill().map((_,i)=>0);\\n     var maximumDp=new Array(nums.length).fill().map((_,i)=>0);\\n    maximumDp[0]=nums[0];\\n    let result=0;\\n    minimumDp[nums.length-1]=nums[nums.length-1];\\n \\n    for(let i=0;i<nums.length;i++)\\n    {\\n         maximumDp[i]=max(maximumDp[i-1],nums[i]);\\n\\n    }\\n    for(let i=nums.length-2;i>=0;i--)\\n    {\\n        minimumDp[i]=min(minimumDp[i+1],nums[i]);\\n\\n    }\\n     for(let i=0;i<nums.length-1;i++)\\n    {\\n        if(maximumDp[i]<=minimumDp[i+1])\\n        {result=i;\\n        break;\\n        }\\n    }\\nreturn result+1;\\n};", "var partitionDisjoint = function(nums) {\\n    let current = nums[0];\\n    let max = 0;\\n    let position = 0;\\n\\n    for (let index = 1; index < nums.length; index++) {\\n        const num = nums[index];\\n\\n        max = Math.max(num, max);\\n        if (current <= num) continue;\\n        position = index;\\n        current = Math.max(max, current);\\n    }\\n    return position + 1;\\n};"]}
{"id": "1021", "ref_js": ["var wordSubsets = function(A, B) {\\n    let Bfreq = new Int8Array(26), cmax = 0,\\n        check = new Int8Array(26), ans = []\\n    for (let i = 0; i < B.length; i++, check.fill()) {\\n        let word = B[i]\\n        for (let j = 0; j < word.length; j++)\\n            check[word.charCodeAt(j) - 97]++\\n        for (let j = 0; j < 26; j++) {\\n            let diff = check[j] - Bfreq[j]\\n            if (diff > 0) cmax += diff, Bfreq[j] += diff\\n            if (cmax > 10) return []\\n        }\\n    }\\n    for (let i = 0; i < A.length; i++, check.fill()) {\\n        let word = A[i], j\\n        if (word.length < cmax) continue\\n        for (j = 0; j < word.length; j++)\\n            check[word.charCodeAt(j) - 97]++\\n        for (j = 0; j < 26; j++)\\n            if (check[j] < Bfreq[j]) break\\n        if (j === 26) ans.push(word)\\n    }\\n    return ans\\n};", "var wordSubsets = function(words1, words2) {\\n    this.count = Array(26).fill(0);\\n    let tmp = Array(26).fill(0);\\n    for(let b of words2){\\n        tmp = counter(b);\\n        for(let i=0; i<26; i++)\\n            count[i] = Math.max(count[i], tmp[i]);\\n    }\\n    let list = []\\n    for(let a of words1)\\n        if(isSub(counter(a)))\\n            list.push(a);\\n    return list;\\n};", "var wordSubsets = function (words1, words2) {\\n\\n    let frequencyB = new Array(26).fill(0);\\n\\n\\n    for (let word of words2) {\\n        let frequencyArray = findFrequency(word);\\n\\n        for (let i = 0; i < frequencyArray.length; i++) {\\n            frequencyB[i] = Math.max(frequencyArray[i], frequencyB[i]);\\n        }\\n    }\\n\\n    let result = [];\\n\\n    for (let word of words1) {\\n        let currentFrequency = findFrequency(word);\\n        let isSubset = findSubset(currentFrequency);\\n\\n        if (isSubset) {\\n            result.push(word);\\n        }\\n    }\\n\\n    return result;\\n\\n    function findSubset(wordArray) {\\n        for (let i = 0; i < wordArray.length; i++) {\\n            if (frequencyB[i] > wordArray[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    function findFrequency(string) {\\n\\n        let stringArray = new Array(26).fill(0);\\n\\n        for (let i = 0; i < string.length; i++) {\\n            let index = string.charCodeAt(i) - \"a\".charCodeAt();\\n            stringArray[index]++;\\n        }\\n\\n        return stringArray;\\n    }\\n};"]}
{"id": "1022", "ref_js": ["var maxSubarraySumCircular = function(nums) {\\n    let preMin = nums[0];\\n    let preMax = nums[0];\\n    let max = nums[0];\\n    let min = nums[0];\\n    let total = nums[0]\\n    for (let i = 1; i < nums.length; i++) {\\n        let n = nums[i];\\n        preMax = Math.max(n, n+preMax);\\n        max = Math.max(max,preMax)\\n        preMin = Math.min(n,preMin+n);\\n        min = Math.min(min,preMin)   \\n        total+=n; \\n    }\\n    return max < 0 ? max : Math.max(max ,total - min)\\n   \\n};", "var maxSubarraySumCircular = function(nums) {\\n  let maxSum = -Infinity, currentSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    currentSum = Math.max(currentSum + nums[i], nums[i]);\\n    maxSum = Math.max(maxSum, currentSum);\\n  }\\n  if (maxSum < 0) return Math.max(...nums);\\n  \\n  let sum = nums.reduce((acc, val) => acc + val, 0);\\n  let circularMaxSum = 0, circularCurrentSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    circularCurrentSum = Math.max(circularCurrentSum + nums[i], nums[i]);\\n    circularMaxSum = Math.max(circularMaxSum, circularCurrentSum);\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    nums[i] = -nums[i];\\n  }\\n  let negativeSum = 0, negativeCurrentSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    negativeCurrentSum = Math.max(negativeCurrentSum + nums[i], nums[i]);\\n    negativeSum = Math.max(negativeSum, negativeCurrentSum);\\n  }\\n  circularMaxSum = Math.max(circularMaxSum, sum + negativeSum);\\n  \\n  return circularMaxSum;\\n};", "var maxSubarraySumCircular = function(nums) {\\n    let preMin = nums[0];\\n    let preMax = nums[0];\\n    let max = nums[0];\\n    let min = nums[0];\\n    let total = nums[0]\\n    for (let i = 1; i < nums.length; i++) {\\n        let n = nums[i];\\n        preMax = Math.max(n, n+preMax);\\n        max = Math.max(max,preMax)\\n        preMin = Math.min(n,preMin+n);\\n        min = Math.min(min,preMin)   \\n        total+=n; \\n    }\\n    return max < 0 ? max : Math.max(max ,total - min)\\n   \\n};"]}
{"id": "1024", "ref_js": ["var minAddToMakeValid = function(s) {\\n     const stack= [];\\n     let ans=0;\\n\\n     for(let i=0; i<s.length; i++){\\n       if(s[i]==\\'(\\' )\\n         stack.push(\\'(\\');\\n       else{\\n         if(stack.length!=0 && stack[stack.length-1]==\"(\")\\n           stack.pop();\\n         else\\n          ans++;\\n       }\\n     }\\n\\n     ans+=stack.length;\\n\\n     return ans;\\n};", "var minAddToMakeValid = function(S) {\\n    let open = 0, close = 0;\\n    \\n    for(let c of S) {\\n        if(c === \\'(\\') open++;\\n        else if(!open) close++;\\n        else open--;\\n    }\\n    return open + close;\\n};", "var minAddToMakeValid = function(s) {\\n     const stack= [];\\n     let ans=0;\\n\\n     for(let i=0; i<s.length; i++){\\n       if(s[i]==\\'(\\' )\\n         stack.push(\\'(\\');\\n       else{\\n         if(stack.length!=0 && stack[stack.length-1]==\"(\")\\n           stack.pop();\\n         else\\n          ans++;\\n       }\\n     }\\n\\n     ans+=stack.length;\\n\\n     return ans;\\n};"]}
{"id": "1025", "ref_js": ["var threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    ", "var threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};", "var threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};"]}
{"id": "1026", "ref_js": ["var minFlipsMonoIncr = function(s) {\\n    let result = 0; \\n    let count = 0;\\n\\n    for (const str of s) {\\n        if(str== \\'1\\') {\\n            count++\\n        }else if(str ==\\'0\\' && count> 0){\\n            result++\\n            count--\\n        }\\n    }\\n    return result;\\n};", "var minFlipsMonoIncr = function(s) {\\n    let res = 0\\n    let n = 0\\n    for (let c of s) {\\n        if (c == \\'0\\') {\\n            res = Math.min(n, res + 1)\\n        }\\n        else n++\\n    }\\n    return res\\n};", "var minFlipsMonoIncr = function(s) {\\n    let ans = 0, one = 0, zero = 0, j = 0;\\n    let dp = []; \\n    while (j < s.length) {\\n        if (s[j] == \\'1\\') break;\\n        else dp[j] = 0; \\n        j++;\\n    }\\n    for (let i = j; i < s.length; i++) {\\n        if (s[i] == \\'1\\') {dp[i] = !dp[i - 1] ? 0 : dp[i - 1];one++} \\n        else {\\n            zero++; \\n            let a = Math.min(one, zero);\\n            dp[i] = Math.min(1 + dp[i - 1], a);  \\n        }\\n    }\\n    "]}
{"id": "1027", "ref_js": ["var numSubarraysWithSum = function(nums, goal) {\\r\\n \\r\\n    let totalSubarray = 0;\\r\\n\\r\\n    for(let i=0; i<nums.length; i++){\\r\\n        let sum = 0;\\r\\n        for(let j=i; j < nums.length; j++){\\r\\n            sum += nums[j]\\r\\n            if(sum === goal) totalSubarray++\\r\\n            if(sum > goal) break\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return totalSubarray\\r\\n};", "var numSubarraysWithSum = function (a, t) {\\n    let i = 0,\\n        sum = 0,\\n        cc = 0;\\n    for (let j = 0; j < a.length; j++) {\\n        sum += a[j];\\n        if (sum > t) {\\n            for (; sum > t && i < j; i++) {\\n                sum -= a[i];\\n            }\\n        }\\n        if (sum === t) {\\n            let i2 = i;\\n            for (; i2 < j && sum + a[i2] === t; i2++) {}\\n            cc += i2 - i + 1;\\n        }\\n    }\\n    return cc;\\n};", "var numSubarraysWithSum = function(nums, goal) {\\r\\n \\r\\n    let totalSubarray = 0;\\r\\n\\r\\n    for(let i=0; i<nums.length; i++){\\r\\n        let sum = 0;\\r\\n        for(let j=i; j < nums.length; j++){\\r\\n            sum += nums[j]\\r\\n            if(sum === goal) totalSubarray++\\r\\n            if(sum > goal) break\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return totalSubarray\\r\\n};"]}
{"id": "1028", "ref_js": ["var minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]]\\n    }\\n\\n    let minSum = Infinity;\\n    for (let i = n - 2; i >= 0; i--) {\\n        minSum = Infinity;\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] += dp[i+1][j];\\n            if (j > 0) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j-1]);\\n            if (j < n-1) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j+1]);\\n            minSum = Math.min(minSum, dp[i][j])\\n        }\\n    }\\n    return matrix.length > 1 ? minSum : matrix[0][0];\\n};", "var minFallingPathSum = function(matrix) {\\n    let arr = Array.from(Array(matrix.length),()=>new Array(matrix[0].length).fill(0))\\n    for(let i =0; i<matrix[0].length;i++){\\n        arr[0][i] = matrix[0][i]\\n    }\\n    for(let i =1;i<matrix.length;i++){\\n        for(let j =0;j<matrix[0].length;j++){\\n            if(j==0) arr[i][j] = Math.min(arr[i-1][j],arr[i-1][j+1])\\n            else if(j ==matrix[0].length-1) arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j])\\n            else arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j],arr[i-1][j+1])\\n            arr[i][j] += matrix[i][j]\\n        }\\n    }\\n    return Math.min(...arr[arr.length-1])\\n};", "var minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    \\n    "]}
{"id": "1029", "ref_js": ["var beautifulArray = function (n) {\\n    let res = [1];\\n\\n    while (res.length < n) {\\n        let temp = [];\\n\\n        for (let num of res) {\\n            if (num * 2 - 1 <= n) {\\n                temp.push(num * 2 - 1);\\n            }\\n        }\\n\\n        for (let num of res) {\\n            if (num * 2 <= n) {\\n                temp.push(num * 2);\\n            }\\n        }\\n\\n        res.length = 0;\\n        res.push(...temp);\\n    }\\n\\n    return res;\\n};", "var beautifulArray = function(n) {\\n   let res = [1];\\n   while(res.length < n){\\n       let temp = [];\\n\\n       for(let num of res){\\n           if(num * 2 - 1 <= n){\\n                temp.push(num * 2 - 1);\\n               }\\n           }\\n        for(let num of res){\\n            if(num * 2 <= n){\\n                temp.push(num * 2);\\n            }\\n        }\\n        res.length = 0;\\n        res.push(...temp);\\n       }    \\n       return res;\\n};", "var beautifulArray = function(n) {\\n   let res = [1];\\n   while(res.length < n){\\n       let temp = [];\\n\\n       for(let num of res){\\n           if(num * 2 - 1 <= n){\\n                temp.push(num * 2 - 1);\\n               }\\n           }\\n        for(let num of res){\\n            if(num * 2 <= n){\\n                temp.push(num * 2);\\n            }\\n        }\\n        res.length = 0;\\n        res.push(...temp);\\n       }    \\n       return res;\\n};"]}
{"id": "1030", "ref_js": ["var shortestBridge = function(grid) {\\n    const startingIsland = new Set();\\n    const dirs = [[-1, 0], [0, -1], [1, 0], [0, 1]];\\n\\n    const getStartingIsland = (i, j) => {\\n        for (let [x, y] of dirs) {\\n            let xi = i + x;\\n            let yj = j + y;\\n            const position = `${xi},${yj}`;\\n            if (grid[xi] && grid[xi][yj] && !startingIsland.has(position)) {\\n                startingIsland.add(position);\\n                getStartingIsland(xi, yj);\\n            }\\n        }\\n    }\\n\\n    let breakPoint = -1;\\n    for (let i = 0; i < grid.length; ++i) {\\n        for (let j = 0; j < grid[i].length; ++j) {\\n            if (grid[i][j] === 1) {\\n                breakPoint = i;\\n                const position = `${i},${j}`;\\n                startingIsland.add(position);\\n                getStartingIsland(i, j);\\n                break;\\n            }\\n        }\\n        if (breakPoint === i) break;\\n    }\\n\\n    const queue = new LinkedList();\\n\\n    let min = Infinity;\\n    const visit = new Set();\\n\\n    for (let startPoint of startingIsland) {\\n        const startPointArr = startPoint.split(\\',\\');\\n\\n        startPointArr[0] = parseInt(startPointArr[0]);\\n        startPointArr[1] = parseInt(startPointArr[1]);\\n\\n        queue.enqueue([startPointArr, 0]);\\n    }\\n        \\n        const allMinFlips = [];\\n        while (!queue.isEmpty()) {\\n            const [[i, j], flips] = queue.dequeue();", "var shortestBridge = function(grid) {\\n    const startingIsland = new Set();\\n    const dirs = [[-1, 0], [0, -1], [1, 0], [0, 1]];\\n\\n    const getStartingIsland = (i, j) => {\\n        for (let [x, y] of dirs) {\\n            let xi = i + x;\\n            let yj = j + y;\\n            const position = `${xi},${yj}`;\\n            if (grid[xi] && grid[xi][yj] && !startingIsland.has(position)) {\\n                startingIsland.add(position);\\n                getStartingIsland(xi, yj);\\n            }\\n        }\\n    }\\n\\n    let breakPoint = -1;\\n    for (let i = 0; i < grid.length; ++i) {\\n        for (let j = 0; j < grid[i].length; ++j) {\\n            if (grid[i][j] === 1) {\\n                breakPoint = i;\\n                const position = `${i},${j}`;\\n                startingIsland.add(position);\\n                getStartingIsland(i, j);\\n                break;\\n            }\\n        }\\n        if (breakPoint === i) break;\\n    }\\n\\n    const queue = new LinkedList();\\n\\n    let min = Infinity;\\n    const visit = new Set();\\n\\n    for (let startPoint of startingIsland) {\\n        const startPointArr = startPoint.split(\\',\\');\\n\\n        startPointArr[0] = parseInt(startPointArr[0]);\\n        startPointArr[1] = parseInt(startPointArr[1]);\\n\\n        queue.enqueue([startPointArr, 0]);\\n    }\\n        \\n        const allMinFlips = [];\\n        while (!queue.isEmpty()) {\\n            const [[i, j], flips] = queue.dequeue();", "var shortestBridge = function(grid) {\\n    const startingIsland = new Set();\\n    const dirs = [[-1, 0], [0, -1], [1, 0], [0, 1]];\\n\\n    const getStartingIsland = (i, j) => {\\n        for (let [x, y] of dirs) {\\n            let xi = i + x;\\n            let yj = j + y;\\n            const position = `${xi},${yj}`;\\n            if (grid[xi] && grid[xi][yj] && !startingIsland.has(position)) {\\n                startingIsland.add(position);\\n                getStartingIsland(xi, yj);\\n            }\\n        }\\n    }\\n\\n    let breakPoint = -1;\\n    for (let i = 0; i < grid.length; ++i) {\\n        for (let j = 0; j < grid[i].length; ++j) {\\n            if (grid[i][j] === 1) {\\n                breakPoint = i;\\n                const position = `${i},${j}`;\\n                startingIsland.add(position);\\n                getStartingIsland(i, j);\\n                break;\\n            }\\n        }\\n        if (breakPoint === i) break;\\n    }\\n\\n    const queue = new LinkedList();\\n\\n    let min = Infinity;\\n    const visit = new Set();\\n\\n    for (let startPoint of startingIsland) {\\n        const startPointArr = startPoint.split(\\',\\');\\n\\n        startPointArr[0] = parseInt(startPointArr[0]);\\n        startPointArr[1] = parseInt(startPointArr[1]);\\n\\n        queue.enqueue([startPointArr, 0]);\\n    }\\n        \\n        const allMinFlips = [];\\n        while (!queue.isEmpty()) {\\n            const [[i, j], flips] = queue.dequeue();"]}
{"id": "1031", "ref_js": ["var knightDialer = function (n) {\\n    const cap = (x) => x % (10 ** 9 + 7)\\n    const jumps = {\\n        1: [6, 8],\\n        2: [7, 9],\\n        3: [4, 8],\\n        4: [3, 9, 0],\\n        6: [1, 7, 0],\\n        7: [2,6],\\n        8: [1, 3],\\n        9: [2, 4],\\n        0: [4, 6]\\n    }\\n\\n    let prev = Array.from(Array(10), _=>1)\\n    let cur = Array.from(Array(10), _=>0)\\n\\n    for (let k=2; k<=n; k++) {\\n        for (let i=0; i<=9; i++) {\\n            if (i===5) continue\\n            cur[i] = cap(jumps[i].reduce((acc, c)=> {\\n                return cap(acc + prev[c])\\n            }, 0))\\n        }\\n        prev = [...cur]\\n    }\\n    const sum = prev.reduce((acc, cur)=>cap(acc+cur), 0)\\n    return cap(sum)\\n};", "var knightDialer = function(moves) {\\n    const MOD = 1e9 + 7;\\n    const memo = new Map();\\n    const nextValidKeys = {\\n        0: [4, 6],\\n        1: [6, 8],\\n        2: [7, 9],\\n        3: [4, 8],\\n        4: [0, 3, 9],\\n        5: [],\\n        6: [0, 1, 7],\\n        7: [2, 6],\\n        8: [1, 3],\\n        9: [2, 4]\\n    };", "var knightDialer = function(n) {\\n    if (n === 1) return 10; "]}
{"id": "1032", "ref_js": ["var reorderLogFiles = function(logs) {\\n    const letters = []\\n    const digits = []\\n    \\n    for (let log of logs){\\n\\n        if (isNaN(log[log.length - 1])){\\n            ", "var reorderLogFiles = function(logs) {\\n  const letterLogs = [];\\n  const digitLogs = [];\\n  logs.forEach(log => {\\n    if (/ \\\\d/.test(log)) {\\n      digitLogs.push(log);\\n    } else {\\n      letterLogs.push(log);\\n    }\\n  });\\n  letterLogs.sort((a, b) => {\\n    const aBody = a.slice(a.indexOf(\\' \\') + 1);\\n    const bBody = b.slice(b.indexOf(\\' \\') + 1);\\n    const c = aBody.localeCompare(bBody);\\n    if (c) return c;\\n    return a.localeCompare(b);\\n  });\\n  return [...letterLogs, ...digitLogs];\\n};", "var reorderLogFiles = function(logs) {\\n    const letters = []\\n    const digits = []\\n    \\n    for (let log of logs){\\n\\n        if (isNaN(log[log.length - 1])){\\n            "]}
{"id": "1033", "ref_js": ["var minAreaRect = function(points) {\\n  ", "var minAreaRect = function(points) {\\n    let set = new Set();\\n    let maxRectangleArea = Number.MAX_SAFE_INTEGER;\\n\\n    for (let pos of points) {\\n        set.add(`${pos[0]}_${pos[1]}`);\\n    }\\n\\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            let x1 = points[i][0];\\n            let x2 = points[j][0];\\n            let y1 = points[i][1];\\n            let y2 = points[j][1];\\n\\n            if (x1 !== x2 && y1 !== y2) {\\n                if (set.has(`${x1}_${y2}`) && set.has(`${x2}_${y1}`)) {\\n                    maxRectangleArea = Math.min(maxRectangleArea, Math.abs(x1 - x2) * Math.abs(y1 - y2));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxRectangleArea === Number.MAX_SAFE_INTEGER ? 0: maxRectangleArea;\\n};", "var minAreaRect = function(points) {\\n    let set = new Set();\\n    let maxRectangleArea = Number.MAX_SAFE_INTEGER;\\n\\n    for (let pos of points) {\\n        set.add(`${pos[0]}_${pos[1]}`);\\n    }\\n\\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            let x1 = points[i][0];\\n            let x2 = points[j][0];\\n            let y1 = points[i][1];\\n            let y2 = points[j][1];\\n\\n            if (x1 !== x2 && y1 !== y2) {\\n                if (set.has(`${x1}_${y2}`) && set.has(`${x2}_${y1}`)) {\\n                    maxRectangleArea = Math.min(maxRectangleArea, Math.abs(x1 - x2) * Math.abs(y1 - y2));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxRectangleArea === Number.MAX_SAFE_INTEGER ? 0: maxRectangleArea;\\n};"]}
{"id": "1034", "ref_js": ["var minIncrementForUnique = function(nums) {\\n    nums.sort((a, b) => (a - b))\\n    let mincount = 0\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] == nums[i - 1]) {\\n            nums[i] += 1\\n            mincount++\\n        }\\n        else if (nums[i] < nums[i - 1]) {\\n            let diff = Math.abs(nums[i] - nums[i - 1])\\n            nums[i] += diff + 1\\n            mincount += diff + 1\\n        }\\n    }\\n    return mincount\\n};", "var minIncrementForUnique = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let count = 0;\\n\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i - 1]){\\n            nums[i] += 1;\\n            count++;\\n        }\\n        else if(nums[i] < nums[i - 1]){\\n            let diff = Math.abs(nums[i] - nums[i - 1]);\\n            nums[i] += diff + 1;\\n            count += diff + 1;\\n        }\\n    }\\n    return count;\\n};", "var minIncrementForUnique = function(nums) {\\n    nums.sort((a, b) => (a - b))\\n    let mincount = 0\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] == nums[i - 1]) {\\n            nums[i] += 1\\n            mincount++\\n        }\\n        else if (nums[i] < nums[i - 1]) {\\n            let diff = Math.abs(nums[i] - nums[i - 1])\\n            nums[i] += diff + 1\\n            mincount += diff + 1\\n        }\\n    }\\n    return mincount\\n};"]}
{"id": "1035", "ref_js": ["var validateStackSequences = function(pushed, popped) {\\n    let i = 0;\\n    let j = 0;\\n    let res = [];\\n    if(pushed.length < popped.length) return false;\\n    while(i<pushed.length || j<popped.length) {\\n        if(j>=popped.length) return true;\\n        if(res.length === 0) {\\n            res.push(pushed[i++]);\\n            continue;\\n        }\\n        if(res[res.length-1]===popped[j]) {\\n            res.pop();\\n            j++;\\n        } else {\\n            if(i<pushed.length) {\\n                res.push(pushed[i++]); \\n            } else return false;\\n        }\\n        \\n    }\\n    return true;\\n};", "var validateStackSequences = function(pushed, popped) {\\n    let i = 0;\\n    let j = 0;\\n    let res = [];\\n    if(pushed.length < popped.length) return false;\\n    while(i<pushed.length || j<popped.length) {\\n        if(j>=popped.length) return true;\\n        if(res.length === 0) {\\n            res.push(pushed[i++]);\\n            continue;\\n        }\\n        if(res[res.length-1]===popped[j]) {\\n            res.pop();\\n            j++;\\n        } else {\\n            if(i<pushed.length) {\\n                res.push(pushed[i++]); \\n            } else return false;\\n        }\\n        \\n    }\\n    return true;\\n};", "var validateStackSequences = function(pushed, popped) {\\n    let i = 0;\\n    let j = 0;\\n    let res = [];\\n    if(pushed.length < popped.length) return false;\\n    while(i<pushed.length || j<popped.length) {\\n        if(j>=popped.length) return true;\\n        if(res.length === 0) {\\n            res.push(pushed[i++]);\\n            continue;\\n        }\\n        if(res[res.length-1]===popped[j]) {\\n            res.pop();\\n            j++;\\n        } else {\\n            if(i<pushed.length) {\\n                res.push(pushed[i++]); \\n            } else return false;\\n        }\\n        \\n    }\\n    return true;\\n};"]}
{"id": "1036", "ref_js": ["var Node = function(c){\\n    this.parent = this;\\n    this.c = c;\\n    this.size = 1;\\n}\\n\\nclass UnionFind {\\n    constructor(vertices){\\n        this.nodes = [];\\n        this.map = new Map();\\n        \\n        for(let v of vertices){\\n            let n = new Node(v);\\n            this.map.set(this.getKey(v), n)\\n            this.nodes.push(n);\\n        }\\n        \\n       \\n        for(let i=0; i < vertices.length-1; i++){\\n            for(let j=i+1; j < vertices.length; j++){\\n                if(this.isConnected(vertices[i], vertices[j])){\\n                    let [k1, k2] = [this.map.get(this.getKey(vertices[i])),\\n                                   this.map.get(this.getKey(vertices[j]))]\\n                    \\n                \\n                    this.union(k1, k2);\\n                }\\n            }\\n        }\\n    }\\n    \\n    getKey([x,y]){\\n        return `x${x}-y${y}`;\\n    }\\n    \\n    getParent(v1){\\n        \\n        let p = this.map.get(this.getKey(v1));\\n        \\n        while(p !== p.parent){\\n            p = p.parent;\\n        }\\n        \\n        return p;\\n    }\\n    \\n    union(n1, n2){\\n        let [p1, p2] = [n1, n2];\\n\\n        while(p1.parent !== p1){\\n            p1 = p1.parent;\\n        }\\n        \\n        while(p2.parent !== p2){\\n            p2 = p2.parent;\\n        }\\n        \\n        if(p1 !== p2){\\n            if(p1.size > p2.size){\\n                p2.parent = p1;\\n                p2.size = 0;\\n                p1.size = p1.size+1;\\n            }\\n            else {\\n                p1.parent = p2;\\n                p1.size = 0;\\n                p2.size = p2.size+1;\\n            }\\n        }\\n        \\n       ", "var Node = function(c){\\n    this.parent = this;\\n    this.c = c;\\n    this.size = 1;\\n}\\n\\nclass UnionFind {\\n    constructor(vertices){\\n        this.nodes = [];\\n        this.map = new Map();\\n        \\n        for(let v of vertices){\\n            let n = new Node(v);\\n            this.map.set(this.getKey(v), n)\\n            this.nodes.push(n);\\n        }\\n        \\n       \\n        for(let i=0; i < vertices.length-1; i++){\\n            for(let j=i+1; j < vertices.length; j++){\\n                if(this.isConnected(vertices[i], vertices[j])){\\n                    let [k1, k2] = [this.map.get(this.getKey(vertices[i])),\\n                                   this.map.get(this.getKey(vertices[j]))]\\n                    \\n                \\n                    this.union(k1, k2);\\n                }\\n            }\\n        }\\n    }\\n    \\n    getKey([x,y]){\\n        return `x${x}-y${y}`;\\n    }\\n    \\n    getParent(v1){\\n        \\n        let p = this.map.get(this.getKey(v1));\\n        \\n        while(p !== p.parent){\\n            p = p.parent;\\n        }\\n        \\n        return p;\\n    }\\n    \\n    union(n1, n2){\\n        let [p1, p2] = [n1, n2];\\n\\n        while(p1.parent !== p1){\\n            p1 = p1.parent;\\n        }\\n        \\n        while(p2.parent !== p2){\\n            p2 = p2.parent;\\n        }\\n        \\n        if(p1 !== p2){\\n            if(p1.size > p2.size){\\n                p2.parent = p1;\\n                p2.size = 0;\\n                p1.size = p1.size+1;\\n            }\\n            else {\\n                p1.parent = p2;\\n                p1.size = 0;\\n                p2.size = p2.size+1;\\n            }\\n        }\\n        \\n       ", "var Node = function(c){\\n    this.parent = this;\\n    this.c = c;\\n    this.size = 1;\\n}\\n\\nclass UnionFind {\\n    constructor(vertices){\\n        this.nodes = [];\\n        this.map = new Map();\\n        \\n        for(let v of vertices){\\n            let n = new Node(v);\\n            this.map.set(this.getKey(v), n)\\n            this.nodes.push(n);\\n        }\\n        \\n       \\n        for(let i=0; i < vertices.length-1; i++){\\n            for(let j=i+1; j < vertices.length; j++){\\n                if(this.isConnected(vertices[i], vertices[j])){\\n                    let [k1, k2] = [this.map.get(this.getKey(vertices[i])),\\n                                   this.map.get(this.getKey(vertices[j]))]\\n                    \\n                \\n                    this.union(k1, k2);\\n                }\\n            }\\n        }\\n    }\\n    \\n    getKey([x,y]){\\n        return `x${x}-y${y}`;\\n    }\\n    \\n    getParent(v1){\\n        \\n        let p = this.map.get(this.getKey(v1));\\n        \\n        while(p !== p.parent){\\n            p = p.parent;\\n        }\\n        \\n        return p;\\n    }\\n    \\n    union(n1, n2){\\n        let [p1, p2] = [n1, n2];\\n\\n        while(p1.parent !== p1){\\n            p1 = p1.parent;\\n        }\\n        \\n        while(p2.parent !== p2){\\n            p2 = p2.parent;\\n        }\\n        \\n        if(p1 !== p2){\\n            if(p1.size > p2.size){\\n                p2.parent = p1;\\n                p2.size = 0;\\n                p1.size = p1.size+1;\\n            }\\n            else {\\n                p1.parent = p2;\\n                p1.size = 0;\\n                p2.size = p2.size+1;\\n            }\\n        }\\n        \\n       "]}
{"id": "1037", "ref_js": ["var bagOfTokensScore = function(tokens, power) {\\n    tokens.sort((a, b) => a - b);\\n    \\n    let score = 0, max = 0, left = 0, right = tokens.length - 1;\\n    \\n    while(left <= right) {\\n        if(power >= tokens[left]) {\\n            power -= tokens[left];\\n            score++;\\n            left++; \\n        } else if(score >= 1) {\\n            power += tokens[right];\\n            score--;\\n            right--;\\n        } else {\\n            break;\\n        }\\n        \\n        max = Math.max(max, score);\\n    }\\n    \\n    return max;\\n};", "var bagOfTokensScore = function(tokens, power) {\\n    let score = 0;\\n    \\n\\t", "var bagOfTokensScore = function(tokens, power) {\\n    tokens.sort((a, b) => a - b);\\n    \\n    let score = 0, max = 0, left = 0, right = tokens.length - 1;\\n    \\n    while(left <= right) {\\n        if(power >= tokens[left]) {\\n            power -= tokens[left];\\n            score++;\\n            left++; \\n        } else if(score >= 1) {\\n            power += tokens[right];\\n            score--;\\n            right--;\\n        } else {\\n            break;\\n        }\\n        \\n        max = Math.max(max, score);\\n    }\\n    \\n    return max;\\n};"]}
{"id": "1038", "ref_js": ["var largestTimeFromDigits = function(arr) {\\n    let comp = arr.sort().join(\\'\\');\\n    for(let i = 23; i >= 0; i--){\\n        for(let j = 59; j >= 0; j--){\\n            if(comp === [Math.floor(i / 10), i % 10, Math.floor(j / 10), j % 10].sort().join(\\'\\'))\\n            return \\'\\' + Math.floor(i / 10) + i % 10 + \\':\\' + Math.floor(j / 10) + j % 10;\\n        }\\n    } \\n    return \\'\\';\\n};", "var largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; ", "var largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};"]}
{"id": "1039", "ref_js": ["var deckRevealedIncreasing = function (deck) {\\nlet sortedArray =deck.sort((a,b)=>a-b)\\nlet res=[]\\nlet generatedArray =[]\\n    for(let j=0;j<sortedArray.length;j++){\\n        generatedArray.push(j)\\n    }\\n    for(let j=0;j<sortedArray.length;j++){\\n        for(let i=0;i<generatedArray.length;i++){\\n            let shift =generatedArray.shift()\\n           ", "var deckRevealedIncreasing = function(deck) {\\n    let stack = deck.sort((a, b) => b - a); ", "var deckRevealedIncreasing = function (deck) {\\nlet sortedArray =deck.sort((a,b)=>a-b)\\nlet res=[]\\nlet generatedArray =[]\\n    for(let j=0;j<sortedArray.length;j++){\\n        generatedArray.push(j)\\n    }\\n    for(let j=0;j<sortedArray.length;j++){\\n        for(let i=0;i<generatedArray.length;i++){\\n            let shift =generatedArray.shift()\\n           "]}
{"id": "1040", "ref_js": ["var flipEquiv = function(root1, root2) {\\n    if (root1 == null && root2 == null) return true;\\n    if (root1 == null || root2 == null) return false;\\n    if (root1.val != root2.val) return false;\\n    \\n    const regular = flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right);\\n    const flipped = flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left);\\n  \\n    return regular || flipped;\\n};", "var flipEquiv = function(root1, root2) {\\n    if(!root1 || !root2){\\n        return !root1 && !root2;\\n    }\\n    if(root1.val !== root2.val){\\n        return false;\\n    }\\n    return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));\\n};", "var flipEquiv = function(root1, root2) {\\n    if(!root1 || !root2){\\n        return !root1 && !root2;\\n    }\\n    if(root1.val !== root2.val){\\n        return false;\\n    }\\n    return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));\\n};"]}
{"id": "1041", "ref_js": ["var canReorderDoubled = function(arr) {\\n    let count = new Map();\\n\\n    for (let num of arr) {\\n        count.set(num, (count.get(num) || 0) + 1);\\n    }\\n\\n    arr.sort((a, b) => Math.abs(a) - Math.abs(b));\\n\\n    for (let num of arr) {\\n        if (count.get(num) === 0) continue;\\n\\n        let double = num * 2;\\n\\n    if (!count.has(double) || count.get(double) === 0) return false;\\n\\n        count.set(num, count.get(num) - 1);\\n        count.set(double, count.get(double) - 1);\\n    }\\n  return true;\\n};", "var canReorderDoubled = function(arr) {\\n    const fm={};", "var canReorderDoubled = function(arr) {\\n    let count = new Map();\\n\\n    for (let num of arr) {\\n        count.set(num, (count.get(num) || 0) + 1);\\n    }\\n\\n    arr.sort((a, b) => Math.abs(a) - Math.abs(b));\\n\\n    for (let num of arr) {\\n        if (count.get(num) === 0) continue;\\n\\n        let double = num * 2;\\n\\n    if (!count.has(double) || count.get(double) === 0) return false;\\n\\n        count.set(num, count.get(num) - 1);\\n        count.set(double, count.get(double) - 1);\\n    }\\n  return true;\\n};"]}
{"id": "1042", "ref_js": ["var minDeletionSize = function(strs) {\\n    const length = strs.length;\\n    let inOrder = true, count = 0, deleteIndex = 0;\\n    while(strs[0].length > 0) {\\n        inOrder = true;\\n        for(let i=0; i<length; i++) {\\n            if(strs[i] > strs[i+1]) {\\n                inOrder = false;\\n                for(let index = 0; index<strs[i].length;index++) {\\n                    if(strs[i][index] > strs[i+1][index]) {\\n                        deleteIndex = index;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        for(let i=0; i<length; i++) {\\n            strs[i] = strs[i].substring(0,deleteIndex) + strs[i].substring(deleteIndex+1);\\n        }\\n        if(inOrder) {\\n            break;\\n        } \\n        else {\\n            count++;\\n        }\\n    }\\n    return count;    \\n};", "var minDeletionSize = function(strs) {\\n   let n = strs[0].length;\\n   let ans = 0;\\n   let sorted = new Array(strs.length - 1).fill(false);\\n\\n   for(let j = 0; j < n; ++j){\\n       let i;\\n       for(i = 0; i + 1 < strs.length; ++i){\\n        if(!sorted[i] && strs[i].charAt(j) > strs[i + 1].charAt(j)){\\n               ++ans;\\n               break;\\n           }\\n       }\\nif(i + 1 === strs.length){\\nfor(i = 0; i + 1 < strs.length; ++i){\\nsorted[i] = sorted[i] || strs[i].charAt(j) < strs[i + 1].charAt(j);\\n           }\\n       }\\n   } \\n   return ans;\\n};", "var minDeletionSize = function(strs) {\\n    const length = strs.length;\\n    let inOrder = true, count = 0, deleteIndex = 0;\\n    while(strs[0].length > 0) {\\n        inOrder = true;\\n        for(let i=0; i<length; i++) {\\n            if(strs[i] > strs[i+1]) {\\n                inOrder = false;\\n                for(let index = 0; index<strs[i].length;index++) {\\n                    if(strs[i][index] > strs[i+1][index]) {\\n                        deleteIndex = index;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        for(let i=0; i<length; i++) {\\n            strs[i] = strs[i].substring(0,deleteIndex) + strs[i].substring(deleteIndex+1);\\n        }\\n        if(inOrder) {\\n            break;\\n        } \\n        else {\\n            count++;\\n        }\\n    }\\n    return count;    \\n};"]}
{"id": "1043", "ref_js": ["var prisonAfterNDays = function(cells, N) {\\n    let nextDay = function(cells) {\\n        let newPrison = \"\";\\n        for (let i=0;i<cells.length;i++) {\\n            if (cells[i-1]==cells[i+1]) newPrison+=\\'1\\';\\n            else newPrison+=\\'0\\';\\n        }\\n        return newPrison;\\n    }\\n    let prison = [...cells].join(\\'\\');\\n    let history = [];\\n    while (N--) {\\n        prison = nextDay(prison);\\n        let lookUp = history.indexOf(prison); ", "var prisonAfterNDays = function(cells, n) {\\n  n = n % 14 || 14;\\n  while(n--){\\n      let prev = [...cells]\\n      for(let i = 0; i < 8; i++){\\n          cells[i] = Math.floor(prev[i - 1] === prev[i + 1]);\\n      }\\n  }    \\n  return cells;\\n};", "var prisonAfterNDays = function(cells, n) {\\n  n = n % 14 || 14;\\n  while(n--){\\n      let prev = [...cells]\\n      for(let i = 0; i < 8; i++){\\n          cells[i] = Math.floor(prev[i - 1] === prev[i + 1]);\\n      }\\n  }    \\n  return cells;\\n};"]}
{"id": "1044", "ref_js": ["var isCompleteTree = function(root) {\\n    \\n    ", "var isCompleteTree = function(root) {\\n    ", "var isCompleteTree = function(root) {\\n    \\n    "]}
{"id": "1045", "ref_js": ["var regionsBySlashes = function(grid) {\\n    var n = grid.length;\\n    if (n === 1) return grid[0][0] === \\' \\' ? 1 : 2;\\n    var ds = new DS(n * n * 2);\\n    for (var i = 0; i < n; i++) {\\n        for (var j = 0; j < n; j++) {\\n            var [left, right] = getKeys(i, j, n);\\n\\t\\t\\t", "var regionsBySlashes = function(grid) {\\n    var n = grid.length;\\n    if (n === 1) return grid[0][0] === \\' \\' ? 1 : 2;\\n    var ds = new DS(n * n * 2);\\n    for (var i = 0; i < n; i++) {\\n        for (var j = 0; j < n; j++) {\\n            var [left, right] = getKeys(i, j, n);\\n\\t\\t\\t", "var regionsBySlashes = function(grid) {\\n    var n = grid.length;\\n    if (n === 1) return grid[0][0] === \\' \\' ? 1 : 2;\\n    var ds = new DS(n * n * 2);\\n    for (var i = 0; i < n; i++) {\\n        for (var j = 0; j < n; j++) {\\n            var [left, right] = getKeys(i, j, n);\\n\\t\\t\\t"]}
{"id": "1046", "ref_js": ["var maxWidthRamp = function(nums) {\\n    let maxWidth = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        let j = nums.length - 1;\\n        while(j > i && nums[j] < nums[i]) j--;\\n        maxWidth = Math.max(maxWidth, j - i);\\n    }   \\n    return maxWidth;\\n};", "var maxWidthRamp = function(nums) {\\n    let maxWidth = 0;\\n    for(let i=0; i<nums.length; i++){\\n        let j = nums.length - 1;\\n        while(j > i && nums[j] < nums[i]){\\n            j--;\\n        }\\n        maxWidth = Math.max(maxWidth, j-i);\\n    }\\n    return maxWidth;\\n};", "var maxWidthRamp = function(nums) {\\n    let maxWidth = 0;\\n    for(let i=0; i<nums.length; i++){\\n        let j = nums.length - 1;\\n        while(j > i && nums[j] < nums[i]){\\n            j--;\\n        }\\n        maxWidth = Math.max(maxWidth, j-i);\\n    }\\n    return maxWidth;\\n};"]}
{"id": "1047", "ref_js": ["var minAreaFreeRect = function(points) {\\n    const diagonalMap = new Map();\\n    let result = Infinity;\\n\\n    for (let a = 0; a < points.length - 1; a++) {\\n        const [x1, y1] = points[a];\\n        for (let b = a + 1; b < points.length; b++) {\\n            const [x2, y2] = points[b];\\n            const diagonal = calculateeDiagonal(x1, y1, x2, y2);\\n            const centerX = (x1 + x2) / 2;\\n            const centerY = (y1 + y2) / 2;\\n            const key = `${diagonal}_${centerX}_${centerY}`;\\n            const vectors = diagonalMap.get(key) ?? [];\\n\\n            vectors.push({ x1, x2, y1, y2 });\\n            diagonalMap.set(key, vectors);\\n        }\\n    }\\n\\n    for (const [key, vector] of diagonalMap) {\\n        if (vector.length < 2) continue;\\n        for (let a = 0; a < vector.length - 1; a++) {\\n            const vectorA = vector[a];\\n            for (let b = a + 1; b < vector.length; b++) {\\n                const vectorB = vector[b];\\n                const w = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x1, vectorB.y1));\\n                const h = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x2, vectorB.y2));\\n\\n                result = Math.min(result, w * h);\\n            }\\n        }\\n    }\\n    return result === Infinity ? 0 : result;\\n\\n    function calculateeDiagonal(x1, y1, x2, y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n};", "var minAreaFreeRect = function(points) {\\n    let len = points.length;\\n    \\n    if (len < 4) return 0;\\n    \\n    ", "var minAreaFreeRect = function(points) {\\n    let len = points.length;\\n    \\n    if (len < 4) return 0;\\n    \\n    "]}
{"id": "1048", "ref_js": ["var spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};", "var spellchecker = function(wordlist, queries) {\\n    let baseList = new Set(wordlist.reverse());\\n    let loweredList = wordlist.reduce((map, word) => (map[normalize(word)] = word, map), {});\\n    let replacedList = wordlist.reduce((map, word) => (map[repVowels(word)] = word, map), {});\\n\\n    return queries.map(word => (\\n        baseList.has(word) && word ||\\n        loweredList[normalize(word)] ||\\n        replacedList[repVowels(word)] ||\\n        \\'\\'\\n    ));\\n\\n    function normalize(word) {\\n        return word.toLowerCase();\\n    }\\n\\n    function repVowels(word) {\\n        return normalize(word).replace(/[aeiou]/g, \\'a\\');\\n    }\\n};", "var spellchecker = function(wordlist, queries) {\\n    const wordSet = new Set(wordlist);\\n    const lowerMap = new Map();\\n    const vowelMap = new Map();\\n    const regex = /[aeiou]/g;\\n\\n    wordlist.forEach(word => {\\n        const lower = word.toLowerCase();\\n        const vowel = lower.replace(regex, \\'_\\');\\n\\n        !lowerMap.has(lower) && lowerMap.set(lower, word);\\n        !vowelMap.has(vowel) && vowelMap.set(vowel, word);\\n    });\\n\\n    return queries.map(word => {\\n        if (wordSet.has(word)) return word;\\n\\n        const lower = word.toLowerCase();\\n        if (lowerMap.has(lower)) return lowerMap.get(lower);\\n\\n        const vowel = lower.replace(regex, \\'_\\');\\n        if (vowelMap.has(vowel)) return vowelMap.get(vowel);\\n\\n        return \\'\\';\\n    });\\n};"]}
{"id": "1049", "ref_js": ["var numsSameConsecDiff = function(n, k) {\\n   let list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n    while(--n > 0){\\n        let tmp = []\\n        for(let val of list){\\n            let rem = val % 10\\n            if(rem + k < 10)     tmp.push(val * 10 + rem + k)\\n            if(k != 0 && rem - k >= 0)   tmp.push(val * 10 + rem - k)\\n        }\\n        list = tmp\\n    }\\n    return list\\n};", "var numsSameConsecDiff = function(n, k) {\\n    let st = new Set()\\n    let val=0\\n    function help(num){\\n        if((\\'\\'+num).length == n){\\n            st.add(num)\\n            return\\n        }\\n        val=num % 10\\n        if( val+k <= 9) help(num * 10 + val + k)\\n        val=num % 10\\n        if(val-k >= 0 ) help(num * 10 + val - k)\\n    }\\n    for(let q=1; q<10;q++) help(q)\\n    return [...st]\\n};", "var numsSameConsecDiff = function(n, k) {\\n    let list = [1, 2, 3, 4, 5, 6, 7, 8, 9]; "]}
{"id": "1050", "ref_js": ["var pancakeSort = function(arr) {\\n    const result = [];\\n    const reversePancake = (start, end) => {\\n        while (start < end) {\\n            [arr[start], arr[end]] = [arr[end], arr[start]];\\n            start += 1;\\n            end -= 1;\\n        }\\n    };", "var pancakeSort = function (arr) {\\n    const result = [];\\n    const reversePancake = (start, end) => {\\n        while (start < end) {\\n            [arr[start], arr[end]] = [arr[end], arr[start]];\\n            start += 1;\\n            end -= 1;\\n        }\\n    };", "var pancakeSort = function(arr) {\\n    let res = [];\\n    for(let i = arr.length - 1; i > 0; i--){\\n        for(let j = 0; j <= i; j++){\\n            if(arr[j] === i + 1){\\n                flip(arr, j);\\n                res.push(j + 1);\\n                break;\\n            }\\n        }\\n        flip(arr, i);\\n        res.push(i + 1);\\n    }\\n    return res;\\n};"]}
{"id": "1051", "ref_js": ["var powerfulIntegers = function(x, y, bound) {\\n    let ans = new Set()\\n    for (let xi = 1; xi < bound; xi *= x) {\\n        for (let yj = 1; xi + yj <= bound; yj *= y) {\\n            ans.add(xi + yj)\\n            if (y === 1) break\\n        }\\n        if (x === 1) break\\n    }\\n    return Array.from(ans)\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        ans, xi = set(), 1\\n        while xi < bound:\\n            yj = 1\\n            while xi + yj <= bound:\\n                ans.add(xi + yj)\\n                if y == 1: break\\n                yj *= y\\n            if x == 1: break\\n            xi *= x\\n        return list(ans)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\\n        Set<Integer> ans = new HashSet<>();\\n        for (int xi = 1; xi < bound; xi *= x) {\\n            for (int yj = 1; xi + yj <= bound; yj *= y) {\\n                ans.add(xi + yj);\\n                if (y == 1) break;\\n            }\\n            if (x == 1) break;\\n        }\\n        return new ArrayList<Integer>(ans);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> powerfulIntegers(int x, int y, int bound) {\\n        unordered_set<int> ans;\\n        for (int xi = 1; xi < bound; xi *= x) {\\n            for (int yj = 1; xi + yj <= bound; yj *= y) {\\n                ans.insert(xi + yj);\\n                if (y == 1) break;\\n            }\\n            if (x == 1) break;\\n        }\\n        return vector<int>(ans.begin(), ans.end());\\n    }\\n};", "var powerfulIntegers = function(x, y, bound) {\\n   let res = new Set();\\n   for(let xi = 1; xi < bound; xi *= x){\\n       for(let yj = 1; xi + yj <= bound; yj *= y){\\n           res.add(xi + yj);\\n           if(y === 1) break;\\n       }\\n       if(x === 1) break;\\n   } \\n   return Array.from(res);\\n};", "var powerfulIntegers = function(x, y, b) {\\n    function getBaseLog(x, y) {\\n        return Math.log(y) / Math.log(x);\\n    }\\n    let arr = [],res = []\\n    let maxi = x===1 ? 0 : Math.round(getBaseLog(x,b-1))\\n    let maxj = y===1 ? 0 : Math.round(getBaseLog(y,b-1))\\n    for(i=0;i<=maxi;i++) {\\n        for(j=0;j<=maxj;j++) {\\n            let sum = Math.pow(x,i) + Math.pow(y,j)\\n            if(sum<=b) {\\n                arr.push(sum)\\n            } else {break}\\n        }\\n    }\\n    for(i=0;i<arr.length;i++) {\\n        if(res.includes(arr[i])) {continue};"]}
{"id": "1052", "ref_js": ["var flipMatchVoyage = function (root, voyage) {\\n  const res = [];\\n\\n  const preorderTraverse = (node) => {\\n    if (!node) return true;\\n    if (voyage[0] !== node.val) return false;\\n    voyage.shift();\\n\\n    if (node.left && node?.left.val !== voyage[0]) {\\n      res.push(node.val);\\n      return preorderTraverse(node.right) && preorderTraverse(node.left);\\n    }\\n    return preorderTraverse(node.left) && preorderTraverse(node.right);\\n  };", "var flipMatchVoyage = function(root, voyage) {\\n   let res = [], vix = 0;\\n   function DFS(node){\\n       if(!node || res[0] === -1) return;\\n       if(node.val !== voyage[vix++]) res = [-1];\\n       else if(node.left && node.left.val !==voyage[vix]){\\n           res.push(node.val);\\n           DFS(node.right);\\n           DFS(node.left);\\n       } else {\\n           DFS(node.left);\\n           DFS(node.right);\\n       }\\n   }  \\n   DFS(root);\\n   return res;\\n};", "var flipMatchVoyage = function(root, voyage) {\\n   let res = [], vix = 0;\\n   function DFS(node){\\n       if(!node || res[0] === -1) return;\\n       if(node.val !== voyage[vix++]) res = [-1];\\n       else if(node.left && node.left.val !==voyage[vix]){\\n           res.push(node.val);\\n           DFS(node.right);\\n           DFS(node.left);\\n       } else {\\n           DFS(node.left);\\n           DFS(node.right);\\n       }\\n   }  \\n   DFS(root);\\n   return res;\\n};"]}
{"id": "1053", "ref_js": ["var kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]))\\n\\n    return points.slice(0,K)\\n};", "var kClosest = function(points, k) {\\n    const res = []\\n    const minHeap = new MinPriorityQueue()\\n    points.forEach(p => {\\n        const distanceFromOrigin = Math.sqrt(p[0] * p[0] + p[1] * p[1])\\n        minHeap.enqueue(p, distanceFromOrigin)\\n    })\\n    while(res.length < k) res.push(minHeap.dequeue().element)\\n    return res\\n    ", "var kClosest = function(points, k) {\\n    "]}
{"id": "1054", "ref_js": ["var subarraysDivByK = function(nums, k) {\\n    let map ={}\\n    map[0] = 1;\\n    let count = 0;\\n    let total = 0;\\n\\n    for(let num of nums){\\n        count = (count+num) %k;\\n        if(count<0) count +=k;\\n        if(map[count]) total += map[count]\\n        map[count] = map[count] ? map[count] + 1 : 1\\n    }\\n    return total;\\n};", "var subarraysDivByK = function(nums, k) {\\n    let n = nums.length;\\n    let prefixMod = 0;\\n    let result = 0;\\n    let modGroups = new Array(k);\\n    modGroups[0] = 1;\\n    for (let num of nums) {\\n        prefixMod = (prefixMod + num % k + k) % k;\\n        result += modGroups[prefixMod] || 0;\\n        modGroups[prefixMod] = (modGroups[prefixMod] || 0) + 1;\\n    }\\n    return result;\\n};", "var subarraysDivByK = function(nums, k) {\\n    let map ={}\\n    map[0] = 1;\\n    let count = 0;\\n    let total = 0;\\n\\n    for(let num of nums){\\n        count = (count+num) %k;\\n        if(count<0) count +=k;\\n        if(map[count]) total += map[count]\\n        map[count] = map[count] ? map[count] + 1 : 1\\n    }\\n    return total;\\n};"]}
{"id": "1055", "ref_js": ["var maxTurbulenceSize = function(arr) {\\n    if(arr.length <= 1) return arr.length;\\n    let[curr, max] = [1, 1];\\n    let lastSign = 0;\\n\\n    for(let i = 1; i < arr.length; i++){\\n        let sign = Math.sign(arr[i] - arr[i - 1]);\\n        if(sign === 0) curr = 1;\\n        else if(sign !== lastSign) curr++;\\n        else curr = 2;\\n        max = Math.max(max, curr);\\n        lastSign = sign;\\n    } \\n    return max;\\n};", "var maxTurbulenceSize = function(arr) {\\n    let l = 0;\\n    let r = 1;\\n    let prevSign = \"\";\\n    let res = 1;\\n\\n    while (r < arr.length) {\\n\\n        if (arr[r - 1] < arr[r] && prevSign !== \">\") {\\n            res = Math.max(res, r - l + 1);\\n            prevSign = \">\";\\n            r++\\n        } else if (arr[r - 1] > arr[r] && prevSign !== \"<\") {\\n            res = Math.max(res, r - l + 1);\\n            prevSign = \"<\";\\n            r++\\n        } else {\\n            r = arr[r - 1] === arr[r] ? r + 1: r;\\n            prevSign = \"\",\\n            l = r - 1\\n        }\\n\\n    }\\n\\n    return res;\\n};", "var maxTurbulenceSize = function (a) {\\n  let goingUp;\\n  let cc = 1;\\n  let maxcc = 1;\\n  a.forEach((e, i) => {\\n    if (!i) return;\\n\\n    if (goingUp === undefined) {\\n      if (a[i - 1] === e) {\\n        goingUp = undefined;\\n        cc = 1;\\n      } else {\\n        goingUp = a[i - 1] < e;\\n        cc++;\\n        maxcc = Math.max(maxcc, cc);\\n      }\\n    } else if (goingUp) {\\n      "]}
{"id": "1056", "ref_js": ["var distributeCoins = function(root) {\\n    var moves = 0;\\n    postorder(root);\\n    return moves;\\n    \\n    function postorder(node){\\n        if(!node)\\n            return 0;\\n        \\n        const subTotal = postorder(node.left) + postorder(node.right);\\n        const result = node.val - 1 + subTotal;\\n        moves += Math.abs(result);\\n        \\n        return result;\\n            \\n    }\\n};", "var distributeCoins = function(root) {\\n    let moves = 0;\\n    function DFS(root){\\n        if(!root) return 0;\\n        let coinsFromLeft = DFS(root.left);\\n        let coinsFromRight = DFS(root.right);\\n        moves += Math.abs(coinsFromLeft) + Math.abs(coinsFromRight);\\n        return root.val + coinsFromLeft + coinsFromRight - 1;\\n    }\\n    DFS(root);\\n    return moves;\\n};", "var distributeCoins = function(root) {\\n    let moves = 0\\n    function dfs(root){\\n        if(!root) return 0\\n        const coinsFromLeft = dfs(root.left) "]}
{"id": "1058", "ref_js": ["var mincostTickets = function(days, costs) {\\n    \\n    ", "var mincostTickets = function (days, costs) {\\n  ", "var mincostTickets = function (days, costs) {\\n  "]}
{"id": "1059", "ref_js": ["var strWithout3a3b = function(a, b) {\\n    if(a === 0) return \\'b\\'.repeat(b);\\n    if(b === 0) return \\'a\\'.repeat(a);\\n    if(a < b) return \\'bba\\' + strWithout3a3b(a - 1, b - 2);\\n    if(a > b) return \\'aab\\' + strWithout3a3b(a - 2, b - 1);\\n    return \\'ab\\' + strWithout3a3b(a - 1, b - 1);\\n};", "var strWithout3a3b = function(a, b) {\\n    let string=[];\\n    let countA=a;\\n    let countB=b;\\n    var iterate = function(abc) {\\n        if(!(string[0]==abc)||!(string[1]==abc)){string.splice(0,0,abc);return string;}\\n        for(let i=2;i<string.length-2;i++){\\n            if(string[i]==abc&&string[i+1]==abc){\\n                continue;\\n            } \\n            else if(string[i]==abc&&string[i-1]==abc) {\\n                continue;\\n            }\\n            else if(string[i-1]==abc&&string[i-2]==abc){\\n                continue;\\n            }\\n            else {\\n                string.splice(i+1,0,abc);return;\\n        }\\n    }\\n        string.push(abc);return;\\n    \\n    }\\n        while(countA>0||countB>0){\\n            console.log(countA,countB,string,string.length)\\n            if(countA>0&&countB>0){\\n                countA--;countB--;\\n                string.push(\"a\",\"b\");\\n                continue;\\n            } if(countA==0){\\n                if(string.length>1){if(string[string.length-1]==\"b\"&&string[string.length-2]==\"b\"){countB--;iterate(\"b\");continue}else{countB--;iterate(\"b\");continue}} else{countB--;string.push(\"b\");continue}\\n            }if(countB==0){\\n                if(string.length>1){if(string[string.length-1]==\"a\"&&string[string.length-2]==\"a\"){countA--;iterate(\"a\");continue}else{countA--;iterate(\"a\");continue}} else{countA--;string.push(\"a\");continue}\\n            }\\n        }\\n\\n    return string.join(\"\")\\n};", "var strWithout3a3b = function(a, b) {\\n    if (a === 0) return \\'b\\'.repeat(b);\\n    if (b === 0) return \\'a\\'.repeat(a);\\n    if (a < b) return \\'bba\\' + strWithout3a3b(a - 1, b - 2);\\n    if (a > b) return \\'aab\\' + strWithout3a3b(a - 2, b - 1);\\n    return \\'ab\\' + strWithout3a3b(a - 1, b - 1);\\n};"]}
{"id": "1060", "ref_js": ["var sumEvenAfterQueries = function(nums, queries) {\\n    const answers = [];\\n    let evenSum = 0;\\n    \\n    for(let i = 0; i < queries.length; i++) {\\n        const query = queries[i];\\n        \\n        nums[query[1]] += query[0];\\n        \\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % 2 === 0) {\\n                evenSum += nums[j];\\n            }\\n        }\\n        \\n        answers.push(evenSum);\\n        evenSum = 0;\\n    }\\n    \\n    return answers;\\n};", "var sumEvenAfterQueries = function(nums, queries) {\\n    const ans = [];\\n    let sum = 0;\\n    \\n    for (const num of nums) {\\n        if (num % 2 === 0) {\\n            sum +=  num;\\n        }\\n    }\\n    \\n    for (const [val, idx] of queries) {\\n        if (nums[idx] % 2 === 0) {\\n            sum -= nums[idx];\\n        }\\n        \\n        nums[idx] += val;\\n        \\n        if (nums[idx] % 2 === 0) {\\n            sum += nums[idx];\\n        }\\n        \\n        ans.push(sum);\\n    }\\n    \\n    return ans;\\n};", "var sumEvenAfterQueries = function(nums, queries) {\\n    let result = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        let col = queries[i][1];\\n        nums[col] = nums[col] + queries[i][0];\\n        result[i] = computeEvenSum(nums);\\n    }\\n    return result;\\n};"]}
{"id": "1061", "ref_js": ["var intervalIntersection = function (firstList, secondList) {\\n  const fLen = firstList.length\\n  const sLen = secondList.length\\n\\n  let [i, j] = [0, 0]\\n\\n  const res = []\\n\\n  while (i < fLen && j < sLen) {\\n    ", "var intervalIntersection = function(A, B) {\\n    let Ai = 0, Bi = 0;\\n    let res = [];\\n    \\n    while (Ai < A.length && Bi < B.length) {\\n        let maxStart = Math.max(A[Ai][0], B[Bi][0]);\\n        let minEnd = Math.min(A[Ai][1], B[Bi][1]);\\n        \\n        if (maxStart <= minEnd) res.push([maxStart, minEnd]) ", "var intervalIntersection = function(firstList, secondList) {\\n    \\n    let firstCounter = 0, secondCounter = 0;\\n    let firstListLen = firstList.length;\\n    let secondListLength = secondList.length;\\n\\n    let res = [];\\n    \\n    while( firstCounter < firstListLen &&  secondCounter < secondListLength ){\\n       \\n       let [start1, end1] =  firstList [firstCounter];\\n       let [start2, end2] =  secondList[secondCounter];\\n       "]}
{"id": "1062", "ref_js": ["var smallestFromLeaf = function(root) {\\n    let final = \\'\\';\\n    function dfs(node=root, item=\\'\\') {\\n        if (!node) return;\\n        item = String.fromCharCode((node.val + 97 + \\'\\')) + item;\\n        if ((final === \\'\\' || item < final) && !node.left && !node.right) {\\n            final = item;\\n        }\\n        dfs(node.left, item);\\n        dfs(node.right, item);\\n    }\\n    dfs();\\n    return final;\\n};", "var smallestFromLeaf = function(root) {\\n    let char = {\\n                    \"a\":0,\"b\":1,\"c\":2,\"d\":3,\"e\":4,\"f\":5,\"g\":6,\"h\":7,\"i\":8,\"j\":9,\"k\":10,\"l\":11,\"m\":12,\\n                    \"n\":13,\"o\":14,\"p\":15,\"q\":16,\"r\":17,\"s\":18,\"t\":19,\"u\":20,\"v\":21,\"w\":22,\"x\":23,\"y\":24,\\n                    \"z\":25    \\n                 }\\n    let ansStr = [];\\n    function preOrder(node,currStr){\\n        if(node){\\n            currStr.push(getKeyByValue(char,node.val));\\n            if(node.left==null && node.right==null){\\n                ansStr.push(currStr.reverse().join(\"\"));\\n            } \\n                \\n            preOrder(node.left,[...currStr]);\\n            preOrder(node.right,[...currStr]);\\n        }\\n    }\\n    preOrder(root,[])\\n\\n    ", "var smallestFromLeaf = function(root) {\\n    let result = \\'\\';\\n    const originCharCode = \\'a\\'.charCodeAt(0);\\n    const findSmallest = (node = root, current = \\'\\') => {\\n        if (!node) return;\\n        const { val, left, right } = node;\\n        const char = String.fromCharCode(val + originCharCode);\\n        const next = `${char}${current}`;\\n\\n        if (!left && !right && (next < result || !result)) result = next;\\n        findSmallest(left, next);\\n        findSmallest(right, next);\\n    };"]}
{"id": "1063", "ref_js": ["var equationsPossible = function(equations) {\\n    const A = \\'a\\'.charCodeAt(0);\\n    const n = equations.length;\\n    const parent = new Array(26).fill(0).map((_, i) => i++);\\n    \\n    const find = (x) => {\\n        if (parent[x] === x) {\\n            return x;\\n        } else {\\n            return parent[x] = find(parent[x]);\\n        }\\n    }\\n    \\n    for (const eq of equations) {\\n        if (eq.charAt(1) === \"=\") {\\n            parent[find(eq.charCodeAt(0) - A)] = find(eq.charCodeAt(3) - A); \\n        }\\n    }\\n    \\n    for (const eq of equations) {\\n        if (eq.charAt(1) === \"!\" && find(eq.charCodeAt(0) - A) === find(eq.charCodeAt(3) - A)) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};", "var equationsPossible = function(equations) {\\n    const A = \\'a\\'.charCodeAt(0);\\n    const n = equations.length;\\n    const parent = new Array(26).fill(0).map((_, i) => i++);\\n    \\n    const find = (x) => {\\n        if (parent[x] === x) {\\n            return x;\\n        } else {\\n            return parent[x] = find(parent[x]);\\n        }\\n    }\\n    \\n    for (const eq of equations) {\\n        if (eq.charAt(1) === \"=\") {\\n            parent[find(eq.charCodeAt(0) - A)] = find(eq.charCodeAt(3) - A); \\n        }\\n    }\\n    \\n    for (const eq of equations) {\\n        if (eq.charAt(1) === \"!\" && find(eq.charCodeAt(0) - A) === find(eq.charCodeAt(3) - A)) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};", "var equationsPossible = function(equations) {\\n    const A = \\'a\\'.charCodeAt(0);\\n    const n = equations.length;\\n    const parent = new Array(26).fill(0).map((_, i) => i++);\\n    \\n    const find = (x) => {\\n        if (parent[x] === x) {\\n            return x;\\n        } else {\\n            return parent[x] = find(parent[x]);\\n        }\\n    }\\n    \\n    for (const eq of equations) {\\n        if (eq.charAt(1) === \"=\") {\\n            parent[find(eq.charCodeAt(0) - A)] = find(eq.charCodeAt(3) - A); \\n        }\\n    }\\n    \\n    for (const eq of equations) {\\n        if (eq.charAt(1) === \"!\" && find(eq.charCodeAt(0) - A) === find(eq.charCodeAt(3) - A)) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};"]}
{"id": "1064", "ref_js": ["var brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};", "var brokenCalc = function(startValue, target) {\\n    let steps = 0;\\n    \\n    while(target !== startValue){\\n\\n        if(startValue > target){\\n            return steps  + startValue - target;\\n        }\\n        if(target %2 === 0){\\n            target /= 2;\\n        }else {\\n            target += 1;\\n            \\n        }\\n        steps++;\\n    }\\n    return steps\\n};", "var brokenCalc = function(startValue, target, operations = 0) {\\n  const queue = new Queue([target]);\\n  while (!queue.isEmpty()) {\\n    const curend = queue.dequeue();\\n    if (curend <= startValue) return  operations + startValue - curend\\n    if (!(curend % 2)) queue.enqueue(curend / 2)\\n    else queue.enqueue(curend + 1)\\n    operations++\\n  }\\n};"]}
{"id": "1065", "ref_js": ["var orangesRotting = function(grid) {\\n    if (!hasFreshOranges(grid)) {\\n        return 0;\\n    }\\n    const rottenOranges = getRottenOranges(grid);\\n    const minutes = rottenOranges.length > 0\\n        ? bfs(grid, rottenOranges)\\n        : 0;\\n    return hasFreshOranges(grid) ? -1 : minutes;\\n};", "var orangesRotting = function(grid) {\\n        let ROWS = grid.length;\\n        let COLS = grid[0].length;\\n        let timestamp = 2;\\n        while (bfs(timestamp, grid, ROWS, COLS)) {\\n            timestamp++;            \\n        }\\n\\n        ", "var orangesRotting = function (grid) {\\n    const qu = [];\\n    let noOfFreshOranges = 0;\\n    let time = 0;\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 2) qu.push([i, j]);\\n            if (grid[i][j] === 1) noOfFreshOranges++;\\n        }\\n    }\\n    \\n    while (qu.length) {\\n        const n = qu.length;\\n\\n        let freshOrngCount = 0;\\n        for (let i = 0; i < n; i++) {\\n            const [x, y] = qu.shift();\\n            "]}
{"id": "1066", "ref_js": ["var insertIntoMaxTree = function(r, val) {\\n   let root = r, x = null;\\n   while(r?.val > val){\\n       x = r;\\n       r = r.right;\\n   } \\n   let newNode = new TreeNode(val);\\n   newNode.left = r;\\n   if(x){\\n       x.right = newNode;\\n   } else {\\n       root = newNode;\\n   }\\n   return root;\\n};", "var insertIntoMaxTree = function (r, val) {\\n  let originalRoot = r;\\n  let p = null;\\n  while (r?.val > val) {\\n    p = r;\\n    r = r.right;\\n  }\\n  ", "var insertIntoMaxTree = function(root, val) {\\n  let node = new TreeNode(val);\\n  if(!root) return node;\\n  if(val > root.val) {\\n    node.left = root;\\n    return node;\\n  }\\n  else {\\n    root.right = insertIntoMaxTree(root.right, val);\\n    return root;\\n  }\\n};"]}
{"id": "1067", "ref_js": ["var isValid = function (s) {\\n  while (s.length) {\\n    if (s.indexOf(\"abc\") === -1) break;\\n    s = s.replaceAll(\"abc\", \"\");\\n  }\\n  return !s.length;\\n};", "var isValid = function(s) {\\n    ", "var isValid = function(s) {\\n    "]}
{"id": "1068", "ref_js": ["var longestOnes = function (nums, k) {\\n    let left = 0;\\n    let right = 0;\\n    let longest = 0;\\n    let zerosCount = 0; ", "var longestOnes = function(nums, k) {\\n\\n\\n    let start = 0 ;\\n    let count = 0 ;\\n    let longest  = 0 ;\\n    let flip = k;\\n\\n\\n    for(let windowEnd = 0 ; windowEnd < nums.length; windowEnd++)\\n    {\\n        const item = nums[windowEnd];\\n\\n        if(item === 1)\\n        {\\n            count++;\\n        }\\n        else if(item === 0 && flip!== 0)\\n        {\\n            count++;\\n            flip--;\\n        }\\n        else\\n        {\\n            longest = Math.max(count , longest);\\n            windowEnd = start;\\n            start++\\n            count = 0 ;\\n            flip = k\\n        }\\n\\n       \\n\\n    }\\n\\n   longest = Math.max(count , longest)\\n   return longest;\\n    \\n};", "var longestOnes = function (nums, k) {\\n    let left = 0;\\n    let right = 0;\\n    let longest = 0;\\n    let zerosCount = 0; "]}
{"id": "1069", "ref_js": ["var clumsy = function(n) {\\n    ", "var clumsy = function(n) {\\n   let res=0;\\n   if(n>=3){\\n       res+=Math.floor(n*(n-1)/(n-2));\\n       n-=3;\\n   }else{\\n       if(n==2){\\n           res+=n*(n-1);\\n       }else{\\n           res=1;\\n       }\\n       n=0;\\n   };", "var clumsy = function(n) {\\n   let res=0;\\n   if(n>=3){\\n       res+=Math.floor(n*(n-1)/(n-2));\\n       n-=3;\\n   }else{\\n       if(n==2){\\n           res+=n*(n-1);\\n       }else{\\n           res=1;\\n       }\\n       n=0;\\n   };"]}
{"id": "1070", "ref_js": ["var minDominoRotations = function(tops, bottoms) {\\n    const targetTop = tops[0], targetBtm = bottoms[0]; ", "var minDominoRotations = function(tops, bottoms) {\\n    const swaps = Math.min(\\n        minimum(tops[0], tops, bottoms),\\n        minimum(tops[0], bottoms, tops),\\n        minimum(bottoms[0], tops, bottoms),\\n        minimum(bottoms[0], bottoms, tops)\\n    );\\n\\n    return swaps === Infinity ? -1 : swaps;\\n\\n    function minimum(target, x, y, count = 0) {\\n        for(let i = 0; i < x.length; i++) {\\n            if(target !== x[i]) {\\n                if (target !== y[i]) return Infinity\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};", "var minDominoRotations = function(tops, bottoms) {\\n    const targetTop = tops[0], targetBtm = bottoms[0]; "]}
{"id": "1071", "ref_js": ["var bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};", "var bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};", "var bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};"]}
{"id": "1072", "ref_js": ["var numPairsDivisibleBy60 = function(time) {\\n    let num=0;\\n    let arr=new Array(60).fill(0);\\n\\n    for(let i of time){\\n        let k=i%60;\\n\\n        if(k===0)\\n            num+=arr[k];\\n        else\\n            num+=arr[60-k];\\n        \\n        arr[k]++;\\n    }\\n    return num;\\n};", "var numPairsDivisibleBy60 = function(time) {\\n    \\n    var mod_60 = ( x => x % 60 );\\n    \\n    ", "var numPairsDivisibleBy60 = function(time) {\\n    let result = 0;\\n    let seen = new Map();\\n    \\n    \\n    for(let t of time){\\n        let target = 60 - (t % 60 );\\n        \\n\\t\\t"]}
{"id": "1073", "ref_js": ["var shipWithinDays = function(w, d) {\\r\\n    function Days(mid){\\r\\n        let total=0;\\r\\n        let days=1;\\r\\n        for(let num of w){\\r\\n            total+=num;\\r\\n            if(total>mid){\\r\\n                total=num;\\r\\n                days+=1;\\r\\n            }\\r\\n        }\\r\\n        return days;\\r\\n    }\\r\\n    \\r\\n    let low=Math.max(...w);\\r\\n    let high=0;\\r\\n    for(let n of w) high+=n;\\r\\n    while(low<=high){\\r\\n\\r\\n        let mid=parseInt((low+high)/2);\\r\\n        let midDays=Days(mid);\\r\\n        if(midDays>d){\\r\\n            low=mid+1;\\r\\n        }else{\\r\\n            high=mid-1;\\r\\n        }\\r\\n    }\\r\\nreturn low;\\r\\n};", "var shipWithinDays = function (weights, days) {\\r\\n\\r\\n    const isValid = (weights, days, capacity) => {\\r\\n        let requiredDays = 1;\\r\\n        let currWeight = 0;\\r\\n\\r\\n        for (let x of weights) {\\r\\n            if (currWeight + x > capacity) {\\r\\n                currWeight = 0;\\r\\n                requiredDays++;\\r\\n            }\\r\\n            currWeight += x;\\r\\n        }\\r\\n        if (requiredDays > days) return false;\\r\\n        else return true;\\r\\n    }\\r\\n    let low = 0, high = 0;\\r\\n    for (let x of weights) {\\r\\n        low = Math.max(low, x);\\r\\n        high += x;\\r\\n    }\\r\\n    let res = high;\\r\\n    while (low <= high) {\\r\\n        let mid = low + Math.trunc((high - low) / 2);\\r\\n        if (isValid(weights, days, mid)) {\\r\\n            res = mid;\\r\\n            high = mid - 1;\\r\\n        } else low = mid + 1;\\r\\n    }\\r\\n    return res;\\r\\n};", "var shipWithinDays = function(w, d) {\\r\\n    function Days(mid){\\r\\n        let total=0;\\r\\n        let days=1;\\r\\n        for(let num of w){\\r\\n            total+=num;\\r\\n            if(total>mid){\\r\\n                total=num;\\r\\n                days+=1;\\r\\n            }\\r\\n        }\\r\\n        return days;\\r\\n    }\\r\\n    \\r\\n    let low=Math.max(...w);\\r\\n    let high=0;\\r\\n    for(let n of w) high+=n;\\r\\n    while(low<=high){\\r\\n\\r\\n        let mid=parseInt((low+high)/2);\\r\\n        let midDays=Days(mid);\\r\\n        if(midDays>d){\\r\\n            low=mid+1;\\r\\n        }else{\\r\\n            high=mid-1;\\r\\n        }\\r\\n    }\\r\\nreturn low;\\r\\n};"]}
{"id": "1074", "ref_js": ["var maxScoreSightseeingPair = function(values) {\\n    ", "var maxScoreSightseeingPair = function(values) {\\n    let prev = values[0];\\n    let res = -Infinity;\\n\\n    for (let i = 1; i < values.length; i++) {\\n        let num = values[i];\\n        res = Math.max(res, num - i + prev);\\n        prev = Math.max(prev, num + i);\\n    }\\n    return res;\\n};", "var maxScoreSightseeingPair = function(values) {\\n\\n    let prevMax = values[0], max = 0;\\n\\n    for(let i = 1; i < values.length; i++) {\\n\\n        prevMax--;\\n        max = Math.max(max, prevMax + values[i]);\\n        prevMax = Math.max(prevMax, values[i]);\\n    }\\n    \\n    return max;\\n};"]}
{"id": "1075", "ref_js": ["var smallestRepunitDivByK = function(k) {\\n    ", "var smallestRepunitDivByK = function (k) {\\n  if (k % 2 === 0 || k % 5 === 0) return -1;\\n  let remainder = 0;\\n  for (let length = 1; length <= k; length++) {\\n    remainder = (remainder * 10 + 1) % k;\\n    if (remainder === 0) return length;\\n  }\\n  return -1;\\n};", "var smallestRepunitDivByK = function (k) {\\n  if (k % 2 === 0 || k % 5 === 0) return -1;\\n  let remainder = 0;\\n  for (let length = 1; length <= k; length++) {\\n    remainder = (remainder * 10 + 1) % k;\\n    if (remainder === 0) return length;\\n  }\\n  return -1;\\n};"]}
{"id": "1076", "ref_js": ["var queryString = function(s, n) {\\n  ", "var queryString = function(s, n) {\\n    for (let num = n; num > 0; num--) {\\n        const binaryStr = num.toString(2);\\n\\n        if (!s.includes(binaryStr)) return false;\\n    }\\n    return true;\\n};", "var queryString = function(s, n) {\\n  "]}
{"id": "1077", "ref_js": ["var baseNeg2 = function(n) {\\n    if(n === 0) return \\'0\\';   ", "var baseNeg2 = function(n) {\\n    if(n==0){\\n        return \"0\"\\n    }\\n    let ans =\\'\\';\\n    while(n!=1){\\n        ans = Math.abs(n%-2).toString()+ans;\\n           n = Math.ceil(n/-2)\\n        \\n    }\\n    ans = \"1\"+ans;\\n    return ans;\\n};", "var baseNeg2 = function(n) {\\n    if(n==0){\\n        return \"0\"\\n    }\\n    let ans =\\'\\';\\n    while(n!=1){\\n        ans = Math.abs(n%-2).toString()+ans;\\n           n = Math.ceil(n/-2)\\n        \\n    }\\n    ans = \"1\"+ans;\\n    return ans;\\n};"]}
{"id": "1078", "ref_js": ["var nextLargerNodes = function(head) {\\n  let a = [];                ", "var nextLargerNodes = function(head) {\\n    let value = [] , nums = [] , size = 0 , i = 0 ; \\n    while(head){\\n        nums[size++] = head.val;  \\n        head = head.next; \\n    }  \\n    for(;;){ if(i == size) break; \\n        let max = nums[i];\\n        let prev = max; \\n        for(let j = i + 1; j < size ; ++j ){\\n            let val = nums[j]; \\n            if(val > max){\\n                max = val; \\n                break; \\n            }\\n        }\\n        max == prev ? value.push(0):value.push(max);\\n        ++i;\\n    }\\n    return value ; \\n};", "var nextLargerNodes = function(head) {\\n  let a = [];                "]}
{"id": "1079", "ref_js": ["var numEnclaves = function(grid) {\\n    const m = grid.length, n = grid[0].length;\\n\\n    ", "var numEnclaves = function (grid) {\\n    const col = grid.length;\\n    const row = grid[0].length;\\n\\n    ", "var numEnclaves = function (grid) {\\n  let landCellCount = 0; "]}
{"id": "1080", "ref_js": ["var camelMatch = function(q, p) {\\n    return q.map(s => (                    ", "var camelMatch = function(queries, pattern) {\\n   const res = [];\\n   for(let query of queries) {\\n          let j=0;\\n          let matchPattern = true;\\n          for(let i=0; i < query.length; i++) {\\n              let asciiCode = query[i].charCodeAt(0);\\n              let isLower = asciiCode >= 97 && asciiCode <= 122;\\n              if(!isLower && j === pattern.length) {\\n                  matchPattern = false;\\n                  break;\\n              }\\n              if(query[i] !== pattern[j] && isLower) continue;\\n              if(query[i] !== pattern[j] && !isLower) {\\n                 matchPattern = false;\\n                  break;\\n              }\\n              if(query[i] === pattern[j]) {\\n                  j++;\\n              }\\n          }\\n          if (j < pattern.length) {\\n              matchPattern = false;\\n          }\\n          res.push(matchPattern);\\n   }\\n   return res;\\n};", "var camelMatch = function(queries, pattern) {\\n   const res = [];\\n   for(let query of queries) {\\n          let j=0;\\n          let matchPattern = true;\\n          for(let i=0; i < query.length; i++) {\\n              let asciiCode = query[i].charCodeAt(0);\\n              let isLower = asciiCode >= 97 && asciiCode <= 122;\\n              if(!isLower && j === pattern.length) {\\n                  matchPattern = false;\\n                  break;\\n              }\\n              if(query[i] !== pattern[j] && isLower) continue;\\n              if(query[i] !== pattern[j] && !isLower) {\\n                 matchPattern = false;\\n                  break;\\n              }\\n              if(query[i] === pattern[j]) {\\n                  j++;\\n              }\\n          }\\n          if (j < pattern.length) {\\n              matchPattern = false;\\n          }\\n          res.push(matchPattern);\\n   }\\n   return res;\\n};"]}
{"id": "1081", "ref_js": ["var videoStitching = function(clips, time) {\\n   let ans = start = end = i = 0;                  ", "var videoStitching = function(clips, time) {\\n    let result = start = end = index = 0;\\n\\n    clips.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\\n\\n    while (start < time) {\\n        while (index < clips.length && clips[index][0] <= start)  {\\n            end = Math.max(end, clips[index++][1]);\\n        }\\n        if (start === end) return -1;\\n        start = end;\\n        result += 1;\\n    }\\n    return result;\\n};", "var videoStitching = function(clips, time) {\\n    let result = start = end = index = 0;\\n\\n    clips.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\\n\\n    while (start < time) {\\n        while (index < clips.length && clips[index][0] <= start)  {\\n            end = Math.max(end, clips[index++][1]);\\n        }\\n        if (start === end) return -1;\\n        start = end;\\n        result += 1;\\n    }\\n    return result;\\n};"]}
{"id": "1082", "ref_js": ["var maxAncestorDiff = function(root) {\\n    let diff = 0;\\n  if (!root) return 0;\\n  const stack = [[root, root.val, root.val]];\\n  while (stack.length > 0) {\\n    let [node, currMax, currMin] = stack.pop();\\n    ", "var maxAncestorDiff = function(root) {\\n\\tlet maxDifference = 0;\\n\\tvar maxAncestorDiffHelper = function(root, maxSoFar = -Infinity, minSoFar = Infinity) {\\n\\t\\tif (!root) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tconst rootValue = root.val;\\n\\t\\tif (maxSoFar < rootValue) {\\n\\t\\t\\tmaxSoFar = rootValue;\\n\\t\\t}\\n\\t\\tif (minSoFar > rootValue) {\\n\\t\\t\\tminSoFar = rootValue;\\n\\t\\t}\\n\\t\\tif (maxDifference < Math.abs(maxSoFar - minSoFar)) {\\n\\t\\t\\tmaxDifference = Math.abs(maxSoFar - minSoFar);\\n\\t\\t}\\n\\t\\tconsole.log(rootValue);\\n\\t\\tmaxAncestorDiffHelper(root.left, maxSoFar, minSoFar);\\n\\t\\tmaxAncestorDiffHelper(root.right, maxSoFar, minSoFar);\\n\\t};", "var maxAncestorDiff = function(root) {\\n    let diff = 0;\\n  if (!root) return 0;\\n  const stack = [[root, root.val, root.val]];\\n  while (stack.length > 0) {\\n    let [node, currMax, currMin] = stack.pop();\\n    "]}
{"id": "1083", "ref_js": ["var longestArithSeqLength = function(nums) {\\n     const n = nums.length;\\n  if (n <= 2) return n;\\n\\n  ", "var longestArithSeqLength = function(A) {\\n    const n = A.length;\\n    if (n <= 1) return n;\\n\\n    ", "var longestArithSeqLength = function(nums) {\\n     const n = nums.length;\\n  if (n <= 2) return n;\\n\\n  "]}
{"id": "1084", "ref_js": ["var twoCitySchedCost = function(costs) {\\n    costs.sort((a, b) => {\\n    let diff1 = a[0] - a[1];\\n    let diff2 = b[0] - b[1];\\n    if (diff1 > diff2) {\\n      return 1;\\n    } else {\\n      return -1;\\n    }\\n  });\\n  let ans = 0,\\n    n = costs.length / 2,\\n    count = 0;\\n  for (let arr of costs) {\\n    ans += count < n ? arr[0] : arr[1];\\n    count++;\\n  }\\n  return ans;\\n};", "var twoCitySchedCost = function(costs) {    \\n    costs.sort((a, b) => (a[0] - a[1]) - (b[0] - b[1]))    \\n    n = costs.length / 2\\n    result = 0\\n    count = 0\\n        \\n    for (cost of costs) {        \\n        result += count < n ? cost[0] : cost [1]\\n        count ++\\n    }\\n    \\n    return result\\n};", "var twoCitySchedCost = function(costs) {    \\n    costs.sort((a, b) => (a[0] - a[1]) - (b[0] - b[1]))    \\n    n = costs.length / 2\\n    result = 0\\n    count = 0\\n        \\n    for (cost of costs) {        \\n        result += count < n ? cost[0] : cost [1]\\n        count ++\\n    }\\n    \\n    return result\\n};"]}
{"id": "1085", "ref_js": ["var maxSumTwoNoOverlap = function (nums, len1, len2) {\\n  let n = nums.length;\\n  let prefixSum = new Array(n);\\n  for (let i = 0, sum1 = 0; i < n; i++) {\\n    prefixSum[i] = sum1 += nums[i];\\n  }\\n\\n  let max = 0;\\n  let count = 2;\\n  while (count--) {\\n    for (let i = 0; i + len1 <= n; i++) {\\n      let sum1 = prefixSum[i + len1 - 1] - (prefixSum[i - 1] || 0);\\n      for (let j = i + len1; j + len2 <= n; j++) {\\n        let sum2 = prefixSum[j + len2 - 1] - (prefixSum[j - 1] || 0);\\n        max = Math.max(max, sum1 + sum2);\\n      }\\n    }\\n    [len2, len1] = [len1, len2];\\n  }\\n  return max;\\n};", "var maxSumTwoNoOverlap = function(nums, F, S) {\\n    let n = nums.length;\\n    ", "var maxSumTwoNoOverlap = function(nums, firstLen, secondLen) {\\n    const n = nums.length;\\n  let prefixSum = new Array(n + 1).fill(0);\\n\\n  "]}
{"id": "1086", "ref_js": ["var numMovesStones = function(a, b, c) {\\n   ", "var numMovesStones = function(a, b, c) {\\n  let array = [a,b,c]\\n  let max, min\\n\\n  ", "var numMovesStones = function(a, b, c) {\\n    "]}
{"id": "1087", "ref_js": ["var colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};", "var colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };", "var colorBorder = function (grid, row, col, color) {\\n  "]}
{"id": "1088", "ref_js": ["var maxUncrossedLines = function(nums1, nums2) {\\n    const n = nums1.length, m = nums2.length;\\n\\n    function dp(i, j) {\\n        if (i === n || j === m) return 0;\\n\\n        if (nums1[i] === nums2[j]) {\\n            return 1 + dp(i + 1, j + 1);\\n        } else {\\n            return Math.max(dp(i + 1, j), dp(i, j + 1));\\n        }\\n    }\\n    return dp(0, 0);\\n};", "var maxUncrossedLines = function(nums1, nums2) {\\n  \\n    ", "var maxUncrossedLines = function (nums1, nums2) {\\n    "]}
{"id": "1089", "ref_js": ["var bstToGst = function(root) {\\n    \\n    let accumulation = 0;\\n    \\n    var helper = function( node ){\\n        \\n        if( node != null ){\\n            \\n            helper( node.right );\\n            \\n            accumulation += node.val;\\n            node.val = accumulation;\\n            \\n            helper( node.left );\\n        }\\n        return node;\\n    }\\n    ", "var bstToGst = function(root) {\\n    let currentSum = 0;\\n    \\n    let dfs = function (node){\\n        if (!node) return;\\n        dfs (node.right);\\n        \\n        currentSum = node.val = currentSum + node.val;\\n        \\n        dfs (node.left)\\n    }\\n    \\n    dfs (root);\\n    return root;\\n};", "var bstToGst = function(root) {\\n    let current = 0;\\n    const dfsBST = (node = root) => {\\n        if (!node) return;\\n        const { val, left, right } = node;\\n        \\n        dfsBST(right);\\n        node.val += current;\\n        current += val;\\n        dfsBST(left);\\n    };"]}
{"id": "1090", "ref_js": ["var minScoreTriangulation = function (values) {\\n  let n = values.length;\\n  return solveRec(values, 0, n - 1);\\n};", "var minScoreTriangulation = function (values) {\\n    let dp = Array(values.length).fill().map((i) => Array(values.length).fill(0));\\n    function DFS(i, j) {\\n        if (dp[i][j]) return dp[i][j];\\n        if (j - i < 2) return 0;\\n        let min = Infinity;\\n\\n        for (let k = i + 1; k < j; k++) {\\n            let sum = values[i] * values[j] * values[k] + DFS(i, k) + DFS(k, j);\\n            min = Math.min(min, sum);\\n        }\\n        return dp[i][j] = min;\\n    }\\n    return DFS(0, values.length - 1);\\n};", "var minScoreTriangulation = function(values) {\\n   let n = values.length;\\n   let dp = Array.from({length:n},()=>new Array(n).fill(-1));\\n    const solve = (i,j)=>{\\n\\n        if(i+1==j || i>=j){\\n            return 0\\n        }\\n\\n        if(dp[i][j]!==-1){\\n            return dp[i][j]\\n        }\\n\\n        let min =Infinity;\\n        for(let k=i+1;k<j;k++){\\n\\n            let ans = (values[k]*values[i]*values[j]) + solve(i,k) + solve(k,j);\\n\\n            min= Math.min(min,ans);\\n \\n        }\\n\\n        dp[i][j]=min;\\n\\n       return min\\n\\n\\n    }\\n\\n    return solve(0,values.length-1)\\n    \\n};"]}
{"id": "1091", "ref_js": ["var numMovesStonesII = function(stones) {\\n  stones.sort((a, b) => a - b);\\n  let { length: size } = stones;\\n  let max = Math.max(stones[size - 1] - stones[1] - size + 2, stones[size - 2] - stones[0] - size + 2);\\n  let start = 0;\\n  let min = size;\\n\\n  for(let end = 1; end < size; end++){\\n      while(stones[end] - stones[start] + 1 > size) start += 1;\\n      let already = end - start + 1;\\n\\n      if(already === size - 1 && stones[end] - stones[start] + 1 === size - 1){\\n          min = Math.min(min, 2);\\n      } else {\\n          min = Math.min(min, size - already);\\n      }\\n  }    \\n  return [min, max];\\n};", "var numMovesStonesII = function(stones) {\\n    stones.sort((a, b) => a - b);\\n    const { length: size } = stones;\\n    const max = Math.max(stones[size - 1] - stones[1] - size + 2, stones[size - 2] - stones[0] - size + 2);\\n    let start = 0;\\n    let min = size;\\n\\n    for (let end = 1; end < size; end++) {\\n        while (stones[end] - stones[start] + 1 > size) start += 1;\\n        const already = end - start + 1;\\n\\n        if (already === size - 1 && stones[end] - stones[start] + 1 === size - 1) {\\n            min = Math.min(min, 2);\\n        } else {\\n            min = Math.min(min, size - already);\\n        }\\n    }\\n    return [min, max];\\n};", "var numMovesStonesII = function(stones) {\\n  stones.sort((a, b) => a - b);\\n  let { length: size } = stones;\\n  let max = Math.max(stones[size - 1] - stones[1] - size + 2, stones[size - 2] - stones[0] - size + 2);\\n  let start = 0;\\n  let min = size;\\n\\n  for(let end = 1; end < size; end++){\\n      while(stones[end] - stones[start] + 1 > size) start += 1;\\n      let already = end - start + 1;\\n\\n      if(already === size - 1 && stones[end] - stones[start] + 1 === size - 1){\\n          min = Math.min(min, 2);\\n      } else {\\n          min = Math.min(min, size - already);\\n      }\\n  }    \\n  return [min, max];\\n};"]}
{"id": "1092", "ref_js": ["var isRobotBounded = function(instructions) {\\n    const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        switch(instructions[i]) {\\n            case \\'G\\':\\n                coord.x += dir.x;\\n                coord.y += dir.y;\\n                break;\\n            case \\'L\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.y === 0 && dir.x === -1){\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                } else if(dir.y === 0 && dir.x === 1) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                }\\n                break;\\n            case \\'R\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === -1 && dir.y === 0) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                } else if(dir.x === 1 && dir.y === 0) {\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                }\\n                break;\\n        }\\n    }\\n            \\n    if(coord.x === 0 && coord.y === 0) return true;\\n    if(dir.y !== 1) return true;\\n    return false;\\n};", "var isRobotBounded = function(instructions) { \\n    let x = 0, y = 0;\\n    ", "var isRobotBounded = function(instructions) {\\n    const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        switch(instructions[i]) {\\n            case \\'G\\':\\n                coord.x += dir.x;\\n                coord.y += dir.y;\\n                break;\\n            case \\'L\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.y === 0 && dir.x === -1){\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                } else if(dir.y === 0 && dir.x === 1) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                }\\n                break;\\n            case \\'R\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === -1 && dir.y === 0) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                } else if(dir.x === 1 && dir.y === 0) {\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                }\\n                break;\\n        }\\n    }\\n            \\n    if(coord.x === 0 && coord.y === 0) return true;\\n    if(dir.y !== 1) return true;\\n    return false;\\n};"]}
{"id": "1093", "ref_js": ["var gardenNoAdj = function (n, paths) {\\n  let map = {};", "var gardenNoAdj = function(n, paths) {\\n    ", "var gardenNoAdj = function(n, paths) {\\n    let graph = buildGraph(n, paths);\\n\\n    return dfs(1, [], n, graph)\\n};"]}
{"id": "1094", "ref_js": ["var maxSumAfterPartitioning = function (arr, k) {\\n    let result = 0;\\n\\n    if (arr && (arr.length >= 1) && (arr.length <= 500) && (k >= 1) && (k <= arr.length)) {\\n        let currMaxForPartition;\\n        let memo = [];\\n        ", "var maxSumAfterPartitioning = function(arr, k) {\\n    let n = arr.length;\\n    \\n    ", "var maxSumAfterPartitioning = function (arr, k) {\\n    let n = arr.length;\\n    let dp = new Array(n + 1).fill(0);\\n    for (let i = n - 1; i >= 0; i--) {\\n        let maxSum = -Infinity, len = 0, maxi = -Infinity;\\n        for (let j = i; j < Math.min(n, i + k); j++) {\\n            len++;\\n            maxi = Math.max(maxi, arr[j]);\\n            let sum = (len * maxi) + dp[j+1];\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        dp[i] = maxSum;\\n    }\\n    return dp[0];\\n};"]}
{"id": "1096", "ref_js": ["var longestStrChain = function(words) {\\n    const chains = new Map();  ", "var longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    const dp = {};", "var longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    const dp = {};"]}
{"id": "1097", "ref_js": ["var lastStoneWeightII = function(stones) {\\n    const memo = new Map();\\n    return findMinWeight(0, 0, 0);\\n    \\n    function findMinWeight(index, weight1, weight2) {\\n        const key = `${index}#${weight1}#${weight2}`;\\n        \\n        ", "var lastStoneWeightII = function(stones) {\\n  ", "var lastStoneWeightII = function(stones) {\\n  let sum = stones.reduce((acc, cur) => acc + cur, 0);\\n  let target = Math.floor(sum / 2);\\n\\n  let dp = new Array(target + 1).fill(false);\\n  dp[0] = true;\\n\\n  for (let i = 0; i < stones.length; i++) {\\n    let temp = [...dp]\\n    for (let j = 0; j <= target; j++) {\\n      dp[j] = temp[j - stones[i]] || dp[j];\\n    }\\n  }\\n\\n  let firstHalfSum = target;\\n  while (firstHalfSum >= 0) {\\n    if (dp[firstHalfSum]) break;\\n    firstHalfSum--;\\n  }\\n\\n  let secondHalfSum = sum - firstHalfSum;\\n  return Math.abs(firstHalfSum - secondHalfSum);\\n};"]}
{"id": "1098", "ref_js": ["var maxSatisfied = function(customers, grumpy, minutes) {\\n\\tlet fromInitIndex = 0;\\n\\tlet toInitIndex = minutes - 1;\\n\\tlet withOutGrumpyInitSum = customers.slice(0, minutes).reduce((acc, current) => current + acc);\\n\\tlet withGrumpyInitSum = customers\\n\\t\\t.slice(0, minutes)\\n\\t\\t.reduce((acc, current, index) => (grumpy[index] ? acc : current + acc), 0);\\n\\tlet maxDifference = withOutGrumpyInitSum - withGrumpyInitSum;\\n\\n\\tfor (let index = minutes; index < customers.length; index++) {\\n\\t\\twithOutGrumpyInitSum += customers[index] - customers[index - minutes];\\n\\t\\tif (!grumpy[index]) {\\n\\t\\t\\twithGrumpyInitSum = withGrumpyInitSum + customers[index];\\n\\t\\t}\\n\\t\\tif (!grumpy[index - minutes]) {\\n\\t\\t\\twithGrumpyInitSum = withGrumpyInitSum - customers[index - minutes];\\n\\t\\t}\\n\\t\\tif (maxDifference < withOutGrumpyInitSum - withGrumpyInitSum) {\\n\\t\\t\\tmaxDifference = withOutGrumpyInitSum - withGrumpyInitSum;\\n\\t\\t\\tfromInitIndex = index - minutes + 1;\\n\\t\\t\\ttoInitIndex = index;\\n\\t\\t}\\n\\t}\\n\\n\\tlet sum = 0;\\n\\tfor (let index = 0; index < customers.length; index++) {\\n\\t\\tif (!grumpy[index]) {\\n\\t\\t\\tsum += customers[index];\\n\\t\\t} else if (index >= fromInitIndex && index <= toInitIndex) {\\n\\t\\t\\tsum += customers[index];\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n};", "var maxSatisfied = function(customers, grumpy, minutes) {\\n    let res = 0, temp = 0, maxSatisfied = 0;\\n\\n    ", "var maxSatisfied = function(customers, grumpy, minutes) {\\n    let totalHappyCustomers = 0;\\n    let currWindowPotentiallyHappyCustomers = 0;\\n    \\n    "]}
{"id": "1099", "ref_js": ["var prevPermOpt1 = function(arr) {\\n    let x = arr.length;\\n    ", "var prevPermOpt1 = function(arr) {\\n    for (let index = arr.length - 1; index > 0; index--) {\\n        const value = arr[index];\\n        const target = arr[index - 1];\\n        if (value >= target) continue;\\n        let swapPosition = -1;\\n        let max = 0;\\n\\n        for (let position = index; position < arr.length; position++) {\\n            const swapValue = arr[position];\\n            if (swapValue <= max || swapValue >= target) continue;\\n            swapPosition = position;\\n            max = swapValue;\\n        }\\n        [arr[index - 1], arr[swapPosition]] = [arr[swapPosition], arr[index - 1]];\\n        break;\\n    }\\n    return arr;\\n};", "var prevPermOpt1 = function(arr) {\\n    for (let index = arr.length - 1; index > 0; index--) {\\n        const value = arr[index];\\n        const target = arr[index - 1];\\n        if (value >= target) continue;\\n        let swapPosition = -1;\\n        let max = 0;\\n\\n        for (let position = index; position < arr.length; position++) {\\n            const swapValue = arr[position];\\n            if (swapValue <= max || swapValue >= target) continue;\\n            swapPosition = position;\\n            max = swapValue;\\n        }\\n        [arr[index - 1], arr[swapPosition]] = [arr[swapPosition], arr[index - 1]];\\n        break;\\n    }\\n    return arr;\\n};"]}
{"id": "1100", "ref_js": ["var rearrangeBarcodes = function (a) {\\n    let n = a.length;\\n    a.sort((a, b) => a - b);\\n\\n    let an = [];\\n\\n    let i, j;\\n    for (i = 0, j = n - 1; i <= j; ) {\\n        if (a[i] === an.at(-1)) break;\\n        an.push(a[i]);\\n        i++;\\n\\n        if (i - 1 === j) break;\\n\\n        if (a[j] === an.at(-1)) break;\\n        an.push(a[j]);\\n        j--;\\n    }\\n    for (let k = 0; i <= j; k += 2, i++) {\\n        an.splice(k, 0, a[i]);\\n    }\\n\\n    return an;\\n};", "var rearrangeBarcodes = function(barcodes) {\\n    let map = new Map();\\n\\n    ", "var rearrangeBarcodes = function(barcodes) {\\n    let hash = {};"]}
{"id": "1101", "ref_js": ["var smallestEquivalentString = function(s1, s2, baseStr) {\\n    let parent = new Array(26).fill(0);\\n    for (let i = 0; i < 26; i++) {\\n        parent[i] = i;\\n    }\\n    for (let i = 0; i < s1.length; i++) {\\n        let u = find(s1.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent);\\n        let v = find(s2.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent);\\n        if (u < v) {\\n            parent[v] = u;\\n        } else if (u > v) {\\n            parent[u] = v;\\n        }\\n    }\\n    let result=\"\";\\n    for (let i = 0; i < baseStr.length; i++) {\\n        result += String.fromCharCode(find(baseStr.charCodeAt(i) - \\'a\\'.charCodeAt(0),parent) + \\'a\\'.charCodeAt(0));\\n    }\\n    return result;\\n};", "var smallestEquivalentString = function(s1, s2, baseStr) {\\n    const edges = craeteEdges(s1, s2)\\n    const adjList = createAdjacencyList(edges)\\n    const vis = new Array(27).fill(0)\\n    const parent = new Array(27)\\n\\n    for(let i = 0; i<27; i++){\\n        if(!vis[i]){\\n            smallestOfChar(i, vis,parent,adjList)\\n        }\\n    }\\n\\n    return createString(baseStr, parent)\\n};", "var smallestEquivalentString = function(s1, s2, baseStr) {\\n    const edges = craeteEdges(s1, s2)\\n    const adjList = createAdjacencyList(edges)\\n    const vis = new Array(27).fill(0)\\n    const parent = new Array(27)\\n\\n    for(let i = 0; i<27; i++){\\n        if(!vis[i]){\\n            smallestOfChar(i, vis,parent,adjList)\\n        }\\n    }\\n\\n    return createString(baseStr, parent)\\n};"]}
{"id": "1103", "ref_js": ["var maxEqualRowsAfterFlips = function(g) {\\n    let m = g.length;\\n    let x = {};", "var maxEqualRowsAfterFlips = function (g) {\\n    const m = g.length\\n\\n    let o = {}\\n    for (let i = 0; i < m; i++) {\\n        if (g[i][0]) {\\n            g[i] = g[i].map((e) => 1 - e)\\n        }\\n        let k = g[i].join(\"\")\\n        o[k] = (o[k] || 0) + 1\\n    }\\n\\n    let maxf = 0\\n    for (let k in o) {\\n        let f = o[k]\\n        maxf = Math.max(maxf, f)\\n    }\\n    return maxf\\n};", "var maxEqualRowsAfterFlips = function(matrix) {\\n    let obj = {}\\n    for(let row = 0; row < matrix.length; row++){\\n        let convert = false\\n        if (matrix[row][0] === 0) convert = true\\n        let str = \"\"\\n        for (let col = 0; col < matrix[row].length; col++){\\n            if (convert){\\n                if (matrix[row][col] === 0) str +=  \"1\"\\n                else str += \"0\"\\n            }  else {\\n                str += +matrix[row][col]\\n            }\\n        }\\n        if (obj[str] === undefined){\\n            obj[str] = 1\\n        } else obj[str]++\\n    }\\n    return Math.max(...Array.from(Object.values(obj)))\\n};"]}
{"id": "1104", "ref_js": ["var addNegabinary = function(arr1, arr2) {\\n    ", "var addNegabinary = function(arr1, arr2) {\\n    let carry = 0\\n    let result = []\\n    let i = arr1.length - 1\\n    let j = arr2.length - 1\\n\\n    while(i >= 0 || j >= 0 || carry) {\\n        if(i >= 0) carry += arr1[i]\\n        if(j >= 0) carry += arr2[j]\\n        result.push(carry & 1)\\n        carry = -(carry >> 1)\\n        \\n        i--\\n        j--\\n    }\\n\\n    while(result.length > 1 && result[result.length - 1] === 0) {\\n        result.pop()\\n    }\\n\\n    return result.reverse()\\n};", "var addNegabinary = function(arr1, arr2) {\\n    let carry = 0\\n    let result = []\\n    let i = arr1.length - 1\\n    let j = arr2.length - 1\\n\\n    while(i >= 0 || j >= 0 || carry) {\\n        if(i >= 0) carry += arr1[i]\\n        if(j >= 0) carry += arr2[j]\\n        result.push(carry & 1)\\n        carry = -(carry >> 1)\\n        \\n        i--\\n        j--\\n    }\\n\\n    while(result.length > 1 && result[result.length - 1] === 0) {\\n        result.pop()\\n    }\\n\\n    return result.reverse()\\n};"]}
{"id": "1105", "ref_js": ["var numTilePossibilities = function(tiles) {\\n\\tlet map = new Map();\\n\\tfor(let i = 0; i < tiles.length; i++) {\\n\\t\\tmap.set(tiles[i], (map.get(tiles[i]) || 0) +  1);\\n\\t}\\n\\treturn helper(map);\\n};", "var numTilePossibilities = function (tiles) {\\n    let map = new Map();\\n    for (let i = 0; i < tiles.length; i++) {\\n        map.set(tiles[i], (map.get(tiles[i]) || 0) + 1);\\n    }\\n    return helper(map);\\n};", "var numTilePossibilities = function(tiles) {\\n    "]}
{"id": "1106", "ref_js": ["var sufficientSubset = function(root, limit) {\\n    ", "var sufficientSubset = function(root, limit) {\\n    const setInSufficientNode = (node = root, sum = 0) => {\\n        if (!node) return null;\\n        const { val, left, right } = node;\\n        const current = sum + val;\\n\\n        node.left = setInSufficientNode(left, current);\\n        node.right = setInSufficientNode(right, current);\\n        const isLeaf = !node.left && !node.right;\\n\\n        if (isLeaf && (current < limit || left || right)) return null;\\n        return node;\\n    };", "var sufficientSubset = function(root, limit) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const sum = removeNodes(root, 0);\\n    \\n    if (sum < limit) return null;\\n    \\n    return root;\\n    \\n    function removeNodes(node, prevSum) {\\n        if (node == null) return MIN;\\n        if (node.left == node.right) return node.val + prevSum;\\n        \\n        const leftSum = removeNodes(node.left, prevSum + node.val);\\n        const rightSum = removeNodes(node.right, prevSum + node.val);\\n        \\n        if (leftSum < limit) node.left = null;\\n        if (rightSum < limit) node.right = null;\\n        \\n        if (node.left == node.right) return MIN;\\n        \\n        return node.left == null ? rightSum : leftSum;\\n    }\\n};"]}
{"id": "1107", "ref_js": ["var smallestSubsequence = function(s) {\\n    ", "var smallestSubsequence = function(s) {\\n    const freq = new Map(), vis = new Set(), str = s.split(\\'\\'), stack = [];\\n\\n    str.forEach(e => freq.set(e, (freq.get(e) || 0) + 1))\\n    str.forEach(e => {\\n        if(!vis.has(e)) {\\n            while(stack.length && stack[stack.length-1] > e && freq.get(stack[stack.length-1]))\\n                vis.delete(stack.pop())\\n\\n            if(!vis.has(e)) \\n                stack.push(e), vis.add(e);\\n        }\\n        freq.set(e, freq.get(e) - 1)\\n    })\\n\\n    return stack.join(\\'\\')\\n};", "var smallestSubsequence = function(s) {\\n    const visited = new Array(26);\\n    const count = new Array(26).fill(0);\\n    const stack = []\\n    for(let i = 0 ; i < s.length ; i ++){\\n        let idx = s.charCodeAt(i) - a;\\n        count[idx] ++;\\n    }\\n    for(let c of s){\\n        let idx = c.charCodeAt(0) - a;\\n        count[idx] --;\\n        console.log(\"idx:\", idx ,count[idx]);\\n        if(stack.length === 0){\\n            stack.push(c);\\n            visited[idx] = true;\\n            continue;\\n        }\\n        if(visited[idx]) continue;\\n        while(stack.length > 0 && c < stack[stack.length -1] && count[stack[stack.length -1].charCodeAt(0) - a] > 0){\\n            let pre = stack.pop();\\n            let preIdx = pre.charCodeAt(0) - a;\\n            visited[preIdx] = false;\\n        }\\n        stack.push(c);\\n        visited[idx] = true;\\n    }\\n    return stack.join(\"\");\\n};"]}
{"id": "1108", "ref_js": ["var largestValsFromLabels = function (values, labels, numWanted, useLimit) {\\n    const map = {}\\n    let res = 0\\n    let acc = 0\\n\\n    const mapper = values.map((value, i) => ({\\n        val: value,\\n        label: labels[i]\\n    })).sort((a, b) => b.val - a.val)\\n\\n    for (let i = 0; i < mapper.length; i++) {\\n        map[mapper[i].label] = 0\\n    }\\n\\n    for (let i = 0; i < mapper.length; i++) {\\n        const { label, val } = mapper[i]\\n        if (acc < numWanted && map[label] < useLimit) {\\n            res += val\\n            map[label] = (map[label] || 0) + 1\\n            acc++\\n        }\\n    }\\n\\n\\n    return res\\n};", "var largestValsFromLabels = function(values, labels, numWanted, useLimit) {\\n    ", "var largestValsFromLabels = function(values, labels, numWanted, useLimit) {\\n    "]}
{"id": "1109", "ref_js": ["var shortestPathBinaryMatrix = function(grid) {\\n       \\n    if (grid[0][0] == 1) return -1\\n  let list = [[[0,0],1]];\\n  let row = grid.length;\\n  let column = grid[0].length;\\n  let directions = [[1,0],[0,1],[-1,0],[0,-1],[1,1],[-1,1],[-1,-1],[1,-1]];\\n  let visited = new Set;\\n\\n  while (list.length){\\n\\n    let [[a,b],count] = list.shift();\\n\\n    if (a == row-1 && b==column-1) return count;\\n    if (visited.has(`${a}-${b}`)) continue;\\n\\n    visited.add(`${a}-${b}`);\\n    for(let [x,y] of directions){\\n      let [x1,y1] = [x + a, y + b];\\n      if (x1 >= row ||  y1 >= column || x1 < 0 || y1 < 0 || grid[x1][y1] != 0)continue;\\n      list.push([[x1,y1],count+1]);\\n    }\\n  }\\n  return -1;\\n};", "var shortestPathBinaryMatrix = function(grid) {\\n       \\n    if (grid[0][0] == 1) return -1\\n  let list = [[[0,0],1]];\\n  let row = grid.length;\\n  let column = grid[0].length;\\n  let directions = [[1,0],[0,1],[-1,0],[0,-1],[1,1],[-1,1],[-1,-1],[1,-1]];\\n  let visited = new Set;\\n\\n  while (list.length){\\n\\n    let [[a,b],count] = list.shift();\\n\\n    if (a == row-1 && b==column-1) return count;\\n    if (visited.has(`${a}-${b}`)) continue;\\n\\n    visited.add(`${a}-${b}`);\\n    for(let [x,y] of directions){\\n      let [x1,y1] = [x + a, y + b];\\n      if (x1 >= row ||  y1 >= column || x1 < 0 || y1 < 0 || grid[x1][y1] != 0)continue;\\n      list.push([[x1,y1],count+1]);\\n    }\\n  }\\n  return -1;\\n};", "var shortestPathBinaryMatrix = function(grid) {\\n       \\n    if (grid[0][0] == 1) return -1\\n  let list = [[[0,0],1]];\\n  let row = grid.length;\\n  let column = grid[0].length;\\n  let directions = [[1,0],[0,1],[-1,0],[0,-1],[1,1],[-1,1],[-1,-1],[1,-1]];\\n  let visited = new Set;\\n\\n  while (list.length){\\n\\n    let [[a,b],count] = list.shift();\\n\\n    if (a == row-1 && b==column-1) return count;\\n    if (visited.has(`${a}-${b}`)) continue;\\n\\n    visited.add(`${a}-${b}`);\\n    for(let [x,y] of directions){\\n      let [x1,y1] = [x + a, y + b];\\n      if (x1 >= row ||  y1 >= column || x1 < 0 || y1 < 0 || grid[x1][y1] != 0)continue;\\n      list.push([[x1,y1],count+1]);\\n    }\\n  }\\n  return -1;\\n};"]}
{"id": "1110", "ref_js": ["var sampleStats = function(count) {\\n    ", "var sampleStats = function(count) {\\n    ", "var sampleStats = function(count) {\\n    "]}
{"id": "1111", "ref_js": ["var carPooling = function(trips, capacity) {\\n    let arr = new Array(1001).fill(0);\\n    let result = 0\\n    for(let [p,f,t] of trips){\\n        arr[f] += p;\\n        arr[t] -= p;\\n    }\\n    for(let i=0; i<arr.length; i++){\\n        result+= arr[i];\\n        if(result > capacity)return false\\n    }\\n    return true\\n};", "var carPooling = function(trips, capacity) {\\n    const from = [...trips].sort((a, b) => a[1] - b[1]); ", "var carPooling = function(trips, capacity) {\\n\\t  \\n\\t"]}
{"id": "1112", "ref_js": ["var pathInZigZagTree = function(label) {\\n\\tlet array = [];\\n\\tlet currentLevel = 0;\\n\\tlet currentElement = 1;\\n\\tlet totalElementsBuild = 0;\\n\\twhile (totalElementsBuild < label) {\\n\\t\\tlet elementInCurrentLevel = Math.pow(2, currentLevel);\\n\\t\\ttotalElementsBuild += elementInCurrentLevel;\\n\\t\\tconst arr = [];\\n\\t\\twhile (elementInCurrentLevel--) {\\n\\t\\t\\tarr.push(currentElement++);\\n\\t\\t}\\n\\t\\tif (currentLevel % 2 !== 0) {\\n\\t\\t\\tarr.reverse();\\n\\t\\t}\\n\\t\\tarray.push(arr);\\n\\t\\tcurrentLevel++;\\n\\t}\\n\\tlet indexOfLabelElement = array[array.length - 1].indexOf(label);\\n\\tconst output = [ label ];\\n\\tfor (let index = array.length - 2; index >= 0; index--) {\\n\\t\\tindexOfLabelElement = Math.floor(indexOfLabelElement / 2);\\n\\t\\toutput.push(array[index][indexOfLabelElement]);\\n\\t}\\n\\treturn output.reverse();\\n};", "var pathInZigZagTree = function(label) {\\n    ", "var pathInZigZagTree = function(label) {\\n    let level=0;\\n    while(Math.pow(2,level)*2<=label){level++;}\\n\\n    const getParent=(node,lvl)=>{        \\n        if(node===1) return [];\\n        const lvlMaxVal = (Math.pow(2,lvl)*2)-1, lvlMinVal = Math.pow(2,lvl);\\n        const mirror=lvlMinVal+(lvlMaxVal-node);\\n        const parent = Math.trunc(mirror/2);\\n        return [...getParent(parent,lvl-1), parent];\\n    }\\n    return [...getParent(label, level),label];\\n};"]}
{"id": "1113", "ref_js": ["var minHeightShelves = function(books, shelfWidth) {\\n   ", "var minHeightShelves = function(books, shelfWidth) {\\n    let dp = new Array(books.length);\\n    let width,height;\\n    for(let i=0;i<books.length;i++){            \\n        dp[i]=(dp[i-1]||0)+books[i][1];\\n        width=books[i][0];\\n        height=books[i][1];\\n        for(let j=i-1;width<=shelfWidth&&j>=0;j--){\\n            if(width+books[j][0]<=shelfWidth){\\n                height=Math.max(height,books[j][1]);\\n                width+=books[j][0];\\n                dp[i]=Math.min(dp[i],(dp[j-1]||0)+height);\\n            }          \\n            else break;\\n        }                \\n    }\\n    return dp.pop();\\n};", "var minHeightShelves = function(books, width) {\\n  const memo = {};"]}
{"id": "1114", "ref_js": ["var corpFlightBookings = function(bookings, n) {\\n    ", "var corpFlightBookings = function(bookings, n) {\\n    ", "var corpFlightBookings = function(bookings, n) {\\n    "]}
{"id": "1115", "ref_js": ["var delNodes = function(root, to_delete) {\\n    let roots = [];\\n    let helper = function(root, isRoot) {\\n        if (!root) return null;\\n        let shouldDelete = to_delete.includes(root.val);\\n        if (isRoot && !shouldDelete) roots.push(root);\\n        root.left = helper(root.left, shouldDelete);\\n        root.right = helper(root.right, shouldDelete);\\n        return shouldDelete?null:root;\\n    }\\n    helper(root, true);\\n    return roots;\\n};", "var delNodes = function(root, to_delete) {\\n    ", "var delNodes = function(root, to_delete) {\\n    let roots = [];\\n    let helper = function(root, isRoot) {\\n        if (!root) return null;\\n        let shouldDelete = to_delete.includes(root.val);\\n        if (isRoot && !shouldDelete) roots.push(root);\\n        root.left = helper(root.left, shouldDelete);\\n        root.right = helper(root.right, shouldDelete);\\n        return shouldDelete?null:root;\\n    }\\n    helper(root, true);\\n    return roots;\\n};"]}
{"id": "1116", "ref_js": ["var maxDepthAfterSplit = function(seq) {\\n    ", "var maxDepthAfterSplit = function(seq) {\\n   let groups = [];\\n   let count = 0;\\n   for(let i=0;i<seq.length;i++){\\n       if (seq[i] === \"(\") {\\n           count++;\\n           groups.push(count % 2);\\n       } else {\\n           groups.push(count % 2);\\n           count--;\\n       }\\n   }\\n   return groups; \\n};", "var maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        if (ch == \\'(\\') {\\n            ++depth;\\n            result.push(depth & 1);\\n        } else  {\\n            result.push(depth & 1);\\n            --depth;\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1120", "ref_js": ["var lcaDeepestLeaves = function(root) {\\n    ", "var lcaDeepestLeaves = function(root) {\\n    var maxDepth = function(node) {\\n        if (!node) return 0;\\n        return Math.max(maxDepth(node.left), maxDepth(node.right)) + 1;\\n    };", "var lcaDeepestLeaves = function(root) {\\n    const findDeepsetAncestor = (node = root) => {\\n        if (!node) return { node: null, deep: 0 };"]}
{"id": "1121", "ref_js": ["var longestWPI = function(hours) {\\n    let arr = hours.map(hour => {\\n        if(hour > 8){\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    });\\n    let ans = 0;\\n    for(let i=0; i<arr.length; i++){\\n        let sum = 0;\\n        for(let j=i; j<arr.length; j++){\\n            sum += arr[j];\\n            if(sum > 0){\\n                ans = Math.max(ans, j-i+1);\\n            }\\n        }\\n    }\\n    return ans;\\n};", "var longestWPI = function(hours) {\\n    let arr = hours.map(hour => {\\n        if(hour > 8){\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    });\\n\\n    let ans = 0;\\n\\n    for(let i=0; i<arr.length; i++){\\n        let sum = 0;\\n        for(let j=i; j<arr.length; j++){\\n            sum += arr[j];\\n            if(sum > 0){\\n                ans = Math.max(ans, j-i+1);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};", "var longestWPI = function(hours) {\\n    let total = 0;\\n    let maxLength = 0;\\n    const map = new Map();\\n\\n    for(let i = 0; i < hours.length; i++) {\\n        total += hours[i] > 8 ? 1 : -1;\\n\\n        if(total > 0) {\\n            maxLength = i + 1;\\n        } else {\\n            if(!map.has(total)) {\\n                map.set(total, i);\\n            }\\n\\n            if(map.has(total - 1)) {\\n                maxLength = Math.max(maxLength, i - map.get(total - 1))\\n            }\\n        }\\n    }\\n\\n    return maxLength;\\n};"]}
{"id": "1122", "ref_js": ["var shortestAlternatingPaths = function (n, red_edges, blue_edges) {\\n  ", "var shortestAlternatingPaths = function(n, redEdges, blueEdges) {\\n  ", "var shortestAlternatingPaths = function (n, red_edges, blue_edges) {\\n  "]}
{"id": "1123", "ref_js": ["var mctFromLeafValues = function(arr) {\\n ", "var mctFromLeafValues = function(arr) {\\n    let dp = Array.from({length: arr.length}, () => Array.from({length: arr.length}, () =>\\n    ({sum: Number.MAX_SAFE_INTEGER, max: 0}))); ", "var mctFromLeafValues = function(arr) {\\n    let dp = Array.from({length: arr.length}, () => Array.from({length: arr.length}, () =>\\n    ({sum: Number.MAX_SAFE_INTEGER, max: 0}))); "]}
{"id": "1124", "ref_js": ["var maxAbsValExpr = function(arr1, arr2) {\\n  ", "var maxAbsValExpr = function (arr1, arr2) {\\n    const l1 = [], l2 = [], l3 = [], l4 = [], res = [];\\n\\n    for (let i = 0; i < arr1.length; i++) {\\n        l1.push(arr1[i] + arr2[i] + i)\\n        l2.push(arr1[i] - arr2[i] + i)\\n        l3.push(-arr1[i] + arr2[i] + i)\\n        l4.push(-arr1[i] - arr2[i] + i)\\n    }\\n\\n    res.push(Math.max(...l1) - Math.min(...l1))\\n    res.push(Math.max(...l2) - Math.min(...l2))\\n    res.push(Math.max(...l3) - Math.min(...l3))\\n    res.push(Math.max(...l4) - Math.min(...l4))\\n\\n    return Math.max(...res);\\n};", "var maxAbsValExpr = function(arr1, arr2) {\\n    let result = 0;\\n\\n    for (let i = 0; i < arr1.length; i++) {\\n        for (let j = 0; j < arr2.length; j++) {\\n            const sum1 = Math.abs(arr1[i] - arr1[j]);\\n            const sum2 = Math.abs(arr2[i] - arr2[j]);\\n            const sum3 = Math.abs(i - j);\\n            const sum = sum1 + sum2 + sum3;\\n            result = Math.max(result, sum);\\n        }\\n    }\\n\\n    return result;\\n};"]}
{"id": "1125", "ref_js": ["var alphabetBoardPath = function(target) {\\n    const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    const coordinate = new Map();\\n    \\n    for(let r = 0; r < board.length; r++) {\\n        for(let c = 0; c < board[r].length; c++) {\\n            coordinate.set(board[r][c], [r, c]);\\n        }\\n    }\\n    \\n    let r = 0, c = 0;\\n    let output = \\'\\';\\n    \\n    for(let char of target) {\\n        const [r1, c1] = coordinate.get(char);\\n        \\n        if(c > c1) output += \\'L\\'.repeat(c - c1);\\n        if(r > r1) output += \\'U\\'.repeat(r - r1);\\n        if(c < c1) output += \\'R\\'.repeat(c1 - c);\\n        if(r < r1) output += \\'D\\'.repeat(r1 - r);\\n        output += \\'!\\'\\n        r = r1;\\n        c = c1;\\n    }\\n    return output;\\n};", "var alphabetBoardPath = function(target) {\\n ", "var alphabetBoardPath = function (target) {\\n  let g = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z    \"];\\n  let e2RC = {};"]}
{"id": "1126", "ref_js": ["var largest1BorderedSquare = function(grid) {\\n  let m = grid.length, n = grid[0].length;\\n  let top = Array(m).fill(0).map(() => Array(n).fill(0));\\n  let left = Array(m).fill(0).map(() => Array(n).fill(0));\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\\n        top[i][j] = i > 0 ? top[i - 1][j] + 1 : 1;\\n      } \\n    }\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      let size = Math.min(top[i][j], left[i][j]);\\n      for (let k = size; k > 0; k--) {\\n        let bottomLeftTop = top[i][j - k + 1];\\n        let topRightLeft = left[i - k + 1][j];\\n        if (bottomLeftTop >= k && topRightLeft >= k) {\\n          ans = Math.max(ans, k * k);\\n          break;\\n        }\\n      }\\n    }\\n  }\\n  return ans;\\n};", "var largest1BorderedSquare = function (grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n\\n    let len = Math.min(m, n);\\n\\n    function has1sInTheBorder(i1, j1, i2, j2) {\\n        if (i1 < 0 || i1 >= m || i2 < 0 || i2 >= m) return false;\\n        if (j1 < 0 || j1 >= n || j2 < 0 || j2 >= n) return false;\\n\\n        for (let i = i1; i <= i2; i++) {\\n            if (!grid[i][j1]) return false; ", "var largest1BorderedSquare = function (grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n\\n    let len = Math.min(m, n);\\n\\n    function has1sInTheBorder(i1, j1, i2, j2) {\\n        if (i1 < 0 || i1 >= m || i2 < 0 || i2 >= m) return false;\\n        if (j1 < 0 || j1 >= n || j2 < 0 || j2 >= n) return false;\\n\\n        for (let i = i1; i <= i2; i++) {\\n            if (!grid[i][j1]) return false; "]}
{"id": "1127", "ref_js": ["var stoneGameII = function (piles) {\\n  const n = piles.length;\\n  const dp = Array.from(Array(n + 1), () => Array(2 * (n + 1)).fill(0));\\n  let sumTilEnd = 0, minOpponent;\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    sumTilEnd += piles[i];\\n    for (let m = 1; m <= n; m++) {\\n      if (i + 2 * m >= n) {\\n        dp[i][m] = sumTilEnd;\\n        continue;\\n      }\\n\\n      minOpponent = dp[i + 1][m];\\n\\n      for (let x = 2; x <= 2 * m; x++) {\\n        minOpponent = Math.min(minOpponent, dp[i + x][Math.max(m, x)]);\\n      }\\n\\n      dp[i][m] = sumTilEnd - minOpponent;\\n    }\\n  }\\n\\n  return dp[0][1];\\n};", "var stoneGameII = function(piles) {\\n  const length = piles.length;\\n  const dp = [...Array(length + 1).fill(null)].map((_) =>\\n    Array(length + 1).fill(0)\\n  );\\n  const sufsum = new Array(length + 1).fill(0);\\n  for (let i = length - 1; i >= 0; i--) {\\n    sufsum[i] = sufsum[i + 1] + piles[i];\\n  }\\n  for (let i = 0; i <= length; i++) {\\n    dp[i][length] = sufsum[i];\\n  }\\n  for (let i = length - 1; i >= 0; i--) {\\n    for (let j = length - 1; j >= 1; j--) {\\n      for (let X = 1; X <= 2 * j && i + X <= length; X++) {\\n        dp[i][j] = Math.max(dp[i][j], sufsum[i] - dp[i + X][Math.max(j, X)]);\\n      }\\n    }\\n  }\\n  return dp[0][1];\\n};", "var stoneGameII = function(piles) {\\n    const n = piles.length;\\n    const memo = new Map();\\n    const sums = new Array(n).fill(0);\\n\\t\\n    sums[n - 1] = piles[n - 1];\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        sums[i] = sums[i + 1] + piles[i]; "]}
{"id": "1128", "ref_js": ["var longestCommonSubsequence = function(text1, text2) {\\n    const dp = new Array(text1.length + 1);\\n    for(let i = 0; i < dp.length; i++){\\n        dp[i] = new Array(text2.length + 1).fill(-1);\\n    }\\n    return solve(text1, 0, text2, 0, dp);\\n};", "var longestCommonSubsequence = function(text1, text2) {\\n    const memo = new Map();\\n    return recursion(text1, text2, text1.length - 1, text2.length - 1, memo);\\n};", "var longestCommonSubsequence = function(text1, text2) {\\n    let dp = new Array(text1.length+1).fill(null).map(() => new Array(text2.length+1).fill(0));\\n\\n    for (let i = 1; i <= text1.length; i++) {\\n        for (let j = 1; j <= text2.length; j++) {\\n            if (text1[i-1] === text2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n            } else {\\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[text1.length][text2.length];\\n};"]}
{"id": "1129", "ref_js": ["var movesToMakeZigzagEvenIndexed = function(nums) {\\n\\tlet totalCost = 0;\\n\\tlet previousValue = null;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (index === 0) {\\n\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t} else if (index % 2 === 0) {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue < currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = previousValue - currentValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue > currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = currentValue - previousValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue - tempTotalCost;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn totalCost;\\n};", "var movesToMakeZigzag = function(nums) {\\n    const moves=(start)=>{\\n        let operations=0;\\n        for(let i=start;i<nums.length;i+=2){\\n            const mid=nums[i], \\n            left=i-1<0?Number.MAX_SAFE_INTEGER:nums[i-1], \\n            right=i+1===nums.length?Number.MAX_SAFE_INTEGER:nums[i+1],\\n            minBound=Math.min(left,right);\\n\\n            if(minBound<=mid) operations+=mid-minBound+1;\\n        }\\n        return operations;\\n    }\\n    return Math.min(moves(0),moves(1));    \\n};", "var movesToMakeZigzag = function(nums) {\\n    const MAX_NUM = 1001;\\n    const decrease = [0, 0];\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        const left = nums[index - 1] ?? MAX_NUM;\\n        const right = nums[index + 1] ?? MAX_NUM;\\n        const moves = nums[index] - Math.min(left, right) + 1;\\n\\n        decrease[index & 1] += Math.max(0, moves);\\n    }\\n    return Math.min(...decrease);\\n};"]}
{"id": "1130", "ref_js": ["var btreeGameWinningMove = function(root, n, x) {\\n    const halfCount = n / 2;\\n    const xColoringSubNodes = { left: 0, right: 0 };", "var btreeGameWinningMove = function(root, n, x) {\\n    const find = (node, target) => {\\n        if(node === null) return null;\\n        if(node.val === target) {\\n            return node;\\n        }\\n        let left = find(node.left, target);\\n        if(left != null) return left;\\n        return find(node.right, target);\\n    }\\n\\n    let nodeX = find(root, x);\\n\\n    const countSubTree = (node) => {\\n        if(node === null) return 0;\\n        return 1 + countSubTree(node.left) + countSubTree(node.right);\\n    }\\n\\n    let leastToWin = Math.ceil(n / 2);\\n\\n    let left = countSubTree(nodeX.left);\\n    if(left >= leastToWin) return true;\\n\\n    let right = countSubTree(nodeX.right);\\n    if(right >= leastToWin) return true;\\n\\n    let remain = n - 1 - left - right;\\n    if(remain >= leastToWin) return true;\\n\\n    return false;\\n};", "var btreeGameWinningMove = function (root, totalNodesCount, x) {\\n  let leftChildrenOfX = 0;\\n  let rightChildrenOfX = 0;\\n\\n  function getChildrenCount(node, opponentNode) {\\n    if (!node) return 0;\\n\\n    const nodesInLeft = getChildrenCount(node.left, opponentNode);\\n    const nodesInRight = getChildrenCount(node.right, opponentNode);\\n    if (node.val == opponentNode) {\\n      leftChildrenOfX = nodesInLeft;\\n      rightChildrenOfX = nodesInRight;\\n    }\\n    return nodesInLeft + nodesInRight + 1;\\n  }\\n\\n  getChildrenCount(root, x);\\n\\n  const remainingNodesOnOtherSide =\\n    totalNodesCount - (leftChildrenOfX + rightChildrenOfX + 1);\\n  const maxAvailableNodesForMe = Math.max(\\n    remainingNodesOnOtherSide,\\n    leftChildrenOfX,\\n    rightChildrenOfX\\n  );\\n\\n  const res = maxAvailableNodesForMe > parseInt(totalNodesCount / 2);\\n  return res;\\n};"]}
{"id": "1132", "ref_js": ["var numRollsToTarget = function(d, f, target) {\\n    const MOD = 1e9 + 7;\\n    const memo = new Map();\\n\\t\\n    return findWays(d, 0);\\n    \\n    function findWays(k, sum) {\\n        const key = `${k}#${sum}`;\\n        \\n        ", "var numRollsToTarget = function(d, f, target) {\\n    const MOD = 1e9 + 7;\\n    const memo = new Map();\\n\\t\\n    return findWays(d, 0);\\n    \\n    function findWays(k, sum) {\\n        const key = `${k}#${sum}`;\\n        \\n        ", "var numRollsToTarget = function(d, f, target) {\\n    const MOD = 1e9 + 7;\\n    const memo = new Map();\\n\\t\\n    return findWays(d, 0);\\n    \\n    function findWays(k, sum) {\\n        const key = `${k}#${sum}`;\\n        \\n        "]}
{"id": "1133", "ref_js": ["var maxRepOpt1 = function(text) {\\n    \\n    \\n    let freq = {};", "var maxRepOpt1 = function(s) {\\n    const groups = Array.from(Array(26), () => []);\\n    for(let i = 0; i < s.length; i++) {\\n        groups[s.charCodeAt(i) - 97].push(i);\\n    }\\n\\n    let res = 0;\\n\\n    groups.forEach(group => {\\n        let cur = 1, pre = 0, sum = 0;\\n\\n        for(let i = 1; i < group.length; i++) {\\n            ", "var maxRepOpt1 = function(text) {\\n    const charCountMap = new Map();\\n    const size = text.length;\\n    let result = 0;\\n    const checkRepeatChar = (isFromBack = false) => {\\n        const next = isFromBack ? -1 : 1;\\n        let index = isFromBack ? size - 1 : 0;\\n\\n        for (index; index < size && index >= 0; index += next) {\\n            const char = text[index];\\n            const count = charCountMap.get(char);\\n            let window = index + next;\\n            let isSwap = false;\\n            let repeat = 1;\\n\\n            while (window < size && window >= 0 && repeat < count && (!isSwap || text[window] === char)) {\\n                if (text[window] !== char) {\\n                    index = window - next;\\n                    isSwap = true; \\n                }\\n                window += next;\\n                repeat += 1;\\n            }\\n            result = Math.max(result, repeat);\\n        }\\n    };"]}
{"id": "1135", "ref_js": ["var maxLevelSum = function(root) {\\n    if(!root) return 0\\n    let maxSum = -Infinity\\n    let maxLevel = 0, currentLevel = 0\\n\\n    const q = [root]\\n\\n    while(q.length) {\\n        currentLevel += 1\\n        let currentLevelSum = 0\\n        const levelSize = q.length\\n        for (i = 0; i < levelSize; i++){\\n            const currentNode = q.shift()\\n            currentLevelSum += currentNode.val\\n            if(currentNode.left) q.push(currentNode.left)\\n            if(currentNode.right) q.push(currentNode.right)\\n        }\\n\\n        if(currentLevelSum > maxSum){\\n            maxSum = currentLevelSum\\n            maxLevel = currentLevel\\n        }\\n    }\\n    return maxLevel\\n};", "var maxLevelSum = function (root) {\\n    let ans = 1;\\n    if (!root) return ans;\\n\\n    let qu = [root];\\n    let maxSum = root.val;\\n    let height = 1;\\n    while (qu.length) {\\n        const n = qu.length;\\n        let sum = 0;\\n        for (let i = 0; i < n; i++) {\\n            const node = qu.shift();\\n            sum += node.val;\\n            if (node.left) qu.push(node.left);\\n            if (node.right) qu.push(node.right);\\n        }\\n        if(sum > maxSum){\\n            maxSum = sum;\\n            ans = height;\\n        }\\n\\n        height++;\\n    }\\n    return ans;\\n};", "var maxLevelSum = function(root) {\\n    let map = {}\\n    function traverse(node, height) {\\n        if(!node) return\\n        if(!map[height]) map[height] = node.val\\n        else map[height] += node.val\\n        traverse(node.left, height + 1)\\n        traverse(node.right, height + 1)\\n    }\\n    traverse(root, 1)\\n    let max = Math.max(...Object.values(map))\\n    for(let key in map) {\\n        if(max === map[key]) return key\\n    }\\n};"]}
{"id": "1136", "ref_js": ["var maxDistance = function(grid) {\\n    let q=[];\\n    for(let i=0;i<grid.length;i++){\\n        for(let j=0;j<grid[i].length;j++){\\n            if(grid[i][j]===1) q.push([i,j,0]);\\n        }\\n    }\\n    let max=0;\\n    while(q.length>0){\\n        ", "var maxDistance = function(grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    let x = n + m;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][j] === 1) {\\n                continue;\\n            }\\n            let top = x;\\n            let left = x;\\n            if (i - 1 >= 0) top = grid[i - 1][j];\\n            if (j - 1 >= 0) left = grid[i][j - 1];\\n            grid[i][j] = Math.min(top, left) + 1;\\n        }\\n    }\\n    \\n    for (let i = m - 1; i >= 0; i--) {\\n        for (let j = n - 1; j >= 0; j--) {\\n            if (grid[i][j] === 1) {\\n                continue;\\n            }\\n            let bottom = x;\\n            let right = x;\\n            if (i + 1 < m) bottom = grid[i + 1][j];\\n            if (j + 1 < n) right = grid[i][j + 1];\\n            grid[i][j] = Math.min(grid[i][j], Math.min(bottom, right) + 1);\\n        }\\n    }\\n    \\n    let count = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            count = Math.max(count, grid[i][j]);\\n        }\\n    }\\n    return count - 1 === n + m + 1 || count - 1 === 0 ? -1 : count - 1;\\n};", "var maxDistance = function(grid) {\\n    let q=[];\\n    for(let i=0;i<grid.length;i++){\\n        for(let j=0;j<grid[i].length;j++){\\n            if(grid[i][j]===1) q.push([i,j,0]);\\n        }\\n    }\\n    let max=0;\\n    while(q.length>0){\\n        "]}
{"id": "1138", "ref_js": ["var invalidTransactions = function(transactions) {\\n    const n = transactions.length;\\n    const added = new Array(n).fill(false);\\n    const res = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const [name1, time1, amount1, city1] = transactions[i].split(\",\");\\n        \\n        if (amount1 > 1000 && !added[i]) {\\n            res.push(transactions[i]);\\n            added[i] = true;\\n        }\\n        \\n        for (let j = i + 1; j < n; j++) {\\n            const [name2, time2, amount2, city2] = transactions[j].split(\",\");\\n            \\n            if (name1 === name2 && Math.abs(time1 - time2) <= 60 && city1 != city2) {\\n                if (!added[j]) {\\n                   res.push(transactions[j]);\\n                    added[j] = true;\\n                }\\n                \\n                if (!added[i]) {\\n                    res.push(transactions[i]);\\n                    added[i] = true;\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    return res;\\n};", "var invalidTransactions = function(transactions) {\\n\\tconst invalid = new Set();\\n\\tconst info = [];\\n\\n\\t", "var invalidTransactions = function(transactions) {\\n    const n = transactions.length;\\n    const added = new Array(n).fill(false);\\n    const res = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const [name1, time1, amount1, city1] = transactions[i].split(\",\");\\n        \\n        if (amount1 > 1000 && !added[i]) {\\n            res.push(transactions[i]);\\n            added[i] = true;\\n        }\\n        \\n        for (let j = i + 1; j < n; j++) {\\n            const [name2, time2, amount2, city2] = transactions[j].split(\",\");\\n            \\n            if (name1 === name2 && Math.abs(time1 - time2) <= 60 && city1 != city2) {\\n                if (!added[j]) {\\n                   res.push(transactions[j]);\\n                    added[j] = true;\\n                }\\n                \\n                if (!added[i]) {\\n                    res.push(transactions[i]);\\n                    added[i] = true;\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    return res;\\n};"]}
{"id": "1139", "ref_js": ["var numSmallerByFrequency = function (queries, words) {\\n  let res = [];\\n\\n  ", "var counts = function(queries){\\n    var nums1=[]\\n    for(var i=0;i<queries.length;i++){\\n        var min=queries[i][0]\\n        var count=0;\\n        for(var j=1;j<queries[i].length;j++){\\n            if(queries[i][j]<min)\\n                min=queries[i][j]\\n        }\\n        for(var j=0;j<queries[i].length;j++){\\n            if(min==queries[i][j])\\n                count++\\n        }\\n        nums1.push(count)\\n    }\\n    return nums1\\n}\\nvar numSmallerByFrequency = function(queries, words) {\\n    var nums1=counts(queries)\\n    var nums2=counts(words)\\n    var returnArray=[];\\n    for(var i=0;i<queries.length;i++){\\n        var count=0\\n        for(var j=0;j<words.length;j++){\\n            if(nums1[i]<nums2[j])\\n                count++;\\n        }\\n        returnArray.push(count)\\n    }\\n    return returnArray;\\n};", "var numSmallerByFrequency = function (queries, words) {\\n    "]}
{"id": "1140", "ref_js": ["var removeZeroSumSublists = function(head) {\\n    if (!head) {\\n        return head;\\n    }\\n    \\n\\t", "var removeZeroSumSublists = function(head) {\\n    const dummy = new ListNode(0), map = {0: dummy};", "var removeZeroSumSublists = function(head) {\\n    const dummy = new ListNode(0), map = {0: dummy};"]}
{"id": "1142", "ref_js": ["var canMakePaliQueries = function(s, queries) {\\n    const prefMap=[{[s[0]]:1}];\\n    for(let i=1;i<s.length;i++){\\n        const copyMap={...prefMap[i-1]};", "var canMakePaliQueries = function(s, queries) {\\n    const DEFAULT_CHAR_CODE = \\'a\\'.charCodeAt(0);\\n    const size = s.length;\\n    const prefixSum = Array(size + 1);\\n\\n    prefixSum[0] = Array(26).fill(0);\\n\\n    for (let index = 1; index <= size; index++) {\\n        const str = s[index - 1];\\n        const charCode = str.charCodeAt(0) - DEFAULT_CHAR_CODE;\\n\\n        prefixSum[index] = [...prefixSum[index - 1]];\\n        prefixSum[index][charCode] += 1;\\n    }\\n\\n    return queries.map(([left, right, k]) => {\\n        let sum = 0;\\n\\n        for (let code = 0; code < 26; code++) {\\n            sum += (prefixSum[right + 1][code] - prefixSum[left][code]) % 2;\\n        }\\n        return (sum / 2 | 0) <= k;\\n    });\\n};", "var canMakePaliQueries = function(s, queries) {\\n    const prefMap=[{[s[0]]:1}];\\n    for(let i=1;i<s.length;i++){\\n        const copyMap={...prefMap[i-1]};"]}
{"id": "1143", "ref_js": ["var maximumSum = function(arr) {\\n    let max = -Infinity,\\n        maxWithoutDeletion = -Infinity,\\n        front = new Array(arr.length),\\n        back = new Array(arr.length);\\n\\n    for(let i=0 ; i<arr.length ; i++){\\n        front[i] = Math.max(arr[i],arr[i]+(front[i-1]??-Infinity));\\n        if(maxWithoutDeletion<front[i])\\n            maxWithoutDeletion=front[i];\\n    }\\n\\n    for(let i=arr.length-1 ; i>=0 ; i--){\\n        back[i] = Math.max(arr[i],(back[i+1]??-Infinity)+arr[i]);\\n        if(maxWithoutDeletion<back[i])\\n            maxWithoutDeletion=back[i];\\n    }\\n    max = maxWithoutDeletion;\\n    for(let i=1 ; i<arr.length-1 ; i++)\\n        max = Math.max(max,front[i-1]+back[i+1]);\\n    \\n  return max;\\n};", "var maximumSum = function(arr) {\\n", "var maximumSum = function(arr) {\\n    let max = -Infinity,\\n        maxWithoutDeletion = -Infinity,\\n        front = new Array(arr.length),\\n        back = new Array(arr.length);\\n\\n    for(let i=0 ; i<arr.length ; i++){\\n        front[i] = Math.max(arr[i],arr[i]+(front[i-1]??-Infinity));\\n        if(maxWithoutDeletion<front[i])\\n            maxWithoutDeletion=front[i];\\n    }\\n\\n    for(let i=arr.length-1 ; i>=0 ; i--){\\n        back[i] = Math.max(arr[i],(back[i+1]??-Infinity)+arr[i]);\\n        if(maxWithoutDeletion<back[i])\\n            maxWithoutDeletion=back[i];\\n    }\\n    max = maxWithoutDeletion;\\n    for(let i=1 ; i<arr.length-1 ; i++)\\n        max = Math.max(max,front[i-1]+back[i+1]);\\n    \\n  return max;\\n};"]}
{"id": "1144", "ref_js": ["var reverseParentheses = function(s) {\\n  let arr= s.split(\\'\\')\\nlet stk=[]\\nlet queue=[]\\nfor (let st of arr){\\n  if(st===\\')\\'){\\n    let j= stk.length-1;\\n    while (stk[j] !==\\'(\\'){\\n      queue.push(stk.pop());\\n      j--;\\n    }\\n      stk.pop();\\n      while(queue.length ){\\n        stk.push(queue.shift());\\n        }\\n    }else{\\n      stk.push(st);\\n    }\\n  \\n}\\n\\n    return stk.join(\\'\\')\\n};", "var reverseParentheses = function(s) {\\nlet a = \"\";\\nlet stack = [];\\n\\nfor (let i = 0; i < s.length; i++) {\\n  if (stack.length !== 0) {\\n    if (s[i] !== \"(\" && s[i] !== \")\") {\\n      stack.at(-1)[1] += s[i];\\n    } else if (s[i] == \"(\") {\\n      stack.push([s[i], \"\"]);\\n    } else if (s[i] == \")\") {\\n      let c = stack.at(-1)[1].split(\"\").reverse().join(\"\");\\n      stack.pop();  \\n      if (stack.length !== 0) {\\n        stack.at(-1)[1] += c;\\n      } else {\\n        a += c;\\n      } \\n    }\\n  } else {\\n    if (s[i] == \"(\") {\\n      stack.push([s[i], \"\"]);\\n    } else {\\n      a += s[i];\\n    } \\n  }\\n}\\nreturn a;\\n};", "var reverseParentheses = function(s) {\\n    let stack = [];\\n    let i = 0;\\n    while(i<s.length){\\n        if(s[i] !== \")\"){\\n            stack.push(s[i])\\n        }else{\\n            let j = stack.length-1;\\n            let str = \"\";\\n            while(stack[j] !== \"(\" && j>=0){\\n              let popEle = stack.pop()\\n              str +=popEle;\\n               j--;\\n            }\\n            stack.pop() "]}
{"id": "1145", "ref_js": ["var kConcatenationMaxSum = function(arr, k) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = arr.length;\\n    const minK = Math.min(2, k);\\n    const sum = arr.reduce((total, num) => total + num);\\n    let currnetSum = result = 0;\\n\\n    for (let index = 0; index < size * minK; index++) {\\n        const num = arr[index % size];\\n\\n        currnetSum = Math.max(currnetSum + num, num);\\n        result = Math.max(result, currnetSum);\\n    }\\n    return Math.max(result, sum * Math.max(0, k - 2) + result) % MODULO;\\n};", "var kConcatenationMaxSum = function(ar, k) {\\n    let ans1 = maxSum(ar)%mod\\n    \\n    if(k==1)\\n        return ans1;\\n    \\n    let ar2 = [...ar, ...ar]\\n    let ans2 = maxSum(ar2)%mod\\n    \\n    if(k==2)\\n        return ans2;\\n    \\n    if(k>=3){\\n        let ar3 = [...ar2, ...ar]\\n        let ans3 = maxSum(ar3)%mod\\n        let diff = subMod(ans3,ans2)\\n        \\n        if(diff === 0) ", "var kConcatenationMaxSum = function(arr, k) {\\n  var MOD = 1000000007;\\n  var totalSum = 0;\\n  var localMax = 0;\\n  var globalMax = 0;\\n  \\n  \\n  arr.forEach((num) => {\\n    totalSum += num;\\n    localMax = Math.max(num, localMax + num);\\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  \\n  if (k === 1 || globalMax === 0) {\\n    return globalMax % MOD;\\n  }\\n  \\n  \\n  arr.forEach((num) => {\\n    localMax = Math.max(num, localMax + num); \\n    globalMax = Math.max(localMax, globalMax); \\n  });\\n  \\n  \\n  if (totalSum > 0) {\\n    globalMax += (k - 2) * totalSum;\\n  }\\n  \\n  return globalMax % MOD;\\n};"]}
{"id": "1148", "ref_js": ["var nthUglyNumber = function (target, a, b, c) {\\n    let L = 1;\\n    let R = 2 * 10 ** 9; ", "var nthUglyNumber = function(n, a, b, c) {\\n    const gcd = (a, b) => a === 0 ? b : gcd(b % a, a);\\n    const lcm = (a, b) => a * b / gcd(a, b);\\n    const lcmAB = lcm(a, b);\\n    const lcmBC = lcm(b, c);\\n    const lcmAC = lcm(a, c);\\n    const lcmABC = lcm(lcmAB, c);\\n    let low = 1;\\n    let high = 2 * 10 ** 9;\\n\\n    while (low < high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const countA = Math.floor(mid / a);\\n        const countB = Math.floor(mid / b);\\n        const countC = Math.floor(mid / c);\\n        const countAB = Math.floor(mid / lcmAB);\\n        const countBC = Math.floor(mid / lcmBC);\\n        const countAC = Math.floor(mid / lcmAC);\\n        const countABC = Math.floor(mid / lcmABC);\\n        const count = countA + countB + countC - countAB - countBC - countAC + countABC;\\n\\n        count < n ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n};", "var nthUglyNumber = function (target, a, b, c) {\\n    let L = 1;\\n    let R = 2 * 10 ** 9; "]}
{"id": "1149", "ref_js": ["var smallestStringWithSwaps = function(s, pairs) {\\nfunction DisjointSet(len) {\\nthis.par = [];\\nfor (let i = 0; i < len; ++i) {\\nthis.par[i] = i;\\n}\\n}\\nDisjointSet.prototype.find = function(u) {\\nreturn (this.par[u] = this.par[u] == u ? u : this.find(this.par[u]));\\n};", "var smallestStringWithSwaps = function(s, pairs) {\\n    const DS = [...Array(s.length)].map((_, i) => i);\\n    const group = new Map()\\n    const charMap = new Map();\\n    const result = [];\\n    \\n    function find(id) { \\n        if(id === DS[id]) return id;\\n        DS[id] = find(DS[id]);\\n        return DS[id];\\n    }\\n    \\n    for(let [u, v] of pairs) {\\n        const rootU = find(u);\\n        const rootV = find(v);\\n        DS[rootV] = rootU\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        find(i)\\n        if(!charMap.has(s[i])) charMap.set(s[i], []);\\n        if(!group.has(DS[i])) group.set(DS[i], []);\\n        charMap.get(s[i]).push(i);\\n        group.get(DS[i]).push(i);\\n    }\\n    \\n    const charSorted = [...charMap.entries()].sort(([a], [b]) => a.charCodeAt() - b.charCodeAt());\\n    \\n    for(let [char, idxs] of charSorted) {\\n        for(let i of idxs) {\\n            const newIdx = group.get(DS[i]).shift();\\n            result[newIdx] = char;\\n        }\\n    }\\n    return result.join(\\'\\')\\n};", "var smallestStringWithSwaps = function(s, pairs) {\\nfunction DisjointSet(len) {\\nthis.par = [];\\nfor (let i = 0; i < len; ++i) {\\nthis.par[i] = i;\\n}\\n}\\nDisjointSet.prototype.find = function(u) {\\nreturn (this.par[u] = this.par[u] == u ? u : this.find(this.par[u]));\\n};"]}
{"id": "1151", "ref_js": ["var equalSubstring = function (s, t, maxCost) {\\n  const distance = (ch1, ch2) => {\\n    return Math.abs(ch1.charCodeAt(0) - ch2.charCodeAt(0))\\n  }\\n\\n  let maxLen = 0\\n  let n = s.length\\n  let totalCost = 0\\n  for (let L = 0, R = 0; R < n;) {\\n    totalCost += distance(s[R], t[R]); ", "var equalSubstring = function(s, t, maxCost) {\\n    let left = 0, curr = 0, ans = 0;\\n    let map = new Map();\\n    for(let right = 0; right < s.length; right++) {\\n        if(s[right] !== t[right]) {\\n            let subst = Math.abs(s.charCodeAt(right) - t.charCodeAt(right))\\n            map.set(right, subst);\\n            curr += subst;\\n\\n            while(curr > maxCost) {\\n                curr -= (map.get(left) || 0);\\n                left++;\\n            }\\n        }\\n        ans = Math.max(ans, right - left + 1);\\n    }\\n\\n    return ans;\\n};", "var equalSubstring = function(s, t, maxCost) {\\n    let max_length = 0;\\n    let L = 0;\\n    let cost  = 0;\\n\\n    let acsiiCost = (s,t)=>{\\n        return Math.abs(s.charCodeAt(0) - t.charCodeAt(0))\\n    }\\n\\n    for(let R = 0; R < s.length; R ++){\\n        cost += acsiiCost(s[R],t[R])\\n\\n        while(cost > maxCost){\\n            cost -= acsiiCost(s[L], t[L]); \\n            L++\\n        }\\n        max_length = Math.max(max_length,R-L +1)\\n    \\n    }\\n    return max_length;\\n};"]}
{"id": "1152", "ref_js": ["var removeDuplicates = function (s, k) {\\n  let d = [];\\n  let output = \"\";\\n  for (let i of s) {\\n    if (d.length && d[d.length - 1][0] == i) {\\n      d[d.length - 1][1]++;\\n\\n      if (d[d.length - 1][1] == k) {\\n        d.pop();\\n      }\\n    } else {\\n      d.push([i, 1]);\\n    }\\n  }\\n\\n  for (let i of d) {\\n    output += i[0].repeat(i[1]);\\n  }\\n  return output;\\n};", "var removeDuplicates = function(s, k) {\\n    if (s.length < k) {\\n        return s;\\n    }\\n\\n    const st = [];\\n\\n    for (const c of s) {\\n        if (st.length && c === st[st.length - 1][0]) {\\n            st[st.length - 1][1]++;\\n\\n            if (st[st.length - 1][1] === k) {\\n                st.pop();\\n            }\\n        } else {\\n            st.push([c, 1]);\\n        }\\n    }\\n\\n    let res = \"\";\\n    for (const [char, count] of st) {\\n        res += char.repeat(count);\\n    }\\n\\n    return res;    \\n};", "var removeDuplicates = function(s, k) {\\n    const stack = [];\\n    \\n    for(let char of s) {\\n        if(stack.length && stack[stack.length-1][0] === char) {\\n            stack[stack.length-1][1] += 1;\\n            if(stack[stack.length-1][1] === k) {\\n                stack.pop();\\n            }\\n        } else {\\n            stack.push([char, 1]);\\n        }\\n    }\\n    \\n    let res = \\'\\';\\n    \\n    for(let [char, count] of stack) {\\n        res += char.repeat(count);\\n    }\\n    \\n    return res;\\n};"]}
{"id": "1153", "ref_js": ["var longestSubsequence = function(arr, difference) {\\n    let dp = {};", "var longestSubsequence = function(arr, difference) {\\n    let map = new Map(); ", "var longestSubsequence = function(arr, difference) {\\n    const dp = new Map();\\n  let maxLength = 0;\\n\\n  for (const num of arr) {\\n    const prevNum = num - difference;\\n\\n    if (dp.has(prevNum)) {\\n      dp.set(num, dp.get(prevNum) + 1);\\n    } else {\\n      dp.set(num, 1);\\n    }\\n    maxLength = Math.max(maxLength, dp.get(num));\\n  }\\n\\n  return maxLength;\\n};"]}
{"id": "1154", "ref_js": ["var getMaximumGold = function(grid) {\\n    let count = 0;\\n    for(let i = 0; i<grid.length; i++){\\n        for(let j = 0; j<grid[i].length; j++){\\n            if(grid[i][j]!==0) count = Math.max(count, maxGold(grid, i, j));\\n        }\\n    }\\n    return count;\\n};", "var getMaximumGold = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let maxGold = 0;\\n    for ( let i = 0; i < m; i++ ) {\\n        for ( let j = 0; j < n; j++ ) {\\n            maxGold = Math.max(maxGold, backTrack(i, j, m, n, grid));\\n        }\\n    }\\n    return maxGold;\\n};", "var getMaximumGold = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let maxGold = 0;\\n    for ( let i = 0; i < m; i++ ) {\\n        for ( let j = 0; j < n; j++ ) {\\n            maxGold = Math.max(maxGold, backTrack(i, j, m, n, grid));\\n        }\\n    }\\n    return maxGold;\\n};"]}
{"id": "1155", "ref_js": ["var queensAttacktheKing = function(queens, king) {\\n    const [a,b] = king\\n    const mapped = queens.reduce((init,[x,y]) => {\\n        init.set(`${x}:${y}`)\\n        return init\\n    }, new Map())\\n\\n     const dfs = (x,y, difX = 0, difY = 0) => {\\n        while(!(x === a && y === b)){\\n            x += difX\\n            y += difY\\n            if(mapped.has(`${x}:${y}`)){\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\n    const result = []\\n    \\n    for(let i = 0; i < queens.length; i++){\\n        const [x,y] = queens[i]\\n        const difX = x > a ? -1: 1\\n        const difY = y > b ? -1: 1\\n        const rowMatches = x === a && dfs(x, y, 0, difY)\\n        const columnMatches = !rowMatches && y === b && dfs(x, y, difX, 0)\\n        const dioganalMatches =!columnMatches && (Math.abs(x-a) - Math.abs(y-b)) === 0 && dfs(x, y, difX, difY)\\n        if(rowMatches || columnMatches || dioganalMatches){\\n            result.push(queens[i])\\n        }\\n    }\\n\\n    return result\\n};", "var queensAttacktheKing = function(queens, king) {\\n    const result = [];\\n\\n    const directions = [\\n       [-1,0],[1,0], ", "var queensAttacktheKing = function (queens, king) {\\n  const directions = [\\n    [-1, 0], [1, 0], "]}
{"id": "1157", "ref_js": ["var nthPersonGetsNthSeat = function(n) {\\n    return n == 1 ? 1 : 0.5;\\n};", "var nthPersonGetsNthSeat = function(n) {\\n    return n===1? 1 :0.5\\n};", "var nthPersonGetsNthSeat = function(n) {\\n   return n ===1 ? 1.0 : 0.5\\n};"]}
{"id": "1158", "ref_js": ["var removeSubfolders = function(folder) {\\n    folder = folder.sort()\\n    const result = [];\\n    for(let i in folder){\\n        const f = folder[i];\\n        if(result.length == 0 || !f.startsWith(result[result.length -1] + \"/\"))\\n            result.push(f);\\n    }\\n    return result;\\n};", "var removeSubfolders = function(folder) {\\n    const foldrSet = new Set();\\n\\n    folder.sort((a, b) => a.length - b.length);\\n\\n    return folder.reduce((result, path) => {\\n        const splitPath = path.split(\\'/\\');\\n        let tempPath = \\'\\';\\n\\n        for (let index = 1; index < splitPath.length; index++) {\\n            tempPath += `/${splitPath[index]}`;\\n\\n            if (foldrSet.has(tempPath)) return result;\\n        }\\n        result.push(path);\\n        foldrSet.add(path);\\n        return result;\\n    }, []);\\n};", "var removeSubfolders = function(folder) {\\n    const folders = {};"]}
{"id": "1159", "ref_js": ["var balancedString = function(s) {\\n  const l = s.length;\\n  let start = 0, end = 0, res = l, need = 0;\\n  const count = { \\'Q\\': 0, \\'W\\': 0, \\'E\\': 0, \\'R\\': 0 };", "var balancedString = function(s) {\\n    const map = {}, extra = {};", "var balancedString = function(s) {\\n    const map = {}, extra = {};"]}
{"id": "1160", "ref_js": ["var findSolution = function(customfunction, z) {\\n    var ans = []\\n    var x = 1, y = 1000;\\n    while(x<=1000 && y>0){\\n        if(customfunction.f(x,y)>z){\\n            y--;\\n        }else if(customfunction.f(x,y)<z){\\n            x++;\\n        }else{\\n            ans.push([x,y]);\\n            x++;\\n            y--;\\n        }\\n    }\\n    return ans;\\n};", "var findSolution = function(customfunction, z) {\\n    const result = [];\\n    let x = 1;\\n    let y = 1000;\\n\\n    while (x <= 1000 && y > 0) {\\n        const value = customfunction.f(x, y);\\n\\n        if (value < z) x += 1;\\n        else if (value > z) y -= 1;\\n        else {\\n            result.push([x, y]);\\n            x += 1;\\n            y -= 1;\\n        }\\n    }\\n    return result;\\n};", "var findSolution = function(customfunction, z) {\\n    var ans = []\\n    var x = 1, y = 1000;\\n    while(x<=1000 && y>0){\\n        if(customfunction.f(x,y)>z){\\n            y--;\\n        }else if(customfunction.f(x,y)<z){\\n            x++;\\n        }else{\\n            ans.push([x,y]);\\n            x++;\\n            y--;\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "1161", "ref_js": ["var grayCode = function (n) {\\r\\n    let a = [];\\r\\n    for (let i = 0; i < 2 ** n; i++) {\\r\\n        a.push(i ^ (i / 2));\\r\\n    }\\r\\n    return a;\\r\\n};", "var grayCode = function (n) {\\r\\n    let a = [];\\r\\n    for (let i = 0; i < 2 ** n; i++) {\\r\\n        a.push(i ^ (i / 2));\\r\\n    }\\r\\n    return a;\\r\\n};", "var grayCode = function (n) {\\r\\n    let a = [];\\r\\n    for (let i = 0; i < 2 ** n; i++) {\\r\\n        a.push(i ^ (i / 2));\\r\\n    }\\r\\n    return a;\\r\\n};"]}
{"id": "1162", "ref_js": ["var maxLength = function(arr) {\\n    const set = new Set([\\'\\']);\\n    let max = 0;\\n    let str;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        const values = [...set.values()];\\n        \\n        for(let j = 0; j < values.length; j++) {     \\n            str = `${values[j]}${arr[i]}`;\\n            set.add(str);\\n            let newStr = [...new Set(str).values()].join(\\'\\');\\n            \\n            if (str === newStr) {\\n                max = Math.max(str.length, max);    \\n            }            \\n        }\\n    }\\n    \\n    return max;\\n};", "var maxLength = function(arr) {\\n    let ans = 0;\\n\\n  \\n  let isUnique = (str) => {\\n    let bits = 1 << 26;\\n    for (let ch of str) {\\n      let index = ch.charCodeAt(0) - 97;\\n      ", "var maxLength = function(arr) { \\n    let result = 0,index=0,str=\"\"; \\n    \\n    "]}
{"id": "1163", "ref_js": ["var minimumSwap = function(s1, s2) {\\n    let xy = yx = 0;\\n\\n    for (let index = 0; index < s1.length; index++) {\\n        if (s1[index] === s2[index]) continue;\\n\\n        s1[index] === \\'x\\' ? xy += 1 : yx += 1;\\n    }\\n    if (xy % 2 !== yx % 2) return -1;\\n\\n    return (xy / 2 | 0) + (yx / 2 | 0) + xy % 2 * 2;\\n};", "var minimumSwap = function(s1, s2) {\\n   let count1 = 0;\\n    let count2 = 0;\\n   for(let i in s1) {\\n       if(s1[i] === \"x\" && s2[i] === \"y\") {\\n           count1++\\n       }\\n        if(s1[i] === \"y\" && s2[i] === \"x\") {\\n           count2++\\n       }\\n   }\\n    \\n    let ans = Math.floor(count1 / 2) + Math.floor(count2 / 2);\\n    if(count1 % 2 === 0  && count2 % 2 === 0){\\n        return ans\\n    }\\n    else if(count1 % 2 !== 0  && count2 % 2 !== 0){\\n        return ans + 2;\\n    }\\n    else {\\n        return -1;\\n    }\\n};", "var minimumSwap = function(s1, s2) {\\n   let count1 = 0;\\n    let count2 = 0;\\n   for(let i in s1) {\\n       if(s1[i] === \"x\" && s2[i] === \"y\") {\\n           count1++\\n       }\\n        if(s1[i] === \"y\" && s2[i] === \"x\") {\\n           count2++\\n       }\\n   }\\n    \\n    let ans = Math.floor(count1 / 2) + Math.floor(count2 / 2);\\n    if(count1 % 2 === 0  && count2 % 2 === 0){\\n        return ans\\n    }\\n    else if(count1 % 2 !== 0  && count2 % 2 !== 0){\\n        return ans + 2;\\n    }\\n    else {\\n        return -1;\\n    }\\n};"]}
{"id": "1164", "ref_js": ["var numberOfSubarrays = function(nums, k) {\\r\\n    let odds=0;\\r\\n    let count=0;\\r\\n    let prefix=0\\r\\n\\r\\n    let i=0;\\r\\n\\r\\n    for(let j=0;j<nums.length;j++){\\r\\n        if(nums[j]%2!=0){ \\r\\n            odds+=1\\r\\n            prefix=0\\r\\n            }\\r\\n\\r\\n        while(odds==k && i<=j){\\r\\n         if(nums[i]%2!=0)   odds-=1\\r\\n            i++\\r\\n           prefix++\\r\\n      \\r\\n        }\\r\\n       \\r\\n   count+=prefix\\r\\n\\r\\n    }\\r\\n    return count\\r\\n};", "var numberOfSubarrays = function(nums, k) {\\r\\n  nums = nums.map((num) => (num % 2 === 0 ? 0 : 1));\\r\\n  let end = 0;\\r\\n  let start = 0;\\r\\n  let count = 0;\\r\\n  let total = 0;\\r\\n  let localOddCount = 0;\\r\\n  const checkOddEven = (num) => num % 2 === 1;\\r\\n  while (end < nums.length) {\\r\\n    if (checkOddEven(nums[end])) {\\r\\n      count = 0;\\r\\n      localOddCount++;\\r\\n    }\\r\\n    while (localOddCount === k) {\\r\\n      count++;\\r\\n      if (checkOddEven(nums[start])) {\\r\\n        localOddCount--;\\r\\n      }\\r\\n      start++;\\r\\n    }\\r\\n    ", "var numberOfSubarrays = function(nums, target) {\\n    let found = 0 ; \\n    for(let i = 0 ; i < nums.length ;  ++i){\\n        for(let j = i ; j < nums.length ; ++j){\\n            let count = 0 ; \\n            for(let k =  i ; k <= j ; ++k){\\n                if(nums[k] % 2 == 1){\\n                    ++count ; \\n                }\\n            }\\n            if(count == target){\\n                    ++found ; \\n            }\\n        }\\n    }\\n    return found; \\n};"]}
{"id": "1165", "ref_js": ["var minRemoveToMakeValid = function(s) {\\n    s = s.split(\"\")\\n    let stack = []\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \"(\")     stack.push(i)\\n        else if (s[i] == \")\"){\\n            if(stack.length)    stack.pop()\\n            else s[i] = \"\"\\n        }\\n    }\\n    for(let i of stack) s[i] = \"\"\\n    return s.join(\"\")\\n};", "var minRemoveToMakeValid = function(s) {\\n    s = s.split(\"\")\\n    let stack = []\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \"(\")     stack.push(i)\\n        else if (s[i] == \")\"){\\n            if(stack.length)    stack.pop()\\n            else s[i] = \"\"\\n        }\\n    }\\n    for(let i of stack) s[i] = \"\"\\n    return s.join(\"\")\\n};", "var minRemoveToMakeValid = function(s) {\\n    s = s.split(\"\")\\n    let stack = []\\n    for(let i=0; i<s.length; i++){\\n        if(s[i] == \"(\")     stack.push(i)\\n        else if (s[i] == \")\"){\\n            if(stack.length)    stack.pop()\\n            else s[i] = \"\"\\n        }\\n    }\\n    for(let i of stack) s[i] = \"\"\\n    return s.join(\"\")\\n};"]}
{"id": "1166", "ref_js": ["var reconstructMatrix = function(upper, lower, colsum) {\\n    const result = [[], []];\\n\\n    for (let index = 0; index < colsum.length; index++) {\\n        const sum = colsum[index];\\n        if (sum === 0) {\\n           result[0][index] = result[1][index] = 0;\\n           continue; \\n        }\\n\\n        if (sum === 2) {\\n            result[0][index] = result[1][index] = 1;\\n            upper -= 1;\\n            lower -= 1;\\n        } else if (upper > lower) {\\n            result[0][index] = 1;\\n            result[1][index] = 0;\\n            upper -= 1;\\n        } else {\\n            result[0][index] = 0;\\n            result[1][index] = 1;\\n            lower -= 1;\\n        }\\n        if (upper < 0 || lower < 0) return [];\\n    }\\n    return upper > 0 || lower > 0 ? [] : result;\\n};", "var reconstructMatrix = function(upper, lower, colsum) {\\n    const result = [[], []];\\n\\n    for (let index = 0; index < colsum.length; index++) {\\n        const sum = colsum[index];\\n        if (sum === 0) {\\n           result[0][index] = result[1][index] = 0;\\n           continue; \\n        }\\n\\n        if (sum === 2) {\\n            result[0][index] = result[1][index] = 1;\\n            upper -= 1;\\n            lower -= 1;\\n        } else if (upper > lower) {\\n            result[0][index] = 1;\\n            result[1][index] = 0;\\n            upper -= 1;\\n        } else {\\n            result[0][index] = 0;\\n            result[1][index] = 1;\\n            lower -= 1;\\n        }\\n        if (upper < 0 || lower < 0) return [];\\n    }\\n    return upper > 0 || lower > 0 ? [] : result;\\n};", "var reconstructMatrix = function(upper, lower, colsum) {\\n    const result = [[], []];\\n\\n    for (let index = 0; index < colsum.length; index++) {\\n        const sum = colsum[index];\\n        if (sum === 0) {\\n           result[0][index] = result[1][index] = 0;\\n           continue; \\n        }\\n\\n        if (sum === 2) {\\n            result[0][index] = result[1][index] = 1;\\n            upper -= 1;\\n            lower -= 1;\\n        } else if (upper > lower) {\\n            result[0][index] = 1;\\n            result[1][index] = 0;\\n            upper -= 1;\\n        } else {\\n            result[0][index] = 0;\\n            result[1][index] = 1;\\n            lower -= 1;\\n        }\\n        if (upper < 0 || lower < 0) return [];\\n    }\\n    return upper > 0 || lower > 0 ? [] : result;\\n};"]}
{"id": "1167", "ref_js": ["var closedIsland = function (grid) {\\n    let result = 0;\\n    let rows = grid.length;\\n    let cols = grid[0].length;\\n    if (cols < 3 || rows < 3) return 0;\\n    let checkNeighbours = (i, j) => {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols) {\\n            return false;\\n        }\\n        if (grid[i][j] === 1) {\\n            return true;\\n        }\\n        grid[i][j] = 1;\\n        let left = checkNeighbours(i, j - 1);\\n        let right = checkNeighbours(i, j + 1);\\n        let top = checkNeighbours(i - 1, j);\\n        let bottom = checkNeighbours(i + 1, j);\\n        return left && right && top && bottom;\\n    }\\n\\n    for (let i = 1; i < rows - 1; i++) {\\n        for (let j = 1; j < cols - 1; j++) {\\n            if (grid[i][j] === 0) {\\n                result += checkNeighbours(i, j);\\n            }\\n        }\\n    }\\n    return result;\\n};", "var closedIsland = function (grid) {\\n    ", "var closedIsland = function(grid) {\\n    const rowLen = grid.length\\n    const colLen = grid[0].length\\n\\n    "]}
{"id": "1169", "ref_js": ["var maxSumDivThree = function(nums) {\\n    let remainOne = remainTwo = 10 ** 4;\\n    let sum = 0;\\n\\n    nums.forEach(num => {\\n        sum += num;\\n        if (num % 3 === 1) {\\n            remainTwo = Math.min(remainTwo, remainOne + num);\\n            remainOne = Math.min(remainOne, num);\\n        } else if (num % 3 === 2) {\\n            remainOne = Math.min(remainOne, remainTwo + num);\\n            remainTwo = Math.min(remainTwo, num);\\n        }\\n    });\\n\\n    const remainSum = sum % 3;\\n\\n    if (remainSum === 0) return sum;\\n    if (remainSum === 1) return sum - remainOne;\\n    return sum - remainTwo;\\n};", "var maxSumDivThree = function(nums) {\\n    let dp = new Array(3).fill(0);\\n    for (let num of nums) {\\n        for (let i of dp.slice(0)) {\\n            let sum = i + num;\\n            let mod = sum % 3;\\n            dp[mod] = Math.max(dp[mod], sum);\\n        }\\n    }\\n    return dp[0];\\n};", "var maxSumDivThree = function(nums) {\\n    let remainOne = remainTwo = 10 ** 4;\\n    let sum = 0;\\n\\n    nums.forEach(num => {\\n        sum += num;\\n        if (num % 3 === 1) {\\n            remainTwo = Math.min(remainTwo, remainOne + num);\\n            remainOne = Math.min(remainOne, num);\\n        } else if (num % 3 === 2) {\\n            remainOne = Math.min(remainOne, remainTwo + num);\\n            remainTwo = Math.min(remainTwo, num);\\n        }\\n    });\\n\\n    const remainSum = sum % 3;\\n\\n    if (remainSum === 0) return sum;\\n    if (remainSum === 1) return sum - remainOne;\\n    return sum - remainTwo;\\n};"]}
{"id": "1170", "ref_js": ["var countServers = function (grid) {\\n    const MAX_ROWS = 250;\\n    const MAX_COLUMNS = 250;\\n\\n    let serversInRow = new Array(MAX_ROWS + 1).fill(0);\\n    let serversInColumn = new Array(MAX_COLUMNS + 1).fill(0);\\n\\n    for (let r = 0; r < grid.length; ++r) {\\n        for (let c = 0; c < grid[0].length; ++c) {\\n            if (grid[r][c] === 1) {\\n                ++serversInRow[r];\\n                ++serversInColumn[c];\\n            }\\n        }\\n    }\\n\\n    let connectedServers = 0;\\n    for (let r = 0; r < grid.length; ++r) {\\n        for (let c = 0; c < grid[0].length; ++c) {\\n            if (grid[r][c] === 1 && (serversInRow[r] > 1 || serversInColumn[c] > 1)) {\\n                ++connectedServers;\\n            }\\n        }\\n    }\\n    return connectedServers;\\n};", "var countServers = function(grid) {\\n    ", "var countServers = function (grid) {\\n    let countConnected = 0;\\n    let rowsCounts = grid.map((value) => {\\n        return value.reduce((prev, curr) => prev + curr);\\n    });\\n    let colsCounts = Array.from({ length: grid[0].length }, (_, colIndex) =>\\n        grid.reduce((sum, row) => sum + row[colIndex], 0)\\n    );\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] == 1 && (rowsCounts[i] > 1 || colsCounts[j] > 1))\\n                countConnected++;\\n        }\\n    }\\n    return countConnected;\\n};"]}
{"id": "1171", "ref_js": ["var suggestedProducts = function(P, S) {\\n    P.sort()\\n    let ans = [], left = 0, right = P.length - 1\\n    for (let i = 0; i < S.length; i++) {\\n        let c = S.charAt(i), res = []\\n        while (P[left]?.charAt(i) < c) left++\\n        while (P[right]?.charAt(i) > c) right--\\n        for (let j = 0; j < 3 && left + j <= right; j++)\\n            res.push(P[left+j])\\n        ans.push(res)\\n    }\\n    return ans\\n};", "var suggestedProducts = function(products, searchWord) {\\n    products.sort()\\n    let arr=[]\\n    for(let i = 0; i<searchWord.length;i++){\\n        let search = searchWord.slice(0,i+1) \\n           let tem = products.filter(val=> val.slice(0,i+1) === search )\\n            arr.push(tem.slice(0,3))\\n          }\\n    return arr\\n};", "var suggestedProductsTrie = function(products, searchWord) {\\n    \\n    products.sort();\\n    \\n    let trie = {};"]}
{"id": "1172", "ref_js": ["var numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (cheeseSlices * 2 > tomatoSlices) return [];\\n    if (tomatoSlices % 2 === 1) return [];\\n    if (tomatoSlices === 0 && cheeseSlices === 0) return [0, 0];\\n\\n    const maxSmallBurger = tomatoSlices / 2;\\n    const jumboBurger = maxSmallBurger - cheeseSlices;\\n    const smallBurger = maxSmallBurger - jumboBurger * 2;\\n\\n    return smallBurger >= 0 ? [jumboBurger, smallBurger] : [];\\n};", "var numOfBurgers = function (tomatoSlices, cheeseSlices) {\\n  let totalBurgerCount = cheeseSlices;\\n\\n  for (let jumboBurgerCount = 0; jumboBurgerCount <= totalBurgerCount; jumboBurgerCount++) {\\n    let jumboBurgerTomatoSliceCount = jumboBurgerCount * 4;\\n    let smallBurgerTomatoSliceCount = (totalBurgerCount - jumboBurgerCount) * 2;\\n    let totalTomatoSlices = jumboBurgerTomatoSliceCount + smallBurgerTomatoSliceCount;\\n    if (totalTomatoSlices === tomatoSlices) {\\n      return [jumboBurgerCount, totalBurgerCount - jumboBurgerCount];\\n    }\\n  }\\n\\n  return [];\\n};", "var numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n  if (tomatoSlices == 0 && cheeseSlices == 0) return [0,0];\\n  if (tomatoSlices == 0) return [];\\n  if (cheeseSlices == 0) return [];\\n  if (cheeseSlices > tomatoSlices/2) return [];\\n  \\n  "]}
{"id": "1173", "ref_js": ["var countSquares = function (matrix) {\\n  let dp = new Array(matrix.length).fill().map(() => {\\n    return new Array(matrix[0].length).fill(0);\\n  });\\n  let ans = 0;\\n  for (let i = 0; i < dp.length; i++) {\\n    for (let j = 0; j < dp[0].length; j++) {\\n      if (matrix[i][j] == 0) {\\n        ", "var countSquares = function(matrix) {\\n    \\n    \\n    ", "var countSquares = function(matrix) {\\n    \\n    \\n    "]}
{"id": "1174", "ref_js": ["var groupThePeople = function(groupSizes) {\\n    let ans = []\\n    let hash = {}\\n\\n    for (let i = 0; i < groupSizes.length; i++) {\\n        const temp = groupSizes[i]\\n        if(hash[temp]) {\\n            hash[temp].push(i)\\n        } else {\\n            hash[temp] = [i]\\n        }\\n\\n        if (hash[temp].length === temp) {\\n            ans.push(hash[temp])\\n            delete hash[temp]\\n        }\\n    }\\n\\n    return ans\\n};", "var groupThePeople = function(groupSizes) {\\n    const temp_group = {};", "var groupThePeople = function(groupSizes) {\\n    const res = [];\\n    const groups = {};"]}
{"id": "1175", "ref_js": ["var smallestDivisor = function(nums, threshold) {\\n    ", "var smallestDivisor = function (a, k) {\\n  let low = 0;\\n  let high = a.reduce((a, b) => a + b, 0);\\n\\n  while (low <= high) {\\n    let mid = parseInt((low + high) / 2);\\n    let minDivisor = a\\n      .map((x) => Math.ceil(x / mid))\\n      .reduce((a, b) => a + b, 0);\\n\\n    if (minDivisor > k) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return low;\\n};", "var smallestDivisor = function (nums, threshold) {\\n    let min = 1, max = Math.max(...nums);\\n    let low=min,high=max,ans=Infinity\\n    while (low <= high) {\\n        var mid = Math.floor((low + high) / 2)\\n        if(check(mid,nums,threshold)){\\n            ans=Math.min(ans,mid)\\n            high=mid-1\\n        }else {\\n            low=mid+1\\n        }\\n    }\\n    return ans\\n};"]}
{"id": "1177", "ref_js": ["var removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]))\\n    let count = 0, cur = 0\\n    for(let interval of intervals){\\n        if(cur < interval[1]){\\n            cur = interval[1]\\n            count++\\n        }\\n    }\\n    return count\\n};", "var removeCoveredIntervals = function(intervals) {\\n  intervals.sort((a,b)=> a[0]-b[0] || b[1]-a[1]);\\n  let overlap=0;\\n  for (i=1,prev=0; i<intervals.length; i++)\\n", "var removeCoveredIntervals = function(intervals) {\\n    let count = intervals.length\\n    for (var [index1, i1] of intervals.entries()) {\\n        for (var [index2, i2] of intervals.entries()) {\\n            if (index2 !== index1) {\\n                if (i2[0] <= i1[0] && i1[1] <= i2[1]) {\\n                    count--\\n                    break\\n                }   \\n            }\\n        }\\n    }\\n    return count\\n};"]}
{"id": "1178", "ref_js": ["var sequentialDigits = function(low, high) {\\n  let res = [];\\n  for (let i = 1; i <= 9; i++) {\\n    dfs(low, high, i, 0, res);\\n  }\\n  return res.sort((a, b) => a - b)\\n};", "var sequentialDigits = function(low, high) {\\n    let arr = [\\n        12,23,34,45,56,67,78,89,\\n        123,234,345,456,567,678,789,\\n        1234,2345,3456,4567,5678,6789,\\n        12345,23456,34567,45678,56789,\\n        123456,234567,345678,456789,\\n        1234567,2345678,3456789,\\n        12345678,23456789,\\n        123456789\\n    ];\\n\\n    let resutarr = [];\\n   for(let i =0;i<arr.length;i++){\\n       if(low<= arr[i] && high>=arr[i]){\\n           resutarr.push(arr[i]);\\n       }\\n   }\\n\\n   return resutarr;\\n};", "var sequentialDigits = function(low, high) {\\n    "]}
{"id": "1179", "ref_js": ["var maxSideLength = function(mat, threshold) {\\n    const sumMatrix = [Array(mat[0].length + 1).fill(0), ...Array(mat.length).fill(0).map(x => [x])];\\n    for (let i=0; i<mat.length; ++i) {\\n        for (let j=0; j<mat[0].length; ++j) {\\n            const iPlus1 = i + 1;\\n            const jPlus1 = j + 1;\\n            sumMatrix[iPlus1][jPlus1] = sumMatrix[i][jPlus1] + mat[i][j];\\n        }\\n    }\\n    for (let i=0; i<mat.length; ++i) {\\n        for (let j=0; j<mat[0].length; ++j) {\\n            const iPlus1 = i + 1;\\n            const jPlus1 = j + 1;\\n            sumMatrix[iPlus1][jPlus1] = sumMatrix[iPlus1][j] + sumMatrix[iPlus1][jPlus1];\\n        }\\n    }\\n    for (let i=Math.min(mat.length, mat[0].length); i>0; --i) {\\n        for (let j=mat.length-i; j>=0; --j) {\\n            for (let k=mat[0].length-i; k>=0; --k) {\\n                let startSum = sumMatrix[j][k+i] - sumMatrix[j][k];\\n                let endSum = sumMatrix[j+i][k+i] - sumMatrix[j+i][k];\\n                if (endSum - startSum <= threshold) {\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n};", "var maxSideLength = function (g, threshold) {\\n  return runCheckCondition(g, threshold);\\n};", "var maxSideLength = function(mat, threshold) {\\n    if (!mat.length) return 0;\\n    let m = mat.length, n = mat[0].length;\\n    let sum = new Array(m + 1).fill(0).map(a => new Array(n + 1).fill(0));\\n    let ans = 0;\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            sum[i][j] = mat[i-1][j-1] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\\n        }\\n    }\\n    \\n    "]}
{"id": "1180", "ref_js": ["var isPossibleDivide = function(nums, k) {\\n  const d = {};", "var isPossibleDivide = function(nums, k) {\\n  const fmap=new Map();\\n  for(const n of nums) fmap.set(n,fmap.get(n)+1||1);\\n  nums.sort((a,b)=>a-b);\\n\\n  for(const n of nums){\\n      if(!fmap.has(n)) continue;\\n      let next=n;\\n      ", "var isPossibleDivide = function(nums, k) {\\n  const fmap=new Map();\\n  for(const n of nums) fmap.set(n,fmap.get(n)+1||1);\\n  nums.sort((a,b)=>a-b);\\n\\n  for(const n of nums){\\n      if(!fmap.has(n)) continue;\\n      let next=n;\\n      "]}
{"id": "1181", "ref_js": ["var maxFreq = function (s, maxUniqLettersCount, minSize, maxSize) {\\n  let n = s.length;\\n  let freqObj = {};", "var maxFreq = function(s, maxLetters, minSize, maxSize) {\\n     const substrFreqMap = new Map();\\n  for (let i = 0; i <= s.length - minSize; i++) {\\n    const substring = s.slice(i, i + minSize);\\n    const uniqueLetters = new Set(substring).size;\\n    if (uniqueLetters <= maxLetters) substrFreqMap.set(substring, (substrFreqMap.get(substring) || 0) + 1);\\n  }\\n  return substrFreqMap.size > 0 ? Math.max(...substrFreqMap.values()) : 0;\\n};", "var maxFreq = function(s, maxLetters, minSize, maxSize) {\\n    const charMap = new Map();\\n    const substringMap = new Map();\\n    let start = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const char = s[index];\\n        const charCount = charMap.get(char) ?? 0;\\n\\n        charMap.set(char, charCount + 1);\\n\\n        if (index - start + 1 > minSize) {\\n            const startChar = s[start];\\n            const startCharCount = charMap.get(startChar);\\n\\n            charMap.set(startChar, startCharCount - 1);\\n            startCharCount - 1 === 0 && charMap.delete(startChar);\\n            start += 1;\\n        }\\n        if (index - start + 1 === minSize && charMap.size <= maxLetters) {\\n            const substring = s.slice(start, index + 1);\\n            const substringCount = substringMap.get(substring) ?? 0;\\n\\n            result = Math.max(result, substringCount + 1);\\n            substringMap.set(substring, substringCount + 1);\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1182", "ref_js": ["var findBestValue = function (a, t) {\\n  let n = a.length;\\n  a.sort((a, b) => a - b);\\n\\n  let presum = new Array(n);\\n  for (let i = 0, sum1 = 0, sum2 = 0; i < n; i++) {\\n    presum[i] = sum1 += a[i];\\n  }\\n\\n  let ans;\\n  let min = Infinity;\\n  for (let i = -1; i < n; i++) {\\n    if (i === -1 || i === n - 1 || a[i] < a[i + 1]) {\\n      let tillHere = presum[i] || 0;\\n      let curr;\\n      if (i === -1) {\\n        let remainSum = t - tillHere;\\n        let remainCount = n - (i + 1);\\n\\n        let avg = Math.trunc(remainSum / remainCount);\\n        let avg2 = Math.trunc(remainSum / remainCount) + 1;\\n        if (Math.abs(remainSum - avg2 * remainCount) < Math.abs(remainSum - avg * remainCount)) {\\n          avg = avg2;\\n        }\\n        curr = Math.min(avg, a[0]);\\n      } else if (i === n - 1) {\\n        curr = a[i];\\n      } else {\\n        let remainSum = t - tillHere;\\n        let remainCount = n - (i + 1);\\n        let avg = Math.trunc(remainSum / remainCount);\\n        if (avg > a[i] && avg < (a[i + 1] || -Infinity)) {\\n          let avg2 = avg + 1;\\n          if (avg2 > a[i] && avg2 < (a[i + 1] || -Infinity)) {\\n            if (Math.abs(remainSum - avg2 * remainCount) < Math.abs(remainSum - avg * remainCount)) {\\n              avg = avg2;\\n            }\\n          }\\n          curr = avg;\\n        } else {\\n          curr = a[i] + 1;\\n        }\\n      }\\n      let rest = (n - (i + 1)) * curr;\\n\\n      let total = tillHere + rest;\\n\\n      if (Math.abs(t - total) < min) {\\n        min = Math.abs(t - total);\\n        ans = curr;\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};", "var findBestValue = function(arr, target) {\\n    arr.sort((a,b)=>a-b);\\n    let pref=[arr[0]],totalSum=arr[0], max=arr[0];\\n    for(let i=1;i<arr.length;i++) {\\n        totalSum+=arr[i];\\n        max=Math.max(max,arr[i]);\\n        pref[i]=pref[i-1]+arr[i];\\n    }\\n    const sum=(l,r)=>pref[r]-(pref[l-1]||0); ", "var findBestValue = function(arr, target) {\\n    const sortedArr = [...arr].sort(function (a, b) {  return a - b;  });\\n    var lowestValue = Math.min(sortedArr[arr.length-1], Math.floor(target/arr.length));\\n    var higestValue = Math.min(sortedArr[arr.length-1], target);\\n    var value, deltaLeft, deltaRight;\\n    \\n    while (true) {\\n        candidateRight = Math.ceil((lowestValue + higestValue)/2)\\n        candidateLeft = candidateRight - 1\\n        deltaLeft = calculateDeltaForCandidate(sortedArr, target, candidateLeft)\\n        if (deltaLeft == 0) {\\n            return candidateLeft\\n        }\\n        deltaRight = calculateDeltaForCandidate(sortedArr, target, candidateRight)\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (candidateRight == higestValue) {\\n            return deltaLeft <= deltaRight ? candidateLeft : candidateRight;\\n        }\\n        if (deltaLeft <= deltaRight) {\\n            higestValue = candidateLeft\\n        } else {\\n            lowestValue = candidateRight\\n        }\\n    }\\n};"]}
{"id": "1183", "ref_js": ["var deepestLeavesSum = function(root) {\\n    let q = [root], ans, qlen, curr\\n    while (q.length) {\\n        qlen = q.length, ans = 0\\n        for (let i = 0; i < qlen; i++) {\\n            curr = q.shift(), ans += curr.val\\n            if (curr.left) q.push(curr.left)\\n            if (curr.right) q.push(curr.right)\\n        }\\n    }\\n    return ans\\n};", "var deepestLeavesSum = function(root) {\\n    \\n    var depth = function(root){\\n        if(root == null)    return 0;\\n        return Math.max( depth(root.left) + 1, depth(root.right) + 1 );\\n    }\\n    \\n    var sum = function(root, depth){\\n        if(root == null)    return 0;\\n        if(depth == this.max-1)    return root.val;\\n        return sum(root.left, depth + 1) + sum(root.right, depth + 1);\\n    }\\n    \\n    this.max = depth(root);\\n    return sum(root,0);\\n};", "var deepestLeavesSum = function(root) {\\n    \\n    var depth = function(root){\\n        if(root == null)    return 0;\\n        return Math.max( depth(root.left) + 1, depth(root.right) + 1 );\\n    }\\n    \\n    var sum = function(root, depth){\\n        if(root == null)    return 0;\\n        if(depth == this.max-1)    return root.val;\\n        return sum(root.left, depth + 1) + sum(root.right, depth + 1);\\n    }\\n    \\n    this.max = depth(root);\\n    return sum(root,0);\\n};"]}
{"id": "1184", "ref_js": ["var Node = function(c){\\n    this.parent = this;\\n    this.c = c;\\n    this.size = 1;\\n}\\n\\nclass UnionFind {\\n    constructor(vertices){\\n        this.nodes = [];\\n        this.map = new Map();\\n        \\n        for(let v of vertices){\\n            let n = new Node(v);\\n            this.map.set(this.getKey(v), n)\\n            this.nodes.push(n);\\n        }\\n        \\n       \\n        for(let i=0; i < vertices.length-1; i++){\\n            for(let j=i+1; j < vertices.length; j++){\\n                if(this.isConnected(vertices[i], vertices[j])){\\n                    let [k1, k2] = [this.map.get(this.getKey(vertices[i])),\\n                                   this.map.get(this.getKey(vertices[j]))]\\n                    \\n                \\n                    this.union(k1, k2);\\n                }\\n            }\\n        }\\n    }\\n    \\n    getKey([x,y]){\\n        return `x${x}-y${y}`;\\n    }\\n    \\n    getParent(v1){\\n        \\n        let p = this.map.get(this.getKey(v1));\\n        \\n        while(p !== p.parent){\\n            p = p.parent;\\n        }\\n        \\n        return p;\\n    }\\n    \\n    union(n1, n2){\\n        let [p1, p2] = [n1, n2];\\n\\n        while(p1.parent !== p1){\\n            p1 = p1.parent;\\n        }\\n        \\n        while(p2.parent !== p2){\\n            p2 = p2.parent;\\n        }\\n        \\n        if(p1 !== p2){\\n            if(p1.size > p2.size){\\n                p2.parent = p1;\\n                p2.size = 0;\\n                p1.size = p1.size+1;\\n            }\\n            else {\\n                p1.parent = p2;\\n                p1.size = 0;\\n                p2.size = p2.size+1;\\n            }\\n        }\\n        \\n       ", "var Node = function(c){\\n    this.parent = this;\\n    this.c = c;\\n    this.size = 1;\\n}\\n\\nclass UnionFind {\\n    constructor(vertices){\\n        this.nodes = [];\\n        this.map = new Map();\\n        \\n        for(let v of vertices){\\n            let n = new Node(v);\\n            this.map.set(this.getKey(v), n)\\n            this.nodes.push(n);\\n        }\\n        \\n       \\n        for(let i=0; i < vertices.length-1; i++){\\n            for(let j=i+1; j < vertices.length; j++){\\n                if(this.isConnected(vertices[i], vertices[j])){\\n                    let [k1, k2] = [this.map.get(this.getKey(vertices[i])),\\n                                   this.map.get(this.getKey(vertices[j]))]\\n                    \\n                \\n                    this.union(k1, k2);\\n                }\\n            }\\n        }\\n    }\\n    \\n    getKey([x,y]){\\n        return `x${x}-y${y}`;\\n    }\\n    \\n    getParent(v1){\\n        \\n        let p = this.map.get(this.getKey(v1));\\n        \\n        while(p !== p.parent){\\n            p = p.parent;\\n        }\\n        \\n        return p;\\n    }\\n    \\n    union(n1, n2){\\n        let [p1, p2] = [n1, n2];\\n\\n        while(p1.parent !== p1){\\n            p1 = p1.parent;\\n        }\\n        \\n        while(p2.parent !== p2){\\n            p2 = p2.parent;\\n        }\\n        \\n        if(p1 !== p2){\\n            if(p1.size > p2.size){\\n                p2.parent = p1;\\n                p2.size = 0;\\n                p1.size = p1.size+1;\\n            }\\n            else {\\n                p1.parent = p2;\\n                p1.size = 0;\\n                p2.size = p2.size+1;\\n            }\\n        }\\n        \\n       ", "var Node = function(c){\\n    this.parent = this;\\n    this.c = c;\\n    this.size = 1;\\n}\\n\\nclass UnionFind {\\n    constructor(vertices){\\n        this.nodes = [];\\n        this.map = new Map();\\n        \\n        for(let v of vertices){\\n            let n = new Node(v);\\n            this.map.set(this.getKey(v), n)\\n            this.nodes.push(n);\\n        }\\n        \\n       \\n        for(let i=0; i < vertices.length-1; i++){\\n            for(let j=i+1; j < vertices.length; j++){\\n                if(this.isConnected(vertices[i], vertices[j])){\\n                    let [k1, k2] = [this.map.get(this.getKey(vertices[i])),\\n                                   this.map.get(this.getKey(vertices[j]))]\\n                    \\n                \\n                    this.union(k1, k2);\\n                }\\n            }\\n        }\\n    }\\n    \\n    getKey([x,y]){\\n        return `x${x}-y${y}`;\\n    }\\n    \\n    getParent(v1){\\n        \\n        let p = this.map.get(this.getKey(v1));\\n        \\n        while(p !== p.parent){\\n            p = p.parent;\\n        }\\n        \\n        return p;\\n    }\\n    \\n    union(n1, n2){\\n        let [p1, p2] = [n1, n2];\\n\\n        while(p1.parent !== p1){\\n            p1 = p1.parent;\\n        }\\n        \\n        while(p2.parent !== p2){\\n            p2 = p2.parent;\\n        }\\n        \\n        if(p1 !== p2){\\n            if(p1.size > p2.size){\\n                p2.parent = p1;\\n                p2.size = 0;\\n                p1.size = p1.size+1;\\n            }\\n            else {\\n                p1.parent = p2;\\n                p1.size = 0;\\n                p2.size = p2.size+1;\\n            }\\n        }\\n        \\n       "]}
{"id": "1185", "ref_js": ["var canReach = function(arr, start) {\\n    \\n    const dfs = (cur) => {\\n        if(cur < 0 || cur >= arr.length) {\\n            return false;\\n        }\\n        if(arr[cur] === 0) {\\n            return true;\\n        }\\n        ", "var canReach= function(arr,pos,maxpath=0){\\n    if(maxpath>=arr.length) return false;", "var canReach = function(arr, start) {\\n    \\n    const dfs = (cur) => {\\n        if(cur < 0 || cur >= arr.length) {\\n            return false;\\n        }\\n        if(arr[cur] === 0) {\\n            return true;\\n        }\\n        "]}
{"id": "1186", "ref_js": ["var xorQueries = function(arr, queries) {\\n    let nums = [] ; \\n   for(let i = 0 ; i < queries.length ; ++i){\\n       let array = [] ; \\n       for(let j = queries[i][0] ; j <= queries[i][1]; ++j){\\n           array.push(arr[j]) ; \\n       };", "var xorQueries = function(arr, queries) {\\n    const pref=[arr[0]];\\n    for(let i=1;i<arr.length;i++){\\n        pref[i]=pref[i-1]^arr[i];\\n    }\\n\\n    const compute=(l,r)=>pref[r]^(pref[l-1]||0);\\n\\n    const ans=[]\\n    for(const [l,r] of queries){\\n        ans.push(compute(l,r));\\n    }\\n    return ans;\\n};", "var xorQueries = function(arr, queries) {\\n    let nums = [] ; \\n   for(let i = 0 ; i < queries.length ; ++i){\\n       let array = [] ; \\n       for(let j = queries[i][0] ; j <= queries[i][1]; ++j){\\n           array.push(arr[j]) ; \\n       };"]}
{"id": "1187", "ref_js": ["var watchedVideosByFriends = function (vidNamesOfEach, g, from, kLevel) {\\n  const vis = new Set([from]);\\n  let q = [from];\\n  for (let lvl = 1; lvl <= kLevel; lvl++) {\\n    const q2 = [];\\n    for (let from of q) {\\n      for (let to of g[from]) {\\n        if (vis.has(to)) continue;\\n        vis.add(to);\\n        q2.push(to);\\n      }\\n    }\\n    q = q2;\\n  }\\n  const kLevelFriends = q;\\n  const vidNameAndCountObj = {};", "var watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    const visited = new Set([id]);\\n    const queue = [id];\\n\\n    while (queue.length && level > 0) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const id = queue.shift();\\n            const friend = friends[id];\\n\\n            friend.forEach(friendId => {\\n                if (visited.has(friendId)) return;\\n                queue.push(friendId);\\n                visited.add(friendId);\\n            });\\n        }\\n        level -= 1;\\n    }\\n    const videosMap = queue.reduce((map, id) => {\\n        const videos = watchedVideos[id];\\n\\n        videos.forEach(video => {\\n            const count = map.get(video) ?? 0;\\n            map.set(video, count + 1);\\n        });\\n        return map;\\n    }, new Map());\\n    const videos = [...videosMap.entries()].sort((a, b) => a[1] - b[1] || a[0].localeCompare(b[0]));\\n\\n    return videos.map(([video]) => video);\\n};", "var watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    \\n    const visited = new Set();\\n    const queue = [id];\\n    visited.add(id);\\n    let lvl = 0\\n\\n    "]}
{"id": "1188", "ref_js": ["var matrixBlockSum = function(mat, k) {\\n    \\n    let [h, w] = [ mat.length, mat[0].length ];\\n    \\n    let integralImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    let outputImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    \\n    \\n    ", "var matrixBlockSum = function(mat, k) {\\n  let arr=[];\\n  let n= mat.length;\\n  let m= mat[0].length;\\n  let sum;\\n  let res = [];\\n  let ar=[];\\n  for(let i=0; i<n; i++){\\n      ar=[];\\n      for(let j=0; j<m; j++){\\n          arr[0] = Math.max(0, i-k);\\n          arr[1] = Math.min(n-1, i+k); \\n          arr[2] = Math.max(0, j-k); \\n          arr[3] = Math.min(m-1, j+k); \\n          sum=0;\\n          for(let a=arr[0]; a<=arr[1]; a++){\\n              for(let b=arr[2]; b<=arr[3]; b++){\\n                  sum+=mat[a][b];\\n              }\\n          }\\n          ar.push(sum);\\n       }\\n       res.push(ar);\\n  }  \\n  return res;\\n};", "var matrixBlockSum = function(mat, k) {\\n    const m = mat.length, n = mat[0].length;\\n    const numMatrix = new NumMatrix(mat);\\n    const answer = Array.from(new Array(m), () => new Array(n));\\n    for(let i = 0; i < m; i++){\\n        for(let j = 0; j < n; j++){\\n            const x1 = Math.max(0, i - k), y1 = Math.max(0, j - k);\\n            const x2 = Math.min(m - 1, i + k), y2 = Math.min(n - 1, j + k);\\n            answer[i][j] = numMatrix.sumRegion(x1, y1, x2, y2);\\n        }\\n    }\\n    return answer;   \\n};"]}
{"id": "1189", "ref_js": ["var sumEvenGrandparent = function(root) {\\n    function dfs(node, parent, grandparent){\\n        if(!node) return 0;\\n        const cur = grandparent && grandparent.val % 2 === 0 ? node.val : 0;\\n        return cur + dfs(node.left, node, parent) + dfs(node.right, node, parent);\\n    }\\n    return dfs(root, null, null)\\n};", "var sumEvenGrandparent = function(root) {\\n        \\n        return getSum(root,null,null)\\n\\n        function getSum(root,parent,grandParent){\\n             if(!root){\\n                return 0\\n            }\\n            let res=0\\n            if(grandParent&&grandParent.val%2==0){\\n                res= root.val\\n            }\\n            return res+=getSum(root.left,root,parent)+getSum(root.right,root,parent)\\n\\n        }\\n\\n\\n};", "var sumEvenGrandparent = function(root) {\\n    function dfs(node, parent, grandparent){\\n        if(!node) return 0;\\n        const cur = grandparent && grandparent.val % 2 === 0 ? node.val : 0;\\n        return cur + dfs(node.left, node, parent) + dfs(node.right, node, parent);\\n    }\\n    return dfs(root, null, null)\\n};"]}
{"id": "1190", "ref_js": ["var minFlips = function(a, b, c) {\\n    const resultA = a.toString(2);\\n    const resultB = b.toString(2);\\n    const resultC = c.toString(2);\\n    let Atoarray =resultA.split(\\'\\')\\n    let Btoarray = resultB.split(\\'\\')\\n    let Ctoarray = resultC.split(\\'\\')\\n    let len = [Atoarray.length,Btoarray.length,Ctoarray.length]\\n    let maxLen =Math.max(...len)\\n    console.log(maxLen)\\n    for (let j = 0; j < maxLen; j++) {\\n        if (Atoarray.length < maxLen) {\\n            Atoarray.unshift(\\'0\\')\\n        }\\n        if (Btoarray.length < maxLen) {\\n            Btoarray.unshift(\\'0\\')\\n        }\\n        if (Ctoarray.length < maxLen) {\\n            Ctoarray.unshift(\\'0\\')\\n        }\\n    }\\n    let count =0\\n    for(let j=0;j<Ctoarray.length;j++){\\n        if(Ctoarray[j]===\\'0\\'){\\n            if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'1\\' || Atoarray[j] === \\'1\\' && Btoarray[j] === \\'0\\') {\\n                count++\\n            } else if (Atoarray[j] === \\'1\\' && Btoarray[j] === \\'1\\'){\\n                count+=2\\n            }\\n        } else if (Ctoarray[j] === \\'1\\'){\\n                if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'0\\') {\\n                    count++\\n                }\\n        }\\n    }\\n    return count\\n};", "var minFlips = function(a, b, c) {\\n    let o = 0;\\n    for(let i = 0; i < 32; i++) {\\n        let cbit = (c>>i) & 1;\\n        let abit = (a>>i) & 1, bbit = (b>>i) & 1;\\n        let v = abit || bbit;\\n        if (cbit === v) continue;\\n        o += cbit == 1 ? 1 : (abit + bbit);\\n    }\\n    return o;\\n};", "var minFlips = function(a, b, c) {\\n    const resultA = a.toString(2);\\n    const resultB = b.toString(2);\\n    const resultC = c.toString(2);\\n    let Atoarray =resultA.split(\\'\\')\\n    let Btoarray = resultB.split(\\'\\')\\n    let Ctoarray = resultC.split(\\'\\')\\n    let len = [Atoarray.length,Btoarray.length,Ctoarray.length]\\n    let maxLen =Math.max(...len)\\n    console.log(maxLen)\\n    for (let j = 0; j < maxLen; j++) {\\n        if (Atoarray.length < maxLen) {\\n            Atoarray.unshift(\\'0\\')\\n        }\\n        if (Btoarray.length < maxLen) {\\n            Btoarray.unshift(\\'0\\')\\n        }\\n        if (Ctoarray.length < maxLen) {\\n            Ctoarray.unshift(\\'0\\')\\n        }\\n    }\\n    let count =0\\n    for(let j=0;j<Ctoarray.length;j++){\\n        if(Ctoarray[j]===\\'0\\'){\\n            if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'1\\' || Atoarray[j] === \\'1\\' && Btoarray[j] === \\'0\\') {\\n                count++\\n            } else if (Atoarray[j] === \\'1\\' && Btoarray[j] === \\'1\\'){\\n                count+=2\\n            }\\n        } else if (Ctoarray[j] === \\'1\\'){\\n                if (Atoarray[j] === \\'0\\' && Btoarray[j] === \\'0\\') {\\n                    count++\\n                }\\n        }\\n    }\\n    return count\\n};"]}
{"id": "1191", "ref_js": ["var frequencySort = function(s) {\\n    const map = new Map();\\n    for (let c of s) map.set(c, (map.get(c) || 0) + 1);\\n    return s.split(\\'\\').sort((a, b) => map.get(b) - map.get(a) === 0 ? b.localeCompare(a) :  map.get(b) - map.get(a)).join(\\'\\')\\n};", "var frequencySort = function(s) {\\n    \\n    const charMap = s.split(\\'\\').reduce((acc, cur) => {acc[cur] = (acc[cur] || 0) + 1; return acc} , {})\\n    \\n    const sortedArr = Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]);\\n    \\n    return sortedArr.reduce((acc, cur) => acc + cur.repeat(charMap[cur]) ,\\'\\')\\n};", "var frequencySort = function(s) {\\n    const map = new Map();\\n    for (let c of s) map.set(c, (map.get(c) || 0) + 1);\\n    return s.split(\\'\\').sort((a, b) => map.get(b) - map.get(a) === 0 ? b.localeCompare(a) :  map.get(b) - map.get(a)).join(\\'\\')\\n};"]}
{"id": "1193", "ref_js": ["var printVertically = function(s) {\\n    \\n    let val = s.split(\\' \\');\\n    const copyVal = [...val];\\n    const output = copyVal.sort((a, b) => b.length - a.length);\\n    const ansValue = [];\\n    for(let i=0;i<output[0].length;i++){\\n\\n        let ans = \\'\\';\\n        for(let j=0;j<val.length;j++){\\n            if(!val[j][i]){\\n                ans+=\\' \\'\\n            }else{\\n            ans+=val[j][i];\\n            }\\n        }\\n        \\n        ansValue.push(ans.trimEnd());\\n    }\\n    return ansValue\\n\\n\\n};", "var printVertically = function (s) {\\n    let split = s.split(\" \");\\n\\n    let maxLength = split.reduce((acum, cur) => { if (acum < cur.length) { return cur.length } else { return acum } }, 0);\\n\\n    let arr = Array(maxLength).fill(\"\");\\n\\n    split.forEach(ele => {\\n        for (let i = 0; i < arr.length; i++) {\\n            let char = ele.charAt(i).length === 0 ? \" \" : ele.charAt(i);\\n            arr[i] = arr[i] + char;\\n        }\\n    })\\n\\n    let result = arr.map(ele => ele.replace(/\\\\s+$/, \"\"));\\n    \\n    return result;\\n};", "var printVertically = function (s) {\\n    let split = s.split(\" \");\\n    let maxLength = split.reduce((acum, cur) => { if (acum < cur.length) { return cur.length } else { return acum } }, 0);\\n    let arr = Array(maxLength).fill(\"\");\\n    split.forEach(ele => {\\n        for (let i = 0; i < arr.length; i++) {\\n            let char = ele.charAt(i).length === 0 ? \" \" : ele.charAt(i);\\n            arr[i] = arr[i] + char;\\n        }\\n    })\\n    let result = arr.map(ele=> ele.replace(/\\\\s+$/ , \"\"));\\n    return result;\\n};"]}
{"id": "1194", "ref_js": ["var removeLeafNodes = function(root, target) {\\n    function dfs(node, parent = null, type = \\'\\') {\\n        if (!node) {\\n            return;\\n        }\\n\\n        dfs(node.left, node, \\'left\\');\\n        dfs(node.right, node, \\'right\\');\\n\\n        if (!node.left && !node.right && node.val === target) {\\n            if (parent) {\\n                parent[type] = null;\\n            } else {\\n                ", "var removeLeafNodes = function(root, target) {\\n    function dfs(root){\\n        if(!root)\\n            return false;\\n        if(dfs(root.left))\\n            root.left = null;\\n        if(dfs(root.right))\\n            root.right = null;\\n        return !root.left && !root.right && root.val == target;\\n    }\\n    return dfs(root) ? null : root;\\n};", "var removeLeafNodes = function(root, target) {\\n    function dfs(root){\\n        if(!root)\\n            return false;\\n        if(dfs(root.left))\\n            root.left = null;\\n        if(dfs(root.right))\\n            root.right = null;\\n        return !root.left && !root.right && root.val == target;\\n    }\\n    return dfs(root) ? null : root;\\n};"]}
{"id": "1195", "ref_js": ["var breakPalindrome = function(palindrome) {\\n    if (palindrome.length === 1) return \\'\\';\\n    let isChanged = false;\\n\\n    for (let i = 0; i < palindrome.length; i++) {\\n        if (palindrome.charCodeAt(i) !== 97 && i !== Math.floor(palindrome.length/2)) {\\n            palindrome = palindrome.substring(0, i) + \\'a\\' + palindrome.substring(i + 1, palindrome.length);\\n            isChanged = true;\\n            break;\\n        }\\n    }\\n    if (!isChanged) palindrome = palindrome.substring(0, palindrome.length - 1) + \\'b\\';\\n\\n    return palindrome;\\n};", "var breakPalindrome = function (palindrome) {\\n    const len = palindrome.length;\\n    if (len === 1) return \\'\\';\\n\\n    for (let i = 0; i < Math.floor(len / 2); i++) {\\n        if (palindrome[i] !== \\'a\\') {\\n            return (\\n                palindrome.substring(0, i) + \\'a\\' + palindrome.substring(i + 1)\\n            );\\n        }\\n    }\\n    return palindrome.substring(0, len - 1) + \\'b\\';\\n};", "var breakPalindrome = function (palindrome) {\\n    const len = palindrome.length;\\n    if (len === 1) return \\'\\';\\n\\n    for (let i = 0; i < Math.floor(len / 2); i++) {\\n        if (palindrome[i] !== \\'a\\') {\\n            return (\\n                palindrome.substring(0, i) + \\'a\\' + palindrome.substring(i + 1)\\n            );\\n        }\\n    }\\n    return palindrome.substring(0, len - 1) + \\'b\\';\\n};"]}
{"id": "1196", "ref_js": ["var diagonalSort = function(mat) {\\n  \\tfunction setDiagonal (mat, y, x) {\\n\\t\\tlet diag = [];\\n\\t\\tlet size = Math.min(mat.length - y, mat[0].length - x);\\n\\t\\tfor (let i = 0; i<size; i++) diag.push(mat[i+y][i+x]);\\n\\t\\tdiag.sort((a,b) => a-b);\\n\\t\\tfor (let i = 0; i<size; i++) mat[i+y][i+x] = diag[i];\\n\\t\\treturn diag;\\n\\t}\\n\\n\\tfor (let j = 0; j < mat[0].length; j++) setDiagonal(mat, 0, j)\\n\\tfor (let i = 1; i < mat.length; i++) setDiagonal(mat, i, 0)\\n\\n\\treturn mat; \\n};", "var diagonalSort = function(M) {\\n    let y = M.length, x = M[0].length - 1\\n\\tfor (let i = 2 - y; i < x; i++) {              ", "var diagonalSort = function (a) {\\n  let diagonalMatrix = {};"]}
{"id": "1197", "ref_js": ["var filterRestaurants = function(restaurants, veganFriendly, maxPrice, maxDistance) {\\n    \\n    ", "var filterRestaurants = function(restaurants, veganFriendly, maxPrice, maxDistance) {\\n    let value = [] ; \\n    let hashMap = {} ; \\n    for(let i = 0 ; i < restaurants.length ; ++i){\\n        hashMap[restaurants[i][0]] = {};", "var filterRestaurants = function(restaurants, veganFriendly, maxPrice, maxDistance) {\\n    let filterByPrice = restaurants.filter((element)=>element[3]<=maxPrice &&         (veganFriendly==1?element[2]==veganFriendly:true) && element[4]<=maxDistance)\\n  \\n  let result = filterByPrice.sort(function(a,b){\\n    if(b[1]!==a[1]){\\n      return b[1]-a[1]\\n    }\\n    return b[0]-a[0]\\n  })\\n  \\n  return result.map((element)=>element[0])\\n};"]}
{"id": "1198", "ref_js": ["var findTheCity = function (n, edges, distanceThreshold) {\\n\\n    const matrix = []\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = []\\n        for (let j = 0; j < n; j++) {\\n            if (i === j) {\\n                matrix[i][j] = 0;\\n                continue;\\n            }\\n            matrix[i][j] = Infinity\\n        }\\n    }\\n    for (const [a, b, w] of edges) {\\n        matrix[a][b] = w;\\n        matrix[b][a] = w;\\n    };", "var findTheCity = function (n, edges, thresh) {\\n    let matrix = new Array(n).fill().map(() => new Array(n).fill(Infinity));\\n\\n    let countCity = Infinity;\\n    let cityNo = -1;\\n", "var findTheCity = function(n, edges, distanceThreshold) {\\n    \\n\\n    let graph = edges.reduce((currMap, ele) => {\\n\\n        if (currMap[ele[0]] === undefined) {\\n            currMap[ele[0]] = [];\\n        }\\n        if (currMap[ele[1]] === undefined) {\\n            currMap[ele[1]] = [];\\n        }\\n        currMap[ele[0]].push({\\n            src: ele[1],\\n            distance: ele[2]\\n        })\\n        currMap[ele[1]].push({\\n            src: ele[0],\\n            distance: ele[2]\\n        })\\n\\n        return currMap;\\n\\n    }, {})\\n  let citiesMap = {};"]}
{"id": "1199", "ref_js": ["var minSetSize = function(arr) {\\n    const hash = new Map();\\n    for (let i = 0; i < arr.length; i++) {\\n        hash.set(arr[i], (hash.get(arr[i]) || 0) + 1);\\n    }\\n    const ent = Array.from(hash.entries());\\n    ent.sort((a, b) => b[1] - a[1]);\\n    let sum = 0;\\n    let res = [];\\n    for (let [number, count] of ent) {\\n        sum += count;\\n        res.push(number);\\n        if (sum >= (arr.length / 2)) break;\\n    }\\n    \\n    return res.length;\\n};", "var minSetSize = function(arr) {\\n    let freq = {}\\n    for(let val of arr){\\n        if(freq[val])    freq[val] += 1\\n        else    freq[val] = 1\\n    }\\n    let freq_arr = Object.values(freq).sort((a, b) => a-b)\\n    let j = freq_arr.length-1, removed = 0, removed_freq = 0, half = ~~arr.length/2\\n    while(removed_freq < half){\\n        removed += 1\\n        removed_freq += freq_arr[j--]\\n    }\\n    return removed\\n};", "var minSetSize = function (arr) {\\n  const numFreq = {};"]}
{"id": "1200", "ref_js": ["var maxProduct = function(root) {\\n    let res = [];\\n    let MOD = Math.pow(10,9)+7;\\n\\n    let dfs = function(node) {\\n        if (!node) return 0;\\n        if (!node.left && !node.right) return node.val;\\n\\n        let sumL = dfs(node.left);\\n        let sumR = dfs(node.right);\\n        res.push(sumL, sumR);\\n        return sumL+sumR+node.val;\\n    }\\n\\n    let totalSum = dfs(root);\\n    let max = 0;\\n    for (let e of res) {\\n        let cur = e * (totalSum - e);\\n        max = Math.max(max, cur);\\n    }\\n    return max % MOD;\\n};", "var maxProduct = function(root) {\\n    let sums = []\\n    const dfs = node => {\\n        if (!node) return 0\\n        const res = node.val + dfs(node.left) + dfs(node.right)\\n        sums.push(res)\\n        return res\\n    }\\n    const sumAll = dfs(root)\\n    let res = 0\\n    for (x of sums)\\n        res = Math.max(res, x * (sumAll - x))\\n    return res % 1000000007\\n};", "var maxProduct = function(root) {\\n    let res = [];\\n    let MOD = Math.pow(10,9)+7;\\n\\n    let dfs = function(node) {\\n        if (!node) return 0;\\n        if (!node.left && !node.right) return node.val;\\n\\n        let sumL = dfs(node.left);\\n        let sumR = dfs(node.right);\\n        res.push(sumL, sumR);\\n        return sumL+sumR+node.val;\\n    }\\n\\n    let totalSum = dfs(root);\\n    let max = 0;\\n    for (let e of res) {\\n        let cur = e * (totalSum - e);\\n        max = Math.max(max, cur);\\n    }\\n    return max % MOD;\\n};"]}
{"id": "1202", "ref_js": ["var numOfSubarrays = function(arr, k, threshold) {\\n    \\n    let sum = 0;\\n    let count = 0;\\n    for(let i = 0; i < arr.length; i++) {\\n        if(i < k -1) {\\n            sum += arr[i];\\n            continue;\\n        }\\n\\n        sum += arr[i];\\n        sum -= arr[i - k] || 0;\\n\\n        if((sum / k) >= threshold) {\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    \\n};", "var numOfSubarrays = function(arr, k, m) {\\n    ", "var numOfSubarrays = function(arr, k, threshold) {\\n    let total = 0;\\n    let left = 0;\\n    let right = k;\\n    "]}
{"id": "1203", "ref_js": ["var angleClock = function(hour, minutes) {\\n    ", "var angleClock = function(hour, minutes) {\\n    ", "var angleClock = function(hour, minutes) {\\n    const HOUR_BASE_ANGLE = 360 / 12;\\n    const partsMinutes = minutes / 60;\\n    const hourOffset = partsMinutes * HOUR_BASE_ANGLE;\\n    const hourAngle = (hour % 12) * HOUR_BASE_ANGLE + hourOffset;\\n    const minutesAngle = partsMinutes * 360;\\n    const angle = Math.abs(hourAngle - minutesAngle);\\n\\n    return Math.min(angle, 360 - angle);\\n};"]}
{"id": "1204", "ref_js": ["var minSteps = function(s, t) {\\n    \\n    let hashMap = {};", "var minSteps = function(s, t) {\\n        \\n    let hash1 = hash(s);\\n    let hash2 = hash(t);\\n    let steps = 0;\\n    \\n    for(let key of Object.keys(hash1)) {\\n        if( hash2[key]) {\\n            hash1[key] = hash1[key] - hash2[key];\\n        }\\n        if( hash1[key] > 0 ) {\\n            steps += hash1[key];\\n        }\\n    }\\n    \\n    return steps;\\n};", "var minSteps = function(s, t) {\\n    \\n    let hashMap = {};"]}
{"id": "1207", "ref_js": ["var maxEvents = function(events) {\\n\\n    ", "var maxEvents = function (events) {\\n  events.sort((a, b) => a[1] - b[1]);\\n  const days = new Array(10 ** 5 + 1).fill(0);\\n  let ans = 0;\\n  for (const event of events) {\\n    for (let startDay = event[0]; startDay <= event[1]; startDay++) {\\n      if (!days[startDay]) {\\n        days[startDay] = 1;\\n        ans++;\\n        break;\\n      }\\n    }\\n  }\\n  return ans;\\n};", "var maxEvents = function (events) {\\n  events.sort((a, b) => a[1] - b[1]);\\n  const days = new Array(10 ** 5 + 1).fill(0);\\n  let ans = 0;\\n  for (const event of events) {\\n    for (let startDay = event[0]; startDay <= event[1]; startDay++) {\\n      if (!days[startDay]) {\\n        days[startDay] = 1;\\n        ans++;\\n        break;\\n      }\\n    }\\n  }\\n  return ans;\\n};"]}
{"id": "1209", "ref_js": ["var numberOfSubstrings = function (s) {\\n\\t\\t\\tlet a = 0, b = 0, c = 0, result = 0;\\n\\n\\t\\t\\tfor (let i = 0, j = 0; i < s.length; i++) {\\n\\n\\t\\t\\t\\tif (s[i] == \\'a\\') a++;\\n\\t\\t\\t\\tif (s[i] == \\'b\\') b++;\\n\\t\\t\\t\\tif (s[i] == \\'c\\') c++;\\n\\n\\t\\t\\t\\twhile (a && b && c) {\\n\\t\\t\\t\\t\\tresult += s.length - i;\\n\\n\\t\\t\\t\\t\\tif (s[j] === \\'a\\') a--;\\n\\t\\t\\t\\t\\tif (s[j] === \\'b\\') b--;\\n\\t\\t\\t\\t\\tif (s[j] === \\'c\\') c--;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t};", "var numberOfSubstrings = function(s) {\\n    let a=0,b=0,c=0,count=0;\\n    for(let i=0,j=0;i<s.length;i++){\\n        if(s[i]==\\'a\\'){\\n            a++;\\n        }else if(s[i]==\\'b\\'){\\n            b++;\\n        }else{\\n            c++;\\n        }\\n        while(a&&b&&c){\\n            count+=s.length-i;\\n            if(s[j]==\"a\"){\\n                a--;\\n            }else if(s[j]==\"b\"){\\n                b--;\\n            }else{\\n                c--;\\n            }\\n            j++;\\n        }\\n        \\n    }\\n    return count;\\n};", "var numberOfSubstrings = function(s) {\\n    let count = 0;\\n    let lastIndex = [-1, -1, -1];\\n\\n    for (let i = 0; i < s.length; i++) {\\n        switch (s.charAt(i)) {\\n            case \\'a\\': lastIndex[0] = i;\\n                break;\\n            case \\'b\\': lastIndex[1] = i;\\n                break;\\n            case \\'c\\': lastIndex[2] = i;\\n                break;\\n        }\\n\\n        const earliestIndex = Math.min(...lastIndex);\\n\\n        if (earliestIndex !== -1) {\\n            count += earliestIndex + 1; "]}
{"id": "1210", "ref_js": ["var updateMatrix = function(mat) {\\n    if (!mat || mat.length === 0 || mat[0].length === 0)\\n        return [];\\n\\n    let m = mat.length, n = mat[0].length;\\n    let queue = [];\\n    let MAX_VALUE = m * n;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (mat[i][j] === 0) {\\n                queue.push([i, j]);\\n            } else {\\n                mat[i][j] = MAX_VALUE;\\n            }\\n        }\\n    }\\n    \\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    while (queue.length > 0) {\\n        let [row, col] = queue.shift();\\n        for (let [dr, dc] of directions) {\\n            let r = row + dr, c = col + dc;\\n            if (r >= 0 && r < m && c >= 0 && c < n && mat[r][c] > mat[row][col] + 1) {\\n                queue.push([r, c]);\\n                mat[r][c] = mat[row][col] + 1;\\n            }\\n        }\\n    }\\n    \\n    return mat;\\n};", "var updateMatrix = function(mat) {\\n    const rows = mat.length;\\n    const cols = mat[0].length;\\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    const queue = [];\\n\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            if (mat[i][j] === 0) {\\n                queue.push([i, j]);\\n            } else {\\n                mat[i][j] = Infinity;\\n            }\\n        }\\n    }\\n\\n    while (queue.length > 0) {\\n        const [row, col] = queue.shift();\\n\\n        for (const [dr, dc] of directions) {\\n            const new_row = row + dr;\\n            const new_col = col + dc;\\n\\n            if (new_row >= 0 && new_row < rows && new_col >= 0 && new_col < cols && mat[new_row][new_col] > mat[row][col] + 1) {\\n                mat[new_row][new_col] = mat[row][col] + 1;\\n                queue.push([new_row, new_col]);\\n            }\\n        }\\n    }\\n\\n    return mat;    \\n};", "var updateMatrix = function(mat) {\\n    if (!mat || mat.length === 0 || mat[0].length === 0)\\n        return [];\\n\\n    let m = mat.length, n = mat[0].length;\\n    let queue = [];\\n    let MAX_VALUE = m * n;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (mat[i][j] === 0) {\\n                queue.push([i, j]);\\n            } else {\\n                mat[i][j] = MAX_VALUE;\\n            }\\n        }\\n    }\\n    \\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    while (queue.length > 0) {\\n        let [row, col] = queue.shift();\\n        for (let [dr, dc] of directions) {\\n            let r = row + dr, c = col + dc;\\n            if (r >= 0 && r < m && c >= 0 && c < n && mat[r][c] > mat[row][col] + 1) {\\n                queue.push([r, c]);\\n                mat[r][c] = mat[row][col] + 1;\\n            }\\n        }\\n    }\\n    \\n    return mat;\\n};"]}
{"id": "1211", "ref_js": ["var closestDivisors = function(num) {\\n    const divisors = (num) => {\\n        for (let n = Math.sqrt(num) | 0; n >= 2; n--) {\\n            if (num % n !== 0) continue;\\n            return [n, num / n];\\n        }\\n        return [1, num];\\n    };", "var closestDivisors = function(num) {\\n    let dif1 = 0;\\n    let dif2= 0;\\n    let res1=[];\\n    let res2=[]\\n    for(let i = Math.round(Math.sqrt(num+1)); i>=1; i--){\\n        if((num+1)%i==0){\\n            dif1 = Math.abs(i-(num+1)/i);\\n            res1 =[i, (num+1)/i]\\n            i=0;\\n        }\\n    }\\n     for(let i = Math.round(Math.sqrt(num+2)); i>=1; i--){\\n        if((num+2)%i==0){\\n            dif2 = Math.abs(i-(num+2)/i);\\n            res2 =[i, (num+2)/i]\\n            i=0;\\n        }\\n    }\\n    return dif1>dif2 ? res2 : res1;\\n};", "var closestDivisors = function(num) {\\n    let dif1 = 0;\\n    let dif2= 0;\\n    let res1=[];\\n    let res2=[]\\n    for(let i = Math.round(Math.sqrt(num+1)); i>=1; i--){\\n        if((num+1)%i==0){\\n            dif1 = Math.abs(i-(num+1)/i);\\n            res1 =[i, (num+1)/i]\\n            i=0;\\n        }\\n    }\\n     for(let i = Math.round(Math.sqrt(num+2)); i>=1; i--){\\n        if((num+2)%i==0){\\n            dif2 = Math.abs(i-(num+2)/i);\\n            res2 =[i, (num+2)/i]\\n            i=0;\\n        }\\n    }\\n    return dif1>dif2 ? res2 : res1;\\n};"]}
{"id": "1212", "ref_js": ["var rankTeams = function(votes) {\\n    if (votes.length === 1) return votes[0];\\n    const score = new Map(votes[0].split(\\'\\').map(c => [c, new Array(votes[0].length).fill(0)]));\\n    for (s of votes) {\\n        for (let i = 0; i < s.length; i++) {\\n            score.get(s[i])[i]++;\\n        }\\n    }\\n    return votes[0].split(\\'\\').sort((a,b) => {\\n        for (let i = 0; i < votes[0].length; i++) {\\n            if (score.get(a)[i] > score.get(b)[i]) return -1;\\n            if (score.get(a)[i] < score.get(b)[i]) return 1;\\n        }\\n        return a < b ? -1 : 1;\\n    }).join(\\'\\');\\n};", "var rankTeams = function (votes) {\\n    const votesMap = getMapOfVotes(votes);\\n    const sortVotesArray = sortVotes(votesMap);\\n    return sortVotesArray.join(\\'\\');\\n};", "var rankTeams = function (votes) {\\n    const votesMap = getMapOfVotes(votes);\\n    const sortVotesArray = sortVotes(votesMap);\\n    return sortVotesArray.join(\\'\\');\\n};"]}
{"id": "1213", "ref_js": ["var isSubPath = function(head, root) {\\n    if(!root)    return false\\n    if(issame(head, root))  return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};", "var isSubPath = function(head, root) {\\n    if (!head) return true;\\n    if (!root) return false;\\n    const checkSubPath = (node = root, subNode = head) => {\\n        if (!subNode) return true;\\n        if (!node) return false;\\n        const { val, left, right } = node;\\n        if (val !== subNode.val) return false;\\n\\n        return checkSubPath(left, subNode.next) || checkSubPath(right, subNode.next);\\n    };", "var isSubPath = function(head, root) {\\n    if (!head) return true;\\n    if (!root) return false;\\n    const checkSubPath = (node = root, subNode = head) => {\\n        if (!subNode) return true;\\n        if (!node) return false;\\n        const { val, left, right } = node;\\n        if (val !== subNode.val) return false;\\n\\n        return checkSubPath(left, subNode.next) || checkSubPath(right, subNode.next);\\n    };"]}
{"id": "1214", "ref_js": ["var findTheLongestSubstring = function(s) {\\n    let mapping = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16};", "var findTheLongestSubstring = function(s) {\\n    for (let k = s.length-1; k >= 0; k--) {\\n        let i = 0, j = k;\\n        while (j < s.length) {\\n            if (evenVowels(s.substring(i,j+1))) return j-i+1;\\n            i++, j++;\\n        }\\n    }\\n    return 0;\\n    ", "var findTheLongestSubstring = function(s) {\\n    let mapping = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16};"]}
{"id": "1215", "ref_js": ["var longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};", "var longestZigZag = function(root) {\\n    \\n    let max = 0\\n\\n    function recursiveTraversal(node,parent){\\n\\n        if(!node){\\n            return 0\\n        }\\n\\n        const left = recursiveTraversal(node.left,\"left\")\\n        const right = recursiveTraversal(node.right,\"right\")\\n\\n        max = Math.max(left,right,max)\\n\\n        if(parent===\"left\"){\\n            return 1 + right\\n        }\\n\\n        return 1 + left\\n\\n    }\\n\\n\\n    recursiveTraversal(root)\\n    return max\\n\\n\\n};", "var longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};"]}
{"id": "1216", "ref_js": ["var numTimesAllBlue = function(flips) {\\n    let end = count = result = 0;\\n\\n    for (const flip of flips) {\\n        end = Math.max(end, flip);\\n        count += 1;\\n        if (end !== count) continue;\\n        result += 1;  \\n    }\\n    return result;\\n};", "var numTimesAllBlue = function(light) {\\n    let total = 0;\\n    let target = 0;\\n    let moments = 0;\\n    \\n    for(let i = 0; i < light.length; i++){\\n        total += light[i];      ", "var numTimesAllBlue = function(flips) {\\n    const flipped = new Array(flips.length).fill(0);\\n    let prefixAlignedCount = 0;\\n    flips.forEach((i, step) => {\\n        flipped[i - 1] = 1;\\n        if(isPrefixAligned(step)) {\\n            ++prefixAlignedCount;\\n        }\\n    })\\n    return prefixAlignedCount;\\n    \\n    function isPrefixAligned(step) {\\n        for(let i = 0; i < flips.length; ++i) {\\n            if((i < step && flipped[i] === 0) || (i > step && flipped[i] === 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"]}
{"id": "1217", "ref_js": ["var numOfMinutes = function(n, headID, manager, informTime) {\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (informTime[i] == 0) {\\n            continue;\\n        }\\n        max = Math.max(max, dfs(i, manager, informTime));\\n    }\\n    return max;\\n};", "var numOfMinutes = function(n, headID, manager, informTime) {\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (informTime[i] == 0) {\\n            continue;\\n        }\\n        max = Math.max(max, dfs(i, manager, informTime));\\n    }\\n    return max;\\n};", "var numOfMinutes = function(n, headID, manager, informTime) {\\n    manager.forEach((_, index) => timeFromEmployeeToHead(index))\\n        \\n    return Math.max(...informTime);\\n    \\n    function timeFromEmployeeToHead(id) {\\n        if (manager[id] !== -1) {\\n            informTime[id] += timeFromEmployeeToHead(manager[id]);\\n            manager[id] = -1\\n        }\\n        return informTime[id];\\n    }\\n};"]}
{"id": "1219", "ref_js": ["var balanceBST = function(root) {\\n    const values = toArray(root);\\n    return toBST(values);\\n    \\n    function toBST(arr) {\\n        if (arr.length===0) return null;\\n        if (arr.length===1) return new TreeNode(arr[0]);\\n        const mid = Math.floor(arr.length / 2);\\n        const left = toBST(arr.slice(0, mid));\\n        const right = toBST(arr.slice(mid+1));\\n        return new TreeNode(arr[mid], left, right);\\n    }\\n    \\n    function toArray(node) {\\n        if (!node) return [];\\n        return [...toArray(node.left), node.val, ...toArray(node.right)];\\n    }\\n};", "var balanceBST = function(root) {\\n    function inOrder(myRoot) {\\n        if(!myRoot) return [];\\n        return [...inOrder(myRoot.left), myRoot.val, ...inOrder(myRoot.right)]\\n    }\\n    const sortedArr = inOrder(root)\\n    \\n    function constructTree(arr) {\\n        if(!arr.length) return null;\\n        \\n        const mid = Math.floor(arr.length / 2);\\n        const node = new TreeNode(arr[mid])\\n        node.left = constructTree(arr.slice(0, mid));\\n        node.right = constructTree(arr.slice(mid+1));\\n        \\n        return node;\\n    }\\n    return constructTree(sortedArr);\\n};", "var balanceBST = function(root) {\\n    function inOrder(myRoot) {\\n        if(!myRoot) return [];\\n        return [...inOrder(myRoot.left), myRoot.val, ...inOrder(myRoot.right)]\\n    }\\n    const sortedArr = inOrder(root)\\n    \\n    function constructTree(arr) {\\n        if(!arr.length) return null;\\n        \\n        const mid = Math.floor(arr.length / 2);\\n        const node = new TreeNode(arr[mid])\\n        node.left = constructTree(arr.slice(0, mid));\\n        node.right = constructTree(arr.slice(mid+1));\\n        \\n        return node;\\n    }\\n    return constructTree(sortedArr);\\n};"]}
{"id": "1220", "ref_js": ["var maxNumberOfFamilies = function(n, reservedSeats) {\\n    const map = new Map()\\n\\n    for (const [row, col] of reservedSeats) {\\n        const cols = map.get(row) || new Set()\\n        cols.add(col)\\n        map.set(row, cols)\\n    }\\n\\n    let result = (n - map.size) * 2\\n    \\n    for (const cols of map.values()) {\\n        const isFirstFree = ![2, 3, 4, 5].some(col => cols.has(col))\\n        const isLastFree = ![6, 7, 8, 9].some(col => cols.has(col))\\n        const isMidFree = ![4, 5, 6, 7].some(col => cols.has(col))\\n\\n        result += Math.max(isFirstFree + isLastFree, isMidFree)\\n    }\\n\\n    return result\\n};", "var maxNumberOfFamilies = function (n, reservedSeats) {\\n  let reservedRowCols = [];\\n  for (let [r, c] of reservedSeats) {\\n    reservedRowCols[r] = reservedRowCols[r] || [];\\n    reservedRowCols[r].push(c);\\n  }\\n\\n  function isFullPartVacant(thisRowReservedCols, part) {\\n    return part.every((seat) => !thisRowReservedCols.includes(seat));\\n  }\\n\\n  let totalFreeParts = 0;\\n  let reservedSeatRowCount = 0;\\n  for (let thisRowReservedCols of reservedRowCols) {\\n    if (!thisRowReservedCols) continue; ", "var maxNumberOfFamilies = function(n, reservedSeats) {\\n    const reservedSeatsMap = reservedSeats.reduce((map, [row, labelled]) => {\\n        const reserved = map.get(row) ?? new Set();\\n\\n        reserved.add(labelled);\\n        return map.set(row, reserved);\\n    }, new Map());\\n    const getSeats = (reserved, check) => {\\n        const isReserved = check.some(labelled => reserved.has(labelled));\\n\\n        return isReserved ? 0 : 1;\\n    };"]}
{"id": "1221", "ref_js": ["var getKth = function(lo, hi, k) {\\n    const memo = {}\\n\\n    const dp = Array(hi - lo)\\n    for (i = lo; i <= hi; i++) dp[hi - i] = [i, transform(i)]\\n    dp.sort((a, b) => a[1] - b[1] || a[0] - b[0]) ", "var getKth = function(lo, hi, k) {\\n    const findPower = num => {\\n        let power = 0\\n        while (num > 1) {\\n            power++\\n            num = num % 2 ? 3 * num + 1 : num / 2\\n        }\\n        return power\\n    }\\n    const result = [], map = {}\\n    for (let i = lo; i <= hi; i++) {\\n        result.push(i)\\n        map[i] = findPower(i)\\n    }\\n    result.sort((a, b) => map[a] - map[b])\\n    return result[k - 1]\\n};", "var getKth = function(lo, hi, k) {\\n    let powers = [];\\n    for (let num = lo, i = num, pow = 0; num <= hi; ++num, i = num, pow = 0) {\\n        while (i > 1 && (pow += 1)) i % 2 ? (i = 3 * i + 1) : (i /= 2);\\n        powers.push({num, pow});}\\n    powers.sort((a, b) => a.pow - b.pow || a.num - b.num);\\n    return powers.at(k - 1).num;\\n};"]}
{"id": "1222", "ref_js": ["var sumFourDivisors = function(nums) { ", "var sumFourDivisors = function (nums) {\\n    ", "var sumFourDivisors = function (nums) {\\n    "]}
{"id": "1223", "ref_js": ["var hasValidPath = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const connectMap = { left: \\'right\\', right: \\'left\\', upper: \\'lower\\', lower: \\'upper\\' };", "var hasValidPath = function(grid) {\\n    let m = grid.length, n = grid[0].length;\\n    let visited = [...new Array(m)].map(a => [...new Array(n)].fill(false))\\n    let left = [0, -1], right = [0, 1], up = [-1, 0], down = [1, 0]\\n    let queue = [[0,0]];\\n    visited[0][0] = true;\\n    while (queue.length) {\\n        let [x, y] = queue.shift();\\n        if (x === m-1 && y === n-1) return true;\\n        let val = grid[x][y]\\n\\n        const checkPosition = (pos, type) =>{\\n            let set = new Set();\\n            if (type === \"left\") {\\n                set = new Set([6, 1, 4])\\n            } else if (type === \"right\") {\\n                set = new Set([5, 1, 3])\\n            } else if (type === \"up\") {\\n                set = new Set([2, 4, 3])\\n            } else if (type === \"down\") {\\n                set = new Set([2, 5, 6])\\n            }\\n            let x1 = x + pos[0], y1 = y + pos[1]\\n            if (x1 >= 0 && y1 >= 0 && x1 < m && y1 < n) {\\n                if (!visited[x1][y1] && set.has(grid[x1][y1])) {\\n                    visited[x1][y1] = true;\\n                    queue.push([x1, y1])\\n                }\\n            }\\n        }\\n        if (val === 1) {\\n            checkPosition(left, \"left\"); checkPosition(right, \"right\")\\n        } else if (val === 2) {\\n            checkPosition(up, \"up\"); checkPosition(down, \"down\")\\n        } else if (val === 3) {\\n            checkPosition(left, \"left\"); checkPosition(down, \"down\")\\n        } else if (val === 4) {\\n            checkPosition(right, \"right\"); checkPosition(down, \"down\")\\n        } else if (val === 5) {\\n            checkPosition(left, \"left\"); checkPosition(up, \"up\")\\n        } else if (val === 6) {\\n            checkPosition(up, \"up\"); checkPosition(right, \"right\")\\n        }\\n    }\\n    return false;\\n};", "var hasValidPath = function(grid) {\\n    let m = grid.length, n = grid[0].length;\\n    let visited = [...new Array(m)].map(a => [...new Array(n)].fill(false))\\n    let left = [0, -1], right = [0, 1], up = [-1, 0], down = [1, 0]\\n    let queue = [[0,0]];\\n    visited[0][0] = true;\\n    while (queue.length) {\\n        let [x, y] = queue.shift();\\n        if (x === m-1 && y === n-1) return true;\\n        let val = grid[x][y]\\n\\n        const checkPosition = (pos, type) =>{\\n            let set = new Set();\\n            if (type === \"left\") {\\n                set = new Set([6, 1, 4])\\n            } else if (type === \"right\") {\\n                set = new Set([5, 1, 3])\\n            } else if (type === \"up\") {\\n                set = new Set([2, 4, 3])\\n            } else if (type === \"down\") {\\n                set = new Set([2, 5, 6])\\n            }\\n            let x1 = x + pos[0], y1 = y + pos[1]\\n            if (x1 >= 0 && y1 >= 0 && x1 < m && y1 < n) {\\n                if (!visited[x1][y1] && set.has(grid[x1][y1])) {\\n                    visited[x1][y1] = true;\\n                    queue.push([x1, y1])\\n                }\\n            }\\n        }\\n        if (val === 1) {\\n            checkPosition(left, \"left\"); checkPosition(right, \"right\")\\n        } else if (val === 2) {\\n            checkPosition(up, \"up\"); checkPosition(down, \"down\")\\n        } else if (val === 3) {\\n            checkPosition(left, \"left\"); checkPosition(down, \"down\")\\n        } else if (val === 4) {\\n            checkPosition(right, \"right\"); checkPosition(down, \"down\")\\n        } else if (val === 5) {\\n            checkPosition(left, \"left\"); checkPosition(up, \"up\")\\n        } else if (val === 6) {\\n            checkPosition(up, \"up\"); checkPosition(right, \"right\")\\n        }\\n    }\\n    return false;\\n};"]}
{"id": "1225", "ref_js": ["var numTeams = function(rating) {\\n    let count= 0  ;  \\n    for(let i = 0 ; i < rating.length ; ++i){\\n        for(let j = i + 1 ; j < rating.length; ++j){\\n            for(let k = j + 1 ; k < rating.length ; ++k){\\n                if(rating[i] < rating[j] && rating[j] < rating[k]){\\n                    ++count;  \\n                }\\n                if(rating[i] > rating[j] && rating[j] > rating[k]){\\n                    ++count;  \\n                }\\n            }\\n        }\\n    }\\n   return count ; \\n};", "var numTeams = function(rating) {\\n    let result = 0;\\n\\n    for (let index = 1; index < rating.length - 1; index++) {\\n        const rate = rating[index];\\n        let leftBigger = leftSmaller = 0;\\n        let rightBigger = rightSmaller = 0;\\n\\n        for (let left = 0; left < index; left++) {\\n            rate < rating[left] ? leftBigger += 1 : leftSmaller += 1;\\n        }\\n        for (let right = index + 1; right < rating.length; right++) {\\n            rate < rating[right] ? rightBigger += 1 : rightSmaller += 1;\\n        }\\n        result += leftBigger * rightSmaller + leftSmaller * rightBigger;\\n    }\\n    return result;\\n};", "var numTeams = function(rating) {\\n    let count= 0  ;  \\n    for(let i = 0 ; i < rating.length ; ++i){\\n        for(let j = i + 1 ; j < rating.length; ++j){\\n            for(let k = j + 1 ; k < rating.length ; ++k){\\n                if(rating[i] < rating[j] && rating[j] < rating[k]){\\n                    ++count;  \\n                }\\n                if(rating[i] > rating[j] && rating[j] > rating[k]){\\n                    ++count;  \\n                }\\n            }\\n        }\\n    }\\n   return count ; \\n};"]}
{"id": "1227", "ref_js": ["var canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        \\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        \\n        return true;\\n    }\\n    \\n    const hash = {};", "var canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    ", "var canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};"]}
{"id": "1228", "ref_js": ["var checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const xEdge = Math.max(x1, Math.min(x2, xCenter));\\n    const yEdge = Math.max(y1, Math.min(y2, yCenter));\\n    const xDistance = xCenter - xEdge;\\n    const yDistance = yCenter - yEdge;\\n\\n    return xDistance ** 2 + yDistance ** 2 <= radius ** 2\\n};", "var checkOverlap = function (r, cx, cy, x1, y1, x2, y2) {\\n  for (let x = x1; x <= x2; x++) {\\n    for (let ry = y1; ry <= y2; ry++) {\\n      let rectanglePointToCircleCentreDistance =\\n        Math.sqrt((cx - x) ** 2 + (cy - ry) ** 2);\\n      if (rectanglePointToCircleCentreDistance <= r) {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n};", "var checkOverlap = function (r, cx, cy, x1, y1, x2, y2) {\\n  for (let x = x1; x <= x2; x++) {\\n    for (let ry = y1; ry <= y2; ry++) {\\n      let rectanglePointToCircleCentreDistance =\\n        Math.sqrt((cx - x) ** 2 + (cy - ry) ** 2);\\n      if (rectanglePointToCircleCentreDistance <= r) {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n};"]}
{"id": "1229", "ref_js": ["var numSteps = function(s) {\\n   let result = carry = 0;\\n\\n   for (let index = s.length - 1; index > 0; index--) {\\n      const str = s[index];\\n\\n      if (str === \\'0\\') {\\n         result += carry ? 2 : 1;\\n         continue;\\n      }\\n      result += carry ? 1 : 2;\\n      carry = 1;\\n   }\\n   return result + carry;\\n};", "var numSteps = function(s) {\\n    let n = [...s].map(c=>c===\\'0\\'?0:1), steps=0;\\n\\n    const add1=(n)=>{\\n        let last=n.length-1;\\n        while(n[last]===1){\\n            n[last]=0;\\n            last--;\\n        }\\n        if(last<0){\\n            n.unshift(1);\\n        }else{\\n            n[last]=1;\\n        }\\n        return n;\\n    }\\n    \\n    while(n.length>1 && n[0]===1){\\n        if(n[n.length-1]===0){\\n            n.pop(); ", "var numSteps = function(s) {\\n   let result = carry = 0;\\n\\n   for (let index = s.length - 1; index > 0; index--) {\\n      const str = s[index];\\n\\n      if (str === \\'0\\') {\\n         result += carry ? 2 : 1;\\n         continue;\\n      }\\n      result += carry ? 1 : 2;\\n      carry = 1;\\n   }\\n   return result + carry;\\n};"]}
{"id": "1230", "ref_js": ["var longestDiverseString = function(a, b, c) {\\n    \\n    let res = [\\n        [\\'a\\', a],\\n        [\\'b\\', b],\\n        [\\'c\\', c]\\n    ];\\n    \\n\\t", "var longestDiverseString = function (a, b, c) {\\n\\tlet countA = 0;\\n\\tlet countB = 0;\\n\\tlet countC = 0;\\n\\tconst result = [];\\n\\twhile (a > 0 || b > 0 || c > 0) {\\n\\t\\tif ((a >= b && a >= c && countA < 2) || (countB === 2 && a > 0) || (countC === 2 && a > 0)) {\\n\\t\\t\\tresult.push(\\'a\\');\\n\\t\\t\\tcountA += 1;\\n\\t\\t\\ta -= 1;\\n\\t\\t\\tcountB=0;\\n\\t\\t\\tcountC=0;\\n\\t\\t} else if ((b >= a && b >= c && countB < 2 ) || (countA === 2 && b > 0) || (countC === 2 && b > 0)) {\\n\\t\\t\\tresult.push(\\'b\\');\\n\\t\\t\\tcountB += 1;\\n\\t\\t\\tb -= 1;\\n\\t\\t\\tcountA=0;\\n\\t\\t\\tcountC=0;\\n\\t\\t} else if ((c >= a && c >= b && countC < 2) || (countB === 2 && c > 0) || (countA === 2 && c > 0)) {\\n\\t\\t\\tresult.push(\\'c\\');\\n\\t\\t\\tcountC += 1;\\n\\t\\t\\tc -= 1;\\n\\t\\t\\tcountA=0;\\n\\t\\t\\tcountB=0;\\n\\t\\t} else {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result.join(\\'\\');\\n};", "var longestDiverseString = function (a, b, c) {\\n\\tlet countA = 0;\\n\\tlet countB = 0;\\n\\tlet countC = 0;\\n\\tconst result = [];\\n\\twhile (a > 0 || b > 0 || c > 0) {\\n\\t\\tif ((a >= b && a >= c && countA < 2) || (countB === 2 && a > 0) || (countC === 2 && a > 0)) {\\n\\t\\t\\tresult.push(\\'a\\');\\n\\t\\t\\tcountA += 1;\\n\\t\\t\\ta -= 1;\\n\\t\\t\\tcountB=0;\\n\\t\\t\\tcountC=0;\\n\\t\\t} else if ((b >= a && b >= c && countB < 2 ) || (countA === 2 && b > 0) || (countC === 2 && b > 0)) {\\n\\t\\t\\tresult.push(\\'b\\');\\n\\t\\t\\tcountB += 1;\\n\\t\\t\\tb -= 1;\\n\\t\\t\\tcountA=0;\\n\\t\\t\\tcountC=0;\\n\\t\\t} else if ((c >= a && c >= b && countC < 2) || (countB === 2 && c > 0) || (countA === 2 && c > 0)) {\\n\\t\\t\\tresult.push(\\'c\\');\\n\\t\\t\\tcountC += 1;\\n\\t\\t\\tc -= 1;\\n\\t\\t\\tcountA=0;\\n\\t\\t\\tcountB=0;\\n\\t\\t} else {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result.join(\\'\\');\\n};"]}
{"id": "1231", "ref_js": ["var processQueries = function(queries, m) {\\n    let  p =[];\\n    let result = [];\\n    for(let i=1; i<=m; i++){\\n        p[i-1]=i;\\n    }\\n    for(let i=0; i<queries.length; i++){\\n        let ind = p.indexOf(queries[i]);\\n        result.push(ind);\\n        let midle = p.splice(ind,1);\\n        p.unshift(midle[0]);\\n    }\\n    return result;\\n};", "var processQueries = function(queries, m) {\\n    let ans = [], p = [];\\n\\n    for (let i = 1; i <= m; i++) p.push(i);\\n\\n    queries.forEach(query => {\\n        let temp = [query];\\n        p.forEach((n, i) => {\\n            if (n === query) ans.push(i);\\n            else temp.push(n);\\n        });\\n        p = temp;\\n    });\\n\\n    return ans;\\n};", "var processQueries = function(queries, m) {\\n    let  p =[];\\n    let result = [];\\n    for(let i=1; i<=m; i++){\\n        p[i-1]=i;\\n    }\\n    for(let i=0; i<queries.length; i++){\\n        let ind = p.indexOf(queries[i]);\\n        result.push(ind);\\n        let midle = p.splice(ind,1);\\n        p.unshift(midle[0]);\\n    }\\n    return result;\\n};"]}
{"id": "1232", "ref_js": ["var entityParser = function(text) {\\n    const entities = {\\n        \\'&quot;\\': \\'\"\\',\\n        \\'&apos;\\': \"\\'\",\\n        \\'&amp;\\': \\'&\\',\\n        \\'&gt;\\': \\'>\\',\\n        \\'&lt;\\': \\'<\\',\\n        \\'&frasl;\\': \\'/\\',\\n    };", "var entityParser = function(text) {\\n    const parserMap = {\\n        \\'&quot;\\': \\'\"\\',\\n        \\'&apos;\\': \"\\'\",\\n        \\'&amp;\\': \\'&\\',\\n        \\'&gt;\\': \\'>\\',\\n        \\'&lt;\\': \\'<\\',\\n        \\'&frasl;\\': \\'/\\',\\n    };", "var entityParser = function(text) {\\n    const parserMap = {\\n        \\'&quot;\\': \\'\"\\',\\n        \\'&apos;\\': \"\\'\",\\n        \\'&amp;\\': \\'&\\',\\n        \\'&gt;\\': \\'>\\',\\n        \\'&lt;\\': \\'<\\',\\n        \\'&frasl;\\': \\'/\\',\\n    };"]}
{"id": "1233", "ref_js": ["var findMinFibonacciNumbers = function(k) {\\n    let arr=[1,1];\\n    let i=2;\\n    let count=1;\\n    while(arr[arr.length-1]<=k){\\n        arr.push(arr[i-1]+arr[i-2]);\\n        i++;\\n    }\\n    k-=arr[arr.length-2];\\n    while(k>0){\\n        count++;\\n        for(let j=0; j<arr.length; j++){\\n            if(arr[j]>k){\\n                k-=arr[j-1];\\n                j=arr.length;\\n            }\\n        }\\n    }\\n    return count;\\n};", "var findMinFibonacciNumbers = function(k) {\\n    let nums=[1,1];\\n    let i=2;\\n    let count=0;\\n    while(nums[i-1]<=k){\\n        nums[i]=nums[i-1]+nums[i-2];\\n        i++;\\n    }\\n    for(let i=nums.length-2; i>=0; i--){\\n        if(nums[i]<=k){\\n            k-=nums[i];\\n            count++;\\n            i--;\\n        }\\n    }\\n    return count;\\n\\n};", "var findMinFibonacciNumbers = function(k) {\\n    let arr=[1,1];\\n    let i=2;\\n    let count=1;\\n    while(arr[arr.length-1]<=k){\\n        arr.push(arr[i-1]+arr[i-2]);\\n        i++;\\n    }\\n    k-=arr[arr.length-2];\\n    while(k>0){\\n        count++;\\n        for(let j=0; j<arr.length; j++){\\n            if(arr[j]>k){\\n                k-=arr[j-1];\\n                j=arr.length;\\n            }\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "1234", "ref_js": ["var getHappyString = function(n, k) {\\n    function* getHappy(str) {\\n        if (str.length === n) {\\n            yield str;\\n            return;\\n        }\\n        for (let c of \\'abc\\') {\\n            if (c === str.slice(-1)) continue;\\n            yield* getHappy(str + c);\\n        }\\n    }\\n    const happy = getHappy(\\'\\');\\n    let res = \\'\\';\\n    while (k--) res = happy.next().value;\\n    return res || \\'\\';\\n};", "var getHappyString = function(n, k) {\\n    function* getHappy(str) {\\n        if (str.length === n) {\\n            yield str;\\n            return;\\n        }\\n        for (let c of \\'abc\\') {\\n            if (c === str.slice(-1)) continue;\\n            yield* getHappy(str + c);\\n        }\\n    }\\n    const happy = getHappy(\\'\\');\\n    let res = \\'\\';\\n    while (k--) res = happy.next().value;\\n    return res || \\'\\';\\n};", "var getHappyString = function(n, k) {\\n    function* getHappy(str) {\\n        if (str.length === n) {\\n            yield str;\\n            return;\\n        }\\n        for (let c of \\'abc\\') {\\n            if (c === str.slice(-1)) continue;\\n            yield* getHappy(str + c);\\n        }\\n    }\\n    const happy = getHappy(\\'\\');\\n    let res = \\'\\';\\n    while (k--) res = happy.next().value;\\n    return res || \\'\\';\\n};"]}
{"id": "1235", "ref_js": ["var displayTable = function (orders) {\\r\\n    const tablesLookup = new Map(); \\r\\n    const foodsLookup = new Set();\\r\\n    for (const [_, table, food] of orders) {\\r\\n        foodsLookup.add(food); \\r\\n        if (!tablesLookup.has(table)) {\\r\\n            tablesLookup.set(table, new Map()); \\r\\n        }\\r\\n        const tableMap = tablesLookup.get(table);\\r\\n        tableMap.set(food, (tableMap.get(food) || 0) + 1);\\r\\n    }\\r\\n    const food = [\"Table\", ...[...foodsLookup].sort()];\\r\\n    const result = [food];\\r\\n    for (const [table, tableMap] of [...tablesLookup].sort(([a], [b]) => parseInt(a) - parseInt(b))) {\\r\\n        const row = [table]; \\r\\n        for (let i = 1; i < food.length; i++) {\\r\\n            row.push((tableMap.get(food[i]) || 0).toString());\\r\\n        } \\r\\n        result.push(row);\\r\\n    } \\r\\n    return result;\\r\\n};", "var displayTable = function (orders) {\\r\\n    const tablesLookup = new Map(); \\r\\n    const foodsLookup = new Set();\\r\\n    for (const [_, table, food] of orders) {\\r\\n        foodsLookup.add(food); \\r\\n        if (!tablesLookup.has(table)) {\\r\\n            tablesLookup.set(table, new Map()); \\r\\n        }\\r\\n        const tableMap = tablesLookup.get(table);\\r\\n        tableMap.set(food, (tableMap.get(food) || 0) + 1);\\r\\n    }\\r\\n    const food = [\"Table\", ...[...foodsLookup].sort()];\\r\\n    const result = [food];\\r\\n    for (const [table, tableMap] of [...tablesLookup].sort(([a], [b]) => parseInt(a) - parseInt(b))) {\\r\\n        const row = [table]; \\r\\n        for (let i = 1; i < food.length; i++) {\\r\\n            row.push((tableMap.get(food[i]) || 0).toString());\\r\\n        } \\r\\n        result.push(row);\\r\\n    } \\r\\n    return result;\\r\\n};", "var displayTable = function (orders) {\\r\\n    const tablesLookup = new Map(); \\r\\n    const foodsLookup = new Set();\\r\\n    for (const [_, table, food] of orders) {\\r\\n        foodsLookup.add(food); \\r\\n        if (!tablesLookup.has(table)) {\\r\\n            tablesLookup.set(table, new Map()); \\r\\n        }\\r\\n        const tableMap = tablesLookup.get(table);\\r\\n        tableMap.set(food, (tableMap.get(food) || 0) + 1);\\r\\n    }\\r\\n    const food = [\"Table\", ...[...foodsLookup].sort()];\\r\\n    const result = [food];\\r\\n    for (const [table, tableMap] of [...tablesLookup].sort(([a], [b]) => parseInt(a) - parseInt(b))) {\\r\\n        const row = [table]; \\r\\n        for (let i = 1; i < food.length; i++) {\\r\\n            row.push((tableMap.get(food[i]) || 0).toString());\\r\\n        } \\r\\n        result.push(row);\\r\\n    } \\r\\n    return result;\\r\\n};"]}
{"id": "1236", "ref_js": ["var minNumberOfFrogs = function(croakOfFrogs) {\\n    let c=0;let r=0;let o=0;let a=0;let k=0;\\n    ", "var minNumberOfFrogs = function(croakOfFrogs) {\\n    ", "var minNumberOfFrogs = function(croakOfFrogs) {\\n    const countMap = new Map();\\n    const croak = [\\'c\\', \\'r\\', \\'o\\', \\'a\\', \\'k\\'];\\n    const croakMap = croak.reduce((map, char, index) => (map[char] = index, map), {});\\n    let result = frog = 0;\\n\\n    for (const char of croakOfFrogs) {\\n        if (char !== \\'k\\') {\\n           const count = countMap.get(char) ?? 0;\\n\\n           countMap.set(char, count + 1);\\n        }\\n        if (char === \\'c\\') {\\n            frog += 1;\\n            result = Math.max(result, frog);\\n            continue;\\n        } \\n        const index = croakMap[char];\\n        const preCharCount = countMap.get(croak[index - 1]) ?? 0;\\n    \\n        if (preCharCount - 1 < 0) return -1;\\n        if (char === \\'k\\') frog -= 1;\\n        countMap.set(croak[index - 1], preCharCount - 1);\\n    }\\n    return frog ? -1 : result;\\n};"]}
{"id": "1237", "ref_js": ["var maxScore = function(C, K) {\\n    let total = 0\\n    for (let i = 0; i < K; i++) total += C[i]\\n    let best = total\\n    for (let i = K - 1, j = C.length - 1; ~i; i--, j--)\\n        total += C[j] - C[i], best = Math.max(best, total)\\n    return best\\n};", "var maxScore = function(cardPoints, k) {\\n    let size = cardPoints.length;\\n    let [left, right] = [k-1, size-1];\\n    \\n    ", "var maxScore = function(cardPoints, k) {\\n    let max_score = 0, total_score = 0, curr_score = 0, n = cardPoints.length\\n    for(let points of cardPoints)    total_score += points\\n    if(n == k)  return total_score\\n    for(let i=0; i<n-k-1; i++)  curr_score += cardPoints[i]\\n    for(let i=n-k-1; i<n; i++){\\n        curr_score += cardPoints[i]\\n        max_score = Math.max(max_score, total_score - curr_score)\\n        curr_score -= cardPoints[i-(n-k-1)]\\n    }   \\n    return max_score\\n};"]}
{"id": "1238", "ref_js": ["var findDiagonalOrder = function(nums) {\\n    const result = [];\\n\\n    for (let row = 0; row < nums.length; row++) {\\n        for (let col = 0; col < nums[row].length; col++) {\\n            const num = nums[row][col];\\n            if (!num) continue;\\n            const current = result[row + col];\\n\\n            current \\n                ? current.unshift(num)\\n                : result[row + col] = [num];\\n        }\\n    }\\n    return result.flat();\\n};", "var findDiagonalOrder = function (nums) {\\n     if (!nums || nums.length === 0 || nums[0].length === 0) {\\n        return [];\\n    }\\n\\n    const rows = nums.length;\\n    const cols = Math.max(...nums.map(row => row.length)); \\n    const result = [];\\n\\n    for (let sum = 0; sum <= rows + cols - 2; sum++) {\\n        for (let row = Math.min(sum, rows - 1); row >= 0 && sum - row < cols; row--) {\\n            if (nums[row][sum - row] !== undefined) {\\n                result.push(nums[row][sum - row]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n};", "var findDiagonalOrder = function(nums) {\\n    let m = nums.length;\\n    let maxSum = 0, size = 0, index = 0;\\n    let map = new Array(100001);\\n    \\n    for (let i = 0; i < m; i++) {\\n        size += nums[i].length;\\n        for (let j = 0; j < nums[i].length; j++) {\\n            let sum = i + j;\\n            if (!map[sum]) map[sum] = [];\\n            map[sum].push(nums[i][j]);\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n    }\\n    \\n    let res = new Array(size);\\n    for (let i = 0; i <= maxSum; i++) {\\n        let cur = map[i];\\n        for (let j = cur.length - 1; j >= 0; j--) {\\n            res[index++] = cur[j];\\n        }\\n    }\\n    \\n    return res;\\n};"]}
{"id": "1239", "ref_js": ["var maxDiff = function(num) {\\n\\n    let arrA = Array.from(num.toString())\\n    let numX = arrA[0]\\n    let numY = arrA[0]\\n    let checkA = checkB = true\\n    for(let i=0 ; i<arrA.length ; i++){\\n        if(arrA[i] != 9 && checkA){\\n            numX = arrA[i]\\n            checkA = false\\n        }\\n        if(arrA[i] != 1 && arrA[i] != 0 && checkB){\\n            numY = arrA[i]\\n            checkB= false\\n        }\\n    }\\n\\n    let lowerNumber = arrA[0] === numY ? 1 : 0\\n    \\n    \\n    let a = Number( arrA.map(str =>  str===numX? 9 : str).join(\"\") )\\n    let b = Number( arrA.map(str =>  str===numY? lowerNumber : str).join(\"\") )\\n    return a-b\\n\\n};", "var maxDiff = function(num) {\\n    let s = String(num);\\n    let start1 =s[0];\\n    let start2=s[0];\\n    let isOne = s[0]==\\'1\\';\\n    let a=true;\\n    let b= true;\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]!=\\'9\\' && a){\\n            start1=s[i];\\n            a=false;\\n        }\\n        if((s[i]!=\\'1\\' && s[i]!=\\'0\\') && b){\\n            start2=s[i];\\n            b=false;\\n        }\\n        if(!a && !b) i=s.length;\\n    };", "var maxDiff = function(num) {\\n    const arrRepr = num.toString().split(\\'\\')\\n    let a = arrRepr\\n    let b = arrRepr\\n\\n    for (let i = 0; i < arrRepr.length; i++) {\\n        if (arrRepr[i] === \\'9\\') continue\\n        else {\\n            a = a.map(d => d === arrRepr[i] ? \\'9\\' : d)\\n            break\\n        }\\n    }\\n\\n    for (let i = 0; i < arrRepr.length; i++) {\\n        if (arrRepr[i] === \\'0\\') continue\\n        if (arrRepr[0] === \\'1\\' && arrRepr[i] === \\'1\\') continue\\n        if (i === 0) {\\n            b = b.map(d => d === arrRepr[i] ? \\'1\\' : d)\\n            break\\n        } else {\\n            b = b.map((d, ind) => d === arrRepr[i] && ind !== 0 ? \\'0\\' : d)\\n            break\\n        }\\n    }\\n\\n    return Number(a.join(\\'\\')) - Number(b.join(\\'\\'))\\n};"]}
{"id": "1240", "ref_js": ["var checkIfCanBreak = function(s1, s2) {\\n    const permutationS1 = s1.split(\\'\\').sort();\\n    const permutationS2 = s2.split(\\'\\').sort();\\n    const isCanBreak = (s1, s2) => {\\n        for (let index = 0; index < s1.length; index++) {\\n            if (s1[index] >= s2[index]) continue;\\n            return false;\\n        }\\n        return true;\\n    };", "var checkIfCanBreak = function(s1, s2) {\\n    var r1=[],r2=[];  ", "var checkIfCanBreak = function(s1, s2) {\\n    var r1=[],r2=[];  "]}
{"id": "1241", "ref_js": ["var longestSubarray = function(nums, limit) {\\n    const maxQueue = [];\\n    const minQueue = [];\\n    let start = 0;\\n    let res = 0;\\n    for(let end = 0; end < nums.length; end ++) {\\n        const num = nums[end];\\n        while(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n            maxQueue.pop();\\n        }\\n        \\n        while(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n            minQueue.pop();\\n        }\\n        maxQueue.push(num);\\n        minQueue.push(num);\\n        if(maxQueue[0] - minQueue[0] > limit) {\\n            if(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n            \\n            start +=1;\\n        }\\n        res = Math.max(res, end - start + 1);\\n    }\\n    \\n    return res;\\n};", "var longestSubarray = function(nums, limit) {\\n    const maxQueue = [];\\n    const minQueue = [];\\n    let start = 0;\\n    let res = 0;\\n    for(let end = 0; end < nums.length; end ++) {\\n        const num = nums[end];\\n        while(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n            maxQueue.pop();\\n        }\\n        \\n        while(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n            minQueue.pop();\\n        }\\n        maxQueue.push(num);\\n        minQueue.push(num);\\n        if(maxQueue[0] - minQueue[0] > limit) {\\n            if(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n            \\n            start +=1;\\n        }\\n        res = Math.max(res, end - start + 1);\\n    }\\n    \\n    return res;\\n};", "var longestSubarray = function(nums, limit) {\\n    const maxQueue = [];\\n    const minQueue = [];\\n    let start = 0;\\n    let res = 0;\\n    for(let end = 0; end < nums.length; end ++) {\\n        const num = nums[end];\\n        while(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n            maxQueue.pop();\\n        }\\n        \\n        while(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n            minQueue.pop();\\n        }\\n        maxQueue.push(num);\\n        minQueue.push(num);\\n        if(maxQueue[0] - minQueue[0] > limit) {\\n            if(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n            \\n            start +=1;\\n        }\\n        res = Math.max(res, end - start + 1);\\n    }\\n    \\n    return res;\\n};"]}
{"id": "1242", "ref_js": ["var buildArray = function(target, n) {\\n    const result = [];  ", "var buildArray = function (target, n) {\\n    let ans = [];\\n    let i = 1;\\n\\n    for (let a of target) {\\n        while (i < a) {\\n            ans.push(\"Push\");\\n            ans.push(\"Pop\");\\n            i++;\\n        }\\n\\n        ans.push(\"Push\");\\n        i++;\\n    }\\n\\n    return ans;\\n};", "var buildArray = function (target, n) {\\n    let ans = [];\\n    let i = 1;\\n\\n    for (let a of target) {\\n        while (i < a) {\\n            ans.push(\"Push\");\\n            ans.push(\"Pop\");\\n            i++;\\n        }\\n\\n        ans.push(\"Push\");\\n        i++;\\n    }\\n\\n    return ans;\\n};"]}
{"id": "1243", "ref_js": ["var countTriplets = function(arr) {\\n    const size = arr.length;\\n    let result = 0;\\n\\n    for (let i = 0; i < size; i++) {\\n        let current = arr[i];\\n\\n        for (let k = i + 1; k < size; k++) {\\n            current = current ^ arr[k];\\n            if (current > 0) continue;\\n            result += k - i;\\n        }\\n    }\\n    return result;\\n};", "var countTriplets = function(arr) {\\n    let n = arr.length;\\n    let res = 0, xor = 0, c, t;\\n    let count = {0:1}, total = {}\\n    for (let i = 0; i < n; i++) {\\n        xor ^= arr[i];\\n        c = count[xor] || 0;\\n        t = total[xor] || 0;\\n        res += c * i - t;\\n        count[xor] = c + 1;\\n        total[xor] = t + i + 1;\\n    }\\n    return res;\\n};", "var countTriplets = function(arr) {\\n    const size = arr.length;\\n    let result = 0;\\n\\n    for (let i = 0; i < size; i++) {\\n        let current = arr[i];\\n\\n        for (let k = i + 1; k < size; k++) {\\n            current = current ^ arr[k];\\n            if (current > 0) continue;\\n            result += k - i;\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1244", "ref_js": ["var minTime = function(n, edges, hasApple) {\\n    const parentMap = new Map();\\n    let answer = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n        parentMap.set(edges[i][1], edges[i][0]);\\n    }\\n    for (let i = 0; i < hasApple.length; i++) {\\n        if (hasApple[i]) {\\n            let pointer = i;\\n            while (pointer !== 0) {\\n                const parent = parentMap.get(pointer);\\n                answer += 2;\\n                if (hasApple[parent]) {\\n                    break;\\n                }\\n                hasApple[parent] = true;\\n                pointer = parent;\\n            }\\n        }\\n    }\\n    return answer;\\n};", "var minTime = function(n, edges, hasApple) {\\n    const adj = {}\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = [];\\n    }\\n\\n    for (let i = 0; i < edges.length; i++) {\\n        [par, child] = edges[i];\\n        adj[par].push(child);\\n        adj[child].push(par);\\n    }\\n\\n   function dfs(curr, par) {\\n        let time = 0;\\n        for (let nei of adj[curr]) {\\n            if (nei === par) continue;\\n            let childTime = dfs(nei, curr);\\n            if (childTime || hasApple[nei]) {\\n                time += 2 + childTime;\\n            }\\n        }\\n        return time;\\n   }\\n\\n   return dfs(0, -1);\\n};", "var minTime = function(n, edges, hasApple) {\\n    const parentMap = new Map();\\n    let answer = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n        parentMap.set(edges[i][1], edges[i][0]);\\n    }\\n    for (let i = 0; i < hasApple.length; i++) {\\n        if (hasApple[i]) {\\n            let pointer = i;\\n            while (pointer !== 0) {\\n                const parent = parentMap.get(pointer);\\n                answer += 2;\\n                if (hasApple[parent]) {\\n                    break;\\n                }\\n                hasApple[parent] = true;\\n                pointer = parent;\\n            }\\n        }\\n    }\\n    return answer;\\n};"]}
{"id": "1245", "ref_js": ["var simplifiedFractions = function (N) {\\n  let s1 = new Set()\\n  let an = []\\n  for (let n = 1; n < N; n++) {\\n    for (let d = 2; d <= N; d++) {\\n      if (((n / d) > 0) && ((n / d) < 1)) {\\n        ", "var simplifiedFractions = function(n) {\\n    const gcd = (a, b) => !b ? a : gcd(b, a % b), result = [];\\n    for (let i = 1; i < n; i++) for (let j = i + 1; j <= n; j++)\\n        if (gcd(i,j) === 1) result.push(`${i}/${j}`);\\n    return result;\\n};", "var simplifiedFractions = function(n) {\\n    if(n===1)\\n    return [];\\n\\n    var ans=[];\\n    for(var i=2;i<=n;i++)\\n    {\\n      for(var j=1;j<i;j++)\\n      {\\n        if(hcf(i,j) == 1)\\n        ans.push(`${j}/${i}`);\\n      }\\n    }\\n    return ans;\\n};"]}
{"id": "1246", "ref_js": ["var goodNodes = function(root) {\\n    let count = 0;\\n  \\n    function dfs(root, max) {\\n        if (root == null)\\n            return;\\n        \\n        if (root.val >= max) {\\n            max = root.val;\\n            count++;\\n        }\\n        \\n        dfs(root.left, max);\\n        dfs(root.right, max);\\n    }\\n\\t\\n\\tdfs(root, root.val);\\n    return count;\\n};", "var goodNodes = function(root, max = -Infinity) {   \\n    if(root == null) return 0;\\n    let res = 0;\\n\\n    if(root.val >= max){\\n        res++;\\n        max = root.val;\\n    }\\n\\n    res += goodNodes(root.left, max);\\n    res += goodNodes(root.right, max);\\n\\n    return res;\\n}\\n\\nvar goodNodes = function(root) {\\n    \\n    let stck = [], res = 0;\\n    stck.push([root, root.val])\\n\\n    while(stck.length > 0){\\n        let curr = stck.pop();\\n        let [node, max] = [curr[0], curr[1]];\\n\\n        if(node.val >= max){\\n            res++;\\n            max = node.val;\\n        }\\n        node.left && stck.push([node.left, max]);\\n        node.right && stck.push([node.right, max]);\\n    }\\n    return res;\\n};", "var goodNodes = function(root) {\\n\\t"]}
{"id": "1247", "ref_js": ["var arrangeWords = function(text) {\\n   let Obj = {}\\n   let count = 0\\n   let str = \"\"\\n   text = text.toLocaleLowerCase()\\n   for (let i = 0; i <= text.length; i++) {\\n      if (text[i] !== \" \" && i <= text.length - 1) {\\n         count++\\n         str += text[i]\\n      }\\n      else {\\n         if (Obj[count])\\n            Obj[count] +=\" \"+ str\\n         else Obj[count] = str\\n         count = 0\\n         str = \"\"\\n      }\\n   }", "var arrangeWords = function (text) {\\n    \\n    let rearranged = text.toLowerCase()\\n        .split(\" \")\\n        .map((word, index) => [word, index])\\n        .sort((a, b) => a[0].length - b[0].length || a[1] - b[1])\\n        .map((info) => info[0])\\n        .join(\" \");\\n\\n    rearranged = rearranged.charAt(0).toUpperCase() + rearranged.substring(1);\\n\\n    return rearranged;\\n};", "var arrangeWords = function(text) {\\n   let Obj = {}\\n   let count = 0\\n   let str = \"\"\\n   text = text.toLocaleLowerCase()\\n   for (let i = 0; i <= text.length; i++) {\\n      if (text[i] !== \" \" && i <= text.length - 1) {\\n         count++\\n         str += text[i]\\n      }\\n      else {\\n         if (Obj[count])\\n            Obj[count] +=\" \"+ str\\n         else Obj[count] = str\\n         count = 0\\n         str = \"\"\\n      }\\n   }"]}
{"id": "1248", "ref_js": ["var peopleIndexes = function (favCompaniesOfUsers) {\\n  ", "var peopleIndexes = function(favoriteCompanies) {\\n  const invertedIndex = new Map();\\n  const result = [];\\n\\n  for(let i=0; i < favoriteCompanies.length; i++) {\\n      for(let compa of favoriteCompanies[i]) {\\n          const target = invertedIndex.get(compa) || new Set();\\n          target.add(i);\\n          invertedIndex.set(compa, target);\\n      }\\n  }\\n  for(let i = 0; i < favoriteCompanies.length; i++) {\\n      let counterSet = null;\\n      for(let compa of favoriteCompanies[i]) {\\n          if(counterSet === null) {\\n            counterSet = new Set([...invertedIndex.get(compa)]);\\n          } else {\\n            counterSet = intersect(counterSet, invertedIndex.get(compa));\\n          }\\n      }\\n      if(counterSet.size === 1) {\\n        result.push(i);\\n      }\\n  }\\n  return result.length === 0 ? [0] : result;\\n};", "var peopleIndexes = function(favoriteCompanies) {\\n    const companiesSet = [];\\n    const sortFavoriteCompanies = [...favoriteCompanies]\\n        .map((favorites, index) => ({ favorites, index }))\\n        .sort((a, b) => b.favorites.length - a.favorites.length);\\n    \\n    return sortFavoriteCompanies.reduce((result, { favorites, index }) => {\\n        const isSubset = companiesSet.some(companies => {\\n            return favorites.every(company => companies.has(company));\\n        });\\n\\n        if (!isSubset) {\\n            companiesSet.push(new Set(favorites));\\n            result.push(index);\\n        }\\n        return result;\\n    }, []).sort((a, b) => a - b);\\n};"]}
{"id": "1249", "ref_js": ["var maxVowels = function(s, k) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n    let maxCount = 0;\\n    let start = 0;\\n    let count = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        if (vowels.includes(s[end])) {\\n            count +=1;\\n        }\\n        if (end - start + 1 > k) {\\n            if(vowels.includes(s[start])) {\\n                count -=1;\\n            }\\n            start +=1;\\n        }\\n        maxCount = Math.max(maxCount, count)\\n        if (maxCount == k) return maxCount;\\n    }\\n    return maxCount;\\n};", "var maxVowels = function(s, k) {\\n    let max = 0;\\n    let counter = 0;\\n\\n    ", "var maxVowels = function(s, k) {\\n    let max =0, count=0; \\n    for(let i=0;i<k;i++){\\n        if(check(s[i])){\\n            count++\\n        }\\n\\n    }\\n    max = count\\n    for(let i=k; i<s.length; i++){\\n        if(check(s[i])){\\n            count++\\n        }\\n        if(check(s[i-k])){\\n            count--\\n        }\\n        max = Math.max(max, count)\\n    }\\n    return max\\n\\n    \\n};"]}
{"id": "1250", "ref_js": ["var pseudoPalindromicPaths  = function(root) {\\n    ans = 0;\\n    let arr = new Array(10);\\n    for(let i=1;i<=9;i++) arr[i] = 0;\\n    fun(root,arr,0);\\n    return ans;\\n};", "var pseudoPalindromicPaths = function(root) {\\n    let count = 0\\n    var driver = function(r, freq) {\\n        if (!r) return\\n        freq[r.val] += 1\\n        if (r.right === null && r.left === null) {\\n            mismatch = 0;\\n            for (i = 0; i < 10; i++) {\\n                mismatch += (freq[i] % 2)\\n            }\\n            if (mismatch <= 1) {\\n                count++\\n            };", "var pseudoPalindromicPaths  = function(root) {\\n    const countOddOccurrences = (occurrences) => occurrences.reduce((acc, occurrence) => acc + occurrence%2, 0);\\n\\n    const dfs = (node = root, occurrences = new Array(10).fill(0)) => {\\n        if(!node) return 0;\\n\\n        let paths = 0;\\n        occurrences[node.val] += 1;\\n        if(!node.left && !node.right) {\\n            paths = countOddOccurrences(occurrences) <= 1 ? 1 : 0;\\n        } else {\\n            paths = dfs(node.left, occurrences) + dfs(node.right, occurrences);\\n        }\\n        occurrences[node.val] -= 1;\\n\\n        return paths;\\n    }\\n\\n    return dfs();\\n};"]}
{"id": "1251", "ref_js": ["var hasAllCodes = function(s, k) {\\n    \\n    if (k > s.length) {\\n        return false;\\n    }\\n    \\n    \\n    const max = Math.pow(2, k);\\n    \\n     \\n    const set = new Set();\\n    \\n    for(let i = 0; i < s.length - k + 1; i++) {\\n        \\n        const substr = s.substr(i, k);        \\n        set.add(substr);\\n        \\n        \\n        if (set.size === max) {\\n            return true;\\n        }\\n    }\\n          \\n    return set.size === max;\\n};", "var hasAllCodes = function(S, K) {\\n    let len = S.length, count = 1 << K,\\n        seen = new Uint8Array(count),\\n        num = parseInt(S.slice(len - K + 1), 2) << 1\\n    for (let i = len - K; ~i; i--) {\\n        num = ((S.charAt(i) << K) + num) >> 1\\n        if (!seen[num]) seen[num] = 1, count--\\n        if (!count) return true\\n        if (i < count) return false\\n    }\\n};", "var hasAllCodes = function(s, k) {\\n    \\n    if (k > s.length) {\\n        return false;\\n    }\\n    \\n    \\n    const max = Math.pow(2, k);\\n    \\n     \\n    const set = new Set();\\n    \\n    for(let i = 0; i < s.length - k + 1; i++) {\\n        \\n        const substr = s.substr(i, k);        \\n        set.add(substr);\\n        \\n        \\n        if (set.size === max) {\\n            return true;\\n        }\\n    }\\n          \\n    return set.size === max;\\n};"]}
{"id": "1252", "ref_js": ["var checkIfPrerequisite = function (n, pres, qs) {\\n  let g = Array.from({ length: n }, () => new Array(n).fill(0))\\n  for (let [u, v] of pres) {\\n    g[u][v] = 1\\n  }\\n\\n  for (let mid = 0; mid < n; mid++) {\\n    for (let u = 0; u < n; u++) {\\n      for (let v = 0; v < n; v++) {\\n        if (g[u][mid] && g[mid][v]) {\\n          g[u][v] = 1\\n        }\\n      }\\n    }\\n  }\\n\\n  let an = []\\n  for (let [u, v] of qs) {\\n    an.push(g[u][v])\\n  }\\n  return an\\n};", "var checkIfPrerequisite = function(numCourses, prerequisites, queries) {\\n    const answer = []\\n    const adj = []\\n    const preMap = {}\\n\\n    for(let i =0;i<numCourses;i++){\\n        adj[i] = []\\n    }\\n\\n    for(const [pre, crs] of prerequisites){\\n        adj[crs].push(pre)\\n    }\\n\\n    const dfs = (crs)=>{\\n        if(!(crs in preMap)){\\n            const preSet= new Set()\\n            for(const pre of adj[crs]){\\n                preSet.add(pre)\\n               const preOfPreSet = dfs(pre)\\n               preOfPreSet.forEach(val => preSet.add(val))\\n            }\\n            preMap[crs] = preSet\\n        }\\n        return preMap[crs]\\n    }\\n\\n    for(let i =0;i<numCourses;i++){\\n        dfs(i)\\n    }\\n\\n    for(const [u, v] of queries){\\n       answer.push(preMap[v].has(u))\\n        \\n    }\\n    return answer\\n};", "var checkIfPrerequisite = function(numCourses, prerequisites, queries) {\\n    let adjList = {};"]}
{"id": "1253", "ref_js": ["var maxArea = function(h, w, hc, vc) {\\n    hc.sort((a,b) => a - b)\\n    vc.sort((a,b) => a - b)\\n    let maxh = Math.max(hc[0], h - hc[hc.length-1]),\\n        maxv = Math.max(vc[0], w - vc[vc.length-1])\\n    for (let i = 1; i < hc.length; i++)\\n        maxh = Math.max(maxh, hc[i] - hc[i-1])\\n    for (let i = 1; i < vc.length; i++)\\n        maxv = Math.max(maxv, vc[i] - vc[i-1])\\n    return BigInt(maxh) * BigInt(maxv) % 1000000007n\\n};", "var maxArea = function(h, w, horizontalCuts, verticalCuts) {\\n    horizontalCuts.sort((a,b) => a-b)\\n    verticalCuts.sort((a,b) => a-b)\\n    let max_hor_dis = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length-1])\\n    let max_ver_dis = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length-1])\\n    for(let i=1; i<horizontalCuts.length; i++){\\n        max_hor_dis = Math.max(max_hor_dis, horizontalCuts[i] - horizontalCuts[i-1])\\n    }\\n    for(let i=1; i<verticalCuts.length; i++){\\n        max_ver_dis = Math.max(max_ver_dis, verticalCuts[i] - verticalCuts[i-1])\\n    }\\n    return BigInt(max_hor_dis) * BigInt(max_ver_dis) % BigInt(1e9+7)\\n};", "var maxArea = function(h, w, hc, vc) {\\n    hc.sort((a,b) => a - b)\\n    vc.sort((a,b) => a - b)\\n    let maxh = Math.max(hc[0], h - hc[hc.length-1]),\\n        maxv = Math.max(vc[0], w - vc[vc.length-1])\\n    for (let i = 1; i < hc.length; i++)\\n        maxh = Math.max(maxh, hc[i] - hc[i-1])\\n    for (let i = 1; i < vc.length; i++)\\n        maxv = Math.max(maxv, vc[i] - vc[i-1])\\n    return BigInt(maxh) * BigInt(maxv) % 1000000007n\\n};"]}
{"id": "1254", "ref_js": ["var minReorder = function(n, connections) {\\n    ", "var minReorder = function (n, connections) {\\n  ", "var minReorder = function (n, connections) {\\n  "]}
{"id": "1255", "ref_js": ["var getStrongest = function(arr, k) {\\n    const mid = Math.floor((arr.length - 1) / 2);\\n\\n    arr.sort((a, b) => a - b);\\n    const median = arr[mid];\\n    const result = [];\\n    let left = 0;\\n    let right = arr.length - 1;\\n \\n    while (left <= right && result.length < k) {\\n        if (median - arr[left] > arr[right] - median) {\\n            result.push(arr[left]);\\n            left += 1;\\n        } else {\\n            result.push(arr[right]);\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};", "var getStrongest = function(arr, k) {\\n    const mid = Math.floor((arr.length - 1) / 2);\\n\\n    arr.sort((a, b) => a - b);\\n    const median = arr[mid];\\n    const result = [];\\n    let left = 0;\\n    let right = arr.length - 1;\\n \\n    while (left <= right && result.length < k) {\\n        if (median - arr[left] > arr[right] - median) {\\n            result.push(arr[left]);\\n            left += 1;\\n        } else {\\n            result.push(arr[right]);\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};", "var getStrongest = function(arr, k) {\\n    const mid = Math.floor((arr.length - 1) / 2);\\n\\n    arr.sort((a, b) => a - b);\\n    const median = arr[mid];\\n    const result = [];\\n    let left = 0;\\n    let right = arr.length - 1;\\n \\n    while (left <= right && result.length < k) {\\n        if (median - arr[left] > arr[right] - median) {\\n            result.push(arr[left]);\\n            left += 1;\\n        } else {\\n            result.push(arr[right]);\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1258", "ref_js": ["var minSumOfLengths = function (a, t) {\\n  let n = a.length;\\n  let arrLRLen = [];\\n  let sum = 0;\\n  let L = 0;\\n  for (let R = 0; R < n; R++) {\\n    sum += a[R];\\n    while (sum > t) {\\n      sum -= a[L++];\\n    }\\n    if (sum === t) {\\n      arrLRLen.push([L, R, R - L + 1]);\\n      sum -= a[L++];\\n    }\\n  }\\n  arrLRLen.sort((a, b) => a[2] - b[2]);\\n  let min = Infinity;\\n  for (let i = 0; i < arrLRLen.length; i++) {\\n    for (let j = i + 1; j < arrLRLen.length; j++) {\\n      if (arrLRLen[i][2] + arrLRLen[j][2] >= min) break;\\n      if (arrLRLen[i][1] < arrLRLen[j][0] || arrLRLen[j][1] < arrLRLen[i][0]) {\\n        min = arrLRLen[i][2] + arrLRLen[j][2];\\n      }\\n    }\\n  }\\n  return min === Infinity ? -1 : min;\\n};", "var minSumOfLengths = function(arr, target) {\\n   let runSum=0, bestEndWnd=Array(arr.length).fill(), ans=Number.MAX_SAFE_INTEGER;\\n   for(let i=0,j=i;j<arr.length;j++){\\n       runSum+=arr[j];\\n       while(i<=j && runSum>target){\\n           runSum-=arr[i++];\\n       }\\n       \\n       if(runSum===target){\\n           bestEndWnd[j]=Math.min(j-1<0?Number.MAX_SAFE_INTEGER:bestEndWnd[j-1], j-i);\\n           if(i-1>=0 && bestEndWnd[i-1]!=Number.MAX_SAFE_INTEGER){\\n               ans=Math.min(ans,bestEndWnd[i-1]+(j-i)+2);\\n           }\\n           runSum-=arr[i];\\n           i++;\\n       }else{\\n           bestEndWnd[j]=j-1>=0?bestEndWnd[j-1]:Number.MAX_SAFE_INTEGER;\\n       }\\n       \\n   }\\n  return ans===Number.MAX_SAFE_INTEGER?-1:ans;\\n};", "var minSumOfLengths = function(arr, target) {\\n    const minSumLength = [];\\n    let currentSum = left = 0;\\n    let result = minSize = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < arr.length; index++) {\\n        currentSum += arr[index];\\n\\n        while (currentSum > target) {\\n            currentSum -= arr[left];\\n            left += 1;\\n        }\\n        if (currentSum === target) {\\n            const size = index - left + 1;\\n\\n            if (minSumLength[left - 1]) {\\n                result = Math.min(size + minSumLength[left - 1], result);\\n            }\\n            minSize = Math.min(size, minSize);\\n        }\\n        minSumLength[index] = minSize;\\n    }\\n    return result === Number.MAX_SAFE_INTEGER ? -1 : result;\\n};"]}
{"id": "1259", "ref_js": ["var findLeastNumOfUniqueInts = function(arr, k) {\\n    let m = new Map();\\n    arr.forEach(num => m.set(num, m.get(num)+1 || 1));\\n    let occurrences = Array.from(m.values());\\n    occurrences.sort((a,b) => a-b);\\n    let res = occurrences.length;\\n    for (let num of occurrences) {\\n        if (k >= num) {\\n            k -= num;\\n            res--;\\n        }\\n        else return res;\\n    }\\n    return res;\\n    ", "var findLeastNumOfUniqueInts = function(arr, k) {\\n    arr.sort()\\n    const counts = arr.reduce((acc, curr) => { \\n        acc[curr] = acc[curr] ? acc[curr] + 1: 1;\\n        return acc;\\n    }, {});\\n    \\n    arr.sort((a, b) => counts[a] - counts[b]);\\n    return new Set(arr.slice(k)).size;\\n};", "var findLeastNumOfUniqueInts = function(arr, k) {\\r\\n    const counter = new Map();\\r\\n    for (let i=0; i<arr.length; i++) {\\r\\n        let key = arr[i];\\r\\n        if (!counter.has(key)) {\\r\\n            counter.set(key, 1);\\r\\n        } else {\\r\\n            let value = counter.get(key);\\r\\n            counter.set(key, value+1);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    let unique = counter.size;\\r\\n\\r\\n    const array = [];\\r\\n    for (let key of counter.keys()){\\r\\n        array.push([key, counter.get(key)]);\\r\\n    }\\r\\n    array.sort((a,b) => a[1]-b[1]);\\r\\n\\r\\n    let currentK = k;\\r\\n        \\r\\n    for (let i=0; i<array.length; i++) {\\r\\n        let restK = currentK-array[i][1];\\r\\n        if (restK < 0){\\r\\n            break;\\r\\n        } else {\\r\\n            unique -= 1;\\r\\n            currentK = restK;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    return unique;\\r\\n};"]}
{"id": "1260", "ref_js": ["var minDays = function (bloomDay, m, k) {\\n  let n = bloomDay.length;\\n  let left = 1;\\n  let right = Number.MAX_SAFE_INTEGER;\\n  if (m * k > n) {\\n    return -1;\\n  }\\n  while (left < right) {\\n    let mid = Math.floor(left / 2 + right / 2);\\n    let flowers = 0;\\n    let bouque = 0;\\n    for (let j = 0; j < n; j++) {\\n      if (bloomDay[j] > mid) {\\n        flowers = 0;\\n      } else {\\n        flowers++;\\n        if (flowers >= k) {\\n          bouque++;\\n          flowers = 0;\\n        }\\n      }\\n    }\\n    if (bouque < m) {\\n      left = mid + 1;\\n    } else {\\n      right = mid;\\n    }\\n  }\\n\\n  return left;\\n};", "var minDays = function(bloomDay, m, k) {\\n    let n=bloomDay.length;\\n    if(n<(m*k)) return -1\\n    let low=Math.min(...bloomDay)\\n    let high=Math.max(...bloomDay)\\n    let ans=-1;\\n    while(low<=high)\\n    {\\n        let mid=Math.floor((low+high)/2)\\n        let days=position(bloomDay,mid,m,k)\\n        if(days)\\n        {\\n            ans=mid;\\n            high=mid-1\\n        }\\n        else\\n        {\\n            low=mid+1\\n        }\\n    }\\n    return ans\\n};", "var minDays = function(bloomDay, m, k) {\\n    let n=bloomDay.length;\\n    if(n<(m*k)) return -1\\n    let low=Math.min(...bloomDay)\\n    let high=Math.max(...bloomDay)\\n    let ans=-1;\\n    while(low<=high)\\n    {\\n        let mid=Math.floor((low+high)/2)\\n        let days=position(bloomDay,mid,m,k)\\n        if(days)\\n        {\\n            ans=mid;\\n            high=mid-1\\n        }\\n        else\\n        {\\n            low=mid+1\\n        }\\n    }\\n    return ans\\n};"]}
{"id": "1261", "ref_js": ["var getFolderNames = function (a) {\\n  let r = [];\\n  let map = new Map();\\n  for (let e of a) {\\n    if (!map.has(e)) {\\n      map.set(e, 0);\\n      r.push(e);\\n    } else {\\n      let cc = map.get(e);\\n      map.set(e, cc + 1);\\n      let eNew;\\n      do {\\n        eNew = e + \"(\" + (cc + 1) + \")\";\\n        cc++;\\n      } while (map.has(eNew));\\n      map.set(eNew, 0);\\n      r.push(eNew);\\n    }\\n  }\\n  return r;\\n};", "var getFolderNames = function(names) {\\n    const map={}, ans=[];\\n    for(const name of names){\\n        if(map[name]!==undefined){\\n            let nameCount=map[name]+1;\\n            let newName=`${name}(${nameCount})`;\\n            while(map[newName]!==undefined){ ", "var getFolderNames = function(names) {\\n    const map={}, ans=[];\\n    for(const name of names){\\n        if(map[name]!==undefined){\\n            let nameCount=map[name]+1;\\n            let newName=`${name}(${nameCount})`;\\n            while(map[newName]!==undefined){ "]}
{"id": "1262", "ref_js": ["var avoidFlood = function(rains) {\\n    const fullLakeMap = new Map();\\n    const dryDays = [];\\n    const result = [];\\n    const searchDryDay = (day) => {\\n        if (dryDays.at(-1) < day) return -1; \\n        let start = 0;\\n        let end = dryDays.length - 1;\\n\\n        while (start < end) {\\n            const mid = Math.floor((start + end) / 2);\\n\\n            dryDays[mid] < day ? start = mid + 1 : end = mid;\\n        }\\n        return start;\\n    };", "var avoidFlood = function(rains) {\\n    const fullLakeMap = new Map();\\n    const dryDays = [];\\n    const result = [];\\n    const searchDryDay = (day) => {\\n        if (dryDays.at(-1) < day) return -1; \\n        let start = 0;\\n        let end = dryDays.length - 1;\\n\\n        while (start < end) {\\n            const mid = Math.floor((start + end) / 2);\\n\\n            dryDays[mid] < day ? start = mid + 1 : end = mid;\\n        }\\n        return start;\\n    };", "var avoidFlood = function(rains) {\\n    const fullLakeMap = new Map();\\n    const dryDays = [];\\n    const result = [];\\n    const searchDryDay = (day) => {\\n        if (dryDays.at(-1) < day) return -1; \\n        let start = 0;\\n        let end = dryDays.length - 1;\\n\\n        while (start < end) {\\n            const mid = Math.floor((start + end) / 2);\\n\\n            dryDays[mid] < day ? start = mid + 1 : end = mid;\\n        }\\n        return start;\\n    };"]}
{"id": "1263", "ref_js": ["var wordPattern = function(pattern, s) {\\n\\n    ", "var wordPattern = function(pattern, s) {\\n    const arrayString = s.split(\\' \\');\\n    const hashMapPattern = {};", "var wordPattern = function(pattern, str) {\\n    const words = str.split(/\\\\s+/);\\n    const map = new Map();\\n    \\n    if(words.length !== pattern.length) return false;\\n    if(new Set(words).size !== new Set(pattern).size) return false;\\n    \\n    for(let i = 0; i < pattern.length; i++) {\\n        if(map.has(pattern[i]) && \\n           map.get(pattern[i]) !== words[i]) return false;\\n        map.set(pattern[i], words[i]);\\n    }\\n    return true;\\n};"]}
{"id": "1264", "ref_js": ["var longestSubarray = function(nums) {\\n    let leftPtr = 0;\\n    let result = 0;\\n    let zeroCount = 0;\\n    for(let rightPtr=0;rightPtr<nums.length;rightPtr++){\\n        \\n        if(nums[rightPtr]===0){\\n            zeroCount++\\n        }\\n\\n        if(zeroCount>1){\\n            if(nums[leftPtr]===0){\\n                zeroCount--;\\n            }\\n            leftPtr++;\\n        }\\n        if(zeroCount<=1){\\n            result = Math.max(result,rightPtr-leftPtr);\\n        }\\n    }\\n    return result;\\n};", "var longestSubarray = function(nums) {\\n    let leftPtr = 0;\\n    let result = 0;\\n    let zeroCount = 0;\\n    for(let rightPtr=0;rightPtr<nums.length;rightPtr++){\\n        \\n        if(nums[rightPtr]===0){\\n            zeroCount++\\n        }\\n\\n        if(zeroCount>1){\\n            if(nums[leftPtr]===0){\\n                zeroCount--;\\n            }\\n            leftPtr++;\\n        }\\n        if(zeroCount<=1){\\n            result = Math.max(result,rightPtr-leftPtr);\\n        }\\n    }\\n    return result;\\n};", "var longestSubarray = function(nums) {\\n    let leftPtr = 0;\\n    let result = 0;\\n    let zeroCount = 0;\\n    for(let rightPtr=0;rightPtr<nums.length;rightPtr++){\\n        \\n        if(nums[rightPtr]===0){\\n            zeroCount++\\n        }\\n\\n        if(zeroCount>1){\\n            if(nums[leftPtr]===0){\\n                zeroCount--;\\n            }\\n            leftPtr++;\\n        }\\n        if(zeroCount<=1){\\n            result = Math.max(result,rightPtr-leftPtr);\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1265", "ref_js": ["var canArrange = function (nums, k) {\\n    let map = {};", "var canArrange = function(arr, k) {\\n    const remaindMap = arr.reduce((map, num) => {\\n        const remaind = (num % k + k) % k;\\n        const count = map.get(remaind) ?? 0;\\n        \\n        return map.set(remaind, count + 1);\\n    }, new Map());\\n\\n    for (let num = 1; num < k; num++) {\\n        const count = remaindMap.get(num);\\n\\n        if (count !== remaindMap.get(k - num)) return false;\\n    }\\n    return !(remaindMap.get(0) % 2);\\n};", "var canArrange = function(arr, k) {\\n    arr = arr.map(x => x % k).map(x => (x < 0) ? (x + k) : x);\\n\\n    let counts = new Map();\\n    for (let i = 0; i < arr.length; i++) {\\n        let n = arr[i];\\n        counts.set(n, (counts.get(n) || 0) + 1);\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        let n = arr[i];\\n        if (counts.get(n) === 0) {\\n            continue;\\n        }\\n\\n        counts.set(n, counts.get(n) - 1);\\n\\n        let m = (k - n) % k;\\n        if (!counts.has(m) || (counts.get(m) === 0)) {\\n            return false;\\n        }\\n\\n        counts.set(m, counts.get(m) - 1);\\n    }\\n\\n    return true;\\n};"]}
{"id": "1266", "ref_js": ["var numSubseq = function(nums, target) \\n{\\n    const mod = 1000000007, arr = [];\\n    let num = 1;\\n\\n    for (let i = 0; i < nums.length; i++) \\n    {\\n        arr.push(num);\\n        num = num * 2 % mod;\\n    }\\n\\n    nums.sort((a,b) => a - b);\\n\\n    let count = 0, j = nums.length - 1;\\n\\n    for (let i = 0; i < nums.length && nums[i]*2 <= target; i++) \\n    {\\n        while (j && nums[j] + nums[i] > target) \\n        j--;\\n\\n        count = (count + arr[j - i])%mod;\\n    }\\n    return count;\\n};", "var numSubseq = function(nums, target) {\\n        let n = nums.length;\\n        let mod = 1_000_000_007;\\n        nums.sort((a,b) => a - b);\\n        \\n        ", "var numSubseq = function(nums, target) \\n{\\n    const mod = 1000000007, arr = [];\\n    let num = 1;\\n\\n    for (let i = 0; i < nums.length; i++) \\n    {\\n        arr.push(num);\\n        num = num * 2 % mod;\\n    }\\n\\n    nums.sort((a,b) => a - b);\\n\\n    let count = 0, j = nums.length - 1;\\n\\n    for (let i = 0; i < nums.length && nums[i]*2 <= target; i++) \\n    {\\n        while (j && nums[j] + nums[i] > target) \\n        j--;\\n\\n        count = (count + arr[j - i])%mod;\\n    }\\n    return count;\\n};"]}
{"id": "1267", "ref_js": ["var getLastMoment = function(n, left, right) {\\n    let leftMax = -Infinity;\\n    let rightMin = Infinity;\\n    \\n    for (let pos of left) {\\n        leftMax = Math.max(leftMax, pos);\\n    }\\n    \\n    for (let pos of right) {\\n        rightMin = Math.min(rightMin, pos);\\n    }\\n    \\n    return Math.max(leftMax, n - rightMin);\\n};", "var getLastMoment = function(n, left, right) {\\n    ", "var getLastMoment = function(n, left, right) {\\n    let leftMax = -Infinity;\\n    let rightMin = Infinity;\\n    \\n    for (let pos of left) {\\n        leftMax = Math.max(leftMax, pos);\\n    }\\n    \\n    for (let pos of right) {\\n        rightMin = Math.min(rightMin, pos);\\n    }\\n    \\n    return Math.max(leftMax, n - rightMin);\\n};"]}
{"id": "1268", "ref_js": ["var numSubmat = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const dp = Array(m + 1).fill(\\'\\').map(_ => Array(n + 1).fill(0));\\n    let result = 0;\\n\\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            if (!mat[row - 1][col - 1]) continue;\\n            dp[row][col] = dp[row][col - 1] + 1;\\n            let ones = dp[row][col];\\n\\n            for (k = row - 1; k >= 0; k--) {\\n                result += ones;\\n                ones = Math.min(ones, dp[k][col]);\\n            }\\n        }\\n    }\\n    return result;\\n};", "var numSubmat = function(mat) {\\n    let submatrices = 0;\\n\\n    for (let i = 0; i < mat.length; i++)\\n        for (let j = 0; j < mat[0].length; j++)\\n            mat[i][j] += mat[i][j] ? (mat[i][j - 1] || 0) : 0;\\n\\n    for (let i = 0; i < mat.length; i++)\\n        for (let j = 0; j < mat[0].length; j++)\\n            for (let k = i, len = Infinity; len > 0 && k >= 0; k--)\\n                len = Math.min(len, mat[k][j]), submatrices += len;\\n\\n    return submatrices;\\n};", "var numSubmat = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const dp = Array(m + 1).fill(\\'\\').map(_ => Array(n + 1).fill(0));\\n    let result = 0;\\n\\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            if (!mat[row - 1][col - 1]) continue;\\n            dp[row][col] = dp[row][col - 1] + 1;\\n            let ones = dp[row][col];\\n\\n            for (k = row - 1; k >= 0; k--) {\\n                result += ones;\\n                ones = Math.min(ones, dp[k][col]);\\n            }\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1269", "ref_js": ["var rangeSum = function(nums, n, left, right) {\\n  var len = nums.length\\n\\n  var prefix = [nums[0]]\\n  function buildPrefix() {\\n    for (var i = 1; i < len; i++) {\\n      prefix[i] = prefix[i - 1] + nums[i]\\n    }\\n  }\\n\\n  buildPrefix()\\n\\n  function countUnderSum(sum, cb) {\\n    var left = 0\\n    var count = 0\\n    var right = 0\\n\\n    while (right < len) {\\n      let wholeSubSum = prefix[right] - (left === 0 ? 0 : prefix[left - 1])\\n      if (wholeSubSum <= sum) {\\n        count += right - left + 1\\n        cb && cb(left, right)\\n      } else {\\n        while (\\n          wholeSubSum > sum\\n        ) {\\n          if (left <= right) {\\n            wholeSubSum -= nums[left]\\n            left++\\n          } else {\\n            break\\n          }\\n        }\\n        count += right - left + 1\\n        cb && cb(left, right)\\n      }\\n      right++\\n    }\\n\\n    return count\\n    \\n  }\\n\\n  function calSubArraySumByRange(i, j) {\\n    var windowLen = j - i + 1\\n    var sum = 0\\n    while (windowLen > 0) {\\n      sum += nums[j] * windowLen\\n      windowLen--\\n      j--\\n    }\\n    return sum\\n  }\\n\\n  function calSum(count) {\\n    var lowSum = findTheLowestSumThatSatisfyTheSpecficCount(count)\\n    var sum = 0 \\n    countUnderSum(lowSum, (i, j) => {\\n      sum += calSubArraySumByRange(i, j)\\n    })\\n\\n    ", "var rangeSum = function(nums, n, left, right) {\\n    const heap = new MinPriorityQueue({priority: x => x[0]});\\n    const mod = 10**9 + 7;\\n    let result = 0;\\n    \\n    for(let i = 0; i < n; i++) {\\n        heap.enqueue([nums[i], i]);\\n    }\\n    \\n    for(let i = 1; i <= right; i++) {\\n        const [sum, idx] = heap.dequeue().element;\\n        if(i >= left) result = (result + sum) % mod;\\n        ", "var rangeSum = function(nums, n, left, right) {\\n    if(n == 1000 && left == 1 && right == 500500) return 716699888;\\n    let array = [] ; \\n    for(let i = 0 ; i < nums.length ; ++i){\\n        for(let j = i ; j < nums.length ; ++j){\\n            let sum = 0 ; \\n            for(let k = i ; k <= j ; ++k){\\n                sum += nums[k] ; \\n            }\\n            array.push(sum) ; \\n        }\\n    }\\n    array.sort((a , b) => a - b) ;\\n    let count = 0 ; \\n    for(let i = left - 1 ; i < right ; ++i){\\n        count += array[i] ; \\n    }\\n    return count ; \\n};"]}
{"id": "1270", "ref_js": ["var minDifference = function(nums) {\\n    let len = nums.length;\\n    if(len <= 4){\\n        return 0;\\n    } else if(len <= 8){\\n        nums = nums.sort((a,b) => a-b);\\n        let min = Infinity;\\n        let t = len - 4;\\n        for(let i = 0; i< len-t; i++){\\n            min = Math.min(nums[i+t] - nums[i],min);\\n        }\\n        return min;\\n    } else{\\n        let s1 = smallest(nums);\\n        nums = removeItemOnce(nums,s1);\\n        let s2 = smallest(nums);\\n        nums = removeItemOnce(nums,s2);\\n        let s3 = smallest(nums);\\n        nums = removeItemOnce(nums,s3);\\n        let s4 = smallest(nums);\\n        nums = removeItemOnce(nums,s4);\\n        let l1 = maximal(nums);\\n        nums = removeItemOnce(nums,l1);\\n        let l2 = maximal(nums);\\n        nums = removeItemOnce(nums,l2);\\n        let l3 = maximal(nums);\\n        nums = removeItemOnce(nums,l3);\\n        let l4 = maximal(nums);\\n        return Math.min(l1 - s4, l2 - s3, l3 - s2, l4 - s1);\\n    }\\n};", "var minDifference = function(nums) {\\n    let len = nums.length;\\n    if(len <= 4){\\n        return 0;\\n    } else if(len <= 8){\\n        nums = nums.sort((a,b) => a-b);\\n        let min = Infinity;\\n        let t = len - 4;\\n        for(let i = 0; i< len-t; i++){\\n            min = Math.min(nums[i+t] - nums[i],min);\\n        }\\n        return min;\\n    } else{\\n        let s1 = smallest(nums);\\n        nums = removeItemOnce(nums,s1);\\n        let s2 = smallest(nums);\\n        nums = removeItemOnce(nums,s2);\\n        let s3 = smallest(nums);\\n        nums = removeItemOnce(nums,s3);\\n        let s4 = smallest(nums);\\n        nums = removeItemOnce(nums,s4);\\n        let l1 = maximal(nums);\\n        nums = removeItemOnce(nums,l1);\\n        let l2 = maximal(nums);\\n        nums = removeItemOnce(nums,l2);\\n        let l3 = maximal(nums);\\n        nums = removeItemOnce(nums,l3);\\n        let l4 = maximal(nums);\\n        return Math.min(l1 - s4, l2 - s3, l3 - s2, l4 - s1);\\n    }\\n};", "var minDifference = function(nums) {\\n    let len = nums.length;\\n    if(len <= 4){\\n        return 0;\\n    } else if(len <= 8){\\n        nums = nums.sort((a,b) => a-b);\\n        let min = Infinity;\\n        let t = len - 4;\\n        for(let i = 0; i< len-t; i++){\\n            min = Math.min(nums[i+t] - nums[i],min);\\n        }\\n        return min;\\n    } else{\\n        let s1 = smallest(nums);\\n        nums = removeItemOnce(nums,s1);\\n        let s2 = smallest(nums);\\n        nums = removeItemOnce(nums,s2);\\n        let s3 = smallest(nums);\\n        nums = removeItemOnce(nums,s3);\\n        let s4 = smallest(nums);\\n        nums = removeItemOnce(nums,s4);\\n        let l1 = maximal(nums);\\n        nums = removeItemOnce(nums,l1);\\n        let l2 = maximal(nums);\\n        nums = removeItemOnce(nums,l2);\\n        let l3 = maximal(nums);\\n        nums = removeItemOnce(nums,l3);\\n        let l4 = maximal(nums);\\n        return Math.min(l1 - s4, l2 - s3, l3 - s2, l4 - s1);\\n    }\\n};"]}
{"id": "1271", "ref_js": ["var numSub = function(s) {\\n    return s.split(\"0\").map(a=>a.length*(a.length+1)/2).reduce((a,b)=>a+b,0)  % 1000000007;\\n};", "var numSub = function(s) {\\n   let res=0;\\n   let cnt=0;\\n   const modul = 10 ** 9 + 7;\\n   for(let i=0; i<s.length; i++){\\n       if(s[i]==\\'1\\'){\\n           cnt++;\\n       }else{\\n           res=(res+cnt*(cnt+1)/2)%modul;\\n           cnt=0;\\n       }\\n       if(i==s.length-1 && cnt>0){\\n           res=(res+cnt*(cnt+1)/2)%modul;\\n       }\\n   } \\n   return res;\\n};", "var numSub = function(s) {\\n    const MODULO = 10 ** 9 + 7;\\n    let current = result = 0;\\n\\n    for (let index = 0; index <= s.length; index++) {\\n        const value = s[index];\\n\\n        if (value === \\'1\\') current += 1;\\n        else {\\n            result = (result + (current + 1) * current / 2) % MODULO;\\n            current = 0;\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1272", "ref_js": ["var maxProbability = function(n, edges, succProb, start, end) {\\n    const p = Array(n).fill(0);\\n    const graph = p.reduce((m, _, i) => m.set(i, []), new Map());\\n    edges.forEach(([u, v], i) => {\\n        graph.get(u).push([v, succProb[i]]);\\n        graph.get(v).push([u, succProb[i]]);\\n    });\\n    \\n    const queue = [[start, 1]];\\n    p[start] = 1;\\n    \\n    for (let [node, currP] of queue) {   \\n        for (let [adj, nextP] of graph.get(node)) {\\n        if (currP * nextP > p[adj]) {\\n            p[adj] = currP * nextP;\\n            queue.push([adj, p[adj]]);\\n        }\\n        }\\n    }\\n    \\n    return p[end];\\n};", "var maxProbability = function(n, edges, succProb, start, end) {\\n   const graph =  new Array(n).fill(null).map(()=>[]);\\n\\n   for(let i=0;i<edges.length;i++){\\n     const [a, b] = edges[i];\\n     graph[a].push([b, succProb[i]]);\\n     graph[b].push([a, succProb[i]])\\n   } \\n   const maxProb = new Array(n).fill(0);\\n\\n   maxProb[start] = 1;\\n\\n   const queue = [[start, 1]];\\n\\n   while(queue.length>0){\\n     const [current, currentProb] = queue.shift();\\n\\n     if(current === end){\\n       return currentProb;\\n     }\\n     for(const[next, prob] of graph[current]){\\n       const newProb = currentProb * prob;\\n\\n       if(newProb > maxProb[next]){\\n         maxProb[next] = newProb;\\n         queue.push([next, newProb]);\\n       }\\n     }\\n     queue.sort((a, b) =>{\\n       return b[1]-a[1];\\n     })\\n   }\\n   return 0;\\n};", "var maxProbability = function(n, edges, succProb, start, end) {\\n    const p = Array(n).fill(0);\\n    const graph = p.reduce((m, _, i) => m.set(i, []), new Map());\\n    edges.forEach(([u, v], i) => {\\n        graph.get(u).push([v, succProb[i]]);\\n        graph.get(v).push([u, succProb[i]]);\\n    });\\n    \\n    const queue = [[start, 1]];\\n    p[start] = 1;\\n    \\n    for (let [node, currP] of queue) {   \\n        for (let [adj, nextP] of graph.get(node)) {\\n        if (currP * nextP > p[adj]) {\\n            p[adj] = currP * nextP;\\n            queue.push([adj, p[adj]]);\\n        }\\n        }\\n    }\\n    \\n    return p[end];\\n};"]}
{"id": "1273", "ref_js": ["var countSubTrees = function(n, edges, labels) {\\n    labels = labels.split(\"\")\\n\\n    let adj = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        adj[edge[0]].push(edge[1])\\n        adj[edge[1]].push(edge[0])\\n    }\\n\\n    let res = new Array(n)\\n    let dfs = function (node, parent) {\\n        let map = {}\\n        for (let neighbor of adj[node]) {\\n            if (neighbor === parent) continue\\n            let val = dfs(neighbor, node)\\n            for (let [label, count] of Object.entries(val)) {\\n                if (!map[label]) map[label] = 0\\n                map[label] += count\\n            }\\n        }\\n        if (!map[labels[node]]) map[labels[node]] = 0\\n        map[labels[node]]++\\n        res[node] = map[labels[node]]\\n        return map\\n    }\\n\\n    dfs(0)\\n    return res\\n};", "var countSubTrees = function(n, edges, labels) {\\n    labels = labels.split(\"\")\\n\\n    let adj = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        adj[edge[0]].push(edge[1])\\n        adj[edge[1]].push(edge[0])\\n    }\\n\\n    let res = new Array(n)\\n    let dfs = function (node, parent) {\\n        let map = {}\\n        for (let neighbor of adj[node]) {\\n            if (neighbor === parent) continue\\n            let val = dfs(neighbor, node)\\n            for (let [label, count] of Object.entries(val)) {\\n                if (!map[label]) map[label] = 0\\n                map[label] += count\\n            }\\n        }\\n        if (!map[labels[node]]) map[labels[node]] = 0\\n        map[labels[node]]++\\n        res[node] = map[labels[node]]\\n        return map\\n    }\\n\\n    dfs(0)\\n    return res\\n};", "var countSubTrees = function(n, edges, labels) {\\n    labels = labels.split(\"\")\\n\\n    let adj = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        adj[edge[0]].push(edge[1])\\n        adj[edge[1]].push(edge[0])\\n    }\\n\\n    let res = new Array(n)\\n    let dfs = function (node, parent) {\\n        let map = {}\\n        for (let neighbor of adj[node]) {\\n            if (neighbor === parent) continue\\n            let val = dfs(neighbor, node)\\n            for (let [label, count] of Object.entries(val)) {\\n                if (!map[label]) map[label] = 0\\n                map[label] += count\\n            }\\n        }\\n        if (!map[labels[node]]) map[labels[node]] = 0\\n        map[labels[node]]++\\n        res[node] = map[labels[node]]\\n        return map\\n    }\\n\\n    dfs(0)\\n    return res\\n};"]}
{"id": "1274", "ref_js": ["var numOfSubarrays = function(arr) {\\n    const MODULO = 10 ** 9 + 7;\\n    const dp = Array(arr.length + 1).fill(\\'\\').map(_ => ({ odd: 0, even: 0 }));\\n    let result = 0;\\n\\n    for (let index = 1; index < dp.length; index++) {\\n        if (arr[index - 1] % 2) {\\n            dp[index].odd = dp[index - 1].even + 1;\\n            dp[index].even = dp[index - 1].odd;\\n        } else {\\n            dp[index].odd = dp[index - 1].odd;\\n            dp[index].even = dp[index - 1].even + 1;\\n        }\\n        result += dp[index].odd;\\n    }\\n   return result % MODULO;\\n};", "var numOfSubarrays = function(arr) {\\n\\n    let count = 0;\\n        let oddCount = 0;\\n        let evenCount = 0;\\n        let current = 0;\\n        let MOD = 1000000007\\n        for(let i = 0; i < arr.length; i++) {\\n            current = current + arr[i];\\n            if(current % 2 != 0) {\\n                count += 1 + evenCount;\\n                oddCount++;\\n            }\\n            else {\\n                count += oddCount;\\n                evenCount++;\\n            }\\n            count %= MOD;\\n        }\\n        return count;\\n    \\n};", "var numOfSubarrays = function(arr) {\\n    const temp = [1, 0], MOD = 1000000007;\\n    let value = 0;\\n    for (let i = 0; i < arr.length; i++){\\n        value = (value + arr[i]) % 2;\\n        temp[value]++;\\n    }\\n    return (temp[0] * temp[1]) % MOD;\\n};"]}
{"id": "1275", "ref_js": ["var numSplits = function(s) {\\n    let set = new Set();\\n    let l2r = new Array(s.length), r2l = new Array(s.length);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        set.add(s[i]);\\n        l2r[i] = set.size;\\n    }\\n    \\n    set = new Set();\\n    for (let i = s.length-1; i >= 0; i--) {\\n        set.add(s[i]);\\n        r2l[i] = set.size;\\n    }\\n    \\n    let res = 0;\\n    for (let i = 1; i < s.length; i++) {\\n        if (l2r[i-1] == r2l[i])\\n            res++;\\n    }\\n    return res;\\n};", "var numSplits = function(str) {\\n\\tlet l = -1;\\n\\tlet r = str.length;\\n\\tlet lSet = new Set();\\n\\tlet rSet = new Set();\\n\\tlet lInc = 0;\\n\\tlet rInc = str.length - 1;\\n\\n\\t", "var numSplits = function(s) {\\n        const leftDistinctCount = new Array(s.length);\\n    const rightDistinctCount = new Array(s.length);\\n    const distinctLeft = new Set();\\n    const distinctRight = new Set();\\n    let goodSplits = 0;\\n\\n    "]}
{"id": "1276", "ref_js": ["var minFlips = function(target) {\\n    let count = 0;\\n    let flipNum = \"0\";\\n    for(let i =0;i<target.length;i++){\\n      let char = target.charAt(i);\\n      if(char !== flipNum){\\n          flipNum = flipNum === \"0\" ? \"1\" : \"0\";\\n          count++; \\n      }\\n    }\\nreturn count;\\n};", "var minFlips = function(target) {\\n    let count = 0\\n    for(let i=0;i<target.length;i++){\\n        if(target[i] == \\'0\\') continue\\n        while(i < target.length && target[i] == \\'1\\'){\\n            i++\\n        }\\n        count++\\n    }\\n    return target[target.length-1] == \\'1\\' ? 2 * count - 1 : 2 * count\\n};", "var minFlips = function (target) {\\n\\n    let current = result = 0;\\n\\n    for (const value of target) {\\n        if (current === +value) continue;\\n        current ^= 1;\\n        result += 1;\\n    }\\n    return result;\\n\\n};"]}
{"id": "1277", "ref_js": ["var countPairs = function(root, distance) {\\n    let result = 0;\\n    const dfsTreeNode = (node = root) => {\\n        if (!node) return [];\\n        const { left, right } = node;\\n        if (!left && !right) return [1];\\n        const distances = Array(distance + 1).fill(0);\\n        const leftDistances = dfsTreeNode(node.left);\\n        const rightDistance = dfsTreeNode(node.right);\\n\\n        for (let l = 0; l < distance; l++) {\\n            for (let r = 0; r < distance; r++) {\\n                if (l + r + 2 > distance) continue;\\n                result += (leftDistances[l] ?? 0) * (rightDistance[r] ?? 0);\\n            }\\n        }\\n        for (let index = 0; index < distance; index++) {\\n            distances[index + 1] = (leftDistances[index] ?? 0) + (rightDistance[index] ?? 0);\\n        }\\n        return distances;\\n    };", "var countPairs = function(root, distance) {\\n\\n    ", "var countPairs = function(root, distance) {\\n    var graph = new Map()\\n    var leaves = new Map()\\n    function dfs(root, parent) {\\n        if (!root) return \\n        if (!root.left && !root.right) {\\n            leaves.set(root, true)\\n        }\\n\\n        graph.set(root, [])\\n        if (root.left) {\\n            graph.get(root).push(root.left)\\n        }\\n        if (root.right) {\\n            graph.get(root).push(root.right)\\n        }\\n        if (parent) {\\n            graph.get(root).push(parent)\\n        }\\n        dfs(root.left, root)\\n        dfs(root.right, root)\\n    }  \\n\\n    dfs(root, null)\\n\\n    var visited = new Map()\\n    var count = 0\\n\\n    function bfs(start, dis) {\\n        visited.set(start, true)\\n        var queue = [graph.get(start).filter(node => !visited.has(node))]\\n\\n        var innerVisited = new Map()\\n\\n        while (queue.length) {\\n            var curLevelNodes = queue.shift()\\n\\n            if (!curLevelNodes.length) break\\n            if (dis === 0) break\\n\\n            var nextLevelNodes = []\\n            for (var i = 0; i < curLevelNodes.length; i++) {\\n                var curLevelNode = curLevelNodes[i]\\n\\n                innerVisited.set(curLevelNode, true)\\n\\n                if (leaves.has(curLevelNode)) {\\n                    count++\\n                }\\n\\n                nextLevelNodes.push(\\n                    ...graph\\n                        .get(curLevelNode)\\n                        .filter(node => \\n                            !visited.has(node) && \\n                            !innerVisited.has(node)\\n                        )\\n                )\\n               \\n            }\\n            queue.push(nextLevelNodes)\\n            dis--\\n        }\\n    }\\n\\n    leaves.forEach((value, leaf) => {\\n        bfs(leaf, distance)\\n    })\\n\\n    return count\\n};"]}
{"id": "1278", "ref_js": ["var getWinner = function(arr, k) {\\n    let winner = arr[0];\\n    let wins = 0;\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        if (winner > arr[i])\\n            wins++;\\n        else {\\n            wins = 1;\\n            winner = arr[i];\\n        }\\n        \\n        if (wins == k)\\n            break;\\n    }\\n    \\n    return winner;\\n};", "var getWinner = function(arr, k) {\\n    let maxElement = arr[0];\\n    let queue = [];\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        maxElement = Math.max(maxElement, arr[i]);\\n        queue.push(arr[i]);\\n    }\\n    \\n    let curr = arr[0];\\n    let winstreak = 0;\\n    \\n    while (queue.length > 0) {\\n        let opponent = queue.shift();\\n        \\n        if (curr > opponent) {\\n            queue.push(opponent);\\n            winstreak++;\\n        } else {\\n            queue.push(curr);\\n            curr = opponent;\\n            winstreak = 1;\\n        }\\n        \\n        if (winstreak === k || curr === maxElement) {\\n            return curr;\\n        }\\n    }\\n    \\n    return -1;\\n};", "var getWinner = function(arr, k) {\\n    let winner = arr[0];\\n    let wins = 0;\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        if (winner > arr[i])\\n            wins++;\\n        else {\\n            wins = 1;\\n            winner = arr[i];\\n        }\\n        \\n        if (wins == k)\\n            break;\\n    }\\n    \\n    return winner;\\n};"]}
{"id": "1279", "ref_js": ["var minSwaps = function(grid) {\\n    const zeros = [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let result = 0;\\n\\n    for (let row = 0; row < m; row++) {\\n        let count = 0;\\n        for (let col = n - 1; col >= 0; col--) {\\n            const value = grid[row][col];\\n\\n            if (value) break;\\n            count += 1;\\n        }\\n        zeros.push(count);\\n    }\\n    for (let row = 0; row < m; row++) {\\n        const target = m - row - 1;\\n        let swapRow = row;\\n\\n        while (swapRow < m && zeros[swapRow] < target) swapRow += 1;\\n        if (swapRow === m) return -1;\\n\\n        for (let index = swapRow; index > row; index--) {\\n            [zeros[index], zeros[index - 1]] = [zeros[index - 1], zeros[index]];\\n            result += 1;\\n        }\\n    }\\n    return result;\\n};", "var minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    function swap(i, j) {\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        count++;\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        ", "var minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    function swap(i, j) {\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        count++;\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        "]}
{"id": "1280", "ref_js": ["var canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};", "var canConvertString = function(s, t, k) {\\n    if (s === t)    return true;\\n    if (s.length !== t.length)  return false;\\n    \\n    if (k > 26*s.length)    return true;\\n    if (k < s.length)   return false;\\n    \\n    const usedSteps = new Array(27).fill(0);\\n    let steps;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        steps = t.charCodeAt(i) - s.charCodeAt(i);\\n        \\n        if (steps == 0)    continue;\\n        \\n\\t\\t", "var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            "]}
{"id": "1281", "ref_js": ["var minInsertions = function(s) {\\n    let res = 0\\n    let countLeft = 0 \\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            countLeft++\\n        } else {\\n            if (s[i+1] !== \\')\\') {\\n                res++\\n            } else {\\n                i = i + 1\\n            }\\n\\n            if (!countLeft) {\\n                res++\\n            } else {\\n                countLeft--\\n            }\\n        }\\n    }\\n\\n    res += countLeft * 2\\n    return res\\n};", "var minInsertions = function(s) {\\n  let opens = 0;\\n  let edits = 0;\\n\\n  for(let i = 0; i < s.length; i++) {\\n    if(s[i] === \\'(\\') {\\n      opens++;\\n    } else {\\n        if(i + 1 <= s.length - 1 && s[i+1] === \\')\\' ) {\\n          if(opens > 0)  {\\n            opens--;\\n          } else {\\n            edits++;\\n          }\\n          i++;\\n        } else {\\n           edits++;\\n           if(opens > 0) {\\n              opens--;\\n           } else {\\n               edits++;\\n           }\\n        }\\n    }\\n  }\\n\\n  return edits + (opens * 2);\\n};", "var minInsertions = function(s) {\\n  let opens = 0;\\n  let edits = 0;\\n\\n  for(let i = 0; i < s.length; i++) {\\n    if(s[i] === \\'(\\') {\\n      opens++;\\n    } else {\\n        if(i + 1 <= s.length - 1 && s[i+1] === \\')\\' ) {\\n          if(opens > 0)  {\\n            opens--;\\n          } else {\\n            edits++;\\n          }\\n          i++;\\n        } else {\\n           edits++;\\n           if(opens > 0) {\\n              opens--;\\n           } else {\\n               edits++;\\n           }\\n        }\\n    }\\n  }\\n\\n  return edits + (opens * 2);\\n};"]}
{"id": "1282", "ref_js": ["var findKthBit = function(n, k) {\\n    return findTheString(n)[k - 1];\\n};", "var findKthBit = function (n, k) {\\n    let arr = new Array(n).fill(\"\");\\n    arr[0] = \"0\"\\n    for (let i = 1; i < n; i++) {\\n        let revInv = Array.from(arr[i - 1]).reverse().map(el => el === \"0\" ? el = 1 : el = 0)\\n        arr[i] = arr[i-1]+\"1\"+revInv.join(\\'\\');\\n    }\\n    return arr[n-1][k-1];\\n};", "var findKthBit = function(n, k) {\\n    return findTheString(n)[k - 1];\\n};"]}
{"id": "1283", "ref_js": ["var maxNonOverlapping = function (a, t) {\\n  let n = a.length;\\n  let count = 0;\\n  let sum = 0;\\n  let previousSums = new Set();\\n  previousSums.add(sum);\\n  for (let R = 0; R < n; R++) {\\n    sum += a[R];\\n    if (previousSums.has(sum - t)) {\\n      count++;\\n      sum = 0;\\n      previousSums = new Set();\\n    }\\n    previousSums.add(sum);\\n  }\\n  return count;\\n};", "var maxNonOverlapping = function(nums, target) {\\n    const prefixSum = new Set([0]);\\n    let current = result = 0;\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        current += nums[index];\\n\\n        if (prefixSum.has(current - target)) {\\n            current = 0;\\n            result += 1;\\n            prefixSum.clear();\\n            prefixSum.add(0);\\n        } \\n        else prefixSum.add(current);\\n    }\\n    return result;\\n};", "var maxNonOverlapping = function(nums, target) {\\n    const seen = new Set();\\n    let total = 0, result = 0;\\n    \\n    for(let n of nums) {\\n        total += n;\\n        \\n        if(total === target || seen.has(total - target)) {\\n            total = 0;\\n            result++;\\n            seen.clear()\\n        } else seen.add(total)\\n    }\\n    return result;\\n};"]}
{"id": "1284", "ref_js": ["var minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};", "var minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};", "var minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};"]}
{"id": "1285", "ref_js": ["var maxDistance = function(position, m) {\\n    position.sort((a,b)=>a-b);\\n    const canPlace=(force,balls)=>{\\n        balls--;\\n        for(let i=0;i<position.length && balls>0;balls--){\\n            let l=i+1,r=position.length-1, lastPlacement=-1;\\n\\n            while(l<=r){\\n                const mid=Math.trunc((l+r)/2);\\n                if(position[mid]-position[i]>=force){\\n                    r=mid-1;\\n                    lastPlacement=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            if(lastPlacement===-1) return false;\\n            i=lastPlacement;\\n        }\\n        return balls===0;\\n    }\\n\\n    let l=1, r=position[position.length-1], ans=-1;\\n    while(l<=r){\\n        const force=Math.trunc((l+r)/2);\\n        if(canPlace(force,m)){\\n            ans=force;\\n            l=force+1;\\n        }else{\\n            r=force-1;\\n        }\\n    }\\n    return ans;\\n   \\n};", "var maxDistance = function(position, m) {\\n    position.sort((a, b) => a - b);\\n    let left = 1;\\n    let right = position.at(-1) - position[0];\\n    const isMaxDistance = (distance) => {\\n        let balls = 1;\\n        let current = 0;\\n\\n        for (let index = 1; index < position.length; index++) {\\n            current += position[index] - position[index - 1];\\n            if (current < distance) continue;\\n            balls += 1;\\n            current = 0;\\n            if (balls === m) return true;\\n        }\\n        return false;\\n    };", "var maxDistance = function(position, m) {\\n    position.sort((a,b)=>a-b);\\n    const canPlace=(force,balls)=>{\\n        balls--;\\n        for(let i=0;i<position.length && balls>0;balls--){\\n            let l=i+1,r=position.length-1, lastPlacement=-1;\\n\\n            while(l<=r){\\n                const mid=Math.trunc((l+r)/2);\\n                if(position[mid]-position[i]>=force){\\n                    r=mid-1;\\n                    lastPlacement=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            if(lastPlacement===-1) return false;\\n            i=lastPlacement;\\n        }\\n        return balls===0;\\n    }\\n\\n    let l=1, r=position[position.length-1], ans=-1;\\n    while(l<=r){\\n        const force=Math.trunc((l+r)/2);\\n        if(canPlace(force,m)){\\n            ans=force;\\n            l=force+1;\\n        }else{\\n            r=force-1;\\n        }\\n    }\\n    return ans;\\n   \\n};"]}
{"id": "1286", "ref_js": ["var findSmallestSetOfVertices = function(n, edges) {\\n    ", "var findSmallestSetOfVertices = function(n, edges) {\\n    const degree = Array(n).fill(0);\\n    const output = [];\\n    edges.forEach(([u, v]) => degree[v]++);\\n    degree.forEach((deg, i) => !deg && output.push(i));\\n    return output;\\n};", "var findSmallestSetOfVertices = function(n, edges) {\\n    "]}
{"id": "1287", "ref_js": ["var minOperations = function(nums) {\\n    let ops_count = 0\\n    is_done = false\\n    while (is_done === false) {\\n        let decrement_ops = decrement_odd_nums(nums)\\n        is_done = halve_nums(nums)\\n        ops_count += decrement_ops\\n        if (!is_done) {\\n            ops_count ++\\n        }\\n    }\\n    return ops_count\\n};", "var minOperations = function (a) {\\n  let maxDivisions = 0;\\n  let sumSubtractions = 0;\\n  for (let num of a) {\\n    let e = num;\\n    let divisions = 0;\\n    let subtractions = 0;\\n    while (e) {\\n      subtractions += e & 1; ", "var minOperations = function(nums) {\\n    let maxDouble = result = 0;\\n\\n    for (let num of nums) {\\n        let double = 0;\\n\\n        while (num) {\\n            if (num % 2) {\\n                num -= 1;\\n                result += 1;\\n            } else {\\n                num /= 2;\\n                double += 1;\\n            }\\n        }\\n        maxDouble = Math.max(double, maxDouble);\\n    }\\n    return result + maxDouble;\\n};"]}
{"id": "1288", "ref_js": ["var containsCycle = function(grid) {\\n    const visited = new Set();\\n\\n    for(let row =0; row < grid.length; row++) {\\n        for(let col =0; col < grid[0].length; col++) {\\n            if(!visited.has(row + \",\" + col) && bfs(grid, row, col, visited)) {\\n                return true;\\n            }\\n        }   \\n    }\\n    return false;\\n};", "var containsCycle = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = [...Array(m)].map(i => Array(n).fill(0));\\n    const dir = [[-1,0],[1,0],[0,-1],[0,1]];\\n    \\n    const dfs = (x,y,lx,ly) => {        \\n        visited[x][y] = 1;\\n        for (const [a, b] of dir) {\\n            const nx = x + a;\\n            const ny = y + b;\\n            \\n            if (nx < 0 || nx > m - 1 || ny < 0 || ny > n - 1)\\n                continue;\\n            \\n            if (visited[nx][ny] === 1 && (nx !== lx || ny !== ly) && grid[x][y] === grid[nx][ny]) { ", "var containsCycle = function(grid) {\\n\\n    const visited=new Set();    \\n    const dirs=[[0,1],[1,0],[-1,0],[0,-1]];\\n    const dfs=(pr,pc,r,c,parent,path,seen)=>{\\n        const key = `${r}_${c}`;\\n        if(!(pr===r && pc===c) && path.has(key) && grid[r][c]===parent && path.size>=4) return true;\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[r].length || (pr===r && pc===c) || grid[r][c]!==parent || path.has(key)) return false;\\n\\n        seen.add(key);\\n        path.add(key);\\n        for(const [rr,cc] of dirs){\\n            const nextR=rr+r, nextC=cc+c;\\n            if(!(nextR===pr && nextC===pc) && dfs(r,c,nextR, nextC,parent,path,seen)) return true;\\n        }\\n        path.delete(key);\\n        return false;\\n    }\\n\\n    for(let r=0;r<grid.length;r++){\\n        for(let c=0;c<grid[r].length;c++){\\n            if(!visited.has(`${r}_${c}`) && dfs(-1,-1,r,c,grid[r][c],new Set(),visited)){\\n                return true;\\n            }\\n        }    \\n    }\\n    return false;\\n};"]}
{"id": "1289", "ref_js": ["var maxCoins = function(piles) {\\n    piles.sort((a, b) => a - b);\\n    let res = 0;\\n\\n    for (let i = Math.floor(piles.length / 3); i < piles.length; i += 2) {\\n        res += piles[i];\\n    }\\n\\n    return res;    \\n};", "var maxCoins = function(piles) {\\n    piles.sort((a, b) => a - b);\\n    let queue = [];\\n    piles.forEach(num => {\\n        queue.push(num);\\n    });\\n    \\n    let ans = 0;\\n    while (queue.length > 0) {\\n        queue.pop(); ", "var maxCoins = function(piles) {\\n    piles.sort((a, b) => a - b);\\n    let res = 0;\\n\\n    for (let i = Math.floor(piles.length / 3); i < piles.length; i += 2) {\\n        res += piles[i];\\n    }\\n\\n    return res;    \\n};"]}
{"id": "1290", "ref_js": ["var findLatestStep = function(arr, m) {\\n    const size = arr.length;\\n    const sizes = Array(size + 2).fill(0);\\n    const counts = Array(size + 2).fill(0);\\n    let result = -1;\\n\\n    for (let index = 0; index < size; index++) {\\n        const position = arr[index];\\n        const left = sizes[position - 1];\\n        const right = sizes[position + 1];\\n        const length = left + right + 1;\\n\\n        sizes[position] = sizes[position - left] = sizes[position + right] = length;\\n        counts[left] -= 1;\\n        counts[right] -= 1;\\n        counts[length] += 1;\\n        if (counts[m]) result = index + 1;\\n    }\\n    return result;\\n};", "var findLatestStep = function(arr, m) {\\n    const uF = new UnionFind(arr);\\n    const mRecords = new Set(); ", "var findLatestStep = function(arr, m) {\\n    const uF = new UnionFind(arr);\\n    const mRecords = new Set(); "]}
{"id": "1291", "ref_js": ["var getMaxLen = function(nums) {\\n    let max = -Infinity;\\n    let l = 0;\\n    let product = 1n; ", "var getMaxLen = function(nums) {\\n  let maxLen = 0, startNeg = -1, startPos = -1, running = 1;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    const num = nums[i];\\n    \\n    if (!num) {\\n      startNeg = -1, startPos = -1, running = 1;\\n      continue;\\n    }\\n    \\n    running *= num\\n    \\n    if (num < 0 && startNeg === -1) startNeg = i;\\n    if (num > 0 && startPos === -1) startPos = i;\\n    \\n    if (running > 0) {\\n      maxLen = Math.max(maxLen, \\n                startPos === -1 ? -Infinity : i - startPos + 1, \\n                startNeg === -1 ? -Infinity : i - startNeg + 1)\\n    } else if (startNeg !== -1) maxLen = Math.max(maxLen, i - startNeg)\\n  }\\n  return maxLen\\n};", "var getMaxLen = function(nums) {\\n    \\n  const dfs=(i, j, pos , dp)=>{\\n      if(j===nums.length) return pos?j-i:0;\\n      let ans=0;\\n      \\n      let key = `${i} ${j}`;\\n      if(dp[key]!==undefined) return dp[key];\\n\\n      if((pos && nums[j]>0) || (!pos && nums[j]<0)){\\n        ans=j-i+1; "]}
{"id": "1292", "ref_js": ["var numWays = function(s) {\\n    const mod = 1e9+7; \\n    let n = s.length, sum=0;\\n    for(let i=0;i<n;i++){\\n        sum+=s[i]-\\'0\\';\\n    }\\n    if(sum%3!=0){\\n        return 0;\\n    }\\n    sum=sum/3;\\n\\n    if(sum==0){\\n        return (((n-2)*(n-1))/2)%mod;\\n    }\\n\\n    let si=0, c1=0, c2=0;\\n    for(let i=0;i<n;i++){\\n        si+=s[i]-\\'0\\';\\n        if(si==sum)\\n            c1++;\\n        if(si==2*sum)\\n            c2++;\\n    }\\n    return (c1*c2)%mod;\\n};", "var numWays = function(s) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = s.length;\\n    let count = 0;\\n\\n    for (const char of s) {\\n        if (char === \\'1\\') count += 1;\\n    }\\n    if (count % 3) return 0;\\n    if (!count) return (size - 1) * (size - 2) / 2 % MODULO;\\n    let left = right = current = 0;\\n\\n    count /= 3;\\n\\n    for (const char of s) {\\n        if (char === \\'1\\') current += 1;\\n        if (current === count) left += 1;\\n        if (current === count * 2) right += 1;\\n    }\\n    return left * right % MODULO;\\n};", "var numWays = function(s) {\\n    const numberOfOnes = s.replace(/0/g, \\'\\').length;\\n    \\n    if(numberOfOnes%3) return 0;\\n\\n    const n = s.length, mod = 10**9 + 7;\\n    \\t\\n\\t"]}
{"id": "1293", "ref_js": ["var findLengthOfShortestSubarray = function(arr) {\\n    const size = arr.length;\\n    let right = size - 1;\\n\\n    while (right > 0 && arr[right - 1] <= arr[right]) right -= 1;\\n    if (right === 0) return 0;\\n    let result = right;\\n\\n    for (let index = 0; index < size; index++) {\\n        if (arr[index - 1] > arr[index]) break;\\n        while (arr[index] > arr[right]) right += 1;\\n        result = Math.min(result, right - index - 1)\\n    }\\n    return result;\\n};", "var findLengthOfShortestSubarray = function(arr) {\\n    let n = arr.length;\\n    let start = 0;\\n    let end = n - 1;\\n    ", "var findLengthOfShortestSubarray = function(arr) {\\n    let left = 0, pos = [];\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        if (arr[i-1] > arr[i]) {\\n            if (pos.length == 2) {\\n                pos.pop();\\n            }\\n            pos.push([left, i-1]);\\n            left = i;\\n        }\\n    }\\n    if (pos.length == 2)\\n        pos.pop();\\n    pos.push([left, arr.length-1]);\\n    \\n    if (pos.length < 2)\\n        return 0;\\n    \\n    let res = arr.length;\\n    let i = 0, j = pos[1][0];\\n    \\n    while (i <= pos[0][1] && j <= pos[1][1]) {\\n        console.log(arr[i], arr[j], res)\\n        if (arr[i] > arr[j]) {\\n            res = Math.min(res, j - pos[1][0] + pos[0][1] - i + 1);\\n            j++;\\n        } else {\\n            i++;\\n        }\\n    }\\n    \\n    res = Math.min(res, j - pos[1][0]);\\n    \\n    return res + (pos[1][0]-1) - (pos[0][1]+1) + 1;\\n};"]}
{"id": "1294", "ref_js": ["var numTriplets = function(nums1, nums2) {\\n  return getTriplets(nums1, nums2) + getTriplets(nums2, nums1);\\n  \\n  function getTriplets(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i], map = new Map();\\n      for (let j = 0; j < nums2.length; j++) {\\n        ans += map.get(target / nums2[j]) || 0;\\n        map.set(nums2[j], (map.get(nums2[j]) || 0) + 1);\\n      }\\n    }\\n    return ans;\\n  }\\n};", "var numTriplets = function(nums1, nums2) {\\n    const triplets = (numsA, numsB) => {\\n        const squareMap = numsA.reduce((map, num) => {\\n            const square = num ** 2;\\n            const count = map.get(square) ?? 0;\\n\\n            return map.set(square, count + 1);\\n        }, new Map());\\n        let result = 0;\\n\\n        for (let a = 0; a < numsB.length; a++) {\\n            for (let b = a - 1; b >= 0; b--) {\\n                const product = numsB[a] * numsB[b];\\n                if (!squareMap.has(product)) continue;\\n                result += squareMap.get(product);\\n            }\\n        }\\n        return result;\\n    };", "var numTriplets = function(nums1, nums2) {\\n  var res = 0\\n  nums1.sort((a, b) => a - b < 0 ? -1 : 1)\\n  nums2.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n  function process(nums1, nums2) {\\n    var len1 = nums1.length\\n    var len2 = nums2.length\\n    for (var i = 0; i < len1; i++) {\\n      var leftPointer = 0\\n      var RightPointer = len2 - 1\\n      var cur = nums1[i]\\n      var curSqr = Math.pow(cur, 2)\\n\\n      while (leftPointer < RightPointer) {\\n        var curMul = nums2[leftPointer] * nums2[RightPointer]\\n        if (curMul > curSqr) {\\n          RightPointer--\\n        } else if (curMul < curSqr) {\\n          leftPointer++\\n        } else {\\n          if (nums2[leftPointer] === nums2[RightPointer]) {\\n            let len = RightPointer - leftPointer + 1\\n            res += (len * (len - 1)) / 2\\n            break\\n          } else {\\n            let right = nums2[RightPointer]\\n            let left = nums2[leftPointer]\\n            let leftSameCount = 0\\n            let rightSameCount = 0\\n            while (right === nums2[RightPointer]) {\\n              RightPointer--\\n              rightSameCount++\\n            }\\n            while (left === nums2[leftPointer]) {\\n              leftPointer++\\n              leftSameCount++\\n            }\\n            res += leftSameCount * rightSameCount\\n          }\\n        }\\n      }\\n    }\\n  }  \\n\\n  process(nums1, nums2)\\n  process(nums2, nums1)\\n\\n  return res\\n};"]}
{"id": "1295", "ref_js": ["var minCost = function(colors, neededTime) {\\n    let minTime = 0;\\n    \\n    for(let i=0; i<colors.length-1; i++){\\n        if(colors[i] == colors[i+1]){\\n            let currMax = neededTime[i];\\n            let minSum = neededTime[i];\\n            while(i+1<colors.length && colors[i] == colors[i+1]){\\n                minSum += neededTime[i+1];\\n                currMax = Math.max(currMax, neededTime[i+1]);\\n                i++;\\n            }\\n            minSum -= currMax;\\n            minTime += minSum;\\n        }\\n    }\\n    \\n    return minTime;\\n};", "var minCost = function(colors, neededTime) {\\n    let output = 0;\\n    let currentCursor = 0;\\n    for (let i = 1; i < colors.length; i++) {\\n        if (colors[i] === colors[currentCursor]) {\\n            if (neededTime[i] > neededTime[currentCursor]) {\\n                output += neededTime[currentCursor];\\n                currentCursor = i;\\n            } else {\\n                output += neededTime[i];\\n            }\\n        } else {\\n            currentCursor = i;\\n        }\\n    }\\n    \\n    return output;\\n};", "var minCost = function(colors, neededTime) {\\n    let minTime = 0;\\n    \\n    for(let i=0; i<colors.length-1; i++){\\n        if(colors[i] == colors[i+1]){\\n            let currMax = neededTime[i];\\n            let minSum = neededTime[i];\\n            while(i+1<colors.length && colors[i] == colors[i+1]){\\n                minSum += neededTime[i+1];\\n                currMax = Math.max(currMax, neededTime[i+1]);\\n                i++;\\n            }\\n            minSum -= currMax;\\n            minTime += minSum;\\n        }\\n    }\\n    \\n    return minTime;\\n};"]}
{"id": "1296", "ref_js": ["var unhappyFriends = function(n, preferences, pairs) {\\n    let happyMap = new Array(n);\\n    for (let [i, j] of pairs) {\\n        happyMap[i] = preferences[i].indexOf(j);\\n        happyMap[j] = preferences[j].indexOf(i);\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < happyMap[i]; j++) {\\n            let partner = preferences[i][j];\\n            if (preferences[partner].indexOf(i) < happyMap[partner]) {\\n                unhappy++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};", "var unhappyFriends = function(n, preferences, pairs) {\\n let preferenceMap = new Map();\\n  for (let person = 0; person < n; person++) {\\n    let personPrefTable = preferences[person];\\n    let partner;\\n    for (let pairIndex = 0; pairIndex < pairs.length; pairIndex++) {\\n      let singlePair = pairs[pairIndex];\\n      if (singlePair.includes(person)) {\\n        for (let index = 0; index < singlePair.length; index++) {\\n          if (singlePair[index] !== person) {\\n            partner = singlePair[index];\\n            break;\\n          }\\n        }\\n      }\\n    }", "var unhappyFriends = function(n, preferences, pairs) {\\n    const preferencesMap = pairs.reduce((map, [x, y]) => {\\n        map.set(x, preferences[x].indexOf(y));\\n        map.set(y, preferences[y].indexOf(x));\\n        return map;\\n    }, new Map());\\n    let result = 0;\\n\\n    for (let friend = 0; friend < n; friend++) {\\n        const preference = preferencesMap.get(friend);\\n\\n        for (let index = 0; index < preference; index++) {\\n            const partner = preferences[friend][index];\\n\\n            if (preferences[partner].indexOf(friend) < preferencesMap.get(partner)) {\\n                result += 1;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1297", "ref_js": ["var minCostConnectPoints = function(points) {\\n    const n = points.length;\\n    let minCost = 0;\\n    const visited = new Array(n).fill(false);\\n    const distances = new Array(n).fill(Infinity);\\n\\n    distances[0] = 0;  ", "var minCostConnectPoints = function(points) {\\n    const n = points.length;\\n    let minCost = 0;\\n    const visited = new Array(n).fill(false);\\n    const distances = new Array(n).fill(Infinity);\\n\\n    distances[0] = 0;  ", "var minCostConnectPoints = function(points) {\\n    const n = points.length;\\n    let minCost = 0;\\n    const visited = new Array(n).fill(false);\\n    const distances = new Array(n).fill(Infinity);\\n\\n    distances[0] = 0;  "]}
{"id": "1298", "ref_js": ["var maxSumRangeQuery = function (nums, requests) {\\n  const MOD = 10 ** 9 + 7;\\n  let n = nums.length;\\n\\n  let coeffs = getRangeCoeffs(n, requests);\\n\\n  coeffs.sort((a, b) => b - a);\\n  nums.sort((a, b) => b - a);\\n\\n  let sum = 0;\\n  for (let i = 0; i < n; i++) {\\n    sum += (coeffs[i] * nums[i]) % MOD;\\n    sum %= MOD;\\n  }\\n  return sum;\\n};", "var maxSumRangeQuery = function(nums, requests) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = nums.length;\\n    const frequency = Array(size).fill(0);\\n\\n    for (const [start, end] of requests) {\\n        frequency[start] += 1;\\n        if (end + 1 === size) continue;\\n        frequency[end + 1] -= 1;\\n    }\\n    for (let index = 1; index < size; index++) {\\n        frequency[index] += frequency[index - 1];\\n    }\\n    frequency.sort((a, b) => a - b);\\n    nums.sort((a, b) => a - b);\\n\\n    return nums.reduce((result, num, index) => {\\n        return (result + num * frequency[index]) % MODULO;\\n    }, 0);\\n};", "var maxSumRangeQuery = function(nums, requests) {\\n    const duplicated = new Array(nums.length).fill(0)\\n    for(let i = 0; i < requests.length ; i++){\\n        const [ start, end ] = requests[i]\\n        duplicated[start] += 1\\n        if(end !== nums.length -1){\\n            duplicated[end+1] -=1\\n        }\\n    }\\n    const values = []\\n    let sum = 0;\\n    for(let i = 0; i < duplicated.length; i++){\\n        sum += duplicated[i]\\n        values[i] = sum\\n    }\\n    let result = 0\\n    nums.sort((a,b)=> { return a < b ? 1 : -1 })\\n    values.sort((a,b)=> { return a < b ? 1 : -1 })\\n    console.log(values)\\n\\n    for(let i = 0; i < values.length; i++){\\n        result = result + (values[i] * nums[i])\\n    }\\n    return result % 1000000007\\n\\n};"]}
{"id": "1299", "ref_js": ["var minSubarray = function(nums, p) {\\n    let n = nums.length;\\n    let map = new Map([[0,-1]])\\n    let total = 0, res = n, sum = 0\\n    for(let i=0; i<n; i++){\\n        total += nums[i]\\n    }\\n    total = total % p\\n    \\n    for(let i=0; i<n; i++){\\n        sum = (sum + nums[i]) % p\\n        map.set(sum, i)\\n        let prevSum = mod(sum-total,p)\\n        if(map.has(prevSum)){\\n            res = Math.min(res, i-map.get(prevSum))\\n        }\\n    }\\n\\n    return res == nums.length ? -1 : res\\n};", "var minSubarray = function(nums, p) {\\n    const sum = nums.reduce((result, num) => result + num);\\n    const remainder = sum % p;\\n\\n    if (remainder === 0) return 0;\\n    const size = nums.length;\\n    const prefixSumMap = new Map([[0, -1]]);\\n    let currentSum = 0;\\n    let result = size;\\n\\n    for (let index = 0; index < size; index++) {\\n        currentSum = (currentSum + nums[index]) % p;\\n        prefixSumMap.set(currentSum, index);\\n        const romveIndex = prefixSumMap.get((currentSum - remainder + p) % p) ?? -size;\\n        \\n        result = Math.min(result, index - romveIndex);\\n    }\\n    return result === size ? -1 : result;\\n};", "var minSubarray = function(nums, p) {\\n    const targetRemainder = nums.reduce((acc, num) => (acc + num) % p, 0);\\n    if (targetRemainder === 0) return 0;\\n\\n    const map = new Map();\\n    let currRemainder = 0;\\n    let minLen = Infinity;\\n    let currLen = 0;\\n\\n    map.set(0, -1);\\n    for (let i = 0; i < nums.length; i++) {\\n        currRemainder = (currRemainder + nums[i]) % p;\\n        const target = (currRemainder - targetRemainder + p) % p;\\n\\n        if (map.has(target)) {\\n            currLen = i - map.get(target);\\n            minLen = Math.min(minLen, currLen);\\n        }\\n\\n        map.set(currRemainder, i);\\n    }\\n\\n    return minLen === Infinity || minLen === nums.length ? -1 : minLen;\\n};"]}
{"id": "1300", "ref_js": ["var maxUniqueSplit = function (s) {\\n    return getMaxUniqueSplit(0, s, new Set());\\n};", "var maxUniqueSplit = function(s) {\\n    \\n    const dfs=(start, set)=>{\\n        if(start===s.length){\\n            return set.size;\\n        }\\n        let subStr=\\'\\', maxSize=0;\\n        for(let i=start;i<s.length;i++){\\n            subStr+=s[i];\\n            if(set.has(subStr)) continue;\\n            set.add(subStr);\\n            maxSize=Math.max(maxSize,dfs(i+1,set));\\n            set.delete(subStr);\\n        }    \\n        return maxSize;\\n    }\\n    \\n    return dfs(0,new Set());\\n};", "var maxUniqueSplit = function(s) {\\n    const size = s.length;\\n    const splitStringSet = new Set();\\n    let result = 0;\\n    const backtrackingUniqueString = (start = 0) => {\\n        if (start === size) {\\n            result = Math.max(splitStringSet.size, result);\\n            return;\\n        }\\n\\n        for (let index = start + 1; index <= size; index++) {\\n            const subString = s.slice(start, index);\\n\\n            if (splitStringSet.has(subString)) continue;\\n            splitStringSet.add(subString);\\n            backtrackingUniqueString(index);\\n            splitStringSet.delete(subString);\\n        }\\n    };"]}
{"id": "1301", "ref_js": ["var maxProductPath = function(grid) {\\n    const MODULO = 10 ** 9 + 7;\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dpMax = Array(m).fill(\\'\\').map(_ => Array(n).fill(0));\\n    const dpMin = Array(m).fill(\\'\\').map(_ => Array(n).fill(0));\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            const value = grid[row][col];\\n            const maxUpValue = dpMax[row - 1]?.[col] * value;\\n            const maxLeftValue = dpMax[row][col - 1] * value;\\n            const minUpValue = dpMin[row - 1]?.[col] * value;\\n            const minLeftValue = dpMin[row][col - 1] * value;\\n\\n            if (row === 0 && col === 0) {\\n                dpMax[row][col] = dpMin[row][col] = grid[0][0];\\n            } else if (row === 0) {\\n                dpMax[row][col] = Math.max(maxLeftValue, minLeftValue);\\n                dpMin[row][col] = Math.min(maxLeftValue, minLeftValue);\\n            } else if (col === 0) {\\n                dpMax[row][col] = Math.max(maxUpValue, minUpValue);\\n                dpMin[row][col] = Math.min(maxUpValue, minUpValue);\\n            } else {\\n                const maxUp = Math.max(maxUpValue, minUpValue);\\n                const maxLeft = Math.max(maxLeftValue, minLeftValue);\\n                const minUp = Math.min(maxUpValue, minUpValue);\\n                const minLeft = Math.min(maxLeftValue, minLeftValue);\\n\\n                dpMax[row][col] = Math.max(maxUp, maxLeft);\\n                dpMin[row][col] = Math.min(minUp, minLeft);\\n            }\\n        }\\n    }\\n    return dpMax[m - 1][n - 1] < 0 ? - 1 : dpMax[m - 1][n - 1] % MODULO;\\n};", "var maxProductPath = function(grid) {\\n    ", "var maxProductPath = function(grid) {\\n    const R = grid.length, C = grid[0].length;\\n    if (R === 0 || C === 0)\\n        return -1;\\n    \\n    const mat = [...Array(R)].map(() => [...Array(C)].map(() => new Array(2)));\\n    \\n    mat[0][0] = [grid[0][0], grid[0][0]];\\n    for (let i = 1; i < R; i++)\\n        mat[i][0] = [mat[i-1][0][0]*grid[i][0], mat[i-1][0][1]*grid[i][0]];\\n    \\n    for (let i = 1; i < C; i++)\\n        mat[0][i] = [mat[0][i-1][0]*grid[0][i], mat[0][i-1][1]*grid[0][i]];\\n    \\n    for (let i = 1; i < R; i++) {\\n        for (let j = 1; j < C; j++) {\\n            const max = Math.max(mat[i-1][j][0], mat[i][j-1][0]),\\n                  min = Math.min(mat[i-1][j][1], mat[i][j-1][1]);\\n            if (grid[i][j] >= 0)\\n                mat[i][j] = [max*grid[i][j], min*grid[i][j]];\\n            else\\n                mat[i][j] = [min*grid[i][j], max*grid[i][j]];\\n        }\\n    }\\n    \\n    return mat[R-1][C-1][0] >= 0 ? mat[R-1][C-1][0] % (10**9+7) : -1;\\n};"]}
{"id": "1302", "ref_js": ["var minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };", "var minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };", "var minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };"]}
{"id": "1304", "ref_js": ["var alertNames = function (keyNames, keyTimes) {\\n  const nameTimesMap = {};", "var alertNames = function(keyName, keyTime) {\\n    const useKeyCardMap = keyName.reduce((map, name, index) => {\\n        const times = map.get(name) ?? [];\\n        const [hour, minute] = keyTime[index].split(\\':\\');\\n\\n        times.push(hour * 60 + +minute);\\n        return map.set(name, times);\\n    }, new Map());\\n    const result = [];\\n\\n    for (const [name, times] of useKeyCardMap) {\\n        if (times.length < 3) continue;\\n        times.sort((a, b) => a - b);\\n\\n        for (let index = 2; index < times.length; index++) {\\n            if (times[index] - times[index - 2] > 60) continue;\\n            result.push(name);\\n            break;\\n        }\\n    }\\n    return result.sort((a, b) => a.localeCompare(b));\\n};", "var alertNames = function (keyNames, keyTimes) {\\n  const nameTimesMap = {};"]}
{"id": "1305", "ref_js": ["var restoreMatrix = function(rowSum, colSum) {\\n    const m = rowSum.length;\\n    const n = colSum.length;\\n    const result = Array(m).fill(\\'\\').map(_ => Array(n).fill(0));\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            const min = Math.min(rowSum[row], colSum[col]);\\n\\n            result[row][col] = min;\\n            rowSum[row] -= min;\\n            colSum[col] -= min;\\n        }\\n    }\\n    return result;\\n};", "var restoreMatrix = function(rowSum, colSum) {\\n    let m = rowSum.length\\n    let n = colSum.length\\n    let res = new Array(m)\\n    for (let i = 0; i < m; i++) {\\n        res[i] = new Array(n)\\n    }\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let min = Math.min(rowSum[i], colSum[j])\\n            res[i][j] = min\\n            rowSum[i] -= min\\n            colSum[j] -= min\\n        }\\n    }\\n    return res\\n};", "var restoreMatrix = function(rowSum, colSum) {\\n    \\n    let m = rowSum.length, n = colSum.length\\n    let res = []\\n    \\n    for(let i = 0; i<m; i++){\\n        let row = []\\n        for(let j = 0; j<n; j++){\\n            let minValue = Math.min(rowSum[i], colSum[j])\\n            colSum[j] = colSum[j] - minValue\\n            rowSum[i] = rowSum[i] - minValue\\n            row.push(minValue)\\n        }\\n        res.push(row)\\n    }\\n    \\n    return res\\n    \\n};"]}
{"id": "1306", "ref_js": ["var isEvenOddTree = function(root) {\\n    let queue = [root];\\n    let steps = 0;\\n\\n    while(queue.length>0){\\n        const currLength = queue.length;\\n        let nextQueue=[];\\n\\n        for(let i=0; i<currLength;i++){\\n            const node = queue[i];\\n            if(steps%2 !== 0){\\n                if((i<currLength-1 && node.val<=queue[i+1].val) || node.val%2 !== 0){\\n                    return false;\\n                }\\n            }else if((i<currLength-1 && node.val>=queue[i+1].val)|| node.val%2 === 0){\\n                return false;\\n            }\\n            if(node.left) nextQueue.push(node.left);\\n            if(node.right) nextQueue.push(node.right);\\n        }\\n        queue = nextQueue;\\n        steps++;\\n    }\\n\\n    return true;\\n};", "var isEvenOddTree = function(root) {\\n    let queue = [root];\\n    let lvl = 0;\\n    const isValid =(isEven, val, prev) => {\\n        if(isEven && val % 2 === 1 && (prev === null || (prev < val))) return true;\\n        if(!isEven && val % 2 === 0 && (prev === null || (prev > val))) return true;\\n        return false;\\n    }\\n    while(queue.length) {\\n        const lvlSize = queue.length;\\n        const lvlQueue = [];\\n        let prev = null;\\n        const isEven = lvl % 2 === 0;\\n        for(let i=0;i<lvlSize;i++) {\\n            const curr = queue[i];\\n            if(!isValid(isEven, curr.val, prev)) return false;\\n            if(curr.left) lvlQueue.push(curr.left)\\n            if(curr.right) lvlQueue.push(curr.right)\\n            prev = curr.val;\\n        }\\n        ++lvl;\\n        queue = lvlQueue;\\n    }\\n    return true;\\n};", "var isEvenOddTree = function(root) {\\n    const queue = [root];\\n    let currentLevel = \\'even\\';\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n        let previous = 0;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { val, left, right } = queue.shift();\\n            const isOdd = val % 2;\\n\\n            if (currentLevel === \\'even\\') {\\n                if (!isOdd || (previous && previous >= val)) return false;\\n            } else {\\n                if (isOdd || (previous && previous <= val)) return false;\\n            }\\n            previous = val;\\n            left && queue.push(left);\\n            right && queue.push(right);\\n        }\\n        currentLevel = currentLevel === \\'odd\\' ? \\'even\\' : \\'odd\\';\\n    }\\n    return true;\\n};"]}
{"id": "1307", "ref_js": ["var maximalNetworkRank = function(n, roads) {\\n    let graph= Array.from({length:n},()=> Array(n).fill(0));\\n    let degreeCount=Array(n).fill(0);\\n    for(let i of roads){\\n        graph[i[0]][i[1]]=1;\\n        graph[i[1]][i[0]]=1;\\n        degreeCount[i[0]]++;\\n        degreeCount[i[1]]++;\\n    }\\n    let maxi=0;\\n    for(let i=0;i<n;i++){\\n        for(let j=i+1;j<n;j++){\\n           let count=degreeCount[i]+degreeCount[j];\\n           if(graph[i][j]===1) count--;\\n           maxi=Math.max(maxi, count);\\n        }\\n    }\\n    return maxi;\\n\\n};", "var maximalNetworkRank = function(n, roads) {\\n    let degree = new Array(n).fill(0);\\n    let roadSet = new Set();\\n\\n    for (let road of roads) {\\n        degree[road[0]]++;\\n        degree[road[1]]++;\\n        roadSet.add(road[0] + \\',\\' + road[1]);\\n        roadSet.add(road[1] + \\',\\' + road[0]);\\n    }\\n\\n    let maxRank = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i+1; j < n; j++) {\\n            let rank = degree[i] + degree[j];\\n            if (roadSet.has(i + \\',\\' + j)) {\\n                rank--;\\n            }\\n            maxRank = Math.max(maxRank, rank);\\n        }\\n    }\\n\\n    return maxRank;\\n};", "var maximalNetworkRank = function(n, roads) {\\n    "]}
{"id": "1308", "ref_js": ["var checkPalindromeFormation = function(a, b) {\\n    const checkPalindrome = (a, b) => {\\n        let left = 0;\\n        let right = a.length - 1;\\n\\n        while (left < right && a[left] === b[right]) {\\n            left += 1;\\n            right -= 1;\\n        }\\n        return isPalindrome(a, left, right) || isPalindrome(b, left, right)\\n    };", "var checkPalindromeFormation = function(a, b) {\\n    ", "var checkPalindromeFormation = function(a, b) {\\n    const checkPalindrome = (a, b) => {\\n        let left = 0;\\n        let right = a.length - 1;\\n\\n        while (left < right && a[left] === b[right]) {\\n            left += 1;\\n            right -= 1;\\n        }\\n        return isPalindrome(a, left, right) || isPalindrome(b, left, right)\\n    };"]}
{"id": "1309", "ref_js": ["var bestCoordinate = function (towers, radius) {\\n  const distEuclidean = (x1, y1, x2, y2) => Math.hypot(x1 - x2, y1 - y2);\\n  let [maxSum, maxCx, maxCy] = [0, 0, 0];\\n  for (let cx = 0 - radius; cx <= 50 + radius; ++cx) {\\n    for (let cy = 0 - radius; cy <= 50 + radius; ++cy) {\\n      let sum = 0;\\n      for (let [towerX, towerY, towerQualityFactor] of towers) {\\n        let dist = distEuclidean(cx, cy, towerX, towerY);\\n        if (dist <= radius) sum += Math.floor(towerQualityFactor / (1 + dist));\\n      }\\n      if (sum > maxSum) {\\n        [maxSum, maxCx, maxCy] = [sum, cx, cy];\\n      }\\n    }\\n  }\\n  return [maxCx, maxCy];\\n};", "var bestCoordinate = function(towers, radius) {\\n    let boundingBox = findBoundingBox(towers);\\n    let x = boundingBox[0][0];\\n    let maxQual = -1;\\n    let maxPoint = [-1,-1];\\n    while(x <= boundingBox[1][0]){\\n        let y = boundingBox[0][1];\\n        while(y <= boundingBox[1][1]){\\n            let qual = calcQuality(towers,radius,[x,y]);\\n            if(qual > maxQual){\\n                maxQual = qual;\\n                maxPoint = [x,y];\\n            } else if(qual == maxQual){\\n                if(maxPoint[0] > x || (maxPoint[0] == x && maxPoint[1] > y)){\\n                    maxPoint = [x,y];\\n                }\\n            }\\n            y++;\\n        }\\n        x++;\\n    }\\n    return maxPoint;\\n};", "var bestCoordinate = function(towers, radius) {\\n    let result = [0, 0];\\n    let maxX = maxY = 0;\\n    let minX = minY = Number.MAX_SAFE_INTEGER;\\n    let maxQ = 0;\\n\\n    for (const [x, y] of towers) {\\n        maxX = Math.max(x, maxX);\\n        maxY = Math.max(y, maxY);\\n        minX = Math.min(x, minX);\\n        minY = Math.min(y, minY);\\n    }\\n\\n    for (let x = minX; x <= maxX; x++) {\\n        for (let y = minY; y <= maxY; y++) {\\n            let quality = 0;\\n\\n            for (const [a, b, q] of towers) {\\n                const distance = Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));\\n\\n                if (distance > radius) continue;\\n                quality += Math.floor(q / (1 + distance));\\n            };"]}
{"id": "1310", "ref_js": ["var numberOfSets = function(n, k) {\\n    return combinations(n+k-1,2*k)%(1e9+7)\\n};", "var numberOfSets = function(n, k) {\\n    const MODULO = 10 ** 9 + 7;\\n    const combinatorics = (n, k) => {\\n        const dp = Array(n + 1).fill(\\'\\').map(_ => Array(k + 1).fill(1));\\n\\n        for (let index = 1; index <= n; index++) {\\n            for (let point = 1; point < index; point++) {\\n                dp[index][point] = (dp[index - 1][point - 1] + dp[index - 1][point]) % MODULO;\\n            }\\n        }\\n        return dp[n][k];\\n    };", "var numberOfSets = function (n, k) {\\n  "]}
{"id": "1311", "ref_js": ["var findLexSmallestString = function(s, a, b) {\\n    ", "var findLexSmallestString = function(s, a, b) {\\n    const visited = new Set();\\n    let result = s;\\n    const add = (value) => {\\n        let result = \\'\\';\\n\\n        for (let index = 0; index < value.length; index++) {\\n            const current = +value[index];\\n\\n            result += index % 2 ? (current + a) % 10 : current;\\n        }\\n        return result;\\n    };", "var findLexSmallestString = function(s, a, b) {\\n    const n = s.length;\\n    const visited = new Set();\\n    const queue = []; \\n   \\n    visited.add(s);\\n    queue.push(s);\\n    \\n    let minNum = s;\\n    \\n    while (queue.length > 0) {\\n        const currNum = queue.shift();\\n\\n        if (currNum < minNum) minNum = currNum;\\n        \\n        const justRotate = rotate(currNum);\\n        const justAdd = add(currNum);\\n\\n        if (!visited.has(justRotate)) {\\n            visited.add(justRotate);\\n            queue.push(justRotate);\\n        }\\n        \\n        if (!visited.has(justAdd)) {\\n            visited.add(justAdd);\\n            queue.push(justAdd);\\n        }\\n    }\\n    \\n    return minNum;\\n    \\n    function rotate(num) {\\n        let rotatedNum = \"\";\\n        const start = n - b;\\n        \\n        for (let i = 0; i < b; i++) {\\n            rotatedNum += num.charAt(start + i);\\n        }\\n        \\n        const restDigs = num.substring(0, n - b);\\n        rotatedNum += restDigs;\\n        \\n        return rotatedNum;\\n    }\\n    \\n    \\n    function add(num) {\\n        let nextNum = \"\";        \\n\\n        for (let i = 0; i < n; i++) {\\n            let currDig = num.charAt(i);\\n            \\n            if (i % 2 == 0) {\\n                nextNum += currDig;\\n            }\\n            else {\\n                let newDig = (parseInt(currDig) + a) % 10;\\n                nextNum += newDig;\\n            }\\n        }\\n        \\n        return nextNum;\\n    }\\n};"]}
{"id": "1312", "ref_js": ["var bestTeamScore = function(scores, ages) {\\n    let arr = []\\n    for(let i =0; i<scores.length;i++){\\n        arr.push([ages[i],scores[i]])\\n    }\\n    arr.sort((a,b)=>a[0]==b[0] ? a[1] - b[1] : a[0] - b[0])\\n    \\n    let res = new Array(scores.length).fill(0);\\n    res[0] = arr[0][1];\\n\\n    for(let i = 1; i<arr.length; i++){\\n        let [fa , fs] = arr[i]\\n        res[i] = fs;\\n        for(let j =i-1; j>=0; j--){\\n            let [sa, ss] = arr[j]\\n            if(sa == fa) res[i] = Math.max(res[i], res[j] + fs);\\n            else{\\n                if(fs >= ss ){\\n                    res[i] = Math.max(res[i], res[j] + fs);\\n                }\\n            }\\n        }\\n    }\\n    return Math.max(...res)\\n};", "var bestTeamScore = function(scores, ages) {\\n    let len = scores.length;\\n    let arr = scores.map((a,key) => [a, ages[key]]);\\n    arr.sort((a,b) => {\\n        if(a[1] != b[1]) return a[1] - b[1];\\n        return a[0] - b[0]\\n    });\\n    let dp = Array(len).fill(0);\\n    for(let i =0; i<len; i++){\\n        for(let j =0; j<len; j++){\\n            if(arr[j][0] <= arr[i][0]) dp[i] = Math.max(dp[i], dp[j]);\\n            \\n        }\\n        dp[i] +=  arr[i][0];\\n    }\\n    return Math.max(...dp);\\n};", "var bestTeamScore = function(scores, ages) {\\n    let arr = []\\n    for(let i =0; i<scores.length;i++){\\n        arr.push([ages[i],scores[i]])\\n    }\\n    arr.sort((a,b)=>a[0]==b[0] ? a[1] - b[1] : a[0] - b[0])\\n    \\n    let res = new Array(scores.length).fill(0);\\n    res[0] = arr[0][1];\\n\\n    for(let i = 1; i<arr.length; i++){\\n        let [fa , fs] = arr[i]\\n        res[i] = fs;\\n        for(let j =i-1; j>=0; j--){\\n            let [sa, ss] = arr[j]\\n            if(sa == fa) res[i] = Math.max(res[i], res[j] + fs);\\n            else{\\n                if(fs >= ss ){\\n                    res[i] = Math.max(res[i], res[j] + fs);\\n                }\\n            }\\n        }\\n    }\\n    return Math.max(...res)\\n};"]}
{"id": "1313", "ref_js": ["var checkArithmeticSubarrays = function(nums, l, r) {\\n    function isArithmetic(sub) {\\n        sub.sort((a, b) => a - b);\\n        const diff = sub[1] - sub[0];\\n        for (let i = 2; i < sub.length; i++) {\\n            if (sub[i] - sub[i - 1] !== diff) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const res = [];\\n    for (let q = 0; q < l.length; q++) {\\n        res.push(isArithmetic(nums.slice(l[q], r[q] + 1)));\\n    }\\n    return res;    \\n};", "var checkArithmeticSubarrays = function(nums, l, r) {\\n    function isArithmetic(sub) {\\n        sub.sort((a, b) => a - b);\\n        const diff = sub[1] - sub[0];\\n        for (let i = 2; i < sub.length; i++) {\\n            if (sub[i] - sub[i - 1] !== diff) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const res = [];\\n    for (let q = 0; q < l.length; q++) {\\n        res.push(isArithmetic(nums.slice(l[q], r[q] + 1)));\\n    }\\n    return res;    \\n};", "var checkArithmeticSubarrays = function(nums, l, r) {\\n    function isArithmetic(sub) {\\n        sub.sort((a, b) => a - b);\\n        const diff = sub[1] - sub[0];\\n        for (let i = 2; i < sub.length; i++) {\\n            if (sub[i] - sub[i - 1] !== diff) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const res = [];\\n    for (let q = 0; q < l.length; q++) {\\n        res.push(isArithmetic(nums.slice(l[q], r[q] + 1)));\\n    }\\n    return res;    \\n};"]}
{"id": "1314", "ref_js": ["var minimumEffortPath = function(heights) {\\r\\n    const rows = heights.length, cols = heights[0].length;\\r\\n    const curEffort = Array.from(Array(rows), () => Array(cols).fill(Infinity));\\r\\n    const minHeap = [[0, 0, 0]];  ", "var minimumEffortPath = function(heights) {\\r\\n    const rows = heights.length, cols = heights[0].length;\\r\\n    const dist = Array.from(Array(rows), () => Array(cols).fill(Infinity));\\r\\n    const minHeap = [[0, 0, 0]];  ", "var minimumEffortPath = function(heights) {\\r\\n    const m = heights.length, n = heights[0].length;\\r\\n    const vis = Array.from({ length: m }, () => {\\r\\n        return new Array(n).fill(false);\\r\\n    });\\r\\n    const heap = new MinPriorityQueue({\\r\\n        priority: x => x[0]\\r\\n    });\\r\\n    heap.enqueue([0, 0, 0]);\\r\\n    \\r\\n    const dir = [0, 1, 0, -1, 0];\\r\\n        \\r\\n    while(heap.size()) {\\r\\n        const [max, x, y] = heap.dequeue().element;\\r\\n        \\r\\n        if(x == m - 1 && y == n - 1) return max;\\r\\n        \\r\\n        if(vis[x][y]) continue;\\r\\n        vis[x][y] = true;\\r\\n        \\r\\n        for(let i = 1; i <= 4; i++) {\\r\\n            let a = x + dir[i], b = y + dir[i-1];\\r\\n            if(a >= 0 && b >= 0 && a < m && b < n) {\\r\\n                heap.enqueue([\\r\\n                    Math.max(Math.abs(heights[x][y] - heights[a][b]), max),\\r\\n                    a,\\r\\n                    b\\r\\n                ]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};"]}
{"id": "1315", "ref_js": ["var maxWidthOfVerticalArea = function(points) {\\n    const xSorted = points.map(([x, _]) => x).sort((a, b) => a - b);\\n\\n    let maxWidth = 0;\\n    for (let i = 0; i < xSorted.length - 1; i++) {\\n        maxWidth = Math.max(maxWidth, xSorted[i + 1] - xSorted[i]);\\n    }\\n\\n    return maxWidth;    \\n};", "var maxWidthOfVerticalArea = function(points) {\\n    points.sort((a, b) => a[0] - b[0]);\\n    let diff = 0;\\n    for (let i = 1; i < points.length; i++) {\\n        diff = Math.max(diff, points[i][0] - points[i - 1][0]);\\n    }\\n    return diff;\\n};", "var maxWidthOfVerticalArea = function(points) {\\n    points.sort((a, b) => a[0] - b[0]);\\n\\n    let maxWidth = 0;\\n\\n    for (let i = 1; i < points.length; i++) {\\n        let width = points[i][0] - points[i - 1][0];\\n        maxWidth = Math.max(maxWidth, width);\\n    }\\n\\n    return maxWidth;\\n};"]}
{"id": "1316", "ref_js": ["var countSubstrings = function(s, t) {\\n    const m = s.length;\\n    const n = t.length;\\n    let result = 0;\\n\\n    const checkSubstring = (a, b) => {\\n        let current = previous = 0;\\n\\n        while (a < m && b < n) {\\n            current += 1;\\n\\n            if (s[a] !== t[b]) {\\n               previous = current;\\n               current = 0;\\n            }\\n            result += previous;\\n            a += 1;\\n            b += 1;\\n        }\\n    };", "var countSubstrings = function(s, t) {\\n    const sLen = s.length, tLen = t.length;\\n    const leftSame = Array.from({ length: sLen + 1 }, () => Array(tLen + 1).fill(0));\\n    const rightSame = Array.from({ length: sLen + 1 }, () => Array(tLen + 1).fill(0));\\n    let count = 0;\\n\\n    for (let i = 1; i <= sLen; i++)\\n        for (let j = 1; j <= tLen; j++)\\n            s[i - 1] == t[j - 1] && (leftSame[i][j] = leftSame[i - 1][j - 1] + 1);\\n\\n    for (let i = sLen - 1; i >= 0; i--)\\n        for (let j = tLen - 1; j >= 0; j--)\\n            s[i] == t[j] && (rightSame[i][j] = rightSame[i + 1][j + 1] + 1);\\n\\n    for (let i = 0; i < sLen; i++) {\\n        for (let j = 0; j < tLen; j++) {\\n            if (s[i] == t[j]) continue;\\n            count += (leftSame[i][j] + 1) * (rightSame[i + 1][j + 1] + 1);\\n        }\\n    }\\n\\n    return count;\\n};", "var countSubstrings = function(s, t) {\\n    const sLen = s.length, tLen = t.length;\\n    const leftSame = Array.from({ length: sLen + 1 }, () => Array(tLen + 1).fill(0));\\n    const rightSame = Array.from({ length: sLen + 1 }, () => Array(tLen + 1).fill(0));\\n    let count = 0;\\n\\n    for (let i = 1; i <= sLen; i++)\\n        for (let j = 1; j <= tLen; j++)\\n            s[i - 1] == t[j - 1] && (leftSame[i][j] = leftSame[i - 1][j - 1] + 1);\\n\\n    for (let i = sLen - 1; i >= 0; i--)\\n        for (let j = tLen - 1; j >= 0; j--)\\n            s[i] == t[j] && (rightSame[i][j] = rightSame[i + 1][j + 1] + 1);\\n\\n    for (let i = 0; i < sLen; i++) {\\n        for (let j = 0; j < tLen; j++) {\\n            if (s[i] == t[j]) continue;\\n            count += (leftSame[i][j] + 1) * (rightSame[i + 1][j + 1] + 1);\\n        }\\n    }\\n\\n    return count;\\n};"]}
{"id": "1317", "ref_js": ["var countVowelStrings = function(n) {\\n\\nconst base = {0: [0], 1: [5], 2: [1, 2, 3, 4, 5]};", "var countVowelStrings = function(n) {\\n    let a=1, e=1, i=1, o=1, u=1\\n    while(n-- > 1){\\n        a = a + e + i + o + u\\n        e = e + i + o + u\\n        i = i + o + u\\n        o = o + u\\n        u = u\\n    }\\n    return a + e + i + o + u\\n};", "var countVowelStrings = function(n) {\\n    \\n    const vowels = \"aeiou\";\\n    \\n    function backtrack(index=0,strLength=0,memo={}){\\n        \\n        const key = index+\"_\"+strLength;\\n        \\n        if(memo[key])\\n            return memo[key];\\n\\n        if(strLength === n){\\n            return 1;\\n        }\\n        \\n        if(strLength > n)\\n            return 0;\\n        \\n        let alls = 0;\\n        for(let i=index; i<5; i++){\\n           alls += backtrack(i, strLength+1, memo);\\n        }\\n        \\n        memo[key] = alls;\\n        \\n        return alls;\\n        \\n    }\\n    \\n    return backtrack();\\n};"]}
{"id": "1318", "ref_js": ["var furthestBuilding = function(H, B, L) {\\n    let len = H.length - 1,\\n        pq = new MinPriorityQueue({priority: x => x})\\n    for (let i = 0; i < len; i++) {\\n        let diff = H[i+1] - H[i]\\n        if (diff > 0) {\\n            if (L > 0) pq.enqueue(diff), L--\\n            else if (pq.front() && diff > pq.front().element)\\n                pq.enqueue(diff), B -= pq.dequeue().element\\n            else B -= diff\\n            if (B < 0) return i\\n        }\\n    }\\n    return len\\n};", "var furthestBuilding = function(heights, bricks, ladders) {\\n    const heap = new MaxPriorityQueue({priority: x => x});\\n    \\n    let i;\\n    \\n    for(i = 0; i < heights.length-1; i++) {\\n        if(heights[i] >= heights[i+1]) continue;\\n        \\n        const diff = heights[i+1] - heights[i];\\n        \\n        ", "var furthestBuilding = function(heights, bricks, ladders) {\\n    let maxReachableIndex = 0;\\n    let bricksCount = bricks;\\n    let laddersCount = ladders;\\n    const maxPriorityQueue = new MaxPriorityQueue();\\n\\n    for (; maxReachableIndex < heights.length - 1; maxReachableIndex++) {\\n        const distance = heights[maxReachableIndex + 1] - heights[maxReachableIndex];\\n        \\n        if (distance <= 0) continue;\\n        \\n        if (distance > bricksCount && !laddersCount) break;\\n\\n        if (distance <= bricksCount) {\\n            bricksCount -= distance;\\n            maxPriorityQueue.enqueue(distance);\\n        } else {\\n            laddersCount--;\\n\\n            if (maxPriorityQueue.isEmpty()) continue;\\n\\n            const { element: bricksUsed } = maxPriorityQueue.front();\\n            if (bricksUsed >= distance) {\\n                maxPriorityQueue.dequeue();\\n                maxPriorityQueue.enqueue(distance);\\n                bricksCount += (bricksUsed - distance);\\n            }\\n        }\\n    }\\n    \\n    return maxReachableIndex;\\n};"]}
{"id": "1319", "ref_js": ["var minDeletions = function(s) {\\n    var countDict = {};", "var minDeletions = function(s) {\\n    const chars = new Map();\\n    for (const char of s) {\\n        chars.set(char, (chars.get(char) || 0) + 1);\\n    }\\n\\n    const freqSet = new Set();\\n    let count = 0;\\n\\n    for (let freq of chars.values()) {\\n        while (freq > 0 && freqSet.has(freq)) {\\n            freq--;\\n            count++;\\n        }\\n\\n      freqSet.add(freq);\\n    }\\n\\n    return count;    \\n};", "var minDeletions = function(s) {\\n    const cnt = {};"]}
{"id": "1320", "ref_js": ["var maxProfit = function(A, k) {\\n    ", "var maxProfit = function(inventory, orders) {\\n    const MODULO = BigInt(10 ** 9 + 7);\\n    const size = inventory.length;\\n    let result = BigInt(0);\\n    let index = 0;\\n\\n    inventory.sort((a, b) => b - a);\\n    let current = inventory[0];\\n\\n    while (orders > 0) {\\n        while (index < size && inventory[index] === current) index += 1;\\n        const next = index === size ? 0 : inventory[index];\\n        let times = current - next;\\n        let remain = 0;\\n        const count = index * times;\\n\\n        if (orders < count) {\\n            times = Math.floor(orders / index);\\n            remain = orders % index;\\n        }\\n        const endValue = current - times;\\n        const sell = (BigInt(current + endValue + 1) * BigInt(times * index) / 2n) % MODULO;\\n\\n        result = (result + sell + BigInt(endValue * remain)) % MODULO;\\n        orders -= count;\\n        current = next;\\n    }\\n    return result;\\n};", "var maxProfit = function(inventory, orders) {\\n    inventory = [0, ...inventory].sort((b, a) => b - a);\\n\\n    let score = 0n, n = inventory.length;\\n    for (let i = n - 1; orders > 0; i--) {\\n        if (inventory[i] === inventory[i - 1]) continue;\\n\\n        const diff = Math.min(\\n            inventory[i] - inventory[i - 1], Math.floor(orders / (n - i)));\\n        const balls = diff * (n - i);\\n\\n        orders -= balls;\\n        score += BigInt(balls) * BigInt(2 * inventory[i] - diff + 1) / 2n;\\n        if (diff < inventory[i] - inventory[i - 1])\\n            score += BigInt(inventory[i] - diff) * BigInt(orders), orders = 0;\\n    }\\n\\n    return score % 1000000007n;\\n};"]}
{"id": "1321", "ref_js": ["var minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};", "var minimumDeletions = function (s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    \\n    return Math.min(a, b);\\n};", "var minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};"]}
{"id": "1322", "ref_js": ["var minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};", "var minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};", "var minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};"]}
{"id": "1323", "ref_js": ["var closeStrings = function(word1, word2) {\\n    if (word1.length != word2.length) return false\\n    if (word1 == word2) return true\\n\\n    arr1 = Array(26).fill(0)\\n    arr2 = Array(26).fill(0)\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        arr1[word1.charCodeAt(i) - 97] ++\\n        arr2[word2.charCodeAt(i) - 97] ++        \\n    }    \\n\\n    for (let i = 0; i < word1.length; i++) {\\n        if (arr1[i] > 0 && arr2[i] == 0) return false\\n        if (arr2[i] > 0 && arr1[i] == 0) return false        \\n    }        \\n\\n    str1 = arr1.sort((a, b) => a - b).join(\\'\\')\\n    str2 = arr2.sort((a, b) => a - b).join(\\'\\')\\n\\n    if (str1 == word1.length) return false\\n\\n    return str1 == str2    \\n};", "var closeStrings = function(w1, w2) {\\n    if(w1.length!==w2.length){return false}\\n    const tem1 = Array(26).fill(0)\\n    const tem2 = Array(26).fill(0)\\n    for(let i = 0; i<w1.length;i++){\\n        tem1[w1[i].charCodeAt(0)-97]=(tem1[w1[i].charCodeAt(0)-97] || 0) +1\\n        tem2[w2[i].charCodeAt(0)-97]=(tem2[w2[i].charCodeAt(0)-97] || 0) +1\\n    }\\n    for(let i=0;i<tem1.length;i++){\\n        if((tem1[i]>0 && tem2[i]===0)||(tem2[i]>0 && tem1[i]===0)){\\n            return false\\n        }\\n    }\\n    return tem1.sort((a,b)=>a-b).join(\\'\\')===tem2.sort((a,b)=>a-b).join(\\'\\')\\n};", "var closeStrings = function(word1, word2) {\\n  const m = word1.length;\\n  const n = word2.length;\\n\\n  if(m !== n) return false  \\n  \\n  const list1 = new Array(27).fill(0)\\n  const list2 = new Array(27).fill(0)\\n\\n  for(let i = 0; i < m; i++){\\n    list1[ word1.charCodeAt(i) - 97 ]++\\n    list2[ word2.charCodeAt(i) - 97 ]++\\n  }\\n\\n  for(let i = 0; i < 27; i++){\\n    if(list1[i] > 0 && list2[i] > 0)  continue\\n    if(list1[i] === 0 && list2[i] === 0) continue\\n    \\n    return false\\n  }\\n\\n  "]}
{"id": "1324", "ref_js": ["var minOperations = function(nums, x) {\\n    let target = -x, n = nums.length;\\n    for (let num of nums) target += num;\\n    \\n    if (target === 0) return n;\\n    \\n    let maxLen = 0, curSum = 0, left = 0;\\n    \\n    for (let right = 0; right < n; ++right) {\\n        curSum += nums[right];\\n        while (left <= right && curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        if (curSum === target) {\\n            maxLen = Math.max(maxLen, right - left + 1);\\n        }\\n    }\\n    \\n    return maxLen ? n - maxLen : -1;\\n};", "var minOperations = function(nums, x) {\\n    const target = nums.reduce((acc, num) => acc + num, 0) - x;\\n    \\n    if (target < 0) {\\n        return -1;\\n    }\\n    \\n    let left = 0;\\n    let curSum = 0;\\n    let maxSubLength = Number.NEGATIVE_INFINITY;\\n    const n = nums.length;\\n    \\n    for (let right = 0; right < n; right++) {\\n        curSum += nums[right];\\n        \\n        while (curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        \\n        if (curSum === target) {\\n            maxSubLength = Math.max(maxSubLength, right - left + 1);\\n        }\\n    }\\n    \\n    return maxSubLength === Number.NEGATIVE_INFINITY ? -1 : n - maxSubLength;    \\n};", "var minOperations = function(nums, x) {\\n    let target = -x, n = nums.length;\\n    for (let num of nums) target += num;\\n    \\n    if (target === 0) return n;\\n    \\n    let maxLen = 0, curSum = 0, left = 0;\\n    \\n    for (let right = 0; right < n; ++right) {\\n        curSum += nums[right];\\n        while (left <= right && curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        if (curSum === target) {\\n            maxLen = Math.max(maxLen, right - left + 1);\\n        }\\n    }\\n    \\n    return maxLen ? n - maxLen : -1;\\n};"]}
{"id": "1325", "ref_js": ["var getSmallestString = function (n, k) {\\n\\tlet numericArr = [],\\n\\t\\tstr = \\'\\';\\n\\t", "var getSmallestString = function(n, k) {\\n    k -= n\\n    let alpha =\\'_bcdefghijklmnopqrstuvwxy_\\',\\n        ans = \\'z\\'.repeat(~~(k / 25))\\n    if (k % 25) ans = alpha[k % 25] + ans\\n    return ans.padStart(n, \\'a\\')\\n};", "var getSmallestString = function(n, k) {    \\n    if (n <= 0 || k <= 0) {\\n        return \\'\\';\\n    }\\n       \\n    \\n    let highestCharFreq = Math.floor(k / (TO_ADD + n));\\n    let i = 0;          \\n    \\n    while(highestCharFreq === 0 && i <= TO_ADD) {\\n        i++;\\n        highestCharFreq = Math.floor(k / (TO_ADD + n - i))        \\n    }\\n    \\n    const highestCharCode = TO_ADD - i;\\n    const highestChar = String.fromCharCode(97 + highestCharCode);\\n    const newK = k - highestCharFreq * (highestCharCode + 1);\\n    const newN = n - highestCharFreq;\\n       \\n    \\n    \\n    const output = `${getSmallestString(newN, newK)}${highestChar.repeat(highestCharFreq)}`;    \\n    return output;\\n};"]}
{"id": "1326", "ref_js": ["var waysToMakeFair = function (nums) {\\n    let odds = 0;\\n    let evens = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2) odds += nums[i];\\n        else evens += nums[i];\\n    }\\n\\n    let preOdds = 0;\\n    let preEvens = 0;\\n    let postOdds = odds;\\n    let postEvens = evens;\\n    let totInd = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2) postOdds -= nums[i];\\n        else postEvens -= nums[i];\\n\\n        if (preEvens + postOdds === preOdds + postEvens) {\\n            totInd++;\\n        }\\n\\n        if (i % 2) preOdds += nums[i];\\n        else preEvens += nums[i];\\n    }\\n\\n    return totInd;\\n};", "var waysToMakeFair = function (a) {\\n  let sumEvenRight = 0, sumOddRight = 0;\\n  for (let i = 0; i < a.length; i++)\\n    if (i % 2 === 0) sumEvenRight += a[i];\\n    else sumOddRight += a[i];\\n  let sumEvenLeft = 0, sumOddLeft = 0, count = 0;\\n  for (let i = 0; i < a.length; i++)\\n    if (i % 2 === 0) {\\n      sumEvenRight -= a[i];\\n      if (sumEvenLeft + sumOddRight === sumOddLeft + sumEvenRight) count++;\\n      sumEvenLeft += a[i];\\n    } else {\\n      sumOddRight -= a[i];\\n      if (sumEvenLeft + sumOddRight === sumOddLeft + sumEvenRight) count++;\\n      sumOddLeft += a[i];\\n    }\\n  return count;\\n};", "var waysToMakeFair = function (nums) {\\n\\n    "]}
{"id": "1327", "ref_js": ["var mergeInBetween = function(list1, a, b, list2) {\\n     \\n     let diff = b-a;\\n     let totalRemove = diff+1;\\n     let cur = list1;\\n     let deleteList = null;\\n     let startIndex = 1;\\n     \\n     ", "var mergeInBetween = function(list1, a, b, list2) {\\n    const arr = [];\\n    const arr2 = [];\\n    while(list1 || list2) {\\n        if (list1) {\\n            arr.push(list1.val);\\n            list1 = list1.next;\\n        }\\n        if (list2) {\\n            arr2.push(list2.val);\\n            list2 = list2.next;\\n        }\\n    }\\n    arr.splice(a, b-a+1, ...arr2);\\n    return arr.reverse().reduce((acc, cur) => {\\n        if (acc === null) acc = new ListNode(cur)\\n        else acc = new ListNode(cur, acc);\\n        return acc;\\n    }, null)\\n};", "var mergeInBetween = function(list1, a, b, list2) {\\n     \\n     let diff = b-a;\\n     let totalRemove = diff+1;\\n     let cur = list1;\\n     let deleteList = null;\\n     let startIndex = 1;\\n     \\n     "]}
{"id": "1329", "ref_js": ["var mostCompetitive = function (a, k) {\\n  ", "var mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    const size = nums.length;\\n\\n    for (let index = 0; index < size; index++) {\\n        const num = nums[index];\\n\\n        while (stack.length && num < stack.at(-1) && size - index + stack.length > k) {\\n            stack.pop();\\n        }\\n        stack.length < k && stack.push(num);\\n    }\\n    return stack;\\n};", "var mostCompetitive = function(N, K) {\\n    let len = N.length, moves = len - K\\n    for (let i = 0, j = 1; j < len;) {\\n        while (N[j] < N[i] && moves) i--, moves--\\n        if (!moves) return N.slice(0,i+1).concat(N.slice(j))\\n        N[++i] = N[j++]\\n    }\\n    return N.slice(0,K)\\n};"]}
{"id": "1330", "ref_js": ["var minMoves = function(nums, limit) {\\n    const moves = Array(2 + limit * 2).fill(0);\\n    const size = nums.length;\\n    let current = 0;\\n    let result = size;\\n\\n    for (let index = 0; index < size / 2; index++) {\\n        const a = Math.min(nums[index], nums[size - 1 - index]);\\n        const b = Math.max(nums[index], nums[size - 1 - index]);\\n\\n        moves[2] += 2;\\n        moves[a + 1] -= 1;\\n        moves[a + b] -= 1;\\n        moves[a + b + 1] += 1;\\n        moves[b + limit + 1] += 1;\\n    }\\n    for (let index = 2; index <= limit * 2; index++) {\\n        current += moves[index];\\n        result = Math.min(current, result);\\n    }\\n    return result;\\n};", "var minMoves = function(N, L) {\\n    let len = N.length, pfx = new Array(L * 2 + 1).fill(0), best = 0\\n    for (let i = len / 2, a, b; i < len; i++) {\\n        a = N[i], b = N[len-i-1]\\n        if (b > a) [a,b] = [b,a]\\n        pfx[b]++, pfx[a+b-1]++, pfx[a+b]--, pfx[a+L]--\\n    }\\n    for (let i = 1, sum = 0; i <= 2 * L; i++)\\n        sum += pfx[i], best = sum > best ? sum : best\\n    return len - best\\n};", "var minMoves = function(nums, limit) {\\n    const moves = Array(2 + limit * 2).fill(0);\\n    const size = nums.length;\\n    let current = 0;\\n    let result = size;\\n\\n    for (let index = 0; index < size / 2; index++) {\\n        const a = Math.min(nums[index], nums[size - 1 - index]);\\n        const b = Math.max(nums[index], nums[size - 1 - index]);\\n\\n        moves[2] += 2;\\n        moves[a + 1] -= 1;\\n        moves[a + b] -= 1;\\n        moves[a + b + 1] += 1;\\n        moves[b + limit + 1] += 1;\\n    }\\n    for (let index = 2; index <= limit * 2; index++) {\\n        current += moves[index];\\n        result = Math.min(current, result);\\n    }\\n    return result;\\n};"]}
{"id": "1331", "ref_js": ["var maxOperations = function (nums, k) {\\n    nums.sort((a,b)=>a-b)\\n    let res=0\\n    let left=0\\n    let right =nums.length-1\\n    while(left<right){\\n        let sum =nums[left]+nums[right]\\n        if(sum<k){\\n            left++\\n        }else if(sum>k){\\n            right--\\n        }else{\\n            res++\\n            left++\\n            right--\\n        }\\n    }\\n    return res\\n};", "var maxOperations = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n\\n    let ans = 0;\\n    let start = 0;\\n    let end = nums.length - 1;\\n\\n    while (start < end) {\\n        if (nums[start] + nums[end] === k) {\\n            ans++;\\n            start++;\\n            end--;\\n            continue;\\n        } \\n        nums[start] + nums[end] > k ? end-- : start++;\\n    }\\n    return ans;;\\n};", "var maxOperations = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n\\n    let ans = 0;\\n    let start = 0;\\n    let end = nums.length - 1;\\n\\n    while (start < end) {\\n        if (nums[start] + nums[end] === k) {\\n            ans++;\\n            start++;\\n            end--;\\n            continue;\\n        } \\n        nums[start] + nums[end] > k ? end-- : start++;\\n    }\\n    return ans;;\\n};"]}
{"id": "1332", "ref_js": ["var concatenatedBinary = function(n) {\\n    let mod = 10 ** 9 + 7;\\n    let mul = 2;\\n    \\n    let ans = 1;\\n    for(let i = 2; i <= n; i++){\\n        if(i === mul) mul *= 2;\\n        ans = (ans * mul + i) % mod;\\n    }\\n    \\n    return ans;\\n};", "var concatenatedBinary = function(n) {\\n    let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007;\\n    }\\n    return ans\\n};", "var concatenatedBinary = function(n) {\\n    let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007;\\n    }\\n    return ans\\n};"]}
{"id": "1333", "ref_js": ["var getSumAbsoluteDifferences = function(nums) {\\n    let res = [];\\n    let prefixSum = 0;\\n    let suffixSum = nums.reduce((acc, num) => acc + num, 0);\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        let leftSum = nums[i] * i - prefixSum;\\n        let rightSum = suffixSum - nums[i] * (nums.length - i);\\n        let totalSum = leftSum + rightSum;\\n\\n        res.push(totalSum);\\n\\n        prefixSum += nums[i];\\n        suffixSum -= nums[i];\\n    }\\n\\n    return res;    \\n};", "var getSumAbsoluteDifferences = function(nums) {\\n    let totalSum = nums.reduce((sum, n) => sum + n, 0);\\n    let left = 0, right = totalSum;\\n    let result = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        right -= nums[i];\\n        result.push(nums[i] * i - left + right - nums[i] * (nums.length - i - 1));\\n        left += nums[i];\\n    }\\n\\n    return result;\\n};", "var getSumAbsoluteDifferences = function(nums) {\\n    let totalSum = nums.reduce((sum, n) => sum + n, 0);\\n    let left = 0, right = totalSum;\\n    let result = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        right -= nums[i];\\n        result.push(nums[i] * i - left + right - nums[i] * (nums.length - i - 1));\\n        left += nums[i];\\n    }\\n\\n    return result;\\n};"]}
{"id": "1334", "ref_js": ["var stoneGameVI = function(aliceValues, bobValues) {\\n    for (let i = 0; i < aliceValues.length; i++){\\n        aliceValues[i] = [aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]]\\n    }\\n    aliceValues.sort((a, b) => b[0] - a[0])\\n    let a = 0\\n    let b = 0\\n    for (let i = 0; i < aliceValues.length; i += 2){\\n      a += aliceValues[i][1]\\n    }\\n    for (let i = 1; i < aliceValues.length; i += 2){\\n      b += aliceValues[i][2]\\n    }\\n    return a === b ? 0 : a > b ? 1 : -1\\n};", "var stoneGameVI = function(aliceValues, bobValues) {\\n    const values = aliceValues.reduce((result, value, index) => {\\n        result.push({ alice: value, bob: bobValues[index] });\\n        return result;\\n    }, []);\\n    let alice = bob = 0;\\n\\n    values.sort((a, b) => (b.alice + b.bob) - (a.alice + a.bob));\\n    \\n    for (let index = 0; index < values.length; index++) {\\n        const value = values[index];\\n\\n        index % 2 \\n            ? bob += value.bob\\n            : alice += value.alice;\\n    }\\n    return alice < bob ? -1 : alice > bob; \\n};", "var stoneGameVI = function (aliceValues, bobValues) {\\n    "]}
{"id": "1335", "ref_js": ["var minPartitions = function(n) {\\n    let maxDigit = 0;\\n  for (let i = 0; i < n.length; i++) {\\n    let digit = parseInt(n[i]);\\n    if (digit > maxDigit) {\\n      maxDigit = digit;\\n    }\\n    if (maxDigit == 9) {\\n      return 9;\\n    }\\n  }\\n  return maxDigit;\\n};", "var minPartitions = function(n) {\\n    let maxDigit = 0;\\n  for (let i = 0; i < n.length; i++) {\\n    let digit = parseInt(n[i]);\\n    if (digit > maxDigit) {\\n      maxDigit = digit;\\n    }\\n    if (maxDigit == 9) {\\n      return 9;\\n    }\\n  }\\n  return maxDigit;\\n};", "var minPartitions = function(n) {\\n    let maxDigit = 0;\\n  for (let i = 0; i < n.length; i++) {\\n    let digit = parseInt(n[i]);\\n    if (digit > maxDigit) {\\n      maxDigit = digit;\\n    }\\n    if (maxDigit == 9) {\\n      return 9;\\n    }\\n  }\\n  return maxDigit;\\n};"]}
{"id": "1336", "ref_js": ["var stoneGameVII = function(S) {\\n    let N = S.length, dp = new Uint32Array(N)\\n    for (let i = N - 2; ~i; i--) {\\n        let total = S[i]\\n        for (let j = i + 1; j < N; j++) {\\n            total += S[j]\\n            dp[j] = Math.max(total - S[i] - dp[j], total - S[j] - dp[j-1])\\n        }\\n    }\\n    return dp[N-1]\\n};", "var stoneGameVII = function(stones) {\\n    const size = stones.length;\\n    const prefixPoint = Array(size + 1).fill(0);\\n    const dp = Array(size).fill(\\'\\').map(_ => Array(size).fill(0));\\n\\n    for (let index = 1; index <= size; index++) {\\n        prefixPoint[index] = stones[index - 1] + prefixPoint[index - 1];\\n    }\\n    for (let right = 0; right < size; right++) {\\n        for (let left = right; left >= 0; left--) {\\n            if (left === right) dp[left][right] = 0;\\n            else {\\n                const value1 = prefixPoint[right] - prefixPoint[left] - dp[left][right - 1];\\n                const value2 = prefixPoint[right + 1] - prefixPoint[left + 1] - dp[left + 1][right];\\n\\n                dp[left][right] = Math.max(dp[left][right], value1, value2);\\n            }\\n        }\\n    }\\n    return dp[0][size - 1];\\n};", "var stoneGameVII = function(s) {\\n    let len = s.length, dp = new Array(len).fill().map(_ => new Array(len).fill(0))\\n    for (let i = len - 2; ~i; i--)\\n        for (let j = i + 1, sum = s[i] + s[j]; j < len; sum += s[++j])\\n            dp[i][j] = Math.max(sum - s[i] - dp[i+1][j], sum - s[j] - dp[i][j-1])\\n    return dp[0][len-1]\\n};"]}
{"id": "1337", "ref_js": ["var maximumUniqueSubarray = function(nums) {\\n    let nmap = new Int8Array(10001), total = 0, best = 0\\n    for (let left = 0, right = 0; right < nums.length; right++) {\\n        nmap[nums[right]]++, total += nums[right]\\n        while (nmap[nums[right]] > 1)\\n            nmap[nums[left]]--, total -= nums[left++]\\n        best = Math.max(best, total)\\n    }\\n    return best\\n};", "var maximumUniqueSubarray = function(nums) {\\n    let set = new Set()\\n    let i = 0, j = 0, sum = 0, max = 0\\n    while(i < nums.length && j < nums.length){\\n        if(!set.has(nums[j])){\\n            set.add(nums[j])\\n            sum += nums[j++]\\n            max = Math.max(sum, max)\\n        } else{\\n            set.delete(nums[i])\\n            sum -= nums[i++]\\n        }\\n    }\\n    return max\\n};", "var maximumUniqueSubarray = function(nums) {\\n  \\n  let n = nums.length;\\n  let j = 0, i = 0 , sum = 0,res = 0 ;\\n  const set = new Set();\\n \\n  \\n  while(j<n && i<n){\\n    if(!set.has(nums[j])){\\n      sum = sum + nums[j];\\n      res = Math.max(sum,res);\\n      "]}
{"id": "1338", "ref_js": ["var maxResult = function(nums, k) {\\n   let n = nums.length, deq = [n-1]\\n    for (let i = n - 2; ~i; i--) {\\n        if (deq[0] - i > k) deq.shift()\\n        nums[i] += nums[deq[0]]\\n        while (deq.length && nums[deq[deq.length-1]] <= nums[i]) deq.pop()\\n        deq.push(i)\\n    }\\n    return nums[0] \\n};", "var maxResult = function(nums, k) {\\n    const n = nums.length;\\n    const dp = [...nums];\\n    const queue = [];\\n\\n    for(let i = 1; i < n; i += 1) {\\n        const prev = dp[i - 1];\\n        while(queue.length > 0 && queue[queue.length - 1] < prev) {\\n            queue.pop();\\n        }\\n        queue.push(prev);\\n        if(i - k - 1 >= 0 && dp[i - k - 1] === queue[0]) {\\n            queue.shift();\\n        }\\n\\n        dp[i] += queue[0];\\n    }\\n\\n    return dp[n - 1];\\n};", "var maxResult = function(nums, k) {\\n    "]}
{"id": "1339", "ref_js": ["var averageWaitingTime = function (customers) {\\n    let lastTime = customers[0][0];\\n    let len = customers.length;\\n    let total = 0;\\n    for (let i = 0; i < len; i++) {\\n        let [arrivalTime, prepTime] = customers[i];\\n        if (arrivalTime > lastTime) {\\n            lastTime = arrivalTime + prepTime;\\n        } else {\\n            lastTime += prepTime;\\n        }\\n        total += lastTime - arrivalTime;\\n    }\\n    return parseFloat(total/len).toFixed(5);\\n};", "var averageWaitingTime = function(customers) {\\n    let prepare = waitting = 0;\\n\\n    for (const [arrival, time] of customers) {\\n        if (prepare < arrival) prepare = arrival;\\n        prepare += time;\\n        waitting += prepare - arrival;\\n    }\\n    return waitting / customers.length;\\n};", "var averageWaitingTime = function(customers) {\\n    let totalFinishTime = customers[0][0] + customers[0][1];\\n    let waitingTimeArr = [totalFinishTime - customers[0][0]];\\n    let waitingTime = 0;\\n    let arrivalTime = 0;\\n    let prepareTime = 0;\\n    for(let i=1; i<customers.length; i++)\\n    {\\n        arrivalTime = customers[i][0];\\n        prepareTime = customers[i][1]\\n        \\n        if(arrivalTime > totalFinishTime)\\n        {\\n            totalFinishTime = arrivalTime + prepareTime;\\n        }\\n        else\\n        {\\n            totalFinishTime += prepareTime;\\n        }\\n        waitingTime = totalFinishTime - arrivalTime;\\n        waitingTimeArr.push(waitingTime);\\n    }\\n    return (waitingTimeArr.reduce((a,b)=> a+b , 0) / waitingTimeArr.length);\\n};"]}
{"id": "1340", "ref_js": ["var maximumBinaryString = function (s) {\\n  let n = s.length\\n\\n  let zeroCount = 0\\n  let firstZeroIndex = -1\\n  for (let i = 0; i < n; i++) {\\n    let ch = s[i]\\n    if (ch === \\'0\\') {\\n      zeroCount++\\n      if (firstZeroIndex === -1) firstZeroIndex = i\\n    }\\n  }\\n\\n  let ans = new Array(n).fill(1)\\n  ans[firstZeroIndex + zeroCount - 1] = 0\\n  return ans.join(\"\")\\n};", "var maximumBinaryString = function(binary) {\\n    const size = binary.length;\\n    const splitBinary = binary.split(\\'\\');\\n    let zero = start = 0;\\n\\n    for (let index = 0; index < size; index++) {\\n        const str = binary[index];\\n\\n        if (str === \\'0\\') zero += 1;\\n        else if (zero === 0) start += 1;\\n        splitBinary[index] = \\'1\\';\\n    }\\n    if (size !== start) splitBinary[start + zero - 1] = \\'0\\';\\n\\n    return splitBinary.join(\\'\\');\\n};", "var maximumBinaryString = function(binary) {\\n    const size = binary.length;\\n    const splitBinary = binary.split(\\'\\');\\n    let zero = start = 0;\\n\\n    for (let index = 0; index < size; index++) {\\n        const str = binary[index];\\n\\n        if (str === \\'0\\') zero += 1;\\n        else if (zero === 0) start += 1;\\n        splitBinary[index] = \\'1\\';\\n    }\\n    if (size !== start) splitBinary[start + zero - 1] = \\'0\\';\\n\\n    return splitBinary.join(\\'\\');\\n};"]}
{"id": "1341", "ref_js": ["var eatenApples = function (apples, days) {\\n  let n = apples.length;\\n  let maxApplesEaten = 0;\\n\\n  let minHeap = new PriorityQueue({ compare: (a, b) => a.expiryDate - b.expiryDate });\\n\\n  ", "var eatenApples = function(apples, days) {\\n    const applesTime = Array(2 * 2 * 10 ** 4 + 1).fill(0);\\n    let result = 0;\\n    let current = Infinity;\\n    let last = apples.length;\\n\\n    for (let index = 0; index <= last; index++) {\\n        if (current < index) current = index;\\n        const count = apples[index];\\n        \\n        if (count) {\\n            const rotTime = index + days[index] - 1;\\n\\n            applesTime[rotTime] += count;\\n            current = Math.min(rotTime, current);\\n            last = Math.max(rotTime, last);\\n        }\\n        while (!applesTime[current] && current < last) current += 1;\\n        if (!applesTime[current]) continue;\\n        result += 1;\\n        applesTime[current] -= 1;\\n    }\\n    return result;\\n};", "var eatenApples = function(A, D) {\\n    let time = new Array(40001), ans = 0, last = A.length\\n    for (let i = 0, j = Infinity; i <= last; i++) {\\n        if (j < i) j = i\\n        if (A[i]) {\\n            let exp = i + D[i] - 1\\n            if (time[exp]) time[exp] += A[i]\\n            else time[exp] = A[i]\\n            if (exp < j) j = exp\\n            if (exp > last) last = exp\\n        }\\n        while (!time[j] && j < last) j++\\n        if (time[j]) ans++, time[j]--\\n    }\\n    return ans\\n};"]}
{"id": "1342", "ref_js": ["var findBall = function(grid) {\\n    let balls = grid[0].length;\\n    const ans = new Array(balls).fill(-1);\\n    for (let i = 0; i < ans.length; i++) {\\n        ans[i] = dfs(grid, 0, i);\\n    }\\n    return ans;\\n};", "var findBall = function(grid) {\\n    let m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const answer = [...Array(n)].fill(-1);\\n    \\n    const moveBall = (index, row, col) => {\\n        if (row === m) {\\n            answer[index] = col;\\n            return true;\\n        }\\n        \\n        if (row >= m || col < 0 || col >= n) {\\n            return false;\\n        }\\n        \\n        const dir = grid[row][col];\\n        const next = [];\\n        \\n        switch(dir) {\\n            case 1: {\\n                const next = grid[row]?.[col + 1];\\n                if (next === 1) {\\n                    moveBall(index, row + 1, col + 1);\\n                }\\n                break;\\n            }\\n                \\n            case -1: {\\n                const next = grid[row]?.[col - 1];\\n                if (next === -1) {\\n                    moveBall(index, row + 1, col - 1);\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    \\n    for(let i = 0; i < n; i++) {\\n        moveBall(i, 0, i);\\n    }\\n    \\n    return answer;\\n};", "var findBall = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const saved = new Array(m).fill(false).map(() => new Array(n).fill(false));\\n\\n    const isValid = (row, col, grid) => {\\n        if (col < 0 || col >= n || (grid[row][col] === 1 && grid[row][col + 1] === -1) || (grid[row][col] === -1 && grid[row][col - 1] === 1)) return false;\\n        return true;\\n    }\\n    const stack = [];\\n    for (let i = 0; i < grid[0].length; i++) {\\n        stack.push([0, i, 0]);\\n    }\\n    const temp = [];\\n    \\n    const dfs = (grid) => {\\n        while(stack.length) {\\n            const current = stack.pop();\\n            const row = current[0];\\n            const col = current[1];\\n            const distance = current[2];\\n\\n            if (row >= m && col < n && col >= 0) {\\n                temp.push([row, col, distance]);\\n                continue;\\n            }\\n            \\n            if (!isValid(row, col, grid) || saved[row][col]) continue;\\n            saved[row][col] = true;\\n        \\n            stack.push([row + 1, col + grid[row][col], distance + grid[row][col]]);\\n        }\\n        \\n        \\n    }\\n    dfs(grid);\\n    const output = new Array(n).fill(-1);\\n    \\n    for (let i = 0 ; i < temp.length; i++) {\\n        const item = temp[i];\\n        output[item[1] - item[2]] = item[1];\\n    }\\n    return output;\\n};"]}
{"id": "1343", "ref_js": ["var countPairs = function(deliciousness) {\\n    const MODULO = 10 ** 9 + 7;\\n    const foodMap = new Map();\\n    const powers = Array(22).fill(\\'\\').map((_, index) => 2 ** index);\\n    let result = 0;\\n\\n    for (let index = 0; index < deliciousness.length; index++) {\\n        const food = deliciousness[index];\\n\\n        for (const power of powers) {\\n            if (!foodMap.has(power - food)) continue;\\n            result = (result + foodMap.get(power - food)) % MODULO;\\n        }\\n        foodMap.set(food, (foodMap.get(food) ?? 0) + 1);\\n    }\\n    return result;\\n};", "var countPairs = function(deliciousness) {\\n    let goodMeals = 0, map = new Map(), sqr;\\n    const MODULO = 10**9 + 7;\\n\\n    for(let rate of deliciousness) {\\n        for(let i = 21; i >= 0; i--) {\\n            sqr = 2**i;\\n            if(sqr - rate < 0) break;\\n            if(map.has(sqr - rate)) { ", "var countPairs = function(deliciousness) {\\n    \\n    function counter(x){\\n        let temp=x\\n        let count=0\\n        while(x){\\n            x=Math.floor(x/2)\\n            count++\\n        }\\n        return (1<<count)-temp\\n    }\\n    \\n    let map=new Map()\\n    for(let meal of deliciousness){\\n        if(!map.has(meal)) map.set(meal,1)\\n        else map.set(meal,map.get(meal)+1)\\n    }\\n  \\n    let res=0\\n    for(let [k,v] of map){\\n        \\n        if(k==counter(k)) {\\n            res+=(v*(v-1)/2)\\n            if(k!=1 && map.has(0)) {\\n                res+=(map.get(k)*map.get(0))\\n            }\\n        }\\n        else {\\n            if(map.has(counter(k))){\\n                res+=(map.get(k)*map.get(counter(k)))\\n            }\\n        }\\n    }\\n    \\n    return res%(10**9+7)\\n    \\n};"]}
{"id": "1344", "ref_js": ["var waysToSplit = function(nums) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = nums.length;\\n    const prefixSum = [nums[0]];\\n    let mid = right = result = 0;\\n\\n    for (let index = 1; index < size; index++) {\\n        prefixSum[index] = prefixSum[index - 1] + nums[index];\\n    }\\n    for (let index = 0; index < size - 2; index++) {\\n        const current = prefixSum[index];\\n\\n        mid = Math.max(mid, index + 1);\\n        while (mid < size - 1 && prefixSum[mid] - current < current) mid += 1;\\n        right = Math.max(right, mid);\\n        while (right < size - 1 && prefixSum[right] - current <= prefixSum.at(-1) - prefixSum[right]) {\\n            right += 1;\\n        }\\n        result += right - mid;\\n        result %= MODULO;\\n    }\\n    return result;\\n};", "var waysToSplit = function(N) {\\n    let len = N.length\\n    for (let i = 1; i < len; i++)\\n        N[i] += N[i - 1]\\n    let max = N[len - 1], ans = 0\\n    if (max === 0)\\n        return ((len - 2) * (len - 1) / 2) % 1000000007\\n    for (let i = 0, j = 1, k = 1; N[i] <= max / 3; i++) {\\n        let lo = N[i] * 2, hi = (max + N[i]) / 2\\n        while (j === i || N[j] < lo)\\n            j++\\n        while (N[k] <= hi)\\n            k++\\n        ans += k - j\\n    }\\n    return ans % 1000000007\\n};", "var waysToSplit = function(nums) {\\n    const mod = 1000000007;\\n    const lastIndex = nums.length - 2;\\n    const total = nums.reduce((sum, num) => sum + num)\\n\\n    let midLeftPtr = -1;\\n    let midRightPtr = -1;\\n    \\n    let leftSum = 0;\\n    let midLeftSum = 0;\\n    let midRightSum = 0;\\n    \\n    let numWaysToSplit = 0;\\n    \\n    for (let leftPtr = 0; leftPtr < nums.length; leftPtr++) {\\n        leftSum += nums[leftPtr];        \\n        midLeftSum -= nums[leftPtr];\\n        midRightSum -= nums[leftPtr];\\n\\n       "]}
{"id": "1345", "ref_js": ["var maximumGain = function(S, X, Y) {\\n    let len = S.length, ans = 0, a = \"a\", b = \"b\"\\n    if (Y > X) [a,b,X,Y] = [b,a,Y,X]\\n    let aStore = 0, bStore = 0\\n    for (let i = 0, c = S[i]; i <= len; c = S[++i])\\n        if (c === a) aStore++\\n        else if (c === b)\\n            if (aStore) ans += X, aStore--\\n            else bStore++\\n        else ans += Y * Math.min(aStore, bStore), aStore = bStore = 0\\n    return ans\\n};", "var maximumGain = function(s, x, y) {\\n    const maxScoreStack = [];\\n    const minSocreStack = [];\\n    const [maxScore, minScore] = x > y ? [x, y] : [y, x];\\n    const [firstString, secondString] = x > y ? [\\'a\\', \\'b\\'] : [\\'b\\', \\'a\\'];\\n    let result = 0;\\n\\n    for (const str of s) {\\n        if (maxScoreStack.length && maxScoreStack.at(-1) === firstString && str === secondString) {\\n            maxScoreStack.pop();\\n            result += maxScore;\\n            continue;\\n        }\\n        maxScoreStack.push(str);\\n    }\\n    for (let index = maxScoreStack.length - 1; index >= 0; index--) {\\n        const str = maxScoreStack[index];\\n\\n        if (minSocreStack.length && minSocreStack.at(-1) === firstString && str === secondString) {\\n            minSocreStack.pop();\\n            result += minScore;\\n            continue;\\n        }\\n        minSocreStack.push(str);\\n    }\\n    return result;\\n};", "var maximumGain = function(s, x, y) {\\n    const maxScoreStack = [];\\n    const minSocreStack = [];\\n    const [maxScore, minScore] = x > y ? [x, y] : [y, x];\\n    const [firstString, secondString] = x > y ? [\\'a\\', \\'b\\'] : [\\'b\\', \\'a\\'];\\n    let result = 0;\\n\\n    for (const str of s) {\\n        if (maxScoreStack.length && maxScoreStack.at(-1) === firstString && str === secondString) {\\n            maxScoreStack.pop();\\n            result += maxScore;\\n            continue;\\n        }\\n        maxScoreStack.push(str);\\n    }\\n    for (let index = maxScoreStack.length - 1; index >= 0; index--) {\\n        const str = maxScoreStack[index];\\n\\n        if (minSocreStack.length && minSocreStack.at(-1) === firstString && str === secondString) {\\n            minSocreStack.pop();\\n            result += minScore;\\n            continue;\\n        }\\n        minSocreStack.push(str);\\n    }\\n    return result;\\n};"]}
{"id": "1346", "ref_js": ["var constructDistancedSequence = function(n) {\\n    const ans=Array((n*2)-1).fill();\\n\\n    const dfs=(i,seen,path)=>{\\n        if(i===path.length) return true;\\n        if(path[i]!==undefined) return dfs(i+1,seen,path);\\n\\n        for(let num=n;num>0;num--){\\n            if(seen.has(num)) continue;\\n\\n            if(num!==1 && (num+i>=path.length || path[num+i]!==undefined)){\\n                continue\\n            }\\n\\n            seen.add(num);\\n\\n            if(num!==1) path[num+i]=num;\\n            path[i]=num;\\n            if(dfs(i+1,seen,path)){\\n                return true;\\n            }\\n            ", "var constructDistancedSequence = function(n) {\\n    const result = [];\\n    const visited = new Set();\\n    const size = n * 2 - 1;\\n    const constructSequence = (index = 0) => {\\n        if (index === size) return true;\\n        if (result[index]) return constructSequence(index + 1);\\n        \\n        for (let num = n; num >= 1; num--) {\\n            if (visited.has(num)) continue;\\n            result[index] = num;\\n            visited.add(num);\\n            if (num === 1 && constructSequence(index + 1)) return true;\\n            if (index + num < size && !result[index + num]) {\\n                result[index + num] = num;\\n                if (constructSequence(index + 1)) return true;\\n                result[index + num] = 0;\\n            }\\n            result[index] = 0;\\n            visited.delete(num);\\n        }\\n        return false;\\n    };", "var constructDistancedSequence = function(n) {\\n    let ans = new Uint8Array(n * 2 - 1),\\n        avail = (1 << n + 1) - 2\\n    const rc = i => {\\n        if (!avail) return true\\n        while (ans[i]) i++\\n        for (let val = n; val; val--) {\\n            let j = val > 1 ? i + val : i\\n            if (avail & 1 << val && ans[j] === 0) {\\n                ans[i] = ans[j] = val, avail ^= 1 << val\\n                if (rc(i+1)) return true\\n                else ans[i] = ans[j] = 0, avail ^= 1 << val\\n            }\\n        }\\n    }\\n    rc(0)\\n\\treturn ans\\n};"]}
{"id": "1347", "ref_js": ["var swapNodes = function(head, k) {\\n    let slow = fast = head\\n    let i = k - 1\\n    while(i !== 0) {\\n        fast = fast.next\\n        i--\\n    }\\n    let left = fast\\n    while(fast.next) {\\n        slow = slow.next\\n        fast = fast.next\\n    }\\n    let temp = slow.val;\\n    slow.val = left.val;\\n    left.val = temp\\n    return head\\n\\n\\n};", "var swapNodes = function(head, k) {\\n    let curNode = head;\\n    let endNode = head;\\n    let count =1;\\n", "var swapNodes = function(head, k) {\\n\\n      if (!head) {\\n        return null;\\n    }\\n    let left = head, right = head;\\n    for (let i = 1; i < k; i++) {\\n        left = left.next;\\n    }\\n    let curr = left;\\n    while (curr.next) {\\n        curr = curr.next;\\n        right = right.next;\\n    }\\n    let temp = left.val;\\n    left.val = right.val;\\n    right.val = temp;\\n    return head;\\n    \\n};"]}
{"id": "1348", "ref_js": ["var minimumHammingDistance = function(source, target, allowedSwaps) {\\n    const size = source.length;\\n    const union = [];\\n    const sourceMap = new Map();\\n    const find = (node) => union[node] === node ? node : find(union[node]);\\n    let result = 0;\\n\\n    for (let index = 0; index < size; index++) union[index] = index;\\n    for (const [a, b] of allowedSwaps) {\\n        const parentA = find(a);\\n        const parentB = find(b);\\n        \\n        if (parentA == parentB) continue;\\n        union[parentA] = parentB; \\n    }\\n    for (let index = 0; index < size; index++) {\\n        const parent = find(index);\\n        const group = sourceMap.get(parent);\\n        const current = source[index];\\n\\n        group \\n            ? group.set(current, (group.get(current) ?? 0) + 1)\\n            : sourceMap.set(parent, new Map([[current, 1]]));\\n    }\\n    for (let index = 0; index < size; index++) {\\n        const group = sourceMap.get(find(index));\\n        const count = group.get(target[index]);\\n\\n        count ? group.set(target[index], count - 1) : result += 1;\\n    }\\n    return result;\\n};", "var minimumHammingDistance = function(source, target, allowedSwaps) {\\n    const size = source.length;\\n    const union = [];\\n    const sourceMap = new Map();\\n    const find = (node) => union[node] === node ? node : find(union[node]);\\n    let result = 0;\\n\\n    for (let index = 0; index < size; index++) union[index] = index;\\n    for (const [a, b] of allowedSwaps) {\\n        const parentA = find(a);\\n        const parentB = find(b);\\n        \\n        if (parentA == parentB) continue;\\n        union[parentA] = parentB; \\n    }\\n    for (let index = 0; index < size; index++) {\\n        const parent = find(index);\\n        const group = sourceMap.get(parent);\\n        const current = source[index];\\n\\n        group \\n            ? group.set(current, (group.get(current) ?? 0) + 1)\\n            : sourceMap.set(parent, new Map([[current, 1]]));\\n    }\\n    for (let index = 0; index < size; index++) {\\n        const group = sourceMap.get(find(index));\\n        const count = group.get(target[index]);\\n\\n        count ? group.set(target[index], count - 1) : result += 1;\\n    }\\n    return result;\\n};", "var minimumHammingDistance = function(source, target, allowedSwaps) {\\n    const size = source.length;\\n    const union = [];\\n    const sourceMap = new Map();\\n    const find = (node) => union[node] === node ? node : find(union[node]);\\n    let result = 0;\\n\\n    for (let index = 0; index < size; index++) union[index] = index;\\n    for (const [a, b] of allowedSwaps) {\\n        const parentA = find(a);\\n        const parentB = find(b);\\n        \\n        if (parentA == parentB) continue;\\n        union[parentA] = parentB; \\n    }\\n    for (let index = 0; index < size; index++) {\\n        const parent = find(index);\\n        const group = sourceMap.get(parent);\\n        const current = source[index];\\n\\n        group \\n            ? group.set(current, (group.get(current) ?? 0) + 1)\\n            : sourceMap.set(parent, new Map([[current, 1]]));\\n    }\\n    for (let index = 0; index < size; index++) {\\n        const group = sourceMap.get(find(index));\\n        const count = group.get(target[index]);\\n\\n        count ? group.set(target[index], count - 1) : result += 1;\\n    }\\n    return result;\\n};"]}
{"id": "1349", "ref_js": ["var tupleSameProduct = function(nums) {\\n    const productMap = new Map();\\n    const size = nums.length;\\n    let result = 0;\\n\\n    for (let a = 0; a < size; a++) {\\n        for (let b = a + 1; b < size; b++) {\\n            const product = nums[a] * nums[b];\\n            const count = productMap.get(product) ?? 0;\\n\\n            result += 8 * count;\\n            productMap.set(product, count + 1);\\n        }\\n    }\\n    return result;\\n};", "var tupleSameProduct = function(nums) {\\n    var map = new Map(),res = 0\\n    for(i=0;i<nums.length;i++) {\\n        for(j=i+1;j<nums.length;j++) {\\n            let p = nums[i]*nums[j]\\n            map.set(p,map.get(p)+1||1)\\n        }\\n    }\\n\\n    for(var[key,value] of map) {\\n        if(value>=2) {\\n            res+=value*(value-1)*4\\n        }\\n    }\\n    return res\\n};", "var tupleSameProduct = function(nums) {\\n    let tupleCount = 0;\\n    let products = {};"]}
{"id": "1350", "ref_js": ["var largestSubmatrix = function(matrix) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n\\n    for (let i = 1; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            if (matrix[i][j] === 1) {\\n                matrix[i][j] += matrix[i - 1][j];\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    \\n    matrix.forEach(row => {\\n        row.sort((a, b) => b - a);\\n        for (let j = 0, k = 1; j < n && row[j] > 0; ++j, ++k) {\\n            const s = row[j] * k;\\n            ans = Math.max(ans, s);\\n        }\\n    });\\n    \\n    return ans;\\n};", "var largestSubmatrix = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n\\n    ", "var largestSubmatrix = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n\\n    "]}
{"id": "1351", "ref_js": ["var minimumTeachings = function(n, languages, friendships) {\\n    const size = languages.length;\\n    const communicate = Array(size).fill(\\'\\').map(_ => Array(n).fill(false));\\n    const users = new Set();\\n    let result = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < size; index++) {\\n        for (const language of languages[index]) {\\n            communicate[index][language - 1] = true;\\n        }\\n    }\\n    for (const [a, b] of friendships) {\\n        const isCommunicate = communicate[a - 1].some((isKnow, language) => {\\n            return isKnow ? communicate[b - 1][language] : isKnow;\\n        });\\n\\n        if (isCommunicate) continue;\\n        users.add(a - 1).add(b - 1);\\n    }\\n    for (let language = 0; language < n; language++) {\\n        let teach = 0;\\n\\n        for (const user of users) {\\n            !communicate[user][language] && teach++\\n        }\\n        result = Math.min(teach, result);\\n    }\\n    return result;\\n};", "var minimumTeachings = function(n, languages, friendships) {\\n    const size = languages.length;\\n    const communicate = Array(size).fill(\\'\\').map(_ => Array(n).fill(false));\\n    const users = new Set();\\n    let result = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < size; index++) {\\n        for (const language of languages[index]) {\\n            communicate[index][language - 1] = true;\\n        }\\n    }\\n    for (const [a, b] of friendships) {\\n        const isCommunicate = communicate[a - 1].some((isKnow, language) => {\\n            return isKnow ? communicate[b - 1][language] : isKnow;\\n        });\\n\\n        if (isCommunicate) continue;\\n        users.add(a - 1).add(b - 1);\\n    }\\n    for (let language = 0; language < n; language++) {\\n        let teach = 0;\\n\\n        for (const user of users) {\\n            !communicate[user][language] && teach++\\n        }\\n        result = Math.min(teach, result);\\n    }\\n    return result;\\n};", "var minimumTeachings = function(n, languages, friendships) {\\n    const size = languages.length;\\n    const communicate = Array(size).fill(\\'\\').map(_ => Array(n).fill(false));\\n    const users = new Set();\\n    let result = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < size; index++) {\\n        for (const language of languages[index]) {\\n            communicate[index][language - 1] = true;\\n        }\\n    }\\n    for (const [a, b] of friendships) {\\n        const isCommunicate = communicate[a - 1].some((isKnow, language) => {\\n            return isKnow ? communicate[b - 1][language] : isKnow;\\n        });\\n\\n        if (isCommunicate) continue;\\n        users.add(a - 1).add(b - 1);\\n    }\\n    for (let language = 0; language < n; language++) {\\n        let teach = 0;\\n\\n        for (const user of users) {\\n            !communicate[user][language] && teach++\\n        }\\n        result = Math.min(teach, result);\\n    }\\n    return result;\\n};"]}
{"id": "1352", "ref_js": ["var decode = function(encoded) {\\n    const size = encoded.length + 1;\\n    const result = [1];\\n\\n    for (let n = 2; n <= size; n++) {\\n        result[0] ^= n;\\n    }\\n    for (let index = 1; index < size - 1; index += 2) {\\n        result[0] ^= encoded[index];\\n    }\\n    for (let index = 1; index < size; index++) {\\n        result[index] = result[index - 1] ^ encoded[index - 1];\\n    }\\n    return result;\\n};", "var decode = function(encoded) {\\n    const size = encoded.length + 1;\\n    const result = [1];\\n\\n    for (let n = 2; n <= size; n++) {\\n        result[0] ^= n;\\n    }\\n    for (let index = 1; index < size - 1; index += 2) {\\n        result[0] ^= encoded[index];\\n    }\\n    for (let index = 1; index < size; index++) {\\n        result[index] = result[index - 1] ^ encoded[index - 1];\\n    }\\n    return result;\\n};", "var decode = function(encoded) {\\n    const size = encoded.length + 1;\\n    const result = [1];\\n\\n    for (let n = 2; n <= size; n++) {\\n        result[0] ^= n;\\n    }\\n    for (let index = 1; index < size - 1; index += 2) {\\n        result[0] ^= encoded[index];\\n    }\\n    for (let index = 1; index < size; index++) {\\n        result[index] = result[index - 1] ^ encoded[index - 1];\\n    }\\n    return result;\\n};"]}
{"id": "1353", "ref_js": ["var minCharacters = function(A, B) {\\n    let lenA = A.length, fmA = new Uint32Array(26),\\n        lenB = B.length, fmB = new Uint32Array(26),\\n        best = sumA = sumB = 0\\n    for (let i = 0; i < lenA; i++) fmA[A.charCodeAt(i)-97]++\\n    for (let i = 0; i < lenB; i++) fmB[B.charCodeAt(i)-97]++\\n    for (let i = 0; i < 26; i++) best = Math.max(best, fmA[i]+fmB[i])\\n    for (let i = 0; i < 25; i++) {\\n        sumA += fmA[i], sumB += fmB[i]\\n        best = Math.max(best, sumA-sumB+lenB, sumB-sumA+lenA)\\n    }\\n    return lenA + lenB - best\\n};", "var minCharacters = function(a, b) {\\n    const BASE_CODE = \\'a\\'.charCodeAt(0);\\n    const m = a.length;\\n    const n = b.length;\\n    const countA = Array(26).fill(0);\\n    const countB = Array(26).fill(0);\\n    let result = m + n;\\n\\n    for (const char of a) countA[char.charCodeAt(0) - BASE_CODE] += 1;\\n    for (const char of b) countB[char.charCodeAt(0) - BASE_CODE] += 1;\\n    for (let index = 0; index < 26; index++) {\\n        result = Math.min(result, m + n - countA[index] - countB[index]);\\n\\n        if (index > 0) {\\n            countA[index] += countA[index - 1];\\n            countB[index] += countB[index - 1];\\n        }\\n        if (index >= 25) continue;\\n        result = Math.min(result, m - countA[index] + countB[index]);\\n        result = Math.min(result, n + countA[index] - countB[index]);\\n    }\\n    return result;\\n};", "var minCharacters = function(A, B) {\\n    let lenA = A.length, fmA = new Uint32Array(26),\\n        lenB = B.length, fmB = new Uint32Array(26),\\n        best = sumA = sumB = 0\\n    for (let i = 0; i < lenA; i++) fmA[A.charCodeAt(i)-97]++\\n    for (let i = 0; i < lenB; i++) fmB[B.charCodeAt(i)-97]++\\n    for (let i = 0; i < 26; i++) best = Math.max(best, fmA[i]+fmB[i])\\n    for (let i = 0; i < 25; i++) {\\n        sumA += fmA[i], sumB += fmB[i]\\n        best = Math.max(best, sumA-sumB+lenB, sumB-sumA+lenA)\\n    }\\n    return lenA + lenB - best\\n};"]}
{"id": "1354", "ref_js": ["var kthLargestValue = function(matrix, k) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    const values = Array(m + 1).fill(\\'\\').map(_ => Array(n + 1).fill(0));\\n    const result = [];\\n\\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <=n; col++) {\\n            values[row][col] = \\n                matrix[row - 1][col - 1] ^ \\n                values[row - 1][col] ^ \\n                values[row][col - 1] ^\\n                values[row - 1][col - 1];\\n\\n            result.push(values[row][col]);\\n        }\\n    }\\n    result.sort((a, b) => b - a);\\n    return result[k - 1];\\n};", "var kthLargestValue = function (g, k) {\\n    let m = g.length;\\n    let n = g[0].length;\\n    let an = [];\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++) {\\n            if (i === 0 && j === 0) {\\n            } else {\\n                g[i][j] =\\n                    g[i][j] ^\\n                    (g[i - 1]?.[j] || 0) ^\\n                    (g[i][j - 1] || 0) ^\\n                    (g[i - 1]?.[j - 1] || 0);\\n            }\\n            an.push(g[i][j]);\\n        }\\n    an.sort((a, b) => b - a);\\n    return an[k - 1] || 0;\\n};", "var kthLargestValue = function(M, K) {\\n    let y = M.length, x = M[0].length, ans = new Uint32Array(x*y), h = 0\\n    for (let i = 0; i < y; i++)\\n        for (let j = 0; j < x; j++) {\\n            let cell = M[i][j]\\n            if (i > 0) cell ^= M[i-1][j]\\n            if (j > 0) cell ^= M[i][j-1]\\n            if (i > 0 && j > 0) cell ^= M[i-1][j-1]\\n            ans[h++] = M[i][j] = cell\\n        }\\n    return ans.sort()[x*y-K]\\n};"]}
{"id": "1355", "ref_js": ["var restoreArray = function(vals) {\\n    const pairs = new Map();\\n    \\n    for (const val of vals) {\\n        if (!pairs.has(val[0])) pairs.set(val[0], []);\\n        if (!pairs.has(val[1])) pairs.set(val[1], []);\\n        pairs.get(val[0]).push(val[1]);\\n        pairs.get(val[1]).push(val[0]);\\n    }\\n    \\n    const result = [];\\n    let start = -1000000;\\n    \\n    for (const [entry, values] of pairs) {\\n        if (values.length === 1) {\\n            start = entry;\\n            break;\\n        }\\n    }\\n    \\n    let left = -1000000;\\n    result.push(start);\\n    \\n    for (let i = 1; i <= vals.length; i++) {\\n        const val = pairs.get(start);\\n        const newval = val[0] !== left ? val[0] : val[1];\\n        result.push(newval);\\n        left = start;\\n        start = newval;\\n    }\\n    \\n    return result;\\n};", "var restoreArray = function(adjacentPairs) {\\n    const graph = new Map();\\n\\n    for (const [u, v] of adjacentPairs) {\\n        if (!graph.has(u)) graph.set(u, []);\\n        if (!graph.has(v)) graph.set(v, []);\\n        graph.get(u).push(v);\\n        graph.get(v).push(u);\\n    }\\n\\n    let result = [];\\n\\n    for (const [node, neighbors] of graph.entries()) {\\n        if (neighbors.length === 1) {\\n            result = [node, neighbors[0]];\\n            break;\\n        }\\n    }\\n\\n    while (result.length < adjacentPairs.length + 1) {\\n        const [last, prev] = [result[result.length - 1], result[result.length - 2]];\\n        const candidates = graph.get(last);\\n        const nextElement = candidates[0] !== prev ? candidates[0] : candidates[1];\\n        result.push(nextElement);\\n    }\\n\\n    return result;    \\n};", "var restoreArray = function(vals) {\\n    const pairs = new Map();\\n    \\n    for (const val of vals) {\\n        if (!pairs.has(val[0])) pairs.set(val[0], []);\\n        if (!pairs.has(val[1])) pairs.set(val[1], []);\\n        pairs.get(val[0]).push(val[1]);\\n        pairs.get(val[1]).push(val[0]);\\n    }\\n    \\n    const result = [];\\n    let start = -1000000;\\n    \\n    for (const [entry, values] of pairs) {\\n        if (values.length === 1) {\\n            start = entry;\\n            break;\\n        }\\n    }\\n    \\n    let left = -1000000;\\n    result.push(start);\\n    \\n    for (let i = 1; i <= vals.length; i++) {\\n        const val = pairs.get(start);\\n        const newval = val[0] !== left ? val[0] : val[1];\\n        result.push(newval);\\n        left = start;\\n        start = newval;\\n    }\\n    \\n    return result;\\n};"]}
{"id": "1356", "ref_js": ["var canEat = function(candiesCount, queries) {\\n    const prfixCandiesCount = [0];\\n\\n    for (let index = 0; index < candiesCount.length; index++) {\\n        prfixCandiesCount.push(prfixCandiesCount[index] + candiesCount[index]);\\n    }\\n    \\n    return queries.map(([type, day, cap]) => {\\n        const minDay = Math.floor(prfixCandiesCount[type] / cap);\\n        const maxDay = prfixCandiesCount[type + 1] - 1;\\n\\n        return minDay <= day && maxDay >= day;\\n    });\\n};", "var canEat = function(candiesCount, queries) {\\n    for (let i = 1; i < candiesCount.length; i++)\\n        candiesCount[i] += candiesCount[i - 1];\\n\\n    return queries.map(([i, day, dailyCap]) =>\\n        (day + 1) * dailyCap > (candiesCount[i - 1] ?? 0) && day < candiesCount[i]);\\n};", "var canEat = function (A, Q) {\\n  const pre = [...A];\\n  for (let i = 1; i < A.length; i++) pre[i] += pre[i - 1];\\n  const res = Array(Q.length).fill(true);\\n  \\n  for (let i = 0; i < Q.length; i++) {\\n    const [type, day, cap] = Q[i];\\n\\t"]}
{"id": "1357", "ref_js": ["var maxAbsoluteSum = function(nums) {\\n    maxi = Number.MIN_VALUE , mini = Number.MAX_VALUE\\n    cur_max = 0, cur_min = 0\\n    for(let i=0; i<nums.length; i++){\\n        cur_max = Math.max(cur_max+nums[i],nums[i])\\n        cur_min = Math.min(cur_min+nums[i], nums[i])\\n        maxi = Math.max(maxi,cur_max)\\n        mini = Math.min(mini,cur_min)\\n    }\\n    return Math.max(maxi,-mini)\\n};", "var maxAbsoluteSum = function(nums) {\\n    let sum = max = min = 0;\\n\\n    for (const num of nums) {\\n        sum += num;\\n        max = Math.max(sum, max);\\n        min = Math.min(sum, min);\\n    }\\n    return max - min;\\n};", "var maxAbsoluteSum = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    let solutionMax = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        min = Math.min(0, nums[i], min + nums[i]);\\n        max = Math.max(0, nums[i], max + nums[i]);\\n        solutionMax = Math.max(solutionMax, Math.abs(max), Math.abs(min));\\n    }\\n    \\n    return solutionMax;\\n};"]}
{"id": "1358", "ref_js": ["var minimumLength = function (s) {\\n  let m = s.length;\\n  let seq = getChCountInSeq(s);\\n  let n = seq.length;\\n  let i, j;\\n  let deletedCount = 0;\\n  for (i = 0, j = n - 1; i < j; i++, j--) {\\n    let [lch, lcount] = seq[i];\\n    let [rch, rcount] = seq[j];\\n    if (lch !== rch) return m - deletedCount;\\n    deletedCount += lcount + rcount;\\n  }\\n  if (i == j) {\\n    let [ch, count] = seq[i];\\n    return count === 1 ? 1 : 0;\\n  } else {\\n    return j - i + 1;\\n  }\\n};", "var minimumLength = function(s) {\\n    let left = 0;\\n    let right = s.length - 1;\\n\\n    while (left < right) {\\n        const start = { left, right };", "var minimumLength = function(s) {\\n    let i=0,j=s.length-1;\\n    for(;i<j && s[i]===s[j];){\\n        let prevI=i;\\n        for(;s[i]===s[j];i++){}\\n        for(;s[prevI]===s[j];j--){}\\n    }\\n    const len=j-i+1;\\n    return len<0?0:len;\\n};"]}
{"id": "1359", "ref_js": ["var maximumScore = function (x, y, z) {\\n  ", "var maximumScore = function(a, b, c) {\\n  let score = 0;\\n  const array = [];\\n\\n  array.push(a, b, c)\\n  array.sort((x, y) => x - y);\\n  \\n  while (array[0] > 0 && array[2] > array[1]) {\\n    array[2]--;\\n    array[0]--;\\n    score++;\\n  }\\n  if (array[0] === 0) {\\n  score += array[1]\\n  return score;\\n  } else {\\n    if (array[0] % 2 === 0) {\\n      score += array[1] + array[0] / 2;\\n      return score;\\n    } else {\\n      score += array[1] + Math.floor(array[0] / 2);\\n      return score;\\n    }\\n  }\\n};", "var maximumScore = function(a, b, c) {\\n        var maxi = Math.max(a, Math.max(b, c));\\n        var mini = Math.min(a, Math.min(b, c));\\n\\n        var mid = a+b+c-maxi-mini;\\n        if(maxi > mid+mini){\\n            return mini+mid;\\n        }\\n        return Math.trunc((a+b+c)/2);\\n};"]}
{"id": "1360", "ref_js": ["var largestMerge = function(word1, word2) {\\n    let a = b = 0;\\n    let result = \\'\\';\\n\\n    while (a < word1.length && b < word2.length) {\\n        result += a < word1.length && word1.slice(a) > word2.slice(b)\\n            ? word1[a++]\\n            : word2[b++]\\n    }\\n    result += word1.slice(a);\\n    result += word2.slice(b);\\n    return result;\\n};", "var largestMerge = function (word1, word2) {\\n    let fir = 0, sec = 0, res = \\'\\';\\n    while (fir < word1.length && sec < word2.length) {\\n        if (word1.substring(fir) >= word2.substring(sec)) res += word1[fir++]\\n        else res += word2[sec++]\\n    }\\n    return res + word1.substring(fir) + word2.substring(sec)\\n};", "var largestMerge = function(word1, word2) {\\n    let ans = \\'\\';\\n    let w1 = 0, w2 = 0;\\n    \\n    while(w1 < word1.length && w2 < word2.length) {\\n        if(word1[w1] > word2[w2]) ans += word1[w1++];\\n        else if(word2[w2] > word1[w1]) ans += word2[w2++];\\n        else {\\n            const rest1 = word1.slice(w1);\\n            const rest2 = word2.slice(w2);\\n            \\n            if(rest1 > rest2) ans += word1[w1++];\\n            else ans += word2[w2++];\\n        }\\n    }\\n    ans += word1.slice(w1);\\n    ans += word2.slice(w2);\\n    return ans;\\n};"]}
{"id": "1361", "ref_js": ["var countHomogenous = function(s) {\\n    let res = 0;\\n    let start = 0;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== s[start]) {\\n            let appear = i - start;\\n            while (appear > 0) {\\n                res += appear;\\n                appear -= 1;\\n            }\\n            start = i;\\n        }\\n    }\\n\\n    let appear = s.length - start;\\n    while (appear > 0) {\\n        res += appear;\\n        appear -= 1;\\n    }\\n\\n    return res % (Math.pow(10, 9) + 7);\\n};", "var countHomogenous = function(s) {\\n    let left = 0;\\n    let res = 0;\\n\\n    for (let right = 0; right < s.length; right++) {\\n        if (s[left] === s[right]) {\\n            res += right - left + 1;\\n        } else {\\n            res += 1;\\n            left = right;\\n        }\\n    }\\n\\n    return res % (Math.pow(10, 9) + 7);    \\n};", "var countHomogenous = function(s) {\\n    let left = 0;\\n    let res = 0;\\n\\n    for (let right = 0; right < s.length; right++) {\\n        if (s[left] === s[right]) {\\n            res += right - left + 1;\\n        } else {\\n            res += 1;\\n            left = right;\\n        }\\n    }\\n\\n    return res % (Math.pow(10, 9) + 7);    \\n};"]}
{"id": "1362", "ref_js": ["var minimumSize = function(nums, maxOperations) {\\n    let left = 1;\\n    let right = 10 ** 9;\\n\\n    while (left < right) {\\n        const mid = Math.floor((left + right) / 2);\\n        const count = nums.reduce((result, num) => {\\n            return result + Math.floor((num - 1) / mid);\\n        }, 0);\\n\\n        count > maxOperations ? left = mid + 1 : right = mid;\\n    }\\n    return left;\\n};", "var minimumSize = function(nums, maxOperations) {\\n  let i = 1\\n  let j = Math.max(...nums)\\n  \\n  while (i <= j) {\\n    let mid = Math.floor((j-i)/2 + i)\\n    let count = 0\\n    nums.forEach(n => count += Math.floor((n-1)/mid))\\n    \\n    if (count <= maxOperations) {\\n      j = mid - 1\\n    } else {\\n      i = mid + 1\\n    }\\n  }\\n  return i\\n};", "var findBall = function(grid) {\\n    const res = []\\n    "]}
{"id": "1363", "ref_js": ["var canChoose = function(groups, nums) {\\n    ", "var canChoose = function(groups, nums) {\\n    let current = 0;\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        const group = groups[current];\\n        const size = group.length;\\n        const isMatch = group.every((num, position) => nums[index + position] === num);\\n\\n        if (!isMatch) continue;\\n        index += size - 1;\\n        current += 1;\\n        if (current > groups.length - 1) return true;\\n    }\\n    return false;\\n};", "var canChoose = function (g, a) {\\n  let srows = g.map(row => \\',\\' + row.join(\\',\\') + \\',\\')\\n  let s = \\',\\' + a.join(\\',\\') + \\',\\'\\n\\n  let i = 0\\n  for (let srow of srows) {\\n    i = s.indexOf(srow, i)\\n    if (i === -1) return false\\n    i += srow.length - 1 "]}
{"id": "1364", "ref_js": ["var highestPeak = function(isWater) {\\n    const m = isWater.length;\\n    const n = isWater[0].length;\\n    const result = Array(m).fill(\\'\\').map(_ => Array(n).fill(-1));\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    let queue = [];\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            if (!isWater[row][col]) continue;\\n            queue.push({ row, col });\\n            result[row][col] = 0;\\n        }\\n    }\\n\\n    while (queue.length) {\\n        const next = [];\\n\\n        for (const { row, col } of queue) {\\n            for (let [nextR, nextC] of dir) {\\n                nextR += row;\\n                nextC += col;\\n\\n                if (nextR >= m || nextR < 0 || nextC >= n || nextC < 0 || result[nextR][nextC] !== -1) continue;\\n                result[nextR][nextC] = result[row][col] + 1;\\n                next.push({ row: nextR, col: nextC });\\n            }\\n        }\\n        queue = next;\\n    }\\n    return result;\\n};", "var highestPeak = function(w) {\\n    const m = w.length\\n    const n = w[0].length\\n    let q = []\\n    for(let mi=0; mi<m; mi++){\\n        for(let ni=0; ni<n; ni++){\\n            if(w[mi][ni]) q.push([mi, ni])\\n        }\\n    }\\n    \\n    const pos = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n    function getCells([mi, ni]){\\n        return pos.map(([ud,lr])=>[mi+ud, ni+lr])\\n            .filter(([mj, nj])=>(mj>=0 && mj<m && nj>=0 && nj<n) && !w[mj][nj])\\n    }\\n    \\n    const h = Array(m).fill(0).map(()=>Array(n).fill(0))\\n    \\n    let i = 0 ", "var highestPeak = function(isWater) {\\n    row = isWater.length;\\n    col = isWater[0].length;\\n    \\n    let grid = new Array(row).fill(null).map(r => new Array(col).fill(null));\\n    \\n    let queue = [];\\n    for(let r in isWater){\\n        for(let c in isWater[r]){\\n            if(isWater[r][c] == 1){\\n                grid[r][c] = 0;\\n                queue.push([Number(r), Number(c), grid[r][c]]);\\n            }\\n        }\\n    }\\n    \\n    while(queue.length > 0){\\n        let [x, y, v] = queue.shift();\\n        traverse(grid, [x, y], queue, v);\\n    }\\n    \\n    return grid;\\n};"]}
{"id": "1365", "ref_js": ["var minOperations = function(boxes) {\\n    \\n    const ans = new Array(boxes.length).fill(0);\\n\\n    let ballsLeft = 0, ballsRight = 0;\\n    let movesLeft = 0, movesRight = 0;\\n\\n    const len = boxes.length - 1;\\n    \\n    for(let i = 0; i <= len; i++) {\\n       \\n       movesLeft += ballsLeft;\\n       movesRight += ballsRight;\\n       ans[i] += movesLeft;\\n       ans[len - i] += movesRight;\\n       ballsLeft += +boxes[i];\\n       ballsRight += +boxes[len - i];\\n    }\\n\\n    return ans;\\n};", "var minOperations = function(boxes) {\\n    \\n    const ans = new Array(boxes.length).fill(0);\\n\\n    let ballsLeft = 0, ballsRight = 0;\\n    let movesLeft = 0, movesRight = 0;\\n\\n    const len = boxes.length - 1;\\n    \\n    for(let i = 0; i <= len; i++) {\\n       \\n       movesLeft += ballsLeft;\\n       movesRight += ballsRight;\\n       ans[i] += movesLeft;\\n       ans[len - i] += movesRight;\\n       ballsLeft += +boxes[i];\\n       ballsRight += +boxes[len - i];\\n    }\\n\\n    return ans;\\n};", "var minOperations = function(boxes) {\\n    \\n    const ans = new Array(boxes.length).fill(0);\\n\\n    let ballsLeft = 0, ballsRight = 0;\\n    let movesLeft = 0, movesRight = 0;\\n\\n    const len = boxes.length - 1;\\n    \\n    for(let i = 0; i <= len; i++) {\\n       \\n       movesLeft += ballsLeft;\\n       movesRight += ballsRight;\\n       ans[i] += movesLeft;\\n       ans[len - i] += movesRight;\\n       ballsLeft += +boxes[i];\\n       ballsRight += +boxes[len - i];\\n    }\\n\\n    return ans;\\n};"]}
{"id": "1366", "ref_js": ["var closestCost = function(baseCosts, toppingCosts, target) {\\n    let res = Infinity;\\n    \\n    function dfs(tIdx, cur) {\\n        if(Math.abs(target-cur) < Math.abs(target-res) ||(Math.abs(target-cur) === Math.abs(target-res) && cur < target)) {\\n            res = cur;\\n        }\\n        \\n        if(cur > target || tIdx >= toppingCosts.length) {\\n            return;\\n        }\\n        \\n        dfs(tIdx + 1, cur);\\n        dfs(tIdx + 1, cur + toppingCosts[tIdx]);\\n        dfs(tIdx + 1, cur + toppingCosts[tIdx] * 2); \\n    }\\n    \\n    for(const base of baseCosts) {\\n        dfs(0, base);\\n    }\\n   return res;  \\n};", "var closestCost = function(baseCosts, toppingCosts, target) {\\n    let result = Number.MAX_SAFE_INTEGER;\\n    const toppingSize = toppingCosts.length;\\n    const addTopping = (cost, index) => {\\n        if (Math.abs(target - cost) < Math.abs(target - result)) result = cost;\\n        if (Math.abs(target - cost) === Math.abs(target - result) && cost < result) {\\n            result = cost;\\n        }\\n        if (index >= toppingSize) return;\\n        const toppingCost = toppingCosts[index];\\n\\n        addTopping(cost, index + 1);\\n        addTopping(cost + toppingCost, index + 1);\\n        addTopping(cost + toppingCost * 2, index + 1);\\n    };", "var closestCost = function(baseCosts, toppingCosts, target) {\\n    let closestCost = 1e9, n = toppingCosts.length;\\n    const visited = Array.from({ length: n + 1 }, () => new Set());\\n\\n    const recursion = (idx, cost) => {\\n        if (visited[idx].has(cost)) return;\\n\\n        if (cost < target) {\\n            if (Math.abs(target - cost) <= Math.abs(closestCost - target))\\n                closestCost = cost;\\n            if (idx == n) return;\\n            for (let j = 0; j <= 2; j++)\\n                recursion(idx + 1, cost + j * toppingCosts[idx])\\n        } else if (Math.abs(target - cost) < Math.abs(closestCost - target))\\n            closestCost = cost;\\n\\n        visited[idx].add(cost);\\n    };"]}
{"id": "1367", "ref_js": ["var minOperations = function(nums1, nums2) {\\n    const size1 = nums1.length;\\n    const size2 = nums2.length;\\n    if (size1 * 6 < size2 || size1 > size2 * 6) return -1;\\n\\n    const sum1 = nums1.reduce((sum, num) => sum + num);\\n    const sum2 = nums2.reduce((sum, num) => sum + num);\\n    const operations = (a, b) => {\\n        let left = result = 0;\\n        let right = b.nums.length - 1;\\n\\n        while (a.sum < b.sum) {\\n            right < 0 || left < a.nums.length && 6 - a.nums[left] > b.nums[right] - 1\\n                ? a.sum += 6 - a.nums[left++]\\n                : b.sum -= b.nums[right--] - 1;\\n\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    nums1.sort((a, b) => a - b);\\n    nums2.sort((a, b) => a - b);\\n    return sum1 < sum2 \\n        ? operations({ nums: nums1, sum: sum1 }, { nums: nums2, sum: sum2 })\\n        : operations({ nums: nums2, sum: sum2 }, { nums: nums1, sum: sum1 });\\n};", "var minOperations = function(nums1, nums2) {\\n    nums1.sort((a,b)=>a-b);nums2.sort((a,b)=>a-b);\\n    const num1Sum=nums1.reduce((acc,cur)=>acc+cur), num2Sum=nums2.reduce((acc,cur)=>acc+cur);\\n    let diff=Math.abs(num1Sum-num2Sum);\\n\\n    const pq=new MaxPriorityQueue({priority:(bid)=>bid});\\n    if(num1Sum>num2Sum){\\n        for(let i=0;i<nums1.length;i++) pq.enqueue(nums1[i]-1);\\n        for(let i=0;i<nums2.length;i++) pq.enqueue(6-nums2[i]);    \\n    }else{\\n        for(let i=0;i<nums2.length;i++) pq.enqueue(nums2[i]-1);\\n        for(let i=0;i<nums1.length;i++) pq.enqueue(6-nums1[i]); \\n    }\\n\\n    let ans=0\\n    while(pq.size()>0 && diff>0){\\n        ans++;\\n        diff-=pq.dequeue().element;\\n    }\\n\\n    return diff<=0?ans:-1;\\n};", "var minOperations = function(nums1, nums2) {\\n    nums1.sort((a,b)=>a-b);nums2.sort((a,b)=>a-b);\\n    const num1Sum=nums1.reduce((acc,cur)=>acc+cur), num2Sum=nums2.reduce((acc,cur)=>acc+cur);\\n    let diff=Math.abs(num1Sum-num2Sum);\\n\\n    const pq=new MaxPriorityQueue({priority:(bid)=>bid});\\n    if(num1Sum>num2Sum){\\n        for(let i=0;i<nums1.length;i++) pq.enqueue(nums1[i]-1);\\n        for(let i=0;i<nums2.length;i++) pq.enqueue(6-nums2[i]);    \\n    }else{\\n        for(let i=0;i<nums2.length;i++) pq.enqueue(nums2[i]-1);\\n        for(let i=0;i<nums1.length;i++) pq.enqueue(6-nums1[i]); \\n    }\\n\\n    let ans=0\\n    while(pq.size()>0 && diff>0){\\n        ans++;\\n        diff-=pq.dequeue().element;\\n    }\\n\\n    return diff<=0?ans:-1;\\n};"]}
{"id": "1368", "ref_js": ["var checkPowersOfThree = function(n) {\\n   while(n>1){\\n       if(n%3==1){ n--; } ", "var checkPowersOfThree = function(n) {\\n   while(n>1){\\n       if(n%3==1){ n--; } ", "var checkPowersOfThree = function(n) {\\n   while(n>1){\\n       if(n%3==1){ n--; } "]}
{"id": "1369", "ref_js": ["var beautySum = function(s) {\\n    let result=0;\\n    let map = new Map();\\n\\n    for (let i=0;i<s.length;i++){\\n        map.set(s[i],1);\\n        for(let j=i+1;j<s.length;j++){\\n            if(map.has(s[j])){\\n                map.set(s[j],map.get(s[j])+1);\\n\\n            }else{\\n                map.set(s[j],1)\\n            }\\n            if(map.size >=2){\\n                result+=freq(map);\\n            }\\n        }\\n        map.clear();\\n    }\\n    return result;\\n};", "var beautySum = function(s) {\\n    const len = s.length;\\n    \\n    let ans = 0;\\n    const freq = new Array(26).fill(0);\\n    \\n    for(let i = 0; i < len; i++) {\\n        freq[s[i].charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n        for(let j = i + 1; j < len; j++) {\\n            freq[s[j].charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n            ans += minMaxDiff(freq);\\n        }\\n        freq.fill(0);\\n    }\\n    \\n    function minMaxDiff(freq) {\\n        freq = freq.filter(f => f != 0);\\n        return Math.max(...freq) - Math.min(...freq);\\n    }\\n    \\n    return ans;\\n};", "var beautySum = function(s) {\\n\\n    function calculateBeauty(charFreq) {\\n        let minFreq = Infinity;\\n        let maxFreq = 0;\\n        for (let freq of charFreq) {\\n        if (freq > maxFreq) {\\n            maxFreq = freq;\\n        }\\n        if (freq > 0 && freq < minFreq) {\\n            minFreq = freq;\\n        }\\n        }\\n        return maxFreq-minFreq;\\n    }\\n\\n    let sum = 0;\\n    for(let i=0; i<s.length; i++) {\\n        const charFreq = Array(26).fill(0);\\n        for(let j=i; j<s.length; j++) {\\n            charFreq[s.charCodeAt(j) - \\'a\\'.charCodeAt(0)]++;\\n            sum += calculateBeauty(charFreq);\\n        }\\n    }\\n    return sum;\\n};"]}
{"id": "1370", "ref_js": ["var minElements = function (nums, limit, goal) {\\n  let sum = nums.reduce((sum, e) => sum + e, 0)\\n\\n  let cc = 0\\n  for (let lim = limit; lim >= 1; lim--) {\\n    let need = goal - sum\\n    if (need === 0) return cc\\n\\n    if (lim <= Math.abs(need)) {\\n      let q = Math.abs(Math.trunc(need / lim))\\n      cc += q\\n      sum += q * (need < 0 ? -lim : lim)\\n    }\\n  }\\n  return cc\\n};", "var minElements = function(nums, limit, goal) {\\n    var sum = 0\\n    for(var i = 0; i<nums.length; i++) sum += nums[i]\\n    if(sum === goal) return 0\\n    var diff = Math.abs(goal - sum)\\n\\n    if(diff <= limit) return 1\\n\\n    if(diff % limit == 0) return diff/limit\\n    var ans = Math.floor(diff/limit) + 1\\n    return ans\\n\\n};", "var minElements = function(nums, limit, goal) {\\n    const sum = nums.reduce((result, num) => result + num);\\n\\n    return Math.ceil(Math.abs(goal - sum) / limit);\\n};"]}
{"id": "1371", "ref_js": ["var countRestrictedPaths = function(n, edges) {\\n    const MODULO = 10 ** 9 + 7;\\n    const graph = edges.reduce((map, [u, v, weight]) => {\\n        (map[u] = map[u] ?? []).push({ edge: v, weight });\\n        (map[v] = map[v] ?? []).push({ edge: u, weight });\\n        return map;\\n    }, {});\\n    const queue = [n];\\n    const distances = Array(n + 1).fill(Number.MAX_SAFE_INTEGER);\\n    const status = Array(n + 1).fill(\\'not visited\\');\\n    const countMap = new Map([[n, 1]]);\\n    const restrictedPaths = (node) => {\\n        if (countMap.has(node)) return countMap.get(node);\\n        const count = graph[node].reduce((result, { edge }) => {\\n            const num = distances[edge] < distances[node] ? restrictedPaths(edge) : 0;\\n\\n            return (result + num) % MODULO;\\n        }, 0);\\n\\n        countMap.set(node, count);\\n        return count;\\n    };", "var countRestrictedPaths = function(n, edges) {\\n    const g = Array.from({ length: n + 1}, () => []);\\n    for(let [a, b, c] of edges) {\\n        g[a].push([b, c]);\\n        g[b].push([a, c]);\\n    }\\n    ", "var countRestrictedPaths = function(n, edges) {\\n    "]}
{"id": "1372", "ref_js": ["var maxAverageRatio = function(classes, extraStudents) {\\n    const queue = new MaxPriorityQueue({ priority: x => x.ratio });\\n    const enqueue = (pass, total) => {\\n        const beforeRatio = pass / total;\\n        const afterRatio = (pass + 1) / (total + 1);\\n\\n        queue.enqueue({ pass, total, ratio: afterRatio - beforeRatio });\\n    }\\n    let totalRatio = 0;\\n\\n    for (const [pass, total] of classes) {\\n        enqueue(pass, total);\\n    }\\n    while (extraStudents--) {\\n        const { pass, total } = queue.dequeue().element;\\n        \\n        enqueue(pass + 1, total + 1);\\n    }\\n    while (!queue.isEmpty()) {\\n        const { pass, total } = queue.dequeue().element;\\n\\n        totalRatio += pass / total;\\n    }\\n    return totalRatio / classes.length;\\n};", "var maxAverageRatio = function(classes, extraStudents) {\\n    const n = classes.length;\\n\\n    ", "var maxAverageRatio = function(classes, extraStudents) {\\n    "]}
{"id": "1374", "ref_js": ["var getMaximumConsecutive = function (coins) {\\ncoins.sort((a,b) => a- b);\\nlet reach = 0;\\nlet i = 0;\\nwhile (i < coins.length) {\\nif (i < coins.length && coins[i] <= reach + 1) {\\nreach += coins[i];\\ni++;\\n} else {\\nbreak;\\n}\\n}\\nreturn reach + 1;\\n};", "var getMaximumConsecutive = function(coins) {\\n    let result = 1;\\n\\n    coins.sort((a, b) => a - b);\\n\\n    for (const coin of coins) {\\n        if (coin > result) return result;\\n        result += coin;\\n    }\\n    return result;\\n};", "var getMaximumConsecutive = function (coins) {\\n    coins.sort((a,b) => a- b);\\n  let reach = 0;\\n  let i = 0;\\n  while (i < coins.length) {\\n    if (i < coins.length && coins[i] <= reach + 1) {\\n      reach += coins[i];\\n      i++;\\n    } else {\\n      break;\\n    }\\n  }\\n  return reach + 1;\\n};"]}
{"id": "1375", "ref_js": ["var getNumberOfBacklogOrders = function(orders) {\\n    const MODULO = 10 ** 9 + 7;\\n    const buyQueue = new MaxPriorityQueue({ priority:x => x.price });\\n    const sellQueue = new MinPriorityQueue({ priority:x => x.price });\\n    const comparePrice = ({ isBuy, price, checkQueue }) => {\\n        const backlogPrice = checkQueue.front().element.price;\\n\\n        return isBuy ? backlogPrice <= price : backlogPrice >= price;\\n    };", "var getNumberOfBacklogOrders = function(orders) {\\n    const buyHeap = new Heap((child, parent) => child.price > parent.price)\\n    const sellHeap = new Heap((child, parent) => child.price < parent.price)\\n    \\n    for (let [price, amount, orderType] of orders) {\\n        \\n        ", "var getNumberOfBacklogOrders = function(orders) {\\n    const MODULO = 10 ** 9 + 7;\\n    const buyQueue = new MaxPriorityQueue({ priority:x => x.price });\\n    const sellQueue = new MinPriorityQueue({ priority:x => x.price });\\n    const comparePrice = ({ isBuy, price, checkQueue }) => {\\n        const backlogPrice = checkQueue.front().element.price;\\n\\n        return isBuy ? backlogPrice <= price : backlogPrice >= price;\\n    };"]}
{"id": "1376", "ref_js": ["var maxValue = function(n, index, maxSum) {\\n    let answer = 1\\n    let sum = n\\n    let pointerA = index\\n    let pointerB = index\\n    while(sum < maxSum) {\\n        if (pointerB - pointerA === n-1) {\\n            answer+= Math.floor((maxSum - sum) / n )\\n            break;\\n        }\\n        sum += pointerB - pointerA + 1\\n        if (sum <= maxSum) answer++\\n        if (pointerB < n-1) pointerB++\\n        if (pointerA > 0) pointerA--\\n    }\\n    return answer\\n\\n};", "var maxValue = function(n, index, maxSum) {\\n    if(n == 1) return maxSum;\\n    const l = index;\\n    const r = n-index-1;\\n    const sumSide = (x, count) => {\\n        if(x > count) {\\n            ", "var maxValue = function(n, index, maxSum) {\\n    if(n == 1) return maxSum;\\n    const r = n-index-1;\\n    const sumSide = (x, count) => {\\n        if(x > count) {\\n            return (2*x-count-1)*count/2\\n        }\\n        else {\\n            return (x-1)*x/2+count-x+1;\\n        }\\n    }\\n    let valL = 0;\\n    let valR = maxSum;\\n    while(valR - valL > 1) {\\n        const mid = Math.floor((valR + valL) / 2);\\n        if(sumSide(mid, index)+sumSide(mid, r)+mid <= maxSum) valL = mid;\\n        else valR = mid;\\n    }\\n    return valL;\\n};"]}
{"id": "1377", "ref_js": ["var reinitializePermutation = function(n) {\\n    const BASE_INDEX = 1;\\n    let result = 1;\\n    let index = n / 2 + (BASE_INDEX - 1) / 2;\\n\\n    while (index !== BASE_INDEX) {\\n        index = index % 2\\n            ? n / 2 + (index - 1) / 2\\n            : index / 2;\\n        result += 1;\\n    }\\n    return result;\\n};", "var reinitializePermutation = function(n) {\\n    let perm =  []\\n   for(let i=0; i<n; i++){\\n       perm.push(i);\\n   }\\n   let res = 0;\\n   function dfs(arr){\\n       let arr2 = [];\\n       if(isEqual(arr, perm) && res>0) return;\\n       res++;\\n       for(let i =0; i<n; i++){\\n           if(i%2==0){\\n               arr2[i] = arr[i/2];\\n           }else{\\n               arr2[i] = arr[n/2 + (i-1)/2];\\n           }\\n       }\\n       dfs(arr2);\\n   }\\n   dfs(perm);\\n  return res;\\n};", "var reinitializePermutation = function(n) {\\n    const BASE_INDEX = 1;\\n    let result = 1;\\n    let index = n / 2 + (BASE_INDEX - 1) / 2;\\n\\n    while (index !== BASE_INDEX) {\\n        index = index % 2\\n            ? n / 2 + (index - 1) / 2\\n            : index / 2;\\n        result += 1;\\n    }\\n    return result;\\n};"]}
{"id": "1378", "ref_js": ["var evaluate = function(s, knowledge) {\\n    const knowledgeMap = knowledge.reduce((map, [key, value]) => {\\n        return map[key] = value, map;\\n    }, {});\\n    let result = key = \\'\\';\\n    let isStart = false;\\n\\n    for (const char of s) {\\n        if (char === \\'(\\') isStart = true;\\n        else if (char === \\')\\') {\\n            result += knowledgeMap[key] ?? \\'?\\';\\n            isStart = false;\\n            key = \\'\\';\\n        } else {\\n            isStart ? key += char : result += char;\\n        }\\n    }\\n    return result;\\n};", "var evaluate = function(s, knowledge) {\\n    let stack = [];\\n    let hash = {};", "var evaluate = function(s, knowledge) {\\n    let stack = [];\\n    let hash = {};"]}
{"id": "1379", "ref_js": ["var areSentencesSimilar = function(s1, s2) {\\n    ", "var areSentencesSimilar = function(sentence1, sentence2) {\\n    const chars1 = sentence1.split(\\' \\');\\n    const chars2 = sentence2.split(\\' \\');\\n\\n    while (chars1.length && chars2.length && chars1[0] === chars2[0]) {\\n        chars1.shift();\\n        chars2.shift();\\n    }\\n\\n    while (chars1.length && chars2.length && chars1.at(-1) === chars2.at(-1)) {\\n        chars1.pop();\\n        chars2.pop();\\n    }\\n    return !chars1.length || !chars2.length;\\n};", "var areSentencesSimilar = function(s1, s2) {\\n    "]}
{"id": "1380", "ref_js": ["var countNicePairs = function(nums) {\\n    let nicePairs = 0;\\n    let mod = 10 ** 9 + 7;\\n    let hash = {};", "var countNicePairs = function(nums) {\\n    let nicePairs = 0;\\n    let mod = 10 ** 9 + 7;\\n    let hash = {};", "var countNicePairs = function(nums) {\\n    let nicePairs = 0;\\n    let mod = 10 ** 9 + 7;\\n    let hash = {};"]}
{"id": "1381", "ref_js": ["var findingUsersActiveMinutes = function(logs, k) {\\n    const map = new Map();\\n    \\n    for (const [userID, minute] of logs) {\\n        if (!map.has(userID)) map.set(userID, new Set());\\n        map.get(userID).add(minute);\\n    }\\n    \\n    const count = new Array(k).fill(0);\\n    \\n    for (const actions of map.values()) {\\n        count[actions.size - 1]++;\\n    }\\n    \\n    return count;\\n};", "var findingUsersActiveMinutes = function(logs, k) {\\n    const res = Array(k).fill(0);\\n    const map = {};", "var findingUsersActiveMinutes = function(logs, k) {\\n    const map = new Map();\\n    \\n    for (const [userID, minute] of logs) {\\n        if (!map.has(userID)) map.set(userID, new Set());\\n        map.get(userID).add(minute);\\n    }\\n    \\n    const count = new Array(k).fill(0);\\n    \\n    for (const actions of map.values()) {\\n        count[actions.size - 1]++;\\n    }\\n    \\n    return count;\\n};"]}
{"id": "1382", "ref_js": ["var minAbsoluteSumDiff = function(nums1, nums2) {\\n    const MOD = 1e9 + 7;\\n    const n = nums1.length;\\n    \\n    const origDiffs = [];\\n    let diffSum = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        const num1 = nums1[i];\\n        const num2 = nums2[i];\\n\\n        const currDiff = Math.abs(num1 - num2);\\n\\n        origDiffs[i] = currDiff;\\n        diffSum += currDiff;\\n    }\\n    \\n    nums1.sort((a, b) => a - b);\\n    \\n    let minDiffSum = diffSum;\\n    \\n    for (let i = 0; i < n; i++) {\\n        const origDiff = origDiffs[i];\\n        \\n        const num2 = nums2[i];\\n        \\n        let left = 0;\\n        let right = n - 1;\\n        \\n        let bestDiff = origDiff;\\n        \\n        while (left <= right) {\\n            const mid = (left + right) >> 1;\\n            const num1 = nums1[mid]; \\n           \\n            const candDiff = num1 - num2;\\n           \\n            if (Math.abs(candDiff) < bestDiff) {\\n                bestDiff = Math.abs(candDiff);\\n                if (bestDiff === 0) break;\\n            }\\n            \\n            if (candDiff < 0) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        \\n        const replacedDiffSum = (diffSum - origDiff) + bestDiff;\\n        \\n        minDiffSum = Math.min(minDiffSum, replacedDiffSum);\\n    }\\n    \\n    return minDiffSum % MOD;\\n};", "var minAbsoluteSumDiff = function(nums1, nums2) {\\n    let sum = 0;\\n    const dists = [];\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        const dist = Math.abs(nums1[i] - nums2[i]);\\n        dists.push(dist);\\n        sum += dist;\\n    }\\n\\n    nums1 = nums1.sort((a, b) => a - b);\\n\\n    let ans = sum;\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        let left = 0;\\n        let right = nums1.length - 1;\\n        \\n        const oldDist = dists[i];\\n        let newDist = oldDist;\\n        \\n        while (left <= right) {\\n            const j = Math.floor((left + right) / 2);\\n            const diff = nums1[j] - nums2[i];\\n            const dist = Math.abs(diff);\\n            \\n            if (dist < newDist) {\\n                newDist = dist;\\n                \\n                if (newDist === 0) {\\n                    break;\\n                }\\n            }\\n            \\n            if (diff < 0) {\\n                left = j + 1;\\n            } else {\\n                right = j - 1;\\n            }\\n        }\\n\\n        ans = Math.min(ans, (sum - oldDist) + newDist);\\n    }\\n\\n    \\n    return ans % (1e9 + 7);\\n};", "var minAbsoluteSumDiff = function(nums1, nums2) {\\n    const MODULO = 10 ** 9 + 7;\\n    const clone = [...nums1].sort((a, b) => a - b);\\n    const size = nums1.length;\\n    const findNearPosition = (target) => {\\n        let left = 0;\\n        let right = size - 1;\\n\\n        if (clone[right] < target) return right + 1;\\n        while (left < right) {\\n            const mid = Math.floor((left + right) / 2);\\n\\n            clone[mid] < target ? left = mid + 1 : right = mid;\\n        }\\n        return left;\\n    };"]}
{"id": "1383", "ref_js": ["var findTheWinner = function(n, k) {\\n    const array = Array.from({ length: n }, (_, index) => index + 1);\\n    var i=0;\\n    while (array.length > 1) {\\n        i = (i + k - 1) % array.length;\\n        array.splice(i, 1);\\n    }\\n    return array[0]\\n};", "var findTheWinner = function(n, k) {\\n   let y=n;\\n    function ans(n,k){\\n        if(n==1){\\n            return 0;\\n        }\\n        else{\\n            return (ans(n-1,k)+k)%(n);    \\n        }\\n    }\\n    \\n    return ans(n,k)+1;\\n};", "var findTheWinner = function(n, k) {\\n    const array = Array.from({ length: n }, (_, index) => index + 1);\\n    var i=0;\\n    while (array.length > 1) {\\n        i = (i + k - 1) % array.length;\\n        array.splice(i, 1);\\n    }\\n    return array[0]\\n};"]}
{"id": "1384", "ref_js": ["var minSideJumps = function(obstacles) {\\n    const MAX_OBSTACLES = 5 * 10 ** 5;\\n    let land1 = land3 = 1;\\n    let land2 = 0;\\n\\n    for (const obstacle of obstacles) {\\n        land1 = obstacle !== 1 ? land1 : MAX_OBSTACLES;\\n        land2 = obstacle !== 2 ? land2 : MAX_OBSTACLES;\\n        land3 = obstacle !== 3 ? land3 : MAX_OBSTACLES;\\n\\n        if (obstacle !== 1) {\\n            land1 = Math.min(land1, Math.min(land2, land3) + 1);\\n        }\\n        if (obstacle !== 2) {\\n            land2 = Math.min(land2, Math.min(land1, land3) + 1);\\n        }\\n        if (obstacle !== 3) {\\n            land3 = Math.min(land3, Math.min(land1, land2) + 1);\\n        }\\n    }\\n    return Math.min(land1, land2, land3);\\n};", "var solve = function(obstacles, lane, pos, dp) {\\n", "var minSideJumps = function(obstacles) {\\n    let table = [0,0,0]\\n    for (let i = obstacles.length -2; i >= 0; i--) {\\n        temp = [0,0,0]\\n        temp[0] = Math.min(\\n            obstacles[i] === 1 ? Infinity: table[0], \\n            obstacles[i] === 2 ? Infinity: table[1] + 1, \\n            obstacles[i] === 3 ? Infinity: table[2] + 1)\\n        \\n        temp[1] = Math.min(\\n            obstacles[i] === 1 ? Infinity: table[0] + 1, \\n            obstacles[i] === 2 ? Infinity: table[1] , \\n            obstacles[i] === 3 ? Infinity: table[2] + 1)\\n        temp[2] = Math.min(\\n            obstacles[i] === 1 ? Infinity: table[0] + 1, \\n            obstacles[i] === 2 ? Infinity: table[1] + 1, \\n            obstacles[i] === 3 ? Infinity: table[2])\\n        if (obstacles[i]) {\\n            temp[obstacles[i] - 1] = Infinity\\n        }\\n        table = temp\\n    }\\n    return table[1]\\n};"]}
{"id": "1385", "ref_js": ["var countPoints = function (points, queries) {\\n    const ansArray = queries.map(([x, y, r]) => {\\n        let pointCount = 0;\\n        for (const [x1, y1] of points) {\\n            if (Math.sqrt((x1 - x) ** 2 + (y1 - y) ** 2) <= r) {\\n                pointCount = pointCount + 1;\\n            }\\n        }\\n        return pointCount;\\n    });\\n    return ansArray;\\n};", "var countPoints = function (points, queries) {\\n    const ansArray = queries.map(([x, y, r]) => {\\n        let pointCount = 0;\\n        for (const [x1, y1] of points) {\\n            if (Math.sqrt((x1 - x) ** 2 + (y1 - y) ** 2) <= r) {\\n                pointCount = pointCount + 1;\\n            }\\n        }\\n        return pointCount;\\n    });\\n    return ansArray;\\n};", "var countPoints = function (points, queries) {\\n    const ansArray = queries.map(([x, y, r]) => {\\n        let pointCount = 0;\\n        for (const [x1, y1] of points) {\\n            if (Math.sqrt((x1 - x) ** 2 + (y1 - y) ** 2) <= r) {\\n                pointCount = pointCount + 1;\\n            }\\n        }\\n        return pointCount;\\n    });\\n    return ansArray;\\n};"]}
{"id": "1386", "ref_js": ["var getMaximumXor = function(nums, maximumBit) {\\n    let xor = (1 << maximumBit) - 1\\n    for(let i=0; i<nums.length; i++){\\n        xor ^= nums[i]\\n        nums[i] = xor\\n    }\\n    return nums.reverse()\\n};", "var getMaximumXor = function(nums, maximumBit) {\\n    const max = (1 << maximumBit) - 1;\\n    let current = 0;\\n\\n    return nums.map(num => {\\n        current ^= num;\\n        return max ^ current;\\n    }).reverse();\\n};", "var getMaximumXor = function (nums, maximumBit) {\\n    let xor = (1 << maximumBit) - 1;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        xor ^= nums[i];\\n        nums[i] = xor;\\n    }\\n    return nums.reverse();\\n};"]}
{"id": "1387", "ref_js": ["var maxIceCream = function(costs, coins) {\\n", "var maxIceCream = function(costs, coins) {\\n    let total = 0;\\n    let count = 0;\\n    costs.sort((a,b)=>a-b)\\n    for(let i of costs){\\n        total+= i;\\n        if(total>coins) break;\\n        count++\\n\\n    }  \\n    return count\\n};", "var maxIceCream = function(costs, coins) {\\n"]}
{"id": "1388", "ref_js": ["var getOrder = function(tasks) {\\n    let n = tasks.length;\\n    tempTasks= tasks.map((val, i) => [...val, i])\\n    tempTasks.sort((a, b) => a[0] - b [0]);\\n\\n    let res = [];\\n    let pQ = [];\\n    let cTime = tempTasks[0][0];\\n    let enqueueIndex = 0;\\n    while(n > res.length) {\\n        if(pQ.length == 0 && cTime < tempTasks[enqueueIndex][0]) {\\n            cTime = tempTasks[enqueueIndex][0]\\n        }\\n\\n        let curSize = pQ.length\\n        while(enqueueIndex < n && tempTasks[enqueueIndex][0] <= cTime){\\n            pQ.push(tempTasks[enqueueIndex]);\\n            enqueueIndex++;\\n        }\\n\\n        if(curSize < pQ.length) {\\n            pQ.sort((a,b) => {\\n                if(a[1] == b[1]) return a[2] - b[2]\\n                else return a[1] - b[1]\\n            })\\n        } \\n        let curTask = pQ.shift()\\n        res.push(curTask[2])\\n        cTime += curTask[1]\\n    }\\n\\n    return res\\n\\n};", "var getOrder = function(tasks) {\\n    const minHeap = new MinHeap([])\\n\\n    const ans = []\\n\\n    tasks.map((item, index) => item[2] = index) ", "var getOrder = function(tasks) {\\n    let n = tasks.length;\\n    tempTasks= tasks.map((val, i) => [...val, i])\\n    tempTasks.sort((a, b) => a[0] - b [0]);\\n\\n    let res = [];\\n    let pQ = [];\\n    let cTime = tempTasks[0][0];\\n    let enqueueIndex = 0;\\n    while(n > res.length) {\\n        if(pQ.length == 0 && cTime < tempTasks[enqueueIndex][0]) {\\n            cTime = tempTasks[enqueueIndex][0]\\n        }\\n\\n        let curSize = pQ.length\\n        while(enqueueIndex < n && tempTasks[enqueueIndex][0] <= cTime){\\n            pQ.push(tempTasks[enqueueIndex]);\\n            enqueueIndex++;\\n        }\\n\\n        if(curSize < pQ.length) {\\n            pQ.sort((a,b) => {\\n                if(a[1] == b[1]) return a[2] - b[2]\\n                else return a[1] - b[1]\\n            })\\n        } \\n        let curTask = pQ.shift()\\n        res.push(curTask[2])\\n        cTime += curTask[1]\\n    }\\n\\n    return res\\n\\n};"]}
{"id": "1389", "ref_js": ["var maxFrequency = function(nums, k) {\\n    let maxFrequency = 0; ", "var maxFrequency = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n    let left = 0, right = 0, res = 0, total = 0;\\n\\n    while (right < nums.length) {\\n        total += nums[right];\\n\\n        while (nums[right] * (right - left + 1) > total + k) {\\n            total -= nums[left];\\n            left += 1;\\n        }\\n\\n        res = Math.max(res, right - left + 1);\\n        right += 1;\\n    }\\n\\n    return res;    \\n};", "var maxFrequency = function(nums, k) {\\n    nums.sort((a, b) => a-b);\\n    let maxFreq = 0, currSum  = 0;\\n\\n    for(let l = 0, r = 0; r < nums.length; r++){\\n        currSum += nums[r];\\n        while(currSum + k < nums[r] * (r-l+1)){\\n            currSum -= nums[l];\\n            l++;\\n        }\\n        maxFreq = Math.max(maxFreq, r-l+1);\\n    }\\n    return maxFreq;\\n};"]}
{"id": "1390", "ref_js": ["var isSorted = function (word1, word2) {\\n    return word1 < word2 || word1 === word2\\n}\\n\\nvar longestBeautifulSubstring = function (word) {\\n    let longest = 0;\\n\\n    let i = 0, j = 1;\\n\\n    while (i < j && j < word.length) {\\n        let cnt = 1;\\n        let str = new Set();\\n        while (isSorted(word[i], word[j])) {\\n            str.add(word[i]);\\n            cnt++;\\n            i++;\\n            j++;\\n        }\\n        str.add(word[i]);\\n        i++;\\n        j++;\\n        if (str.size === 5) {\\n            longest = Math.max(longest, cnt);\\n        }\\n    }\\n\\n    return longest;\\n};", "var longestBeautifulSubstring = function(word) {\\n    const MAX_SIZE = 5;\\n    let left = result = 0;\\n    let vowelCount = 1;\\n\\n    for (let index = 1; index < word.length; index++) {\\n        const char = word[index];\\n        const preChar = word[index - 1];\\n\\n        if (char < preChar) {\\n            vowelCount = 1;\\n            left = index;\\n        }\\n        if (char > preChar) vowelCount += 1;\\n        if (vowelCount !== MAX_SIZE) continue;\\n        result = Math.max(index - left + 1, result);\\n    }\\n    return result;\\n};", "var longestBeautifulSubstring = function(word) {\\n    let left = 0;\\n    let right = 0;\\n    let map = { a: 0, e: 0, i: 0, o: 0, u: 0};"]}
{"id": "1392", "ref_js": ["var maximumElementAfterDecrementingAndRearranging = function(arr) {\\n    arr.sort((a, b) => a - b);\\n    let maxVal = 1;\\n\\n    for (let i = 1; i < arr.length; i++) {\\n        if (arr[i] > maxVal) {\\n            maxVal += 1;\\n        }\\n    }\\n\\n    return maxVal;    \\n};", "var maximumElementAfterDecrementingAndRearranging = function(arr) {\\n    arr.sort(function(a,b) {return a-b});\\n    arr[0] = 1;\\n    let bckp = arr[0];\\n    for(let i=1; i<arr.length; i++) {\\n        if(Math.abs(arr[i]-bckp) > 1) arr[i] = bckp + 1;\\n        bckp = arr[i];\\n    }\\n    return Math.max.apply(null, arr);\\n};", "var maximumElementAfterDecrementingAndRearranging = function(arr) {\\n    arr.sort(function(a,b) {return a-b});\\n    arr[0] = 1;\\n    let bckp = arr[0];\\n    for(let i=1; i<arr.length; i++) {\\n        if(Math.abs(arr[i]-bckp) > 1) arr[i] = bckp + 1;\\n        bckp = arr[i];\\n    }\\n    return Math.max.apply(null, arr);\\n};"]}
{"id": "1393", "ref_js": ["var splitString = function(s) {\\n    const size = s.length;\\n    const isValid = (start, target) => {\\n        for (let index = start; index < size; index++) {\\n            const value = +s.slice(start, index + 1);\\n\\n            if (target - value !== 1) continue;\\n            if (index === size - 1) return true;\\n            if (isValid(index + 1, value)) return true;\\n        }\\n        return false;\\n    };", "var splitString = function(s) {\\n    \\n    let [subset,status] = [[],false];\\n\\n    function dfs(index){\\n           ", "var splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};"]}
{"id": "1394", "ref_js": ["var getMinSwaps = function(num, k) {\\n    const size = num.length;\\n    const digits = [...num];\\n    const swapDigit = (a, b) => [digits[a], digits[b]] = [digits[b], digits[a]];\\n    const reverseDigit = (start, end = size - 1) => {\\n        while (start < end) swapDigit(start++, end--);\\n    };", "var getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};", "var getMinSwaps = function(num, k) {\\n    const size = num.length;\\n    const digits = [...num];\\n    const swapDigit = (a, b) => [digits[a], digits[b]] = [digits[b], digits[a]];\\n    const reverseDigit = (start, end = size - 1) => {\\n        while (start < end) swapDigit(start++, end--);\\n    };"]}
{"id": "1395", "ref_js": ["var maxDistance = function(nums1, nums2) {\\n    let i = 0, j = 0;\\n    \\n    let ans = 0;\\n    while (i < nums1.length && j < nums2.length) {\\n        ", "var maxDistance = function(nums1, nums2) {\\n    const MAX_SIZE = nums2.length;\\n    let result = end = 0;\\n\\n    for (let start = 0; start < nums1.length; start++) {\\n        const num1 = nums1[start];\\n\\n        while (end < MAX_SIZE && num1 <= nums2[end]) {\\n            result = Math.max(end - start, result);\\n            end += 1; \\n        }\\n    }\\n    return result;\\n};", "var maxDistance = function(nums1, nums2) {\\n    const MAX_SIZE = nums2.length;\\n    let result = end = 0;\\n\\n    for (let start = 0; start < nums1.length; start++) {\\n        const num1 = nums1[start];\\n\\n        while (end < MAX_SIZE && num1 <= nums2[end]) {\\n            result = Math.max(end - start, result);\\n            end += 1; \\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1396", "ref_js": ["var maxSumMinProduct = function(nums) {\\n    const MODULO = BigInt(10 ** 9 + 7);\\n    const size = nums.length;\\n    const prefixSum = Array(size + 1).fill(0);\\n    const stack = [];\\n    let result = BigInt(0);\\n\\n    nums.forEach((num, index) => prefixSum[index + 1] = prefixSum[index] + num);\\n\\n    for (let index = 0; index <= size; index++) {\\n        const num = nums[index];\\n\\n        while (stack.length && (nums[stack.at(-1)] > num || index === size)) {\\n            const minimum = BigInt(nums[stack.pop()]);\\n            const last = stack.length ? stack.at(-1) + 1 : 0;\\n            const sum = BigInt(prefixSum[index] - prefixSum[last]);\\n            const product = minimum * sum;\\n\\n            if (result > product) continue;\\n            result = product;\\n        }\\n        stack.push(index);\\n    }\\n    return result % MODULO;\\n};", "var maxSumMinProduct = function (nums) {\\n    ", "var maxSumMinProduct = function (nums) {\\n    "]}
{"id": "1397", "ref_js": ["var memLeak = function (availableMemoryBits1, availableMemoryBits2) {\\n  ", "var memLeak = function(memory1, memory2) {\\n    let crashTime = 1;\\n\\n    while (memory1 >= crashTime || memory2 >= crashTime) {\\n        memory1 >= memory2 \\n            ? memory1 -= crashTime\\n            : memory2 -= crashTime;\\n        crashTime += 1;\\n    }\\n    return [crashTime, memory1, memory2];\\n};", "var memLeak = function (memory1, memory2) {\\n  let sec = 1;\\n  while (sec <= memory1 || sec <= memory2) {\\n    if (memory1 >= memory2 && sec <= memory1) {\\n      memory1 -= sec;\\n    } else if (memory2 >= memory1 && sec <= memory2) {\\n      memory2 -= sec;\\n    }\\n    sec++;\\n  }\\n  return [sec, memory1, memory2];\\n};"]}
{"id": "1398", "ref_js": ["var rotateTheBox = function(box) {\\n    const m = box.length;\\n    const n = box[0].length;\\n    const result = Array(n).fill(\\'\\').map(_ => Array(m).fill(\\'.\\'));\\n\\n    for (let row = 0; row < m; row++) {\\n        let fallRow = n - 1;\\n\\n        for (let col = n - 1; col >= 0; col--) {\\n            const value = box[row][col];\\n\\n            if (value === \\'.\\') continue;\\n            if (value === \\'*\\') fallRow = col;\\n            result[fallRow][m - row - 1] = value;\\n            fallRow -= 1;\\n        }\\n    }\\n    return result;\\n};", "var rotateTheBox = function(box) {\\n    let matrix = new Array(box[0].length)\\n    for (let r = 0; r < matrix.length; r++){\\n        matrix[r] = new Array(box.length).fill(\".\")\\n    }\\n    for (let r = 0; r < box.length; r++){\\n        let stones = 0\\n        for (let c = 0; c < box[0].length; c++){\\n            if (box[r][c] === \"#\") stones++\\n            if (box[r][c] === \"*\"){\\n                matrix[c][box.length - 1 - r] = \"*\" \\n                fillWithStones(c - 1, box.length - 1 - r, stones)\\n                stones = 0\\n            }\\n        }\\n        if (stones !== 0){\\n            fillWithStones(box[0].length - 1, box.length - 1 - r, stones)\\n        }\\n    }\\n    return matrix\\n    \\n    function fillWithStones(row, col, stones){\\n        let i = 0\\n        while (stones !== i){\\n            matrix[row - i][col] = \"#\"\\n            i++\\n        }\\n    }\\n\\n};", "var rotateTheBox = function(box) {\\n    let matrix = new Array(box[0].length)\\n    for (let r = 0; r < matrix.length; r++){\\n        matrix[r] = new Array(box.length).fill(\".\")\\n    }\\n    for (let r = 0; r < box.length; r++){\\n        let stones = 0\\n        for (let c = 0; c < box[0].length; c++){\\n            if (box[r][c] === \"#\") stones++\\n            if (box[r][c] === \"*\"){\\n                matrix[c][box.length - 1 - r] = \"*\" \\n                fillWithStones(c - 1, box.length - 1 - r, stones)\\n                stones = 0\\n            }\\n        }\\n        if (stones !== 0){\\n            fillWithStones(box[0].length - 1, box.length - 1 - r, stones)\\n        }\\n    }\\n    return matrix\\n    \\n    function fillWithStones(row, col, stones){\\n        let i = 0\\n        while (stones !== i){\\n            matrix[row - i][col] = \"#\"\\n            i++\\n        }\\n    }\\n\\n};"]}
{"id": "1399", "ref_js": ["var minSwaps = function(s) {\\n    const zeros = s.replaceAll(\\'1\\', \\'\\').length;\\n    const ones = s.length - zeros;\\n\\n    if (Math.abs(zeros - ones) > 1) return -1;\\n    const swapString = (current) => {\\n        let swaps = 0;\\n\\n        for (const char of s) {\\n            if (char !== current) swaps += 1;\\n            current = `${current ^ 1}`;\\n        }\\n        return swaps / 2;\\n    };", "var minSwaps = function(str) {\\n    \\n    let check = (alter) => {\\n        let count1need = 0, count0need = 0;\\n        for(let s of str){\\n            if(s != alter){\\n                if(alter == 0) count0need++;\\n                else count1need++;\\n            }\\n            alter = !alter;\\n        } \\n        return count1need == count0need ? count0need : -1;\\n    }  \\n    let check1 = check(0);\\n    let check2 = check(1);\\n    if(check1 == -1 && check2 == -1) return -1;\\n\\n    return Math.min(check1 ==  -1 ? Infinity : check1 , \\n                    check2 ==  -1 ? Infinity : check2);\\n\\n};", "var minSwaps = function(s) {\\n    const fmap={};"]}
{"id": "1401", "ref_js": ["var minSpeedOnTime = function(dist, hour) {\\n    const canArriveOnTime = (speed) => {\\n        return dist.slice(0, -1).reduce((total, d) => total + Math.ceil(d / speed), 0) + dist[dist.length - 1] / speed <= hour;\\n    };", "var minSpeedOnTime = function(dist, hour) {\\n    let lowerBound = 1\\n    let upperBound = 10**7\\n\\n    let result = -1;\\n    const calcTime = function(d, s) {\\n      let travelTime = 0;\\n      for (let i = 0; i < d.length - 1; i++) {\\n        travelTime += Math.ceil(d[i]/s)\\n      }\\n      travelTime += d[d.length - 1]/s;\\n      return travelTime\\n    }\\n    \\n    while (lowerBound <= upperBound) {\\n      const m = Math.floor((lowerBound+upperBound)/2)\\n      const time = calcTime(dist, m)\\n      if (time > hour) lowerBound = m + 1\\n      else {\\n        result = m;\\n        upperBound = m - 1\\n      }\\n    }\\n    return result;\\n};", "var minSpeedOnTime = function (distances, maxTimeToReachOffice) {\\n  let n = distances.length;\\n  let lowSpeed = 1;\\n  let highSpeed = 10e9;\\n  while (lowSpeed < highSpeed) {\\n    let midSpeed = Math.trunc(lowSpeed / 2 + highSpeed / 2);\\n    let diff = timeDiff(midSpeed);\\n    if (diff === 0) {\\n      return midSpeed;\\n    } else if (diff > 0) {\\n      highSpeed = midSpeed;\\n    } else {\\n      lowSpeed = midSpeed + 1;\\n    }\\n  }\\n  return highSpeed === 10e9 ? -1 : highSpeed;\\n  function timeDiff(speed) {\\n    let sumTime = 0;\\n    let j;\\n    for (j = 0; j < n - 1; j++) {\\n      sumTime += Math.ceil(distances[j] / speed);\\n    }\\n    sumTime += distances[j] / speed;\\n    return maxTimeToReachOffice - sumTime;\\n  }\\n};"]}
{"id": "1402", "ref_js": ["var canReach = function (s, minJump, maxJump) {\\n\\n  var LAST = s.length - 1\\n  if (s[LAST] === \\'1\\') return false\\n\\n  var prevBound = 0\\n  var q = [0]\\n\\n  for (let pos of q) {\\n    var i = Math.max(pos + minJump, prevBound + 1)\\n    if (i <= LAST &&  pos + maxJump >= LAST ) return true\\n    for (; i <= pos + maxJump && i < s.length; i++) {\\n      if(s[i] === \\'0\\') q.push(i)\\n    }\\n    prevBound = pos + maxJump\\n  }\\n\\n  return false\\n};", "var canReach = function(s, minJump, maxJump) {\\n    if(s[s.length-1]===\"1\"){return false}\\n    if(s==\"0111000110\"){return true}\\n    if((s.length-1)%minJump===0 && minJump!=1 && minJump%2!=0){return true}\\n    if(s.length>10){\\n        if(Array.from(new Set(s)).length===1&&Array.from(new Set(s))[0]===\"0\" ){return true}\\n    }\\n    var recur=function(str,cur){\\n        if(cur===0 && str[cur]===\"0\"){return true}\\n        for(let i=maxJump;i>=minJump;i--){\\n            if(str[cur-i]===\"0\"){return recur(str,cur-i) }\\n        }\\n        return false\\n    }\\n    return recur(s,s.length-1)\\n};", "var canReach = function (s, minJump, maxJump) {\\n\\n  var LAST = s.length - 1\\n  if (s[LAST] === \\'1\\') return false\\n\\n  var prevBound = 0\\n  var q = [0]\\n\\n  for (let pos of q) {\\n    var i = Math.max(pos + minJump, prevBound + 1)\\n    if (i <= LAST &&  pos + maxJump >= LAST ) return true\\n    for (; i <= pos + maxJump && i < s.length; i++) {\\n      if(s[i] === \\'0\\') q.push(i)\\n    }\\n    prevBound = pos + maxJump\\n  }\\n\\n  return false\\n};"]}
{"id": "1403", "ref_js": ["var minPairSum = function(nums) {\\n    nums.sort((a, b) => a - b);\\n\\n    let n = nums.length;\\n    let minMaxSum = 0;\\n\\n    for (let i = 0; i < n / 2; i++) {\\n        minMaxSum = Math.max(minMaxSum, nums[i] + nums[n - 1 - i]);\\n    }\\n\\n    return minMaxSum;    \\n};", "var minPairSum = function(nums) {\\n    ", "var minPairSum = function(nums) {\\n    "]}
{"id": "1404", "ref_js": ["var getBiggestThree = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    ", "var getBiggestThree = function(grid) {\\n     let rsums = new Set();\\n     let rows=grid.length\\n     let cols=grid[0].length\\n     for(let i=0;i<rows;i++){\\n        for(let j=0; j< cols; j++){\\n            let maxr = Math.min(i-0,j-0,rows-1-i, cols-1-j)\\n            for(let k=0; k<=maxr;k++){\\n                ", "var getBiggestThree = function(grid) {\\n  \\n  "]}
{"id": "1405", "ref_js": ["var maxValue = function(n, x) {\\n    let i = ~~(n[0] === \\'-\\')\\n    while(n[0] === \\'-\\' ? n[i] <= x : n[i] >= x) i++\\n    return n.slice(0,i) + x + n.slice(i)\\n};", "var maxValue = function(n, x) {\\n    let isNegative = false\\n    if(n[0]==\\'-\\'){\\n        isNegative = true;\\n    }\\n\\n    for(let i=0; i<n.length; i++){\\n        if(isNegative && i==0){\\n            ", "var maxValue = function(n, x) {\\n    let i = ~~(n[0] === \\'-\\')\\n    while(n[0] === \\'-\\' ? n[i] <= x : n[i] >= x) i++\\n    return n.slice(0,i) + x + n.slice(i)\\n};"]}
{"id": "1406", "ref_js": ["var assignTasks = function(servers, tasks) {\\n    ", "var assignTasks = function (serverWeights, taskDurations) {\\n  let min_w_sI = new MinPriorityQueue({ compare: (a, b) => serverWeights[a] - serverWeights[b] || a - b }); ", "var assignTasks = function(servers, tasks) {\\n    const n = servers.length;\\n    const m = tasks.length;\\n    \\n    "]}
{"id": "1407", "ref_js": ["var twoEggDrop = function(n) {\\n    ", "var twoEggDrop = function (n) {\\n\\n  let l = 1, h = 50;\\n\\n  let res;\\n\\n  while (l <= h) {\\n    let m = l + Math.floor((h - l) / 2);\\n    if ((m * m) + m >= (n * 2)) {\\n      res = m;\\n      h = m - 1;\\n    } else {\\n      l = m + 1;\\n    }\\n  }\\n\\n  return res;\\n\\n};", "var twoEggDrop = function(n) {\\n    let count = 1;\\n    while(n>0){\\n        n -= count;\\n        count++\\n    }\\n    return count-1;\\n};"]}
{"id": "1408", "ref_js": ["var reductionOperations = function(nums) {\\n    nums.sort((a, b) => a - b); ", "var reductionOperations = function(nums) {\\n    let count = 0\\n    nums.sort(function(a, b){\\n        return a - b\\n    })\\n    for(let i = nums.length-1; i > 0; i--)\\n    {\\n        if(nums[i] > nums[i-1])\\n            count += (nums.length - i)\\n    }\\n    return count;\\n};", "var reductionOperations = function(nums) {\\n    nums.sort((a,b)=> a-b);\\n    let p = 0;\\n    let ans = 0;\\n    for(let i = 1; i<nums.length; i++){\\n        if(nums[i]!==nums[i-1]){\\n            ++p\\n        }\\n        ans+=p\\n    }\\n    return  ans;\\n};"]}
{"id": "1409", "ref_js": ["var minFlips = function(s) {\\n    let res = Math.floor(s.length/2)\\n    let len = s.length\\n \\n ", "var minFlips = function(s) {\\n    let length = s.length-1\\n    let flipMap = {\\n        \\'1\\': \\'0\\',\\n        \\'0\\': \\'1\\'\\n    }\\n    s = s + s\\n    let alt1 = \\'1\\'\\n    let alt2 = \\'0\\'\\n    let left = 0\\n    let right = 0\\n    let diff1 = 0\\n    let diff2 = 0\\n    let min = Infinity\\n\\n    while (right < s.length) {\\n        if (right > 0) {\\n            alt1 = flipMap[alt1]\\n            alt2 = flipMap[alt2]\\n        }\\n\\n        let current = s[right]\\n        if (current !== alt1) diff1++\\n        if (current !== alt2) diff2++\\n        if (right-left === length) {\\n            min = Math.min(diff1, diff2, min)\\n            if ((length+1)%2 === 0) {\\n                if (s[left] !== flipMap[alt1]) diff1--\\n                if (s[left] !== flipMap[alt2]) diff2--\\n            } else {\\n                if (s[left] !== alt1) diff1--\\n                if (s[left] !== alt2) diff2--\\n            }\\n            left++\\n        }\\n        right++\\n    }\\n    return min\\n};", "var minFlips = function(s) {\\n    let length = s.length-1\\n    let flipMap = {\\n        \\'1\\': \\'0\\',\\n        \\'0\\': \\'1\\'\\n    }\\n    s = s + s\\n    let alt1 = \\'1\\'\\n    let alt2 = \\'0\\'\\n    let left = 0\\n    let right = 0\\n    let diff1 = 0\\n    let diff2 = 0\\n    let min = Infinity\\n\\n    while (right < s.length) {\\n        if (right > 0) {\\n            alt1 = flipMap[alt1]\\n            alt2 = flipMap[alt2]\\n        }\\n\\n        let current = s[right]\\n        if (current !== alt1) diff1++\\n        if (current !== alt2) diff2++\\n        if (right-left === length) {\\n            min = Math.min(diff1, diff2, min)\\n            if ((length+1)%2 === 0) {\\n                if (s[left] !== flipMap[alt1]) diff1--\\n                if (s[left] !== flipMap[alt2]) diff2--\\n            } else {\\n                if (s[left] !== alt1) diff1--\\n                if (s[left] !== alt2) diff2--\\n            }\\n            left++\\n        }\\n        right++\\n    }\\n    return min\\n};"]}
{"id": "1410", "ref_js": ["var chalkReplacer = function(chalk, k) {\\n    let arr = new Array(chalk.length)\\n    let sum = 0\\n    for(let i =0; i< chalk.length; i++){\\n        sum += chalk[i]\\n        arr[i]= sum\\n    }\\n    k = k%sum\\n    if(k==0 || k < chalk[0])\\n        return 0\\n    \\n    for(let i =0; i< chalk.length; i++){\\n        if(k < chalk[i]){\\n            return i\\n        }else{\\n            k-=chalk[i]\\n        }\\n    }\\n};", "var chalkReplacer = function(chalk, k) {\\n     let totalChalk = 0;\\n    for (let i = 0; i < chalk.length; i++) {\\n        totalChalk += chalk[i];\\n    }\\n    \\n    k %= totalChalk;\\n    \\n    let ans = 0;\\n    while (k >= chalk[ans]) {\\n        k -= chalk[ans];\\n        ans++;\\n    }\\n    \\n    return ans;\\n};", "var chalkReplacer = function(chalk, k) {\\n     let totalChalk = 0;\\n    for (let i = 0; i < chalk.length; i++) {\\n        totalChalk += chalk[i];\\n    }\\n    \\n    k %= totalChalk;\\n    \\n    let ans = 0;\\n    while (k >= chalk[ans]) {\\n        k -= chalk[ans];\\n        ans++;\\n    }\\n    \\n    return ans;\\n};"]}
{"id": "1411", "ref_js": ["var largestMagicSquare = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const rows = Array(m).fill(\\'\\').map(_ => Array(n + 1).fill(0));\\n    const cols = Array(n).fill(\\'\\').map(_ => Array(m + 1).fill(0));\\n    const maxSize = Math.min(m, n);\\n    const isSame = (row, col, k) => {\\n        const sums = new Set();\\n        let diagonalA = diagonalB = 0;\\n\\n        for (let index = 0; index < k; index++) {\\n            sums.add(rows[row + index][col + k] - rows[row + index][col]);\\n            if (sums.size > 1) return false;\\n            sums.add(cols[col + index][row + k] - cols[col + index][row]);\\n            if (sums.size > 1) return false;\\n        }\\n        for (let index = 0; index < k; index++) {\\n            diagonalA += grid[row + index][col + index];\\n            diagonalB += grid[row + k - index - 1][col + index];\\n        }\\n        sums.add(diagonalA).add(diagonalB);\\n        return sums.size === 1;\\n    };", "var largestMagicSquare = function(grid) {\\n    const row = grid.length;\\n    const col = grid[0].length;\\n    const startSize = row <= col ? row : col;\\n    for(let s = startSize; s > 1; s--){\\n        for(let r = 0; r < grid.length - s + 1; r++){\\n            for(let c = 0; c < grid[0].length - s + 1; c++){\\n                if(isMagic(grid, r, c, s)){\\n                    return s;\\n                }\\n            }\\n        }\\n    }\\n    return 1;\\n};", "var largestMagicSquare = function(grid) {\\n    const row = grid.length;\\n    const col = grid[0].length;\\n    const startSize = row <= col ? row : col;\\n    for(let s = startSize; s > 1; s--){\\n        for(let r = 0; r < grid.length - s + 1; r++){\\n            for(let c = 0; c < grid[0].length - s + 1; c++){\\n                if(isMagic(grid, r, c, s)){\\n                    return s;\\n                }\\n            }\\n        }\\n    }\\n    return 1;\\n};"]}
{"id": "1412", "ref_js": ["var maximumRemovals = function(s, p, removable) {\\n    let arr = s.split(\\'\\');\\n    \\n    const stillFunctions = (k) => {\\n        let result = [...arr];\\n        for(let i = 0; i < k; i++) {\\n            result[removable[i]] = \\'\\';\\n        }\\n\\n        const isSubset = () => {\\n            let idx = 0;\\n            for(let c = 0; c < p.length; c++) {\\n                if(idx > result.length) return false;\\n                const next = result.indexOf(p[c], idx);\\n                if(next === -1) {\\n                    return false;\\n                }\\n                idx = next + 1;\\n            }\\n            return true;\\n        }\\n        \\n        return isSubset();\\n    }\\n\\n    let left = 0;\\n    let right = removable.length;\\n    \\n    while(left < right) {\\n        ", "var maximumRemovals = function(s, p, removable) {\\n    \\n\\t", "var maximumRemovals = function(s, p, removable) {\\n    function isSubsequence(x){\\n        let i = 0;\\n        let j = 0;\\n\\n        while (i < x.length) {\\n            if (x[i] === p[j]){\\n                j++;\\n                if (j === p.length) return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    let res = null;\\n    s = Array.from(s);\\n    let i = 0;\\n    let j = removable.length - 1;\\n    \\n    while (i <= j) {\\n        const mid = Math.floor((i + j)/2);\\n        const temp = new Set(removable.slice(0, mid + 1));\\n        let x = s.map((val, index) => temp.has(index) ? null: val);\\n        \\n        if (isSubsequence(x)) {\\n            res = mid;\\n            if (i === j) break;\\n            i = mid + 1;\\n        } else j = mid - 1;\\n    }\\n\\n    return res !== null ? res + 1 : 0;\\n};"]}
{"id": "1413", "ref_js": ["var mergeTriplets = function (tris, tar) {\\n  let a = 0, b = 0,c = 0,[A, B, C] = tar;\\n  for (let arr of tris) {\\n", "var mergeTriplets = function(triplets, target) {\\n  let isFirstValEqual = false;\\n  let isSecondValEqual = false;\\n  let isThirdValEqual = false;\\n\\n  for (let indexI = 0; indexI < triplets.length; indexI++) {\\n    const aryCurrentVal = triplets[indexI];\\n\\n    ", "var mergeTriplets = function (tris, tar) {\\n  let a = 0, b = 0,c = 0,[A, B, C] = tar;\\n  for (let arr of tris) {\\n"]}
{"id": "1414", "ref_js": ["var findPeakGrid = function(matrix) {\\n    const getMaxElement = (matrix, mid) => {\\n        let index = -1;\\n        let maxi = Number.MIN_SAFE_INTEGER;\\n\\n        for (let row = 0; row < matrix.length; row++) {\\n            let elm = matrix[row][mid];\\n\\n            if (elm > maxi) {\\n                maxi = Math.max(maxi, elm);\\n                index = row;\\n            }\\n        }\\n        return index;\\n    };", "var findPeakGrid = function(mat) {   \\n    \\n    function maxValueIdx(array) {\\n        let maxIdx = 0;\\n        for(let i = 0; i < array.length; i++) {\\n            if(array[i] > array[maxIdx]) {\\n                maxIdx = i;\\n            }\\n        }\\n        return maxIdx\\n    };", "var findPeakGrid = function(mat) {   \\n    \\n    function maxValueIdx(array) {\\n        let maxIdx = 0;\\n        for(let i = 0; i < array.length; i++) {\\n            if(array[i] > array[maxIdx]) {\\n                maxIdx = i;\\n            }\\n        }\\n        return maxIdx\\n    };"]}
{"id": "1415", "ref_js": ["var numberOfRounds = function(startTime, finishTime) {\\n    var start=60*parseInt(startTime.slice(0,2))+parseInt(startTime.slice(3))\\n    var end=60*parseInt(finishTime.slice(0,2))+parseInt(finishTime.slice(3))\\n    if(start>end) end+=24*60\\n    return Math.floor(end/15) - Math.ceil(start/15)\\n};", "var numberOfRounds = function(startTime, finishTime) {\\n\\n    let startH,startM,finishH,finishM,start=-1,ans=0,addition=0,startInMin,finishInMin;\\n    startH = parseInt(startTime.substring(0,2));\\n    startM = parseInt(startTime.substring(3));\\n    finishH = parseInt(finishTime.substring(0,2));\\n    finishM = parseInt(finishTime.substring(3));\\n    \\n    if(finishH<startH || (finishH===startH && finishM<startM)){", "var numberOfRounds = function(loginTime, logoutTime) {\\n    const start = toMins(loginTime);\\n    const end = toMins(logoutTime);\\n\\n    let roundStart = Math.ceil(start / 15);\\n    let roundEnd = Math.floor(end / 15);\\n\\n    if (start < end) {\\n        return Math.max(0, roundEnd - roundStart); \\n    } \\n    else {\\n        roundEnd += 96;\\n        return roundEnd - roundStart;\\n    }\\n\\n\\n    function toMins(timeStr) {\\n        const [hh, mm] = timeStr.split(\":\");\\n\\n        let totMins = 0;\\n\\n        totMins += parseInt(hh) * 60;\\n        totMins += parseInt(mm);\\n\\n        return totMins;\\n    }\\n};"]}
{"id": "1416", "ref_js": ["var countSubIslands = function(grid1, grid2) {\\n    const R = grid2.length, C = grid2[0].length;\\n    \\n    ", "var countSubIslands = function(grid1, grid2) {\\n    const visited = new Set()\\n    let sub = 0;\\n    for (let r = 0; r < grid1.length; r++) {\\n        for (let c = 0; c < grid1[0].length; c++) {\\n            if (grid2[r][c] === 1 && !visited.has(getPosKey(r, c)) && bfs(grid1, grid2, r, c, visited)) {\\n                sub++;\\n            }\\n        }\\n    }\\n    return sub;\\n};", "var countSubIslands = function(grid1, grid2) {\\n    let count = 0\\n    let isSubIsland = true\\n    for (let i = 0; i < grid2.length; i++) {\\n        for (let j = 0; j < grid2[i].length; j++) {\\n            if (grid2[i][j] === 1) {\\n                dfs(i, j)\\n                if (isSubIsland) count++\\n                isSubIsland = true\\n            }\\n        }\\n    }\\n    function dfs(raw, col) {\\n        if (raw >= grid2.length || raw < 0 || col >= grid2[0].length || col < 0 || grid2[raw][col] == 0) return;\\n        if (grid2[raw][col] === 1 && grid1[raw][col] === 0) {\\n            isSubIsland = false\\n            return\\n        }\\n        grid2[raw][col] = 0\\n        dfs(raw - 1, col)\\n        dfs(raw + 1, col)\\n        dfs(raw, col - 1)\\n        dfs(raw, col + 1)\\n    }\\n    return count\\n};"]}
{"id": "1417", "ref_js": ["var minDifference = function(nums, queries) {\\n    const qlen   = queries.length, len = nums.length;\\n    const res    = new Array(qlen).fill(-1);\\n    const prefix = [];\\n    \\n    for(let i = 0; i <= len; i++) {\\n        if(i == 0) prefix[i] = new Array(101).fill(0);\\n        else {\\n            prefix[i] = Array.from(prefix[i-1]);\\n            prefix[i][nums[i-1]]++;   \\n        }\\n    }\\n    \\n    for(let k = 0; k < qlen; k++) {\\n        const [l, r] = queries[k];\\n        const left = prefix[l], right = prefix[r + 1];\\n        let prev = -1, ans = Infinity;\\n        for(let i = 1; i <= 100; i++) {\\n            const diff = right[i] - left[i];\\n            if(diff == 0) continue;\\n            \\n            if(prev != -1) {\\n                ans = Math.min(ans, i - prev);\\n            }\\n            prev = i;\\n        }\\n        if(ans != Infinity) {\\n            res[k] = ans;\\n        }\\n    }\\n    \\n    return res;\\n};", "var minDifference = function(nums, queries) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    const n = nums.length;\\n    const prefixSums = [];\\n    \\n    for (let i = 0; i <= n; ++i) {\\n        const num = nums[i];\\n        \\n        if (i === 0) {\\n            prefixSums[0] = new Array(101).fill(0);\\n        }\\n        else {\\n            prefixSums[i] = [...prefixSums[i - 1]];\\n            ++prefixSums[i][nums[i - 1]];\\n        }\\n    }\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < queries.length; ++i) {\\n        const [left, right] = queries[i];\\n        \\n        const start =  prefixSums[left];\\n        const end = prefixSums[right + 1];\\n        \\n        const intersect = new Array(101).fill(0);\\n        \\n        for (let i = 0; i < 101; ++i) {\\n            intersect[i] = end[i] - start[i];\\n        }\\n        \\n        let last = -1;\\n        let minDiff = MAX;\\n        \\n        for (let i = 1; i <= 100; ++i) {\\n            if (intersect[i] === 0) continue;\\n            \\n            if (last == -1) {\\n                last = i;\\n            }\\n            else {\\n                const diff = i - last;\\n                \\n                minDiff = Math.min(minDiff, diff);\\n                \\n                last = i;\\n            }\\n        }\\n        \\n        if (minDiff === MAX) res[i] = -1;\\n        else res[i] = minDiff;\\n    } \\n    \\n    return res;\\n};", "var minDifference = function (A, Q) {\\n    let n = A.length;\\n    let maxVal = A.reduce((max, e) => Math.max(max, e), -1);\\n    let memo = Array.from({ length: n + 1 }, () => new Array(maxVal + 1).fill(0));\\n    for (let i = 1; i <= n; ++i) {\\n        for (let j = 1; j <= maxVal; ++j) memo[i][j] = memo[i - 1][j];\\n        memo[i][A[i - 1]]++; "]}
{"id": "1419", "ref_js": ["var removeOccurrences = function(s, part) {\\n  let res = s;\\n  while (res.includes(part)) {\\n    res = res.replace(part, \"\");\\n  }\\n  return res;\\n};", "var removeOccurrences = function(s, part) {\\n    let idx = s.indexOf(part);\\n    while (idx !== -1) {\\n        s = s.substring(0, idx) + s.substring(idx + part.length);\\n        idx = s.indexOf(part);\\n    }\\n    return s;\\n};", "var removeOccurrences = function(s, part) {\\n\\n    function partRemove (str) {\\n        const pattern = new RegExp(part)\\n        if (!pattern.test(str)) return str\\n\\n        str = str.replace(pattern, \"\")\\n\\n        return partRemove(str)\\n    }\\n\\n    return partRemove(s)\\n};"]}
{"id": "1420", "ref_js": ["var maxAlternatingSum = function(nums) {\\r\\n    const N = nums.length\\r\\n    let even_sum = nums[0]\\r\\n    let odd_sum = 0\\r\\n\\r\\n    for (let i = 1; i < N; i++) {\\r\\n        new_even_sum = Math.max(even_sum, odd_sum + nums[i])\\r\\n        new_odd_sum = Math.max(odd_sum, even_sum - nums[i])\\r\\n        even_sum = new_even_sum\\r\\n        odd_sum = new_odd_sum\\r\\n    }\\r\\n\\r\\n    return Math.max(even_sum, odd_sum)\\r\\n};", "var maxAlternatingSum = function(nums) {\\r\\n    const len = nums.length\\r\\n    let sum = 0\\r\\n    let i = 0\\r\\n\\r\\n    while (i < len) {\\r\\n        ", "var maxAlternatingSum = function(nums) {\\n    let total = 0;\\n    for(let i=1; i<nums.length; i++) {\\n        if(nums[i-1] > nums[i]) {\\n            total += nums[i-1] - nums[i];\\n        }\\n    }\\n    return total + nums[nums.length-1];\\n};"]}
{"id": "1421", "ref_js": ["var rotateGrid = function(grid, k) {\\r\\n    let layer = Math.min(grid.length / 2, grid[0].length / 2);\\r\\n    const m = grid.length;\\r\\n    const n = grid[0].length;\\r\\n    layer = Math.min(m, n) / 2; ", "var rotateGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    let startRow = 0;\\n    let endRow = m - 1;\\n    \\n    let startCol = 0;\\n    let endCol = n - 1;\\n    \\n    while (startRow <= endRow && startCol <= endCol) {\\n        let currRowStart = startRow;\\n        let currRowEnd = endRow;\\n\\n        let currColStart = startCol;\\n        let currColEnd = endCol;\\n\\n        const vals = [];\\n\\n        ", "var rotateGrid = function(grid, k) {\\n  const dyx = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  const range = [grid[0].length, grid.length];\\n  let [d, y, x] = [0, 0, -1];\\n  let edges = [];\\n  while (range[0] > 0 && range[1] > 0) {\\n    for (let i = 0; i < range[d % 2]; i += 1) {\\n      [y, x] = [y + dyx[d % 4][0], x + dyx[d % 4][1]];\\n      edges.push([y, x]);\\n    }\\n    range[(d + 1) % 2] -= 1;\\n    d = (d + 1) % 4;\\n    "]}
{"id": "1422", "ref_js": ["var wonderfulSubstrings = function(word) {\\n    let hashMap={},ans=0,binaryRepresentation=0,t,pos,number,oneBitToggled;\\n    hashMap[0]=1;\\n    for(let i=0;i<word.length;i++){\\n        pos = word[i].charCodeAt(0)-\"a\".charCodeAt(0);", "var wonderfulSubstrings = function(word) {\\n    ", "var wonderfulSubstrings = function(word) {\\n    let hashMap={},ans=0,binaryRepresentation=0,t,pos,number,oneBitToggled;\\n    hashMap[0]=1;\\n    for(let i=0;i<word.length;i++){\\n        pos = word[i].charCodeAt(0)-\"a\".charCodeAt(0);"]}
{"id": "1423", "ref_js": ["var eliminateMaximum = function(dist, speed) {\\n    const n = dist.length;\\n    const monsters = new Array(n).fill(0);\\n\\n    for (let i = 0; i < n; i++) {\\n        const arrival = Math.ceil(dist[i] / speed[i]);\\n\\n        if (arrival < n) {\\n            monsters[arrival]++;\\n        }\\n    }\\n\\n    let eliminated = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (eliminated + monsters[i] > i) {\\n            return i;\\n        }\\n\\n        eliminated += monsters[i];\\n    }\\n\\n    return n;    \\n};", "var eliminateMaximum = function(dist, speed) {\\n    const n = dist.length;\\n    const monsters = new Array(n).fill(0);\\n\\n    for (let i = 0; i < n; i++) {\\n        const arrival = Math.ceil(dist[i] / speed[i]);\\n\\n        if (arrival < n) {\\n            monsters[arrival]++;\\n        }\\n    }\\n\\n    let eliminated = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (eliminated + monsters[i] > i) {\\n            return i;\\n        }\\n\\n        eliminated += monsters[i];\\n    }\\n\\n    return n;    \\n};", "var eliminateMaximum = function(dist, speed) {\\n    const n = dist.length;\\n    const monsters = new Array(n).fill(0);\\n\\n    for (let i = 0; i < n; i++) {\\n        const arrival = Math.ceil(dist[i] / speed[i]);\\n\\n        if (arrival < n) {\\n            monsters[arrival]++;\\n        }\\n    }\\n\\n    let eliminated = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (eliminated + monsters[i] > i) {\\n            return i;\\n        }\\n\\n        eliminated += monsters[i];\\n    }\\n\\n    return n;    \\n};"]}
{"id": "1424", "ref_js": ["var countGoodNumbers = function(n) {\\n    const a = power(BigInt(5), parseInt(n/2));\\n    const b = power(BigInt(4), parseInt(n/2));\\n    if(n%2 == 0) {\\n        return (a*b)%MOD;\\n    } else {\\n        return (BigInt(5)*a*b)%MOD;\\n    }\\n    \\n};", "var countGoodNumbers = function(n) {\\n    var even=0,odd=0;\\n    if(n%2==1){\\n        even=Math.floor(n/2)+1", "var countGoodNumbers = function(n) {\\n    const a = power(BigInt(5), parseInt(n/2));\\n    const b = power(BigInt(4), parseInt(n/2));\\n    if(n%2 == 0) {\\n        return (a*b)%MOD;\\n    } else {\\n        return (BigInt(5)*a*b)%MOD;\\n    }\\n    \\n};"]}
{"id": "1425", "ref_js": ["var nearestExit = function(maze, entrance) {\\n    ", "var nearestExit = function(maze, entrance) {\\n    ", "var nearestExit = function(maze, entrance) {\\n    "]}
{"id": "1426", "ref_js": ["var sumGame = function(num) {\\n    let sum1=sum2=0,mid=Math.floor(num.length/2);\\n    for(let i=0; i<num.length; i++){\\n        let digit=num[i]\\n        if(digit==\\'?\\'){\\n            ", "var sumGame = function(num) {\\n    \\n    function getInfo(s) {\\n        var sum = 0;\\n        var ques = 0;\\n        for(let c of s.split(\\'\\'))\\n            if (c !== \\'?\\') sum += c - 0;\\n            else ques++;\\n        return [sum, ques];\\n    }\\n    \\n    function check(sum1, sum2, q1, q2, q) {\\n        return sum1 + 9* Math.min(q/2, q1) > sum2 + 9 * Math.min(q/2, q2);\\n    }\\n    \\n    \\n    var q = getInfo(num)[1];\\n    var [sum1, q1] = getInfo(num.substring(0, Math.floor(num.length/2)));\\n    var [sum2, q2] = getInfo(num.substring(Math.floor(num.length/2), num.length));\\n    if (sum1 < sum2) { \\n        [sum1, sum2] = [sum2, sum1];\\n        [q1, q2] = [q2, q1];\\n    }\\n    \\n    return check(sum1, sum2, q1, q2, q) || check(sum2, sum1, q2, q1, q);\\n};", "var sumGame = function(num) {\\n    \\n    function getInfo(s) {\\n        var sum = 0;\\n        var ques = 0;\\n        for(let c of s.split(\\'\\'))\\n            if (c !== \\'?\\') sum += c - 0;\\n            else ques++;\\n        return [sum, ques];\\n    }\\n    \\n    function check(sum1, sum2, q1, q2, q) {\\n        return sum1 + 9* Math.min(q/2, q1) > sum2 + 9 * Math.min(q/2, q2);\\n    }\\n    \\n    \\n    var q = getInfo(num)[1];\\n    var [sum1, q1] = getInfo(num.substring(0, Math.floor(num.length/2)));\\n    var [sum2, q2] = getInfo(num.substring(Math.floor(num.length/2), num.length));\\n    if (sum1 < sum2) { \\n        [sum1, sum2] = [sum2, sum1];\\n        [q1, q2] = [q2, q1];\\n    }\\n    \\n    return check(sum1, sum2, q1, q2, q) || check(sum2, sum1, q2, q1, q);\\n};"]}
{"id": "1427", "ref_js": ["var countPalindromicSubsequence = function(s) {\\n    const c = \\'abcdefghijklmnopqrstuvwxyz\\';\\n        let a = 0, t = 0;\\n\\n        for (const x of c) {\\n            const l = s.indexOf(x);\\n            if (l === -1) {\\n                continue;\\n            }\\n            const r = s.lastIndexOf(x);\\n            if (l >= r) {\\n                continue;\\n            }\\n\\n            const v = new Array(128).fill(false);\\n            t = 0;\\n            for (let i = l + 1; i < r; i++) {\\n                if (!v[s.charCodeAt(i)]) {\\n                    v[s.charCodeAt(i)] = true;\\n                    t++;\\n                    if (t === 26) {\\n                        break;\\n                    }\\n                }\\n            }\\n            a += t;\\n        }\\n        return a;\\n};", "var countPalindromicSubsequence = function(s) {\\n    let res = 0;\\n    const uniq = new Set(s);\\n\\n    for (const c of uniq) {\\n        const start = s.indexOf(c);\\n        const end = s.lastIndexOf(c);\\n\\n        if (start < end) {\\n            res += new Set(s.slice(start + 1, end)).size;\\n        }\\n    }\\n\\n    return res;    \\n};", "var countPalindromicSubsequence = function(s) {\\n    const n = s.length;\\n    let result = 0;\\n    const indices = {};"]}
{"id": "1429", "ref_js": ["var addRungs = function(rungs, dist) {\\n    let curr = 0\\n    let addition = 0\\n    for (const r of rungs){\\n        addition += Math.ceil((r - curr) / dist) - 1\\n        curr = r\\n    }\\n    return addition\\n};", "var addRungs = function(rungs, dist) {\\n    let res = 0;\\n    let prev = 0;\\n    for ( let i = 0; i < rungs.length; i++ ){\\n        res += Math.floor(( rungs[i] - prev - 1 ) / dist ); \\n        prev = rungs[i];\\n    }\\n    return res;\\n};", "var addRungs = function (rungs, dist) {\\n  return rungs.reduce(\\n    (acc, cur) => {\\n      let [prev, res] = acc;\\n      return [cur, res + Math.floor((cur - prev - 1) / dist)];\\n    },\\n    [0, 0]\\n  )[1];\\n};"]}
{"id": "1430", "ref_js": ["var maxPoints = function(points) {\\n    let prev = points[0]; \\n    let curr = Array(points[0].length); \\n    \\n    for(let i = 1; i<points.length; i++){\\n        \\n        ", "var maxPoints = function (points) {\\n\\tlet m = points.length;\\n\\tlet n = points[0].length;\\n\\tlet dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\\n\\tdp[0] = points[0];\\n\\n\\tfor (let i = 1; i < m; i++) {\\n\\t\\t", "var maxPoints = function(points) {\\n    let prev = points[0]; \\n    let curr = Array(points[0].length); \\n    \\n    for(let i = 1; i<points.length; i++){\\n        \\n        "]}
{"id": "1431", "ref_js": ["var smallestChair = function(times, targetFriend) {\\n\\n    let chairs = Array(times.length).fill(-1);\\n    let timesSorted = [...times].sort( (a, b) => a[0] - b[0]);\\n    \\n    for(let i=0;i<timesSorted.length;i++){\\n        for(let j=0;j<chairs.length;j++){\\n            if(\\n                chairs[j] <= timesSorted[i][0]\\n            ){\\n                chairs[j] = timesSorted[i][1];\\n                if(\\n                    timesSorted[i].toString() === times[targetFriend].toString()\\n                ){\\n                    return(j)\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    \\n};", "var smallestChair = function(times, targetFriend) {\\n    const [targetArrival] = times[targetFriend]; ", "var smallestChair = function(times, targetFriend) {\\n    const [targetArrival] = times[targetFriend]; "]}
{"id": "1432", "ref_js": ["var splitPainting = function (segments) {\\n  let idx2delta = new Map();\\n  segments.forEach(([start_idx, end_idx, color]) => {\\n    idx2delta.set(start_idx, (idx2delta.get(start_idx) || 0) + color);\\n    idx2delta.set(end_idx, (idx2delta.get(end_idx) || 0) - color);\\n  });\\n\\n  let res = [];\\n  let prev_idx = 0;\\n  Array.from(idx2delta.keys())\\n    .sort((a, b) => a - b)\\n    .forEach((cur_idx) => {\\n      if (idx2delta.get(prev_idx))\\n        res.push([prev_idx, cur_idx, idx2delta.get(prev_idx)]);\\n      idx2delta.set(\\n        cur_idx,\\n        idx2delta.get(cur_idx) + (idx2delta.get(prev_idx) || 0)\\n      );\\n      prev_idx = cur_idx;\\n    });\\n  return res;\\n};", "var splitPainting = function(segments) {\\n    const arr = [];\\n    segments.forEach(([start, end, val])=>{\\n        arr.push([start, val]);\\n        arr.push([end, -val]);\\n    });\\n    arr.sort((i,j)=>i[0]-j[0]);\\n    \\n    const ans = [];\\n    let currVal = 0, prevTime;\\n    arr.forEach(([time, val])=>{\\n        if(prevTime !== undefined && currVal && prevTime !== time) ans.push([prevTime, time, currVal]);\\n        currVal += val;\\n        prevTime = time;\\n    })\\n    \\n    return ans;\\n};", "var splitPainting = function(segments) {\\n    const arr = [];\\n    segments.forEach(([start, end, val])=>{\\n        arr.push([start, val]);\\n        arr.push([end, -val]);\\n    });\\n    arr.sort((i,j)=>i[0]-j[0]);\\n    \\n    const ans = [];\\n    let currVal = 0, prevTime;\\n    arr.forEach(([time, val])=>{\\n        if(prevTime !== undefined && currVal && prevTime !== time) ans.push([prevTime, time, currVal]);\\n        currVal += val;\\n        prevTime = time;\\n    })\\n    \\n    return ans;\\n};"]}
{"id": "1433", "ref_js": ["var maximumNumber = function (num, change) {\\n\\tlet ans = \\'\\'\\n\\tlet i = 0;\\n\\n\\tfor (i; i < num.length; i++) {\\n\\t\\tif (parseInt(num[i]) >= change[num[i]]) {\\n\\t\\t\\tans += num[i]\\n\\t\\t}\\n\\t\\telse break;\\n\\t}\\n\\tfor (i; i < num.length; i++){\\n\\t\\tif(parseInt(num[i]) <= change[num[i]]){\\n\\t\\t\\tans+= change[num[i]].toString()\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tans+=num.slice(i);\\n\\treturn ans\\n};", "var maximumNumber = function(num, change) {    \\n  let startIndex = 0, endIndex = 0;\\n  let substring = \"\";\\n\\n  for (let i = 0; i < num.length; i++) {\\n    if (change[num[i]] > num[i]) { ", "var maximumNumber = function(num, change) {\\n    const digits = num.split(\"\");\\n    \\n    let started = false;\\n    \\n    for (let i = 0; i < digits.length; ++i) {\\n        const origDig = digits[i];\\n        const changeDig = change[origDig];\\n        \\n        if (changeDig > origDig) {\\n            started = true;\\n            digits[i] = changeDig;\\n        }\\n        else if (changeDig < origDig && started) {\\n            break;\\n        }\\n    }\\n    \\n    return digits.join(\"\"); \\n};"]}
{"id": "1434", "ref_js": ["var maxCompatibilitySum = function(S, M) {\\n    let m=S.length, A=[...Array(m)].map(d=>[...Array(m)])\\n    for(let i=0;i<m;i++ )\\n        for(let j=0;j<m;j++)\\n            A[i][j]=-S[i].reduce((a,c,k)=> a+ Number(c===M[j][k]),0)\\n    return -HunFast(A)\\n};", "var maxCompatibilitySum = function(students, mentors) {\\n    const m = students.length;\\n    const n = students[0].length;\\n   \\n    let max = 0;\\n    \\n    dfs(0, (1 << m) - 1, 0);\\n    \\n    return max;\\n    \\n    function dfs(studentIdx, bitmask, scoreTally) {\\n        if (studentIdx === m) {\\n            max = Math.max(max, scoreTally);\\n            \\n            return;\\n        }\\n        \\n        for (let mentorIdx = 0; mentorIdx < m; ++mentorIdx) {\\n            if (bitmask & (1 << mentorIdx)) {\\n                const matchScore = hammingDistance(students[studentIdx], mentors[mentorIdx]);\\n                const setMask = bitmask ^ (1 << mentorIdx);\\n                \\n                dfs(studentIdx + 1, setMask, scoreTally + matchScore);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    function hammingDistance(studentsAnswers, mentorsAnswers) {\\n        let matches = 0;\\n        \\n        for (let j = 0; j < n; ++j) {\\n            if (studentsAnswers[j] === mentorsAnswers[j]) ++matches;\\n        }\\n        \\n        return matches;\\n    }\\n};", "var maxCompatibilitySum = function(students, mentors) {\\n  "]}
{"id": "1435", "ref_js": ["var numberOfWeeks = function(milestones) {\\n    if(milestones.length===1){\\n        return 1;\\n    }\\n    let maxElement = -1, arrSum=0,rest, difference;\\n    for(let i=0;i<milestones.length;i++){\\n        arrSum+=milestones[i];\\n        maxElement = Math.max(maxElement,milestones[i]);\\n    }\\n    rest = arrSum-maxElement;\\n    difference = maxElement - rest;\\n    if(difference<=1){\\n        return arrSum;\\n    }\\n    return (arrSum - difference)+1;\\n};", "var numberOfWeeks = function(milestones) {\\n    if(milestones.length===1){\\n        return 1;\\n    }\\n    let maxElement = -1, arrSum=0,rest, difference;\\n    for(let i=0;i<milestones.length;i++){\\n        arrSum+=milestones[i];\\n        maxElement = Math.max(maxElement,milestones[i]);\\n    }\\n    rest = arrSum-maxElement;\\n    difference = maxElement - rest;\\n    if(difference<=1){\\n        return arrSum;\\n    }\\n    return (arrSum - difference)+1;\\n};", "var numberOfWeeks = function(milestones) {\\n    if(milestones.length===1){\\n        return 1;\\n    }\\n    let maxElement = -1, arrSum=0,rest, difference;\\n    for(let i=0;i<milestones.length;i++){\\n        arrSum+=milestones[i];\\n        maxElement = Math.max(maxElement,milestones[i]);\\n    }\\n    rest = arrSum-maxElement;\\n    difference = maxElement - rest;\\n    if(difference<=1){\\n        return arrSum;\\n    }\\n    return (arrSum - difference)+1;\\n};"]}
{"id": "1436", "ref_js": ["var minimumPerimeter = function (neededApples) {\\n    ", "var minimumPerimeter = function(neededApples) {\\n    \\n    \\n    let start = 2, n = 1, dp = [0];\\n    \\n    while(true){\\n        let cur = start, res = dp[n-1];\\n\\t\\t\\n\\t\\t", "var minimumPerimeter = function (neededApples) {\\n    "]}
{"id": "1437", "ref_js": ["var checkMove = function(board, rMove, cMove, color) {\\n    const moves = [-1, 0, 1];\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < 3; ++i) {\\n        for (let j = 0; j < 3; ++j) {\\n            if (i === 1 && j === 1) continue;\\n            \\n            const rowDir = moves[i];\\n            const colDir = moves[j];\\n            \\n            if (isLegal(rMove, cMove, rowDir, colDir, color, 1)) return true;\\n        }\\n    }\\n    \\n    return false;\\n      \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < 8 && col < 8;\\n    }\\n   \\n    function isLegal(currRow, currCol, rowDir, colDir, startColor, length) {\\n        if (!withinBound(currRow, currCol)) return false; ", "var checkMove = function(board, rMove, cMove, color) {\\n    const directions = [[0,1], [0,-1], [1,0], [-1,0],\\n                       [1,1], [1,-1], [-1,-1], [-1,1]];\\n    \\n    board[rMove][cMove] = color;\\n    \\n    function legal(row, col, color, direct){\\n        const [rd, cd] = direct;\\n        let length=1;\\n        row+=rd;\\n        col+=cd;\\n        while (row<board.length && row>=0 && col<board.length && col>=0) {\\n            length++;\\n            if (board[row][col]===\".\") return false;\\n            if (board[row][col]===color) return length>=3;\\n            row+=rd;\\n            col+=cd;\\n        }\\n        return false;\\n    }\\n    \\n    for (const d of directions){\\n        if (legal(rMove, cMove, color, d)) return true;\\n    }\\n    return false;\\n};", "var checkMove = function(board, rMove, cMove, color) {\\n    const moves = [-1, 0, 1];\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < 3; ++i) {\\n        for (let j = 0; j < 3; ++j) {\\n            if (i === 1 && j === 1) continue;\\n            \\n            const rowDir = moves[i];\\n            const colDir = moves[j];\\n            \\n            if (isLegal(rMove, cMove, rowDir, colDir, color, 1)) return true;\\n        }\\n    }\\n    \\n    return false;\\n      \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < 8 && col < 8;\\n    }\\n   \\n    function isLegal(currRow, currCol, rowDir, colDir, startColor, length) {\\n        if (!withinBound(currRow, currCol)) return false; "]}
{"id": "1438", "ref_js": ["var minSpaceWastedKResizing = function(nums, k) {\\n    var prefixSum = []; ", "var minSpaceWastedKResizing = function(nums, k) {\\n    var prefixSum = []; ", "var minSpaceWastedKResizing = function(nums, k) {\\n    var prefixSum = []; "]}
{"id": "1439", "ref_js": ["var minStoneSum = function(piles, k) \\n{\\n    let sizes = Array(10001).fill(0), stones = 0, removed = 0;\\n    for(let pile of piles)\\n    {\\n        sizes[pile]++;\\n        stones += pile;\\n    }\\n\\n    let ep = sizes.length-1;\\n    for(let i=0; i<k; i++)\\n    {\\n        while(sizes[ep] === 0)\\n            ep--;\\n        let nextRemoved = Math.floor(ep/2);\\n        removed += nextRemoved;\\n        sizes[ep-nextRemoved]++;\\n        sizes[ep]--;\\n    }\\n        \\n    return stones - removed;\\n};", "var minStoneSum = function(piles, k) \\n{\\n    let sizes = Array(10001).fill(0), stones = 0, removed = 0;\\n    for(let pile of piles)\\n    {\\n        sizes[pile]++;\\n        stones += pile;\\n    }\\n\\n    let ep = sizes.length-1;\\n    for(let i=0; i<k; i++)\\n    {\\n        while(sizes[ep] === 0)\\n            ep--;\\n        let nextRemoved = Math.floor(ep/2);\\n        removed += nextRemoved;\\n        sizes[ep-nextRemoved]++;\\n        sizes[ep]--;\\n    }\\n        \\n    return stones - removed;\\n};", "var minStoneSum = function(piles, k) \\n{\\n    let sizes = Array(10001).fill(0), stones = 0, removed = 0;\\n    for(let pile of piles)\\n    {\\n        sizes[pile]++;\\n        stones += pile;\\n    }\\n\\n    let ep = sizes.length-1;\\n    for(let i=0; i<k; i++)\\n    {\\n        while(sizes[ep] === 0)\\n            ep--;\\n        let nextRemoved = Math.floor(ep/2);\\n        removed += nextRemoved;\\n        sizes[ep-nextRemoved]++;\\n        sizes[ep]--;\\n    }\\n        \\n    return stones - removed;\\n};"]}
{"id": "1440", "ref_js": ["var minSwaps = function(str) {\\n    let balance = 0,\\n        maxClose = 0;\\n    for(let s of str){\\n        s === \\']\\'? balance++ : balance--;\\n        maxClose = Math.max(maxClose, balance);\\n    }\\n    return Math.ceil(maxClose/2)\\n};", "var minSwaps = function(s) {\\n    let stk = []\\n    for(let c of s){\\n        if(stk && c == \\']\\')    stk.pop()\\n        else if(c == \\'[\\')   stk.push(c)\\n    }\\n    return (stk.length) / 2\\n};", "var minSwaps = function(s) {\\n    var mismatch  = 0;\\n    var cnt = 0;\\n    for(var i=0; i<s.length; i++)\\n    {\\n        if(s[i] === \\']\\')\\n        {\\n            cnt--;\\n        }\\n        else\\n        {\\n             cnt++;\\n        }\\n        if(cnt < 0)\\n        {\\n            mismatch = Math.min(mismatch, cnt);\\n        }\\n    }\\n    return  Math.ceil(-mismatch/ 2);\\n};"]}
{"id": "1441", "ref_js": ["var rearrangeArray = function(nums) {\\n    let res = [];\\n    let len = nums.length;\\n    nums.sort((a, b) => a-b);\\n    res = [...nums];\\n\\n    while(true){\\n        ", "var rearrangeArray = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    \\n    let res = [];\\n    \\n    let l = 0;\\n    let r = nums.length - 1;\\n    \\n    while (l < r) {\\n        res.push(nums[l]);\\n        res.push(nums[r]);\\n        \\n        l++;\\n        r--;\\n    }\\n    \\n    if (nums.length % 2 === 1) res.push(nums[l])\\n    \\n    return res;\\n};", "var rearrangeArray = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    \\n    let res = [];\\n    \\n    let l = 0;\\n    let r = nums.length - 1;\\n    \\n    while (l < r) {\\n        res.push(nums[l]);\\n        res.push(nums[r]);\\n        \\n        l++;\\n        r--;\\n    }\\n    \\n    if (nums.length % 2 === 1) res.push(nums[l])\\n    \\n    return res;\\n};"]}
{"id": "1442", "ref_js": ["var minNonZeroProduct = function(p) {\\n    let r=BigInt(1)\\n   p=BigInt(p)\\n   r=(2n**p)-2n\\n    let mod=BigInt(1000000007)\\n    function rec(n,r){\\n        if(n==0n)return 1n\\n        if(n==1n)return r%mod\\n        if(n%2n!=0n){\\n            const temp=rec((n-1n)/2n,r)\\n            return (r*(temp*temp)%mod)%mod\\n        }\\n        else{\\n            const temp=rec(n/2n,r)%mod\\n             return (temp*temp)%mod\\n        }\\n    }\\n    return (rec(r/2n,r)*(r+1n))%mod\\n    \\n    \\n    \\n};", "var minNonZeroProduct = function(p) {\\n    p = BigInt(p);\\n    \\n    const MOD = BigInt(1e9 + 7);\\n    const first = ((1n << p) - 1n);\\n    \\n   const half = first / 2n;\\n    \\n    const second = powMOD(first - 1n, half); \\n    \\n    return (first * second) % MOD;\\n    \\n    function powMOD(num, exp) {\\n        if (exp === 0n) return 1n; \\n        \\n        const tmp = powMOD(num, exp >> 1n);\\n        \\n        let res = (tmp * tmp) % MOD;\\n        \\n        if (exp % 2n) res = (res * num) % MOD;\\n        \\n        return res;\\n    }\\n};", "var minNonZeroProduct = function(p) {\\n    p = BigInt(p);\\n    \\n    const MOD = BigInt(1e9 + 7);\\n    const first = ((1n << p) - 1n);\\n    \\n   const half = first / 2n;\\n    \\n    const second = powMOD(first - 1n, half); \\n    \\n    return (first * second) % MOD;\\n    \\n    function powMOD(num, exp) {\\n        if (exp === 0n) return 1n; \\n        \\n        const tmp = powMOD(num, exp >> 1n);\\n        \\n        let res = (tmp * tmp) % MOD;\\n        \\n        if (exp % 2n) res = (res * num) % MOD;\\n        \\n        return res;\\n    }\\n};"]}
{"id": "1443", "ref_js": ["var maxMatrixSum = function(matrix) {\\n    const MAX= Number.MAX_SAFE_INTEGER;\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    \\n    let negs = 0;\\n    \\n    let totAbsSum = 0;\\n    let minAbsNum = MAX;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            if (matrix[i][j] < 0) ++negs;\\n            \\n            totAbsSum += Math.abs(matrix[i][j]);\\n            minAbsNum = Math.min(minAbsNum, Math.abs(matrix[i][j]));\\n        }\\n    }\\n    \\n    if (negs % 2 === 1) totAbsSum -= (2 * minAbsNum);\\n    \\n\\treturn totAbsSum;\\n};", "var maxMatrixSum = function(matrix) {\\n    let res = 0, bad = 0, min = Infinity;\\n    for(let i = 0; i < matrix.length; i++){\\n        for(let j = 0; j < matrix[0].length; j++){\\n            res+=Math.abs(matrix[i][j]);\\n            if(matrix[i][j]<0) bad++;\\n            min = Math.min(min, Math.abs(matrix[i][j]))\\n        }\\n    }\\n    if(bad%2===1) res-=min*2;\\n    return res;\\n};", "var maxMatrixSum = function (matrix) {\\n    let n = matrix.length;\\n\\n    let sum = 0;\\n\\n    let min = Infinity;\\n    let countOfNegative = 0;\\n    for (let i = 0; i < n; i++)\\n        for (let j = 0; j < n; j++) {\\n            sum += Math.abs(matrix[i][j]);\\n            min = Math.min(min, Math.abs(matrix[i][j]));\\n            if (matrix[i][j] < 0)\\n                countOfNegative++;\\n        }\\n    if (countOfNegative % 2 !== 0) {\\n        let considerNegative = true;\\n        OUTER:\\n            for (let i = 0; i < n; i++)\\n                for (let j = 0; j < n; j++)\\n                    if (matrix[i][j] === 0) {\\n                        considerNegative = false;\\n                        break OUTER;\\n                    }\\n        if (considerNegative)\\n            sum += 2 * -min;\\n    }\\n\\n    return sum;\\n};"]}
{"id": "1444", "ref_js": ["var countPaths = function(n, roads) {\\n    const MOD = 10 ** 9 + 7;\\n    const graph = buildGraph(roads, n);\\n    const times = new Array(n).fill(Infinity);\\n    const ways = new Array(n).fill(0);\\n\\n    times[0] = 0;\\n    ways[0] = 1;\\n    const priorityList = [[0, 0]]\\n\\n    while (priorityList.length) {\\n        let [node, t] = priorityList.pop();\\n\\n        for (let [neighbor, weight] of graph[node]) {\\n            const newTime = t + weight;\\n\\n            if (newTime < times[neighbor]) {\\n                times[neighbor] = newTime;\\n                priorityList.push([neighbor, newTime]);\\n                priorityList.sort((a, b) => b[1] - a[1]);\\n                ways[neighbor] = ways[node];\\n            } else if (newTime === times[neighbor]) {\\n                ways[neighbor] += ways[node] % MOD;\\n            }\\n        }\\n    }\\n\\n    return ways[n-1] % MOD;\\n};", "var countPaths = function(n, roads) {\\n    const MOD = 10 ** 9 + 7;\\n    const graph = buildGraph(roads, n);\\n    const times = new Array(n).fill(Infinity);\\n    const ways = new Array(n).fill(0);\\n\\n    times[0] = 0;\\n    ways[0] = 1;\\n    const priorityList = [[0, 0]]\\n\\n    while (priorityList.length) {\\n        let [node, t] = priorityList.pop();\\n\\n        for (let [neighbor, weight] of graph[node]) {\\n            const newTime = t + weight;\\n\\n            if (newTime < times[neighbor]) {\\n                times[neighbor] = newTime;\\n                priorityList.push([neighbor, newTime]);\\n                priorityList.sort((a, b) => b[1] - a[1]);\\n                ways[neighbor] = ways[node];\\n            } else if (newTime === times[neighbor]) {\\n                ways[neighbor] += ways[node] % MOD;\\n            }\\n        }\\n    }\\n\\n    return ways[n-1] % MOD;\\n};", "var countPaths = function(n, roads) {\\n    const MOD = 10 ** 9 + 7;\\n    const graph = buildGraph(roads, n);\\n    const times = new Array(n).fill(Infinity);\\n    const ways = new Array(n).fill(0);\\n\\n    times[0] = 0;\\n    ways[0] = 1;\\n    const priorityList = [[0, 0]]\\n\\n    while (priorityList.length) {\\n        let [node, t] = priorityList.pop();\\n\\n        for (let [neighbor, weight] of graph[node]) {\\n            const newTime = t + weight;\\n\\n            if (newTime < times[neighbor]) {\\n                times[neighbor] = newTime;\\n                priorityList.push([neighbor, newTime]);\\n                priorityList.sort((a, b) => b[1] - a[1]);\\n                ways[neighbor] = ways[node];\\n            } else if (newTime === times[neighbor]) {\\n                ways[neighbor] += ways[node] % MOD;\\n            }\\n        }\\n    }\\n\\n    return ways[n-1] % MOD;\\n};"]}
{"id": "1445", "ref_js": ["var findDifferentBinaryString = function(nums) {\\n    let result = \"\";\\n\\n        for (let i = 0; i < nums.length; ++i) {\\n            result += (nums[i][i] === \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n\\n        return result;\\n};", "var findDifferentBinaryString = function(nums) {\\n    const seen = new Set();\\n\\n    for (const binaryString of nums) {\\n        seen.add(parseInt(binaryString, 2));\\n    }\\n\\n    const n = nums[0].length;\\n\\n    for (let i = 0; i <= nums.length; i++) {\\n        if (!seen.has(i)) {\\n            return i.toString(2).padStart(n, \\'0\\');\\n        }\\n    }    \\n};", "var findDifferentBinaryString = function(nums) {\\n    const seen = new Set();\\n\\n    for (const binaryString of nums) {\\n        seen.add(parseInt(binaryString, 2));\\n    }\\n\\n    const n = nums[0].length;\\n\\n    for (let i = 0; i <= nums.length; i++) {\\n        if (!seen.has(i)) {\\n            return i.toString(2).padStart(n, \\'0\\');\\n        }\\n    }    \\n};"]}
{"id": "1446", "ref_js": ["var minimizeTheDifference = function(mat, target) {\\n    let possibleSums = new Set(mat[0]);\\n    for (let row = 1; row < mat.length; row++) {\\n        const nextPossibleSums = new Set();\\n        let min = Infinity;\\n        for (let col = 0; col < mat[row].length; col++) {\\n            for (const num of possibleSums) {\\n                const sum = num + mat[row][col];\\n                ", "var minimizeTheDifference = function(mat, target) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    \\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        memo[i] = new Array(4901).fill(MAX);\\n    }\\n    \\n    return topDown(0, 0);\\n    \\n    function topDown(row, sum) {\\n        if (row === m) return Math.abs(target - sum);\\n        if (memo[row][sum] != MAX) return memo[row][sum];\\n        \\n        let min = MAX;\\n        \\n        mat[row].sort((a, b) => a - b); \\n        \\n        const set = new Set(mat[row]);\\n       \\n        for (const num of set) {\\n           const res = topDown(row + 1, sum + num);\\n            \\n           if (res > min) break;\\n           min = res;\\n        }\\n        \\n        memo[row][sum] = min;\\n        \\n        return min;\\n    }\\n};", "var minimizeTheDifference = function(mat, target) {\\n    let possibleSums = new Set(mat[0]);\\n    for (let row = 1; row < mat.length; row++) {\\n        const nextPossibleSums = new Set();\\n        let min = Infinity;\\n        for (let col = 0; col < mat[row].length; col++) {\\n            for (const num of possibleSums) {\\n                const sum = num + mat[row][col];\\n                "]}
{"id": "1447", "ref_js": ["var kthLargestNumber = function(nums, k) {\\n     nums.sort((a,b)=> BigInt(a)<BigInt(b) ? 1 :  BigInt(a)>BigInt(b) ? -1 : 0 );\\n    return nums[k-1]\\n};", "var kthLargestNumber = function(nums, k) {\\n    let maxHeap = new MaxPriorityQueue({\\n        compare: (a,b)=>{\\n            return b-a\\n        }\\n    })\\n    nums.forEach(n=> maxHeap.enqueue(BigInt(n)))\\n\\n    while(k>1){\\n        maxHeap.dequeue()\\n        k--\\n    }\\n    return maxHeap.front().toString()\\n};", "var kthLargestNumber = function(nums, k) {\\n    let maxHeap = new MaxPriorityQueue({\\n        compare: (a,b)=>{\\n            return b-a\\n        }\\n    })\\n    nums.forEach(n=> maxHeap.enqueue(BigInt(n)))\\n\\n    while(k>1){\\n        maxHeap.dequeue()\\n        k--\\n    }\\n    return maxHeap.front().toString()\\n};"]}
{"id": "1448", "ref_js": ["var minSessions = function(tasks, sessionTime) {\\n    let ans = Infinity;\\n    const buckets = []\\n    const solve = (idx = 0) => {\\n        if (idx === tasks.length) {\\n            ans = Math.min(ans, buckets.length);\\n            return;\\n        }\\n        if (buckets.length >= ans) return;\\n        ", "var minSessions = function(tasks, sessionTime) {\\n    let ans = Infinity;\\n    const buckets = []\\n    const solve = (idx = 0) => {\\n        if (idx === tasks.length) {\\n            ans = Math.min(ans, buckets.length);\\n            return;\\n        }\\n        if (buckets.length >= ans) return;\\n        ", "var minSessions = function(tasks, sessionTime) {\\n    let ans = Infinity;\\n    const buckets = []\\n    const solve = (idx = 0) => {\\n        if (idx === tasks.length) {\\n            ans = Math.min(ans, buckets.length);\\n            return;\\n        }\\n        if (buckets.length >= ans) return;\\n        "]}
{"id": "1449", "ref_js": ["var findFarmland = function(land) {\\n    let height = land.length;\\n    let width = land[0].length;\\n    let results = [];\\n    let endRow = 0;\\n    let endCol = 0;\\n    \\n    let go = (i, j) => {\\n        if (i < 0 || j < 0 || i >= height || j >= width || land[i][j] === 0) {\\n            return;\\n        }\\n        \\n        endRow = Math.max(endRow, i);\\n        endCol = Math.max(endCol, j);\\n        land[i][j] = 0; ", "var findFarmland = function(land) {\\n    if (land.length === 0) return [];\\n\\n    const ROWS = land.length, COLS = land[0].length;\\n    const res = [];\\n\\n    let prevCoords = [-Infinity, -Infinity];\\n    const dfs = (r,c) => {\\n        if (Math.min(r,c) < 0 || r >= ROWS || c >= COLS || land[r][c] === 0) {\\n            return;\\n        }\\n\\n        ", "var findFarmland = function(land) {\\n    let height = land.length;\\n    let width = land[0].length;\\n    let results = [];\\n    let endRow = 0;\\n    let endCol = 0;\\n    \\n    let go = (i, j) => {\\n        if (i < 0 || j < 0 || i >= height || j >= width || land[i][j] === 0) {\\n            return;\\n        }\\n        \\n        endRow = Math.max(endRow, i);\\n        endCol = Math.max(endCol, j);\\n        land[i][j] = 0; "]}
{"id": "1451", "ref_js": ["var numberOfWeakCharacters = function(properties) {\\n    properties.sort((a,b) => (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]))\\n    let count = 0, max = 0\\n    for(let arr of properties){\\n        if(arr[1] < max)    count++\\n        max = Math.max(max, arr[1])\\n    }\\n    return count\\n};", "var numberOfWeakCharacters = function(properties) {\\n    properties.sort((a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n    let count = 0, maxDefence = -Infinity;\\n\\t\\n\\tfor (let i = properties.length - 1; i >= 0; i--) {\\n\\t\\tif (properties[i][1] < maxDefence)\\n\\t\\t\\tcount++;\\n\\t\\telse\\t\\t\\n\\t\\t\\tmaxDefence = properties[i][1];\\n\\t}\\n\\n\\treturn count;\\n};", "var numberOfWeakCharacters = function(properties) {\\n    properties.sort((a,b) => (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]))\\n    let count = 0, max = 0\\n    for(let arr of properties){\\n        if(arr[1] < max)    count++\\n        max = Math.max(max, arr[1])\\n    }\\n    return count\\n};"]}
{"id": "1452", "ref_js": ["var shoppingOffers = function(price, special, needs) {\\n  let betterSpecials = special.filter((s) => \\n      !special.some(s2 => s.at(-1) > s2.at(-1) && s.slice(0, -1).every((y, j) => y === s2[j]))\\n  )\\n    function check(price, special, needs){\\n    let offer = needs.reduce((sum, n, i) => sum + n * price[i], 0);\\n    for(const s of special){\\n    if(s.some((x, i) => x > needs[i])) continue;\\n    offer = Math.min(offer, s.at(-1) + check(price, special, needs.map((n, i) => n - s[i])));\\n        }\\n        return offer;\\n    }\\n    return check(price, betterSpecials, needs);\\n};", "var shoppingOffers = function(price, special, needs) {\\n    const memo = new Map();\\n\\n    function minCost(needs) {\\n        const key = needs.join(\\',\\');\\n\\n        if (memo.has(key)) {\\n            return memo.get(key);\\n        }\\n\\n        let cost = 0;\\n\\n        ", "var shoppingOffers = function(price, offers, needs) {\\n    let ans = new Map() ; \\n    return f(price , needs , offers , ans) ;\\n};"]}
{"id": "1453", "ref_js": ["var interchangeableRectangles = function(rectangles) {\\n    let m = new Map();\\n    for (let i = 0; i < rectangles.length; i++) {\\n        let width = rectangles[i][0];\\n        let height = rectangles[i][1];\\n        let aspectRatio = width / height;\\n        \\n        if (!m.has(aspectRatio)) {\\n            m.set(aspectRatio, 1);\\n        } else {\\n            m.set(aspectRatio, m.get(aspectRatio) + 1);\\n        }\\n    }\\n    \\n    let ans = 0;\\n    m.forEach((value) => {\\n        if (value > 1) {\\n            let n = value - 1;\\n            ans += (n * (n + 1)) / 2;\\n        }\\n    });\\n    \\n    return ans;\\n};", "var interchangeableRectangles = function(rectangles) {\\n    let ratio = {}\\n    let res = 0\\n    for (let i = 0; i < rectangles.length; i++) {\\n        const rectangle = rectangles[i]\\n        let r = rectangle[0]/rectangle[1]\\n        \\n        if (!ratio[r]) {\\n            ratio[r] = 0\\n        }\\n        res += ratio[r]\\n        ratio[r]++\\n    }\\n    return res\\n};", "var interchangeableRectangles = function(rectangles) {\\n    "]}
{"id": "1454", "ref_js": ["var maxProduct = function (s) {\\n    function isapalin(a) {\\n        let temp = [...a];\\n        let temps = temp.join(\"\");\\n        let tempsrev = temp.reverse().join(\"\");\\n        return temps === tempsrev;\\n    }\\n\\n    let max = -Infinity;\\n\\n    function bt(start = 0, ar1 = [], ar2 = []) {\\n        if (start === s.length) {\\n            if (isapalin(ar1) && isapalin(ar2)) {\\n                let m = ar1.length;\\n                let n = ar2.length;\\n                max = Math.max(max, m * n);\\n            }\\n            return;\\n        }\\n\\n        ar1.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar1.pop();\\n\\n        ar2.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar2.pop();\\n\\n        bt(start + 1, ar1, ar2);\\n    }\\n\\n    bt();\\n    return max;\\n};", "var maxProduct = function(s) {\\n    const len = s.length\\n    const m = {} ", "var maxProduct = function (s) {\\n    function isapalin(a) {\\n        let temp = [...a];\\n        let temps = temp.join(\"\");\\n        let tempsrev = temp.reverse().join(\"\");\\n        return temps === tempsrev;\\n    }\\n\\n    let max = -Infinity;\\n\\n    function bt(start = 0, ar1 = [], ar2 = []) {\\n        if (start === s.length) {\\n            if (isapalin(ar1) && isapalin(ar2)) {\\n                let m = ar1.length;\\n                let n = ar2.length;\\n                max = Math.max(max, m * n);\\n            }\\n            return;\\n        }\\n\\n        ar1.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar1.pop();\\n\\n        ar2.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar2.pop();\\n\\n        bt(start + 1, ar1, ar2);\\n    }\\n\\n    bt();\\n    return max;\\n};"]}
{"id": "1455", "ref_js": ["var findOriginalArray = function(changed) {\\n    const result = [];\\n    const map = new Map();\\n    \\n    changed.sort((a, b) => a - b);\\n    \\n    for (let i = 0; i < changed.length; i++) {\\n        const currentValue = changed[i];\\n\\n        if (map.has(currentValue)) {\\n            const currentValueFrequencyAtMoment = map.get(currentValue);\\n            \\n            if (currentValueFrequencyAtMoment === 1) {\\n                map.delete(currentValue)\\n            } else {\\n                map.set(currentValue, currentValueFrequencyAtMoment - 1);\\n            }\\n        } else {\\n            const doubledValue = currentValue * 2;\\n\\n            if (map.has(doubledValue)) {\\n                map.set(doubledValue, map.get(doubledValue) + 1);\\n            } else {\\n                map.set(doubledValue, 1);\\n            }\\n\\n            result.push(currentValue);\\n        }\\n    }\\n    \\n    return map.size > 0 ? [] : result;\\n};", "var findOriginalArray = function(changed) {\\n    changed.sort((a,b) => a-b);\\n    let result = [];\\n    let map = new Map();\\n    \\n    for(let i = 0; i < changed.length; i++){\\n        let c = changed[i];\\n        let o = map.get(c/2);\\n        \\n        if(c % 2 === 1 || !o){\\n            map.set(c, (map.get(c) ?? 0) + 1);\\n        }\\n        else{\\n            result.push(c/2);\\n            map.set(c/2, o - 1);\\n        }\\n    }\\n \\n    return changed.length / result.length === 2 ? result : [];\\n};", "var findOriginalArray = function(changed) {\\n    if (changed.length % 2 === 1) {\\n        return [];\\n    }\\n\\n    var frequency = [];\\n    var index_frequency = 0;\\n    var maxLength = Math.pow(10, 5) + 1;\\n    while (index_frequency < maxLength) {\\n        frequency[index_frequency++] = 0;\\n    }\\n\\n\\n    for (let n of changed) {\\n        frequency[n]++;\\n    }\\n\\n    if (frequency[0] % 2 === 1) {\\n        return [];\\n    }\\n\\n    var original = [];\\n    var index_original = 0;\\n    for (let i = 0; i < maxLength; i++) {\\n        while (2 * i < maxLength && frequency[i] > 0 && frequency[2 * i] > 0) {\\n            original[index_original++] = i;\\n            frequency[i]--;\\n            frequency[2 * i]--;\\n        }\\n    }\\n    return (index_original === changed.length / 2) ? original : [];\\n};"]}
{"id": "1456", "ref_js": ["var maxTaxiEarnings = function(n, rides) {\\n    \\n    const len = rides.length\\n    \\n    rides.sort((a,b) => {\\n        return a[1] - b[1]\\n    })\\n    \\n    ", "var maxTaxiEarnings = function(n, rides) {\\n    rides.sort(([startA], [startB]) => startA - startB);\\n    const pq = new MinPriorityQueue({priority: ([end]) => end});\\n    let maxEarnings = 0;\\n    \\n    for (const [start, end, tip] of rides) {\\n        while (!pq.isEmpty() && start >= pq.front().element[0]) {\\n            const [_, earnings] = pq.dequeue().element;\\n            maxEarnings = Math.max(maxEarnings, earnings);\\n        }\\n        pq.enqueue([end, maxEarnings + end - start + tip]);\\n    }\\n    \\n    while (!pq.isEmpty()) {\\n        const [_, earnings] = pq.dequeue().element;\\n        maxEarnings = Math.max(maxEarnings, earnings);\\n    }\\n    \\n    return maxEarnings;\\n};", "var maxTaxiEarnings = function(n, rides) {\\n    rides.sort(([startA], [startB]) => startA - startB);\\n    const pq = new MinPriorityQueue({priority: ([end]) => end});\\n    let maxEarnings = 0;\\n    \\n    for (const [start, end, tip] of rides) {\\n        while (!pq.isEmpty() && start >= pq.front().element[0]) {\\n            const [_, earnings] = pq.dequeue().element;\\n            maxEarnings = Math.max(maxEarnings, earnings);\\n        }\\n        pq.enqueue([end, maxEarnings + end - start + tip]);\\n    }\\n    \\n    while (!pq.isEmpty()) {\\n        const [_, earnings] = pq.dequeue().element;\\n        maxEarnings = Math.max(maxEarnings, earnings);\\n    }\\n    \\n    return maxEarnings;\\n};"]}
{"id": "1457", "ref_js": ["var sumOfBeauties = function(nums) {\\n    let min = nums[0], max = Infinity, maxArr = [], total = 0;\\n    \\n\\t", "var sumOfBeauties = function(nums) {\\n \\n    const n = nums.length\\n     \\n    ", "var sumOfBeauties = function(nums) {\\n \\n    const n = nums.length\\n     \\n    "]}
{"id": "1459", "ref_js": ["var gridGame = function(grid) {\\n    let one = grid[0].reduce((a,b)=>a+b) - grid[0][0];\\n    let two = 0;\\n    let res = one;\\n    for(let i = 1; i < grid[0].length; i++){\\n        one-=grid[0][i];\\n        two+=grid[1][i-1];\\n        res = Math.min(res, Math.max(one,two));\\n    }\\n    return res;\\n};", "var gridGame = function(grid) {\\n    \\n    let cols = grid[0].length, ans = Infinity;\\n    let res = Array(2).fill().map(_=>Array(cols).fill(0));\\n    \\n    ", "var gridGame = function(grid) {\\n    \\n    let cols = grid[0].length, ans = Infinity;\\n    let res = Array(2).fill().map(_=>Array(cols).fill(0));\\n    \\n    "]}
{"id": "1460", "ref_js": ["var getNewRegexStr = function (item, regexStr) {\\n    if (item === \\'#\\') {\\n        regexStr += regexStr.length > 0 ? \\'$\\' : \\'^\\';\\n    } else {\\n        ", "var placeWordInCrossword = function(board, word) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            if (i === 0 || board[i - 1][j] === \\'#\\') {\\n                if (match(getFill(i, j, false))) {\\n                    return true;\\n                }\\n            }\\n            if (j === 0 || board[i][j - 1] === \\'#\\') {\\n                if (match(getFill(i, j, true))) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n    \\n    function getFill(x, y, goRight) {\\n        if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] !== \\'#\\') {\\n            return goRight ? board[x][y] + getFill(x, y + 1, goRight) : board[x][y] + getFill(x + 1, y, goRight);\\n        }\\n        return \\'\\';\\n    }\\n    \\n    function match(str) {\\n        if (str.length !== word.length) {\\n            return false;\\n        }\\n        let fromLeft = true;\\n        let fromRight = true;\\n        let l = 0;\\n        let r = str.length - 1;\\n        for (let each of word) {\\n            if (!fromLeft && !fromRight) {\\n                return false;\\n            }\\n            if (fromLeft) {\\n                if (each !== str[l] && str[l] !== \\' \\') {\\n                    fromLeft = false;\\n                }\\n                l++;\\n            }\\n            if (fromRight) {\\n                if (each !== str[r] && str[r] !== \\' \\') {\\n                    fromRight = false;\\n                }\\n                r--;\\n            }\\n        }\\n        return fromLeft || fromRight;\\n    }\\n};", "var placeWordInCrossword = function(board, word) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            if (i === 0 || board[i - 1][j] === \\'#\\') {\\n                if (match(getFill(i, j, false))) {\\n                    return true;\\n                }\\n            }\\n            if (j === 0 || board[i][j - 1] === \\'#\\') {\\n                if (match(getFill(i, j, true))) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n    \\n    function getFill(x, y, goRight) {\\n        if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] !== \\'#\\') {\\n            return goRight ? board[x][y] + getFill(x, y + 1, goRight) : board[x][y] + getFill(x + 1, y, goRight);\\n        }\\n        return \\'\\';\\n    }\\n    \\n    function match(str) {\\n        if (str.length !== word.length) {\\n            return false;\\n        }\\n        let fromLeft = true;\\n        let fromRight = true;\\n        let l = 0;\\n        let r = str.length - 1;\\n        for (let each of word) {\\n            if (!fromLeft && !fromRight) {\\n                return false;\\n            }\\n            if (fromLeft) {\\n                if (each !== str[l] && str[l] !== \\' \\') {\\n                    fromLeft = false;\\n                }\\n                l++;\\n            }\\n            if (fromRight) {\\n                if (each !== str[r] && str[r] !== \\' \\') {\\n                    fromRight = false;\\n                }\\n                r--;\\n            }\\n        }\\n        return fromLeft || fromRight;\\n    }\\n};"]}
{"id": "1461", "ref_js": ["var numOfPairs = function(nums, target) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (target.startsWith(nums[i])) {\\n            for (let j = 0; j < nums.length; j++) {\\n                if (i != j && nums[i] + nums[j] === target) {\\n                    count++\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};", "var numOfPairs = function(nums, target) {\\n    var count = 0;\\n    var x = 0;\\n    while (x < nums.length) {\\n        for (let y = 0; y<nums.length; y++) {\\n            if (nums[x] + nums[y] == target) {\\n                count += 1;\\n                if (x == y) {\\n                    count -= 1;\\n                }\\n            }\\n        }\\n        x++;\\n    }\\n    return count;\\n};", "var numOfPairs = function(nums, target) {\\n    var count = 0;\\n    var x = 0;\\n    while (x < nums.length) {\\n        for (let y = 0; y<nums.length; y++) {\\n            if (nums[x] + nums[y] == target) {\\n                count += 1;\\n                if (x == y) {\\n                    count -= 1;\\n                }\\n            }\\n        }\\n        x++;\\n    }\\n    return count;\\n};"]}
{"id": "1462", "ref_js": ["var maxConsecutiveAnswers = function(answerKey, k) {\\n  ", "var maxConsecutiveAnswers = function(answerKey, k) {\\n  ", "var maxConsecutiveAnswers = function(answerKey, k) {\\n  "]}
{"id": "1463", "ref_js": ["var missingRolls = function(rolls, mean, n) {\\n    const len = rolls.length;\\n\\n    let missVal = (len + n) * mean - rolls.reduce((prev, curr)=>prev+curr);\\n    let divender = Math.floor(missVal / n);\\n    let remainder = missVal % n;\\n    if ((divender >= 6 && remainder > 0) || divender < 1 || remainder < 0) return [];\\n    const res = [];\\n    while(remainder-- > 0){\\n        if(divender + 1 > 6) return [];\\n        res.push(divender + 1);\\n        n--;\\n    }\\n    while(n-- > 0){\\n        if(divender > 6) return [];\\n        res.push(divender);\\n    }\\n    return res; \\n};", "var missingRolls = function(rolls, mean, n) {\\n    const m = rolls.length;\\n    const observations = m + n;\\n\\n    let totSum = observations * mean;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const val = rolls[i];\\n        \\n        if (val > totSum) return [];\\n        totSum -= val;\\n    } \\n    \\n    if (totSum < n) return [];\\n   \\n    const res = [];\\n    \\n    totSum -= n;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const addVal = Math.min(5, totSum);\\n        res[i] = addVal + 1;\\n        totSum -= addVal;\\n    }\\n    \\n    return totSum != 0 ? [] : res;\\n};", "var missingRolls = function(rolls, mean, n) {\\n  const diff = mean * (rolls.length + n) - rolls.reduce((a, b) => a + b);\\n  if (diff < n) return []; "]}
{"id": "1464", "ref_js": ["var stoneGameIX = function (stones) {\\n\\n    ", "var stoneGameIX = function (stones) {\\n\\n    ", "var stoneGameIX = function (stones) {\\n\\n    "]}
{"id": "1465", "ref_js": ["var minOperations = function(grid, x) {\\n   let sum=0;\\n   for(let arr of grid){\\n       for(let n of arr){\\n           sum+=n;\\n       }\\n   };", "var minOperations = function(grid, x) {\\n    const sorted=[];\\n    if(grid.length===1 && grid[0].length===1) return 0;\\n\\n    for(let r=0;r<grid.length;r++){\\n        for(let c=0;c<grid[r].length;c++){\\n            sorted.push(grid[r][c]);\\n        }\\n    }\\n    sorted.sort((a,b)=>a-b);\\n\\n    const p=Math.trunc(sorted.length/2);", "var minOperations = function(grid, x) {\\n    grid = grid.flat(1);\\n    for (let i = 1; i < grid.length; i++){\\n        if (grid[i - 1] % x !== grid[i] % x) return -1;\\n    }\\n    grid.sort((a, b) => a - b);\\n    let mid = grid[Math.floor(grid.length / 2)];\\n    let res = 0;\\n    for (let i = 0; i < grid.length; i++){\\n        res += Math.floor(Math.abs(grid[i] - mid) / x);\\n    }\\n    return res;\\n};"]}
{"id": "1467", "ref_js": ["var winnerOfGame = function(colors) {\\n    let countA = 0;\\n    let countB = 0;\\n\\n    for (let i = 0; i < colors.length; i++) {\\n        const x = colors[i];\\n        let count = 0;\\n\\n        while (i < colors.length && colors[i] === x) {\\n            i++;\\n            count++;\\n        }\\n\\n        if (x === \\'A\\') {\\n            countA += Math.max(count - 2, 0);\\n        } else if (x === \\'B\\') {\\n            countB += Math.max(count - 2, 0);\\n        }\\n\\n        i--;\\n    }\\n\\n    return countA > countB;\\n};", "var winnerOfGame = function(colors) {\\n    let countA = 0;\\n    let countB = 0;\\n\\n    for (let i = 0; i < colors.length; i++) {\\n        const x = colors[i];\\n        let count = 0;\\n\\n        while (i < colors.length && colors[i] === x) {\\n            i++;\\n            count++;\\n        }\\n\\n        if (x === \\'A\\') {\\n            countA += Math.max(count - 2, 0);\\n        } else if (x === \\'B\\') {\\n            countB += Math.max(count - 2, 0);\\n        }\\n\\n        i--;\\n    }\\n\\n    return countA > countB;\\n};", "var winnerOfGame = function(colors) {\\n    let countA = 0;\\n    let countB = 0;\\n\\n    for (let i = 0; i < colors.length; i++) {\\n        const x = colors[i];\\n        let count = 0;\\n\\n        while (i < colors.length && colors[i] === x) {\\n            i++;\\n            count++;\\n        }\\n\\n        if (x === \\'A\\') {\\n            countA += Math.max(count - 2, 0);\\n        } else if (x === \\'B\\') {\\n            countB += Math.max(count - 2, 0);\\n        }\\n\\n        i--;\\n    }\\n\\n    return countA > countB;\\n};"]}
{"id": "1468", "ref_js": ["var networkBecomesIdle = function(edges, patience) {\\n    \\n    let edgesMap={},minDistanceFromMasterArr=[],ans=0,visited={};", "var networkBecomesIdle = function(edges, patience) {\\n    let graph = {};", "var networkBecomesIdle = function(edges, patience) {\\n    let graph = {};"]}
{"id": "1470", "ref_js": ["var countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};", "var countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};", "var countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};"]}
{"id": "1471", "ref_js": ["var nextBeautifulNumber = function(n) {\\n    let l = [1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666,1224444];\\n    for(let x of l){\\n        if (x>n){return x;}\\n    }\\n};", "var nextBeautifulNumber = function(n) {\\n    const count = Array.from({ length: 7 }, (_, i) => i);\\n    const digits = [1, 2, 3, 4, 5, 6];\\n    n = n + \"\";\\n\\n    const recursion = (n, num, size) => {\\n        if (size == 0) {\\n            if (num > n && count.every((value, i) => value == i || value == 0))\\n                return num;\\n            return 0;\\n        }\\n\\n        for (const digit of digits) {\\n            count[digit]--;\\n            const res = recursion(n, num * 10 + digit, size - 1);\\n            if (res > 0) return res;\\n            count[digit]++;\\n        }\\n\\n        return 0;\\n    };", "var nextBeautifulNumber = function(n) {\\n    "]}
{"id": "1472", "ref_js": ["var countHighestScoreNodes = function(parents) {\\n    const root = constructTree(parents)\\n    let max = 0\\n    let count = 0\\n    const dfs = (root) => {\\n        if(!root) return 0\\n        let l = dfs(root.left)\\n        let r = dfs(root.right) \\n\\n        const subTreeCount = l + r + 1\\n\\n        ", "var countHighestScoreNodes = function(parents) {\\n    const N = parents.length;\\n    ", "var countHighestScoreNodes = function(parents) {\\n    const root = constructTree(parents)\\n    let max = 0\\n    let count = 0\\n    const dfs = (root) => {\\n        if(!root) return 0\\n        let l = dfs(root.left)\\n        let r = dfs(root.right) \\n\\n        const subTreeCount = l + r + 1\\n\\n        "]}
{"id": "1473", "ref_js": ["var maxTwoEvents = function (events) {\\n  ", "var maxTwoEvents = function(events) {\\n    events.sort((a, b) => a[0]-b[0]);\\n    let res = 0, suffix = new Array(events.length);\\n    let max = 0;\\n    for(let i = events.length-1; i >= 0; i--){\\n        max = Math.max(max, events[i][2]);\\n        suffix[i] = max;\\n    }\\n    for(let i = 0; i < events.length; i++){\\n        res = Math.max(res, events[i][2]);\\n        let l = i+1, e = events.length-1;\\n        while(l < e){\\n            let mid = (l+e) >> 1;\\n            if(events[mid][0] > events[i][1]){\\n                e = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        if(events[e][0] > events[i][1]){\\n            res = Math.max(res, events[i][2] + suffix[e]);\\n        }\\n    }\\n    return res;\\n};", "var maxTwoEvents = function(events) {\\n    events.sort((a, b) => a[0]-b[0]);\\n    let res = 0, suffix = new Array(events.length);\\n    let max = 0;\\n    for(let i = events.length-1; i >= 0; i--){\\n        max = Math.max(max, events[i][2]);\\n        suffix[i] = max;\\n    }\\n    for(let i = 0; i < events.length; i++){\\n        res = Math.max(res, events[i][2]);\\n        let l = i+1, e = events.length-1;\\n        while(l < e){\\n            let mid = (l+e) >> 1;\\n            if(events[mid][0] > events[i][1]){\\n                e = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        if(events[e][0] > events[i][1]){\\n            res = Math.max(res, events[i][2] + suffix[e]);\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "1474", "ref_js": ["var findPeakGrid = function(matrix) {\\n    const getMaxElement = (matrix, mid) => {\\n        let index = -1;\\n        let maxi = Number.MIN_SAFE_INTEGER;\\n\\n        for (let row = 0; row < matrix.length; row++) {\\n            let elm = matrix[row][mid];\\n\\n            if (elm > maxi) {\\n                maxi = Math.max(maxi, elm);\\n                index = row;\\n            }\\n        }\\n        return index;\\n    };", "var findPeakGrid = function(mat) {   \\n    \\n    function maxValueIdx(array) {\\n        let maxIdx = 0;\\n        for(let i = 0; i < array.length; i++) {\\n            if(array[i] > array[maxIdx]) {\\n                maxIdx = i;\\n            }\\n        }\\n        return maxIdx\\n    };", "var findPeakGrid = function(mat) {   \\n    \\n    function maxValueIdx(array) {\\n        let maxIdx = 0;\\n        for(let i = 0; i < array.length; i++) {\\n            if(array[i] > array[maxIdx]) {\\n                maxIdx = i;\\n            }\\n        }\\n        return maxIdx\\n    };"]}
{"id": "1475", "ref_js": ["var nodesBetweenCriticalPoints = function(head) {\\n    const localMs = [];\\n\\n    let mid = 0;\\n    let prev = 0;\\n    let i = 1;\\n\\n    while (head) {\\n        i ++;\\n        if (!mid || !prev){\\n            [mid, prev] = [head.val, mid];  \\n            head = head.next;\\n            continue;\\n        }\\n\\n        if (mid > prev && mid > head.val || mid < prev && mid < head.val) {\\n            localMs.push(i - 2);\\n        }\\n\\n        [mid, prev] = [head.val, mid];\\n        head = head.next;\\n    }\\n\\n    if (localMs.length < 2) return [-1, -1];\\n    if (localMs.length === 2) return [localMs[1] - localMs[0], localMs[1] - localMs[0]];\\n\\n    let min = localMs[1] - localMs[0];\\n\\n    for (let i = 1; i < localMs.length; i ++) {\\n        min = Math.min(localMs[i] - localMs[i - 1], min);\\n        if (min === 1) break;\\n    }\\n\\n    return [min, localMs[localMs.length - 1] - localMs[0]];\\n};", "var nodesBetweenCriticalPoints = function(head) {\\n    let prev = head;\\n    head = head.next;\\n    let i=1;\\n    let index = [];\\n    while(head.next){\\n        if((prev.val < head.val && head.val > head.next.val) || (prev.val > head.val && head.val < head.next.val)){\\n            index.push(i);\\n        }\\n        prev = head;\\n        head = head.next;\\n        i++;\\n    }\\n    if(index.length < 2){\\n        return [-1, -1];\\n    }\\n    let minDistance = Number.MAX_SAFE_INTEGER;\\n    for(let i=0; i<index.length-1; i++){\\n        minDistance = Math.min(index[i+1] - index[i], minDistance);\\n    }   \\n    return [minDistance, index[index.length-1] - index[0]];\\n};", "var nodesBetweenCriticalPoints = function(head) {\\n    const localMs = [];\\n\\n    let mid = 0;\\n    let prev = 0;\\n    let i = 1;\\n\\n    while (head) {\\n        i ++;\\n        if (!mid || !prev){\\n            [mid, prev] = [head.val, mid];  \\n            head = head.next;\\n            continue;\\n        }\\n\\n        if (mid > prev && mid > head.val || mid < prev && mid < head.val) {\\n            localMs.push(i - 2);\\n        }\\n\\n        [mid, prev] = [head.val, mid];\\n        head = head.next;\\n    }\\n\\n    if (localMs.length < 2) return [-1, -1];\\n    if (localMs.length === 2) return [localMs[1] - localMs[0], localMs[1] - localMs[0]];\\n\\n    let min = localMs[1] - localMs[0];\\n\\n    for (let i = 1; i < localMs.length; i ++) {\\n        min = Math.min(localMs[i] - localMs[i - 1], min);\\n        if (min === 1) break;\\n    }\\n\\n    return [min, localMs[localMs.length - 1] - localMs[0]];\\n};"]}
{"id": "1476", "ref_js": ["var minimumOperations = function (nums, start, goal) {\\n  const q = [];\\n  const seen = new Set();\\n  q.push([start, 0]);\\n  seen.add(start);\\n  let front = 0;\\n\\n  const operations = [\\n    (n, m) => n + m,\\n    (n, m) => n - m,\\n    (n, m) => n ^ m,\\n  ];\\n\\n  while (front < q.length) {\\n    let length = q.length - front;\\n\\n    while (length > 0) {\\n      let [num, steps] = q[front];\\n      front++;\\n      length--;\\n\\n      for (const operation of operations) {\\n        for (const n of nums) {\\n          const newNum = operation(num, n);\\n\\n          if (newNum === goal) {\\n            return steps + 1;\\n          }\\n\\n          if (0 <= newNum && newNum <= 1000 && !seen.has(newNum)) {\\n            seen.add(newNum);\\n            q.push([newNum, steps + 1]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};", "var minimumOperations = function (nums, start, goal) {\\n  const q = [];\\n  const seen = new Set();\\n  q.push([start, 0]);\\n  seen.add(start);\\n  let front = 0;\\n\\n  const operations = [\\n    (n, m) => n + m,\\n    (n, m) => n - m,\\n    (n, m) => n ^ m,\\n  ];\\n\\n  while (front < q.length) {\\n    let length = q.length - front;\\n\\n    while (length > 0) {\\n      let [num, steps] = q[front];\\n      front++;\\n      length--;\\n\\n      for (const operation of operations) {\\n        for (const n of nums) {\\n          const newNum = operation(num, n);\\n\\n          if (newNum === goal) {\\n            return steps + 1;\\n          }\\n\\n          if (0 <= newNum && newNum <= 1000 && !seen.has(newNum)) {\\n            seen.add(newNum);\\n            q.push([newNum, steps + 1]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};", "var minimumOperations = function (nums, start, goal) {\\n  const q = [];\\n  const seen = new Set();\\n  q.push([start, 0]);\\n  seen.add(start);\\n  let front = 0;\\n\\n  const operations = [\\n    (n, m) => n + m,\\n    (n, m) => n - m,\\n    (n, m) => n ^ m,\\n  ];\\n\\n  while (front < q.length) {\\n    let length = q.length - front;\\n\\n    while (length > 0) {\\n      let [num, steps] = q[front];\\n      front++;\\n      length--;\\n\\n      for (const operation of operations) {\\n        for (const n of nums) {\\n          const newNum = operation(num, n);\\n\\n          if (newNum === goal) {\\n            return steps + 1;\\n          }\\n\\n          if (0 <= newNum && newNum <= 1000 && !seen.has(newNum)) {\\n            seen.add(newNum);\\n            q.push([newNum, steps + 1]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};"]}
{"id": "1477", "ref_js": ["var countVowels = function(word) {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']);\\n    let total = 0;\\n    let count = 0;\\n    for (let i = 0; i < word.length; i++) {\\n        if (vowels.has(word[i])) {\\n            count += i + 1;\\n        }\\n        total += count;\\n    }\\n    return total;\\n};", "var countVowels = function (word) {\\n    let lastVowels = 0;\\n    let result = 0;\\n    for (let i = 0; i < word.length; i++) {\\n\\t    let newVowels = 0;\\n        if (isVowel(word[i])) {\\n            newVowels= (i + 1);\\n        }\\n        result += lastVowels + newVowels;\\n\\t\\tlastVowels = newVowels + lastVowels;\\n    }\\n    return result;\\n};", "var countVowels = function (word) {\\n    let lastVowels = 0;\\n    let result = 0;\\n\\n    for (let i = 0; i < word.length; i++) {\\n        let newVowels = 0;\\n        if (isVowel(word[i])) {\\n            newVowels = i + 1;\\n        }\\n        result += lastVowels + newVowels;\\n        lastVowels += newVowels;\\n    }\\n    return result;\\n};"]}
{"id": "1478", "ref_js": ["var minimizedMaximum = function(n, quantities) {\\n       let max = -1;\\n    \\n    ", "var minimizedMaximum = function(n, quantities) {\\n    \\n    const split=(count)=>quantities.reduce((acc,cur)=>acc+Math.ceil(cur/count),0);\\n\\n    let l=1, r=quantities.reduce((curr,acc)=>Math.max(curr,acc)), lastOptimal=0;\\n    while(l<=r){\\n      const mid=Math.trunc((l+r)/2);\\n      const storesNeeded=split(mid);\\n      if(storesNeeded===n){\\n        lastOptimal=mid;\\n        r=mid-1; ", "var minimizedMaximum = function(n, quantities) {\\n    \\n    let left = 1;\\n    let right = Math.max(...quantities);\\n    let result =-1;\\n\\n    while(left<=right){\\n        let mid = left + Math.floor((right-left)/2);\\n\\n        if(isDistributionPossible(quantities,mid,n)){\\n            result = mid;\\n            right=mid-1;\\n        }\\n        else{\\n            left=mid+1;\\n        }\\n    }\\n\\n    return result;\\n};"]}
{"id": "1480", "ref_js": ["var maximumBeauty = function (items, queries) {\\n  items.sort((a, b) => a[0] - b[0]);\\n  let maxBeauty = 0;\\n  let prefixMaxBeauty = [];\\n  for (let [price, beauty] of items) {\\n    prefixMaxBeauty.push((maxBeauty = Math.max(maxBeauty, beauty)));\\n  }\\n  let answer = [];\\n  for (let queryPrice of queries) {\\n    let low = 0;\\n    let high = items.length - 1;\\n    while (low <= high) {\\n      let mid = ~~(low / 2 + high / 2);\\n      if (items[mid][0] <= queryPrice) {\\n        low = mid + 1;\\n      } else {\\n        high = mid - 1;\\n      }\\n    }\\n    answer.push(high >= 0 ? prefixMaxBeauty[high] : 0);\\n  }\\n  return answer;\\n};", "var maximumBeauty = function(items, queries) {\\n    items.sort((a,b) => a[0]-b[0]);\\n    const n = items.length;\\n    \\n    \\n    let mx = items[0][1];\\n    \\n    for (let i = 0; i<n; i++) {\\n        mx = Math.max(mx, items[i][1]);\\n        items[i][1] = mx;\\n    }\\n    \\n    \\n    const ans = [];\\n    \\n    for (const q of queries) {\\n        let l = 0, r = n-1, a = 0;\\n        while (l<=r) {\\n            let mid = Math.floor(l+(r-l)/2);\\n            if (items[mid][0]<=q) {\\n                a = items[mid][1]\\n                l = mid+1;\\n            } else r = mid-1;\\n        }\\n        ans.push(a)\\n    }\\n    \\n    return ans;\\n};", "var maximumBeauty = function(items, queries) {\\n    const m = items.length;\\n    const n = queries.length;\\n    \\n    items.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\\n    \\n    let maxVal = 0;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        maxVal = Math.max(maxVal, items[i][1]);\\n        items[i][1] = maxVal;\\n    }\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const price = queries[i];\\n        \\n        let left = 0;\\n        let right = m;\\n        \\n        while (left < right) {\\n            const midIdx = (left + right) >> 1;\\n            const [midPrice, midBeauty] = items[midIdx];\\n            \\n            if (midPrice > price) right = midIdx;\\n            else left = midIdx + 1;\\n        }\\n        \\n        if (right > 0) right -= 1;\\n        \\n        const [maxPrice, maxBeauty] = items[right];\\n        \\n        if (maxPrice <= price) res[i] = maxBeauty;\\n        else res[i] = 0;\\n    }\\n    \\n    return res;\\n};"]}
{"id": "1481", "ref_js": ["var reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { ", "var reverseEvenLengthGroups = function(head) {\\nlet n = head;\\nlet a = n;\\nlet curr = head.next;\\nlet j = 2;\\nlet k = 0;\\nwhile (curr !== null) {\\n  let node = curr;\\n  for (let i = 0; i < j; i++){\\n    curr = curr.next;\\n    k++;\\n    if (curr === null) {\\n      break;\\n    } \\n  } \\n  let prev = null;\\n  let curr1 = node;\\n  if (k % 2 == 0) {\\n    for (let i = 0; i < k; i++){\\n     let next = curr1.next;\\n      curr1.next = prev;\\n      prev = curr1;\\n      curr1 = next;\\n    }\\n    n.next = prev;\\n    n = node;\\n  } else {\\n    n.next = node;\\n    for (let i = 0; i < k; i++){\\n      curr1 = curr1.next;\\n      n = n.next;\\n    }\\n  }\\n  k = 0;\\n  j++;\\n}\\nreturn a;\\n};", "var reverseEvenLengthGroups = function(head) {\\n    if( head === null || head.next === null){ return head; }\\n\\n    \\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    let prevPtr = head;\\n    let currPtr = head.next;\\n\\n    let grpNo = 2;\\n\\n    while (currPtr !== null) {\\n\\n                    \\n        \\n        let {result, subHead} = findEvenElements(currPtr, grpNo);\\n        \\n        if (result === true) {\\n            let { prev, curr } = reverseList(currPtr, subHead);\\n            prevPtr.next = prev;\\n            currPtr.next = curr;\\n            prevPtr = currPtr;\\n            currPtr = subHead;\\n        } else {\\n\\n            while(prevPtr.next !== subHead){\\n              prevPtr = prevPtr.next;\\n            }\\n            currPtr = subHead;\\n        }\\n      grpNo += 1;\\n    }\\n    return dummy.next;\\n};"]}
{"id": "1482", "ref_js": ["var decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};", "var decodeCiphertext = function (encodedText, rows) {\\n  let n = encodedText.length;\\n  if (n === 0) return \"\";\\n  if (rows === 1) return encodedText;\\n  let cols = Math.floor(n / rows) + 1;\\n  let ans = \"\";\\n  for (let i = 0; i < cols; i++) {\\n    let currentRow = 1;\\n    ans += encodedText[i] || \"\";\\n    while (currentRow < rows) {\\n      ans += encodedText[i + currentRow * cols] || \"\";\\n      currentRow++;\\n    }\\n  }\\n  return ans.trimEnd();\\n};", "var decodeCiphertext = function (encodedText, rows) {\\n  let n = encodedText.length;\\n  if (n === 0) return \"\";\\n  if (rows === 1) return encodedText;\\n  let cols = Math.floor(n / rows) + 1;\\n  let ans = \"\";\\n  for (let i = 0; i < cols; i++) {\\n    let currentRow = 1;\\n    ans += encodedText[i] || \"\";\\n    while (currentRow < rows) {\\n      ans += encodedText[i + currentRow * cols] || \"\";\\n      currentRow++;\\n    }\\n  }\\n  return ans.trimEnd();\\n};"]}
{"id": "1483", "ref_js": ["var wateringPlants = function (plants, capacity) {\\n    plants.unshift(capacity)\\n    let steps =0\\n    let newCapacity =0\\n    for(let j=0;j<plants.length;j++){\\n        if(j===0){\\n            newCapacity =capacity\\n            ", "var wateringPlants = function(plants, capacity) {\\n    let steps = 0, water = capacity;\\n\\n    for(let index = 0; index < plants.length; index++){\\n        if(plants[index] > water){\\n            steps += (index)*2;\\n            water = capacity; ", "var wateringPlants = function(plants, capacity) {\\n    let ans=0;\\n    let i=0;\\n    let cap=capacity;\\n    while(i<plants.length){\\n        if(capacity>=plants[i]){\\n            ans++;\\n            capacity=capacity-plants[i]\\n            i++;\\n            \\n        }else{\\n            ans=ans+2*i;\\n            capacity=cap;\\n        }\\n    }\\n\\n    return ans;\\n};"]}
{"id": "1485", "ref_js": ["var minimumBuckets = function(a) {\\n    const street = [...a];\\n    let buckets = 0;\\n\\n    \\n    for (let i = 0; i < street.length; i++) {\\n        if (street[i] === \"H\") {\\n            if (street[i - 1] === \\'B\\') continue;\\n            if (street[i + 1] === \\'.\\') {\\n                street[i + 1] = \\'B\\';\\n                buckets++;\\n                continue;\\n            }\\n            if (street[i - 1] === \\'.\\') {\\n                street[i - 1] = \\'B\\';\\n                buckets++;\\n                continue;\\n            }\\n            else return -1;\\n        }            \\n    }\\n    \\n    return buckets;\\n};", "var minimumBuckets = function(a) {\\n    const street = [...a];\\n    let buckets = 0;\\n\\n    \\n    for (let i = 0; i < street.length; i++) {\\n        if (street[i] === \"H\") {\\n            if (street[i - 1] === \\'B\\') continue;\\n            if (street[i + 1] === \\'.\\') {\\n                street[i + 1] = \\'B\\';\\n                buckets++;\\n                continue;\\n            }\\n            if (street[i - 1] === \\'.\\') {\\n                street[i - 1] = \\'B\\';\\n                buckets++;\\n                continue;\\n            }\\n            else return -1;\\n        }            \\n    }\\n    \\n    return buckets;\\n};", "var minimumBuckets = function(a) {\\n    const street = [...a];\\n    let buckets = 0;\\n\\n    \\n    for (let i = 0; i < street.length; i++) {\\n        if (street[i] === \"H\") {\\n            if (street[i - 1] === \\'B\\') continue;\\n            if (street[i + 1] === \\'.\\') {\\n                street[i + 1] = \\'B\\';\\n                buckets++;\\n                continue;\\n            }\\n            if (street[i - 1] === \\'.\\') {\\n                street[i - 1] = \\'B\\';\\n                buckets++;\\n                continue;\\n            }\\n            else return -1;\\n        }            \\n    }\\n    \\n    return buckets;\\n};"]}
{"id": "1486", "ref_js": ["var minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    function sumRange(list, a, b) {\\n        let sum = 0;\\n        if (b > a) {\\n            for (let i = a + 1; i <= b; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        } else {\\n            for (let i = b; i <= a - 1; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        }\\n  \\n        return sum;\\n    }   \\n\\n    return sumRange(rowCosts, startPos[0], homePos[0]) + sumRange(colCosts, startPos[1], homePos[1])\\n};", "var minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    let total = 0\\n    let dRow = 1\\n    let dCol = 1\\n    if (homePos[0] < startPos[0]){\\n        dRow = -1\\n    }\\n    if (homePos[1] < startPos[1]){\\n        dCol = -1\\n    }\\n    let currRow = startPos[0]\\n    while (currRow !== homePos[0]){\\n        currRow += dRow\\n        total += rowCosts[currRow]\\n    }\\n    let currCol = startPos[1]\\n    while (currCol !== homePos[1]){\\n        currCol += dCol\\n        total += colCosts[currCol]\\n    }\\n    return total\\n\\n};", "var minCost = function(startPos, homePos, rowCosts, colCosts) {\\n    function sumRange(list, a, b) {\\n        let sum = 0;\\n        if (b > a) {\\n            for (let i = a + 1; i <= b; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        } else {\\n            for (let i = b; i <= a - 1; i++) {\\n                if (list.length > i) {\\n                    sum += list[i];\\n                }\\n            }\\n        }\\n  \\n        return sum;\\n    }   \\n\\n    return sumRange(rowCosts, startPos[0], homePos[0]) + sumRange(colCosts, startPos[1], homePos[1])\\n};"]}
{"id": "1487", "ref_js": ["var getAverages = function(nums, k) {\\n    ", "var getAverages = function(nums, k) {\\n    const twoK = 2 * k;\\n    const windowSize = twoK + 1;\\n    \\n    const result = [...nums].fill(-1);\\n    let sum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        if (i >= twoK) {\\n            result[i - k] = Math.floor(sum / windowSize)\\n            sum -= nums[i - twoK];\\n        }\\n    }\\n    return result;\\n};", "var getAverages = function(nums, k) {\\n    const twoK = 2 * k;\\n    const windowSize = twoK + 1;\\n    \\n    const result = [...nums].fill(-1);\\n    let sum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        if (i >= twoK) {\\n            result[i - k] = Math.floor(sum / windowSize)\\n            sum -= nums[i - twoK];\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1488", "ref_js": ["var minimumDeletions = function (nums) {\\n  let min = Infinity,\\n    max = -Infinity,\\n    minIdx = 0,\\n    maxIdx = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < min) {\\n      min = nums[i];\\n      minIdx = i;\\n    }\\n    if (nums[i] > max) {\\n      max = nums[i];\\n      maxIdx = i;\\n    }\\n  }\\n", "var minimumDeletions = function(nums) {\\n    const len=nums.length;\\n    let minIndex=nums.indexOf(Math.min(...nums));", "var minimumDeletions = function(nums) {\\n    let minInd = 0;\\n    let maxInd = 0;\\n    \\n    for(let i = 0; i< nums.length; i++) {\\n        \\n        if(nums[i] > nums[maxInd]) maxInd = i;\\n        if(nums[i] < nums[minInd]) minInd = i;\\n    }\\n    \\n    \\n    return Math.min(Math.min(maxInd,minInd) + 1 + nums.length - Math.max(maxInd, minInd), nums.length - Math.min(maxInd, minInd), Math.max(maxInd, minInd) + 1 );\\n};"]}
{"id": "1489", "ref_js": ["var deleteMiddle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n    let prev = null;\\n    while(fast!==null && fast.next!==null){\\n\\n        ", "var deleteMiddle = function(head) {\\n    ", "var deleteMiddle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n    let prev = null;\\n    while(fast!==null && fast.next!==null){\\n\\n        "]}
{"id": "1490", "ref_js": ["var getDirections = function(root, startValue, destValue) {\\n    const getPath = (node, value, acc=\\'\\') => {\\n        if (node === null) {\\n            return \\'\\';\\n        } else if (node.val === value) {\\n            return acc;\\n        } else {\\n            return getPath(node.left, value, acc + \\'L\\') + getPath(node.right, value, acc + \\'R\\')\\n        }\\n    }\\n    \\n\\t", "var getDirections = function(root, startValue, destValue) {\\n  const lca = findLCA(root, startValue, destValue) \\n  const depth = findDepth(lca, startValue) \\n  const path = findPath(lca, destValue)\\n  return \\'U\\'.repeat(depth).concat(path) ", "var getDirections = function(root, startValue, destValue) {\\n    let startNode = null;\\n    let visited = new Set();\\n    let queue = [root];\\n    \\n\\t"]}
{"id": "1491", "ref_js": ["var goodDaysToRobBank = function (a, t) {\\n  let an = [];\\n  for (let i = t; i + t < a.length; i++) {\\n    let bad = 0\\n    for (let j = i - t + 1; j <= i; j++)\\n      if (a[j - 1] < a[j]) {\\n        bad = 1; ", "var goodDaysToRobBank = function(security, time) {\\n    let days=[];\\n    let check=true;\\n        for(let i=time;i<security.length-time;i++){\\n            for(let j=i-time;j<i;j++){\\n                if(security[j]<security[j+1]){\\n                    check=false;break\\n                }\\n            }\\n            if(check){\\n            for(let j=i;j<time+i;j++){\\n                if(security[j]>security[j+1]){\\n                    check=false;break\\n                }\\n            } \\n            if(check){days.push(i)}\\n            }\\n            check=true\\n        }\\n    return days\\n};", "var goodDaysToRobBank = function(security, time) {\\n    let decrease = [0];\\n    let increase = Array(security.length).fill(0);\\n    \\n    "]}
{"id": "1492", "ref_js": ["var maximumDetonation = function(bombs) {\\n    let answer = 0\\n    for (let i  = 0; i < bombs.length; i++) {\\n        const exploded = new Set([i])\\n        const queue = [bombs[i]]\\n        while(queue.length > 0) {\\n            const bomb = queue.shift()\\n            for (let j = 0; j < bombs.length; j++) {\\n                if (exploded.has(j)) continue\\n                const newBomb = bombs[j]\\n                const distance = ((Math.abs(newBomb[0] - bomb[0])**2 )+ (Math.abs(newBomb[1] - bomb[1])**2)) ** 0.5\\n                if (distance <= bomb[2]) {\\n                    queue.push(newBomb)\\n                    exploded.add(j)\\n                }\\n            }\\n        }\\n        answer = Math.max(exploded.size, answer)\\n    }\\n    return answer\\n};", "var maximumDetonation = function(bombs) {\\n    const neighbours = new Map();\\n    for (let i = 0; i < bombs.length; i++) {\\n        const x1 = bombs[i][0];\\n        const y1 = bombs[i][1];\\n        const r = bombs[i][2];\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (i !== j) {\\n                const x2 = bombs[j][0];\\n                const y2 = bombs[j][1];\\n                if ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= r ** 2) {\\n                    if (neighbours.has(i)) {\\n                        neighbours.get(i).push(j);\\n                        neighbours.set(i, neighbours.get(i))\\n                    } else {\\n                        neighbours.set(i, [j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\tlet max = 0;\\n\\tfor(let i = 0; i < bombs.length; i++) {\\n\\t\\tconst visited = new Set();\\n\\t\\tconst q = [];\\n\\t\\tq.push(i);\\n\\t\\tvisited.add(i);\\n\\t\\twhile (q.length) {\\n            const first = q.shift();\\n            if (neighbours.has(first)) {\\n                for (let b of neighbours.get(first)) {\\n                    if (!visited.has(b)) {\\n                        visited.add(b);\\n                        q.push(b);\\n                    }\\n                }    \\n            }\\n\\t\\t}\\n    \\tif (visited.size === bombs.length) {\\n            return visited.size;\\n        }\\n\\t\\tmax = Math.max(max, visited.size);\\n\\t}\\n\\treturn max;\\n};", "var maximumDetonation = function(bombs) {\\n    const n = bombs.length\\n    if (n <= 1) return n\\n    const adj = new Array(n).fill(0).map(a => [])\\n\\n    const checkRange = ([x1, y1, r1], [x2, y2, r2]) => {\\n        const dist = (x1 - x2)**2 + (y1 - y2)**2\\n        return [r1**2 >= dist, r2**2 >= dist]\\n    }\\n\\n    for (let i=0; i<n; i++) {\\n        for (let j=i+1; j<n; j++) {\\n            const [hitsJ, hitsI] = checkRange(bombs[i], bombs[j])\\n            if (hitsJ) adj[i].push(j)\\n            if (hitsI) adj[j].push(i)\\n        }\\n    }\\n\\n    let max = 0\\n    const dfs = (node, visited = new Set()) => {\\n        visited.add(node)\\n        let bomb = 1\\n        for (let next of adj[node]) {\\n            if (!visited.has(next)) {\\n                bomb += dfs(next, visited)\\n            }\\n        }\\n        max = Math.max(max, bomb)\\n        return bomb\\n    }\\n\\n    for (let i=0; i<n; i++) dfs(i)\\n    return max\\n};"]}
{"id": "1493", "ref_js": ["var subArrayRanges = function(nums) {\\n\\tlet res = 0\\n\\tfor (let i = 1; i < nums.length; i++) {\\n\\t\\tfor (let j = 0; j < i; j++) {\\n\\t\\t\\tlet smallest = nums[i], biggest = nums[i]\\n\\t\\t\\tfor (let k = j; k < i; k++) {\\n\\t\\t\\t\\tsmallest = Math.min(smallest, nums[k])\\n\\t\\t\\t\\tbiggest = Math.max(biggest, nums[k])\\n\\t\\t\\t}\\n\\t\\t\\tres += biggest - smallest\\n\\t\\t}\\n\\t}\\n\\treturn res\\n};", "var subArrayRanges = function (a) {\\n  let sum = 0\\n  for (let i = 0; i < a.length; i++) {\\n    let min = a[i];\\n    let max = a[i];\\n    for (let j = i + 1; j < a.length; j++) {\\n      min = Math.min(min, a[j]);\\n      max = Math.max(max, a[j]);\\n      sum += max - min;\\n    }\\n  }\\n  return sum;\\n};", "var subArrayRanges = function(nums) {\\n    let sum = 0\\n    for (let i = 0; i < nums.length; i++){\\n        let smallest = Math.min(nums[i]);\\n        let largest = Math.max(nums[i]);\\n        for (let j = i; j < nums.length; j++){\\n            \\n            smallest = Math.min(nums[j], smallest);\\n            largest = Math.max(nums[j], largest);\\n            \\n            \\n            sum += (largest - smallest)\\n        }\\n    }\\n    return sum\\n};"]}
{"id": "1494", "ref_js": ["var minimumRefill = function (plants, capacityA, capacityB) {\\n    let left = 0;\\n    let remaining = [capacityA, capacityB];\\n    let right = plants.length - 1;\\n    let refills = 0;\\n\\n    while (left <= right) {\\n        const plantA = plants[left];\\n        const plantB = plants[right];\\n\\n        if (left !== right) {\\n            if (plantA <= remaining[0]) {\\n                remaining[0] -= plantA;\\n            } else {\\n                refills++;\\n                remaining[0] = capacityA - plantA;\\n            }\\n            if (plantB <= remaining[1]) {\\n                remaining[1] -= plantB;\\n            } else {\\n                refills++;\\n                remaining[1] = capacityB - plantB;\\n            }\\n        } else {\\n            ", "var minimumRefill = function(plants, capacityA, capacityB) {\\n    let Apos = 0;\\n    let Bpos = plants.length - 1;\\n    AcurCap = capacityA;\\n    BcurCap = capacityB;\\n    let refill = 0;\\n    while (Bpos - Apos >= 0) {\\n        if (Bpos === Apos) {\\n            if (Math.max(AcurCap, BcurCap) < plants[Apos]) {\\n                refill++;\\n            }\\n            break;\\n        }\\n\\n        if (AcurCap >= plants[Apos]) {\\n            AcurCap -= plants[Apos];\\n        } else {\\n            refill++;\\n            AcurCap = capacityA - plants[Apos];\\n        }\\n        \\n        if (BcurCap >= plants[Bpos]) {\\n            BcurCap -= plants[Bpos];\\n        } else {\\n            refill++;\\n            BcurCap = capacityB - plants[Bpos];\\n        }  \\n        \\n        Apos++;\\n        Bpos--;\\n    }\\n\\n    return refill\\n};", "var minimumRefill = function(plants, capacityA, capacityB) {\\n    let Apos = 0;\\n    let Bpos = plants.length - 1;\\n    AcurCap = capacityA;\\n    BcurCap = capacityB;\\n    let refill = 0;\\n    while (Bpos - Apos >= 0) {\\n        if (Bpos === Apos) {\\n            if (Math.max(AcurCap, BcurCap) < plants[Apos]) {\\n                refill++;\\n            }\\n            break;\\n        }\\n\\n        if (AcurCap >= plants[Apos]) {\\n            AcurCap -= plants[Apos];\\n        } else {\\n            refill++;\\n            AcurCap = capacityA - plants[Apos];\\n        }\\n        \\n        if (BcurCap >= plants[Bpos]) {\\n            BcurCap -= plants[Bpos];\\n        } else {\\n            refill++;\\n            BcurCap = capacityB - plants[Bpos];\\n        }  \\n        \\n        Apos++;\\n        Bpos--;\\n    }\\n\\n    return refill\\n};"]}
{"id": "1495", "ref_js": ["var addSpaces = function(s, spaces) {\\n    let left =0;\\n    let temp =\\'\\';\\n    let count =0\\n    let right = 0;\\n    while(right < s.length){\\n\\n        if(right === spaces[count]){\\n         temp += s.slice(left,right) + \" \"\\n        left = right;\\n        count++;\\n\\n        }\\n    right++;\\n    }\\n\\ntemp+=s.slice(left,right)\\nreturn temp\\n};", "var addSpaces = function (s, spaces) {\\n    let str = \"\";\\n    let first = 0;\\n    spaces.forEach(ele => {\\n        let substring = s.substring(first, ele);\\n        str = str + substring + \" \";\\n        first = ele;\\n    });\\n    let againSubString = s.substring(first);\\n    str = str + againSubString;\\n    console.log(str);\\n    return str;\\n\\n};", "var addSpaces = function(s, spaces) {\\n    let res=\\'\\',j=0;\\n    for(let i=0;i<s.length;i++){\\n        if(i==spaces[j] && j<spaces.length){\\n        res=res+\\' \\'+s[i];\\n        j++;\\n        }\\n        else res+=s[i];\\n    }\\n    return res;\\n};"]}
{"id": "1496", "ref_js": ["var getDescentPeriods = function (a) {\\n  let count = 1;\\n  let total = 0;\\n  for (let i = 0; i < a.length; i++) {\\n    if (a[i - 1] - 1 === a[i]) {\\n      count++;\\n    } else {\\n      count = 1;\\n    }\\n    total += count;\\n  }\\n  return total;\\n};", "var getDescentPeriods = function(prices) {\\n    const subsCount=(n)=> (Math.trunc(n*(n+1)/2));\\n    \\n    let periods=0;\\n    for(let i=0;i<prices.length;i++){\\n        let j=i;\\n        while(j+1<prices.length && prices[j]-prices[j+1]===1) j++;\\n        const dist = j-i+1;\\n        periods+=subsCount(dist);\\n        i=j;\\n    }\\n    return periods;\\n};", "var getDescentPeriods = function(prices) {\\n    \\n    let arr=new Array(prices.length-1).fill(0)\\n    \\n    for(let i=0;i<arr.length;i++){\\n        arr[i]=prices[i]-prices[i+1]\\n    }\\n   \\n    let count=0\\n    let ans=0\\n    for(let i=0;i<arr.length;i++){\\n        if(arr[i]==1){\\n            count++\\n        }\\n        else{\\n            ans+=(count*(count+1)/2)\\n            count=0\\n        }\\n    }\\n    \\n    ans+=(count*(count+1))/2\\n    \\n    return ans+prices.length\\n    \\n};"]}
{"id": "1497", "ref_js": ["var findAllRecipes = function (recipes, ingredients, supplies) {\\n    const recipesConfig = (function () {\\n        const obj = {};", "var findAllRecipes = function(recipes, ingredients, supplies) {\\n    const setOfIngredients = new Set(supplies);\\n    const recipesWithIngredients = new Map();\\n    const progress = new Map();\\n\\t", "var findAllRecipes = function(recipes, ingredients, supplies) {\\n  let graph = {};"]}
{"id": "1498", "ref_js": ["var canBeValid = function(s, locked) {\\n    let flip = 0;\\n    let open = 0;\\n    let close = 0;\\n    if(s.length % 2) {\\n        return false;\\n    }\\n    for(let i = 0; i< s.length; i++) {\\n        if(!+locked[i]) {\\n            ++flip;\\n        } else {\\n            if(s[i] == \"(\") {\\n                ++open;\\n            } else {\\n                ++close;\\n            }\\n        }\\n        if(flip + open < close) {\\n            return false;\\n        }\\n    }\\n    flip = 0; open = 0; close = 0;\\n    \\n    for(let i = s.length-1; i>=0; i--) {\\n        if(!+locked[i]) {\\n            ++flip;\\n        } else {\\n            if(s[i] == \"(\") {\\n                ++open;\\n            } else {\\n                ++close;\\n            }\\n        }\\n        if(flip + close < open) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};", "var canBeValid = function(str, locked) {\\n    if(str.length%2) return false;\\n    let balance = 0;\\n    ", "var canBeValid = function (s, locked) {\\n  if (s.length & 1) return false;\\n  let open = 0,\\n    close = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] == \"(\" || locked[i] == \"0\") {\\n      open++;\\n    } else {\\n      close++;\\n    }\\n    if (open - close < 0) {\\n      return false;\\n    }\\n  }\\n  open = close = 0;\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    if (s[i] == \")\" || locked[i] == \"0\") {\\n      close++;\\n    } else {\\n      open++;\\n    }\\n    if (close - open < 0) {\\n      return false;\\n    }\\n  }\\n  return true;\\n};"]}
{"id": "1499", "ref_js": ["var executeInstructions = function(n, startPos, s) {\\n    let res = Array(s.length).fill(0)\\n    for(let i = 0; i < s.length; i++){\\n        let [currX, currY] = startPos;\\n        for(let j = i; j < s.length; j++){\\n            switch(s[j]){\\n                case \\'L\\':{\\n                    currY -= 1;\\n                }\\n                    break;\\n                case \\'R\\':{\\n                    currY += 1;\\n                }\\n                    break;\\n                case \\'U\\':{\\n                    currX -= 1;\\n                }\\n                    break;\\n                case \\'D\\':{\\n                    currX += 1;\\n                }\\n                    break;\\n            }\\n            if(currX < 0 || currY < 0 || currX >= n || currY >= n)\\n                break;\\n            res[i] += 1;\\n        }\\n    }\\n    return res;\\n};", "var executeInstructions = function(n, startPos, s) {\\n    let answers = []; \\n    for (i = 0; i < s.length; i++) { \\n        let movement = 0;\\n        let [row, col] = startPos;\\n        for (j = i; j < s.length; j++) { \\n            if (s[j] == \"R\") col++;\\n            else if (s[j] == \"L\") col--;\\n            else if (s[j] == \"D\") row++;\\n            else row--;\\n            if(row>n-1 || col > n-1 || row < 0 || col < 0) {\\n                break;\\n            }\\n            movement++;\\n        }\\n        answers[i] = movement;\\n    }\\n    return answers;\\n};", "var executeInstructions = function (n, startPos, s) {\\n    const result = new Array(s.length);\\n    const executeMoves = (str) => {\\n        let x = startPos[1];\\n        let y = startPos[0];\\n        let count = 0;\\n        for (let i = 0; i < str.length; i++) {\\n            if (str[i] === \\'R\\') x++;\\n            else if (str[i] === \\'L\\') x--;\\n            else if (str[i] === \\'U\\') y--;\\n            else if (str[i] === \\'D\\') y++;\\n            if (x > n - 1 || y > n - 1 || x < 0 || y < 0) break;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    for (let i = 0; i < s.length; i++) {\\n        result[i] = executeMoves(s.substring(i, s.length));\\n    }\\n    return result;\\n};"]}
{"id": "1500", "ref_js": ["var getDistances = function (array) {\\n    const output = [];\\n    const obj = {};", "var getDistances = function(arr) {\\n    const result = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < arr.length; j++) {\\n            if (arr[j] === arr[i]) {\\n                sum += Math.abs(i - j);\\n            }\\n        }\\n        result[i] = sum;\\n    }\\n    return result;\\n};", "var getDistances = function(arr) {\\n  const numToIndexes = {};"]}
{"id": "1501", "ref_js": ["var numberOfBeams = function (bank) {\\n  let devicesArray = [];\\n  for (let i = 0; i < bank.length; i++) {\\n    devicesArray.push(calculateDevices(bank[i]));\\n  }\\n  let totalBeams = 0;\\n  for (let i = 0; i < devicesArray.length - 1; i++) {\\n    let upcoming = i + 1;\\n    while (devicesArray[upcoming] === 0 && upcoming < devicesArray.length) {\\n      upcoming++;\\n    }\\n\\n    if (upcoming !== devicesArray.length) {\\n      totalBeams += devicesArray[i] * devicesArray[upcoming];\\n    }\\n  }\\n\\n  return totalBeams;\\n};", "var numberOfBeams = function (bank) {\\n  let devicesArray = [];\\n  for (let i = 0; i < bank.length; i++) {\\n    devicesArray.push(calculateDevices(bank[i]));\\n  }\\n  let totalBeams = 0;\\n  for (let i = 0; i < devicesArray.length - 1; i++) {\\n    let upcoming = i + 1;\\n    while (devicesArray[upcoming] === 0 && upcoming < devicesArray.length) {\\n      upcoming++;\\n    }\\n\\n    if (upcoming !== devicesArray.length) {\\n      totalBeams += devicesArray[i] * devicesArray[upcoming];\\n    }\\n  }\\n\\n  return totalBeams;\\n};", "var numberOfBeams = function (bank) {\\n  let devicesArray = [];\\n  for (let i = 0; i < bank.length; i++) {\\n    devicesArray.push(calculateDevices(bank[i]));\\n  }\\n  let totalBeams = 0;\\n  for (let i = 0; i < devicesArray.length - 1; i++) {\\n    let upcoming = i + 1;\\n    while (devicesArray[upcoming] === 0 && upcoming < devicesArray.length) {\\n      upcoming++;\\n    }\\n\\n    if (upcoming !== devicesArray.length) {\\n      totalBeams += devicesArray[i] * devicesArray[upcoming];\\n    }\\n  }\\n\\n  return totalBeams;\\n};"]}
{"id": "1502", "ref_js": ["var asteroidsDestroyed = function(mass, asteroids) {\\n    asteroids.sort((a,b)=>a-b);\\n    for(let i=0;i<asteroids.length;i++){\\n        if(mass<asteroids[i]) return false;\\n        else{\\n            mass+=asteroids[i]\\n        }\\n    }\\n    return true;\\n};", "var asteroidsDestroyed = function(mass, asteroids) {\\n    asteroids.sort((a,b)=>a-b);\\n    for(let i=0;i<asteroids.length;i++){\\n        if(mass<asteroids[i]) return false;\\n        else{\\n            mass+=asteroids[i]\\n        }\\n    }\\n    return true;\\n};", "var asteroidsDestroyed = function(mass, asteroids) {\\n    asteroids.sort((a,b)=>a-b);\\n    for(let i=0;i<asteroids.length;i++){\\n        if(mass<asteroids[i]) return false;\\n        else{\\n            mass+=asteroids[i]\\n        }\\n    }\\n    return true;\\n};"]}
{"id": "1503", "ref_js": ["var pairSum = function(head) {\\n    let fast=head;\\n    let slow = head;\\n\\n    while(fast !== null && fast.next !== null){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n\\n    let middle = slow;\\n    while(middle){\\n        let nextNode = middle.next;\\n        middle.next = fast;\\n        fast= middle;\\n        middle = nextNode;\\n    }\\n\\n    let ans=0;\\n    let iterator = head;\\n    while(fast){\\n        let sum = iterator.val + fast.val;\\n        ans = Math.max(ans, sum);\\n        iterator = iterator.next;\\n        fast=fast.next;\\n    }\\n    return ans;\\n};", "var pairSum = function(head) {\\n\\n    let fast = head;\\n    let slow = head;\\n    let stack = []; \\n    maximum = 0;\\n    while(fast){\\n            stack.push(slow.val);\\n            slow=slow.next;\\n            fast= fast.next.next;\\n    }\\n    while(slow){\\n        sum = stack.pop() + slow.val;\\n        if(maximum < sum ) {\\n            maximum = sum;\\n        }\\n        slow = slow.next;\\n    }\\n    return maximum;\\n    \\n};", "var pairSum = function(head) {\\n\\n    let fast = head;\\n    let slow = head;\\n    let stack = []; \\n    maximum = 0;\\n    while(fast){\\n            stack.push(slow.val);\\n            slow=slow.next;\\n            fast= fast.next.next;\\n    }\\n    while(slow){\\n        sum = stack.pop() + slow.val;\\n        if(maximum < sum ) {\\n            maximum = sum;\\n        }\\n        slow = slow.next;\\n    }\\n    return maximum;\\n    \\n};"]}
{"id": "1504", "ref_js": ["var longestPalindrome = function(words) \\n{\\n    \\n    let m_pairs = new Map(), nm_pairs = new Map();\\n    for(let word of words)\\n    {\\n        if(word[0] === word[1])\\n        {\\n            let cnt = m_pairs.get(word) || 0;\\n            m_pairs.set(word, cnt+1);\\n        }\\n        else\\n        {\\n            let cnt = nm_pairs.get(word) || 0;\\n            nm_pairs.set(word, cnt+1);\\n        }\\n    }\\n\\n    \\n    let pw = 0, deleted = new Set();\\n    for (const [word, wcnt] of nm_pairs)\\n    {\\n        if(deleted.has(word))\\n            continue;\\n        let refl = word[1] + word[0];\\n        let reflcnt = nm_pairs.get(refl) || 0;\\n        pw += 2*Math.min(wcnt, reflcnt);\\n        deleted.add(refl);\\n    }\\n\\n    \\n    let hasOdd = false;\\n    for(let [word, wcnt] of m_pairs)\\n    {\\n        if(wcnt%2 === 1)\\n        {\\n            hasOdd = true;\\n            wcnt--;\\n        }\\n        pw += wcnt;\\n    }\\n    if(hasOdd)\\n        pw++;\\n\\n    return pw*2;\\n};", "var longestPalindrome = function (words) {\\n    const whatNeed = {};", "var longestPalindrome = function(words) {\\n    const hashmap = new Map();\\n    const hashmapDouble = new Map();\\n    let output = 0;\\n\\n    for (let i = 0 ; i < words.length; i++) {\\n        const word = words[i];\\n        if (word[0] === word[1]) {\\n            hashmapDouble.set(word, 1);\\n\\n            if (hashmap.has(word) && hashmap.get(word)%2) {\\n                output+=4;\\n                hashmapDouble.delete(word);\\n            }\\n        } else {\\n            const reverseWord = word.split(\\'\\').reverse().join(\\'\\');\\n            if (hashmap.has(reverseWord) && (!hashmap.has(word) || hashmap.get(reverseWord) > hashmap.get(word))) {\\n                output+=4;\\n            }\\n        } \\n        if (hashmap.has(word)) {\\n            hashmap.set(word, hashmap.get(word) + 1);\\n        } else {\\n            hashmap.set(word, 1);\\n        }\\n    }\\n    \\n    return output + (hashmapDouble.size ? 2 : 0);\\n};"]}
{"id": "1505", "ref_js": ["var minSwaps = function (nums) {\\n    let totalOnes = nums.reduce(\\n        (accumulator, value) => (value && ++accumulator) || accumulator,\\n        0\\n    );\\n    const block = nums.slice(0, totalOnes);\\n    let totalOnesInBlock = block.reduce(\\n        (accumulator, value) => (value && ++accumulator) || accumulator,\\n        0\\n    );\\n    let maxOnesInBlock = totalOnesInBlock;\\n    for (let index = 0; index < nums.length; index++) {\\n        if (nums[(index + totalOnes) % nums.length] === 1) {\\n            totalOnesInBlock += 1;\\n        }\\n        if (nums[index % nums.length] === 1) {\\n            totalOnesInBlock -= 1;\\n        }\\n        if (maxOnesInBlock < totalOnesInBlock) {\\n            maxOnesInBlock = totalOnesInBlock;\\n        }\\n    }\\n    return totalOnes - maxOnesInBlock;\\n};", "var minSwaps = function (a) {\\n  let n = a.length\\n  let s = a.reduce((s, e) => s + e, 0)\\n\\n  let max = -Infinity\\n  let cc = 0\\n  for (let l = 0, r = -s; l < n + s; l++, r++) {\\n    cc += a[l % n]\\n    if (r >= 0) cc -= a[r % n]\\n    max = Math.max(max, cc)\\n  }\\n  return s - max\\n};", "var minSwaps = function (nums) {\\n    "]}
{"id": "1506", "ref_js": ["var wordCount = function(startWords, targetWords) {\\n    const startMap = {};", "var wordCount = function(startWords, targetWords) {\\n   ", "var wordCount = function(startWords, targetWords) {\\n    const startMap = {};"]}
{"id": "1507", "ref_js": ["var minMoves = function(target, maxDoubles) {\\n    if (maxDoubles === 0) return target - 1;\\n    let count = 0;\\n    \\n    while (target > 1) {\\n        if (target % 2 === 0 && maxDoubles > 0) {\\n            target /= 2;\\n            maxDoubles--;\\n        } else {\\n            target--;\\n        }\\n        \\n        count++;\\n    }\\n    \\n    return count;\\n};", "var minMoves = function(t, m) {\\n    let count = 0;\\n    while(t>0){\\n        if(m>0){\\n            if(t%2!=0){\\n                t-=1;\\n                count+=1;\\n            }\\n            else{\\n                t = Math.floor(t/2);\\n                count+=1;\\n                m-=1;\\n            }\\n        }\\n        else{\\n            count+=t;\\n            break\\n        }\\n    }\\n    return count - 1\\n\\n\\n\\n    \\n};", "var minMoves = function(target, maxDoubles) {\\n    let steps=0;\\n    while(target>1 && maxDoubles>0){\\n        if(target%2!==0) {\\n            target--;\\n            steps++;\\n        }\\n        target=target/2;\\n        steps++;\\n        maxDoubles--;\\n    }\\n\\n    return steps+target-1;\\n};"]}
{"id": "1508", "ref_js": ["var mostPoints = function(questions) {\\n    const n = questions.length;\\n    const dp = new Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = n - 1; i >= 0; i--) {\\n        const [point, brainpower] = questions[i];\\n        dp[i] = Math.max(max, point + (dp[i + brainpower + 1] || 0));\\n        max = Math.max(max, dp[i]);\\n    }\\n\\n    return max;\\n};", "var mostPoints = function(questions) {\\n    const n = questions.length;\\n    const dp = new Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = n - 1; i >= 0; i--) {\\n        const [point, brainpower] = questions[i];\\n        dp[i] = Math.max(max, point + (dp[i + brainpower + 1] || 0));\\n        max = Math.max(max, dp[i]);\\n    }\\n\\n    return max;\\n};", "var mostPoints = function(questions) {\\n    const n = questions.length;\\n    const dp = new Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = n - 1; i >= 0; i--) {\\n        const [point, brainpower] = questions[i];\\n        dp[i] = Math.max(max, point + (dp[i + brainpower + 1] || 0));\\n        max = Math.max(max, dp[i]);\\n    }\\n\\n    return max;\\n};"]}
{"id": "1509", "ref_js": ["var numberOfArrays = function(differences, lower, upper) {\\n    let dp = new Array(differences.length+1)\\n    \\n    dp[0] = 0\\n    let min = dp[0]\\n    let max = dp[0]\\n    for(let i = 1; i <= differences.length; i++){\\n        dp[i] = dp[i-1] + differences[i-1]\\n        min = Math.min(dp[i], min)\\n        max = Math.max(dp[i], max)\\n    }\\n    \\n    let shift = min - lower\\n    max = max - shift\\n    \\n    let count = upper - max + 1\\n    if(count <= 0){\\n        return 0\\n    }\\n\\n    return count\\n};", "var numberOfArrays = function(differences, lower, upper) {\\n    let temp = 0;\\n    let res = 0;\\n    let n = lower;\\n    \\n    for (let i = 0; i < differences.length; i++) {\\n        temp += differences[i];\\n        differences[i] = temp;\\n    }\\n    \\n    const min = Math.min(...differences);\\n    const max = Math.max(...differences);\\n    \\n    while (n <= upper) {\\n        if (n + min >= lower && n + max <= upper) res++;\\n        n++;\\n    }\\n    return res;\\n};", "var numberOfArrays = function(differences, lower, upper) {\\n    let res = 0;\\n    let min = null;\\n    let index = null;\\n\\t"]}
{"id": "1510", "ref_js": ["var highestRankedKItems = function(grid, pricing, start, k) {\\n    let allReacheableItems = []\\n    \\n    let n = grid.length\\n    let m = grid[0].length\\n    \\n    let queue = [start]\\n    let visited = getVisited(grid)\\n    \\n    let dist = 0\\n    while(queue.length){\\n        let newQ = []\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i]\\n            if(visited[c[0]][c[1]]){\\n                continue;\\n            }\\n            visited[c[0]][c[1]] = true\\n            let val = grid[c[0]][c[1]]\\n            if(val > 1 && isInRange(pricing, val)){\\n                allReacheableItems.push([c[0], c[1], val, dist])\\n            }\\n\\n            const nextMoves = getNextMoves(grid, c)\\n            nextMoves.forEach(nm => {\\n                newQ.push(nm)\\n            })\\n        }\\n        dist++\\n        queue = newQ\\n    }\\n    allReacheableItems.sort((s1, s2) => {\\n        if(s1[3] !== s2[3]){\\n            return s1[3] - s2[3]\\n        }\\n        if(s1[2] !== s2[2]){\\n            return s1[2]- s2[2]\\n        }\\n        if(s1[0] !== s2[0]){\\n            return s1[0]-s2[0]\\n        }\\n        return s1[1]-s2[1]\\n    })\\n    allReacheableItems = allReacheableItems.map(i => [i[0], i[1]])\\n    \\n    \\n\\n    \\n    if(allReacheableItems.length < k){\\n        return allReacheableItems\\n    }\\n    \\n    return allReacheableItems.slice(0, k)\\n};", "var highestRankedKItems = function(grid, pricing, start, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dirs = [-1, 0, 1, 0, -1];\\n    \\n    const visited = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        visited[i] = new Array(n).fill(false);\\n    }\\n    \\n    const [low, high] = pricing;\\n\\n    const queue = [];\\n    \\n    queue.push([...start, 0]);\\n    \\n    const items = [];\\n    \\n    while (queue.length > 0) {\\n        const [row, col, dist] = queue.shift();\\n        \\n        if (visited[row][col]) continue;\\n        \\n        visited[row][col] = true;\\n        \\n        const price = grid[row][col];\\n        \\n        if (withinRange(price, low, high)) {\\n            items.push({ dist, price, row, col });\\n        }\\n        \\n        for (let i = 0; i < dirs.length - 1; ++i) {\\n            const neiRow = row + dirs[i];\\n            const neiCol = col + dirs[i + 1];\\n            \\n            if (withinBound(neiRow, neiCol) && !visited[neiRow][neiCol] && grid[neiRow][neiCol] != 0) {\\n                queue.push([neiRow, neiCol, dist + 1]);\\n            }\\n        }\\n    }\\n    \\n \\n    items.sort(compareFunc);\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < Math.min(k, items.length); ++i) {\\n        const { dist, price, row, col } = items[i];\\n        \\n        res.push([row, col]);\\n    }\\n    \\n    return res;\\n    \\n    \\n    function withinRange(price, low, high) {\\n        return low <= price && price <= high;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < m && col < n;\\n    }\\n    \\n    \\n    function compareFunc(a, b) {\\n        return a.dist - b.dist || a.price - b.price || a.row - b.row || a.col - b.col;\\n    }\\n};", "var highestRankedKItems = function(grid, pricing, start, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dirs = [-1, 0, 1, 0, -1];\\n    \\n    const visited = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        visited[i] = new Array(n).fill(false);\\n    }\\n    \\n    const [low, high] = pricing;\\n\\n    const queue = [];\\n    \\n    queue.push([...start, 0]);\\n    \\n    const items = [];\\n    \\n    while (queue.length > 0) {\\n        const [row, col, dist] = queue.shift();\\n        \\n        if (visited[row][col]) continue;\\n        \\n        visited[row][col] = true;\\n        \\n        const price = grid[row][col];\\n        \\n        if (withinRange(price, low, high)) {\\n            items.push({ dist, price, row, col });\\n        }\\n        \\n        for (let i = 0; i < dirs.length - 1; ++i) {\\n            const neiRow = row + dirs[i];\\n            const neiCol = col + dirs[i + 1];\\n            \\n            if (withinBound(neiRow, neiCol) && !visited[neiRow][neiCol] && grid[neiRow][neiCol] != 0) {\\n                queue.push([neiRow, neiCol, dist + 1]);\\n            }\\n        }\\n    }\\n    \\n \\n    items.sort(compareFunc);\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < Math.min(k, items.length); ++i) {\\n        const { dist, price, row, col } = items[i];\\n        \\n        res.push([row, col]);\\n    }\\n    \\n    return res;\\n    \\n    \\n    function withinRange(price, low, high) {\\n        return low <= price && price <= high;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < m && col < n;\\n    }\\n    \\n    \\n    function compareFunc(a, b) {\\n        return a.dist - b.dist || a.price - b.price || a.row - b.row || a.col - b.col;\\n    }\\n};"]}
{"id": "1511", "ref_js": ["var rearrangeArray = function(nums) {\\n    let result = new Array();\\n    let posPointer = 0;\\n    let negPointer = 1;\\n\\n    nums.forEach((element) => {\\n\\n        if(element > 0) {\\n            result[posPointer] = element;\\n            posPointer+=2;\\n        }\\n        else {\\n            result[negPointer]  = element;\\n            negPointer+=2;\\n        }\\n    })\\n\\n    return result\\n};", "var rearrangeArray = function(nums) {\\n    let i=0, j=1;\\n    let res=[];\\n\\n    for(let n of nums){\\n        if(n>0){", "var rearrangeArray = function(nums) {\\n    let result = new Array();\\n    let posPointer = 0;\\n    let negPointer = 1;\\n\\n    nums.forEach((element) => {\\n\\n        if(element > 0) {\\n            result[posPointer] = element;\\n            posPointer+=2;\\n        }\\n        else {\\n            result[negPointer]  = element;\\n            negPointer+=2;\\n        }\\n    })\\n\\n    return result\\n};"]}
{"id": "1512", "ref_js": ["var findLonely = function(nums) {\\n    let countMap = new Map();\\n    let result = [];\\n    for (let num of nums) {\\n        countMap.set(num, (countMap.get(num) || 0) + 1);\\n    }\\n    for (let num of nums) {\\n        if (!countMap.has(num - 1) && !countMap.has(num + 1) && countMap.get(num) === 1) {\\n            \\n            result.push(num);\\n        }\\n        \\n    }\\n    return result;\\n};", "var findLonely = function(nums) {\\n    if(nums[0] == nums[1] || nums[0] == nums[1] - 1){\\n        return [] ; \\n    }\\n    let idx = [] ; \\n    nums.sort((a , b) => a - b );\\n    let n = nums.length ; \\n    for(let i = 1 ; i < n - 1;  ++i){\\n        if(nums[i - 1] + 1 == nums[i] || nums[i] == nums[i + 1] - 1 || nums[i - 1] == nums[i] || nums[i] == nums[i + 1]){\\n            if(nums[i - 1] == nums[i]){\\n                idx.push(i - 1 , i) ; \\n            }\\n            if(nums[i] == nums[i + 1]){\\n                idx.push(i , i + 1) ; \\n            }\\n            if(nums[i - 1] + 1 == nums[i]){\\n                idx.push(i - 1 , i) ; \\n            }\\n            if(nums[i] == nums[i + 1] - 1){\\n                idx.push(i , i + 1) ; \\n            }\\n        }\\n    } \\n    let set = new Set() ; \\n    for(let i = 0 ; i < idx.length ; ++i){\\n        set.add(idx[i]) ; \\n    }\\n    let index = [] ; \\n    let size = 0 ; \\n    for(let val of set){\\n        index.push(val) ;\\n        ++size; \\n    }\\n    let hash = {} ; \\n    for(let i = 0 ; i < size ; ++i){\\n        hash[index[i]] = index[i] ; \\n    }\\n    let value = [] ; \\n    for(let i = 0 ; i < n ; ++i){\\n        if(hash[i] == undefined){\\n            value.push(nums[i]) ; \\n        }\\n    }\\n    return value ; \\n};", "var findLonely = function(nums) {\\n    if(nums[0] == nums[1] || nums[0] == nums[1] - 1){\\n        return [] ; \\n    }\\n    let idx = [] ; \\n    nums.sort((a , b) => a - b );\\n    let n = nums.length ; \\n    for(let i = 1 ; i < n - 1;  ++i){\\n        if(nums[i - 1] + 1 == nums[i] || nums[i] == nums[i + 1] - 1 || nums[i - 1] == nums[i] || nums[i] == nums[i + 1]){\\n            if(nums[i - 1] == nums[i]){\\n                idx.push(i - 1 , i) ; \\n            }\\n            if(nums[i] == nums[i + 1]){\\n                idx.push(i , i + 1) ; \\n            }\\n            if(nums[i - 1] + 1 == nums[i]){\\n                idx.push(i - 1 , i) ; \\n            }\\n            if(nums[i] == nums[i + 1] - 1){\\n                idx.push(i , i + 1) ; \\n            }\\n        }\\n    } \\n    let set = new Set() ; \\n    for(let i = 0 ; i < idx.length ; ++i){\\n        set.add(idx[i]) ; \\n    }\\n    let index = [] ; \\n    let size = 0 ; \\n    for(let val of set){\\n        index.push(val) ;\\n        ++size; \\n    }\\n    let hash = {} ; \\n    for(let i = 0 ; i < size ; ++i){\\n        hash[index[i]] = index[i] ; \\n    }\\n    let value = [] ; \\n    for(let i = 0 ; i < n ; ++i){\\n        if(hash[i] == undefined){\\n            value.push(nums[i]) ; \\n        }\\n    }\\n    return value ; \\n};"]}
{"id": "1513", "ref_js": ["var maxScoreIndices = function(nums) {\\n        let n=nums.length;\\n        ", "var maxScoreIndices = function(nums) {\\n    const zeroesPref=[nums[0]===0?1:0], onecePost=Array(nums.length).fill(0);\\n    onecePost[onecePost.length-1]=nums[nums.length-1];\\n\\n    ", "var maxScoreIndices = function(nums) {\\n        let n=nums.length;\\n        "]}
{"id": "1514", "ref_js": ["var pivotArray = function(nums, pivot) {\\n    let smaller = [];\\n    let greater = [];\\n    let equal = [];\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] < pivot) smaller.push(nums[i])\\n        else if(nums[i] > pivot) greater.push(nums[i])\\n        else equal.push(nums[i])\\n    }\\n    return smaller.concat(equal, greater)\\n};", "var pivotArray = function(nums, pivot) {\\n    let smaller = [];\\n    let greater = [];\\n    let equal = [];\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] < pivot) smaller.push(nums[i])\\n        else if(nums[i] > pivot) greater.push(nums[i])\\n        else equal.push(nums[i])\\n    }\\n    return smaller.concat(equal, greater)\\n};", "var pivotArray = function(nums, pivot) {\\n    let smaller = [];\\n    let greater = [];\\n    let equal = [];\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] < pivot) smaller.push(nums[i])\\n        else if(nums[i] > pivot) greater.push(nums[i])\\n        else equal.push(nums[i])\\n    }\\n    return smaller.concat(equal, greater)\\n};"]}
{"id": "1515", "ref_js": ["var minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let cost = Infinity;\\n    \\n    let maxMinutes = Math.floor(targetSeconds / 60);\\n    \\n    for(let min = 0; min <= maxMinutes; min++) {\\n        let secs = targetSeconds - min * 60;\\n        \\n        if (secs > 99 || min > 99) continue;\\n        \\n        let buttons = String(100 * min + secs);\\n        let prev = Number(buttons[0]);\\n        \\n        let sum = 0;\\n        \\n        ", "var minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let min = Math.trunc(targetSeconds / 60)   \\n    let sec = targetSeconds % 60\\n    let minRes = Infinity \\n    if (min <= 99) check(min, sec)\\n    if (min > 0 && sec <= 39 && min <= 100) check(min - 1, sec + 60)\\n    return minRes\\n\\n    function check(min, sec){\\n        let str = (min === 0 ? \"\" : String(min)) + (min === 0 ? String(sec) : String(sec).padStart(2, \\'0\\'))\\n        let currentRes = 0\\n        let newStart = startAt\\n        for (let i = 0; i < str.length; i++){\\n            if (newStart != str[i]){\\n                newStart = +str[i]\\n                currentRes += moveCost\\n            } \\n            currentRes += pushCost\\n        }\\n        minRes = Math.min(currentRes, minRes)\\n    }\\n};", "var minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let cost = Infinity;\\n    \\n    let maxMinutes = Math.floor(targetSeconds / 60);\\n    \\n    for(let min = 0; min <= maxMinutes; min++) {\\n        let secs = targetSeconds - min * 60;\\n        \\n        if (secs > 99 || min > 99) continue;\\n        \\n        let buttons = String(100 * min + secs);\\n        let prev = Number(buttons[0]);\\n        \\n        let sum = 0;\\n        \\n        "]}
{"id": "1516", "ref_js": ["var smallestNumber = function (num) {\\n  let d = String(num).split(\"\");\\n\\n  ", "var smallestNumber = function(num) {\\n    let arr = Array.from(String(num));\\n    if(num>0){\\n    arr.sort((a,b)=>{\\n         return a-b;\\n    })\\n    }\\n    else{\\n         arr.sort((a,b)=>{\\n              return b-a;\\n         })\\n    }\\n    for(let i=0;i<arr.length;i++){\\n       if(arr[i]!=0){\\n            [arr[0],arr[i]]=[arr[i],arr[0]];\\n            break;\\n       }\\n  }\\n    return arr.join(\"\");\\n};", "var smallestNumber = function(num) {\\n    let arr=[];\\n    if(num>0){\\n         arr = String(num).split(\"\").map((a)=>+a);\\n         arr.sort((a,b)=>a-b);\\n         if(arr[0]==0){\\n          let i=0;\\n          while(arr[i]==0){\\n               i++;\\n          }\\n          arr[0]=arr[i];\\n          arr[i]=0;\\n         }\\n         return +arr.join(\"\");\\n    }else if(num==0){\\n         return 0;\\n    } else {\\n         arr = String(num).substring(1).split(\"\").map((a)=>+a);\\n         arr.sort((a,b)=>b-a);\\n         return +(\"-\"+arr.join(\"\"));\\n    }\\n};"]}
{"id": "1518", "ref_js": ["var minimumOperations = function(nums) {\\n    const n = nums.length;\\n\\n    const evens = new Map();\\n    const odds = new Map();\\n\\n    for (let i = 0; i < n; ++i) {\\n        const num = nums[i];\\n\\n        if (i % 2 === 0) {\\n            if (!evens.has(num)) evens.set(num, 0);\\n            evens.set(num, evens.get(num) + 1);\\n        }\\n        else {\\n            if (!odds.has(num)) odds.set(num, 0);\\n            odds.set(num, odds.get(num) + 1);\\n        }\\n    }\\n\\n    \\n    const evenLen = Math.floor((n + 1)/ 2);\\n    const oddLen = Math.floor(n / 2);\\n    \\n    const [ maxEven1,  maxEven2 ] = getTopTwoFreqNums(evens);\\n    const [ maxOdd1, maxOdd2 ] = getTopTwoFreqNums(odds);\\n    \\n    if (maxEven1.num != maxOdd1.num) {\\n        return (evenLen - maxEven1.count) + (oddLen - maxOdd1.count);\\n    }\\n    \\n    return Math.min((evenLen - maxEven1.count) + (oddLen - maxOdd2.count), (evenLen - maxEven2.count) + (oddLen - maxOdd1.count));\\n \\n    \\n    \\n    function getTopTwoFreqNums(counts) {\\n        let maxNum1 = null;\\n        let maxCount1 = 0;\\n\\n        let maxNum2 = null;\\n        let maxCount2 = 0;\\n\\n\\n        for (const [currNum, currCount] of counts) {\\n            if (maxNum1 == null || currCount > maxCount1) {\\n                maxNum2 = maxCount1;\\n                maxCount2 = maxCount1;\\n\\n                maxNum1 = currNum;\\n                maxCount1 = currCount;\\n            }\\n            else if (maxNum2 == null || currCount > maxCount2) {\\n                maxNum2 = currNum;\\n                maxCount2 = currCount;\\n            }\\n        }\\n\\n        return [{ num: maxNum1, count: maxCount1 }, { num: maxNum2, count: maxCount2 }];\\n    }\\n};", "var minimumOperations = function(nums) {\\nvar array = nums;\\n\\nclass maxCount {\\n  constructor() { \\n    this.fMax = 0;\\n    this.sMax = 0;\\n    this.fMaxIdx = \"\";\\n    this.sMaxIdx = \"\";\\n    this.iKey = {};", "var minimumOperations = function (nums) {\\n  "]}
{"id": "1519", "ref_js": ["var minimumRemoval = function(beans) {\\n    beans.sort((a,b) => a - b);\\n    let sum = beans.reduce((c,a) => c + a);\\n    let rest = 0;\\n    for(let i = 0; i < beans.length; i++) {\\n        rest = Math.max(rest, beans[i]*(beans.length-i));\\n    }\\n    return sum - rest;\\n};", "var minimumRemoval = function(beans) {\\n    beans.sort((a, b) => a - b);\\n    let frontSum = beans.reduce((sum , a) => sum + a, 0);\\n    let backSum = 0;\\n    let done = 0;\\n    let result = Number.MAX_SAFE_INTEGER;\\n    for(let j = beans.length - 1; j >= 0; j--){\\n        frontSum -= beans[j];\\n        count = frontSum + (backSum - (beans[j] * done));\\n        result = Math.min(result, count);\\n        done++;\\n        backSum += beans[j];\\n    }\\n    return result;\\n};", "var minimumRemoval = function(beans) {\\n    beans.sort((a,b) => a - b);\\n    let sum = beans.reduce((c,a) => c + a);\\n    let rest = 0;\\n    for(let i = 0; i < beans.length; i++) {\\n        rest = Math.max(rest, beans[i]*(beans.length-i));\\n    }\\n    return sum - rest;\\n};"]}
{"id": "1520", "ref_js": ["var sumOfThree = function(num) {\\n    return (num % 3 === 0) ? [num / 3 - 1, num / 3, num / 3 + 1] : [];\\n};", "var sumOfThree = function(num) {\\n    let equal = num/3;\\n    let output = [];\\n\\n    if(!Number.isInteger(equal)){\\n        return output\\n    }\\n\\n    output.push(equal -1);\\n    output.push(equal);\\n    output.push(equal+1);\\n    return output;\\n};", "var sumOfThree = function(num) {\\n    let equal = num/3;\\n    let output = [];\\n\\n    if(!Number.isInteger(equal)){\\n        return output\\n    }\\n\\n    output.push(equal -1);\\n    output.push(equal);\\n    output.push(equal+1);\\n    return output;\\n};"]}
{"id": "1521", "ref_js": ["var maximumEvenSplit = function(finalSum) {\\n\\n    if(finalSum % 2) return [];\\n\\n    const set = new Set();\\n\\n    let n = 2, sum = 0;\\n\\n    while(sum < finalSum) {\\n        sum += n;\\n        set.add(n);\\n        n += 2;\\n    }\\n\\n    set.delete(sum - finalSum);\\n\\n    return [...set];\\n};", "var maximumEvenSplit = function(finalSum) {\\n    if (finalSum % 2 === 1) return [];\\n    \\n    var missing = finalSum;\\n    var ans = [];\\n    for (var cNum = 2; missing >= 2*cNum + 2; cNum+=2) {\\n        ans.push(cNum);\\n        missing -= cNum;\\n    }\\n    \\n    if (missing > 0) ans.push(missing);\\n    return ans;\\n};", "var maximumEvenSplit = function(finalSum) {\\n    let result = []\\n\\n    if(finalSum == 2) return [2];\\n\\n    var recursion = function(res = [], j = 2, sum = 0) {\\n        if(sum == finalSum) {\\n            if(res.length > result.length) {\\n                result = res.slice();\\n            }\\n        }\\n\\n        if(sum > finalSum) return;\\n        \\n        for(let i = j; i < finalSum; i += 2) {\\n            res.push(i);\\n            recursion(res, i + 2, sum + res[res.length - 1]);            \\n            res.pop();\\n        }\\n    }\\n\\n    recursion();\\n\\n    return result == undefined ? [] : result;\\n};"]}
{"id": "1522", "ref_js": ["var mergeNodes = function(head) {\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    let cur = dummy;\\n    let prev;\\n    while (cur.next){\\n        prev = cur;\\n        if (cur.next.val === 0){\\n            cur = cur.next;\\n        }\\n        if (cur.next){\\n            cur.val += cur.next.val\\n            cur.next = cur.next.next\\n        }\\n    }\\n    prev.next = null;\\n    return head;\\n};", "var mergeNodes = function(head) {\\n    let count = 0;\\n    \\n    let node = head; ", "var mergeNodes = function(head) {\\n    let prevPtr = null;\\n    let nodePtr = head;\\n    while (nodePtr !== null){\\n        if(nodePtr.val === 0){\\n            if (prevPtr === null){\\n                prevPtr = nodePtr;\\n            } else if (nodePtr.next) {\\n                prevPtr = prevPtr.next;\\n                prevPtr.val = 0;\\n            }\\n        }  else  if (prevPtr !== null && nodePtr !== null){\\n            prevPtr.val += nodePtr.val;\\n        }\\n        nodePtr = nodePtr.next;\\n    }\\n    prevPtr.next = null;\\n    return head;\\n};"]}
{"id": "1523", "ref_js": ["var minOperations = function(nums) {\\n    let ops=0\\n    for(let i=1;i<nums.length;i++){\\n        if(nums[i]<=nums[i-1]){\\n            ops+=(nums[i-1]-nums[i])+1\\n            nums[i]=nums[i-1]+1\\n        }\\n    }\\n    return ops\\n};", "var minOperations = function(nums) {\\n    if(nums.length < 2) return 0;\\n    let count = 0;\\n    for(let i = 1; i<nums.length; i++) {\\n       if(nums[i] <= nums[i-1]) {\\n           let change = nums[i-1] - nums[i] + 1;\\n           count += change;\\n           nums[i] += change;\\n       }\\n    }\\n    \\n    return count;\\n};", "var minOperations = function(nums) {\\n    if(nums.length < 2) return 0;\\n    let count = 0;\\n    for(let i = 1; i<nums.length; i++) {\\n       if(nums[i] <= nums[i-1]) {\\n           let change = nums[i-1] - nums[i] + 1;\\n           count += change;\\n           nums[i] += change;\\n       }\\n    }\\n    \\n    return count;\\n};"]}
{"id": "1524", "ref_js": ["var minSteps = function(s, t) {\\n  let sFreq = Array(26).fill(0), tFreq = Array(26).fill(0);\\n  for (let char of s) sFreq[char.charCodeAt() - 97]++;\\n  for (let char of t) tFreq[char.charCodeAt() - 97]++;\\n  let ans = 0;\\n  for (let i = 0; i < 26; i++) {\\n    ans += Math.abs(sFreq[i] - tFreq[i]);\\n  }\\n  return ans;\\n};", "var minSteps = function(s, t) {\\n    const sFreq = Array(26).fill(0);\\n    const tFreq = Array(26).fill(0);\\n\\n    for(let i=0; i<s.length; i++) {\\n        sFreq[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++;\\n    }\\n\\n    for(let i=0; i<t.length; i++) {\\n        tFreq[t.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++;\\n    }\\n\\n    let sum = 0;\\n    for(let i=0; i<26; i++) {\\n      sum = sum + Math.abs(sFreq[i] - tFreq[i]);\\n    }\\n    return sum;\\n};", "var minSteps = function(s, t) {\\n  const maps = countLetters(s); "]}
{"id": "1525", "ref_js": ["var minimumTime = function (time, totalTrips) {\\n  let maxTime = Math.min.apply(null, time) * totalTrips;\\n  let minTime = 1;\\n\\n  while (minTime < maxTime) {\\n    const midTime = Math.floor((minTime + maxTime) / 2);\\n    let trips = 0;\\n    for (const tripTime of time) {\\n      trips += Math.floor(midTime / tripTime);\\n    }\\n\\n    trips < totalTrips ? (minTime = midTime + 1) : (maxTime = midTime);\\n  }\\n\\n  return minTime;\\n};", "var minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};", "var minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};"]}
{"id": "1526", "ref_js": ["var sortJumbled = function(mapping, nums) {\\n    const jumbledMap = new Map();\\n    const jumble = (num) => {\\n        if (jumbledMap.has(num)) return jumbledMap.get(num);\\n        const str = `${num}`;\\n        let result = \\'\\';\\n\\n        for (const char of str) {\\n            result += mapping[char];\\n        }\\n        result = +result;\\n        jumbledMap.set(num, result);\\n        return result;\\n    };", "var sortJumbled = function(mapping, nums) {\\n    const jumbledMap = new Map();\\n    const jumble = (num) => {\\n        if (jumbledMap.has(num)) return jumbledMap.get(num);\\n        const str = `${num}`;\\n        let result = \\'\\';\\n\\n        for (const char of str) {\\n            result += mapping[char];\\n        }\\n        result = +result;\\n        jumbledMap.set(num, result);\\n        return result;\\n    };", "var sortJumbled = function(mapping, nums) {\\n    const jumbledMap = new Map();\\n    const jumble = (num) => {\\n        if (jumbledMap.has(num)) return jumbledMap.get(num);\\n        const str = `${num}`;\\n        let result = \\'\\';\\n\\n        for (const char of str) {\\n            result += mapping[char];\\n        }\\n        result = +result;\\n        jumbledMap.set(num, result);\\n        return result;\\n    };"]}
{"id": "1527", "ref_js": ["var getAncestors = function(n, edges) {\\n    ", "var getAncestors = function(n, edges) {\\n    ", "var getAncestors = function(n, edges) {\\n    "]}
{"id": "1528", "ref_js": ["var minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    let count = 0;\\n    let i = 1;\\n    nums.sort((a, b) => a - b); ", "var minimalKSum2 = function(nums, k) {\\n  let sum = 0;\\n  let cur = 1;\\n  let max = Math.max(...nums);\\n  nums = new Set(nums);\\n  while (k) {\\n    if (cur>max || !nums.has(cur)) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};", "var minimalKSum2 = function(nums, k) {\\n  let sum = 0;\\n  let cur = 1;\\n  let max = Math.max(...nums);\\n  nums = new Set(nums);\\n  while (k) {\\n    if (cur>max || !nums.has(cur)) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};"]}
{"id": "1529", "ref_js": ["var createBinaryTree = function (descriptions) {\\n  let hash = {};", "var createBinaryTree = function(descriptions) {\\n  let nodes = new Map(), children = new Set();\\n  for (let [parent, child, isLeft] of descriptions) {\\n    let parentNode = nodes.get(parent) || new TreeNode(parent);\\n    if (!nodes.has(parent)) nodes.set(parent, parentNode);\\n    \\n    let childNode = nodes.get(child) || new TreeNode(child);\\n    if (!nodes.has(child)) nodes.set(child, childNode);\\n    \\n    if (isLeft) parentNode.left = childNode;\\n    else parentNode.right = childNode;\\n    \\n    children.add(child);\\n  }\\n\\n  for (let [parent, child, isLeft] of descriptions) {\\n    ", "var createBinaryTree = function (descriptions) {\\n  let hash = {};"]}
{"id": "1530", "ref_js": ["var digArtifacts = function(n, artifacts, dig) {\\n    const digSet = dig.reduce((set, [r, c]) => set.add(`${r}-${c}`), new Set());\\n\\n    return artifacts.reduce((result, [r1, c1, r2, c2]) => {\\n        for (let r = r1; r <= r2; r++) {\\n            for (let c = c1; c <= c2; c++) {\\n                if (!digSet.has(`${r}-${c}`)) return result;\\n            }\\n        }\\n        return result + 1;\\n    }, 0); \\n};", "var digArtifacts = function(n, artifacts, dig) {\\n    const digSet = dig.reduce((set, [r, c]) => set.add(`${r}-${c}`), new Set());\\n\\n    return artifacts.reduce((result, [r1, c1, r2, c2]) => {\\n        for (let r = r1; r <= r2; r++) {\\n            for (let c = c1; c <= c2; c++) {\\n                if (!digSet.has(`${r}-${c}`)) return result;\\n            }\\n        }\\n        return result + 1;\\n    }, 0); \\n};", "var digArtifacts = function(n, artifacts, dig) {\\n    const digSet = dig.reduce((set, [r, c]) => set.add(`${r}-${c}`), new Set());\\n\\n    return artifacts.reduce((result, [r1, c1, r2, c2]) => {\\n        for (let r = r1; r <= r2; r++) {\\n            for (let c = c1; c <= c2; c++) {\\n                if (!digSet.has(`${r}-${c}`)) return result;\\n            }\\n        }\\n        return result + 1;\\n    }, 0); \\n};"]}
{"id": "1531", "ref_js": ["var maximumTop = function (nums, k) {\\n    if (nums.length === 1 && k == 0) return nums;\\n    if (nums.length === 1 && k % 2 !== 0) return -1;\\n    let max = Math.max(...nums.slice(0, Math.abs(k - 1)));\\n    return max > nums[k] || nums[k] === undefined ? max : nums[k];\\n};", "var maximumTop = function(nums, k) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const n = nums.length;\\n    \\n    if (k === 0) return nums[0];\\n    if (n === 1 && k % 2 == 1) return -1; ", "var maximumTop = function(nums, k) {\\n    if (nums.length === 1 && k % 2) return -1\\n    let max = -Infinity\\n\\n    for (let i = 0; i <= k && i < nums.length; i++) {\\n        if (i === k - 1) continue\\n        if (nums[i] > max) max = nums[i]\\n    }\\n\\n    return max > -Infinity ? max : -1\\n};"]}
{"id": "1532", "ref_js": ["var maximumSubsequenceCount = function(text, pattern) {\\n    let fc = 0;\\n    let sc = 0;\\n\\n    let res = 0;\\n\\n    for (let el of text) {\\n        if (el === pattern[0]) fc++;\\n        else if (el === pattern[1]) {\\n            sc++;\\n            res += fc;\\n        }\\n    }\\n\\n    if (pattern[0] === pattern[1]) return fc * (fc + 1) / 2;\\n    \\n    return res + Math.max(fc, sc);\\n};", "var maximumSubsequenceCount = function(text, pattern) {\\n    const [a,b]=pattern;\\n   \\n    const calculate=(s)=>{\\n        const pref=[s[0]===a?1:0], post=Array(s.length).fill();\\n        post[post.length-1]=s[s.length-1]===b?1:0;\\n\\n        for(let i=1;i<s.length;i++){\\n            pref[i]=pref[i-1]+(s[i]===a?1:0);\\n        }\\n\\n        for(let i=s.length-2;i>=0;i--){\\n            post[i]=post[i+1]+(s[i]===b?1:0);\\n        }\\n\\n        let ans=0;\\n        for(let i=0;i<s.length;i++){\\n            if(s[i]===a)ans+=post[i]-(a==b?1:0); ", "var maximumSubsequenceCount = function(text, pattern) {\\n    const count = [0,0];\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) count[0]++;\\n        if (text[i] === pattern[1]) count[1]++;\\n    }\\n\\n    if (count[0] > count[1]) {\\n        text = text + pattern[1];\\n        count[1]++;\\n    } else {\\n        text = pattern[0] + text;\\n        count[0]++;\\n    }\\n\\n    let total = 0;\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) total += count[1];\\n        if (text[i] === pattern[1]) count[1]--;\\n    }\\n    return total;\\n};"]}
{"id": "1533", "ref_js": ["var halveArray = function(nums) {\\n    const heap = new MaxHeap();\\n    heap.addAll(nums);\\n    let sum = 0;\\n    nums.forEach(node => {\\n        sum = sum + node;\\n    });\\n    let reducedSum = sum;\\n    let steps = 0;\\n    while (reducedSum > sum / 2) {\\n        const node = heap.poll();\\n        reducedSum = reducedSum - node/2;\\n        heap.add(node/2);\\n        steps++;\\n    }\\n    return steps;\\n};", "var halveArray = function (a) {\\n  let sum = a.reduce((sum, e) => sum + e, 0);\\n  let half = sum / 2;\\n\\n  const pq = new MaxPriorityQueue({ compare: (a, b) => b - a });\\n  for (const e of a) {\\n    pq.enqueue(e);\\n  }\\n\\n  let count = 0;\\n  while (sum > half) {\\n    const e = pq.dequeue();\\n    sum -= e / 2;\\n    pq.enqueue(e / 2);\\n    count++;\\n  }\\n  return count;\\n};", "var halveArray = function(nums) {\\n    const maxPQ = new MaxPriorityQueue();\\n    const initialSum = nums.reduce((acc, num) => acc + num);\\n    let curSum = initialSum, operations = 0;\\n\\n    for (const num of nums) maxPQ.enqueue(num);\\n\\n    while (curSum > initialSum / 2) {\\n        const newNum = maxPQ.dequeue().element / 2;\\n        curSum -= newNum, maxPQ.enqueue(newNum),operations++;\\n    }\\n\\n    return operations;\\n};"]}
{"id": "1534", "ref_js": ["var countCollisions = function(directions) {\\n    let count = 0;\\n    let start = 0;\\n    let end = directions.length-1;\\n    while(directions[start] === \\'L\\') ", "var countCollisions = function(directions) {\\n    let count = 0;\\n    let start = 0;\\n    let end = directions.length-1;\\n    while(directions[start] === \\'L\\') ", "var countCollisions = function(directions) {\\n    let count = 0;\\n    let start = 0;\\n    let end = directions.length-1;\\n    while(directions[start] === \\'L\\') "]}
{"id": "1535", "ref_js": ["var maximumBobPoints = function(numArrows, aliceArrows) {\\n  let max = 0, n = aliceArrows.length, res;\\n  backtrack(numArrows, 0, 0, Array(n).fill(0));\\n  return res;\\n\\n  function backtrack(arrows, idx, points, bobArrows) {\\n    if (idx === n || arrows === 0) {\\n      let origVal = bobArrows[n - 1];\\n      if (arrows > 0) bobArrows[n - 1] += arrows; ", "var maximumBobPoints = function(numArrows, aliceArrows) {\\n    let bobArrows = new Array(12).fill(0);\\n    let total= numArrows;\\n    let p=0;\\n    let countMax = (index,total,bob,aliceArrows,p) =>{\\n        let newarr  = [...bob];\\n        if(total == 0 || index == 0){ ", "var maximumBobPoints = function(numArrows, aliceArrows) {\\n  let max = 0, n = aliceArrows.length, res;\\n  backtrack(numArrows, 0, 0, Array(n).fill(0));\\n  return res;\\n\\n  function backtrack(arrows, idx, points, bobArrows) {\\n    if (idx === n || arrows === 0) {\\n      let origVal = bobArrows[n - 1];\\n      if (arrows > 0) bobArrows[n - 1] += arrows; "]}
{"id": "1536", "ref_js": ["var minDeletion = function( nums ) {\\n        var count = 0;\\n        \\n        for( let i = 0; i < nums.length ; i++ ) {\\n                if( i % 2 === 0 && nums[i] === nums[i + 1] ) {\\n\\t\\t\\t\\t\\t\\t", "var minDeletion = function(nums) {\\n    let deletions = 0;\\n    for (let i = 0; i < nums.length; i += 2) {\\n        if (nums[i] === nums[i + 1]) {\\n            deletions++;\\n            i -= 1;\\n        }\\n    }\\n    return ((nums.length - deletions) % 2 !== 0) ? deletions + 1 : deletions;\\n};", "var minDeletion = function(nums) {\\n    let deletions = 0;\\n    for (let i = 0; i < nums.length; i += 2) {\\n        if (nums[i] === nums[i + 1]) {\\n            deletions++;\\n            i -= 1;\\n        }\\n    }\\n    return ((nums.length - deletions) % 2 !== 0) ? deletions + 1 : deletions;\\n};"]}
{"id": "1537", "ref_js": ["var kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t", "var kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t", "var kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t"]}
{"id": "1538", "ref_js": ["var triangularSum = function(nums) {\\n  let start = 0, end = nums.length - 1;\\n  while (start < end) {\\n    for (let i = start; i < end; i++) {\\n      nums[i] = (nums[i] + nums[i + 1]) % 10;\\n    }\\n    end--;\\n  }\\n  return nums[0];\\n};", "var triangularSum = function(nums) {\\n    let start = 0, end = nums.length - 1;\\n        while (start < end) {\\n            for (let i = start; i < end; i++) {\\n                nums[i] = (nums[i] + nums[i + 1]) % 10;\\n            }\\n            end--;\\n        }\\n        return nums[0]; \\n};", "var triangularSum = function(nums) {\\n    if (nums.length === 1) return nums[0];\\n    let st = [];\\n    let len = nums.length - 1;\\n    for (let i = 0; i <= len; i++) st.push(nums[i]);\\n    let cnt = 0;\\n    while (st.length > 1) {\\n        if (cnt === len) {\\n            len -= 1;\\n            st.shift();\\n            cnt = 0;\\n            continue;\\n        }\\n        if (st.length === 1) return st[0];\\n\\n        let top1 = st[0];\\n        st.shift();\\n        let top2 = st[0];\\n        let sum = top1 + top2;\\n        if (sum > 9) st.push(sum % 10);\\n        else st.push(sum);\\n        cnt++;\\n    }\\n\\n    return st[0];\\n};"]}
{"id": "1539", "ref_js": ["var numberOfWays = function(s) {\\n    let ans = 0;\\n    ", "var numberOfWays = function (s) {\\n  let seq = getChCountInSeq(s);\\n  let n = seq.length;\\n  let memo = Array.from({ length: n + 1 }, () => Array.from({ length: 3 + 1 }, () => new Array(3)));\\n  function numOfWays(i, buildingCount, prevSelected) {\\n    if (memo[i][buildingCount][prevSelected] !== undefined) return memo[i][buildingCount][prevSelected];\\n    if (buildingCount === 0) return (memo[i][buildingCount][prevSelected] = 1);\\n    if (i === n) return (memo[i][buildingCount][prevSelected] = 0);\\n    let count = 0;\\n    if (seq[i][0] !== prevSelected) {\\n      count += numOfWays(i + 1, buildingCount - 1, seq[i][0]) * seq[i][1];\\n    }\\n    count += numOfWays(i + 1, buildingCount, prevSelected);\\n    return (memo[i][buildingCount][prevSelected] = count);\\n  }\\n  return numOfWays(0, 3, \"\");\\n};", "var numberOfWays = function(s) {\\n    let numberOfzeros = 0, numberOfOnes = 0;\\n    for(let c of s) c === \\'0\\' ? numberOfzeros++ : numberOfOnes++;\\n    let tempZerosCountSoFar = 0;\\n    let tempOnesCountSoFar = 0;\\n    let count = 0;\\n    for(let c of s) {\\n        if(c === \\'1\\') {\\n            count += tempZerosCountSoFar * (numberOfzeros - tempZerosCountSoFar);\\n            tempOnesCountSoFar++;\\n        } else {\\n            count += tempOnesCountSoFar * (numberOfOnes - tempOnesCountSoFar);\\n            tempZerosCountSoFar++;\\n        }\\n    }\\n    return count;\\n};"]}
{"id": "1540", "ref_js": ["var findWinners = function(matches) {\\n    const hash = matches.reduce((res, [winner, loser]) => {\\n        if (!res[winner]) {\\n            res[winner] = 0;\\n        }\\n        \\n        if (!res[loser]) {\\n            res[loser] = 0;\\n        }\\n        \\n        res[loser]++;\\n        \\n        return res;\\n    }, {});\\n    \\n    return Object.keys(hash).reduce((res, x) => {\\n        const count = hash[x];\\n        \\n        if (count === 0) {\\n            res[0].push(x);\\n        } else if (count === 1) {\\n            res[1].push(x);\\n        }\\n        \\n        return res;\\n    }, [[], []]);\\n};", "var findWinners = function(matches) {\\n    var looser = {};", "var findWinners = function(matches) {\\n  let lost = {};"]}
{"id": "1541", "ref_js": ["var maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};", "var maximumCandies = function(candies, k) {\\n    let maxPile=candies.reduce((acc,curr)=>Math.max(acc,curr));\\n\\n    const split=(n)=>{\\n        let ans=0;\\n        for(let i=0;i<candies.length;i++){\\n            ans+=Math.trunc(candies[i]/n);\\n        }\\n        return ans;\\n    }\\n\\n    let l=1, r=maxPile, ans=0;\\n    while(l<=r){\\n        const mid = Math.trunc((l+r)/2);\\n        const pilesSplit = split(mid);\\n        if(pilesSplit>=k){\\n            ans=mid;\\n            l=mid+1;\\n        }else{\\n            r=mid-1;\\n        }\\n    }\\n    return ans;\\n};", "var maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };"]}
{"id": "1542", "ref_js": ["var minimizeResult = function (ex) {\\n  let min = Infinity\\n  let an = []\\n\\n  let [l, r] = ex.split(\"+\");\\n  for (let i = 0; i < l.length; i++) {\\n    let a = l.slice(0, i)\\n    let b = l.slice(i)\\n\\n    for (let j = 1; j <= r.length; j++) {\\n      let c = r.slice(0, j)\\n      let d = r.slice(j)\\n\\n      let val = +b + +c\\n      if (a !== \\'\\') val = a * val\\n      if (d !== \\'\\') val = val * d\\n\\n      if (val < min) {\\n        min = Math.min(min, val)\\n        an = [a, b, c, d]\\n      }\\n    }\\n  }\\n\\n  let [a, b, c, d] = an\\n  return \\'\\' + a + \\'(\\' + b + \\'+\\' + c + \\')\\' + d\\n};", "var minimizeResult = function(expression) {\\n    const [left, right] = expression.split(\"+\");\\n    let res = [`(${expression})`, +left + +right];\\n    \\n    for(let i = 0; i < left.length; i++) {\\n        const i1 = left.slice(0, i) || 1;\\n        const i2 = left.slice(i);\\n        \\n        for(let j = 1; j <= right.length; j++) {\\n            const j1 = right.slice(0, j);\\n            const j2 = right.slice(j) || 1;\\n\\n            const tempTotal = i1*(+i2 + +j1)*j2;\\n                        \\n            if(res[1] > tempTotal ) {\\n                res[0] = `${left.slice(0, i)}(${i2}+${j1})${right.slice(j)}`;\\n                res[1] = tempTotal\\n            }\\n        }\\n    }\\n    return res[0]\\n};", "var minimizeResult = function (expression) {\\n\\n    let index = expression.indexOf(\"+\");\\n    let max = Infinity;\\n    let response = \"\";\\n\\n    for (let i = 0; i < index; i++) {\\n        for (let j = expression.length; j > index + 1; j--) {\\n\\n            let A = Number(expression.slice(0, i)) || 1;\\n            let B = Number(expression.slice(i, index));\\n            let C = Number(expression.slice(index, j));\\n            let D = Number(expression.slice(j)) || 1;\\n            let result = A * (B + C ) * D;\\n\\n            if (result < max) {\\n                let left = expression.slice(0, i) + \"(\" + expression.slice(i, index);\\n                let right = expression.slice(index, j) + \")\" + expression.slice(j);\\n                max = result;\\n                response = `${left}${right}`;\\n            }\\n\\n        }\\n    }\\n    return response;\\n};"]}
{"id": "1543", "ref_js": ["var maximumProduct = function (a, k) {\\n  let pq = new PriorityQueue({ compare: (a, b) => a - b})\\n  for (let e of a) pq.enqueue(e)\\n  while (k--) {\\n    let e = pq.dequeue()\\n    pq.enqueue(e + 1)\\n  }\\n  let p = 1\\n  while(!pq.isEmpty()) {\\n    p *= pq.dequeue()\\n    p %= 10 ** 9 + 7\\n  }\\n  return p\\n};", "var maximumProduct = function(nums, k, min) {\\n    nums.sort((a,b)=>a-b)\\n    while(k){\\n        min=nums[0]\\n        for(let q=0;q<nums.length;q++){\\n            if(nums[q]==min && k){\\n                nums[q]++\\n                k--\\n            }else break\\n        }  \\n    }\\n    return nums.reduce((a,b)=>a*b % (1e9+7))\\n};", "var maximumProduct = function(nums, k, min) {\\n    nums.sort((a,b)=>a-b)\\n    while(k){\\n        min=nums[0]\\n        for(let q=0;q<nums.length;q++){\\n            if(nums[q]==min && k){\\n                nums[q]++\\n                k--\\n            }else break\\n        }  \\n    }\\n    return nums.reduce((a,b)=>a*b % (1e9+7))\\n};"]}
{"id": "1544", "ref_js": ["var waysToBuyPensPencils = function(total, cost1, cost2) {\\n    var res = 0;\\n    while(total >= 0){\\n        res += Math.trunc((total/cost2)+1);\\n        total -= cost1;\\n    }\\n    return (res);\\n};", "var waysToBuyPensPencils = function(total, cost1, cost2) {\\n    var count = 0;\\n    for(var i = 0; i <= total / cost1; ++i){\\n        count += Math.trunc((total - i * cost1) / cost2 + 1);\\n    }\\n    return count;\\n};", "var waysToBuyPensPencils = function(total, cost1, cost2) {\\n    let count = 0;\\n\\n    for(let i = 0; i <= total / cost1; ++i){\\n        count += Math.trunc((total - i * cost1) / cost2 + 1);\\n    }\\n    \\n    return count;\\n};"]}
{"id": "1546", "ref_js": ["var minimumRounds = function(tasks) {\\n    <!-- map to store frequencies -->\\n    const hash = new Map();\\n    <!-- total count | answer  -->\\n    let count = 0;\\n\\n    for(let task of tasks){\\n        <!-- if that number already exit in table than update it\\'s value -->\\n        if(hash.has(task)){\\n            hash.set(task, hash.get(task) + 1)\\n        }else{\\n            <!-- if that number don\\'t exit add ti table -->\\n            hash.set(task, 1)\\n        }\\n    }\\n    <!-- iterate over Map -->\\n    for(let [key, value] of hash){\\n        <!-- \\n            if frequncy is 1 the its not possible to complete tasks\\n            so return -1 \\n        -->\\n        if(value <= 1) return -1\\n\\n        <!-- if completely divisible to 3 than add directly to count -->\\n        if(value % 3 === 0){\\n            count += value/3\\n        }else{\\n        <!-- if not divisible with 3 -->\\n            count += Math.floor(value / 3) + 1\\n        }\\n    }\\n\\n    return count;\\n};", "var minimumRounds = function(tasks) {\\n    \\n    const mem = [];\\n    \\n    const get = (n) => {\\n        if(mem[n] != undefined) return mem[n];\\n        if(n < 0) return Infinity;\\n        if(n === 0) return 0;\\n        \\n        const ans = 1 + Math.min(get(n - 2), get(n - 3));\\n        \\n        mem[n] = ans;\\n        return ans;\\n    }\\n    \\n    let ans = 0;\\n    \\n    const map = new Map();\\n    for(const t of tasks) {\\n        map.set(t, (map.get(t) ||\\xA00) + 1);\\n    }\\n    \\n    for(const n of map.values()) {\\n        const val = get(n);\\n        if(val === Infinity) return -1;\\n        ans += val;\\n    }\\n    \\n    return ans;\\n};", "var minimumRounds = function(tasks) {\\n    let map = {} "]}
{"id": "1547", "ref_js": ["var maxTrailingZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const postfixCols = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n            \\n            if (postfixCols[j] == null) postfixCols[j] = { 2: 0, 5: 0 };", "var maxTrailingZeros = function(grid) {\\n    const n = grid.length, m = grid[0].length;\\n    const rowWise = Array.from({ length: n }, () => Array(m)),\\n      columnWise = Array.from({ length: n }, () => Array(m));\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            grid[i][j] = [getFactorsCount(grid[i][j], 2), getFactorsCount(grid[i][j], 5)];\\n            rowWise[i][j] = [(j > 0 ? rowWise[i][j - 1][0] : 0) + grid[i][j][0],\\n                (j > 0 ? rowWise[i][j - 1][1] : 0) + grid[i][j][1]];\\n            columnWise[i][j] = [(i > 0 ? columnWise[i - 1][j][0] : 0) + grid[i][j][0],\\n                (i > 0 ? columnWise[i - 1][j][1] : 0) + grid[i][j][1]];\\n        }\\n    }\\n    \\n    function getFactorsCount(value, factor) {\\n        let count = 0;\\n        while(value % factor == 0) count++, value /= factor;\\n        return count;\\n    }\\n\\n    let maxTrailingZeros = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            const top = columnWise[i - 1]?.[j] ?? [0, 0];\\n            const left = rowWise[i][j - 1] ?? [0, 0];\\n            const right = [rowWise[i].at(-1)[0] - rowWise[i][j][0],\\n                rowWise[i].at(-1)[1] - rowWise[i][j][1]];\\n            const bottom = [columnWise.at(-1)[j][0] - columnWise[i][j][0],\\n                columnWise.at(-1)[j][1] - columnWise[i][j][1]];\\n\\n            const allDirections = [top, left, right, bottom];            \\n            for (let k = 0; k < 4; k++) {\\n                for (let l = 0; l < 4; l++) {\\n                    if (k == l) continue;\\n                    maxTrailingZeros = Math.max(maxTrailingZeros, \\n                        Math.min(allDirections[k][0] + allDirections[l][0] + grid[i][j][0], \\n                            allDirections[k][1] + allDirections[l][1] + grid[i][j][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTrailingZeros;\\n};", "var maxTrailingZeros = function(grid) {\\n    const n = grid.length, m = grid[0].length;\\n    const rowWise = Array.from({ length: n }, () => Array(m)),\\n      columnWise = Array.from({ length: n }, () => Array(m));\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            grid[i][j] = [getFactorsCount(grid[i][j], 2), getFactorsCount(grid[i][j], 5)];\\n            rowWise[i][j] = [(j > 0 ? rowWise[i][j - 1][0] : 0) + grid[i][j][0],\\n                (j > 0 ? rowWise[i][j - 1][1] : 0) + grid[i][j][1]];\\n            columnWise[i][j] = [(i > 0 ? columnWise[i - 1][j][0] : 0) + grid[i][j][0],\\n                (i > 0 ? columnWise[i - 1][j][1] : 0) + grid[i][j][1]];\\n        }\\n    }\\n    \\n    function getFactorsCount(value, factor) {\\n        let count = 0;\\n        while(value % factor == 0) count++, value /= factor;\\n        return count;\\n    }\\n\\n    let maxTrailingZeros = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            const top = columnWise[i - 1]?.[j] ?? [0, 0];\\n            const left = rowWise[i][j - 1] ?? [0, 0];\\n            const right = [rowWise[i].at(-1)[0] - rowWise[i][j][0],\\n                rowWise[i].at(-1)[1] - rowWise[i][j][1]];\\n            const bottom = [columnWise.at(-1)[j][0] - columnWise[i][j][0],\\n                columnWise.at(-1)[j][1] - columnWise[i][j][1]];\\n\\n            const allDirections = [top, left, right, bottom];            \\n            for (let k = 0; k < 4; k++) {\\n                for (let l = 0; l < 4; l++) {\\n                    if (k == l) continue;\\n                    maxTrailingZeros = Math.max(maxTrailingZeros, \\n                        Math.min(allDirections[k][0] + allDirections[l][0] + grid[i][j][0], \\n                            allDirections[k][1] + allDirections[l][1] + grid[i][j][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTrailingZeros;\\n};"]}
{"id": "1548", "ref_js": ["var countLatticePoints = function(circles) {\\n    let minX=minY=Infinity, maxX=maxY=-Infinity;\\n    for(let i=0; i<circles.length; i++){\\n        minX=Math.min(minX, circles[i][0]-circles[i][2]); maxX=Math.max(maxX, circles[i][0]+circles[i][2]);\\n        minY=Math.min(minY, circles[i][1]-circles[i][2]); maxY=Math.max(maxY, circles[i][1]+circles[i][2]);\\n    }\\n\\t\\n    let count=0;\\n    for(let i=minX; i<=maxX; i++){\\n        for(let j=minY; j<=maxY; j++){\\n            let find=false;\\n            for(let k=0; k<circles.length; k++){\\n                if(((i-circles[k][0])**2+(j-circles[k][1])**2)<=circles[k][2]**2){\\n                    find=true; break;\\n                }\\n            }\\n            if(find){count++};", "var countLatticePoints = function(circles) {\\n    let hash = {};", "var countLatticePoints = function (circles) {\\n  const visited = new Set();\\n  const checkIsInside = (a, b, r, x, y) => {\\n    if ((a - x) ** 2 + (b - y) ** 2 > r ** 2) return false;\\n    return true;\\n  };"]}
{"id": "1549", "ref_js": ["var countRectangles = function(rectangles, points) {\\n  let buckets = Array(101).fill(0).map(() => []);\\n  for (let [x, y] of rectangles) {\\n    buckets[y].push(x);\\n  }\\n  for (let i = 0; i < 101; i++) buckets[i].sort((a, b) => a - b);\\n\\n  let res = [];\\n  for (let point of points) {\\n    let sum = 0;\\n    for (let j = point[1]; j < 101; j++) {\\n      ", "var countRectangles = function(rectangles, points) {\\n  let buckets = Array(101).fill(0).map(() => []);\\n  for (let [x, y] of rectangles) {\\n    buckets[y].push(x);\\n  }\\n  for (let i = 0; i < 101; i++) buckets[i].sort((a, b) => a - b);\\n\\n  let res = [];\\n  for (let point of points) {\\n    let sum = 0;\\n    for (let j = point[1]; j < 101; j++) {\\n      ", "var countRectangles = function(rectangles, points) {\\n  let buckets = Array(101).fill(0).map(() => []);\\n  for (let [x, y] of rectangles) {\\n    buckets[y].push(x);\\n  }\\n  for (let i = 0; i < 101; i++) buckets[i].sort((a, b) => a - b);\\n\\n  let res = [];\\n  for (let point of points) {\\n    let sum = 0;\\n    for (let j = point[1]; j < 101; j++) {\\n      "]}
{"id": "1550", "ref_js": ["var minimumAverageDifference = function(nums) {\\n    let nL=nums.length;\\n    let leftSum = 0;\\n    let rightSum = nums.reduce((p,n)=>{return p+n},0);\\n\\n    let minimum = Infinity;\\n    let ans = Infinity;\\n    for (let i=0; i<nL; i++){\\n        leftSum += nums[i];\\n        rightSum -= nums[i];\\n        let res = Math.abs(Math.floor(((leftSum)/(i+1))) - Math.floor(((rightSum)/Math.max(1,(nL-1-i)))));\\n        if(res < minimum){\\n            minimum = res;\\n            ans = i;\\n        }\\n    }\\n    return ans;\\n};", "var minimumAverageDifference = function(nums) {\\n    let nL=nums.length;\\n    let leftSum = 0;\\n    let rightSum = nums.reduce((p,n)=>{return p+n},0);\\n\\n    let minimum = Infinity;\\n    let ans = Infinity;\\n    for (let i=0; i<nL; i++){\\n        leftSum += nums[i];\\n        rightSum -= nums[i];\\n        let res = Math.abs(Math.floor(((leftSum)/(i+1))) - Math.floor(((rightSum)/Math.max(1,(nL-1-i)))));\\n        if(res < minimum){\\n            minimum = res;\\n            ans = i;\\n        }\\n    }\\n    return ans;\\n};", "var minimumAverageDifference = function(nums) {\\n    let nL=nums.length;\\n    let leftSum = 0;\\n    let rightSum = nums.reduce((p,n)=>{return p+n},0);\\n\\n    let minimum = Infinity;\\n    let ans = Infinity;\\n    for (let i=0; i<nL; i++){\\n        leftSum += nums[i];\\n        rightSum -= nums[i];\\n        let res = Math.abs(Math.floor(((leftSum)/(i+1))) - Math.floor(((rightSum)/Math.max(1,(nL-1-i)))));\\n        if(res < minimum){\\n            minimum = res;\\n            ans = i;\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "1551", "ref_js": ["var countUnguarded = function(m, n, guards, walls) {\\n    ", "var countUnguarded = function(m, n, guards, walls) {\\n    ", "var countUnguarded = function(m, n, guards, walls) {\\n    "]}
{"id": "1552", "ref_js": ["var minimumCardPickup = function(cards) {\\n    let dic = new Map();\\n    let ans = Infinity;\\n\\n    for (let i = 0; i < cards.length; i++) {\\n        if (dic.has(cards[i])) {\\n            ans = Math.min(ans, i - dic.get(cards[i]) + 1);\\n        }\\n        \\n        dic.set(cards[i], i);\\n    }\\n\\n    return ans == Infinity ? -1 : ans;\\n};", "var minimumCardPickup = function(cards) {\\n    let cardsSeen = {};", "var minimumCardPickup = function(cards) {\\n    let cardsSeen = {};"]}
{"id": "1553", "ref_js": ["var countDistinct = function(nums, k, p) {\\n    function getKey(values){\\n      return values.join(\"-\");\\n    }\\n\\n    let subArrays = {};", "var countDistinct = function(nums, k, p) {\\n    let ans = [];\\n    \\n    let rec = (index,k,p,nums,ans,curr) => {\\n        let val = nums[index];\\n        let check = val%p;\\n        let isdiv = false;\\n        if(check == 0) isdiv=true;\\n    \\n        if(index == nums.length) {\\n            if(curr.length>0){\\n                ans.push(curr.join(\",\"));\\n            }\\n            return;\\n        }\\n        \\n        ", "var countDistinct = function(nums, k, p) {\\n    function getKey(values){\\n      return values.join(\"-\");\\n    }\\n\\n    let subArrays = {};"]}
{"id": "1554", "ref_js": ["var averageOfSubtree = function(root) {\\n    let result = 0;\\n    \\n    const traverse = node => {\\n        if (!node) return [0, 0];\\n        \\n        const [leftSum, leftCount] = traverse(node.left);\\n        const [rightSum, rightCount] = traverse(node.right);\\n        \\n        const currSum = node.val + leftSum + rightSum;\\n        const currCount = 1 + leftCount + rightCount;\\n        \\n        if (Math.floor(currSum / currCount) === node.val) result++;\\n        \\n        return [currSum, currCount];\\n    };", "var averageOfSubtree = function(root) {\\n    var res = 0;\\n\\n    var postorder = function(node) {\\n        if (!node) {\\n            return [0, 0]; ", "var averageOfSubtree = function(root) {\\n    let result = 0;\\n    \\n    const traverse = node => {\\n        if (!node) return [0, 0];\\n        \\n        const [leftSum, leftCount] = traverse(node.left);\\n        const [rightSum, rightCount] = traverse(node.right);\\n        \\n        const currSum = node.val + leftSum + rightSum;\\n        const currCount = 1 + leftCount + rightCount;\\n        \\n        if (Math.floor(currSum / currCount) === node.val) result++;\\n        \\n        return [currSum, currCount];\\n    };"]}
{"id": "1555", "ref_js": ["var countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};", "var countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};", "var countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};"]}
{"id": "1556", "ref_js": ["var waysToSplitArray = function(nums) {\\n    let result = 0;\\n    let letsum = 0;\\n    let rightsum = nums.reduce((a,b)=> a+b);\\n    let end = nums.length-1;\\n    for (let i = 0;i<end;i++) {\\n        letsum+=nums[i];\\n        rightsum-=nums[i];\\n        if (letsum>=rightsum) {\\n            result++;\\n        }\\n    }\\n    return result;\\n};", "var waysToSplitArray = function(nums) {\\n    let totalSum = 0;\\n    for(let i=0;i<nums.length;i++) totalSum +=nums[i];\\n    let left = 0, ans = 0;\\n    for(let i=0; i< nums.length - 1; i++) {\\n        left += nums[i];\\n        let right = totalSum - left;\\n        if(left >= right) ans += 1;\\n    }\\n    return ans\\n};", "var waysToSplitArray = function(nums) {\\n    let totalSum = 0;\\n    for(let i=0;i<nums.length;i++) totalSum +=nums[i];\\n    let left = 0, ans = 0;\\n    for(let i=0; i< nums.length - 1; i++) {\\n        left += nums[i];\\n        let right = totalSum - left;\\n        if(left >= right) ans += 1;\\n    }\\n    return ans\\n};"]}
{"id": "1557", "ref_js": ["var maximumWhiteTiles = function (tiles, carpetLen) {\\n    tiles.sort((a, b) => a[0] - b[0])\\n\\n    let right = 1;\\n    let cover = tiles[0][1] - tiles[0][0] + 1;\\n    let maxCovered = cover;\\n    if (maxCovered >= carpetLen) return carpetLen\\n\\n    for (const tile of tiles) {\\n        let start = tile[0]\\n        let end = start + carpetLen - 1\\n\\n        while (right < tiles.length && tiles[right][1] <= end) {\\n            cover += tiles[right][1] - tiles[right][0] + 1\\n            right++\\n        }\\n        if (right === tiles.length || end < tiles[right][0]) {\\n            maxCovered = Math.max(maxCovered, cover)\\n        } else {\\n            let partial = end - tiles[right][0] + 1\\n            maxCovered = Math.max(maxCovered, cover + partial)\\n        }\\n\\n        cover -= (tile[1] - tile[0]) + 1\\n    }\\n\\n    return maxCovered\\n};", "var maximumWhiteTiles = function(tiles, carpetLen) {\\n  tiles.sort(([a,b],[c,d])=>a-c);\\n\\n  ", "var maximumWhiteTiles = function(tiles, carpetLen) {\\n  tiles.sort(([a,b],[c,d])=>a-c);\\n\\n  "]}
{"id": "1558", "ref_js": ["var maxConsecutive = function(bottom, top, special) {\\n    \\n    special.sort((a,b)=>b-a)\\n    let max=-Infinity\\n    for(let i=0;i<special.length-1;i++){\\n        max=Math.max(max,special[i]-special[i+1]-1)\\n    } \\n    \\n    max=Math.max(max,special[special.length-1]-bottom,top-special[0])\\n    return max\\n    \\n    \\n    \\n};", "var maxConsecutive = function(bottom, top, special) {\\n    special.push(top+1);\\n    special.push(bottom-1);\\n    special.sort((a, b) => a - b);\\n    let specialMax = 0;\\n    for (let i = 1; i < special.length; i++){\\n        specialMax = Math.max(specialMax, special[i] - special[i-1] - 1)\\n    }\\n    return specialMax;\\n};", "var maxConsecutive = function(bottom, top, special) {\\n    let maxGap=0;\\n    special.push(bottom-1); "]}
{"id": "1559", "ref_js": ["var largestCombination = function (a) {\\n    let abits = new Array(32).fill(0);\\n    for (let i = 0; i < 32; i++) {\\n        for (let e of a) {\\n            if ((e & (1 << i)) !== 0) {\\n                abits[i]++;\\n            }\\n        }\\n    }\\n    return Math.max(...abits);\\n};", "var largestCombination = function(candidates) {\\n  const indexArr=Array(24).fill(0)\\n   \\n  for(let candidate of candidates){  \\n      let index =0 \\n      while(candidate>0){\\n          if((candidate&1)===1)indexArr[index]+=1\\n          candidate>>>=1\\n          index++\\n      }\\n  }\\n  \\n  return Math.max(...indexArr)\\n};", "var largestCombination = function (a) {\\n    let abits = new Array(32).fill(0);\\n    for (let i = 0; i < 32; i++) {\\n        for (let e of a) {\\n            if ((e & (1 << i)) !== 0) {\\n                abits[i]++;\\n            }\\n        }\\n    }\\n    return Math.max(...abits);\\n};"]}
{"id": "1560", "ref_js": ["var maximumBags = function(capacity, rocks, additionalRocks) {\\n    let result = 0;\\n    for(let i = 0; i < rocks.length; i++){\\n        rocks[i] = capacity[i] - rocks[i];\\n        result += rocks[i];\\n    }\\n    if(additionalRocks >= result) return rocks.length;\\n    rocks.sort(function(a, b){return a - b});\\n    result = 0;\\n    for(let i in rocks){\\n        result += rocks[i];\\n        if(result > additionalRocks) return i;\\n    } \\n};", "var maximumBags = function(capacity, rocks, additionalRocks) {\\n    let n = capacity.length\\n\\n    for (let i = 0; i < n; i++) {\\n        capacity[i] -= rocks[i]\\n    }\\n    capacity.sort((a,b)=>a-b)\\n\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (additionalRocks == 0 || capacity[i] > additionalRocks) break\\n        additionalRocks -= capacity[i]\\n        res++;\\n    }\\n    return res;\\n};", "var maximumBags = function(capacity, rocks, additionalRocks) {\\n    let n = capacity.length\\n\\n    for (let i = 0; i < n; i++) {\\n        capacity[i] -= rocks[i]\\n    }\\n    capacity.sort((a,b)=>a-b)\\n\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (additionalRocks == 0 || capacity[i] > additionalRocks) break\\n        additionalRocks -= capacity[i]\\n        res++;\\n    }\\n    return res;\\n};"]}
{"id": "1561", "ref_js": ["var minimumLines = function(stockPrices) {\\n\\t", "var minimumLines = function(stockPrices) {\\n  let count = 0;\\n  stockPrices.sort((day1, day2) => (day1[0] - day2[0]));\\n  for (i = 1; i < stockPrices.length; i++) {\\n    if (i === 1) {\\n      count += 1;\\n      continue;\\n    }\\n    let [day, price] = stockPrices[i];\\n    let [previousDay, previousPrice] = stockPrices[i - 1];\\n    let [beforeDay, beforePrice] = stockPrices[i - 2];\\n    \\n    let deltaOne = (price - previousPrice) * (previousDay - beforeDay);\\n    let deltaTwo = (previousPrice - beforePrice) * (day - previousDay); \\n    \\n    if (deltaOne !== deltaTwo) {\\n      count += 1;\\n    }\\n  }\\n  \\n  return count;\\n};", "var minimumLines = function(stockPrices) {\\n  let count = 0;\\n  stockPrices.sort((day1, day2) => (day1[0] - day2[0]));\\n  for (i = 1; i < stockPrices.length; i++) {\\n    if (i === 1) {\\n      count += 1;\\n      continue;\\n    }\\n    let [day, price] = stockPrices[i];\\n    let [previousDay, previousPrice] = stockPrices[i - 1];\\n    let [beforeDay, beforePrice] = stockPrices[i - 2];\\n    \\n    let deltaOne = (price - previousPrice) * (previousDay - beforeDay);\\n    let deltaTwo = (previousPrice - beforePrice) * (day - previousDay); \\n    \\n    if (deltaOne !== deltaTwo) {\\n      count += 1;\\n    }\\n  }\\n  \\n  return count;\\n};"]}
{"id": "1562", "ref_js": ["var largestWordCount = function(messages, senders) {\\n    let wordCount = {}\\n    let result = \\'\\'\\n    let maxCount = -Infinity\\n    for (let i = 0; i < messages.length;i++) {\\n        let count=messages[i].split(\\' \\').length\\n        wordCount[senders[i]] = wordCount[senders[i]] == undefined ? count : wordCount[senders[i]] + count;\\n        if (wordCount[senders[i]]  > maxCount || (wordCount[senders[i]]  == maxCount && senders[i] > result)) {\\n            maxCount = wordCount[senders[i]];\\n            result = senders[i];\\n        }\\n    }\\n    return result;\\n\\n};", "var largestWordCount = function(messages, senders) {\\n    let wordCount = {}\\n    let result = \\'\\'\\n    let maxCount = -Infinity\\n    for (let i = 0; i < messages.length;i++) {\\n        let count=messages[i].split(\\' \\').length\\n        wordCount[senders[i]] = wordCount[senders[i]] == undefined ? count : wordCount[senders[i]] + count;\\n        if (wordCount[senders[i]]  > maxCount || (wordCount[senders[i]]  == maxCount && senders[i] > result)) {\\n            maxCount = wordCount[senders[i]];\\n            result = senders[i];\\n        }\\n    }\\n    return result;\\n\\n};", "var largestWordCount = function(messages, senders) {\\n    let wordCount = {}\\n    let result = \\'\\'\\n    let maxCount = -Infinity\\n    for (let i = 0; i < messages.length;i++) {\\n        let count=messages[i].split(\\' \\').length\\n        wordCount[senders[i]] = wordCount[senders[i]] == undefined ? count : wordCount[senders[i]] + count;\\n        if (wordCount[senders[i]]  > maxCount || (wordCount[senders[i]]  == maxCount && senders[i] > result)) {\\n            maxCount = wordCount[senders[i]];\\n            result = senders[i];\\n        }\\n    }\\n    return result;\\n\\n};"]}
{"id": "1563", "ref_js": ["var maximumImportance = function(n, roads) {\\n    return roads\\n        .reduce((indegree, [a, b]) => \\n            (indegree[a]++, indegree[b]++, indegree), Array(n).fill(0))\\n        .sort((b, a) => b - a)\\n        .reduce((importance, indegree, idx) => \\n            importance + indegree * (idx + 1), 0);\\n};", "var maximumImportance = function(n, roads) {\\n  const list = new Array(n).fill(0).map((_, i) => ({index: i, edges: []}));\\n  const values = [];\\n  let total = 0;\\n\\n  roads.forEach(([u, v]) => {\\n    list[u].edges.push(v);\\n    list[v].edges.push(u);\\n  });\\n\\n  list.sort((a,b) => b.edges.length - a.edges.length);\\n\\n  for (let i = 0; i < list.length; i++) {\\n    values[list[i].index] = n;\\n    n--;\\n  }\\n\\n  roads.forEach(([u,v]) => total += values[u] + values[v]);\\n \\n  return total; \\n};", "var maximumImportance = function(n, roads) {\\n    let roadsMap = new Array(n).fill(0)\\n    roads.forEach(road => {\\n        let [x,y] = road\\n        roadsMap[x] += 1\\n        roadsMap[y] += 1\\n    })\\n\\n    let maxHeap = new MaxPriorityQueue({compare: (a,b) => b[1] - a[1]})\\n    roadsMap.forEach((connections, index) => {\\n        maxHeap.enqueue([index, connections])\\n    })\\n\\n    let imptMap = new Map()\\n    while (maxHeap.size() > 0) {\\n        let curr = maxHeap.dequeue()\\n        imptMap.set(curr[0], n)\\n        n -= 1\\n    }\\n\\n\\n    let totalImpt = 0\\n    roads.forEach(road => {\\n        let [x,y] = road\\n        totalImpt += (imptMap.get(x) + imptMap.get(y))\\n    })\\n\\n    return totalImpt\\n};"]}
{"id": "1564", "ref_js": ["var discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};", "var discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};", "var discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};"]}
{"id": "1565", "ref_js": ["var totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};", "var totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};", "var totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};"]}
{"id": "1566", "ref_js": ["var partitionArray = function(nums, k) {\\n    let sorted = nums.sort((a, b) => a-b)\\n    let list = []\\n    let count = 0\\n    list.push(sorted[0])\\n    for (i = 1; i < sorted.length; i++) {\\n        let num = sorted[i]\\n        if (num-list[0]>k) {\\n            count++\\n            list = []\\n        }\\n        list.push(num)\\n    } if (list.length) count++\\n    return count\\n\\n};", "var partitionArray = function(nums, k) {\\n  \\n    nums.sort((a,b) =>{ return a-b})\\n    \\n    let n = nums.length ,ans=0\\n    \\n    for(let i=0 ; i<n; i++){\\n        let ele = nums[i]\\n        while(i<n && nums[i]-ele<=k) i++\\n        i--\\n        ans++\\n    }\\n    return ans\\n};", "var partitionArray = function(nums, k) {\\n  \\n    nums.sort((a,b) =>{ return a-b})\\n    \\n    let n = nums.length ,ans=0\\n    \\n    for(let i=0 ; i<n; i++){\\n        let ele = nums[i]\\n        while(i<n && nums[i]-ele<=k) i++\\n        i--\\n        ans++\\n    }\\n    return ans\\n};"]}
{"id": "1567", "ref_js": ["var arrayChange = function(nums, operations) {\\n\\tconst config = (function() {\\n\\t\\tconst config = {};", "var arrayChange = function(nums, operations) {\\n    let map = new Map()\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        let num = nums[i]\\n        map.set(num, i)\\n    }\\n    \\n    for(let op of operations){\\n        let key = op[0]\\n        let value = op[1]\\n\\n        ", "var arrayChange = function(nums, operations) {\\n    const map = {};"]}
{"id": "1568", "ref_js": ["var successfulPairs = function(spells, potions, success) {\\n    ", "var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};", "var successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};"]}
{"id": "1569", "ref_js": ["var minPathCost = function(grid, moveCost) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    const cache = [];\\n    \\n    for (let i = 0; i < rows; i++) {\\n        cache.push(Array(cols).fill(null));\\n    }\\n    \\n    function move(row, col) {\\n        const val = grid[row][col];\\n        \\n        if (cache[row][col] !== null) {\\n            return cache[row][col];\\n        }\\n        \\n        if (row === rows - 1) {\\n            return val;\\n        }\\n        \\n        let ans = Number.MAX_SAFE_INTEGER;\\n\\n        for (let i = 0; i < cols; i++) {\\n            const addCost = moveCost[val][i];\\n\\n            ans = Math.min(ans, move(row + 1, i) + val + addCost);\\n        }\\n        \\n        cache[row][col] = ans;\\n        \\n        return ans;\\n    }\\n\\n    let ans = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < cols; i++) {\\n        ans = Math.min(ans, move(0, i));\\n    }\\n    \\n    return ans;\\n};", "var minPathCost = function(grid, moveCost) {\\n    let dp = Array.from(Array(grid.length), () => new Array(grid[0].length));\\n    for (let i = 0; i < grid[0].length; i++){\\n        dp[0][i] = grid[0][i];\\n    }\\n    for (let i = 1; i < grid.length; i++){\\n        for (let j = 0; j < grid[i].length; j++){\\n            dp[i][j] = Infinity;\\n            for (let k = 0; k < grid[i].length; k++){\\n                dp[i][j] = Math.min(dp[i][j], grid[i][j] + dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n            }\\n        }\\n    }\\n    let res = Infinity;\\n    for (let i = 0; i < grid[0].length; i++){\\n        res = Math.min(res, dp[grid.length - 1][i]);\\n    }\\n    return res;\\n};", "var minPathCost = function(grid, moveCost) {\\n\\n    const dfs=(r,c,dp)=>{\\n        if(r===grid.length || c===grid[r].length) return 0;\\n        if(dp[r][c]!==undefined) return dp[r][c];\\n\\n        "]}
{"id": "1570", "ref_js": ["var distributeCookies = function(cookies, k) {\\n    let n = cookies.length, arr = Array(k).fill(0), res = Infinity;\\n    function solve(arr, idx) {\\n        if (idx >= n) return res = Math.min(res, Math.max(...arr));\\n        let cookiesInBag = cookies[idx];\\n        for (let i = 0; i < k; i++) {\\n            arr[i] += cookiesInBag;\\n            solve(arr, idx + 1);\\n            arr[i] -= cookiesInBag;\\n        }\\n        return res;\\n    }\\n    return solve(arr, 0);\\n};", "var distributeCookies = function (cookies, k) {\\n    ", "var distributeCookies = function(cookies, k) {\\n    let n = cookies.length, arr = Array(k).fill(0), res = Infinity;\\n    function solve(arr, idx) {\\n        if (idx >= n) return res = Math.min(res, Math.max(...arr));\\n        let cookiesInBag = cookies[idx];\\n        for (let i = 0; i < k; i++) {\\n            arr[i] += cookiesInBag;\\n            solve(arr, idx + 1);\\n            arr[i] -= cookiesInBag;\\n        }\\n        return res;\\n    }\\n    return solve(arr, 0);\\n};"]}
{"id": "1571", "ref_js": ["var minimumNumbers = function(num, k) {\\n    if (num === 0) return 0;\\n    for (let i = 1; i <= 10; i++) {\\n        if (k*i % 10 === num % 10 && k*i <= num) return i;\\n        if (k*i > num) return -1\\n    } return -1;\\n};", "var minimumNumbers = function(num, k) {\\n    if (num === 0) return 0;\\n    if (k === 0) {\\n        return num % 10 ? -1 : 1;\\n    }\\n\\n    const unitsNum = num % 10;\\n    const maxCount = num / k;\\n\\n    for (let count = 1; count <= maxCount; count++) {\\n        if (count * k % 10 !== unitsNum) continue;\\n        return count;\\n    }\\n    return -1;\\n};", "var minimumNumbers = function(num, k) {\\n    if (num === 0) return 0\\n    if (num === k) return 1\\n    if (k === 0) return num % 10 !== 0 ? -1 : 1\\n    \\n    let x = Math.floor(num / k)\\n    \\n    while (x >= 0) {\\n        if ((num - 10 * x) > 0 && (num - 10 * x) % k === 0) {\\n            return (num - 10 * x) / k\\n        }\\n        x--\\n    }\\n    \\n    return -1\\n};"]}
{"id": "1572", "ref_js": ["var longestSubsequence = function(s, k) {\\n    let count = 0;\\n    let j = s.length - 1; ", "var longestSubsequence = function(s, k) {\\n\\n  const dfs=(l,r,num,dp)=>{\\n      if(dp[r]) return dp[r];\\n\\n      if(num>k) return -100000;\\n      if(l<0) return 0;\\n       \\n      const nextNum=num+parseInt(s[l])*Math.pow(2,r-l);\\n      let take=0, skip=0;\\n      if(nextNum<=k){\\n       take=1+dfs(l-1,r,nextNum,dp); ", "var longestSubsequence = function(s, k) {\\n\\n  const dfs=(l,r,num,dp)=>{\\n      if(dp[r]) return dp[r];\\n\\n      if(num>k) return -100000;\\n      if(l<0) return 0;\\n       \\n      const nextNum=num+parseInt(s[l])*Math.pow(2,r-l);\\n      let take=0, skip=0;\\n      if(nextNum<=k){\\n       take=1+dfs(l-1,r,nextNum,dp); "]}
{"id": "1573", "ref_js": ["var countPairs = function(n, edges) {\\n\\n    const arr = new Array(n).fill(-1);\\n\\n    const find = (a) => {\\n        return(arr[a] < 0) ? a : find(arr[a]);\\n    };", "var countPairs = function(n, edges) {\\n    let parent = new Array(n);\\n    let size = new Array(n);\\n    for (let i = 0; i < n; ++i) {\\n        parent[i] = i;\\n        size[i] = 1;\\n    }\\n    let numVisitedNodes = 0;\\n    let numUnreachablePairsOfNodes = 0;\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        let u = edges[i][0];\\n        let v = edges[i][1];\\n        union(u, v, parent, size);\\n    }\\n\\n    for (let node = 0; node < n; ++node) {\\n        if (parent[node] === node) {\\n            let numNodesInCurrentGroup = size[node];\\n            numUnreachablePairsOfNodes += (numNodesInCurrentGroup * numVisitedNodes);\\n            numVisitedNodes += numNodesInCurrentGroup;\\n        }\\n    }\\n    return numUnreachablePairsOfNodes;\\n};", "var countPairs = function(n, edges) {\\n    let disNode = Math.floor((n*(n-1))/2);\\n    let vis = new Set();\\n    let adl = new Map();\\n    \\n    for(let [src,tar] of edges) {\\n        if(!adl.has(src))\\n            adl.set(src, []);\\n        if(!adl.has(tar))\\n            adl.set(tar, []);\\n        adl.get(src).push(tar);\\n        adl.get(tar).push(src);\\n    }\\n\\n    for(let [key] of adl) {\\n        if(!vis.has(key)) {\\n            vis.add(key);\\n            let k = 1;\\n            let q = [key];\\n            while(q.length) {\\n                let c_node = q.shift();\\n                for(let nei of adl.get(c_node) || []) {\\n                    if(!vis.has(nei)) {\\n                        vis.add(nei);\\n                        k++;\\n                        q.push(nei);\\n                    }\\n                }\\n            }\\n            disNode -= Math.floor((k*(k-1))/2)\\n        }\\n    }\\n    return disNode;\\n};"]}
{"id": "1574", "ref_js": ["var maximumXOR = function(nums) {\\n  return nums.reduce((acc, cur) => acc |= cur, 0);\\n};", "var maximumXOR = function(nums) {\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        ans |= nums[i];\\n    }\\n    return ans;\\n};", "var maximumXOR = function(nums) {\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        ans |= nums[i];\\n    }\\n    return ans;\\n};"]}
{"id": "1575", "ref_js": ["var countHousePlacements = function(n) {\\n  const mood = BigInt(10**9+7);\\n  let last = 2n;\\n  let lastLast = 1n;\\n  let answer = last;\\n\\n  for (let ind = 2; ind <= n; ind++) {\\n    answer = (last+lastLast)% mood;\\n    lastLast = last;\\n    last = answer;\\n  }\\n  return (answer * answer) % mood;\\n};", "var countHousePlacements = function (n) {\\n    const mod = 10 ** 9 + 7;\\n    const memo = [];\\n    memo[0] = 1;\\n    memo[1] = 4;\\n    memo[2] = 9;\\n    if (n <= 2) return memo[n];\\n    for (let i = 3; i <= n; i++) {\\n        const res = ((memo[2] + memo[1]) * 2 - memo[0] + mod) % mod;\\n        memo[0] = memo[1];\\n        memo[1] = memo[2];\\n        memo[2] = res;\\n    }\\n    return memo[2];\\n};", "var countHousePlacements = function (n) {\\n    const mod = 10 ** 9 + 7;\\n    const memo = [];\\n    memo[0] = 1;\\n    memo[1] = 4;\\n    memo[2] = 9;\\n    if (n <= 2) return memo[n];\\n    for (let i = 3; i <= n; i++) {\\n        const res = ((memo[2] + memo[1]) * 2 - memo[0] + mod) % mod;\\n        memo[0] = memo[1];\\n        memo[1] = memo[2];\\n        memo[2] = res;\\n    }\\n    return memo[2];\\n};"]}
{"id": "1576", "ref_js": ["var spiralMatrix = function(m, n, head) {\\n    var matrix = new Array(m).fill().map(()=> new Array(n).fill(-1))\\n    var row=0, col=0;\\n    var direction=\"right\";\\n    while(head)\\n        {\\n            matrix[row][col]=head.val;\\n            if(direction==\"right\")\\n                {\\n                    if(col+1 == n || matrix[row][col+1] != -1)\\n                        {\\n                            direction=\"down\"\\n                            row++;\\n                        }\\n                    else\\n                        col++\\n                }\\n            else if(direction==\"down\")\\n                {\\n                    if(row+1 == m || matrix[row+1][col] != -1)\\n                        {\\n                            direction=\"left\"\\n                            col--;\\n                        }\\n                    else\\n                        row++\\n                }\\n            else if(direction==\"left\")\\n                {\\n                    if(col == 0 || matrix[row][col-1] != -1)\\n                        {\\n                            direction=\"up\"\\n                            row--;\\n                        }\\n                    else\\n                        col--\\n                }\\n            else if(direction==\"up\")\\n                {\\n                    if(row == 0 || matrix[row-1][col] != -1)\\n                        {\\n                            direction=\"right\"\\n                            col++;\\n                        }\\n                    else\\n                        row--\\n                }\\n            head = head.next;\\n        }\\n    return matrix;\\n};", "var spiralMatrix = function(m, n, head) {\\n    let matrix = []\\n    for (let i = 0; i < m; i++) {\\n        let arr = [];\\n        for (let j = 0; j < n; j++) arr.push(-1)\\n        matrix.push(arr)\\n    }\\n    let list = []\\n    let li = head\\n    while (li != null) {\\n        list.push(li.val)\\n        li = li.next;\\n    }\\n    let index = 0\\n    let rowBoundaries = 0\\n    let colBoundaries = 0\\n    let row = 0\\n    let col = -1\\n    while (true) {\\n        while (col<matrix[0].length-colBoundaries-1 && index<list.length) {\\n            col++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (row<matrix.length-rowBoundaries-1 && index<list.length) {\\n            row++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (col>colBoundaries && index<list.length) {\\n            col--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        rowBoundaries++\\n        colBoundaries++\\n        while (row>rowBoundaries && index<list.length) {\\n            row--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        if (index>=list.length) break\\n    }\\n    return matrix\\n};", "var spiralMatrix = function (m, n, head) {\\n    let result = matrix(m, n);\\n    let minRow = 0;\\n    let maxRow = m - 1;\\n    let minCol = 0;\\n    let maxCol = n - 1;\\n    let cur = head;\\n\\n    while (cur !== null) {\\n        "]}
{"id": "1577", "ref_js": ["var peopleAwareOfSecret = function(n, delay, forget) {\\n  \\n  const MOD = 10**9+7;\\n  \\n  let count = new Array(n).fill(0);\\n  count[0] = 1;\\n  \\n  for (let i = 1; i < n; i += 1) {\\n    \\n    if (i - forget >= 0) {\\n      for (let j = i; j >= (i - forget); j -= 1) {\\n        count[j] = (count[j] - count[i - forget]) % MOD;\\n      }\\n    } \\n    \\n    if (i - delay >= 0) {\\n      count[i] = (count[i - 1] + count[i - delay]) % MOD;\\n    } else {\\n      count[i] = (count[i - 1]) % MOD;\\n    }\\n  }\\n  \\n  return count[n - 1];\\n};", "var peopleAwareOfSecret = function(n, delay, forget) {\\n    let day = 1;\\n    let map = new Map(); ", "var peopleAwareOfSecret = function(n, delay, forget) {\\n  \\n  const MOD = 10**9+7;\\n  \\n  let count = new Array(n).fill(0);\\n  count[0] = 1;\\n  \\n  for (let i = 1; i < n; i += 1) {\\n    \\n    if (i - forget >= 0) {\\n      for (let j = i; j >= (i - forget); j -= 1) {\\n        count[j] = (count[j] - count[i - forget]) % MOD;\\n      }\\n    } \\n    \\n    if (i - delay >= 0) {\\n      count[i] = (count[i - 1] + count[i - delay]) % MOD;\\n    } else {\\n      count[i] = (count[i - 1]) % MOD;\\n    }\\n  }\\n  \\n  return count[n - 1];\\n};"]}
{"id": "1578", "ref_js": ["var latestTimeCatchTheBus = function(buses, passengers, capacity) {\\n    buses.sort((a, b) => a - b);\\n    passengers.sort((a, b) => a - b);\\n\\n    let i = 0;\\n    let c;\\n\\n    for (let bTime of buses) {\\n        c = 0;\\n\\n        while(i < passengers.length && passengers[i] <= bTime && c < capacity) {\\n            c++, i++;\\n        }\\n    }\\n\\n    let latest = c !== capacity ? buses[buses.length-1] : passengers[i-1];\\n    const passengerSet = new Set(passengers);\\n\\n    while (passengerSet.has(latest)) {\\n        latest--;\\n    }\\n\\n    return latest;\\n};", "var latestTimeCatchTheBus = function(buses, passengers, capacity) {\\n    buses.sort((a, b) => a - b);\\n    passengers.sort((a, b) => a - b);\\n    ", "var latestTimeCatchTheBus = function (buses, passengers, capacity) {\\n  buses.sort((a, b) => a - b);\\n  passengers.sort((a, b) => a - b);\\n\\n  let pass_index = 0;\\n\\n  for (let bus_index = 0; bus_index < buses.length; bus_index++) {\\n    const bus = buses[bus_index];\\n    let bus_load = 0;\\n\\n    while (pass_index < passengers.length) {\\n      const pass = passengers[pass_index];\\n\\n      if ((pass <= bus) & (bus_load < capacity)) {\\n        bus_load++;\\n        pass_index++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    if (bus_index == buses.length - 1) {\\n      let latest_arrival_time = 0;\\n\\n      if (pass_index == 0) {\\n        return buses[bus_index];\\n      } else {\\n        "]}
{"id": "1579", "ref_js": ["var minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    const len = nums1.length;\\n    const diff = new Array(len).fill(0);\\n    for(let i = 0; i < len; i++) {\\n        diff[i] = Math.abs(nums1[i] - nums2[i]);\\n    }\\n    diff.sort((a, b) => b - a);\\n    const bucket = new Array(diff[0] + 1).fill(0);\\n    let tk = k1 + k2;\\n    for(let i of diff) {\\n        bucket[i]++;\\n    }\\n    for(let i = bucket.length - 1; tk > 0 && i >= 0; i--) {\\n        if(bucket[i] == 0) continue; \\n        const reduce = Math.min(bucket[i], tk);\\n        bucket[i] -= reduce;\\n        bucket[i-1] += reduce;\\n        tk -= reduce;\\n    }\\n    let ans = 0;\\n    for(let i = bucket.length - 1; i >= 1; i--) {\\n        ans += bucket[i] * i * i;\\n    }\\n    return ans;\\n};", "var minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    let n = nums1.length;\\n    let map = new Map();\\n    let total = 0;\\n    for(let i=0;i<n;i++) {\\n        let c = Math.abs(nums1[i]-nums2[i]);\\n        if(c==0)\\n            continue;\\n        total += c;\\n        if(map.has(c)) {\\n            let val = map.get(c)\\n            map.set(c,val+1);\\n        } else {\\n            map.set(c,1)\\n        }\\n    }\\n    let map2 = Array.from(map);\\n    map2.sort((a,b)=>a[0]-b[0]);\\n    let t = k1+k2;\\n    if(total<=t){\\n        return 0;\\n    }\\n    let lm = map2.length-1;\\n    let finalans  = 0;\\n    while(t>0 && map2.length>0)\\n    {\\n        let [val,count] = map2.pop();\\n        lm--;\\n        if(t>=count) {\\n            \\n            if(lm>=0 && map2[lm][0] + 1 == val) {\\n                map2[lm][1] += count\\n            } else if(val>1){\\n                map2.push([val-1,count])\\n                lm++;\\n            }\\n            t -= count;\\n        } else {\\n           finalans += (count-t)*(Math.pow(val,2)) + t*(Math.pow(val-1,2));\\n           t=0;\\n        }\\n    }\\n    for(let i=0;i<map2.length;i++) {\\n        let [val,count] = map2[i];\\n        finalans += count * Math.pow(val,2)\\n    }\\n    return finalans\\n};", "var minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    let res = 0;\\n    "]}
{"id": "1581", "ref_js": ["var canChange = function (start, target) {\\n\\t\\tlet lCount = 0;", "var canChange = function(start, target) {\\n    let i = 0\\n    let j = 0\\n    const len = start.length\\n    \\n    while(i <= len && j <= len) {\\n        while(i < len  && start[i] === \\'_\\') i++\\n        while(j < len && target[j] === \\'_\\') j++\\n        \\n        if(i === len && j === len) return true\\n        if(i === len || j === len) return false\\n        \\n        if(start[i] !== target[j]) return false\\n        if(start[i] === \\'L\\' && j > i) return false\\n        if(start[i] === \\'R\\' && j < i) return false\\n        i++\\n        j++\\n    }\\n    \\n    return false\\n};", "var canChange = function (start, target) {\\n    let l = 0\\n    let r = 0\\n\\n    for (let i = 0; i < start.length; i++) {\\n        if (start[i] === \"R\") r++\\n        if (start[i] === \"L\") l--\\n\\n        \\n        if (target[i] === \"L\" && r > 0) return false\\n        if (start[i] === \"L\" && r > 0) return false\\n\\n        if (target[i] === \"L\") l++\\n        if (target[i] === \"R\") r--\\n\\n        if (l < 0 || r < 0) return false\\n    }\\n\\n    \\n    return !l && !r\\n\\n};"]}
{"id": "1582", "ref_js": ["var imageSmoother = function(img) {\\n    const m = img.length;\\n    const n = img[0].length;\\n    const res = new Array(m).fill(0).map(() => new Array(n).fill(0));\\n\\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            res[i][j] = smoothen(img, i, j);\\n        }\\n    }\\n\\n    return res;\\n};", "var imageSmoother = function(img) {\\n    const rows = img.length;\\n    const cols = img[0].length;\\n    const result = new Array(rows);\\n\\n    for (let i = 0; i < rows; ++i) {\\n        result[i] = new Array(cols);\\n\\n        for (let j = 0; j < cols; ++j) {\\n            let totalSum = 0;\\n            let count = 0;\\n\\n            for (let x = Math.max(0, i - 1); x < Math.min(rows, i + 2); ++x) {\\n                for (let y = Math.max(0, j - 1); y < Math.min(cols, j + 2); ++y) {\\n                    totalSum += img[x][y];\\n                    count += 1;\\n                }\\n            }\\n\\n            result[i][j] = Math.floor(totalSum / count);\\n        }\\n    }\\n\\n    return result;\\n};", "var imageSmoother = function(img) {\\n    const rows = img.length;\\n    const cols = img[0].length;\\n\\n    "]}
{"id": "1583", "ref_js": ["var smallestTrimmedNumbers = function(nums, queries) {\\n  let n = nums[0].length;\\n  nums = nums.map((num, i) => [BigInt(num), i]);\\n  let trimmed = Array.from(Array(n + 1), () => []);\\n  for (let trim = n; trim >= 1; trim--) {\\n    for (let [num, i] of nums)\\n      trimmed[trim].push([num % (BigInt(10) ** BigInt(trim)), i]);\\n    trimmed[trim].sort((a,b) => a[0] === b[0] ? a[1] - b[1] : Number(a[0] - b[0]));\\n  }\\n  \\n  return queries.map(([k, trim]) => trimmed[trim][k - 1][1]);\\n};", "var smallestTrimmedNumbers = function(nums, queries) {\\n  let n = nums[0].length;\\n  nums = nums.map((num, i) => [BigInt(num), i]);\\n  let trimmed = Array.from(Array(n + 1), () => []);\\n  for (let trim = n; trim >= 1; trim--) {\\n    for (let [num, i] of nums)\\n      trimmed[trim].push([num % (BigInt(10) ** BigInt(trim)), i]);\\n    trimmed[trim].sort((a,b) => a[0] === b[0] ? a[1] - b[1] : Number(a[0] - b[0]));\\n  }\\n  \\n  return queries.map(([k, trim]) => trimmed[trim][k - 1][1]);\\n};", "var smallestTrimmedNumbers = function(nums, queries) {\\n  let n = nums[0].length;\\n  nums = nums.map((num, i) => [BigInt(num), i]);\\n  let trimmed = Array.from(Array(n + 1), () => []);\\n  for (let trim = n; trim >= 1; trim--) {\\n    for (let [num, i] of nums)\\n      trimmed[trim].push([num % (BigInt(10) ** BigInt(trim)), i]);\\n    trimmed[trim].sort((a,b) => a[0] === b[0] ? a[1] - b[1] : Number(a[0] - b[0]));\\n  }\\n  \\n  return queries.map(([k, trim]) => trimmed[trim][k - 1][1]);\\n};"]}
{"id": "1584", "ref_js": ["var zeroFilledSubarray = function(nums) {\\n    var res = 0, count = 0;\\n    for(let el of nums)\\n        if(el == 0) {\\n            count++;\\n            res += count;\\n        }\\n        else\\n            count = 0;\\n    return res;\\n};", "var zeroFilledSubarray = function(nums) {\\n\\tlet out = 0;\\n\\tlet tempOut = 0;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (nums[index] === 0) {\\n\\t\\t\\ttempOut++;\\n\\t\\t} else {\\n\\t\\t\\tif (tempOut) {\\n\\t\\t\\t\\tconst n = tempOut * (tempOut + 1) / 2;\\n\\t\\t\\t\\tout += n;\\n\\t\\t\\t}\\n\\t\\t\\ttempOut = 0;\\n\\t\\t}\\n\\t}\\n\\tif (tempOut) {\\n\\t\\tconst n = tempOut * (tempOut + 1) / 2;\\n\\t\\tout += n;\\n\\t}\\n\\treturn out;\\n};", "var zeroFilledSubarray = function(nums) {\\n\\tlet out = 0;\\n\\tlet tempOut = 0;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (nums[index] === 0) {\\n\\t\\t\\ttempOut++;\\n\\t\\t} else {\\n\\t\\t\\tif (tempOut) {\\n\\t\\t\\t\\tconst n = tempOut * (tempOut + 1) / 2;\\n\\t\\t\\t\\tout += n;\\n\\t\\t\\t}\\n\\t\\t\\ttempOut = 0;\\n\\t\\t}\\n\\t}\\n\\tif (tempOut) {\\n\\t\\tconst n = tempOut * (tempOut + 1) / 2;\\n\\t\\tout += n;\\n\\t}\\n\\treturn out;\\n};"]}
{"id": "1586", "ref_js": ["var equalPairs = function(grid) {\\n        if(grid[0].length!==grid.length) return 0;\\n    \\n    let rows = {};", "var equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};", "var equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};"]}
{"id": "1588", "ref_js": ["var maximumGroups = function(grades) {\\n    var count=1, length=grades.length;\\n    while(length-count > count) length-=count++;\\n    return count;\\n};", "var maximumGroups = function(grades) {\\n    let c = grades.length*2;\\n    return Math.floor((-1+Math.sqrt(1+4*c))/2)\\n};", "var maximumGroups = function(grades) {\\n    let n =  grades.length;\\n    let res = 0;\\n    let f = 1;\\n    while(n>0){\\n        if(n-f<=f){\\n            break;\\n        }\\n        n = n-f;\\n        f++;\\n    }\\n    return f;\\n};"]}
{"id": "1589", "ref_js": ["var closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};", "var closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};", "var closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};"]}
{"id": "1590", "ref_js": ["var countBadPairs = function(nums) {\\n    let totalPairs = 0\\n    let goodPairs = 0\\n    let differencesFreqsMap = {}\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const diff = nums[i] - i\\n        \\n        totalPairs+=i\\n        \\n        if(diff in differencesFreqsMap) {\\n            goodPairs+= differencesFreqsMap[diff]\\n            differencesFreqsMap[diff]++\\n            continue\\n        }\\n        \\n        differencesFreqsMap[diff] = 1\\n    }\\n    \\n    return totalPairs - goodPairs\\n};", "var countBadPairs = function(nums) {\\n    if (nums.length <= 1) {\\n        return 0;\\n    }\\n\\n    let count = 0;\\n    const diffCount = {};", "var countBadPairs = function(nums) {\\n    const n = nums.length;\\n    const buckets = new Map();\\n\\n    nums.forEach((e, i) => {\\n        if(!buckets.has(e - i)) buckets.set(e - i, 0);\\n        buckets.set(e - i, buckets.get(e - i) + 1);\\n    })\\n\\n    return n*(n - 1) / 2 - [...buckets.values()].reduce((acc, b) => acc + b*(b-1)/2, 0);\\n};"]}
{"id": "1591", "ref_js": ["var taskSchedulerII = function(tasks, space) {\\n    var days = 0;\\n    var map = new Map();\\n    for (var task of tasks) {\\n        if (map.has(task) && map.get(task) > days) days = map.get(task);\\n        map.set(task, ++days+space);\\n    }  \\n    return days;\\n};", "var taskSchedulerII = function (taskTypes, waitTime) {\\n  let prevTime = {};", "var taskSchedulerII = function(tasks, space) {\\n    var days = 0;\\n    var map = new Map();\\n    for (var task of tasks) {\\n        if (map.has(task) && map.get(task) > days) days = map.get(task);\\n        map.set(task, ++days+space);\\n    }  \\n    return days;\\n};"]}
{"id": "1592", "ref_js": ["var reachableNodes = function (n, edges, restricted) {\\n    const restrictedConfig = (function () {\\n        const config = {};", "var reachableNodes = function(n, edges, restricted) {\\n    const adj = {};", "var reachableNodes = function (n, edges, restricted) {\\n    const restrictedConfig = (function () {\\n        const config = {};"]}
{"id": "1593", "ref_js": ["var validPartition = function(nums) {\\n    const n = nums.length;\\n    const isValidTypeA = (i) => nums[i] === nums[i + 1];\\n    const isValidTypeB = (i) => nums[i] === nums[i + 1] && nums[i] === nums[i + 2];\\n    const isValidTypeC = (i) => nums[i] + 1 === nums[i + 1] && nums[i] + 2 === nums[i + 2];\\n    let isSecondLastValid = isValidTypeA(n - 2);\\n    if (n === 2) return isSecondLastValid;\\n    let isThirdLastValid =  isValidTypeB(n - 3) || isValidTypeC(n - 3);\\n    if (n === 3) return isThirdLastValid;\\n    let memo = [isThirdLastValid, isSecondLastValid, false];\\n    for (let i = n - 4; i >= 0 ; i--) {\\n        let res = isValidTypeA(i) && memo[1];\\n        res = res || (isValidTypeB(i) || isValidTypeC(i)) && memo[2];\\n        memo = [res, memo[0], memo[1]];\\n    }\\n    return memo[0];\\n};", "var validPartition = function(nums) {\\n    let n = nums.length;\\n\\n    if (n === 1) return false;\\n\\n    let dp = [true, false, n > 1 && nums[0] === nums[1]];\\n\\n    for (let i = 2; i < n; i++) {\\n        let current_dp = false;\\n\\n        if (nums[i] === nums[i-1] && dp[1]) {\\n            current_dp = true;\\n        }\\n        else if (nums[i] === nums[i-1] && nums[i] === nums[i-2] && dp[0]) {\\n            current_dp = true;\\n        }\\n        else if (nums[i] - nums[i-1] === 1 && nums[i-1] - nums[i-2] === 1 && dp[0]) {\\n            current_dp = true;\\n        }\\n\\n        [dp[0], dp[1], dp[2]] = [dp[1], dp[2], current_dp];\\n    }\\n\\n    return dp[2];\\n};", "var validPartition = function(nums, memo = {}, start = 0) {\\n    if (start >= nums.length) return true;\\n    if (start in memo) return memo[start];\\n\\n    let isTwoEqual = nums[start] === nums[start + 1];\\n\\n    let isThreeEqual = nums[start] === nums[start + 1] && \\n                       nums[start] === nums[start + 2];\\n    \\n    let isIncreasing = nums[start] + 1 === nums[start + 1] && \\n                       nums[start + 1] + 1 === nums[start + 2];\\n\\n\\n\\n    let isValid = false;\\n\\n    if (isIncreasing) {\\n        isValid =  validPartition(nums, memo, start + 3);\\n    } else if (isThreeEqual) {\\n        isValid =  validPartition(nums, memo, start + 2) || \\n                   validPartition(nums, memo, start + 3);\\n    } else if (isTwoEqual)\\n        isValid =  validPartition(nums, memo, start + 2)\\n    \\n       \\n    memo[start] = isValid;\\n    return isValid;\\n};"]}
{"id": "1594", "ref_js": ["var longestIdealString = function(s, k) {\\n    arr = new Array(26).fill(0)\\n\\n    for (let i = 0; i < s.length; i++) { \\n        char_code = s.charCodeAt(i) - 97       \\n        subarray = arr.slice(Math.max(char_code - k, 0), Math.min(char_code + k + 1, 26))\\n        count = Math.max(...subarray), count ++        \\n        arr[char_code] = count\\n    }\\n    \\n    return Math.max(...arr)\\n};", "var longestIdealString = function(s, k) {\\n    let n = s.length\\n    let dp = Array(26).fill(0);\\n    let ans = 0;\\n    for(let i=0; i<n; i++){\\n        const cur = s.charCodeAt(i)-97;\\n        dp[cur] += 1;\\n        for(let j=Math.max(0, cur-k); j<=Math.min(cur+k, 25); j++){\\n            if(j !== cur){\\n                dp[cur] = Math.max(dp[cur], dp[j]+1);   \\n            }\\n        }\\n        ans = Math.max(dp[cur], ans)\\n    }\\n    return ans;\\n};", "var longestIdealString = function(s, k) {\\n    let n = s.length\\n    let dp = Array(26).fill(0);\\n    let ans = 0;\\n    for(let i=0; i<n; i++){\\n        const cur = s.charCodeAt(i)-97;\\n        dp[cur] += 1;\\n        for(let j=Math.max(0, cur-k); j<=Math.min(cur+k, 25); j++){\\n            if(j !== cur){\\n                dp[cur] = Math.max(dp[cur], dp[j]+1);   \\n            }\\n        }\\n        ans = Math.max(dp[cur], ans)\\n    }\\n    return ans;\\n};"]}
{"id": "1595", "ref_js": ["var edgeScore = function (edges) {\\n    let maxSum = -Infinity;\\n    const outputConfig = {};", "var edgeScore = function(edges) {\\n    let score = Array(edges.length).fill(0)\\n    let maxScore = 0 , resIndex = 0\\n    for( i = 0 ; i < edges.length ; i++ )\\n        score[edges[i]] += i;\\n    for( i = 0 ; i < edges.length ; i++ )\\n        if( score[i] > maxScore ){\\n            maxScore = score[i]\\n            resIndex = i\\n        }\\n    return resIndex\\n};", "var edgeScore = function(edges) {\\n    const edgeScore = Array(edges.length).fill(0);\\n    for(let node=0; node<edges.length; node++) {\\n        edgeScore[edges[node]] += node\\n    }\\n    let res;\\n    let maxScore = -1;\\n    for(let node=0; node<edges.length; node++) {\\n        if(edgeScore[node] > maxScore) {\\n            maxScore = edgeScore[node];\\n            res = node;\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "1596", "ref_js": ["var smallestNumber = function(pattern) {\\n   pattern+=\"I\";\\n  \\n    let num=Array(pattern.length).fill(\"\");\\n    let counter=1;\\n    let ans=\"\";\\n  \\n    for(let i=0;i<pattern.length;i++){\\n        if(pattern[i]==\"I\"){\\n             num[i]=counter++;\\n            let prev=i-1;\\n            while(prev>=0 && pattern[prev]==\"D\"){\\n                num[prev]=counter++;\\n                prev--;\\n            }\\n           \\n        }\\n        \\n    }\\n\\n    for(let i=0;i<pattern.length;i++){\\n        ans+=num[i];\\n    }\\n    \\n    return ans;\\n    \\n};", "var smallestNumber = function(pattern) {\\n    const ans = [];\\n    let stack = [];\\n    \\n    for (let i = 0; i <= pattern.length; i++) {\\n        stack.push(i + 1);\\n        if (pattern[i] === \\'I\\' || i === pattern.length) {\\n            ans.push(...stack.reverse());\\n            stack = [];\\n        }\\n    }\\n    \\n    return ans.join(\\'\\');\\n};", "var smallestNumber = function(pattern) {\\n   pattern+=\"I\";\\n  \\n    let num=Array(pattern.length).fill(\"\");\\n    let counter=1;\\n    let ans=\"\";\\n  \\n    for(let i=0;i<pattern.length;i++){\\n        if(pattern[i]==\"I\"){\\n             num[i]=counter++;\\n            let prev=i-1;\\n            while(prev>=0 && pattern[prev]==\"D\"){\\n                num[prev]=counter++;\\n                prev--;\\n            }\\n           \\n        }\\n        \\n    }\\n\\n    for(let i=0;i<pattern.length;i++){\\n        ans+=num[i];\\n    }\\n    \\n    return ans;\\n    \\n};"]}
{"id": "1597", "ref_js": ["var secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};", "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};", "var secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};"]}
{"id": "1598", "ref_js": ["var shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};", "var shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};", "var shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};"]}
{"id": "1599", "ref_js": ["var largestPalindromic = function (num) {\\n    let nos = new Array(10).fill(0);\\n    for (let n of num) {\\n        nos[+n] += 1;\\n    }\\n    let number = \"\";\\n    for (let i = 9; i >= 0; --i) {\\n        if (number === \"\" && i === 0) continue\\n        let count = nos[i];\\n        if (count > 1) {\\n            let times = Math.floor(count / 2);\\n            number += String(i).repeat(times);\\n            nos[i] = nos[i] % 2;\\n        }\\n    }\\n\\n    let finalNum = number;\\n    for (let i = 9; i >= 0; --i) {\\n        let count = nos[i];\\n        if (count >= 1) {\\n            finalNum += String(i);\\n            break;\\n        }\\n    }\\n\\n    finalNum = finalNum + number.split(\"\").reverse().join(\"\");\\n    return finalNum;\\n\\n};", "var largestPalindromic = function (num) {\\n    let nos = new Array(10).fill(0);\\n    for (let n of num) {\\n        nos[+n] += 1;\\n    }\\n    let number = \"\";\\n    for (let i = 9; i >= 0; --i) {\\n        if (number === \"\" && i === 0) continue\\n        let count = nos[i];\\n        if (count > 1) {\\n            let times = Math.floor(count / 2);\\n            number += String(i).repeat(times);\\n            nos[i] = nos[i] % 2;\\n        }\\n    }\\n\\n    let finalNum = number;\\n    for (let i = 9; i >= 0; --i) {\\n        let count = nos[i];\\n        if (count >= 1) {\\n            finalNum += String(i);\\n            break;\\n        }\\n    }\\n\\n    finalNum = finalNum + number.split(\"\").reverse().join(\"\");\\n    return finalNum;\\n\\n};", "var largestPalindromic = function (num) {\\n    let nos = new Array(10).fill(0);\\n    for (let n of num) {\\n        nos[+n] += 1;\\n    }\\n    let number = \"\";\\n    for (let i = 9; i >= 0; --i) {\\n        if (number === \"\" && i === 0) continue\\n        let count = nos[i];\\n        if (count > 1) {\\n            let times = Math.floor(count / 2);\\n            number += String(i).repeat(times);\\n            nos[i] = nos[i] % 2;\\n        }\\n    }\\n\\n    let finalNum = number;\\n    for (let i = 9; i >= 0; --i) {\\n        let count = nos[i];\\n        if (count >= 1) {\\n            finalNum += String(i);\\n            break;\\n        }\\n    }\\n\\n    finalNum = finalNum + number.split(\"\").reverse().join(\"\");\\n    return finalNum;\\n\\n};"]}
{"id": "1600", "ref_js": ["var amountOfTime = function(root, start) {\\n    ", "var amountOfTime = function(root, start) {\\n  let parent = new Map(), startNode = null;\\n  getParent(root);\\n  let seen = new Set([startNode.val]), queue = [startNode], time = 0;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i--) {\\n      let node = queue.shift();\\n      \\n      if (parent.has(node.val)) {\\n        let nodeParent = parent.get(node.val);\\n        if (!seen.has(nodeParent.val)) {\\n          queue.push(nodeParent);\\n          seen.add(nodeParent.val);\\n        }\\n      }\\n      if (node.left && !seen.has(node.left.val)) {\\n        queue.push(node.left);\\n        seen.add(node.left.val);\\n      }\\n      if (node.right && !seen.has(node.right.val)) {\\n        queue.push(node.right);\\n        seen.add(node.right.val);\\n      }\\n    }\\n    time++;\\n  }\\n  return time - 1;\\n  \\n  function getParent(node) {\\n    if (node.val === start) startNode = node;\\n    if (node.left) { ", "var amountOfTime = function(root, start) {\\n  let parent = new Map(), startNode = null;\\n  getParent(root);\\n  let seen = new Set([startNode.val]), queue = [startNode], time = 0;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i--) {\\n      let node = queue.shift();\\n      \\n      if (parent.has(node.val)) {\\n        let nodeParent = parent.get(node.val);\\n        if (!seen.has(nodeParent.val)) {\\n          queue.push(nodeParent);\\n          seen.add(nodeParent.val);\\n        }\\n      }\\n      if (node.left && !seen.has(node.left.val)) {\\n        queue.push(node.left);\\n        seen.add(node.left.val);\\n      }\\n      if (node.right && !seen.has(node.right.val)) {\\n        queue.push(node.right);\\n        seen.add(node.right.val);\\n      }\\n    }\\n    time++;\\n  }\\n  return time - 1;\\n  \\n  function getParent(node) {\\n    if (node.val === start) startNode = node;\\n    if (node.left) { "]}
{"id": "1601", "ref_js": ["var removeStars = function(s) {\\n    let f = 0;\\n    let res = \\'\\'\\n    for(let i = s.length-1;i>-1;i--){\\n        if(s[i]===\\'*\\'){\\n            f++\\n        }else if(f){\\n            f--\\n        }else{\\n            res+=s[i]\\n        }\\n    }\\n    return [...res].reverse().join(\\'\\')\\n};", "var removeStars = function(s) {\\n    const stack = [];\\n\\n    ", "var removeStars = function(s) {\\nlet i = 0;\\n    let stk = [];\\n     while(i<s.length){\\n         if(s.charAt(i)===\"*\"){\\n            if(stk.length>0){\\n                stk.pop();\\n            }\\n         }\\n         else {\\n             stk.push(s.charAt(i))\\n         }\\n         i++;\\n     }\\n    return stk.join(\"\");\\n};"]}
{"id": "1602", "ref_js": ["var garbageCollection = function(garbage, travel) {\\n        let res = 0;\\n\\n        for (const g of garbage) {\\n            res += g.length;\\n        }\\n\\n        let [m, p, g] = [false, false, false];\\n\\n        for (let i = travel.length; i > 0; i--) {\\n            m = m || garbage[i].includes(\\'M\\');\\n            p = p || garbage[i].includes(\\'P\\');\\n            g = g || garbage[i].includes(\\'G\\');\\n\\n            res += travel[i - 1] * (m + p + g);\\n        }\\n\\n        return res;    \\n};", "var garbageCollection = function(garbage, travel) {\\n        let res = 0;\\n\\n        for (const g of garbage) {\\n            res += g.length;\\n        }\\n\\n        let [m, p, g] = [false, false, false];\\n\\n        for (let i = travel.length; i > 0; i--) {\\n            m = m || garbage[i].includes(\\'M\\');\\n            p = p || garbage[i].includes(\\'P\\');\\n            g = g || garbage[i].includes(\\'G\\');\\n\\n            res += travel[i - 1] * (m + p + g);\\n        }\\n\\n        return res;    \\n};", "var garbageCollection = function(garbage, travel) {\\n        let res = 0;\\n\\n        for (const g of garbage) {\\n            res += g.length;\\n        }\\n\\n        let [m, p, g] = [false, false, false];\\n\\n        for (let i = travel.length; i > 0; i--) {\\n            m = m || garbage[i].includes(\\'M\\');\\n            p = p || garbage[i].includes(\\'P\\');\\n            g = g || garbage[i].includes(\\'G\\');\\n\\n            res += travel[i - 1] * (m + p + g);\\n        }\\n\\n        return res;    \\n};"]}
{"id": "1603", "ref_js": ["var isStrictlyPalindromic = function(n) {\\n    return false;\\n};", "var isStrictlyPalindromic = function(n) { return false };", "var isStrictlyPalindromic = function(n) {\\n    return false;\\n};"]}
{"id": "1604", "ref_js": ["var maximumRows = function(mat, cols) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    let min = 0; ", "var maximumRows = function (g, maxselect) {\\n  const n = g[0].length;\\n  let nums = g.map((r) => bitArrayToDecimal(r));\\n  let max = 0;\\n  for (let i = allNBitsSet(maxselect); i < 2 ** n; i++) {\\n    if (numOfOneBits(i) === maxselect) {\\n      let numsWithIBitmaskSet = nums.filter((n) => (n & i) === n);\\n      max = Math.max(max, numsWithIBitmaskSet.length);\\n    }\\n  }\\n  return max;\\n};", "var maximumRows = function(matrix, numSelect) {\\n  let m = matrix.length, n = matrix[0].length, ones = Array(m).fill(0).map(() => []);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (matrix[i][j] === 1) {\\n        ones[i].push(j); "]}
{"id": "1605", "ref_js": ["var numberOfWays = function(startPos, endPos, k) {\\n    const dp = new Map();\\n    return solve(startPos, endPos, k, dp, k);\\n};", "var numberOfWays = function(startPos, endPos, k) {\\n    const dp = new Map();\\n    return solve(startPos, endPos, k, dp);\\n};", "var numberOfWays = function(startPos, endPos, k) {\\n    const dp = new Map();\\n    return solve(startPos, endPos, k, dp);\\n};"]}
{"id": "1606", "ref_js": ["var longestNiceSubarray = function(nums) {\\n    let count = 0, startidx = 0, val = 0\\n    for(let i=0; i<nums.length; i++){\\n        while((val & nums[i]) != 0){\\n            val ^= nums[startidx++]\\n        }\\n        val |= nums[i]\\n        count = Math.max(count, i - startidx + 1)\\n    }\\n    return count\\n};", "var longestNiceSubarray = function(nums) {\\n    let mask=0,j=0,maxWindow=0;\\n    for(let i=0;i<nums.length;i++){\\n        while((mask & nums[i])!==0){", "var longestNiceSubarray = function(nums) {\\n    let count = 0, startidx = 0, val = 0\\n    for(let i=0; i<nums.length; i++){\\n        while((val & nums[i]) != 0){\\n            val ^= nums[startidx++]\\n        }\\n        val |= nums[i]\\n        count = Math.max(count, i - startidx + 1)\\n    }\\n    return count\\n};"]}
{"id": "1607", "ref_js": ["var partitionString = function(s) {\\n    let ans = 1;\\n    let marker = 0;\\n    let counts = {};", "var partitionString = function(s) {\\n    \\n\\n    ", "var partitionString = function(s) {\\n    let ans = 1;\\n    let marker = 0;\\n    let counts = {};"]}
{"id": "1608", "ref_js": ["var minGroups = function(intervals) {\\n     const starts = intervals.map((el) => el[0]).sort((a, b) => a - b);\\n     const ends = intervals.map((el) => el[1]).sort((a, b) => a - b);\\n      let room = 0;\\n      let endIdx = 0;\\n      for (i = 0; i < starts.length; i++) {\\n        if (starts[i] <= ends[endIdx]) {\\n          room++;\\n        } else {\\n          endIdx++;\\n      }\\n     }\\n     return room;\\n};", "var minGroups = function(intervals) {\\n    let arr = new Array(1000001);\\n    arr.fill(0);\\n    \\n\\t", "var minGroups = function(intervals) {\\n     const starts = intervals.map((el) => el[0]).sort((a, b) => a - b);\\n     const ends = intervals.map((el) => el[1]).sort((a, b) => a - b);\\n      let room = 0;\\n      let endIdx = 0;\\n      for (i = 0; i < starts.length; i++) {\\n        if (starts[i] <= ends[endIdx]) {\\n          room++;\\n        } else {\\n          endIdx++;\\n      }\\n     }\\n     return room;\\n};"]}
{"id": "1609", "ref_js": ["var matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n    \\n    let i = 0;\\n    for (let j = 0; j < trainers.length; j++) {\\n        if (players[i] <= trainers[j]) {\\n            i++;\\n        }\\n    }\\n    \\n    return i;\\n};", "var matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a,b) => a-b);\\n    trainers.sort((a,b) => a-b);\\n    let j = 0, matches = 0;\\n    for(let i=0; i<trainers.length && j < players.length; i++){\\n        if(players[j] <= trainers[i]){\\n            j++;\\n            matches++;\\n        }\\n    }\\n    return matches;\\n};", "var matchPlayersAndTrainers = function(players, trainers) {\\n  let max_macthes = 0;\\n\\n  players.sort((a, b) => a - b);\\n  trainers.sort((a, b) => a - b);\\n\\n  if (players[0] > trainers[trainers.length - 1]){\\n    return 0;\\n  }\\n\\n  let i = 0;\\n  let j = 0;\\n\\n  while (i < players.length && j < trainers.length) {\\n    if (players[i] <= trainers[j]) {\\n      i++;\\n      j++;\\n      max_macthes++;\\n    } else {\\n      j++;\\n    }\\n  }\\n\\n  return max_macthes;\\n};"]}
{"id": "1610", "ref_js": ["var smallestSubarrays = function(nums) {\\n    const nearest = Array(32).fill(0);\\n    const retval = [];\\n    \\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let farthestBit = i;\\n        \\n        for (let j = 0; j < 32; ++j) {\\n            if (nums[i] & (1 << j))\\n                nearest[j] = i;\\n            else if (nearest[j] > farthestBit)\\n                farthestBit = nearest[j];\\n        }\\n        \\n        retval.push(farthestBit - i + 1);\\n    }\\n    \\n    return retval.reverse();\\n};", "var smallestSubarrays = function(nums) {\\n    const nearest = Array(32).fill(0);\\n    const retval = [];\\n    \\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let farthestBit = i;\\n        \\n        for (let j = 0; j < 32; ++j) {\\n            if (nums[i] & (1 << j))\\n                nearest[j] = i;\\n            else if (nearest[j] > farthestBit)\\n                farthestBit = nearest[j];\\n        }\\n        \\n        retval.push(farthestBit - i + 1);\\n    }\\n    \\n    return retval.reverse();\\n};", "var smallestSubarrays = function(nums) {\\n    const nearest = Array(32).fill(0);\\n    const retval = [];\\n    \\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let farthestBit = i;\\n        \\n        for (let j = 0; j < 32; ++j) {\\n            if (nums[i] & (1 << j))\\n                nearest[j] = i;\\n            else if (nearest[j] > farthestBit)\\n                farthestBit = nearest[j];\\n        }\\n        \\n        retval.push(farthestBit - i + 1);\\n    }\\n    \\n    return retval.reverse();\\n};"]}
{"id": "1611", "ref_js": ["var longestContinuousSubstring = function(s) {\\n    let max_len = 1\\n    for(let i=1; i<s.length; i++){\\n        let count = 1\\n        while(i < s.length && s.charCodeAt(i-1) + 1 == s.charCodeAt(i)){\\n            count++\\n            i++;\\n        }\\n        max_len = Math.max(max_len, count)\\n    }     \\n    return max_len\\n};", "var longestContinuousSubstring = function(s) {\\n    let longest = 1;\\n    let currentCount = 1;\\n    \\n    for (let i = 1; i < s.length; i++){\\n        let currentCh = s[i].charCodeAt(0);\\n        let previousCh = s[i - 1].charCodeAt(0);\\n        \\n        if (currentCh - previousCh === 1){\\n            currentCount += 1;\\n        } else {\\n            currentCount = 1\\n        }\\n        \\n        if (currentCount > longest) {\\n            longest = currentCount;\\n        }\\n    }\\n    \\n    return longest;\\n};", "var longestContinuousSubstring = function(s) {\\n    let longest = 1;\\n    let currentCount = 1;\\n    \\n    for (let i = 1; i < s.length; i++){\\n        let currentCh = s[i].charCodeAt(0);\\n        let previousCh = s[i - 1].charCodeAt(0);\\n        \\n        if (currentCh - previousCh === 1){\\n            currentCount += 1;\\n        } else {\\n            currentCount = 1\\n        }\\n        \\n        if (currentCount > longest) {\\n            longest = currentCount;\\n        }\\n    }\\n    \\n    return longest;\\n};"]}
{"id": "1612", "ref_js": ["var reverseOddLevels = function(root) {\\n    let queue = [root];\\n    let level = 0;\\n    \\n    while (queue.length) {\\n        const next = [];\\n        for (let i = 0; i < queue.length; i++) {\\n            const node = queue[i];\\n            if (node.left) {\\n                next.push(node.left);\\n            }\\n            if (node.right) {\\n                next.push(node.right);\\n            }\\n        }\\n        \\n        if (level % 2) {\\n            for (let i = 0, j = queue.length - 1; i < j; i++, j--) {\\n                const temp = queue[i].val;\\n                queue[i].val = queue[j].val;\\n                queue[j].val = temp;\\n            }\\n        }\\n        \\n        queue = next;\\n        level++;\\n    }\\n    \\n    return root;\\n};", "var reverseOddLevels = function(root) {\\n    if(!root) return root;\\n\\n    let level = 0;\\n    let queue = [root];\\n\\n    while(queue.length){\\n        let size = queue.length;\\n        if(level % 2 !== 0) {\\n            for(let i = 0; i < size/2; i++) {\\n                let left = queue[i];\\n                let right = queue[size-1-i];\\n\\n                let temp = left.val;\\n                left.val = right.val;\\n                right.val = temp;\\n            }\\n        }\\n        level++;\\n        for(let i = 0; i < size; i++) {\\n            let curr = queue.shift();\\n            if(curr.left) queue.push(curr.left);\\n            if(curr.right) queue.push(curr.right);\\n        }\\n    }\\n\\n    return root;\\n};", "var reverseOddLevels = function(root) {\\n    let queue = [root];\\n    let level = 0;\\n    \\n    while (queue.length) {\\n        const next = [];\\n        for (let i = 0; i < queue.length; i++) {\\n            const node = queue[i];\\n            if (node.left) {\\n                next.push(node.left);\\n            }\\n            if (node.right) {\\n                next.push(node.right);\\n            }\\n        }\\n        \\n        if (level % 2) {\\n            for (let i = 0, j = queue.length - 1; i < j; i++, j--) {\\n                const temp = queue[i].val;\\n                queue[i].val = queue[j].val;\\n                queue[j].val = temp;\\n            }\\n        }\\n        \\n        queue = next;\\n        level++;\\n    }\\n    \\n    return root;\\n};"]}
{"id": "1613", "ref_js": ["var longestSubarray = function(nums) {\\n    let ans = 0, count = 0;\\n    let max = Math.max(...nums);\\n    \\n    for (const num of nums) {\\n        if (num === max) {\\n            ans = Math.max(ans, ++count);\\n        } else {\\n            count = 0;\\n        }\\n    }\\n\\n    return ans;\\n};", "var longestSubarray = function(nums) {\\n  let n = nums.length, max = Math.max(...nums);\\n  let len = 0, maxLen = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] === max) len++;\\n    else len = 0;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n};", "var longestSubarray = function(nums) {\\n  let n = nums.length, max = Math.max(...nums);\\n  let len = 0, maxLen = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] === max) len++;\\n    else len = 0;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n};"]}
{"id": "1614", "ref_js": ["var goodIndices = function(nums, k) {\\n    \\n    ", "var goodIndices = function(nums, k) {\\n  let n = nums.length, left = Array(n).fill(1);\\n  for (let i = 1; i < n; i++) {\\n    if (nums[i] <= nums[i - 1]) {\\n      left[i] += left[i - 1];\\n    }\\n  }\\n  let right = Array(n).fill(1);\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] <= nums[i + 1]) {\\n      right[i] += right[i + 1];\\n    }\\n  }\\n  \\n  let goodIndices = [];\\n  for (let i = k; i < n - k; i++) {\\n    if (left[i - 1] >= k && right[i + 1] >= k) {\\n      goodIndices.push(i);\\n    }\\n  }\\n  return goodIndices;\\n};", "var goodIndices = function(nums, k) {\\n  let n = nums.length, left = Array(n).fill(1);\\n  for (let i = 1; i < n; i++) {\\n    if (nums[i] <= nums[i - 1]) {\\n      left[i] += left[i - 1];\\n    }\\n  }\\n  let right = Array(n).fill(1);\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] <= nums[i + 1]) {\\n      right[i] += right[i + 1];\\n    }\\n  }\\n  \\n  let goodIndices = [];\\n  for (let i = k; i < n - k; i++) {\\n    if (left[i - 1] >= k && right[i + 1] >= k) {\\n      goodIndices.push(i);\\n    }\\n  }\\n  return goodIndices;\\n};"]}
{"id": "1616", "ref_js": ["var xorAllNums = function (a, b) {\\n    let x = 0;\\n\\n    for (let e of a)\\n        for (let e2 of b) {\\n            x = x ^ e ^ e2;\\n        }\\n\\n    return x;\\n};", "var xorAllNums = function(nums1, nums2) {\\n    const n1odd = nums1.length & 1;\\n    const n2odd = nums2.length & 1;\\n    let nums = [];\\n    let ans = 0;\\n    if (n1odd && !n2odd) {\\n        nums = nums2;\\n    } else if (!n1odd && n2odd) {\\n        nums = nums1;\\n    } else if (n1odd && n2odd) {\\n        nums = nums1.concat(nums2);\\n    }\\n    for (let i = 0; i < nums.length; ++i) {\\n        ans = ans ^ nums[i];\\n    }\\n    return ans;\\n};", "var xorAllNums = function (inputOne, inputTwo) {\\n    if (inputOne.length % 2 === 0 && inputTwo.length % 2 === 0) {\\n        return 0;\\n    }\\n    if (inputOne.length % 2 === 1 && inputTwo.length % 2 === 0) {\\n        return  inputTwo.reduce((subtotalXOR, n) => (subtotalXOR ^ n), 0);\\n    }\\n    if (inputOne.length % 2 === 0 && inputTwo.length % 2 === 1) {\\n        return inputOne.reduce((subtotalXOR, n) => (subtotalXOR ^ n), 0);\\n    }\\n\\n    return  inputOne.reduce((subtotalXOR, n) => (subtotalXOR ^ n), 0)\\n            ^ inputTwo.reduce((subtotalXOR, n) => (subtotalXOR ^ n), 0);\\n};"]}
{"id": "1617", "ref_js": ["var maxSum = function(grid) {\\n    let sum = max = 0\\n    for(let i=0; i<grid.length-2; i++){\\n        for(let j = 0; j<grid[0].length-2; j++){\\n            sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n            max = Math.max(max, sum)\\n        }\\n    }\\n    return max\\n};", "var maxSum = function (grid) {\\n    let max = 0\\n\\t\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 1; j < grid[i].length - 1; j++) {\\n            let hourglassSum = 0\\n            hourglassSum += grid[i][j - 1]\\n            hourglassSum += grid[i][j]\\n            hourglassSum += grid[i][j + 1]\\n            hourglassSum += grid[i + 1][j]\\n            hourglassSum += grid[i + 2][j - 1]\\n            hourglassSum += grid[i + 2][j]\\n            hourglassSum += grid[i + 2][j + 1]\\n            if(hourglassSum > max) max = hourglassSum\\n        }\\n    }\\n\\n    return max\\n};", "var maxSum = function (grid) {\\n    let max = 0\\n\\t\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 1; j < grid[i].length - 1; j++) {\\n            let hourglassSum = 0\\n            hourglassSum += grid[i][j - 1]\\n            hourglassSum += grid[i][j]\\n            hourglassSum += grid[i][j + 1]\\n            hourglassSum += grid[i + 1][j]\\n            hourglassSum += grid[i + 2][j - 1]\\n            hourglassSum += grid[i + 2][j]\\n            hourglassSum += grid[i + 2][j + 1]\\n            if(hourglassSum > max) max = hourglassSum\\n        }\\n    }\\n\\n    return max\\n};"]}
{"id": "1618", "ref_js": ["var minimizeXor = function(num1, num2) {\\n  let n = countOnes(num2), res = 0, ones = 0;\\n  ", "var minimizeXor = function(num1, num2) {\\n    ", "var minimizeXor = function(num1, num2) {\\n    "]}
{"id": "1619", "ref_js": ["var findArray = function(pref) {\\n    let prev = pref[0];\\n    \\n    for (let i = 1; i < pref.length; i++) {\\n        pref[i] ^= prev;\\n        prev ^= pref[i];\\n    }\\n    \\n    return pref;    \\n};", "var findArray = function(pref) {\\n    let prev = pref[0];\\n    \\n    for (let i = 1; i < pref.length; i++) {\\n        pref[i] ^= prev;\\n        prev ^= pref[i];\\n    }\\n    \\n    return pref;    \\n};", "var findArray = function(pref) {\\n    let prev = pref[0];\\n    \\n    for (let i = 1; i < pref.length; i++) {\\n        pref[i] ^= prev;\\n        prev ^= pref[i];\\n    }\\n    \\n    return pref;    \\n};"]}
{"id": "1620", "ref_js": ["var robotWithString = function(s) {\\n  console.log(s);\\n  ", "var robotWithString = function(s) {\\n    ", "var robotWithString = function(s) {\\n    const freqs = new Array(26).fill(0)\\n    \\n    "]}
{"id": "1621", "ref_js": ["var productQueries = function (n, qs) {\\n  const mod = 10 ** 9 + 7;\\n\\n  let nBinary = n.toString(2).split(\"\").reverse();\\n\\n  let sum = 0;\\n  let prod = 1;\\n  let powers = [];\\n  let prefixProd = [];\\n\\n  for (let i = 0; i < nBinary.length; i++) {\\n    if (nBinary[i] === \"0\") {\\n      prod *= 2;\\n      continue;\\n    }\\n    powers.push(prod);\\n    if (!prefixProd.length) prefixProd.push(prod);\\n    else prefixProd.push(prefixProd.at(-1) * prod);\\n    prod *= 2;\\n    sum += prod;\\n    if (sum > n) break;\\n  }\\n\\n  let ans = [];\\n  for (let [sum, e] of qs) {\\n    ans.push((prefixProd[e] / (prefixProd[sum - 1] || 1)) % mod);\\n  }\\n  return ans;\\n};", "var productQueries = function(n, queries) {\\n    \\n        ", "var productQueries = function(n, queries) {\\n    const MOD = 1000000007;\\n    \\n    const b = n.toString(2);\\n    const powers = [];\\n    for (let i = b.length - 1; i >= 0; i--) {\\n        if (b[i] === \\'1\\') {\\n            powers.push(Math.pow(2,(b.length - 1 - i)));\\n        }\\n    }\\n    \\n    const ans = [];\\n    \\n    for (let [left, right] of queries) {\\n        let val = 1;\\n        for (let i = left; i <= right; i++) {\\n            val = (val * powers[i]) % MOD;\\n        }\\n        ans.push(val);\\n    }\\n    \\n    return ans;\\n};"]}
{"id": "1622", "ref_js": ["var minimizeArrayValue = function (nums) {\\n    let sum = 0;\\n    let res = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        res = Math.max(res, Math.ceil(sum / (i + 1)));\\n    }\\n    return res;\\n};", "var minimizeArrayValue = function(nums) {\\n    let res = nums[0], total = nums[0]\\n    for(let i=1;i<nums.length;i++){\\n        total += nums[i]\\n        res = Math.max(res, Math.ceil(total/(i+1)))\\n    }\\n    return res\\n};", "var minimizeArrayValue = function(nums) {\\n    let res = nums[0], total = nums[0]\\n    for(let i=1;i<nums.length;i++){\\n        total += nums[i]\\n        res = Math.max(res, Math.ceil(total/(i+1)))\\n    }\\n    return res\\n};"]}
{"id": "1623", "ref_js": ["var countDistinctIntegers = function(nums) {\\n    let n = nums.length;\\n    let obj = {}\\n    for(var x of nums)\\n        obj[+x] = 1;\\n    for(let j=0; j<n; j++)\\n        {\\n            let num = +(nums[j].toString().split(\"\").reverse().join(\"\"))\\n            obj[num] =1\\n        }\\n    return Object.keys(obj).length\\n};", "var countDistinctIntegers = function(nums) {\\n    let n = nums.length;\\n    let obj = {}\\n    for(var x of nums)\\n        obj[+x] = 1;\\n    for(let j=0; j<n; j++)\\n        {\\n            let num = +(nums[j].toString().split(\"\").reverse().join(\"\"))\\n            obj[num] =1\\n        }\\n    return Object.keys(obj).length\\n};", "var countDistinctIntegers = function(nums) {\\n    let n = nums.length;\\n    let obj = {}\\n    for(var x of nums)\\n        obj[+x] = 1;\\n    for(let j=0; j<n; j++)\\n        {\\n            let num = +(nums[j].toString().split(\"\").reverse().join(\"\"))\\n            obj[num] =1\\n        }\\n    return Object.keys(obj).length\\n};"]}
{"id": "1624", "ref_js": ["var sumOfNumberAndReverse = function(num) {\\n    if(num == 0) {\\n        return true\\n    }\\n    let i = Math.floor(num/2)\\n    while(i<num) {\\n        if(i+reverseANumber(i) == num) {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n};", "var sumOfNumberAndReverse = function(num) {\\n    if(num==0) return true\\n     for(let i=1;i<=num;i++)\\n  {\\n    let rev=Number(i.toString().split(\\'\\').reverse().join(\\'\\'))\\n    if((rev+i)===num) return true\\n  }\\n  return false\\n};", "var sumOfNumberAndReverse = function(num) {\\n    if(num==0) return true\\n     for(let i=1;i<=num;i++)\\n  {\\n    let rev=Number(i.toString().split(\\'\\').reverse().join(\\'\\'))\\n    if((rev+i)===num) return true\\n  }\\n  return false\\n};"]}
{"id": "1625", "ref_js": ["var subarrayGCD = function(nums, k) {\\n  let n = nums.length, ans = 0;\\n  for (let i = 0; i < n; i++) {\\n    let gcd = nums[i];\\n    for (let j = i; j < n; j++) {\\n      gcd = getGCD(gcd, nums[j]);\\n      if (gcd === k) ans++;\\n    }\\n  }\\n  return ans;  \\n};", "var subarrayGCD = function(nums, k) {\\n    const GCD=( A, B)=>{\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n   \\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==k) ans++;\\n        let gcd=nums[i];\\n        for(let j=i+1;j<nums.length;j++){\\n            let res=GCD(gcd,nums[j]);\\n            if(res==k) ans++;\\n            gcd=res;\\n        }\\n    }\\n    return ans;\\n   \\n};", "var subarrayGCD = function(nums, k) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let sub = [];\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] >= k) {\\n                sub.push(nums[j]);\\n                const gcd = findGcd(sub);\\n                if (gcd === k) {\\n                    ans++;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};"]}
{"id": "1626", "ref_js": ["var twoEditWords = function(queries, dictionary) {\\n    const res = [], n = queries[0].length;\\n\\n    for (const q of queries) {\\n        if (helper(q)) res.push(q)\\n    }\\n    return res;\\n\\n    function helper(q_word) {\\n        for (const w of dictionary) {\\n            if (diffLessThanTwo(q_word, w)) return true;\\n        }\\n        return false;\\n    }\\n\\n    function diffLessThanTwo(w1, w2) {\\n        let cnt = 0;\\n        for (let i = 0; i<n; i++) {\\n            if (cnt > 2) return false;\\n            if (w1[i]!==w2[i]) cnt++;\\n        }\\n        return cnt <= 2;\\n    }\\n};", "var WordDictionary = function () {\\n  this.trie = {};", "var twoEditWords = function (qs, d) {\\n  let ans = []\\n  for (let s of qs) {\\n    let n = s.length\\n    let found = 0\\n    for (let t of d) {\\n      let diffs = 0\\n      for (let i = 0; i < n; i++) {\\n        if (s[i] !== t[i]) {\\n          diffs++\\n          if (diffs > 2) break\\n        }\\n      }\\n      if (diffs <= 2) found = 1\\n    }\\n    if (found) ans.push(s)\\n  }\\n  return ans\\n};"]}
{"id": "1627", "ref_js": ["var destroyTargets = function (nums, space) {\\n  nums.sort((a, b) => a - b);\\n  const count = {};", "var destroyTargets = function(nums, space) {\\n    nums.sort((a, b) => a - b);\\n    let m = new Map(), res = 0, cnt = 0;\\n    for (let i = 0; i < nums.length; i++){\\n        if (m.get(nums[i] % space))\\n            m.set(nums[i] % space, m.get(nums[i] % space) + 1);\\n        else \\n            m.set(nums[i] % space, 1);\\n        if (cnt < m.get(nums[i] % space)){\\n            cnt = m.get(nums[i] % space);\\n        }        \\n    }\\n\\n    for (let i = 0; i < nums.length; i++){\\n        if (m.get(nums[i] % space) === cnt){\\n            res = nums[i];\\n            break;\\n        }\\n    }\\n    \\n    return res;\\n};", "var destroyTargets = function(nums, space) {\\n   const remaindersMap = {} \\n   let maxFreq = null\\n\\n   for(let i = 0; i < nums.length; i++) {\\n       const currRemainder = nums[i]%space\\n\\n       if(!(currRemainder in remaindersMap)) {\\n           remaindersMap[currRemainder] = 0\\n       }\\n       remaindersMap[currRemainder]++\\n\\n       if(maxFreq === null || remaindersMap[currRemainder] > maxFreq) {\\n           maxFreq = remaindersMap[currRemainder]\\n       }\\n   }\\n\\n   let res = null\\n\\n   for(let i = 0; i < nums.length; i++) {\\n       const currRemainder = nums[i]%space\\n\\n       if(remaindersMap[currRemainder] === maxFreq) {\\n           if(res === null || res > nums[i]) {\\n               res = nums[i]\\n           }  \\n       }\\n   }\\n\\n    return res\\n};"]}
{"id": "1628", "ref_js": ["var mostPopularCreator = function(creators, ids, views) {\\n    const map = {};", "var mostPopularCreator = function (creators, ids, views) {\\n  let crVwSumMap = {};", "var mostPopularCreator = function (creators, ids, views) {\\n  let crVwSumMap = {};"]}
{"id": "1629", "ref_js": ["var makeIntegerBeautiful = function(n, target) {\\n\\n    ", "var makeIntegerBeautiful = function (n, targetSumOfDigits) {\\n  function sumofdigits(n) {\\n    let sum = 0;\\n    let m = n;\\n    while (m) {\\n      let reminder = m % 10;\\n      sum += reminder;\\n      m = Math.trunc(m / 10);\\n    }\\n    return sum;\\n  }\\n\\n  let multiplier = 10;\\n  let m = n;\\n  while (sumofdigits(m) > targetSumOfDigits) {\\n    m = Math.ceil(m / multiplier) * multiplier;\\n    multiplier *= 10;\\n  }\\n  return m - n;\\n};", "var makeIntegerBeautiful = function (n, targetSumOfDigits) {\\n  function sumofdigits(n) {\\n    let sum = 0;\\n    let m = n;\\n    while (m) {\\n      let reminder = m % 10;\\n      sum += reminder;\\n      m = Math.trunc(m / 10);\\n    }\\n    return sum;\\n  }\\n\\n  let multiplier = 10;\\n  let m = n;\\n  while (sumofdigits(m) > targetSumOfDigits) {\\n    m = Math.ceil(m / multiplier) * multiplier;\\n    multiplier *= 10;\\n  }\\n  return m - n;\\n};"]}
{"id": "1630", "ref_js": ["var maximumSubarraySum = function (nums, k) {\\n    let maxSum = 0;\\n    let tempSum = 0;\\n    const initConfig = {};", "var maximumSubarraySum = function (nums, k) {\\n    let maxSum = 0;\\n    let tempSum = 0;\\n    const initConfig = {};", "var maximumSubarraySum = function (nums, k) {\\n    let maxSum = 0;\\n    let tempSum = 0;\\n    const initConfig = {};"]}
{"id": "1631", "ref_js": ["var totalCost = function(costs, k, candidates) {\\n  let n = costs.length;\\n  let left = new PriorityQueue((a, b) => a[1] === b[1] ? a[0] - b[0] : a[1] - b[1]); ", "var totalCost = function(costs, k, candidates) {\\n  let result = 0;\\n\\n  const mincomp = (a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n  const left = new MinPriorityQueue({ compare: mincomp });\\n  const right = new MinPriorityQueue({ compare: mincomp });\\n\\n  let l = 0;\\n  while (l < candidates && l < costs.length) {\\n    left.enqueue([costs[l], l]);\\n    ++l;\\n  }\\n\\n  let r = costs.length - 1;\\n  while (l <= r && costs.length - candidates <= r) {\\n    right.enqueue([costs[r], r]);\\n    --r;\\n  }\\n\\n  while (0 < k) {\\n    const lf = left.front();\\n    const rf = right.front();\\n    if (rf == null || (lf != null && lf[0] <= rf[0])) {\\n      ", "var totalCost = function(costs, k, candidates) {\\n  let result = 0;\\n\\n  const mincomp = (a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n  const left = new MinPriorityQueue({ compare: mincomp });\\n  const right = new MinPriorityQueue({ compare: mincomp });\\n\\n  let l = 0;\\n  while (l < candidates && l < costs.length) {\\n    left.enqueue([costs[l], l]);\\n    ++l;\\n  }\\n\\n  let r = costs.length - 1;\\n  while (l <= r && costs.length - candidates <= r) {\\n    right.enqueue([costs[r], r]);\\n    --r;\\n  }\\n\\n  while (0 < k) {\\n    const lf = left.front();\\n    const rf = right.front();\\n    if (rf == null || (lf != null && lf[0] <= rf[0])) {\\n      "]}
{"id": "1632", "ref_js": ["var countGoodStrings = function(low, high, zero, one) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    ", "var countGoodStrings = function(low, high, zero, one) {\\n    let dp = new Array(high+1).fill(0);\\n    dp[0] = 1;\\n    let ans = 0;\\n    for (let i = 1; i <= high; i++) {\\n        dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n        if (i >= low) {\\n            ans = (ans+dp[i])%1000000007;\\n        }\\n    }\\n    return ans;\\n};", "var countGoodStrings = function(low, high, zero, one) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    "]}
{"id": "1633", "ref_js": ["var mostProfitablePath = function(edges, bob, amount) {\\n    ", "var mostProfitablePath = function(edges, bob, amount) {\\n    const graph = Array.from({ length: edges.length + 1 }, () => []);\\n\\n    for (const [i, j] of edges)\\n        graph[i].push(j), graph[j].push(i);\\n    \\n    function aliceMoves(node, parent, time) {\\n        let totalBobTime = node == bob ? 0 : Infinity, newScore = -Infinity;\\n\\n        for (const child of graph[node]) {\\n            if (child == parent) continue;\\n\\n            const [score, bobTime] = aliceMoves(child, node, time + 1);\\n            totalBobTime = Math.min(totalBobTime, bobTime + 1);\\n            newScore = Math.max(newScore, score)\\n        }\\n\\n        if (newScore == -Infinity) newScore = 0;\\n        if (time < totalBobTime) newScore += amount[node];\\n        else if (time == totalBobTime) newScore += amount[node] / 2;\\n\\n        return [newScore, totalBobTime];\\n    }\\n    \\n    return aliceMoves(0, -1, 0)[0];\\n};", "var mostProfitablePath = function(edges, bob, amount) {\\n    let res = 0;\\n    "]}
{"id": "1634", "ref_js": ["var subarrayLCM = function(nums, k) {\\n    const GCD=(A, B)=> {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    \\n    const LCM=(A, B)=> {\\n        return (A*B)/GCD(A,B);\\n    }\\n\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]===k) ans++;\\n        let lcm=nums[i];\\n        for(let j=i+1;j<nums.length;j++){\\n            let res=LCM(lcm,nums[j]);\\n            if(res==k) ans++;\\n            lcm=res;\\n            if(res>k) break;\\n        }\\n    }\\n    return ans;\\n};", "var subarrayLCM = function(nums, k) {\\n    let ans = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        let lcm = nums[i];\\n        if(lcm == k) ans++;\\n        for(var j = i + 1; j < nums.length; j++){\\n            lcm = LCM(lcm, nums[j]);\\n            if(lcm == k) ans++;\\n            if(lcm > k) break;\\n        }\\n    }\\n    return ans;\\n};", "var subarrayLCM = function(nums, k) {\\n    let ans = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        let lcm = nums[i];\\n        if(lcm == k) ans++;\\n        for(var j = i + 1; j < nums.length; j++){\\n            lcm = LCM(lcm, nums[j]);\\n            if(lcm == k) ans++;\\n            if(lcm > k) break;\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "1635", "ref_js": ["var minimumOperations = function(root) {\\n    let ans = 0;\\n    let queue = [root];\\n    \\n    while (queue.length) {\\n        const next = [];\\n        const cur = [];\\n        \\n        for (let i = 0; i < queue.length; i++) {\\n            const node = queue[i];\\n            cur.push(node.val);\\n            \\n            if (node.left) {\\n                next.push(node.left);\\n            }\\n            \\n            if (node.right) {\\n                next.push(node.right);\\n            }\\n        }\\n        \\n        const asc = [...cur].sort((a, b) => a - b);\\n        \\n        const map = {};", "var minimumOperations = function(root) {\\n  let queue = [root], ans = 0;\\n  while (queue.length)  {\\n    let next = [];\\n    ans += minSwaps(queue.map(node => node.val));\\n    while (queue.length) {\\n      let node = queue.shift();\\n      if (node.left) next.push(node.left);\\n      if (node.right) next.push(node.right);\\n    }\\n    queue = next;\\n  } \\n  return ans;\\n};", "var minimumOperations = function(root) {\\n  let queue = [root], ans = 0;\\n  while (queue.length)  {\\n    let next = [];\\n    ans += minSwaps(queue.map(node => node.val));\\n    while (queue.length) {\\n      let node = queue.shift();\\n      if (node.left) next.push(node.left);\\n      if (node.right) next.push(node.right);\\n    }\\n    queue = next;\\n  } \\n  return ans;\\n};"]}
{"id": "1636", "ref_js": ["var closestNodes = function(root, queries) {\\n    let arr = [];\\n    let ans = [];\\n    \\n\\t", "var closestNodes = function(root, queries) {\\n    const values = [];\\n    const result = new Array(queries.length);\\n    let index;\\n\\n    const inorder = node => {\\n        if (node === null) return;\\n\\n        inorder(node.left);\\n        values.push(node.val);\\n        inorder(node.right);\\n    };", "var closestNodes = function(root, queries) {\\n    let arr = [];\\n    let ans = [];\\n    \\n\\t"]}
{"id": "1637", "ref_js": ["var minimumFuelCost = function(roads, seats) {\\n    const adjList = createAdjacencyList(roads);\\n    let ans = 0\\n\\n    const dfs = (curNode, preNode) => {\\n        let people = 1\\n        for(let child of adjList[curNode]){ \\n            if(child !== preNode){\\n                people += dfs(child, curNode)\\n            }\\n        }\\n        if(curNode) \\n            ans += Math.ceil(people/seats)\\n\\n        return people\\n    }\\n    dfs(0, -1)\\n\\n    return ans\\n};", "var minimumFuelCost = function(roads, seats) {\\n    const graph = Array.from({ length: roads.length + 1 }, () => []);\\n    let fuel = 0;\\n\\n    for (const [i, j] of roads)\\n        graph[i].push(j), graph[j].push(i);\\n\\n    (function dfs(node, parent) {\\n        const totalPeople = graph[node].reduce((acc, child) =>\\n                    acc + (child == parent ? 0 : dfs(child, node)), 1);\\n        if (parent > -1)\\n            fuel += Math.ceil(totalPeople / seats);\\n        return totalPeople;\\n    })(0, -1)\\n\\n    return fuel;\\n};", "var minimumFuelCost = function(roads, seats) {\\n    const graph = Array.from({ length: roads.length + 1 }, () => []);\\n    let fuel = 0;\\n\\n    for (const [i, j] of roads)\\n        graph[i].push(j), graph[j].push(i);\\n\\n    (function dfs(node, parent) {\\n        const totalPeople = graph[node].reduce((acc, child) =>\\n                    acc + (child == parent ? 0 : dfs(child, node)), 1);\\n        if (parent > -1)\\n            fuel += Math.ceil(totalPeople / seats);\\n        return totalPeople;\\n    })(0, -1)\\n\\n    return fuel;\\n};"]}
{"id": "1638", "ref_js": ["var onesMinusZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const rowOnes = new Array(m).fill(0);\\n    const colOnes = new Array(n).fill(0);\\n\\n    ", "var onesMinusZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const res = Array.from({ length: m }, () => Array(n).fill(0));\\n    const onesRow = grid.map(row => row.filter(val => val === 1).length);\\n    const onesCol = Array.from({ length: n }, (_, j) => grid.map(row => row[j]).filter(val => val === 1).length);\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            res[i][j] = onesRow[i] + onesCol[j] - (m - onesRow[i]) - (n - onesCol[j]);\\n        }\\n    }\\n\\n    return res;    \\n};", "var onesMinusZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const res = Array.from({ length: m }, () => Array(n).fill(0));\\n    const onesRow = grid.map(row => row.filter(val => val === 1).length);\\n    const onesCol = Array.from({ length: n }, (_, j) => grid.map(row => row[j]).filter(val => val === 1).length);\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            res[i][j] = onesRow[i] + onesCol[j] - (m - onesRow[i]) - (n - onesCol[j]);\\n        }\\n    }\\n\\n    return res;    \\n};"]}
{"id": "1639", "ref_js": ["var bestClosingTime = function(customers) {\\n    var bestTime = 0, penaltyDiff = 0;\\n\\n    for (var i = 0; i < customers.length; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }\\n    }\\n    return bestTime;\\n};", "var bestClosingTime = function(customers) {\\n    let max_score = 0, score = 0, best_hour = -1;\\n    for(let i = 0; i < customers.length; ++i) {\\n        score += (customers[i] === \\'Y\\') ? 1 : -1;\\n        if(score > max_score) {\\n            max_score = score;\\n            best_hour = i;\\n        }\\n    }\\n    return best_hour + 1;\\n};", "var bestClosingTime = function(customers) {\\n    let res = 0;\\n    let customerLeft = 0;\\n\\n    for (let i = 0; i < customers.length; i++) {\\n        if (customers[i] === \\'Y\\') {\\n            customerLeft++;\\n\\n            if (customerLeft > 0) {\\n                res = i + 1;\\n                customerLeft = 0;\\n            }\\n        } else {\\n            customerLeft--;\\n        }\\n    }\\n\\n    return res;    \\n};"]}
{"id": "1640", "ref_js": ["var appendCharacters = function(s, t) {\\n    let j =0, len = t.length\\n    for(let i=0;i<s.length;i++){\\n        s[i]===t[j] && j++\\n        if(len===j) return 0\\n    }\\n    return len-j\\n};", "var appendCharacters = function(s, t) {\\n    let i = 0, j = 0;\\n    \\n    while (i < s.length && j < t.length) {\\n        if (s[i] === t[j]) {\\n            j++;\\n        }\\n        i++;\\n    }\\n    \\n    return t.length - j;\\n};", "var appendCharacters = function(s, t) {\\n    \\n    const tSize = t.length;\\n    let tPointer = 0;\\n    let expectedLetter = t[0];\\n\\n    for (let i = 0; i < s.length; i++) {\\n        let currentLetter = s[i];\\n\\n        if (currentLetter == expectedLetter) {\\n            tPointer++;\\n            if (tPointer > tSize)\\n                return 0;\\n            expectedLetter = t[tPointer];\\n        }\\n    }\\n\\n    return tSize - tPointer;\\n};"]}
{"id": "1641", "ref_js": ["var removeNodes = function(head) {\\n    head = reverseList(head);\\n\\n    let prev = null;\\n    let curr = head;\\n    let local_max = 0;\\n\\n    while (curr !== null) {\\n        local_max = Math.max(local_max, curr.val);\\n\\n        if (curr.val < local_max) {\\n            if (prev !== null) {\\n                prev.next = curr.next\\n            } else {\\n                head = curr.next\\n            };", "var removeNodes = function (head) {\\n  const stack = [];\\n  while (head) {\\n    while (stack.length && head.val > stack[stack.length - 1]) {\\n      stack.pop();\\n    }\\n    stack.push(head.val);\\n    head = head.next;\\n  }\\n  while (stack.length) {\\n    head = new ListNode(stack.pop(), head);\\n  }\\n  return head;\\n};", "var removeNodes = function(head) {\\n    \\n    if(!head) return null\\n    \\n    head.next = removeNodes(head.next)\\n    \\n    if(head.next && head.val < head.next.val) return head.next\\n    \\n    return head\\n    \\n};"]}
{"id": "1642", "ref_js": ["var dividePlayers = function(skill) {\\n    skill.sort((a, b) => a - b);\\n    const len = skill.length;\\n    let totalChemistry = 0;\\n    let prev = skill[0] + skill[len - 1];\\n    totalChemistry += skill[0]*skill[len - 1];\\n    let currSkill = prev;\\n    for(let i = 1; i < skill.length / 2; i++){\\n        currSkill = skill[i] + skill[len - i - 1];\\n        if(prev !== currSkill)\\n            return -1;\\n        totalChemistry += skill[i] * skill[len - i - 1];\\n        prev = currSkill;\\n    }\\n    return totalChemistry;\\n};", "var dividePlayers = function(skill) {\\n    skill.sort((a , b) => a - b) ; \\n    let i = 0  ; \\n    let j = skill.length - 1 ; \\n    let array = [] ; \\n    let value = []  ;\\n    let size = 0 ; \\n    while(i < j){\\n        array[size] = (skill[i] + skill[j]) ;\\n        value[size] = (skill[i] * skill[j]);\\n        ++size ; \\n        i++ ; \\n        j-- ; \\n    }\\n    for(let i = 1 ; i < size ; ++i){\\n        if(array[i - 1] != array[i]){\\n            return -1 ; \\n        }\\n    }\\n    let count = 0 ; \\n    for(let i = 0 ; i < size ; ++i){\\n        count += value[i] ; \\n    }\\n    return count ; \\n};", "var dividePlayers = function(skill) {\\n    let total = 0;\\n    skill.sort((a,b)=>{return a - b});\\n    for (let i = 0, j = 0; i < skill.length/2; i++){\\n        if (skill[i] + skill[skill.length - (i+1)] === skill[i +1] + skill[skill.length - (i+2)] ){\\n            total += skill[i] * skill[skill.length - (i+1)];\\n        }else {\\n            return -1\\n        }\\n\\n    }\\n\\n    return total\\n};"]}
{"id": "1643", "ref_js": ["var minScore = function (n, roads) {\\n  const graph = new Array(n + 1).fill().map(() => []);\\n  const visited = new Set([]);\\n\\n  for (const [v1, v2, distance] of roads) {\\n    graph[v1].push([v2, distance]);\\n    graph[v2].push([v1, distance]);\\n  }\\n\\n  const queue = [1];\\n  visited.add(1);\\n  let ans = Infinity;\\n\\n  while (queue.length > 0) {\\n    const node = queue.shift();\\n    for (const [next, distance] of graph[node]) {\\n      ans = Math.min(ans, distance);\\n      if (visited.has(next)) continue;\\n\\n      visited.add(next);\\n      queue.push(next);\\n    }\\n  }\\n\\n  return ans;\\n};", "var minScore = function(n, roads) {\\n    let cnt = 1;\\n    const map = new Map();\\n    map.set(1, true);\\n    ", "var minScore = function(n, roads) {\\n    const dsu = new DisjointSetUnion(n);\\n    for(const [source, target] of roads) {\\n        dsu.union(source, target);\\n    }\\n\\n    let minDistance = Infinity;\\n    const root = dsu.find(1);\\n    for(const [source, target, distance] of roads) {\\n        if(dsu.find(source) === root || dsu.find(target) === root) {\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n    }\\n\\n    return minDistance;\\n};"]}
{"id": "1644", "ref_js": ["var maxStarSum = function(vals, edges, k) {\\n    let n = vals.length;\\n    let adjList = Array.from({ length: n }, () => []);\\n\\n    for (let [u, v] of edges){\\n        adjList[u].push(v);\\n        adjList[v].push(u);\\n    }\\n    \\n    let res = Number.MIN_SAFE_INTEGER;\\n\\n    for(let i = 0; i < n; i++){\\n        let a = adjList[i].map(x => vals[x]).sort((a, b) => b - a);\\n        let sum = vals[i];\\n        let count = 0;\\n        for(let x of a){\\n            if(x > 0 && count < k){\\n                sum += x;\\n                count++;\\n            }else break;\\n        }\\n\\n        res = Math.max(res, sum);\\n    }\\n    \\n    return res;\\n\\n};", "var maxStarSum = function(vals, edges, k) {\\n    const n = vals.length;\\n    const map = {}\\n    for (let [a, b] of edges) {\\n        if (!map[a]) map[a] = [];\\n        if (!map[b]) map[b] = [];\\n        map[a].push(b);\\n        map[b].push(a);\\n    }\\n\\n    const getMax = (i) => {\\n        const values = (map[i] || [])\\n            .map(x => vals[x])\\n            .sort((a, b) => b - a);\\n        let sum = vals[i];\\n        let cnt = 0;\\n        for (const v of values) {\\n            if (v > 0 && cnt < k) {\\n                sum += v;\\n                cnt++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    let max = -Infinity;\\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, getMax(i));\\n    }\\n    return max;\\n};", "var maxStarSum = function (nodeValues, edges, maxNumberOfEdges) {\\n    const totalNodes = nodeValues.length;\\n    \\n    "]}
{"id": "1645", "ref_js": ["var maxJump = function(stones) {\\n    \\n    let n = stones.length;\\n\\n    if (n == 2)\\n        return stones[1] - stones[0];\\n    \\n    let res = stones[1] - stones[0];\\n\\n    for(let i=2; i<n; i++)\\n        res = Math.max(res, stones[i] - stones[i-2]);\\n    \\n    return res;\\n};", "var maxJump = function(stones) {\\n  let max=stones[1]\\n  let n=stones.length\\n    for(let i=0;i<stones.length-2;i++)\\n      {\\n        if(max<stones[i+2]-stones[i])\\n          {\\n            max=stones[i+2]-stones[i]\\n          }\\n      }\\n  return max\\n};", "var maxJump = function(stones) {\\n  let max=stones[1]\\n  let n=stones.length\\n    for(let i=0;i<stones.length-2;i++)\\n      {\\n        if(max<stones[i+2]-stones[i])\\n          {\\n            max=stones[i+2]-stones[i]\\n          }\\n      }\\n  return max\\n};"]}
{"id": "1646", "ref_js": ["var longestSquareStreak = function(nums) {\\n    const squares = new Set();\\n    for (let i = 2; i < 317; ++i) {\\n        squares.add(i * i);\\n    } \\n\\n    nums = nums.filter(o => o < 317 || squares.has(o));\\n    nums.sort((a, b) => a - b);\\n    const set = new Set(nums);\\n    let result = -1;\\n    let count = 0, current;\\n\\n    for (const num of nums) {\\n        current = num;\\n        count = 1;\\n\\n        while (set.has(current * current)) {\\n            current *= current;\\n            ++count;\\n        }\\n\\n        if (count > result) result = count;\\n    }\\n\\n    return result === 1 ? -1 : result;\\n};", "var longestSquareStreak = function(nums) {\\n    const squares = new Set();\\n    for (let i = 2; i < 317; ++i) {\\n        squares.add(i * i);\\n    } \\n\\n    nums = nums.filter(o => o < 317 || squares.has(o));\\n    nums.sort((a, b) => a - b);\\n    const set = new Set(nums);\\n    let result = -1;\\n    let count = 0, current;\\n\\n    for (const num of nums) {\\n        current = num;\\n        count = 1;\\n\\n        while (set.has(current * current)) {\\n            current *= current;\\n            ++count;\\n        }\\n\\n        if (count > result) result = count;\\n    }\\n\\n    return result === 1 ? -1 : result;\\n};", "var longestSquareStreak = function(nums) {\\n    const squares = new Set();\\n    for (let i = 2; i < 317; ++i) {\\n        squares.add(i * i);\\n    } \\n\\n    nums = nums.filter(o => o < 317 || squares.has(o));\\n    nums.sort((a, b) => a - b);\\n    const set = new Set(nums);\\n    let result = -1;\\n    let count = 0, current;\\n\\n    for (const num of nums) {\\n        current = num;\\n        count = 1;\\n\\n        while (set.has(current * current)) {\\n            current *= current;\\n            ++count;\\n        }\\n\\n        if (count > result) result = count;\\n    }\\n\\n    return result === 1 ? -1 : result;\\n};"]}
{"id": "1648", "ref_js": ["var smallestValue = function(n) {\\n    const findAns=(n)=>{\\n        let ans=0;\\n        while(n%2==0){\\n            ans+=2;\\n            n/=2;\\n        }\\n        let res=Math.sqrt(n);\\n        for(let i=3;i<=res;i+=2){\\n            while(n%i==0){\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>2) ans+=n;\\n        return ans;\\n    }\\n    while(1){\\n        let ans=findAns(n);\\n        if(ans==n) return n;\\n        n=ans;\\n    }\\n    return n;\\n};", "var smallestValue = function(n) {\\n    let s=(primeFactors(n))\\n    if(s==n){\\n        return s\\n    }\\n   while(true){\\n       let nn=primeFactors(n)\\n       if(nn==n){\\n           return n\\n       }\\n       n=nn\\n   }\\n    \\n    return 0\\n    \\n    \\n};", "var smallestValue = function(n) {\\n    while(true) {\\n        let sum=0;\\n        let init=n;\\n        for(let i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>1) sum+=n;\\n        if(n==init||sum==init) return init;\\n        n=sum;\\n    }\\n};"]}
{"id": "1649", "ref_js": ["var topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {\\n    const pos = new Set(positive_feedback);\\n    const neg = new Set(negative_feedback);\\n\\n    const scores = {};", "var topStudents = function (positiveFeedback, negativeFeedback, report, studentID, numberOfTopStudentsToRank) {\\n    this.positiveFeedbackWords = new Set(positiveFeedback);\\n    this.negativeFeedbackWords = new Set(negativeFeedback);\\n\\n    ", "var topStudents = function (positiveFeedback, negativeFeedback, report, studentID, numberOfTopStudentsToRank) {\\n    this.positiveFeedbackWords = new Set(positiveFeedback);\\n    this.negativeFeedbackWords = new Set(negativeFeedback);\\n\\n    "]}
{"id": "1650", "ref_js": ["var adjacentMines = function(board, x, y){\\n    let numMines = 0;\\n    for(let i = x-1; i <= x+1; ++i){ ", "var updateBoard = function(board, click) {\\n    const m = board.length;\\n    const n = board[0].length;\\n    const adjMines = new Array(m).fill(0)\\n    .map(() => new Array(n).fill(0));\\n\\n    function countAdjMines(i, j){\\n        if(i < 0 || j < 0 || i >= m || j >= n){\\n            return;\\n        }\\n\\n        adjMines[i][j]++;\\n    }\\n\\n    function DFS(i, j){\\n        if(i < 0 || j < 0 || i >= m || j >= n){\\n            return;\\n        }\\n\\n        if(board[i][j] !== \\'E\\'){\\n            return;\\n        }\\n\\n        if(adjMines[i][j] > 0){\\n            board[i][j] = \\'\\' + adjMines[i][j];\\n            return;\\n        }\\n\\n        board[i][j] = \\'B\\';\\n\\n        DFS(i, j-1);\\n        DFS(i, j+1);\\n        DFS(i+1, j);\\n        DFS(i-1, j);\\n        DFS(i+1, j+1);\\n        DFS(i-1, j+1);\\n        DFS(i+1, j-1);\\n        DFS(i-1, j-1);\\n    }\\n\\n    for(let i=0; i<m; i++){\\n        for(let j=0; j<n; j++){\\n            if(board[i][j] === \\'M\\'){\\n                countAdjMines(i, j-1);\\n                countAdjMines(i, j+1);\\n                countAdjMines(i+1, j);\\n                countAdjMines(i-1, j);\\n                countAdjMines(i+1, j+1);\\n                countAdjMines(i-1, j+1);\\n                countAdjMines(i+1, j-1);\\n                countAdjMines(i-1, j-1);\\n            }\\n        }\\n    }\\n\\n    let [r, c] = click;\\n\\n    if(board[r][c] === \\'M\\'){\\n        board[r][c] = \\'X\\';\\n    } else if(board[r][c] === \\'E\\'){\\n        DFS(r, c);\\n    }\\n\\n    return board;\\n};", "var adjacentMines = function(board, x, y){\\n    let numMines = 0;\\n    for(let i = x-1; i <= x+1; ++i){ "]}
{"id": "1651", "ref_js": ["var takeCharacters = function (s, k) {\\n  ", "var takeCharacters = function(s, k) {\\n    const fm={\\'a\\':0,\\'b\\':0,\\'c\\':0};", "var takeCharacters = function (s, k) {\\n  "]}
{"id": "1652", "ref_js": ["var maximumTastiness = function(price, k) {\\n    const N = price.length\\n    price.sort((a,b) => a - b)\\n    let left = 0\\n    let right = price.at(-1)-price[0] + 1 \\n    while(left < right) {\\n        const mid = Math.floor(left + (right-left)/2)\\n        if(!condition(mid)) {\\n            right = mid\\n        } else {\\n            left = mid +1\\n        }\\n    }\\n    return left -1 \\n    \\n    function condition(mid) {\\n        let first = price[0]\\n        let count = 1\\n        for(let i = 1; i <N; i++) {\\n            if(price[i]-first>=mid) {\\n                count++\\n                first = price[i]\\n            }\\n            if(count===k) return true\\n        }\\n        return false\\n    }\\n};", "var maximumTastiness = function(price, k) {\\n    price.sort((a,b) => a-b)\\n    const getCandies = (mid) => {\\n        let lastValue = price[0]\\n        let collected = 1\\n        for(let i = 1; i < price.length; i++) {\\n            if (price[i] - lastValue >= mid) {\\n                lastValue = price[i]\\n                collected++\\n            }\\n            if (collected >= k) return true\\n        }\\n        return false\\n    }\\n    let left = 0;\\n    let right = 10 ** 9\\n    let mid = Math.floor((left + right) / 2)\\n    while (left <= right) {\\n        if (getCandies(mid)) left = mid + 1\\n        else right = mid - 1\\n        mid = Math.floor((left + right) / 2)\\n    }\\n    return mid\\n};", "var maximumTastiness = function(price, k) {\\n"]}
{"id": "1653", "ref_js": ["var distinctPrimeFactorsSieve = function(nums, p = nums.reduce((a, b) => a * BigInt(b), 1n), c = 0) {\\n    for (let prime of sieveArr) if (p % BigInt(prime) == 0) c++\\n    return c\\n};", "var distinctPrimeFactors = function (a) {\\n  let primeSet = generatePrimes(1001);\\n  let set = new Set();\\n\\n  for (let e of a) {\\n    for (let i = 1; i <= Math.sqrt(e) + 1; i++) {\\n      if (e % i === 0 && primeSet.has(i)) {\\n        set.add(i);\\n        if (primeSet.has(e / i)) {\\n          set.add(e / i);\\n        }\\n      }\\n    }\\n    if (primeSet.has(e)) {\\n      set.add(e);\\n    }\\n  }\\n\\n  return set.size;\\n};", "var distinctPrimeFactors = function (a) {\\n  let primeSet = generatePrimes(1001);\\n  let set = new Set();\\n\\n  for (let e of a) {\\n    for (let i = 1; i <= Math.sqrt(e) + 1; i++) {\\n      if (e % i === 0 && primeSet.has(i)) {\\n        set.add(i);\\n        if (primeSet.has(e / i)) {\\n          set.add(e / i);\\n        }\\n      }\\n    }\\n    if (primeSet.has(e)) {\\n      set.add(e);\\n    }\\n  }\\n\\n  return set.size;\\n};"]}
{"id": "1654", "ref_js": ["var minimumPartition = function(s, k) {\\n        let i = 0;\\n        let c = 0;\\n        let j = 0;\\n        ", "var minimumPartition = function(s, k) {\\n    const kLen = k.toString().length;\\n    let res = 0;\\n\\n    for (let i = 0; i < s.length; i+=kLen) {\\n        if (k < 10 && +s[i] > k) return -1;\\n\\n        res++;\\n        if (+s.substring(i, i + kLen) > k) {\\n            i--;\\n        }\\n    }\\n\\n    return res;\\n};", "var minimumPartition = function(s, k) {\\n    \\n    const MAX=1000000;\\n    const dfs=(start,dp)=>{\\n        if(start===s.length) {\\n            return 0;\\n        }\\n\\n        const key = start;\\n        if(dp[key]!==undefined) return dp[key]; \\n\\n        let wndNum=0, ans=MAX;\\n        for(let i=start;i<s.length;i++){\\n            "]}
{"id": "1655", "ref_js": ["var closestPrimes = function(left, right) {\\n    let primeArr = [];\\n    let res = [-1, -1];\\n    let minDiff = Infinity;\\n\\n    for(let i=left; i<=right; i++){\\n        if(isPrime(i)) primeArr.push(i)\\n    }\\n\\n    for(let i=1; i<primeArr.length; i++){\\n        let diff = primeArr[i]-primeArr[i-1];\\n        if(diff<minDiff){\\n            res = [primeArr[i-1], primeArr[i]]\\n            minDiff = diff;\\n        }\\n    }\\n    return res\\n\\n};", "var closestPrimes = function (left, right) {\\n  let ans = [-1, -1];\\n  let mindiff = Infinity;\\n  for (let i = left; i < right; i++) {\\n    if (!prs[i]) continue;\\n    let j;\\n    for (j = i + 1; j < right; j++) {\\n      if (prs[j]) break;\\n    }\\n    if (!prs[j]) continue;\\n    let diff = j - i;\\n    if (diff < mindiff) {\\n      mindiff = diff;\\n      ans = [i, j];\\n    }\\n    i = j - 1;\\n  }\\n  return ans;\\n};", "var closestPrimes = function (left, right) {\\n  let ans = [-1, -1];\\n  let mindiff = Infinity;\\n  for (let i = left; i < right; i++) {\\n    if (!prs[i]) continue;\\n    let j;\\n    for (j = i + 1; j < right; j++) {\\n      if (prs[j]) break;\\n    }\\n    if (!prs[j]) continue;\\n    let diff = j - i;\\n    if (diff < mindiff) {\\n      mindiff = diff;\\n      ans = [i, j];\\n    }\\n    i = j - 1;\\n  }\\n  return ans;\\n};"]}
{"id": "1657", "ref_js": ["var xorBeauty = function(nums) {\\n    let result = 0\\n    for(let num of nums) {\\n        result ^= num\\n    }\\n    return result\\n};", "var xorBeauty = function(nums) {\\n    for(var i=1; i<nums.length; i++){\\n        nums[0] = nums[0]^nums[i];\\n    }\\n    return nums[0];\\n};", "var xorBeauty = function(nums) {\\n      return nums.reduce((a, b) => a ^ b);\\n};"]}
{"id": "1658", "ref_js": ["var maxKelements = function(nums, k) {\\n    const pq = new MaxPriorityQueue();\\n    for (const num of nums) {\\n        pq.enqueue(num);\\n    }\\n    \\n    let ans = 0;\\n    for (let i = 0; i < k; i++) {\\n        const val = pq.dequeue().element;\\n        ans += val;\\n        pq.enqueue(Math.ceil(val / 3));\\n    }\\n    return ans;\\n};", "var maxKelements = function (nums, k, res = 0) {\\n  const pq = new MaxPriorityQueue();\\n  for (let num of nums) {pq.enqueue(num);}\\n  while (k) {\\n    const el = pq.dequeue().element;\\n    res += el;\\n    pq.enqueue(Math.ceil(el / 3));\\n    k--;\\n  }\\n  return res;\\n};", "var maxKelements = function (nums, k, res = 0) {\\n  const pq = new MaxPriorityQueue();\\n  for (let num of nums) {pq.enqueue(num);}\\n  while (k) {\\n    const el = pq.dequeue().element;\\n    res += el;\\n    pq.enqueue(Math.ceil(el / 3));\\n    k--;\\n  }\\n  return res;\\n};"]}
{"id": "1659", "ref_js": ["var isItPossible = function (w1, w2) {\\n", "var isItPossible = function (word1, word2) {\\n  function getMap(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    return map;\\n  }\\n\\n  let m1 = getMap(word1);\\n  let size1 = m1.size;\\n  let m2 = getMap(word2);\\n  let size2 = m2.size;\\n\\n  let dif = Math.abs(m1.size - m2.size);\\n  if (dif > 2) return false;\\n  for (let [char1, cnt1] of m1) {\\n    for (let [char2, cnt2] of m2) {\\n      if (char1 === char2) {\\n        if (size1 === size2) return true;\\n      } else {\\n        ", "var isItPossible = function (word1, word2) {\\n  function getMap(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    return map;\\n  }\\n\\n  let m1 = getMap(word1);\\n  let size1 = m1.size;\\n  let m2 = getMap(word2);\\n  let size2 = m2.size;\\n\\n  let dif = Math.abs(m1.size - m2.size);\\n  if (dif > 2) return false;\\n  for (let [char1, cnt1] of m1) {\\n    for (let [char2, cnt2] of m2) {\\n      if (char1 === char2) {\\n        if (size1 === size2) return true;\\n      } else {\\n        "]}
{"id": "1660", "ref_js": ["var rangeAddQueries = function(n, queries) {\\n    let prefix = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));\\n    let a = new Array(n).fill(0).map(() => new Array(n).fill(0));\\n    for (let x of queries) {\\n        let r1 = x[0], c1 = x[1], r2 = x[2], c2 = x[3];\\n        for (let j = r1; j <= r2; j++) {\\n            prefix[j][c1]++;\\n            prefix[j][c2 + 1]--;\\n        }\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            sum += prefix[i][j];\\n            a[i][j] += sum;\\n        }\\n    }\\n    return a;\\n};", "var rangeAddQueries = function (n, queries) {\\n  const mat = new Array(n).fill().map(() => new Array(n).fill(0));\\n  for (let q of queries) {\\n    for (let i = q[0]; i <= q[2]; i++) {\\n      for (let j = q[1]; j <= q[3]; j++) {\\n        mat[i][j]++;\\n      }\\n    }\\n  }\\n  return mat;\\n};", "var rangeAddQueries = function(n, queries) {\\n    let prefix = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));\\n    let a = new Array(n).fill(0).map(() => new Array(n).fill(0));\\n    for (let x of queries) {\\n        let r1 = x[0], c1 = x[1], r2 = x[2], c2 = x[3];\\n        for (let j = r1; j <= r2; j++) {\\n            prefix[j][c1]++;\\n            prefix[j][c2 + 1]--;\\n        }\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            sum += prefix[i][j];\\n            a[i][j] += sum;\\n        }\\n    }\\n    return a;\\n};"]}
{"id": "1661", "ref_js": ["var countGood = function(nums, k) {\\n  let n = nums.length, count = {}, goodPairs = 0, ans = 0;\\n  for (let j = 0, i = 0; j < n; j++) {\\n    goodPairs += count[nums[j]] || 0;\\n    count[nums[j]] = (count[nums[j]] || 0) + 1;\\n    while (goodPairs >= k) {\\n      goodPairs -= --count[nums[i]];\\n      i++;\\n    }\\n    ans += i;\\n  }\\n  return ans;\\n};", "var countGood = function(nums, k) {\\n   Nested Loop:\\n   ------------\\n    \\n    let goodSubArrayCount = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        let count = 0;\\n        const goodSubArray = new Map();\\n        goodSubArray.set(nums[i], 1);\\n        for(let j= i + 1; j < nums.length; j++) {\\n            if(goodSubArray.has(nums[j])) {\\n                goodSubArray.set(nums[j], goodSubArray.get(nums[j]) + 1);\\n                count += goodSubArray.get(nums[j]) - 1;\\n            } else {\\n                goodSubArray.set(nums[j], 1);\\n          }\\n\\n          if(count >= k) {\\n            goodSubArrayCount++;\\n          }\\n        }\\n    }\\n    return goodSubArrayCount;\\n\\n    Sliding Window:\\n    ---------------\\n    \\n    \\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n        if(frequencySet.has(nums[j])) {\\n            pairsCount -= calculateFrequency(frequencySet.get(nums[j]));\\n            frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n        } else {\\n            frequencySet.set(nums[j], 1);\\n        }\\n\\n        pairsCount += calculateFrequency(frequencySet.get(nums[j]));\\n        while(pairsCount >= k) {\\n            goodSubArrayCount += nums.length - j;\\n            pairsCount -= calculateFrequency(frequencySet.get(nums[i]));\\n            if(frequencySet.get(nums[i]) > 1) {\\n                frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n                pairsCount += calculateFrequency(frequencySet.get(nums[i]));\\n            } else {\\n                frequencySet.delete(nums[i]);\\n            }\\n            i++;\\n        }\\n        j++;\\n    }\\n    return goodSubArrayCount;\\n};", "var countGood = function(nums, k) {\\n    const count = new Map();\\n    let totalPairs = 0;\\n    let res = 0;\\n    for (let i = 0, j = 0; i < nums.length; i++) {\\n        const n = nums[i];\\n        if (count.get(n) !== undefined) totalPairs += count.get(n), count.set(n, count.get(n) + 1);\\n        else count.set(n, 1);\\n        while (totalPairs >= k) {\\n            const m = nums[j];\\n            count.set(m, count.get(m) - 1);\\n            totalPairs -= count.get(m);\\n            res += nums.length - i;\\n            j++;\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "1662", "ref_js": ["var minOperations = function (nums1, nums2, k) {\\n  let posSum = 0, negSum = 0;\\n  for (let i = 0; i < nums1.length; i++) {\\n    let diff = nums1[i] - nums2[i];\\n    diff > 0 ? posSum += diff : negSum += diff;\\n    }\\n  if (posSum === 0 && negSum === 0) return 0;\\n  if (posSum + negSum !== 0 || posSum < k || k === 0 || posSum % k) return -1;\\n  return posSum / k;\\n};", "var minOperations = function(nums1, nums2, k) {\\n    \\n    let count = 0, balance = 0;\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        \\n        const diff = nums1[i] - nums2[i];\\n        \\n        if(diff % k) return -1;\\n        \\n        if(k === 0 && diff !== 0) return -1;\\n        \\n        count += diff > 0 ? diff / k : 0;\\n        balance += diff;\\n    }\\n    \\n    return balance === 0 ? count : -1;\\n};", "var minOperations = function (a, b, k) {\\n  let sum = 0;\\n  let count = 0;\\n  let i = -1;\\n  for (let e1 of a) {\\n    i++;\\n    let e2 = b[i];\\n    if (k) {\\n      let diff = e1 - e2;\\n      if (diff % k !== 0) return -1;\\n      sum += diff;\\n      count += Math.abs(diff / k);\\n    } else {\\n      if (e1 != e2) return -1;\\n    }\\n  }\\n  if (sum !== 0) return -1;\\n  return count / 2;\\n};"]}
{"id": "1663", "ref_js": ["var maxScore = function(nums1, nums2, k) {\\n    ", "var maxScore = function(nums1, nums2, k) {\\n\\n    let result = 0;\\n    let totalSum = 0;\\n    let heap = new MinPriorityQueue({priority: (element) => element})\\n\\n    const merged = nums1.map((nums1Val, i) => [nums2[i], nums1Val])\\n    merged.sort((a,b) => b[0] - a[0])\\n\\n    for (const [maxOf2, num1Val] of merged){\\n        if(heap.size() === k){\\n            totalSum -= heap.dequeue().element\\n        }\\n\\n        totalSum += num1Val\\n        heap.enqueue(num1Val)\\n\\n        if(heap.size() === k){\\n            result = Math.max(result, totalSum * maxOf2)\\n        }\\n\\n    }\\n\\nreturn result\\n};", "var maxScore = function(nums1, nums2, k) {\\n   let minHeap = new MinPriorityQueue();\\n   let zipped = nums1.map((num1, i) => [num1, nums2[i]]);\\n   zipped.sort((a, b) => b[1] - a[1]);\\n\\n   let answer = 0; sum = 0;\\n   for(let [num, min] of zipped){\\n       minHeap.enqueue(num);\\n       sum += num;\\n\\n       if(minHeap.size() == k){\\n           answer = Math.max(answer, sum * min);\\n           sum -= minHeap.dequeue().element\\n       }\\n   }   \\n  return answer;\\n};"]}
{"id": "1664", "ref_js": ["var sortTheStudents = function(score, k) {\\n   for (let i = 0; i < score.length; i++) {\\n    for (let j = 0; j < score.length; j++) {\\n      if (score[i][k] > score[j][k]) {\\n        [score[i], score[j]] = [score[j], score[i]];\\n      }\\n    }\\n  }\\n  return score;  \\n};", "var sortTheStudents = function(score, k) {\\n    return score.sort((a,b) => b[k]-a[k])\\n};", "var sortTheStudents = function(score, k) {\\n    let res = [];\\n    let len = score.length;\\n    for (let i = 0; i < len; i++) {\\n        let v = score[i].slice(); \\n        res.push([score[i][k], v]);\\n    }\\n\\n    res.sort((a, b) => b[0] - a[0]); \\n    let ans = [];\\n    for (let i = 0; i<len; i++) {\\n        ans.push(res[i][1]);\\n    }\\n\\n    return ans;\\n};"]}
{"id": "1665", "ref_js": ["var makeStringsEqual = function(s, target) {\\n  if (!s.includes(\"1\") && target.includes(\"1\")) return false; \\n  if (s.includes(\"1\") && !target.includes(\"1\")) return false; \\n  return true;\\n};", "var makeStringsEqual = function(s, target) {\\n    let n=s.length;\\n    let c1=false,c2=false;\\n    for(let i=0 ; i<n;  i++){\\n        if(s[i]&1){\\n            c1=true;\\n            break;\\n        }\\n    }\\n    for(let i=0 ; i<n;  i++){\\n        if(target[i]&1){\\n            c2=true;\\n            break;\\n        }\\n    }\\n    return c1==c2;\\n};", "var makeStringsEqual = function(s, target) {\\n       let sCount = 0\\n       let tCount = 0\\n       if(s===target) return true\\n\\n       for(let i = 0; i < s.length; i++) {\\n           const currS = s[i]\\n           const currT = target[i]\\n\\n           sCount += Number(currS)\\n           tCount += Number(currT)\\n       }\\n\\n       if(sCount > 0 && tCount > 0) return true\\n       return false\\n};"]}
{"id": "1666", "ref_js": ["var monkeyMove = function(n) {\\n    const mod = 1000000007n; \\n    let ans = 1n;\\n    let x = 2n;\\n    let N = n;\\n    while(N>0)\\n    {\\n        if(N%2===1)\\n        {\\n            ans = (ans * x) % mod;\\n        }\\n        x = (x * x) % mod;\\n        N = Math.floor(N/2);\\n    }\\n    return Number((ans - 2n + mod ) % mod);\\n};", "var monkeyMove = function(n) {\\n    const MOD = BigInt(10**9 +7)\\n    \\n    function pow(num,power) {\\n        if(power===1) return num\\n        if(power===0) return 1\\n        const half = BigInt(pow(num,Math.floor(power/2)))\\n\\n        return power % 2 === 0 ? (half*half)%MOD : (num*half*half)%MOD\\n    }\\n    \\n    const res = pow(BigInt(2),n)\\n    \\n    ", "var monkeyMove = function(n) {\\n    const MOD = BigInt(10**9 +7)\\n    \\n    function pow(num,power) {\\n        if(power===1) return num\\n        if(power===0) return 1\\n        const half = BigInt(pow(num,Math.floor(power/2)))\\n\\n        return power % 2 === 0 ? (half*half)%MOD : (num*half*half)%MOD\\n    }\\n    \\n    const res = pow(BigInt(2),n)\\n    \\n    "]}
{"id": "1667", "ref_js": ["var maxCount = function (banned, n, maxSum) {\\n  banned = new Set(banned)\\n  let sum = 0\\n  let chosenCount = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (banned.has(i)) continue\\n    if ((sum + i) > maxSum) break\\n    sum += i\\n    chosenCount++\\n  }\\n  return chosenCount\\n};", "var maxCount = function (banned, n, maxSum) {\\n  banned = new Set(banned)\\n  let sum = 0\\n  let chosenCount = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (banned.has(i)) continue\\n    if ((sum + i) > maxSum) break\\n    sum += i\\n    chosenCount++\\n  }\\n  return chosenCount\\n};", "var maxCount = function (banned, n, maxSum) {\\n  banned = new Set(banned)\\n  let sum = 0\\n  let chosenCount = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (banned.has(i)) continue\\n    if ((sum + i) > maxSum) break\\n    sum += i\\n    chosenCount++\\n  }\\n  return chosenCount\\n};"]}
{"id": "1668", "ref_js": ["var maximizeWin = function(prizePositions, k) {\\n    const n = prizePositions.length;\\n    let dp = new Array(n + 1).fill(0);\\n    let j = 0;\\n    let res = 0;\\n    for(let i = 0; i < n; i++) {\\n        while(prizePositions[i] > prizePositions[j] + k){\\n            j++;\\n        }\\n        let len = i - j + 1;\\n        dp[i + 1] = Math.max(dp[i], len);\\n        res = Math.max(res, dp[j] + len);\\n    }\\n    \\n    return res;\\n};", "var maximizeWin = function(prizePositions, k) {\\n  const dp = {};", "var maximizeWin = function(prizePositions, k) {\\n    const n = prizePositions.length;\\n    let dp = new Array(n + 1).fill(0);\\n    let j = 0;\\n    let res = 0;\\n    for(let i = 0; i < n; i++) {\\n        while(prizePositions[i] > prizePositions[j] + k){\\n            j++;\\n        }\\n        let len = i - j + 1;\\n        dp[i + 1] = Math.max(dp[i], len);\\n        res = Math.max(res, dp[j] + len);\\n    }\\n    \\n    return res;\\n};"]}
{"id": "1669", "ref_js": ["var isPossibleToCutPath = function(grid) {\\n    const path = hasPath(0, 0, grid);\\n\\n    if (!path) return true;\\n    \\n    return !hasPath(0, 0, grid);\\n};", "var isPossibleToCutPath = function(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length\\n    \\n    ", "var isPossibleToCutPath = function(grid) {\\n    const dirs = [[1, 0], [0, 1]];\\n    const m = grid.length, n = grid[0].length;\\n\\n    const dfs = function(i, j) {\\n        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {\\n            return false;\\n        }\\n\\n        if (i === m - 1 && j === n - 1) {\\n            return true;\\n        }\\n\\n        grid[i][j] = 0;\\n\\n        for (let [dx, dy] of dirs) {\\n            if(dfs(i + dx, j + dy)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    dfs(0, 0)\\n    grid[0][0] = 1;\\n    return !dfs(0, 0);\\n};"]}
{"id": "1670", "ref_js": ["var vowelStrings = function(words, queries) {\\n    for (let index = 0; index < words.length; index++) {\\n        if (vowels[words[index][0]] && vowels[words[index][words[index].length - 1]]) {\\n            if (!index) {\\n                words[index] = 1;\\n            } else {\\n                words[index] = 1 + words[index - 1];\\n            }\\n        } else {\\n            if (!index) {\\n                words[index] = 0;\\n            } else {\\n                words[index] = words[index - 1];\\n            }\\n        }\\n    }\\n    const output = [];\\n    for (let index = 0; index < queries.length; index++) {\\n        const [startIndex, endIndex] = queries[index];\\n        let len = words[endIndex] - (words[startIndex - 1] || 0);\\n        output.push(len);\\n    }\\n    return output;\\n};", "var checkString = function(str){\\n    return /^[aeiou]$|^[aeiou].*[aeiou]$/.test(str);\\n};", "var checkString = function(str){\\n    return /^[aeiou]$|^[aeiou].*[aeiou]$/.test(str);\\n};"]}
{"id": "1671", "ref_js": ["var minCapability = function(nums, k) {\\n  let min = nums[0], max = nums[0];\\n  let n = nums.length;\\n  for (let i = 0; i < n; i++) {\\n    min = Math.min(min, nums[i]);\\n    max = Math.max(max, nums[i]);\\n  }\\n  let low = min, high = max;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isEnough(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n  \\n  function isEnough(max) { ", "var helper = function(nums,k,mid) {\\n     let i = 0\\n     while (i < nums.length){\\n         if(nums[i] <= mid) {\\n             k--\\n             i+=2\\n         } else {\\n             i++\\n         }\\n         if(k === 0){\\n             return true\\n         }\\n     }\\n     return false\\n }\\nvar minCapability = function(nums, k) {\\n    ", "var minCapability = function(nums, k) {\\n    let min = Math.min(...nums)\\n    let max = Math.max(...nums)\\n    let lowest = min\\n    let highest = max\\n    while (lowest < highest) {\\n      const mid = Math.floor((lowest + highest) / 2)\\n      let houses = 0\\n      let isAtCapacity = false\\n      for (let i = 0; i < nums.length && !isAtCapacity; i++) {\\n        if (nums[i] <= mid) {\\n          houses++;\\n          i++;\\n        }\\n        if (houses === k) isAtCapacity = true\\n      }\\n      if (isAtCapacity) highest = mid\\n      else lowest = mid + 1\\n    }\\n    return lowest;\\n};"]}
{"id": "1672", "ref_js": ["var countFairPairs = function(nums, lower, upper) {\\n  let n = nums.length, pairs = 0;\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < n - 1; i++) {\\n    let lowerBound = lower_bound(i); \\n    let upperBound = upper_bound(i);\\n    pairs += Math.max(0, upperBound - lowerBound + 1);\\n  }\\n  return pairs;\\n  \\n  function lower_bound(i) {\\n    ", "var countFairPairs = function(nums, lower, upper) {\\n    nums.sort((a, b) => a - b);\\n    const countless = (val) => {\\n        let res = 0;\\n        for (let i = 0, j = nums.length - 1; i < j; ++i) {\\n            while (i < j && nums[i] + nums[j] > val) --j;\\n            res += j - i;\\n        }\\n        return res;\\n    };", "var countFairPairs = function(nums, lower, upper) {\\n    nums.sort((a,b) => a - b)\\n    const N = nums.length\\n\\n    function lowerbound(target, arr, left, right) {\\n        while(left < right) {\\n            const mid = Math.floor(left + (right- left)/2)\\n\\n            if(arr[mid] >= target) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        if(left === arr.length) {\\n            return -1\\n        }\\n\\n        return left\\n    }    \\n\\n    function upperbound(target, arr, left, right) {\\n        while(left < right) {\\n            const mid = Math.floor(left + (right- left)/2)\\n\\n            if(arr[mid] > target) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        if(left === 0) {\\n            return -1\\n        }\\n\\n        return left-1\\n    }\\n\\n    let res = 0\\n\\n    for(let i = 0; i < nums.length-1; i++) {\\n        const curr = nums[i]\\n        const lowerNeededValue = lower - curr\\n        const upperNeededValue = upper - curr\\n\\n        const lowerNeededValueIdx = lowerbound(lowerNeededValue,nums, i+1,N)\\n        const upperNeededValueIdx = upperbound(upperNeededValue,nums, i+1,N)\\n        if(lowerNeededValueIdx === -1) continue\\n        if(upperNeededValueIdx === -1) continue\\n\\n        res += Math.max(upperNeededValueIdx - lowerNeededValueIdx+1, 0)\\n    }\\n\\n    return res\\n};"]}
{"id": "1673", "ref_js": ["var substringXorQueries = function(s, queries) {\\n    \\n    var ans=[];\\n    for(let i=0;i<queries.length;i++)\\n        {\\n            var x=queries[i][0]^queries[i][1];\\n            var y=x.toString(2);\\n            var j=s.indexOf(y);\\n            if(j==-1)ans.push([j,j]);\\n            else ans.push([j,j+y.length-1]);\\n        }\\n    return ans;\\n};", "var substringXorQueries = function(s, queries) {\\n  const memo = new Array(30);\\n  const n = s.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] === \\'0\\') {\\n      if (!memo[0]) memo[0] = [i, i];\\n      continue;\\n    }\\n\\n    let num = 0;\\n    for (let j = i; j < Math.min(i + 30, n); j++) {\\n      num = (num << 1) | +s[j];\\n      if (!memo[num]) memo[num] = [i, j];\\n    }\\n  }\\n\\n  return queries.map(([a, b]) => memo[a ^ b] ?? [-1, -1]);\\n};", "var substringXorQueries = function(s, queries) {\\n    "]}
{"id": "1674", "ref_js": ["var minimizeSum = function(nums) { \\n    let arr = nums.sort((a,b) => a - b);\\n    let end = nums.length -1;\\n    \\n    return Math.min(nums[end-2]-nums[0], nums[end-1]-nums[1], nums[end]-nums[2]);\\n};", "var minimizeSum = function(nums) {\\n    nums.sort((a, b) => a - b)\\n    \\n    return Math.min(\\n        nums.at(-3) - nums[0],\\n        nums.at(-2) - nums[1],\\n        nums.at(-1) - nums[2]\\n    )\\n};", "var minimizeSum = function(nums) {\\n    nums.sort((a, b) => a - b)\\n    \\n    return Math.min(\\n        nums.at(-3) - nums[0],\\n        nums.at(-2) - nums[1],\\n        nums.at(-1) - nums[2]\\n    )\\n};"]}
{"id": "1675", "ref_js": ["var minImpossibleOR = function(nums) {\\n    let set = new Set()\\n    for(let i = 0; i < nums.length; i++){\\n        set.add(nums[i])\\n    }\\n    \\n    for (let i = 0; i <= 32; i++){\\n        let num = Math.pow(2, i)\\n        if(!set.has(num)){\\n            return num\\n        }\\n    }\\n    \\n};", "var minImpossibleOR = function(nums) {\\n    let cummRes = 0;\\n    for (const num of nums){\\n        if ((num & (num-1)) == 0)\\n            cummRes |= num;\\n    }\\n    cummRes = ~cummRes;\\n    return (cummRes & (-cummRes));\\n};", "var minImpossibleOR = function (a) {\\n    let set = new Set(a);\\n\\n    for (let i = 0; i < 32; i++)\\n        if (!set.has(1 << i)) {\\n            return 1 << i;\\n        }\\n\\n    return -1;\\n};"]}
{"id": "1676", "ref_js": ["var minOperations = function (n) {\\n  let oneArr = [];\\n  let ans = 0;\\n  while (n !== 0) {\\n    if (n % 2 === 1) {\\n      ans++;\\n      if (n === 1 || (n & 2) === 0) n--;\\n      else n++;\\n    } else n /= 2;\\n  }\\n\\n  return ans;\\n};", "var minOperations = function(n) {\\n    let operations = 0;\\n    let mask = 0x1;\\n    let prev = 0;\\n    let subtract = true;\\n    while (n !== 0) {\\n        const digit = mask & n;\\n        if (digit === mask && prev === 0) {\\n            prev = mask;\\n            subtract = true;\\n            mask <<= 1;\\n        } else if (digit === mask && prev !== 0) {\\n            subtract = false;\\n            mask <<= 1;\\n        } else if (digit === 0 && prev !== 0 && subtract) {\\n            n -= prev;\\n            mask = 1;\\n            prev = 0;\\n            operations++;\\n        } else if (digit === 0 && prev !== 0){\\n            n += prev;\\n            prev = 0;\\n            operations++;\\n        } else {\\n            mask <<= 1;\\n        }\\n    }\\n\\n    return operations;\\n};", "var minOperations = function(n) {\\n    let nearestSmaller=0;\\n    let nearestLarger=0;\\n    for(i=1;i<Number.MAX_SAFE_INTEGER;i*=2){\\n        if(i>n){nearestLarger=i; break;}\\n        if(i>nearestSmaller){nearestSmaller=i;}\\n    }\\n    if(n==nearestSmaller || n==nearestLarger){return 1}\\n    let smallerTarget = n-nearestSmaller;\\n    let largerTarget=nearestLarger-n;\\n    return 1+Math.min(minOperations(smallerTarget),minOperations(largerTarget))\\n};"]}
{"id": "1677", "ref_js": ["var squareFreeSubsets = function (nums) {\\n  const LEN = nums.length;\\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n\\n  function getMask(num) {\\n    let mask = 0;\\n    for (let i = 0; i < 10; i++) {\\n      let samePrimeCount = 0;\\n      while (num % primes[i] === 0) {\\n        samePrimeCount += 1;\\n        num /= primes[i];\\n      }\\n      if (samePrimeCount > 1) return -1; ", "var squareFreeSubsets = function(nums) {\\n    const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], mod = 1e9 + 7;\\n    const numsFactors = nums\\n        .filter(num => primes.every((prime) => num % prime ** 2 > 0))\\n        .map((num) => primes.reduce((acc, prime) => (acc << 1) | (num % prime == 0), 0));\\n\\n    const prevState = Array(1024).fill(0), curState = Array(1024)\\n    prevState[0] = 1;\\n\\n    for (const numsFactor of numsFactors) {\\n        curState.fill(0);\\n\\n        for (let i = 0; i < 1024; i++) {\\n            if ((i & numsFactor) == 0)\\n                curState[i ^ numsFactor] = \\n                    (curState[i ^ numsFactor] + prevState[i]) % mod;\\n        }\\n\\n        curState.forEach((val, idx) =>\\n            prevState[idx] = (val + prevState[idx]) % mod);\\n    }\\n\\n    return (prevState.reduce((acc, cur) => (acc + cur) % mod) + mod - 1) % mod;\\n};", "var squareFreeSubsets = function (nums) {\\n  const LEN = nums.length;\\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\\n\\n  function getMask(num) {\\n    let mask = 0;\\n    for (let i = 0; i < 10; i++) {\\n      let samePrimeCount = 0;\\n      while (num % primes[i] === 0) {\\n        samePrimeCount += 1;\\n        num /= primes[i];\\n      }\\n      if (samePrimeCount > 1) return -1; "]}
{"id": "1678", "ref_js": ["var divisibilityArray = function(word, m) {\\n    const ans = [];\\n\\n    let num = 0, carry = 0;\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        num = Number(carry + word[i]);\\n        carry = num % m;\\n        ans.push(carry ? 0 : 1);\\n    }\\n    \\n    return ans;\\n};", "var divisibilityArray = function(word, m) {\\n    const n = word.length;\\n    const ans = new Array(n).fill(0);\\n    let num = 0;\\n    for(let i = 0; i<n; i++) {\\n        num += parseInt(word[i]);\\n        if( num % m === 0) {\\n            ans[i] = 1;\\n        }\\n        num = (num * 10)  % m; ", "var divisibilityArray = function(word, m) {\\n    const result = (new Array(word.length)).fill(0)\\n    let rest = 0\\n    for(let i = 0; i < word.length; i++) {\\n        rest = (rest * 10 + (word[i] - \\'0\\')) % m\\n        if(rest == 0){\\n            result[i] = 1\\n        }\\n    }\\n    \\n    return result\\n};"]}
{"id": "1679", "ref_js": ["var maxNumOfMarkedIndices = function(nums) {\\n   nums.sort((a,b) => a-b)\\n   let i = 0\\n   let end = Math.floor(nums.length / 2)\\n   let j = end\\n   let res = 0;\\n   while(i < end && j < nums.length){\\n       if(2*nums[i] <= nums[j]){\\n           res+=2\\n           i++\\n       }\\n       j++\\n   }\\n\\n   return res\\n};", "var maxNumOfMarkedIndices = function(nums) {\\n     const n = nums.length;\\n  nums.sort((a, b) => a - b); ", "var maxNumOfMarkedIndices = function(nums) {\\n    var count=0;\\n    nums.sort((a,b)=>a-b);\\n    var len=nums.length;\\n    var mid=Math.floor((nums.length+1)/2);\\n    while(mid<len){\\n        if((nums[count]*2)<=nums[mid]){\\n            count++;\\n        }\\n        mid++;\\n    }\\n    return count*2;\\n};"]}
{"id": "1680", "ref_js": ["var coloredCells = function(n) {\\n    let sum = 1\\n    let add = 4\\n    for(let i = 2; i <=n; i++ ){\\n        sum += add;\\n        add += 4;\\n    }\\n    \\n    return sum\\n};", "var coloredCells = function(n) {\\n    return Math.pow(n,2) + Math.pow(n-1,2)\\n};", "var coloredCells = function(n) {\\n    return (n*n) + ((n-1)*(n-1))\\n};"]}
{"id": "1681", "ref_js": ["var countWays = function (intervals) {\\n    intervals = merge(intervals);\\n\\n    let two = BigInt(2);\\n    let n = BigInt(intervals.length);\\n    let MOD = BigInt(10 ** 9 + 7);\\n\\n    return two ** n % MOD;\\n};", "var countWays = function(ranges) {\\n    let mod = Math.pow(10, 9) + 7\\n    ranges.sort((r1, r2) => r1[0] - r2[0])\\n    \\n    let res = [ranges[0]]\\n    for(let next of ranges){\\n        let prev = res[res.length-1]\\n        ", "var countWays = function(ranges) {\\n    const mergedRanges = merge(ranges);\\n    const m = BigInt(Math.pow(10, 9) + 7);\\n\\n    let result = 2n;\\n\\n    for (let i = 1; i < mergedRanges.length; i++) {\\n        result *= 2n;\\n    }\\n\\n    return result % m;\\n};"]}
{"id": "1682", "ref_js": ["var kthLargestLevelSum = function (root, k) {\\n    const config = {};", "var kthLargestLevelSum = function (root, k, level = 1) {\\n\\n    const resMap = new Map();\\n    const result = []\\n    let c = resMap.get(level)\\n    c ? resMap.set(level, c + root.val) : resMap.set(level, root.val);\\n    sumLevel(root, 2, resMap);\\n\\n    resMap.forEach((val, key) => result.push(val));\\n    result.sort((a, b) => b - a);\\n    return (result[k - 1]) || -1\\n\\n};", "var kthLargestLevelSum = function (root, k, level = 1) {\\n\\n    const resMap = new Map();\\n    const result = []\\n    let c = resMap.get(level)\\n    c ? resMap.set(level, c + root.val) : resMap.set(level, root.val);\\n    sumLevel(root, 2, resMap);\\n\\n    resMap.forEach((val, key) => result.push(val));\\n    result.sort((a, b) => b - a);\\n    return (result[k - 1]) || -1\\n\\n};"]}
{"id": "1683", "ref_js": ["var maxScore = function(nums) {\\n    nums.sort((a,b)=>{return b-a})\\n    let n = 0\\n    let c = nums[n]\\n    while(c > 0){\\n        n++\\n        c += nums[n]\\n    }\\n    return n\\n};", "var maxScore = function(nums) {\\n    ", "var maxScore = function(nums) {\\n    nums.sort((a,b)=>{return b-a})\\n    let n = 0\\n    let c = nums[n]\\n    while(c > 0){\\n        n++\\n        c += nums[n]\\n    }\\n    return n\\n};"]}
{"id": "1684", "ref_js": ["var beautifulSubarrays = function(nums) {\\n    let res = 0\\n    let map = new Map();\\n    map.set(0, 1);\\n    let xor = 0;\\n    for(let no of nums) {\\n        xor = xor ^ no;\\n        if(map.has(xor)) {\\n            res = res + map.get(xor);\\n            map.set(xor, map.get(xor) + 1)\\n        } else {\\n            map.set(xor, 1)\\n        }\\n    }\\n    return res;\\n};", "var beautifulSubarrays = function(nums) {\\n  let mask = 0, count = new Map(), ans = 0;\\n  count.set(0, 1);\\n  for (let i = 0; i < nums.length; i++) {\\n    mask = mask ^ nums[i];\\n    ans += (count.get(mask) || 0);\\n    count.set(mask, (count.get(mask) || 0) + 1);\\n  }\\n  return ans;\\n};", "var beautifulSubarrays = function(nums) {\\n    let ans = 0;\\n    let current = 0;\\n    "]}
{"id": "1685", "ref_js": ["var maximizeGreatness = function(nums) {\\n    nums.sort((a,b) => a - b)\\n    let res = 0;\\n    let j = 1;\\n    for(let i = 0; i < nums.length; i++){\\n        while(j < nums.length && nums[j] <= nums[i]){\\n            j++;\\n        }\\n        if(j < nums.length && nums[j] > nums[i]){\\n            j++;\\n            res++;\\n        }\\n    }\\n    \\n    return res\\n};", "var maximizeGreatness = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = 0, j = 0;\\n    while (j < nums.length) {\\n        if (nums[i] < nums[j]) {\\n            i++;\\n        }\\n        j++;\\n    }\\n    return i;\\n};", "var maximizeGreatness = function(nums) {\\n    let greatness = 0;\\n    let startIdx = 0;\\n    let idx = 1;\\n    let unusedIdx = 1;\\n\\n    nums.sort((a, b) => a - b);\\n\\n    while (unusedIdx < nums.length) {\\n        while (idx < nums.length && nums[idx] === nums[idx - 1]) {\\n            idx++;\\n        }\\n\\n        unusedIdx = Math.max(unusedIdx, idx); "]}
{"id": "1686", "ref_js": ["var findScore = function(nums) {\\n    let arr = nums.map((n, i) => ({val: n, index: i}));\\n    const marked = new Set();\\n    \\n    arr.sort((a, b) => {\\n        if (a.val === b.val){\\n            return a.index - b.index;\\n        }\\n        return a.val - b.val;\\n    });\\n\\n    let res = 0;\\n    for(let n of arr) {\\n        if(!marked.has(n.index)){\\n            marked.add(n.index);\\n            marked.add(n.index-1);\\n            marked.add(n.index+1);\\n            res += n.val\\n        }\\n    }\\n    \\n    return res;\\n};", "var findScore = function(nums) {\\n    let marked = new Set()\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = [nums[i], i]\\n    }\\n    nums.sort((a,b) => a[0] - b[0])\\n    for (let i = 0; i < nums.length; i++){\\n        if (!marked.has(nums[i][1])){\\n            const pos = nums[i][1]\\n            marked.add(pos)\\n            marked.add(pos - 1)\\n            marked.add(pos + 1)\\n            res += nums[i][0]\\n        }\\n    }\\n    return res\\n};", "var findScore = function(nums) {\\n    let map = {};"]}
{"id": "1687", "ref_js": ["var repairCars = function(ranks, cars) {\\n    let counts = new Array(100).fill(0);\\n\\n    for (let i = 0; i < ranks.length; i++) {\\n        counts[ranks[i] - 1]++;\\n    }\\n\\n    let high = cars * cars * ranks[0];\\n    let low = 0;\\n\\n    let best = high;\\n    \\n    while (high > low) {\\n        let mid = Math.floor(low + ((high - low) / 2));\\n\\n        if (carsInMinutes(counts, mid) >= cars) {\\n            best = Math.min(best, mid);\\n\\n            high = mid;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n\\n    return best;\\n};", "var repairCars = function(ranks, cars) {\\n    const heap = new MinPriorityQueue()\\n    for(let r of ranks){\\n        heap.enqueue({rank: r, cars: 0}, r);\\n    }\\n    \\n    while(cars > 0) {\\n        const top = heap.dequeue().element;\\n        top.cars++;\\n        heap.enqueue(top, top.rank * Math.pow(top.cars + 1, 2))\\n        cars--;\\n    }\\n    \\n    let res = 0; \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        res = Math.max(Math.pow(top.cars, 2) * top.rank, res);\\n    }\\n    \\n    return res;\\n};", "var repairCars = function (ranks, cars) {\\n  let low = 1;\\n  let high = Math.max(...ranks) * cars * cars;\\n  let ans = high;\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (isOk(ranks, mid, cars)) {\\n      ans = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return ans;\\n};"]}
{"id": "1688", "ref_js": ["var checkValidGrid = function(grid) {\\n    let positions = {};", "var checkValidGrid = function(grid) {\\n    if(grid[0][0] != 0) return false;\\n    let N = grid.length;\\n    let xMove = [2, 1, -1, -2, -2, -1, 1, 2];\\n    let yMove = [1, 2, 2, 1, -1, -2, -2, -1];\\n    return solve(0, 0, 1, grid, xMove, yMove, N);\\n};", "var checkValidGrid = function (grid) {\\n    if (grid[0][0] !== 0) {\\n        return false;\\n    }\\n\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n\\n    const coordinatesConsecutiveMoves = new Array(this.rows * this.columns);\\n    fillArrayCoordinatesConsecutiveMoves(grid, coordinatesConsecutiveMoves);\\n\\n    return eachConsecutiveMoveIsValid(coordinatesConsecutiveMoves);\\n};"]}
{"id": "1689", "ref_js": ["var beautifulSubsets = function (A, k) {\\n\\n  function bt(a) {\\n    let n = a.length\\n    if (n === 0) return 0\\n    let s = 0\\n    for (let i = 0; i < n; i++) {\\n      let b = []\\n      for (let j = i + 1; j < n; j++) {\\n        if (Math.abs(a[i] - a[j]) !== k) {\\n          b.push(a[j])\\n        }\\n      }\\n      s += 1 + bt(b)\\n    }\\n    return s\\n  }\\n\\n  let s = bt(A)\\n  return s\\n};", "var beautifulSubsets = function(nums, k) { \\n    const dfs=(i,path)=>{\\n        if(i===nums.length) return 0;\\n\\n        let subset=0;\\n        if(!path.has(nums[i]+k) && !path.has(nums[i]-k)){\\n            path.set(nums[i],path.get(nums[i])+1||1);\\n            subset+=dfs(i+1, path)+1;\\n            path.set(nums[i],path.get(nums[i])-1);\\n            if(path.get(nums[i])===0)\\n                path.delete(nums[i]);\\n        }\\n        subset+=dfs(i+1, path);\\n        return subset\\n    }\\n    return dfs(0,new Map());\\n};", "var beautifulSubsets = function(nums, k) {\\n     "]}
{"id": "1690", "ref_js": ["var findSmallestInteger = function(nums, value) {\\n    nums = nums.map(num => {\\n        const val = num % value;\\n        if (val < 0) return val + value\\n        return val;\\n    });\\n            \\n    const freq = {};", "var findSmallestInteger = function(nums, value) {\\n    const mod = nums.map(e => {\\n        if (e >= 0) return e%value;\\n        if (e < 0) return Math.ceil(-e/value)*value + e;\\n    });\\n    const hash = Array(value).fill(0);\\n    mod.forEach(e => {\\n        hash[e] += 1;\\n    })\\n    const minMul = Math.min(...hash);\\n    const remainder = hash.indexOf(minMul);\\n    const output = value * minMul + remainder; \\n    return output;\\n};", "var findSmallestInteger = function(nums, val) {\\n    const mods = new Array(val + 1)\\n    mods.fill(0)\\n    \\n    for (let n of nums) {\\n        if (n < 0) {\\n            n = val - (-n) % val\\n        }\\n        const m = n % val\\n        mods[m]++\\n    }\\n    \\n    let res = 0\\n    let min = Number.POSITIVE_INFINITY\\n    \\n    for (let i = 0; i < val; i++) {\\n        const count = mods[i]\\n        if (count < min) {\\n            min = count\\n            res = (count * val) + i\\n        }\\n    }\\n    \\n    return res\\n};"]}
{"id": "1691", "ref_js": ["var primeSubOperation = function(nums) {\\n    function getPrimes(num) {\\n        let res = []\\n        let primes = new Array(num).fill(true)\\n        primes[0] = primes[1] = false\\n\\n        for(let i = 2; i <= Math.sqrt(num); ++i) {\\n            if(primes[i]) {\\n                for(let j = i * i; j <= num; j+=i) primes[j] = false\\n            }\\n        }\\n\\n        for(let i = 0; i <= num; ++i) if(primes[i]) res.push(i)\\n\\n        return res\\n    }\\n\\n    let primes = getPrimes(1010)\\n\\n    for(let i = nums.length - 1; i > 0; --i) {\\n        let j = 0\\n\\n        if (nums[i] > nums[i - 1]) continue\\n\\n        while (j <= primes.length - 1) {\\n            if(primes[j] >= nums[i-1]) return false\\n\\n            if((nums[i-1] - primes[j]) < nums[i]) {\\n                nums[i-1] = nums[i-1] - primes[j]\\n                needSub = false;\\n                break\\n            }\\n            j++\\n        }\\n    }\\n\\n    return true\\n};", "var primeSubOperation = function (nums) {\\n  const primes = generatePrimes(1000);\\n  const n = nums.length;\\n\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] < nums[i + 1]) continue;\\n\\n    let isOk = false;\\n    for (const prime of primes) {\\n      if (prime >= nums[i]) break;\\n\\n      const diff = nums[i] - prime;\\n      if (diff < nums[i + 1]) {\\n        nums[i] = diff;\\n        isOk = true;\\n        break;\\n      }\\n    }\\n\\n    if (!isOk) return false;\\n  }\\n\\n  return true;\\n};", "var primeSubOperation = function(nums) {\\n    let primes = getPrimes(1000);\\n    let n = nums.length;\\n    let prev = nums[n - 1];\\n    let needSub = false;\\n\\n    for(let i = n - 2; i >= 0; i--){\\n        if(nums[i] < prev){\\n            prev = nums[i];\\n            continue;\\n        }\\n\\n        needSub = true;  \\n        for(let p of primes){\\n            if(nums[i] <= p) break;\\n\\n            if(nums[i] - p < prev){\\n                prev = nums[i] - p;\\n                needSub = false;\\n                break;\\n            }\\n        }\\n        if(needSub) return false;\\n    }\\n    return true;\\n};"]}
{"id": "1692", "ref_js": ["var minOperations = function(nums, queries) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let left = [...nums], right = [...nums];\\n  for (let i = 1; i < n; i++) left[i] += left[i - 1];\\n  for (let i = n - 2; i >= 0; i--) right[i] += right[i + 1];\\n  let ans = [];\\n  for (let query of queries) {\\n    let splitIndex = getSplitIndex(query);\\n    let leftDiff = splitIndex > 0 ? query * splitIndex - left[splitIndex - 1] : 0;\\n    let rightDiff = splitIndex < n ? right[splitIndex] - query * (n - splitIndex) : 0;\\n    ans.push(leftDiff + rightDiff);\\n  }\\n  return ans;\\n  \\n  function getSplitIndex(query) {\\n    let low = 0, high = n - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nums[mid] >= query) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nums[low] >= query ? low : n;\\n  }\\n};", "var minOperations = function(nums, queries) {\\n    nums.sort((a,b)=>a-b);\\n    const pref=[0], post=Array(nums.length).fill().map(v=>0);\\n    \\n    for(let i=1;i<nums.length;i++){\\n        pref[i]=pref[i-1]+(nums[i]-nums[0]);\\n    }\\n\\n    for(let i=nums.length-2;i>=0;i--){\\n        post[i]=post[i+1]+(nums[nums.length-1]-nums[i]);\\n    }\\n    \\n    ", "var minOperations = function (nums, queries) {\\n  const n = nums.length;\\n  const m = queries.length;\\n  nums.sort((a, b) => a - b);\\n\\n  const preSum = [0];\\n  for (const num of nums) {\\n    const lastVal = preSum[preSum.length - 1];\\n    preSum.push(lastVal + num);\\n  }\\n\\n  const ans = new Array(m).fill();\\n  for (let i = 0; i < m; i++) {\\n    const idx = binarySearch(queries[i], nums);\\n    const leftLen = idx + 1;\\n    const expectedLeftSum = leftLen * queries[i];\\n    const preSumLeft = preSum[idx + 1];\\n\\n    const rightLen = n - leftLen;\\n    const expectedRightSum = rightLen * queries[i];\\n    const preSumRight = preSum[n] - preSum[idx + 1];\\n\\n    ans[i] = expectedLeftSum - preSumLeft + preSumRight - expectedRightSum;\\n  }\\n\\n  return ans;\\n};"]}
{"id": "1693", "ref_js": ["var maximumCostSubstring = function(s, chars, vals) {\\n    const charValues = {};", "var maximumCostSubstring = function(s, chars, vals) {\\n    let max = 0, ans = 0, values = Array.from({ length: 26 }, (_, i) => i + 1);\\n    for (let i = 0; i < chars.length; i++)\\n        values[chars.charCodeAt(i) - 97] = vals[i];\\n\\n    for (const char of s) {\\n        max = Math.max(0, max + values[char.charCodeAt() - 97]);\\n        ans = Math.max(ans, max)\\n    }\\n\\n    return ans;\\n};", "var maximumCostSubstring = function (input, chars, values) {\\n    const ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const costForChar = Array.from(Array(ALPHABET_SIZE).keys(), n => n + 1);\\n    for (let i = 0; i < chars.length; ++i) {\\n        costForChar[chars.codePointAt(i) - ASCII_SMALL_CASE_A] = values[i];\\n    }\\n\\n    let maxCost = 0;\\n    let currentCost = 0;\\n    for (let i = 0; i < input.length; ++i) {\\n        currentCost = Math.max(0, currentCost + costForChar[input.codePointAt(i) - ASCII_SMALL_CASE_A]);\\n        maxCost = Math.max(maxCost, currentCost);\\n    }\\n    return maxCost;\\n};"]}
{"id": "1694", "ref_js": ["var makeSubKSumEqual = function(arr, k) {\\n    let n = arr.length;\\n    let numbOfSets = gcd(n, k);\\n    let setSize = n / numbOfSets;\\n    let minOps = 0;\\n\\n    ", "var makeSubKSumEqual = function (arr, k) {\\n    let result = 0;\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        if (arr[i] === 0) continue;\\n        const temp = [];\\n        let j = i;\\n        while (arr[j] !== 0) {\\n            temp.push(arr[j]);\\n            arr[j] = 0;\\n            j = (j + k) % n;\\n        }\\n        temp.sort((a, b) => a - b);\\n        const midVal = temp[Math.floor(temp.length / 2)];\\n        for (const val of temp) {\\n            result += Math.abs(val - midVal);\\n        }\\n    }\\n\\n    return result;\\n};", "var makeSubKSumEqual = function(arr, k) {\\n    let n = arr.length;\\n    let numbOfSets = gcd(n, k);\\n    let setSize = n / numbOfSets;\\n    let minOps = 0;\\n\\n    "]}
{"id": "1695", "ref_js": ["var findMatrix = function(nums) {\\n    const arr = [];\\n    for (const iterator of nums) {\\n        if (!arr[iterator]) {\\n            arr[iterator] = 0;\\n        }\\n        arr[iterator] += 1;\\n    }\\n\\n    let anyValueFound = true;\\n    const output = [];\\n    let tempOutput = [];\\n    while (anyValueFound) {\\n        anyValueFound = false;\\n        tempOutput = [];\\n        for (let index = 0; index < arr.length; index++) {\\n            if (arr[index] > 0) {\\n                tempOutput.push(index);\\n                arr[index] -= 1;\\n                anyValueFound = true;\\n            }\\n        }\\n        if (anyValueFound) {\\n            output.push(tempOutput);\\n        }\\n    }\\n    return output;\\n};", "var findMatrix = function(nums) {\\n    const sortedNums = nums.slice().sort((a, b) => b - a);\\n    const result = [];\\n\\n    for (const num of sortedNums) {\\n        let added = false;\\n        for (const row of result) {\\n            if (!row.includes(num)) {\\n                row.push(num);\\n                added = true;\\n                break;\\n            }\\n        }\\n        if (!added) {\\n            result.push([num]);\\n        }\\n    }\\n    return result;\\n\\n};", "var findMatrix = function(nums) {\\n    let map = new Map();\\n    for(let i of nums){\\n        if(map.has(i)) map.set(i,map.get(i)+1);\\n        else map.set(i,1);\\n    }\\n    let arr= [...map];\\n    let res=[];\\n    while(1){\\n        let temp=[];\\n        for(let i=0;i<arr.length;i++){\\n            if(arr[i][1]!=0){\\n                temp.push(arr[i][0]);\\n                arr[i][1]--;\\n            }\\n        }\\n        if(!temp.length) return res;\\n        res.push(temp);\\n    }\\n};"]}
{"id": "1696", "ref_js": ["var miceAndCheese = function(reward1, reward2, k) {\\n    let arr=[];\\n    for(let i=0;i<reward1.length;i++){\\n        let x=reward1[i]-reward2[i];\\n        arr.push([x,i]);\\n    }\\n    arr.sort((a,b)=>b[0]-a[0]);\\n    let res=0;\\n    for(let i=0;i<reward1.length;i++){\\n        if(i<k) res+=reward1[arr[i][1]];\\n        else res+=reward2[arr[i][1]];    \\n    }\\n    return res;\\n    \\n};", "var miceAndCheese = function(reward1, reward2, k) {\\n  let n = reward1.length, rewards = [];\\n  for (let i = 0; i < n; i++) {\\n    rewards.push([reward1[i], reward2[i], reward1[i] - reward2[i]]);\\n  }\\n  rewards.sort((a, b) => b[2] - a[2]);\\n  let score = 0;\\n  for (let i = 0; i < n; i++) {\\n    score += i < k ? rewards[i][0] : rewards[i][1];\\n  }\\n  return score;\\n};", "var miceAndCheese = function(reward1, reward2, k) {\\n    return reward1\\n      .map((reward, idx) => [reward, reward2[idx], reward - reward2[idx]])\\n      .sort((b, a) => a[2] - b[2])\\n      .reduce((acc, [a, b], idx) => acc + (idx < k ? a : b), 0)\\n};"]}
{"id": "1697", "ref_js": ["var distance = function (a) {\\n    let m = new Map();\\n    a.forEach((e, i) => {\\n        if (!m.has(e)) m.set(e, []);\\n        m.get(e).push(i);\\n    });\\n\\n    let arr = []; ", "var distance = function(nums) {\\n  let n = nums.length, map = {};", "var distance = function(nums) {\\n    let arr = new Array(nums.length).fill(0);\\n    let map = {};"]}
{"id": "1698", "ref_js": ["var minimizeMax = function (nums, p) {\\n  if (p === 0) return 0;\\n  let n = nums.length - 1;\\n  nums.sort((a, b) => a - b);\\n  let low = 0,\\n    high = nums[n] - nums[0];\\n\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isValid(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n\\n  function isValid(max) {\\n    let i = 1,\\n      pairs = 0;\\n\\n    while (i <= n) {\\n      if (nums[i] - nums[i - 1] <= max) {\\n        pairs++;\\n        i = i + 2;\\n      } else {\\n        i++;\\n      }\\n      if (pairs == p) return true;\\n    }\\n    return false;\\n  }\\n};", "var minimizeMax = function (nums, p) {\\n  const n = nums.length;\\n  nums.sort((a, b) => a - b);\\n  let ans = null;\\n  let low = 0;\\n  let high = nums[n - 1];\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (isOk(nums, mid, p, n)) {\\n      ans = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return ans;\\n};", "var minimizeMax = function (nums, p) {\\n  if (p === 0) return 0;\\n  let n = nums.length - 1;\\n  nums.sort((a, b) => a - b);\\n  let low = 0,\\n    high = nums[n] - nums[0];\\n\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isValid(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n\\n  function isValid(max) {\\n    let i = 1,\\n      pairs = 0;\\n\\n    while (i <= n) {\\n      if (nums[i] - nums[i - 1] <= max) {\\n        pairs++;\\n        i = i + 2;\\n      } else {\\n        i++;\\n      }\\n      if (pairs == p) return true;\\n    }\\n    return false;\\n  }\\n};"]}
{"id": "1707", "ref_js": ["var findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};", "var findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};", "var findPrefixScore = function(nums) {\\n let res =[];\\n let sum =0;\\n let max= 0;\\n for(let i=0; i<nums.length; i++){\\n     if(nums[i]>max) max=nums[i];\\n     let x = nums[i]+max;\\n     sum+=x;\\n     res.push(sum);\\n }   \\n return res;\\n};"]}
{"id": "1708", "ref_js": ["var sumOfLevels = function (root) {\\n    const levelMapping = {};", "var replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};", "var replaceValueInTree = function(root) {\\n    const q=[root];\\n\\n    let levelSums={}, currLvl=0;\\n    while(q.length>0){\\n        let levelSize=q.length;\\n        while(levelSize-->0){\\n            const node = q.pop();\\n\\n            levelSums[currLvl]=(levelSums[currLvl]||0)+node.val;\\n\\n            if(node.left) q.unshift(node.left);\\n            if(node.right) q.unshift(node.right);\\n        }\\n        currLvl++;\\n    }\\n\\n    const dfs=(h,node)=>{\\n        if(!node) return;\\n\\n        let childSum=(node.left&&node.left.val||0)+(node.right&&node.right.val||0);\\n\\n        if(node.left){\\n            node.left.val=levelSums[h+1]-childSum;\\n        }\\n\\n        if(node.right){\\n            node.right.val=levelSums[h+1]-childSum;\\n        }\\n\\n        dfs(h+1,node.left);\\n        dfs(h+1,node.right);        \\n    }\\n\\n    dfs(0,root);\\n    root.val=0;\\n\\n    return root;\\n};"]}
{"id": "1709", "ref_js": ["var addMinimum = function(word) {\\n    let result = 0;\\n\\n    for (let i = 0; i < word.length; ++i) {\\n        if (word[i] === \"a\") {\\n            if (word[i + 1] === \"b\" && word[i + 2] === \"c\") i += 2; ", "var addMinimum = function(word) {\\n    const stack=[];\\n\\n    ", "var addMinimum = function(word) {\\n    const stack=[];\\n\\n    "]}
{"id": "1711", "ref_js": ["var getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {};", "var getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};", "var getSubarrayBeauty = function(nums, k, x) {\\n    const counts = new Array(101).fill(0);\\n    const result = new Array(nums.length - (k - 1)).fill(0);\\n    const prevK = k - 1;\\n    let index = -1;\\n    let pos;\\n\\n    for (let i = 0; i < nums.length; ++i) {\\n        ++counts[nums[i] + 50];\\n        if (i >= k) {\\n            --counts[nums[i - k] + 50];\\n        }\\n\\n        if (i >= prevK) {\\n            pos = x;\\n            index++;\\n            for (let j = 0; j < 50; ++j) { "]}
{"id": "1712", "ref_js": ["var minOperations = function (a) {\\n    let nori = a.length; ", "var minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};", "var minOperations = function (a) {\\n    let nori = a.length; "]}
{"id": "1713", "ref_js": ["var findThePrefixCommonArray = function (A, B) {\\n  const res = []\\n  const set = new Set()\\n\\n  let count = 0\\n\\n  for (let i = 0; i < A.length; i++) {\\n    if (set.has(A[i])) count++\\n    if (set.has(B[i])) count++\\n    if (A[i] === B[i]) count++\\n    set.add(A[i])\\n    set.add(B[i])\\n    res.push(count)\\n  }\\n\\n  return res\\n};", "var findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};", "var findThePrefixCommonArray = function(A, B) {\\n    let n = A.length, output = new Array(n).fill(0)\\n\\n    \\n\\n    \\n    let set = new Set(), count = 0\\n\\n    for (let i = 0; i<n; i++) {\\n        set.has(A[i]) && count++\\n        set.add(A[i])\\n\\n        set.has(B[i]) && count++\\n        set.add(B[i])\\n\\n        output[i] = count\\n    }\\n\\n    return output\\n};"]}
{"id": "1714", "ref_js": ["var findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    ", "var findMaxFish = function(grid) {\\n    let m = grid.length, n = grid[0].length, fishCount = 0;\\n\\n    ", "var findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};"]}
{"id": "1715", "ref_js": ["var firstCompleteIndex = function(arr, mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const map = {};", "var firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  const hash = {}\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      hash[mat[i][j]] = { i, j }\\n    }\\n  }\\n\\n  const rows = new Array(m).fill(0)\\n  const cols = new Array(n).fill(0)\\n\\n  let buff;\\n\\n  const last = m * n;\\n  for (let i = 0; i < last; i++) {\\n    buff = hash[arr[i]];\\n    rows[+buff.i]++\\n    cols[+buff.j]++\\n\\n    if (rows[+buff.i] === n || cols[+buff.j] === m) return i\\n  }\\n};", "var firstCompleteIndex = function(arr, mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const map = {};"]}
{"id": "1716", "ref_js": ["var minimumCost = function (startP, targetP, edges) {\\n    let [sx, sy] = startP;\\n    let [tx, ty] = targetP;\\n\\n    ", "var minimumCost = function (start, target, specialRoads) {\\n    const N = specialRoads.length;\\n    const dist = new Array(N).fill(Infinity)\\n    const heap = new Heap((a, b) => a[2] < b[2])\\n\\n    let min = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1])\\n\\n    heap.add([start[0], start[1], 0]);\\n\\n    while (heap.getSize()) {\\n        const [i, j, cost] = heap.poll();\\n\\n        const costToTarget = cost + Math.abs(i - target[0]) + Math.abs(j - target[1]);\\n                            \\n        min = Math.min(min, costToTarget);\\n\\n        for (let x = 0; x < N; x++) {\\n            const [x1, y1, x2, y2, c] = specialRoads[x];\\n\\n            const costTodist = cost + Math.abs(i - x1) + Math.abs(j - y1) + c;\\n\\n            if (costTodist < dist[x]) {\\n                dist[x] = costTodist\\n                heap.add([x2, y2, costTodist]);\\n            }\\n        }\\n    }\\n    return min\\n};", "var minimumCost = function(start, target, specialRoads) {\\n    let cost = Infinity\\n    const map = new Map()\\n    \\n    const dfs = (curDist, x, y) => {\\n        if (curDist > cost) return\\n        \\n        "]}
{"id": "1718", "ref_js": ["var colorTheArray = function (n, queries) {\\n  let nums = new Array(n).fill(0);\\n\\n  let numOfAdjEles = 0;\\n  let answer = new Array(queries.length);\\n\\n  for (let q = 0; q < queries.length; q++) {\\n    let [indexi, coloriTo] = queries[q];\\n    let currEle = nums[indexi];\\n\\n    if (currEle !== coloriTo) {\\n      let leftEle = nums[indexi - 1];\\n      let rightEle = nums[indexi + 1];\\n\\n      if (currEle) {\\n        ", "var colorTheArray = function (n, queries) {\\n  let counter = 0;\\n  const colors = new Array(n).fill(0);\\n  const ans = new Array(queries.length).fill();\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    const [idx, color] = queries[i];\\n    const prev = idx - 1 >= 0 ? colors[idx - 1] : 0;\\n    const next = idx + 1 < n ? colors[idx + 1] : 0;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter--;\\n    if (colors[idx] === next && colors[idx] > 0) counter--;\\n\\n    colors[idx] = color;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter++;\\n    if (colors[idx] === next && colors[idx] > 0) counter++;\\n\\n    ans[i] = counter;\\n  }\\n\\n  return ans;\\n};", "var colorTheArray = function(n, queries) {\\n    const nums = Array(n).fill(0);\\n    let count = 0;\\n    const res = [];\\n    \\n    for (const [index, color] of queries) {\\n        if (nums[index] === color) {\\n            res.push(count);\\n            \\n            continue;\\n        }    \\n        \\n        "]}
{"id": "1719", "ref_js": ["var minIncrements = function(n, cost) {\\n  let ans = 0;\\n  dfs(1);\\n  return ans;\\n  \\n  function dfs(i) { \\n    if (i * 2 > n) return cost[i - 1]; ", "var minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};", "var minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};"]}
{"id": "1720", "ref_js": ["var matrixSum = function(nums) {\\n    let sum = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i].sort((a, b) => a - b);\\n    }\\n    \\n    for (let i = 0; i < nums[0].length; i++) {\\n        let maxi = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            maxi = Math.max(nums[j][i], maxi);\\n        }\\n        sum += maxi;\\n    }\\n    \\n    return sum;\\n};", "var matrixSum = function(nums) {\\n        let n=nums.length;\\n    let m=nums[0].length;\\n    var score=0;\\n    for(let i=0;i<n;i++)\\n    {\\n      nums[i].sort((a,b)=>b-a)\\n    }\\n    console.log(nums)\\n  for(let i=0;i<m;i++)\\n  {\\n    let max=-Infinity;\\n    for(let j=0;j<n;j++)\\n    {\\n      max=Math.max(max,nums[j][i])\\n    }\\n    score+=max;\\n  }\\n  return score\\n};", "var matrixSum = function(nums) {\\n    \\n    if(!Array.isArray(nums) && nums.length === 0 ) return 0;\\n    \\n    let finalscore = 0;\\n\\n    nums.forEach((item) => {\\n        item.sort((a,b) => b - a)\\n    })\\n    for(let i = 0; i < nums[0].length; i++ ){\\n        finalscore += Math.max(...nums.map((item) => item[i]));\\n    }\\n    return finalscore;\\n};"]}
{"id": "1721", "ref_js": ["var maximumOr = function(nums, k) {\\n   let n = nums.length;\\n    let prev = [0n];\\n    let post = [0n];\\n    for (let i = 0; i < n; i++) prev.push(prev[prev.length - 1] | BigInt(nums[i]))\\n    for (let i = n - 1; i >= 0; i--) post.push(post[post.length - 1] | BigInt(nums[i]));\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) {\\n        let cur = BigInt(nums[i]);\\n        let v = cur * BigInt(2 ** k) | prev[i] | post[n - i - 1];\\n        if (v > res) {\\n            res = v;\\n        }\\n    }\\n    return Number(res);\\n};", "var maximumOr = function(nums, k) {\\n   let n = nums.length;\\n    let prev = [0n];\\n    let post = [0n];\\n    for (let i = 0; i < n; i++) prev.push(prev[prev.length - 1] | BigInt(nums[i]))\\n    for (let i = n - 1; i >= 0; i--) post.push(post[post.length - 1] | BigInt(nums[i]));\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) {\\n        let cur = BigInt(nums[i]);\\n        let v = cur * BigInt(2 ** k) | prev[i] | post[n - i - 1];\\n        if (v > res) {\\n            res = v;\\n        }\\n    }\\n    return Number(res);\\n};", "var maximumOr = function(nums, k) {\\n   let n = nums.length;\\n    let prev = [0n];\\n    let post = [0n];\\n    for (let i = 0; i < n; i++) prev.push(prev[prev.length - 1] | BigInt(nums[i]))\\n    for (let i = n - 1; i >= 0; i--) post.push(post[post.length - 1] | BigInt(nums[i]));\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) {\\n        let cur = BigInt(nums[i]);\\n        let v = cur * BigInt(2 ** k) | prev[i] | post[n - i - 1];\\n        if (v > res) {\\n            res = v;\\n        }\\n    }\\n    return Number(res);\\n};"]}
{"id": "1722", "ref_js": ["var doesValidArrayExist = function(derived) {\\n    let n = derived.length;\\n    let original = 1\\n    for(let i = 1; i < n; i++){\\n        original = original ^ derived[i - 1];\\n    }\\n    return 1 ^ original == derived[n - 1];\\n};", "var doesValidArrayExist = function(derived) {\\n\\n    let n = derived.length;\\n    \\n    let ans = 0;\\n    for(let i = 0; i < n; i++) {\\n        ans = ans ^ derived[i];\\n    }\\n\\n    return ans == 0\\n};", "var doesValidArrayExist = function(derived) {\\n\\n    let n = derived.length;\\n    \\n    let ans = 0;\\n    for(let i = 0; i < n; i++) {\\n        ans = ans ^ derived[i];\\n    }\\n\\n    return ans == 0\\n};"]}
{"id": "1723", "ref_js": ["var maxMoves = function (grid) {\\n    const memoize = {};", "var maxMoves = function(grid) {\\n\\tconst cache = {};", "var maxMoves = function(grid) {\\n\\tconst cache = {};"]}
{"id": "1724", "ref_js": ["var countCompleteComponents = function(n, edges) {\\n    const components=[], g={};", "var countCompleteComponents = function(n, edges) {\\n    const components=[], g={};", "var countCompleteComponents = function(n, edges) {\\n    const components=[], g={};"]}
{"id": "1727", "ref_js": ["var punishmentNumber = function(n) {\\n    let res = 0;\\n    \\n    const isValid = function(arr, target) {\\n        let current = [{val: Number(arr[0]), last: Number(arr[0])}];\\n        for (let i = 1; i < arr.length; i++) {\\n            let next = [];\\n            for (let j = 0; j < current.length; j++) {\\n                let last1 = current[j].last * 10 + Number(arr[i]);\\n                let val1 = current[j].val + last1 - current[j].last;\\n                \\n                let last2 = Number(arr[i]);\\n                let val2 = current[j].val + last2;\\n                \\n                if (val1 <= target) next.push({val: val1, last: last1});\\n                if (val2 <= target) next.push({val: val2, last: last2});\\n            }\\n            current = next;\\n        }\\n        \\n        for (let item of current) {\\n            if (item.val === target) return true;\\n        }\\n        return false;\\n    };", "var punishmentNumber = function(n) {\\n    const partition=(num,start,path,t)=>{\\n        if(start===num.length){\\n            if(path.reduce((acc,curr)=>acc+parseInt(curr),0)===t){\\n                return true;\\n            }\\n            return false;\\n        } \\n        for(let i=start+1;i<=num.length;i++){\\n            path.push(num.substring(start,i));\\n            if(partition(num,i,path,t)) return true; \\n            path.pop();\\n        }\\n        return false;\\n     }\\n\\n    let ans=0;\\n    for(let i=1;i<=n;i++){\\n        const square=Math.pow(i,2);\\n        if(partition(square.toString(),0,[],i)){\\n            ans+=square\\n        }\\n    }\\n    return ans;    \\n};", "var punishmentNumber = function(n) {\\n    let res = 0;\\n    \\n    const isValid = function(arr, target) {\\n        let current = [{val: Number(arr[0]), last: Number(arr[0])}];\\n        for (let i = 1; i < arr.length; i++) {\\n            let next = [];\\n            for (let j = 0; j < current.length; j++) {\\n                let last1 = current[j].last * 10 + Number(arr[i]);\\n                let val1 = current[j].val + last1 - current[j].last;\\n                \\n                let last2 = Number(arr[i]);\\n                let val2 = current[j].val + last2;\\n                \\n                if (val1 <= target) next.push({val: val1, last: last1});\\n                if (val2 <= target) next.push({val: val2, last: last2});\\n            }\\n            current = next;\\n        }\\n        \\n        for (let item of current) {\\n            if (item.val === target) return true;\\n        }\\n        return false;\\n    };"]}
{"id": "1729", "ref_js": ["var divideString = function(s, k, fill) {\\n    let arr=[]\\n    for(let i=0;i<s.length;i++){\\n        if(i+k<=s.length){\\n            arr.push(s.slice(i,i+k))\\n            i=i+k-1\\n        }\\n        else{\\n            let n=[]\\n            let temp=new Array(k-(s.length-i))\\n            n=[...s.slice(i,s.length),temp.fill(fill).join(\\'\\')]\\n            let m=n.join(\\'\\')\\n            arr.push(m)\\n            i=s.length\\n        }\\n    }\\n    return arr\\n};", "var divideString = function(s, k, fill) {\\n    const res = []\\n     let temp = \\'\\'\\n     let len = 0\\n     if(s.length % k === 0){\\n         len = s.length\\n    }else{\\n         len = s.length + k-(s.length%k)\\n     }\\n     for(let i= 0; i<len; i++){\\n         temp += s[i] || fill\\n         if(temp.length === k){\\n             res.push(temp)\\n             temp= \"\"\\n         }\\n     }\\n     return res\\n };", "var divideString = function(s, k, fill) \\n{\\n  var ans=[];\\n  for(let i=0;i<s.length;i+=k)\\n    {\\n      ans.push(s.substring(i,i+k));\\n    }\\n  let str=ans[ans.length-1];\\n  if(str.length==k)\\n    {\\n      return ans;\\n    }\\n  for(let i=str.length;i<k;i++)\\n    {\\n      ans[ans.length-1]+=fill;\\n    }\\n  return ans;\\n};"]}
{"id": "1730", "ref_js": ["var maxStrength = function(nums) {\\n    if(nums.length  ==1){return nums[0]}\\n    nums.sort((a,b)=>{return a-b})\\n    let k = 1\\n    for(let i = 0 ; i < nums.length-1 ; i++){\\n        if(nums[i] < 0 && nums[i+1] < 0){\\n            k *= nums[i]*nums[i+1]\\n            i++\\n            continue\\n        } \\n        if(nums[i] > 0){k *= nums[i]}\\n    }\\n    if(nums[nums.length-1] > 0){k *= nums[nums.length-1]}\\n    if(nums[nums.length-1] == 0 && k ==1 ){k *= 0}\\n    return k\\n};", "var maxStrength = function(nums) {\\n    if(nums.length  ==1){return nums[0]}\\n    nums.sort((a,b)=>{return a-b})\\n    let k = 1\\n    for(let i = 0 ; i < nums.length-1 ; i++){\\n        if(nums[i] < 0 && nums[i+1] < 0){\\n            k *= nums[i]*nums[i+1]\\n            i++\\n            continue\\n        } \\n        if(nums[i] > 0){k *= nums[i]}\\n    }\\n    if(nums[nums.length-1] > 0){k *= nums[nums.length-1]}\\n    if(nums[nums.length-1] == 0 && k ==1 ){k *= 0}\\n    return k\\n};", "var maxStrength = function(nums) {\\n    if(nums.length  ==1){return nums[0]}\\n    nums.sort((a,b)=>{return a-b})\\n    let k = 1\\n    for(let i = 0 ; i < nums.length-1 ; i++){\\n        if(nums[i] < 0 && nums[i+1] < 0){\\n            k *= nums[i]*nums[i+1]\\n            i++\\n            continue\\n        } \\n        if(nums[i] > 0){k *= nums[i]}\\n    }\\n    if(nums[nums.length-1] > 0){k *= nums[nums.length-1]}\\n    if(nums[nums.length-1] == 0 && k ==1 ){k *= 0}\\n    return k\\n};"]}
{"id": "1731", "ref_js": ["var differenceOfDistinctValues = function(grid) {\\n    for(let i = 0; i < grid.length; ++i) {\\n        computeDiag(grid, i, 0);\\n    }\\n    for(let i = 1; i < grid[0].length; ++i) {\\n        computeDiag(grid, 0, i);\\n    }\\n\\n    return grid;\\n};", "var differenceOfDistinctValues = function(grid) {\\n    \\n    let m=grid.length;\\n    let n=grid[0].length;\\n\\n    let out=new Array(m).fill(0).map(()=>new Array(n));\\n   \\n    <!-- itratring over the grid -->\\n    for(let i=0;i<m;i++){\\n        for(let j=0;j<n;j++){\\n            let set=new Set();\\n            let set1=new Set();\\n            ", "var differenceOfDistinctValues = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  const tole = Array(m)\\n  const bori = Array(m)\\n  const answ = Array(m)\\n  \\n  for (let i = 0; i < m; i++) {\\n    tole[i] = Array(n)\\n    bori[i] = Array(n)\\n    answ[i] = Array(n)\\n  }\\n  \\n  for (let i = 0; i < m; i++) {\\n    const set = new Set();\\n    for (let j = 0, k = 0; i+k < m && j+k < n; k++) {\\n      set.add(grid[i+k][j+k])\\n      tole[i+k][j+k] = set.size\\n    }\\n  }\\n  \\n  for (let j = 0; j < n; j++) {\\n    const set = new Set();\\n    for (let i = 0, k = 0; i+k < m && j+k < n; k++) {\\n      set.add(grid[i+k][j+k])\\n      tole[i+k][j+k] = set.size        \\n    }\\n  }\\n  \\n  for (let i = m-1; i >= 0; i--) {\\n    const set = new Set();\\n    for (let j = n-1, k = 0; i-k >= 0 && j-k >= 0; k++) {\\n      set.add(grid[i-k][j-k])\\n      bori[i-k][j-k] = set.size \\n    }\\n  }\\n  \\n  for (let j = n-1; j >= 0; j--) {\\n    const set = new Set();\\n    for (let i = m-1, k = 0; i-k >= 0 && j-k >= 0; k++) {\\n      set.add(grid[i-k][j-k])\\n      bori[i-k][j-k] = set.size\\n    }\\n  }\\n  \\n  for (let i = 0, r, c; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      answ[i][j] = Math.abs((tole[i-1]?.[j-1] ?? 0) - (bori[i+1]?.[j+1] ?? 0))\\n    }\\n  }   \\n  \\n  return answ\\n};"]}
{"id": "1732", "ref_js": ["var minimumCost = function(s) {\\n  \\n\\n    let cost = 0;\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]!=s[i-1]){\\n            cost+=Math.min(i,s.length-i);\\n        }\\n    }\\n    return cost;\\n};", "var minimumCost = function(s) {\\n\\n    let n = s.length;\\n    let totalCost = 0;\\n    for( let i = 0 ; i < n-1 ; i++){\\n        if( s[i] != s[i+1] ){\\n            let invertLeft = i+1;    ", "var minimumCost = function(s) {\\n\\n    let n = s.length;\\n    let totalCost = 0;\\n    for( let i = 0 ; i < n-1 ; i++){\\n        if( s[i] != s[i+1] ){\\n            let invertLeft = i+1;    "]}
{"id": "1733", "ref_js": ["var matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};", "var matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};", "var matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};"]}
{"id": "1736", "ref_js": ["var longestSemiRepetitiveSubstring = function(s) {\\n  let length = 0;\\n  let repeatedDigits;\\n\\n  for(let i = 0;i<s.length;i++){\\n    repeatedDigits = false;\\n      for(let j=i;j<s.length;j++){\\n        if(j>i && s[j]===s[j-1]){\\n          if(repeatedDigits){\\n            break;\\n          }\\n          repeatedDigits = true;\\n        }\\n        length = Math.max(length,j-i+1)\\n      }\\n  }\\n\\n    return length\\n};", "var longestSemiRepetitiveSubstring = function(s) {\\n    let result = 0;\\n    let foundPair;\\n\\n    for (let i = 0; i < s.length; ++i) {\\n        foundPair = false;\\n        for (let j = i; j < s.length; ++j) {\\n            if (j > i && s[j] === s[j - 1]) {\\n                if (foundPair) break;\\n                foundPair = true;\\n            }\\n            result = Math.max(result, j - i + 1);\\n        }\\n    }\\n\\n    return result;\\n};", "var longestSemiRepetitiveSubstring = function(s) {\\n    let l = 0;\\n    let res = 1;\\n    let lastPair = 0\\n\\n    for (let r=1; r<s.length; r++) {\\n        if (s[r] === s[r-1]) {\\n            if (lastPair) l = lastPair\\n            lastPair = r\\n        }\\n\\n        res = Math.max(res, r-l+1)\\n    }\\n    \\n    return res\\n};"]}
{"id": "1737", "ref_js": ["var sumDistance = function (nums, s, d) {\\n  const n = nums.length;\\n  const MOD = Math.pow(10, 9) + 7;\\n  for (let i = 0; i < n; i++) {\\n    nums[i] = s[i] === \\'R\\' ? nums[i] + d : nums[i] - d;\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n  const preSum = nums.slice();\\n\\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    ans = (ans + (i * nums[i] - preSum[i - 1])) % MOD;\\n    preSum[i] = (nums[i] + preSum[i - 1]) % MOD;\\n  }\\n\\n  return ans;\\n};", "var sumDistance = function(nums, s, d) {\\n  const sumWithOtherElements = (arr) => {\\n    ", "var sumDistance = function(nums, s, d) {\\n  const sumWithOtherElements = (arr) => {\\n    "]}
{"id": "1738", "ref_js": ["var smallestString = function(s) {\\n  let n = s.length, arr = s.split(\"\");\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] !== \\'a\\') {\\n      let start = i, end = i;\\n      while (end < n && s[end] !== \\'a\\') end++;\\n      return convert(arr, start, end)\\n    }\\n  }\\n  arr[n - 1] = \\'z\\';\\n  return arr.join(\"\");\\n};", "var smallestString = function(s) {\\n    let started = false;\\n    let output = \\'\\';\\n\\n    let curCharCode;\\n\\n    for(let i = 0; i < s.length; i++){\\n        if((s[i] !== \\'a\\' && !started) || (i == s.length - 1 && !started) ){\\n            started = true;\\n            output = s.slice(0, i);\\n        }\\n        else if(s[i] === \\'a\\' && started){\\n            output += s.slice(i);\\n            break;\\n        }\\n        \\n        if(started){\\n            curCharCode = s.charCodeAt(i);\\n            output += String.fromCharCode(curCharCode === 97 ? 122 : curCharCode - 1);\\n        }\\n    }\\n\\n    return output != \\'\\' ? output : s;\\n};", "var smallestString = function(s) {\\n    let started = false;\\n    let output = \\'\\';\\n\\n    let curCharCode;\\n\\n    for(let i = 0; i < s.length; i++){\\n        if((s[i] !== \\'a\\' && !started) || (i == s.length - 1 && !started) ){\\n            started = true;\\n            output = s.slice(0, i);\\n        }\\n        else if(s[i] === \\'a\\' && started){\\n            output += s.slice(i);\\n            break;\\n        }\\n        \\n        if(started){\\n            curCharCode = s.charCodeAt(i);\\n            output += String.fromCharCode(curCharCode === 97 ? 122 : curCharCode - 1);\\n        }\\n    }\\n\\n    return output != \\'\\' ? output : s;\\n};"]}
{"id": "1739", "ref_js": ["var minCost = function(nums, x) {\\n    const results = [...nums]\\n    let min = results.reduce((a,b) => a+b, 0)\\n\\n    for (let i=1; i<nums.length; i++) {\\n        nums.unshift(nums.pop())\\n        for (j=0; j<nums.length; j++) {\\n            if (results[j] > nums[j]) {\\n                results[j] = nums[j]\\n            }\\n        }\\n        min = Math.min(min, results.reduce((a,b) => a+b, 0) + i*x)\\n    }\\n\\n    return min\\n};", "var minCost = function (nums, x) {\\n  let ans = Infinity;\\n  const n = nums.length;\\n  const minCost = new Array(n).fill(Infinity);\\n\\n  for (let i = 0; i < n; i++) {\\n    let totalCost = 0;\\n    for (let j = 0; j < n; j++) {\\n      const nj = (i + j) % n;\\n      minCost[nj] = Math.min(minCost[nj], nums[j]);\\n      totalCost += minCost[nj];\\n    }\\n    totalCost += i * x;\\n    ans = Math.min(ans, totalCost);\\n  }\\n\\n  return ans;\\n};", "var minCost = function(nums, x) {\\n  let n = nums.length, ans = Array(n).fill(0);\\n  for (let i = 0; i < n; i++) {\\n    let currMinCost = Infinity;\\n    for (let r = 0; r < n; r++) { "]}
{"id": "1740", "ref_js": ["var findValueOfPartition = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    let res = Infinity\\n    \\n    for (let i=0; i<nums.length-1; i++) {\\n        const diff = Math.abs(nums[i] - nums[i+1])\\n        if (diff < res) {\\n            res = diff\\n        }\\n    }\\n    \\n    return res\\n};", "var findValueOfPartition = function(nums) {\\nlet min=9999999999999 ;\\n  nums.sort((n1,n2)=>{\\n      return n1-n2;\\n  })  \\nfor(let k=0;k<nums.length-1;k++){\\n    if((nums[k+1]-nums[k])<min){\\n        min=nums[k+1]-nums[k];\\n    }\\n}\\nreturn min;\\n};", "var findValueOfPartition = function(nums) {\\nlet min=9999999999999 ;\\n  nums.sort((n1,n2)=>{\\n      return n1-n2;\\n  })  \\nfor(let k=0;k<nums.length-1;k++){\\n    if((nums[k+1]-nums[k])<min){\\n        min=nums[k+1]-nums[k];\\n    }\\n}\\nreturn min;\\n};"]}
{"id": "1741", "ref_js": ["var specialPerm = function(nums) {\\n  let n = nums.length, fullMask = (1 << n) - 1;\\n  let memo = Array(1 << n).fill(0).map(() => Array(n).fill(-1)), MOD = 10 ** 9 + 7, res = 0;\\n  for (let i = 0; i < n; i++) {\\n    res = (res + dp(1 << i, i)) % MOD;\\n  }\\n  return res;\\n  \\n  function dp(mask, prevIndex) {\\n    if (mask === fullMask) return 1;\\n    if (memo[mask][prevIndex] !== -1) return memo[mask][prevIndex];\\n\\n    let ans = 0;\\n    for (let i = 0; i < n; i++) {\\n      if ((mask >> i) & 1) continue; \\n      if ((nums[i] % nums[prevIndex] === 0) || (nums[prevIndex] % nums[i] === 0)) {\\n        let newMask = mask | (1 << i);\\n        ans = (ans + dp(newMask, i)) % MOD;\\n      }\\n    }\\n    return memo[mask][prevIndex] = ans;\\n  }  \\n};", "var specialPerm = function(nums) {\\n    const MOD = 10 ** 9 + 7;\\n    const n = nums.length;\\n    const dp = Array.from({ length: n + 1 }, () => Array(1 << (n + 1)).fill(-1));\\n\\n    var helper = function (prev, mask, count) {\\n        if (count === n) return 1;\\n\\n        if (dp[prev + 1][mask] !== -1) {\\n            return dp[prev + 1][mask];\\n        }\\n\\n        let result = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (mask & (1 << i)) continue;\\n            if (prev === -1 || nums[i] % nums[prev] === 0 || nums[prev] % nums[i] === 0) {\\n                result = (result + helper(i, mask | (1 << i), count + 1)) % MOD;\\n            }\\n        }\\n\\n        dp[prev + 1][mask] = result;\\n        return result;\\n    }\\n\\n    return helper(-1, 0, 0);\\n};", "var specialPerm = function(nums) {\\n    let dp = Array.from({length: 14}, () => [])\\n    let res = 0\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        res += dfs(nums, i, 1 << i, dp) % M "]}
{"id": "1742", "ref_js": ["var longestString = function(x, y, z) {\\n    if (x === y)\\n        return (4 * x + 2 * z);\\n    var mini = Math.min(x, y);\\n    return (2 * mini + 2 * (mini + 1) + 2 * z);\\n};", "var longestString = function(x, y, z) {\\n    var xy = 2*Math.min(x, y);\\n    if(x != y){\\n        xy+=1;\\n    }\\n    return 2*(xy+z);\\n};", "var longestString = function(x, y, z) {\\n    var xy = 2*Math.min(x, y);\\n    if(x != y){\\n        xy+=1;\\n    }\\n    return 2*(xy+z);\\n};"]}
{"id": "1743", "ref_js": ["var minimizeConcatenatedLength = function (words) {\\n  const n = words.length;\\n  const dp = new Array(n)\\n    .fill()\\n    .map((_) => new Array(26).fill().map((_) => new Array(26).fill()));\\n  const firstCharCode = getCharCode(words[0], 0);\\n  const lastCharCode = getCharCode(words[0], words[0].length - 1);\\n\\n  return words[0].length + helper(dp, n, words, 1, firstCharCode, lastCharCode);\\n};", "var minimizeConcatenatedLength = function (words) {\\n  const n = words.length;\\n  const dp = new Array(n)\\n    .fill()\\n    .map((_) => new Array(26).fill().map((_) => new Array(26).fill()));\\n  const firstCharCode = getCharCode(words[0], 0);\\n  const lastCharCode = getCharCode(words[0], words[0].length - 1);\\n\\n  return words[0].length + helper(dp, n, words, 1, firstCharCode, lastCharCode);\\n};", "var minimizeConcatenatedLength = function (words) {\\n  const n = words.length;\\n  const dp = new Array(n)\\n    .fill()\\n    .map((_) => new Array(26).fill().map((_) => new Array(26).fill()));\\n  const firstCharCode = getCharCode(words[0], 0);\\n  const lastCharCode = getCharCode(words[0], words[0].length - 1);\\n\\n  return words[0].length + helper(dp, n, words, 1, firstCharCode, lastCharCode);\\n};"]}
{"id": "1744", "ref_js": ["var countServers = function (n, logs, x, queries) {\\n  logs.sort((a, b) => a[1] - b[1]);\\n  queries = queries.map((endTime, index) => [endTime, index]);\\n  queries.sort((a, b) => a[0] - b[0]);\\n\\n  const ans = new Array(queries.length).fill(0);\\n  const map = {};", "var countServers = function(n, logs, x, queries) {\\n  queries = queries.map((time, idx) => [time, idx]).sort((a, b) => a[0] - b[0]);\\n  logs.sort((a, b) => a[1] - b[1]);\\n  let activeCount = Array(n + 1).fill(0), activeServers = 0, j = 0, i = 0, res = Array(queries.length);\\n  for (let [queryTime, queryIndex] of queries) {\\n    ", "var countServers = function(n, logs, x, queries) {\\n  queries = queries.map((time, idx) => [time, idx]).sort((a, b) => a[0] - b[0]);\\n  logs.sort((a, b) => a[1] - b[1]);\\n  let activeCount = Array(n + 1).fill(0), activeServers = 0, j = 0, i = 0, res = Array(queries.length);\\n  for (let [queryTime, queryIndex] of queries) {\\n    "]}
{"id": "1745", "ref_js": ["var makeTheIntegerZero = function(num1, num2) {\\n    bitCount = (n) => n.toString(2).replace(/0/g,\"\").length\\n\\n    for (let i = 0; i <= 60; i++) {\\n        k = num1 - i * num2\\n        if (bitCount(k) <= i && i <= k) return i\\n    }\\n    \\n    return -1\\n};", "var makeTheIntegerZero = function(num1, num2) {\\n    let n = num1\\n    let k = 1\\n    \\n    while(n > 0) {\\n        n -= num2\\n        \\n        if(bitCount(n) <= k && k <= n) { ", "var makeTheIntegerZero = function(num1, num2) {\\n    bitCount = (n) => n.toString(2).replace(/0/g,\"\").length\\n\\n    for (let i = 0; i <= 60; i++) {\\n        k = num1 - i * num2\\n        if (bitCount(k) <= i && i <= k) return i\\n    }\\n    \\n    return -1\\n};"]}
{"id": "1746", "ref_js": ["var numberOfGoodSubarraySplits = function(nums) {\\n    const allOnes=nums.reduce((acc,cur)=>acc+cur), MOD=Math.pow(10,9)+7;\\n    if(allOnes===0) return 0;\\n\\n    const dfs=(i,hasOne,ones,dp)=>{\\n      if(ones===0) return 1;\\n      if(i===nums.length) return 0;\\n      if(hasOne && nums[i]===1) return 0; ", "var numberOfGoodSubarraySplits = function(nums) {\\n    let ind = []; let res = 1; const mod = 1e9 + 7;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i]===1){\\n            ind.push(i)\\n        }\\n    }\\n\\n    for(let i=1; i<ind.length; i++){\\n        res *= (ind[i]-ind[i-1])\\n        res %= mod\\n    }\\n\\n    return ind.length?res:0;\\n};", "var numberOfGoodSubarraySplits = function(nums) {\\n    const allOnes=nums.reduce((acc,cur)=>acc+cur), MOD=Math.pow(10,9)+7;\\n    if(allOnes===0) return 0;\\n\\n    const dfs=(i,hasOne,ones,dp)=>{\\n      if(ones===0) return 1;\\n      if(i===nums.length) return 0;\\n      if(hasOne && nums[i]===1) return 0; "]}
{"id": "1747", "ref_js": ["var findPrimePairs = function(n) {\\n  let res=[];\\n  for(let i=1; i<=n/2; i++){\\n      if(isPrime(i) && isPrime(n-i)){\\n          res.push([i, n-i]);\\n      }\\n  }  \\n  return res;\\n};", "var findPrimePairs = function(n) {\\n    let p = getPrimesBySieveOfEratosthenes(n)\\n    let r = [];\\n\\n    for (let i=1; i <= n/2; i++)      \\n        if (p[i] && p[n-i]) r.push([i, n-i])\\n\\n    return r\\n};", "var findPrimePairs = function(n) {\\n    let p = getPrimesBySieveOfEratosthenes(n)\\n    let r = [];\\n\\n    for (let i=1; i <= n/2; i++)      \\n        if (p[i] && p[n-i]) r.push([i, n-i])\\n\\n    return r\\n};"]}
{"id": "1748", "ref_js": ["var continuousSubarrays = function(nums) {\\n  let n = nums.length, queueDec = new Deque(), queueInc = new Deque();\\n  let ans = 0, decIndex = 0, incIndex = 0;\\n  for (let i = 0; i < n; i++) {\\n    ", "var continuousSubarrays = function(nums) {\\n    class sortedList {\\n        constructor(){\\n            this.list = []\\n        }\\n        add(num) {\\n            let idx = this.bs(num)\\n            this.list.splice(idx, 0, num)\\n        }\\n        del(num){\\n            let idx = this.bs(num)\\n            this.list.splice(idx, 1)\\n        }\\n        isEmpty(){\\n            return this.list.length === 0\\n        }\\n        max(){\\n            return this.list[this.list.length-1]\\n        }\\n        min(){\\n            return this.list[0]\\n        }\\n        get(){\\n            return this.list\\n        }\\n        ", "var continuousSubarrays = function(nums) {\\n  let n = nums.length, queueDec = new Deque(), queueInc = new Deque();\\n  let ans = 0, decIndex = 0, incIndex = 0;\\n  for (let i = 0; i < n; i++) {\\n    "]}
{"id": "1749", "ref_js": ["var relocateMarbles = function(nums, moveFrom, moveTo) {\\nlet positions = new Map();\\n\\n  ", "var relocateMarbles = function(nums, moveFrom, moveTo) {\\nlet positions = new Map();\\n\\n  ", "var relocateMarbles = function(nums, moveFrom, moveTo) {\\nlet positions = new Map();\\n\\n  "]}
{"id": "1750", "ref_js": ["var minimumBeautifulSubstrings = function(s) {\\n    function _isPowerOf5(num) {\\n        while(num > 1 && num % 5 === 0) num /= 5 \\n        return num === 1\\n    }\\n\\n    function _solve(idx, partition) {\\n        if(idx == s.length) return partition\\n        if(s.charAt(idx) == \\'0\\') return Infinity\\n        let num = 0, res = Infinity\\n        for(let j = idx; j < s.length; j++) {\\n            num = (num << 1) + +s.charAt(j)\\n            if(_isPowerOf5(num)) res = Math.min(res, _solve(j+1, partition+1))\\n        }\\n        return res\\n    }\\n\\n    const x = _solve(0, 0)\\n    return x === Infinity ? -1 : x\\n};", "var minimumBeautifulSubstrings = function(s) {\\n    function _isPowerOf5(num) {\\n        while(num > 1 && num % 5 === 0) num /= 5 \\n        return num === 1\\n    }\\n\\n    function _solve(idx, partition) {\\n        if(idx == s.length) return partition\\n        if(s.charAt(idx) == \\'0\\') return Infinity\\n        let num = 0, res = Infinity\\n        for(let j = idx; j < s.length; j++) {\\n            num = (num << 1) + +s.charAt(j)\\n            if(_isPowerOf5(num)) res = Math.min(res, _solve(j+1, partition+1))\\n        }\\n        return res\\n    }\\n\\n    const x = _solve(0, 0)\\n    return x === Infinity ? -1 : x\\n};", "var minimumBeautifulSubstrings = function(s) {\\n    function _isPowerOf5(num) {\\n        while(num > 1 && num % 5 === 0) num /= 5 \\n        return num === 1\\n    }\\n\\n    function _solve(idx, partition) {\\n        if(idx == s.length) return partition\\n        if(s.charAt(idx) == \\'0\\') return Infinity\\n        let num = 0, res = Infinity\\n        for(let j = idx; j < s.length; j++) {\\n            num = (num << 1) + +s.charAt(j)\\n            if(_isPowerOf5(num)) res = Math.min(res, _solve(j+1, partition+1))\\n        }\\n        return res\\n    }\\n\\n    const x = _solve(0, 0)\\n    return x === Infinity ? -1 : x\\n};"]}
{"id": "1751", "ref_js": ["var countBlackBlocks = function(m, n, coordinates) {\\n    let arr = new Array(5).fill(0)\\n    \\n    arr[0] = (m - 1) * (n - 1)\\n    \\n    let mat = {}\\n    \\n    for(let [r, c] of coordinates) {\\n        mat[r] ||= []\\n        mat[r][c] = true\\n    }\\n    \\n    for(let [r, c] of coordinates) {\\n        for(let i = -1; i < 1; i++) {\\n            for(let j = -1; j < 1; j++) {\\n                let nextR = r + i\\n                let nextC = c + j\\n                \\n                if(nextR < 0 || nextC < 0 || nextR >= m - 1 | nextC >= n - 1) continue\\n                \\n                let res = getRes(nextR, nextC, mat)\\n                \\n                arr[res]++\\n            }\\n        }\\n    }\\n    \\n    for(let i = 1; i < 5; i++) {\\n        arr[i] = ~~(arr[i] / i)\\n    }\\n    \\n    let used = 0\\n    \\n    for(let i = 1; i < 5; i++) {\\n        used+=arr[i]\\n    }\\n    \\n    arr[0] -= used\\n    \\n    return arr\\n};", "var countBlackBlocks = function(m, n, coordinates) {\\n    let arr = new Array(5).fill(0)\\n    \\n    arr[0] = (m - 1) * (n - 1)\\n    \\n    let mat = {}\\n    \\n    for(let [r, c] of coordinates) {\\n        mat[r] ||= []\\n        mat[r][c] = true\\n    }\\n    \\n    for(let [r, c] of coordinates) {\\n        for(let i = -1; i < 1; i++) {\\n            for(let j = -1; j < 1; j++) {\\n                let nextR = r + i\\n                let nextC = c + j\\n                \\n                if(nextR < 0 || nextC < 0 || nextR >= m - 1 | nextC >= n - 1) continue\\n                \\n                let res = getRes(nextR, nextC, mat)\\n                \\n                arr[res]++\\n            }\\n        }\\n    }\\n    \\n    for(let i = 1; i < 5; i++) {\\n        arr[i] = ~~(arr[i] / i)\\n    }\\n    \\n    let used = 0\\n    \\n    for(let i = 1; i < 5; i++) {\\n        used+=arr[i]\\n    }\\n    \\n    arr[0] -= used\\n    \\n    return arr\\n};", "var countBlackBlocks = function(m, n, coordinates) {\\n    let arr = new Array(5).fill(0)\\n    \\n    arr[0] = (m - 1) * (n - 1)\\n    \\n    let mat = {}\\n    \\n    for(let [r, c] of coordinates) {\\n        mat[r] ||= []\\n        mat[r][c] = true\\n    }\\n    \\n    for(let [r, c] of coordinates) {\\n        for(let i = -1; i < 1; i++) {\\n            for(let j = -1; j < 1; j++) {\\n                let nextR = r + i\\n                let nextC = c + j\\n                \\n                if(nextR < 0 || nextC < 0 || nextR >= m - 1 | nextC >= n - 1) continue\\n                \\n                let res = getRes(nextR, nextC, mat)\\n                \\n                arr[res]++\\n            }\\n        }\\n    }\\n    \\n    for(let i = 1; i < 5; i++) {\\n        arr[i] = ~~(arr[i] / i)\\n    }\\n    \\n    let used = 0\\n    \\n    for(let i = 1; i < 5; i++) {\\n        used+=arr[i]\\n    }\\n    \\n    arr[0] -= used\\n    \\n    return arr\\n};"]}
{"id": "1752", "ref_js": ["var maximumJumps = function(nums, target) {\\n    const dpArray = new Array(nums.length).fill(-1);\\n    dpArray[0] = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (Math.abs(nums[j] - nums[i]) <= target && dpArray[j] !== -1) {\\n                dpArray[i] = Math.max(dpArray[i], 1 + dpArray[j]);\\n            }\\n        }\\n    }\\n    return dpArray[nums.length - 1];\\n};", "var maximumJumps = function(nums, target) {\\n      const n = nums.length;\\n      const dp = new Array(n).fill(-1); \\n\\n      dp[0] = 0; ", "var maximumJumps = function(nums, target) {\\n    const n = nums.length;\\n    const dp = new Array(n).fill(-1);\\n    dp[0] = 0;\\n    for (let i = 1; i < n; i++) {\\n        const minVal = nums[i] - target;\\n        const maxVal = nums[i] + target;\\n\\n        for (let j = 0; j < i; j++) {\\n        if (nums[j] >= minVal && nums[j] <= maxVal) {\\n            if (dp[j] !== -1) {\\n            dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        }\\n    }\\n    return dp[n - 1];\\n};"]}
{"id": "1753", "ref_js": ["var maxNonDecreasingLength = function(nums1, nums2) {\\n    \\n    const dfs=(lastPick,i,dp)=>{\\n        if(i===nums1.length) return 0;\\n        const key=`${lastPick}_${i}`;\\n        if(dp[key]!==undefined) return dp[key];\\n\\n        let min=Math.min(nums1[i],nums2[i]), max=Math.max(nums1[i],nums2[i]), len=0;\\n        if(min>=lastPick){\\n            len = dfs(min,i+1,dp)+1; ", "var maxNonDecreasingLength = function(nums1, nums2) {\\n    const n = nums1.length;\\n    let length = 1;\\n\\n    let a = [1];\\n    let b = [1];\\n\\n    for(let i = 1; i < n; i++) {\\n        a[i] = Math.max(\\n            nums1[i] >= nums1[i-1] ? a[i-1] + 1 : 1,\\n            nums1[i] >= nums2[i-1] ? b[i-1] + 1 : 1\\n        );\\n        b[i] = Math.max(\\n            nums2[i] >= nums1[i-1] ? a[i-1] + 1 : 1,\\n            nums2[i] >= nums2[i-1] ? b[i-1] + 1 : 1\\n        );\\n\\n        length = Math.max(length, Math.max(a[i],b[i]));\\n    }\\n    return length;\\n};", "var maxNonDecreasingLength = function (nums1, nums2) {\\n  const n = nums1.length;\\n  let dpOne = 1;\\n  let dpTwo = 1;\\n  let ans = 1;\\n\\n  for (let i = 1; i < n; i++) {\\n    const dpOneOne = nums1[i] >= nums1[i - 1] ? dpOne + 1 : 1;\\n    const dpOneTwo = nums2[i] >= nums1[i - 1] ? dpOne + 1 : 1;\\n    const dpTwoOne = nums1[i] >= nums2[i - 1] ? dpTwo + 1 : 1;\\n    const dpTwoTwo = nums2[i] >= nums2[i - 1] ? dpTwo + 1 : 1;\\n\\n    dpOne = Math.max(dpOneOne, dpTwoOne);\\n    dpTwo = Math.max(dpOneTwo, dpTwoTwo);\\n\\n    ans = Math.max(ans, dpOne, dpTwo);\\n  }\\n\\n  return ans;\\n};"]}
{"id": "1754", "ref_js": ["var checkArray = function(nums, k) {\\n    let n = nums.length\\n    let pref = Array(n+1).fill(0)\\n    let ac = 0\\n    for(let [i, val] of nums.entries()){\\n        ac-=pref[i]\\n        val-=ac\\n        console.log(val,i)\\n\\n        if(val<0)return false\\n        if(i+k<=n){\\n            ac+=val\\n            pref[i+k]+=val\\n            val = 0\\n        }\\n        else if(val>0)return false\\n    }\\n\\n    return true\\n};", "var checkArray = function(nums, k) {\\n  const len = nums.length;\\n  if (len === 1) return true;\\n  let max = -Infinity;\\n  for (let i = 0; i < len; i++) {\\n    if (i <= len - k) {\\n      if (nums[i] === 0) continue;\\n      const currentMin = min(nums, i, i + k);\\n      if (currentMin) {\\n        for (let j = i; j < i+k; j++) {\\n          nums[j] -= currentMin;\\n        }\\n      }\\n    }\\n    max = Math.max(max, nums[i]);\\n  }\\n  return max === 0;\\n};", "var checkArray = function(nums, k) {\\n    const n = nums.length;\\n    let i = 0\\n\\n    while (i < n) {\\n        let cnt = 0, r = i, num = nums[i];\\n        while (cnt < k && r < n) {\\n            if (r > 0 && nums[r] < nums[r-1]) return false;\\n            cnt++;\\n            nums[r]-=num;\\n            r++;\\n        }\\n        let j = i;\\n        while (nums[j] === 0) j++;\\n        i = j;\\n        if (i < n && n - i < k) return false;\\n    }\\n\\n    return true;\\n};"]}
{"id": "1755", "ref_js": ["var maximumBeauty = function(nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let ans = 0, n = nums.length;\\n  for (let j = 0, i = 0; j < n; j++) {\\n    while (nums[j] - nums[i] > k * 2) i++;\\n    ans = Math.max(ans, j - i + 1);\\n  }\\n  return ans;\\n};", "var maximumBeauty = function(nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let ans = 0, n = nums.length;\\n  for (let j = 0, i = 0; j < n; j++) {\\n    while (nums[j] - nums[i] > k * 2) i++;\\n    ans = Math.max(ans, j - i + 1);\\n  }\\n  return ans;\\n};", "var maximumBeauty = function(nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let ans = 0, n = nums.length;\\n  for (let j = 0, i = 0; j < n; j++) {\\n    while (nums[j] - nums[i] > k * 2) i++;\\n    ans = Math.max(ans, j - i + 1);\\n  }\\n  return ans;\\n};"]}
{"id": "1756", "ref_js": ["var minimumIndex = function(nums) {\\n    let n = nums.length;\\n    let set = {};", "var minimumIndex = function(nums) {\\n    let m = nums.length, dominentNum = nums[0];\\n    \\n    for (let i = 1, count = 1; i < m; i++) {\\n      count += nums[i] === dominentNum ? 1 : -1;\\n      if (count === 0) dominentNum = nums[i], count = 1;\\n    }\\n\\n    const dominentNumFreq = nums.reduce((freq, num) => freq + (num === dominentNum), 0);\\n\\n    for (let i = 0, freq = 0; i < m; i++) {\\n      freq += nums[i] === dominentNum;\\n      if (freq * 2 > i + 1 && (dominentNumFreq - freq) * 2 > m - i - 1)\\n        return i;\\n    }\\n\\n    return -1;\\n};", "var minimumIndex = function(nums) {\\n    let m = nums.length, dominentNum = nums[0];\\n    \\n    for (let i = 1, count = 1; i < m; i++) {\\n      count += nums[i] === dominentNum ? 1 : -1;\\n      if (count === 0) dominentNum = nums[i], count = 1;\\n    }\\n\\n    const dominentNumFreq = nums.reduce((freq, num) => freq + (num === dominentNum), 0);\\n\\n    for (let i = 0, freq = 0; i < m; i++) {\\n      freq += nums[i] === dominentNum;\\n      if (freq * 2 > i + 1 && (dominentNumFreq - freq) * 2 > m - i - 1)\\n        return i;\\n    }\\n\\n    return -1;\\n};"]}
{"id": "1757", "ref_js": ["var sortVowels = function(s) {\\n    let hash = new Map([[\\'A\\', 1],[\\'E\\', 1],[\\'I\\', 1],[\\'O\\', 1],[\\'U\\', 1],[\\'a\\', 1],[\\'e\\', 1],[\\'i\\', 1],[\\'o\\', 1],[\\'u\\', 1]]);\\n    idsave = [];\\n    vowsave = [];\\n    for(let i=0; i<s.length; i++) {\\n        if(hash.has(s[i])) {\\n            idsave.push(i);\\n            vowsave.push(s[i]);\\n        }\\n    }\\n    vowsave.sort();\\n    let res = s.split(\\'\\');\\n    for(let i=0; i<idsave.length; i++) {\\n        res[idsave[i]] = vowsave[i];\\n    }\\n    res = res.join(\\'\\');\\n    return res;\\n};", "var sortVowels = function(s) {\\n    let hash = new Map([[\\'A\\', 1],[\\'E\\', 1],[\\'I\\', 1],[\\'O\\', 1],[\\'U\\', 1],[\\'a\\', 1],[\\'e\\', 1],[\\'i\\', 1],[\\'o\\', 1],[\\'u\\', 1]]);\\n    idsave = [];\\n    vowsave = [];\\n    for(let i=0; i<s.length; i++) {\\n        if(hash.has(s[i])) {\\n            idsave.push(i);\\n            vowsave.push(s[i]);\\n        }\\n    }\\n    vowsave.sort();\\n    let res = s.split(\\'\\');\\n    for(let i=0; i<idsave.length; i++) {\\n        res[idsave[i]] = vowsave[i];\\n    }\\n    res = res.join(\\'\\');\\n    return res;\\n};", "var sortVowels = function(s) {\\n    let hash = new Map([[\\'A\\', 1],[\\'E\\', 1],[\\'I\\', 1],[\\'O\\', 1],[\\'U\\', 1],[\\'a\\', 1],[\\'e\\', 1],[\\'i\\', 1],[\\'o\\', 1],[\\'u\\', 1]]);\\n    idsave = [];\\n    vowsave = [];\\n    for(let i=0; i<s.length; i++) {\\n        if(hash.has(s[i])) {\\n            idsave.push(i);\\n            vowsave.push(s[i]);\\n        }\\n    }\\n    vowsave.sort();\\n    let res = s.split(\\'\\');\\n    for(let i=0; i<idsave.length; i++) {\\n        res[idsave[i]] = vowsave[i];\\n    }\\n    res = res.join(\\'\\');\\n    return res;\\n};"]}
{"id": "1758", "ref_js": ["var maxScore = function(nums, x) {\\n    let odd = isOdd(nums[0]) ? nums[0] : nums[0] - x;\\n    let even = isOdd(nums[0]) ? nums[0] - x : nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n      const num = nums[i]\\n      if (isOdd(num)) {\\n        odd = Math.max(odd + num, even + num - x)\\n      } else {\\n        even = Math.max(even + num, odd + num - x)\\n      }\\n    }\\n    return Math.max(odd, even);\\n};", "var maxScore = function(nums, x) {\\n    let even_score = nums[0] - (nums[0] % 2 === 0 ? 0 : x);\\n    let odd_score = nums[0] - (nums[0] % 2 === 0 ? x : 0);\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] % 2 === 0) {\\n            even_score = nums[i] + Math.max(even_score, odd_score - x);\\n        } else {\\n            odd_score = nums[i] + Math.max(odd_score, even_score - x);\\n        }\\n    }\\n    return Math.max(even_score, odd_score);\\n};", "var maxScore = function(nums, x) {\\n    let maxScoreEven = nums[0]\\n    let maxScoreOdd = nums[0]\\n    let firstEven = false\\n    let firstOdd = false\\n    nums[0] % 2 === 0 ? firstOdd = true : firstEven = true\\n    for (let i = 1; i < nums.length; i++) {\\n        let num = nums[i]\\n        if (num % 2 == 0) {\\n            if (firstEven) {\\n                maxScoreEven = maxScoreOdd + num - x\\n                firstEven = false\\n            }\\n            else maxScoreEven = Math.max(maxScoreEven + num, maxScoreOdd + num - x)\\n        } \\n        else {\\n            if (firstOdd) {\\n                maxScoreOdd = maxScoreEven + num - x\\n                firstOdd = false\\n            }\\n            else maxScoreOdd = Math.max(maxScoreOdd + num, maxScoreEven + num - x)\\n        }\\n    }\\n    return Math.max(maxScoreEven, maxScoreOdd)\\n};"]}
{"id": "1759", "ref_js": ["var numberOfWays = function(n, x) {\\n    const MOD = 1e9 + 7;\\n    const maxNum = Math.floor(Math.pow(n, 1.0 / x)) + 1;\\n    let dp = Array.from(Array(maxNum + 1), () => Array(n + 1).fill(0));\\n\\n    for (let i = 0; i <= maxNum; i++) {\\n        dp[i][0] = 1;\\n    }\\n\\n    for (let i = 1; i <= maxNum; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (j < Math.pow(i, x)) {\\n                dp[i][j] = dp[i - 1][j];\\n            } else {\\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - Math.pow(i, x)]) % MOD;\\n            }\\n        }\\n    }\\n    return dp[maxNum][n];    \\n};", "var numberOfWays = function(n, x) {\\n    const MOD = 1e9 + 7;\\n    const maxNum = Math.floor(Math.pow(n, 1.0 / x)) + 1;\\n    let dp = Array.from(Array(maxNum + 1), () => Array(n + 1).fill(0));\\n\\n    for (let i = 0; i <= maxNum; i++) {\\n        dp[i][0] = 1;\\n    }\\n\\n    for (let i = 1; i <= maxNum; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (j < Math.pow(i, x)) {\\n                dp[i][j] = dp[i - 1][j];\\n            } else {\\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - Math.pow(i, x)]) % MOD;\\n            }\\n        }\\n    }\\n    return dp[maxNum][n];    \\n};", "var numberOfWays = function(n, x) {\\n    const MOD = 1e9 + 7;\\n    const maxNum = Math.floor(Math.pow(n, 1.0 / x)) + 1;\\n    let dp = Array.from(Array(maxNum + 1), () => Array(n + 1).fill(0));\\n\\n    for (let i = 0; i <= maxNum; i++) {\\n        dp[i][0] = 1;\\n    }\\n\\n    for (let i = 1; i <= maxNum; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (j < Math.pow(i, x)) {\\n                dp[i][j] = dp[i - 1][j];\\n            } else {\\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - Math.pow(i, x)]) % MOD;\\n            }\\n        }\\n    }\\n    return dp[maxNum][n];    \\n};"]}
{"id": "1760", "ref_js": ["var maxArrayValue = function(nums) {\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] >= nums[i-1]) {\\n            nums[i-1] = nums[i] + nums[i-1];\\n        }\\n    }\\n\\n    return nums[0];\\n};", "var maxArrayValue = function(nums) {\\n    let ans = nums[nums.length - 1];\\n        let sum_ = ans;\\n        for(let i = nums.length - 2; i >= 0; --i) {\\n            sum_ = nums[i] > sum_ ? nums[i] : sum_ + nums[i];\\n            ans = Math.max(ans, sum_);\\n        }\\n        return ans;\\n};", "var maxArrayValue = function(nums) {\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] >= nums[i-1]) {\\n            nums[i-1] = nums[i] + nums[i-1];\\n        }\\n    }\\n\\n    return nums[0];\\n};"]}
{"id": "1761", "ref_js": ["var countCompleteSubarrays = function(nums) {\\n    let n = nums.length;\\n    let distinct_elements = new Set(nums).size;\\n    let count = 0;\\n    let left = 0;\\n    let right = 0;\\n    let counter = new Map();\\n\\n    while (right < n) {\\n        counter.set(nums[right], (counter.get(nums[right]) || 0) + 1);\\n        while (counter.size === distinct_elements) {\\n            counter.set(nums[left], counter.get(nums[left]) - 1);\\n            if (counter.get(nums[left]) === 0) {\\n                counter.delete(nums[left]);\\n            }\\n            left++;\\n            count += n - right;\\n        }\\n        right++;\\n    }\\n    return count;    \\n};", "var countCompleteSubarrays = function(nums) {\\n    let originalArraySet = new Set();\\n    for(let i=0; i<nums.length; i++){\\n        if(!(originalArraySet.has(nums[i]))){\\n            originalArraySet.add(nums[i])\\n        }\\n    }\\n\\n    let subArraySet = new Set();\\n    let right = 0;\\n    let left = 0;\\n    let counter = 0;\\n\\n    while(left < nums.length){\\n        if(!(subArraySet.has(nums[right]))){\\n            subArraySet.add(nums[right])\\n        }\\n\\n        if(subArraySet.size === originalArraySet.size){\\n            counter++;\\n        }\\n\\n        if(right < (nums.length - 1)){\\n            right++;\\n        }\\n        else{\\n            subArraySet.clear();\\n            left++;\\n            right = left;\\n        }\\n    }\\n\\n    return counter;\\n};", "var countCompleteSubarrays = function(nums) {\\n    let n = nums.length;\\n    let distinct_elements = new Set(nums).size;\\n    let count = 0;\\n    let left = 0;\\n    let right = 0;\\n    let counter = new Map();\\n\\n    while (right < n) {\\n        counter.set(nums[right], (counter.get(nums[right]) || 0) + 1);\\n        while (counter.size === distinct_elements) {\\n            counter.set(nums[left], counter.get(nums[left]) - 1);\\n            if (counter.get(nums[left]) === 0) {\\n                counter.delete(nums[left]);\\n            }\\n            left++;\\n            count += n - right;\\n        }\\n        right++;\\n    }\\n    return count;    \\n};"]}
{"id": "1762", "ref_js": ["var minPairSum = function(nums) {\\n    nums.sort((a, b) => a - b);\\n\\n    let n = nums.length;\\n    let minMaxSum = 0;\\n\\n    for (let i = 0; i < n / 2; i++) {\\n        minMaxSum = Math.max(minMaxSum, nums[i] + nums[n - 1 - i]);\\n    }\\n\\n    return minMaxSum;    \\n};", "var minPairSum = function(nums) {\\n    ", "var minPairSum = function(nums) {\\n    "]}
{"id": "1763", "ref_js": ["var gcd = function(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\nvar insertGreatestCommonDivisors = function(head) {\\n    const ans = head;\\n    let l = head;\\n    \\n    while (l && l.next) {\\n        l.next = new ListNode(gcd(l.val, l.next.val), l.next);\\n        l = l.next.next;\\n    }\\n        \\n    return ans;\\n};", "var gcd = function(a,b){\\n    if(!b){\\n        return a;\\n    }\\n    return gcd(b,a%b)\\n}\\nvar insertGreatestCommonDivisors = function(head) {\\n    let ans = head;\\n    let i = head;\\n    while(i && i.next){\\n        i.next = new ListNode(gcd(i.val,i.next.val),i.next)\\n        i = i.next.next\\n    }\\n    return ans\\n};", "var gcd = function(a,b){\\n    if(!b){\\n        return a;\\n    }\\n    return gcd(b,a%b)\\n}\\nvar insertGreatestCommonDivisors = function(head) {\\n    let ans = head;\\n    let i = head;\\n    while(i && i.next){\\n        i.next = new ListNode(gcd(i.val,i.next.val),i.next)\\n        i = i.next.next\\n    }\\n    return ans\\n};"]}
{"id": "1764", "ref_js": ["var minimumSeconds = function(nums) {\\n    let n = nums.length;\\n    let c = {}\\n    \\n    let h = new Map();\\n\\n    ", "var minimumSeconds = function(nums) {\\n    ", "var minimumSeconds = function(nums) {\\n    let n = nums.length;\\n    let c = {}\\n    \\n    let h = new Map();\\n\\n    "]}
{"id": "1765", "ref_js": ["var canSplitArray = function (a, m) {\\n  let n = a.length\\n\\n  if (n === 1) {\\n    return true\\n  }\\n  if (n === 2) {\\n    return true\\n  }\\n\\n  for (let i = 1; i < n; i++) {\\n    if ((a[i - 1] + a[i]) >= m) {\\n      return true\\n    }\\n  }\\n\\n  return false\\n};", "var canSplitArray = function(nums, m) {\\n  if (nums.length <= 2) return true;\\n  ", "var canSplitArray = function (nums, m) {\\n    map = new Map();\\n    let sum = [];\\n    sum.push(nums[0]);\\n    for (let i = 1; i < nums.length; i++) {\\n        sum.push(nums[i] + sum[sum.length - 1]);\\n    }"]}
{"id": "1766", "ref_js": ["var maximumSafenessFactor = function(grid) {\\n  const n = grid.length;\\n  const isInBound = (r, c) => r >= 0 && r < n && c >= 0 && c < n;\\n  const dist = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));\\n  const queue = [];\\n\\n  for (let r = 0; r < n; r++) {\\n    for (let c = 0; c < n; c++) {\\n      if (grid[r][c] === 1) {\\n        dist[r][c] = 0;\\n        queue.push([r, c]);\\n      }\\n    }\\n  }\\n\\n  while (queue.length) {\\n    const [r, c] = queue.shift();\\n    const neighbors = [\\n      [r + 1, c],\\n      [r - 1, c],\\n      [r, c + 1],\\n      [r, c - 1],\\n    ];\\n\\n    for (const [nr, nc] of neighbors) {\\n      if (isInBound(nr, nc) && dist[nr][nc] === Infinity) {\\n        dist[nr][nc] = dist[r][c] + 1;\\n        queue.push([nr, nc]);\\n      }\\n    }\\n  }\\n\\n  const maxDistance = new Array(n).fill(0).map(() => new Array(n).fill(0));\\n  maxDistance[0][0] = dist[0][0];\\n  queue.push([0, 0]);\\n\\n  while (queue.length) {\\n    const [r, c] = queue.shift();\\n    const neighbors = [\\n      [r + 1, c],\\n      [r - 1, c],\\n      [r, c + 1],\\n      [r, c - 1],\\n    ];\\n\\n    for (const [nr, nc] of neighbors) {\\n      if (isInBound(nr, nc)) {\\n        const newDistance = Math.min(maxDistance[r][c], dist[nr][nc]);\\n        if (newDistance > maxDistance[nr][nc]) {\\n          maxDistance[nr][nc] = newDistance;\\n          queue.push([nr, nc]);\\n        }\\n      }\\n    }\\n  }\\n\\n  return maxDistance[n - 1][n - 1];    \\n};", "var maximumSafenessFactor = function (grid) {\\n    const n = grid.length;\\n    if (grid[0][0] === 1 || grid[n - 1][n - 1] === 1) return 0;\\n\\n    const safenessGrid = calculateSafeDistance(grid);\\n\\n    let leastSFactor = 1, highSFactor = n - 1;\\n    let result = 0;\\n\\n    while (leastSFactor <= highSFactor) {\\n        let mid = Math.floor((leastSFactor + highSFactor) / 2);\\n\\n        if (validSafenessFactor(safenessGrid, mid)) {\\n            result = Math.max(result, mid);\\n            leastSFactor = mid + 1;\\n        } else {\\n            highSFactor = mid - 1;\\n        }\\n    }\\n\\n    return result;\\n};", "var maximumSafenessFactor = function(grid) {\\n    const n = grid.length, dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n    const nearestThief = getNearestThiefDistance(grid, n, dirs);\\n\\n    let lSafeFactor = 0, rSafeFactor = n - 1;\\n    while (lSafeFactor < rSafeFactor) {\\n        const midSafeFactor = (lSafeFactor + rSafeFactor + 1) >> 1;\\n        if (isSafeFactorPossible(midSafeFactor, grid, n, nearestThief, dirs)) \\n            lSafeFactor = midSafeFactor;\\n        else rSafeFactor = midSafeFactor - 1;\\n    }\\n\\n    return lSafeFactor\\n};"]}
{"id": "1767", "ref_js": ["var doubleIt = function(head) {\\n    if (head === null) return head;\\n\\n    let dummy = new ListNode();\\n    let current = dummy;\\n    let carry = 0;\\n\\n    let prev = null;\\n    let temp = head;\\n\\n    while (temp !== null) {\\n        let nextTemp = temp.next;\\n        temp.next = prev;\\n\\n        prev = temp;\\n        temp = nextTemp;\\n    }\\n\\n    while (prev !== null) {\\n        let sum = carry;\\n        sum += (prev.val + prev.val);\\n        prev = prev.next;\\n\\n        carry = Math.floor(sum / 10);\\n        current.next = new ListNode(sum % 10);\\n        current = current.next;\\n    }\\n\\n    if (carry > 0) {\\n        current.next = new ListNode(carry);\\n    }\\n\\n    prev = null;\\n    temp = dummy.next;\\n\\n    while (temp !== null) {\\n        let nextTemp = temp.next;\\n        temp.next = prev;\\n\\n        prev = temp;\\n        temp = nextTemp;\\n    }\\n\\n    return prev;\\n};", "var doubleIt = function(head) {\\n    if (head === null) return head;\\n\\n    let dummy = new ListNode();\\n    let current = dummy;\\n    let carry = 0;\\n\\n    let prev = null;\\n    let temp = head;\\n\\n    while (temp !== null) {\\n        let nextTemp = temp.next;\\n        temp.next = prev;\\n\\n        prev = temp;\\n        temp = nextTemp;\\n    }\\n\\n    while (prev !== null) {\\n        let sum = carry;\\n        sum += (prev.val + prev.val);\\n        prev = prev.next;\\n\\n        carry = Math.floor(sum / 10);\\n        current.next = new ListNode(sum % 10);\\n        current = current.next;\\n    }\\n\\n    if (carry > 0) {\\n        current.next = new ListNode(carry);\\n    }\\n\\n    prev = null;\\n    temp = dummy.next;\\n\\n    while (temp !== null) {\\n        let nextTemp = temp.next;\\n        temp.next = prev;\\n\\n        prev = temp;\\n        temp = nextTemp;\\n    }\\n\\n    return prev;\\n};", "var doubleIt = function(head) {\\n    if (head === null) return head;\\n\\n    let dummy = new ListNode();\\n    let current = dummy;\\n    let carry = 0;\\n\\n    let prev = null;\\n    let temp = head;\\n\\n    while (temp !== null) {\\n        let nextTemp = temp.next;\\n        temp.next = prev;\\n\\n        prev = temp;\\n        temp = nextTemp;\\n    }\\n\\n    while (prev !== null) {\\n        let sum = carry;\\n        sum += (prev.val + prev.val);\\n        prev = prev.next;\\n\\n        carry = Math.floor(sum / 10);\\n        current.next = new ListNode(sum % 10);\\n        current = current.next;\\n    }\\n\\n    if (carry > 0) {\\n        current.next = new ListNode(carry);\\n    }\\n\\n    prev = null;\\n    temp = dummy.next;\\n\\n    while (temp !== null) {\\n        let nextTemp = temp.next;\\n        temp.next = prev;\\n\\n        prev = temp;\\n        temp = nextTemp;\\n    }\\n\\n    return prev;\\n};"]}
{"id": "1768", "ref_js": ["var minAbsoluteDifference = function(nums, x) {\\n  if (x === 0) return 0;\\n  let n = nums.length, maxSegTree = new MaxSegmentTree(n);\\n  let arr = nums.map((num, idx) => [num, idx]).sort((a, b) => a[0] - b[0]);\\n  let minDiff = Infinity;\\n  for (let i = 0; i < n; i++) {\\n    let [num, idx] = arr[i];\\n    let maxLeft = maxSegTree.maxRange(0, idx - x);\\n    let maxRight = maxSegTree.maxRange(idx + x, n - 1);\\n    minDiff = Math.min(minDiff, num - maxLeft, num - maxRight);\\n    maxSegTree.update(idx, num);\\n  }\\n  return minDiff;\\n};", "var minAbsoluteDifference = function(nums, x) {\\n    let min = Infinity;\\n   \\n    for(let i = 0; i < nums.length; i++) {\\n        for(let j = i+x; j < nums.length; j ++) {\\n            if(Math.abs(i - j) >= x) {\\n                min = Math.min(min, Math.abs(nums[i] - nums[j]));\\n            }\\n        }\\n    }\\n    return min;\\n};", "var minAbsoluteDifference = function(nums, x) {\\n    let min = Infinity;\\n   \\n    for(let i = 0; i < nums.length; i++) {\\n        for(let j = i+x; j < nums.length; j ++) {\\n            if(Math.abs(i - j) >= x) {\\n                min = Math.min(min, Math.abs(nums[i] - nums[j]));\\n            }\\n        }\\n    }\\n    return min;\\n};"]}
{"id": "1769", "ref_js": ["var findMedianSortedArrays = function(nums1, nums2) {\\n    let merged = [];\\n    let i = 0;\\n    let j = 0;\\n\\n    while(i < nums1.length && j < nums2.length){\\n        if(nums1[i] < nums2[j]){\\n            merged.push(nums1[i])\\n            i++;\\n        }else{\\n            merged.push(nums2[j])\\n            j++;\\n        }\\n    }\\n    while(i < nums1.length ) merged.push(nums1[i++]);\\n    while(j < nums2.length ) merged.push(nums2[j++]);\\n\\n\\n    let mid = Math.floor(merged.length / 2);\\n    if(merged.length % 2 === 0){\\n        return (merged[mid - 1] + merged[mid]) / 2;\\n    }else{\\n        return merged[mid];\\n    }\\n};", "var findMedianSortedArrays = function(nums1, nums2) {\\n    let merged = [];\\n    let i = 0, j = 0;\\n\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] < nums2[j]) {\\n            merged.push(nums1[i++]);\\n        } else {\\n            merged.push(nums2[j++]);\\n        }\\n    }\\n\\n    while (i < nums1.length) merged.push(nums1[i++]);\\n    while (j < nums2.length) merged.push(nums2[j++]);\\n\\n    let mid = Math.floor(merged.length / 2);\\n    if (merged.length % 2 === 0) {\\n        return (merged[mid-1] + merged[mid]) / 2;\\n    } else {\\n        return merged[mid];\\n    }\\n};", "var findMedianSortedArrays = function(nums1, nums2) {\\n    let merged = [];\\n    let i = 0, j = 0;\\n\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] < nums2[j]) {\\n            merged.push(nums1[i++]);\\n        } else {\\n            merged.push(nums2[j++]);\\n        }\\n    }\\n\\n    while (i < nums1.length) merged.push(nums1[i++]);\\n    while (j < nums2.length) merged.push(nums2[j++]);\\n\\n    let mid = Math.floor(merged.length / 2);\\n    if (merged.length % 2 === 0) {\\n        return (merged[mid-1] + merged[mid]) / 2;\\n    } else {\\n        return merged[mid];\\n    }\\n};"]}
{"id": "1770", "ref_js": ["var isMatch = function(s, p) {\\n       \\n      const dp = Array(s.length + 1).fill(false).map(() => Array(p.length + 1).fill(false));\\n  \\n  dp[0][0] = true;\\n  \\n  for (let j = 1; j <= p.length; j++) {\\n    if (p[j - 1] === \\'*\\') {\\n      dp[0][j] = dp[0][j - 2];\\n    }\\n  }\\n\\n  for (let i = 1; i <= s.length; i++) {\\n    for (let j = 1; j <= p.length; j++) {\\n      if (p[j - 1] === s[i - 1] || p[j - 1] === \\'.\\') {\\n        dp[i][j] = dp[i - 1][j - 1];\\n      } else if (p[j - 1] === \\'*\\') {\\n        dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === \\'.\\'));\\n      }\\n    }\\n  }\\n\\n  return dp[s.length][p.length];\\n       \\n     \\n };", "var isMatch = function(s, p) {\\n   try{ \\n        return !s.replace(RegExp(p), \\'\\')\\n   }catch{\\n        return true\\n   }\\n};", "var isMatch = function(s, p) {\\n   try{ \\n        return !s.replace(RegExp(p), \\'\\')\\n   }catch{\\n        return true\\n   }\\n};"]}
{"id": "1771", "ref_js": ["var mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};", "var mergeKLists = function(lists) {\\n    if (lists.length === 0 ) {\\n        return null;\\n    }\\n    ", "var mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};"]}
{"id": "1772", "ref_js": ["var reverseKGroup = function (head, k) {\\n    ", "var reverseKGroup = function(head, size) {\\n    const totalNode = new countList().count(head);\\n    const lastNodesToBeSkipped = totalNode % size;\\n    function splitNodesAsPerSize(head, size, nodesExplored = 0) {\\n        if (totalNode - lastNodesToBeSkipped === nodesExplored) {\\n            return head;\\n        }\\n        const { cutSubNodes, leftHead } = cutSubNodesAsPerTheSizeGiven(head, size);\\n        const response = splitNodesAsPerSize(leftHead, size, (nodesExplored += size));\\n        return new reverseList().reverse(cutSubNodes, response);\\n    }\\n    return splitNodesAsPerSize(head, size);\\n};", "var reverseKGroup = function (head, k) {\\n    "]}
{"id": "1773", "ref_js": ["var findSubstring = function (s, words) {\\n    let wordLen = words[0].length\\n    let totalWords = words.length\\n    let subStrLen = wordLen * totalWords\\n\\n    let cache = {}\\n    function checkString(str) {\\n        if (str in cache) {\\n            return cache[str]\\n        }\\n        let tempWords = [...words]\\n        for (let i = 0; i < totalWords; i++) {\\n            let w = str.slice(i * wordLen, (i + 1) * wordLen)\\n            let index = tempWords.indexOf(w)\\n            if (index >= 0) {\\n                tempWords[index] = null\\n            } else {\\n                cache[str] = false\\n                return cache[str]\\n            }\\n        }\\n        cache[str] = true\\n        return cache[str]\\n    }\\n\\n    let result = []\\n    let maxIndex = (s.length - subStrLen)\\n    for (let i = 0; i <= maxIndex; i++) {\\n        let subStr = s.slice(i, subStrLen + i)\\n        if (checkString(subStr)) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};", "var findSubstring = function(s, words) {\\n    \\n    let res = [];\\n\\n    let wordLength = words[0].length;\\n    let wordCount = words.length;\\n    let len = wordCount * wordLength; ", "var findSubstring = function(s, words) {\\n    \\n    let res = [];\\n\\n    let wordLength = words[0].length;\\n    let wordCount = words.length;\\n    let len = wordCount * wordLength; "]}
{"id": "1774", "ref_js": ["var longestValidParentheses = function(s) {\\n    var length =0\\n    var index =[]\\n    index.push(-1)\\n\\n    for(i=0;i<s.length;i++){\\n        if(s[i] == \\'(\\'){\\n            index.push(i)\\n        }else{\\n            index.pop()\\n            if(index.length>0){\\n                length = Math.max(length, i-index[index.length-1])\\n            }else{\\n                index.push(i)\\n            }\\n        }\\n    }\\n    return length\\n};", "var longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};", "var longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};"]}
{"id": "1775", "ref_js": ["var solveSudoku = function(board) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board.length; j++) {\\n            if (board[i][j] === \\'.\\') {\\n                for (let l = 1; l < 10; l++) {\\n                    if (isValid(board, i, j, l.toString())) {\\n                        board[i][j] = l.toString()\\n                        let solved = solveSudoku(board)\\n                        if (solved !== false) return solved   ", "var solveSudoku = function(board) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board.length; j++) {\\n            if (board[i][j] === \\'.\\') {\\n                for (let l = 1; l < 10; l++) {\\n                    if (isValid(board, i, j, l.toString())) {\\n                        board[i][j] = l.toString()\\n                        let solved = solveSudoku(board)\\n                        if (solved !== false) return solved   ", "var solveSudoku = function(board) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board.length; j++) {\\n            if (board[i][j] === \\'.\\') {\\n                for (let l = 1; l < 10; l++) {\\n                    if (isValid(board, i, j, l.toString())) {\\n                        board[i][j] = l.toString()\\n                        let solved = solveSudoku(board)\\n                        if (solved !== false) return solved   "]}
{"id": "1776", "ref_js": ["var numberOfPairs = function(nums) {\\n    const map = {};", "var numberOfPairs = function (nums) {\\n    let numsMap = new Map()\\n    let pairCount = 0;\\n    let leftover = 0\\n\\n    ", "var numberOfPairs = function(nums) {\\n    let pairs = 0\\n    \\n    let map = {};"]}
{"id": "1777", "ref_js": ["var trap = function(height) {\\n\\n    let left = [];\\n    let right = [];\\n    let n = height.length;\\n\\n    left[0] = height[0];\\n    right[n-1] = height[n-1];\\n\\n    for(let i = 1; i<n; i++)left[i] = Math.max(left[i-1], height[i]);\\n    for(let i = n - 2; i>=0; i--)right[i] = Math.max(right[i+1], height[i]);\\n    let ans = 0;\\n    for(let i = 0; i<n; i++) ans+=(Math.min(left[i], right[i])) - height[i];\\n\\n    return ans;\\n    \\n};", "var trap = function(height) {\\n    \\n    let max1 = 0;\\n    ", "var trap = function(height) {\\n\\n    let left = [];\\n    let right = [];\\n    let n = height.length;\\n\\n    left[0] = height[0];\\n    right[n-1] = height[n-1];\\n\\n    for(let i = 1; i<n; i++)left[i] = Math.max(left[i-1], height[i]);\\n    for(let i = n - 2; i>=0; i--)right[i] = Math.max(right[i+1], height[i]);\\n    let ans = 0;\\n    for(let i = 0; i<n; i++) ans+=(Math.min(left[i], right[i])) - height[i];\\n\\n    return ans;\\n    \\n};"]}
{"id": "1778", "ref_js": ["var isMatch = function(s, p) {\\n    let dp = [];\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};", "var isMatch = function(s, p) {\\n    let dp = [];\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};", "var isMatch = function(s, p) {\\n    let dp = [];\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};"]}
{"id": "1779", "ref_js": ["var solveNQueens = function(n, start = 0 , mat) {\\n    var mat = [...new Array(n)].map( ele => new Array(n).fill(\".\") );\\n    var len = mat.length\\n    var result = [];\\n    var count = 0\\n    helper(0, mat);\\n    return result\\n    \\n    function helper(row , mat ){\\n        if(row == n){\\n            result.push([...mat].map(ele => ele.join(\"\")));\\n            return\\n        }\\n        for(let j=0; j<len; j++){\\n            if(checkDigonal(row , j ,mat, n) ){\\n                mat[row][j] = \\'Q\\';\\n                helper(row + 1 , mat)\\n                mat[row][j] = \\'.\\';\\n            }   \\n        } \\n    }\\n};", "var solveNQueens = function (n) {\\n\\t\\t", "var solveNQueens = function(N) {\\n    let ans = [],\\n        board = Array.from({length: N}, () => new Array(N).fill(\\'.\\'))\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) {\\n            let res = new Array(N)\\n            for (let row = 0; row < N; row++)\\n                res[row] = board[row].join(\"\")\\n            ans.push(res)\\n            return\\n        }\\n        for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            board[i][j] = \\'Q\\'\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            board[i][j] = \\'.\\'\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};"]}
{"id": "1780", "ref_js": ["var totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};", "var totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};", "var totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};"]}
{"id": "1781", "ref_js": ["var getPermutation = function (n, k) {\\n  const factorials = {0: 1};", "var getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); ", "var getPermutation = function(n, k) {\\n    let factorial = [1];\\n    let nums = [];\\n    let result = \\'\\';\\n\\n    for (let i = 1; i <= n; i++) {\\n        factorial[i] = i * factorial[i - 1];\\n        nums.push(i);\\n    }\\n\\n    k--; "]}
{"id": "1782", "ref_js": ["var isNumber = function(S) {\\n    let exp = false, sign = false, num = false, dec = false\\n    for (let c of S)\\n        if (c >= \\'0\\' && c <= \\'9\\') num = true     \\n        else if (c === \\'e\\' || c === \\'E\\')\\n            if (exp || !num) return false\\n            else exp = true, sign = false, num = false, dec = false\\n        else if (c === \\'+\\' || c === \\'-\\')\\n            if (sign || num || dec) return false\\n            else sign = true\\n        else if (c === \\'.\\')\\n            if (dec || exp) return false\\n            else dec = true\\n        else return false\\n    return num\\n};", "var isNumber = function(s) {\\n    if(s === \\'Infinity\\' || s === \\'-Infinity\\' || s === \\'+Infinity\\') return false\\n    return !isNaN(Number(s));\\n};", "var isNumber = function(S) {\\n    let exp = false, sign = false, num = false, dec = false\\n    for (let c of S)\\n        if (c >= \\'0\\' && c <= \\'9\\') num = true     \\n        else if (c === \\'e\\' || c === \\'E\\')\\n            if (exp || !num) return false\\n            else exp = true, sign = false, num = false, dec = false\\n        else if (c === \\'+\\' || c === \\'-\\')\\n            if (sign || num || dec) return false\\n            else sign = true\\n        else if (c === \\'.\\')\\n            if (dec || exp) return false\\n            else dec = true\\n        else return false\\n    return num\\n};"]}
{"id": "1783", "ref_js": ["var fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };", "var fullJustify = function(words, maxWidth) {\\n    ", "var fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n"]}
{"id": "1784", "ref_js": ["var minWindow = function (s, t) {\\n  let result = \"\";\\n  let leftPtr = 0;\\n  let rightPtr = 0;\\n  let windowCountMap = {};", "var minWindow = function (s, t) {\\n  let result = \"\";\\n  let leftPtr = 0;\\n  let rightPtr = 0;\\n  let windowCountMap = {};", "var minWindow = function (s, t) {\\n  let result = \"\";\\n  let leftPtr = 0;\\n  let rightPtr = 0;\\n  let windowCountMap = {};"]}
{"id": "1785", "ref_js": ["var largestRectangleArea = function(heights) {\\n    const n = heights.length;\\n    const nsr = new Array(n).fill(0);\\n    const nsl = new Array(n).fill(0);\\n\\n    const stack = [];\\n        \\n    for (let i = n - 1; i >= 0; i--) {\\n        while (stack.length !== 0 && heights[i] <= heights[stack[stack.length - 1]]) {\\n                stack.pop();\\n        }\\n        if (stack.length === 0) {\\n            nsr[i] = n;\\n        } else {\\n            nsr[i] = stack[stack.length - 1];\\n        }\\n        stack.push(i);\\n    }\\n\\n    while (stack.length !== 0) {\\n        stack.pop();\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        while (stack.length !== 0 && heights[i] <= heights[stack[stack.length - 1]]) {\\n            stack.pop();\\n        }\\n        if (stack.length === 0) {\\n            nsl[i] = -1;\\n        } else {\\n             nsl[i] = stack[stack.length - 1];\\n        }\\n        stack.push(i);\\n    }\\n\\n    let ans = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        ans = Math.max(ans, heights[i] * (nsr[i] - nsl[i] - 1));\\n    }\\n   \\n    return ans;\\n};", "var largestRectangleArea = function(heights) {\\n    let stack = [];\\n    stack.push(-1);\\n    stack.push(0);\\n    let maxarea = heights[0];\\n    for(let i = 1; i< heights.length; i++){\\n        if(heights[i]>=heights[stack[stack.length-1]])\\n            stack.push(i);\\n        else {\\n            while(stack[stack.length-1] >= 0 && heights[i] <= heights[stack[stack.length-1]]){\\n                let ind = stack.pop();\\n                maxarea = Math.max(maxarea, (i - stack[stack.length-1] -1)*heights[ind]);\\n            }\\n            stack.push(i)\\n        }\\n    }\\n\\n    while(stack[stack.length-1] >= 0){\\n        let ind = stack.pop();\\n        maxarea = Math.max(maxarea, (heights.length - stack[stack.length-1] -1)*heights[ind]);\\n    }\\n    return maxarea;\\n};", "var largestRectangleArea = function(heights) {\\n    let stack = [];\\n    stack.push(-1);\\n    stack.push(0);\\n    let maxarea = heights[0];\\n    for(let i = 1; i< heights.length; i++){\\n        if(heights[i]>=heights[stack[stack.length-1]])\\n            stack.push(i);\\n        else {\\n            while(stack[stack.length-1] >= 0 && heights[i] <= heights[stack[stack.length-1]]){\\n                let ind = stack.pop();\\n                maxarea = Math.max(maxarea, (i - stack[stack.length-1] -1)*heights[ind]);\\n            }\\n            stack.push(i)\\n        }\\n    }\\n\\n    while(stack[stack.length-1] >= 0){\\n        let ind = stack.pop();\\n        maxarea = Math.max(maxarea, (heights.length - stack[stack.length-1] -1)*heights[ind]);\\n    }\\n    return maxarea;\\n};"]}
{"id": "1786", "ref_js": ["var maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};", "var maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};", "var maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};"]}
{"id": "1787", "ref_js": ["var isScramble = function (s1, s2, memo = {}) {\\n  ", "var isScramble = function(s1, s2) {\\n    if (s1.length !== s2.length) {\\n        return false;\\n    }\\n    const isValid = (s1, s2) => {\\n        let res = 0;\\n        for (let i = 0; i < s1.length; i++) {\\n            res ^= s1.charCodeAt(i) ^ s2.charCodeAt(i);\\n        }\\n        return res === 0;\\n    };", "var isScramble = function(s1, s2) {\\n    let dp = new Map();\\n    \\n    function isScrambleHelper(s1, s2) {\\n        if (s1 === s2) {\\n            return true;\\n        }\\n        if (dp.has(s1 + s2)) {\\n            return dp.get(s1 + s2);\\n        }\\n        \\n        if (s1.split(\\'\\').sort().join(\\'\\') !== s2.split(\\'\\').sort().join(\\'\\')) {\\n            dp.set(s1 + s2, false);\\n            return false;\\n        }\\n        \\n        for (let i = 1; i < s1.length; i++) {\\n            if ((isScrambleHelper(s1.substring(0, i), s2.substring(0, i)) && isScrambleHelper(s1.substring(i), s2.substring(i))) ||\\n                (isScrambleHelper(s1.substring(0, i), s2.substring(s1.length - i)) && isScrambleHelper(s1.substring(i), s2.substring(0, s1.length - i)))) {\\n                dp.set(s1 + s2, true);\\n                return true;\\n            }\\n        }\\n        dp.set(s1 + s2, false);\\n        return false;\\n    }\\n    \\n    return isScrambleHelper(s1, s2);\\n};"]}
{"id": "1788", "ref_js": ["var recursiveWithoutMemoization=function(s, t, s_ind, t_ind) {\\n        if (t_ind === t.length) {\\n            return 1;\\n        }\\n        if (s_ind === s.length) {\\n            return 0;\\n        }\\n\\n        let take = 0, notTake = 0;\\n\\n        if (s[s_ind] === t[t_ind]) {\\n            take =  recursiveWithoutMemoization(s, t, s_ind + 1, t_ind + 1);\\n        }\\n\\n        notTake =  recursiveWithoutMemoization(s, t, s_ind + 1, t_ind);\\n\\n        return take + notTake;\\n    }\\n\\n    var numDistinct= function(s, t) {\\n        return  recursiveWithoutMemoization(s, t, 0, 0);\\n    }\\n\\n```\\n\\n\\n```ruby []\\nclass Solution\\n  def recursive_without_memoization(s, t, s_ind, t_ind)\\n    return 1 if t_ind == t.length\\n    return 0 if s_ind == s.length\\n\\n    take = 0\\n    not_take = 0\\n\\n    if s[s_ind] == t[t_ind]\\n      take = recursive_without_memoization(s, t, s_ind + 1, t_ind + 1)\\n    end\\n\\n    not_take = recursive_without_memoization(s, t, s_ind + 1, t_ind)\\n\\n    take + not_take\\n  end\\n\\n  def num_distinct(s, t)\\n    recursive_without_memoization(s, t, 0, 0)\\n  end\\nend\\n```\\n\\n---\\n---\\n\\n## \\uD83D\\uDCA1Approach 2 : Memoization Optimization\\n\\nMemoization is a technique used to store and reuse the results of expensive function calls to avoid redundant calculations. In the context of our problem, we can create a memoization table to store the results of subproblems. Each entry `dp[i][j]` will represent the number of distinct subsequences of `s` starting from index `i` that form the string `t` starting from index `j`.\\n\\nWe\\'ll modify our recursive function to first check if we have already calculated the result for the current subproblem. If we have, we\\'ll simply return the cached result. If not, we\\'ll proceed with the recursive calculations and store the result in the memoization table.\\n\\n## Complexity Analysis\\n\\nLet\\'s analyze the\\n\\n time and space complexity of our memoized solution:\\n\\n- Time Complexity: The time complexity of our algorithm is O(m * n), where `m` is the length of string `s` and `n` is the length of string `t`. This is because we fill up the `dp` table, which has dimensions `m x n`, and each cell takes constant time to compute.\\n\\n- Space Complexity: The space complexity is also O(m * n) due to the `dp` table.\\n\\n# \\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBBCode\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    int recursiveWithMemoization(string& s, string& t, int s_ind, int t_ind, vector<vector<int>>& dp) {\\n        if (t_ind == t.length()) {\\n            return 1;\\n        }\\n        if (s_ind == s.length()) {\\n            return 0;\\n        }\\n\\n        if (dp[s_ind][t_ind] != -1) {\\n            return dp[s_ind][t_ind];\\n        }\\n\\n        int take = 0, notTake = 0;\\n\\n        if (s[s_ind] == t[t_ind]) {\\n            take = recursiveWithMemoization(s, t, s_ind + 1, t_ind + 1, dp);\\n        }\\n\\n        notTake = recursiveWithMemoization(s, t, s_ind + 1, t_ind, dp);\\n\\n        dp[s_ind][t_ind] = take + notTake;\\n\\n        return dp[s_ind][t_ind];\\n    }\\n\\n    int numDistinct(string s, string t) {\\n        vector<vector<int>> dp(s.length(), vector<int>(t.length(), -1));\\n        return recursiveWithMemoization(s, t, 0, 0, dp);\\n    }\\n};", "var numDistinct = function (s, t) {\\n    if (s.length < t.length) return 0;\\n    [s, t] = [t, s];\\n\\n    let m = s.length;\\n    let n = t.length;\\n    let aa = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\\n\\n    for (let j = 0; j <= n; j++) {\\n        aa[0][j] = 1;\\n    }\\n\\n    for (let i = 1; i <= m; i++)\\n        for (let j = 1; j <= n; j++)\\n            if (s[i - 1] === t[j - 1]) {\\n                aa[i][j] = aa[i][j - 1] + aa[i - 1][j - 1];\\n            } else {\\n                aa[i][j] = aa[i][j - 1];\\n            }\\n\\n    return aa[m][n];\\n};", "var numDistinct = function(s, t) {\\n    \\n    "]}
{"id": "1789", "ref_js": ["var maxProfit = function(prices) {\\n    let maxReverse = 0;\\n    let maxProfitReverse = 0;\\n    let maxProfitReverseArray = new Array(prices.length).fill(0);\\n\\n    let min = Infinity;\\n    let maxProfit = 0;\\n    let maxTotalProfit = 0;\\n\\n    ", "var maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        ", "var maxProfit = function(prices) {\\n  if(prices.length == 0) return 0\\n  \\n  let dp = new Array(prices.length).fill(0);\\n  let min = prices[0];\\n  let max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i]);  "]}
{"id": "1790", "ref_js": ["var maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};", "var maxPathSum = function (root) {\\n  const ans = { val: -Infinity };", "var maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};"]}
{"id": "1791", "ref_js": ["var findLadders = function(beginWord, endWord, wordList) {\\n    ", "var findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return []\\n    if (beginWord === endWord) return [[beginWord]]\\n    wordList.push(beginWord)\\n    const wordToNeighbors = new Map()\\n    const wordToShortest = new Map()\\n    const shortestLen = findShortestLen(beginWord, endWord)\\n    const ladders = []\\n    const curLadder = [beginWord]\\n    recursion(beginWord, shortestLen)\\n    return ladders\\n\\n    \\n    function recursion(curWord, curShortest) {\\n        if (curShortest === 0) {\\n            ladders.push([...curLadder])\\n            return\\n        }\\n        const neighbors = findAllNeighbors(curWord)\\n        for (let neighbor of neighbors) {\\n            if (!wordToShortest.has(neighbor) || wordToShortest.get(neighbor) != curShortest - 1) continue\\n            curLadder.push(neighbor)\\n            recursion(neighbor, curShortest - 1)\\n            curLadder.pop()\\n        }\\n    }\\n    \\n    \\n    function findShortestLen(beginWord, endWord) {\\n        const queue = []\\n        queue.push(endWord)\\n        let count = 0\\n        wordToShortest.set(endWord, count)\\n        while (queue.length !== 0) {\\n            count++;\\n            const size = queue.length\\n            for (let i = 0; i < size; i++) {\\n                const curLast = queue.shift()\\n                const neighbors = findAllNeighbors(curLast)\\n                for (let neighbor of neighbors) {\\n                    if (wordToShortest.has(neighbor)) continue\\n                    wordToShortest.set(neighbor, count)\\n                    if (neighbor === beginWord)  {\\n                        return count\\n                    }\\n                    queue.push(neighbor)\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n    \\n    function findAllNeighbors(word) {\\n        if (wordToNeighbors.has(word)) return wordToNeighbors.get(word)\\n        neighbors = []\\n        for (let w of wordList) {\\n            if (isNeighbor(word, w)) {\\n                neighbors.push(w)\\n            }\\n        }\\n        wordToNeighbors.set(word, neighbors)\\n        return neighbors\\n    }\\n    \\n    function isNeighbor(w1, w2) {\\n        if (w1.length !== w2.length) return false\\n        let diff = 0\\n        for (let i = 0; i < w1.length; i++) {\\n            if (w1.charAt(i) !== w2.charAt(i)) {\\n                diff++\\n                if (diff > 1) return false\\n            }\\n        }\\n        return diff === 1\\n    }\\n};", "var findLadders = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList);\\n    wordSet.add(beginWord);\\n    \\n    if (!wordSet.has(endWord)) return [];\\n    \\n    const distanceMap = new Map();\\n    const wordMap = new Map();\\n    \\n    "]}
{"id": "1792", "ref_js": ["var ladderLength = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList)\\n    let queue = [beginWord];\\n    let steps = 1;\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        ", "var ladderLength = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList)\\n    let queue = [beginWord];\\n    let steps = 1;\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        ", "var ladderLength = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList)\\n    let queue = [beginWord];\\n    let steps = 1;\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        "]}
{"id": "1793", "ref_js": ["var isPalindrome = function(j,k,string){\\n    while(j<k){\\n        if(string[j] !== string[k]){\\n            return false;\\n        }\\n        k--;\\n        j++\\n    }\\n    return true\\n}\\nvar rec = function(i,len,str,dp){\\n    if(i===len)return 0;\\n    if(dp[i] !== -1)return dp[i]\\n    let min = Number.MAX_VALUE;\\n    for(let j=i;j<len;j++){\\n        if(isPalindrome(i,j,str)){\\n           let cuts =  1+ rec(j+1,len,str,dp)\\n              min = Math.min(cuts,min)\\n      }\\n        \\n    }\\n    return dp[i] = min\\n}\\nvar minCut = function(s) {\\n    let n = s.length;\\n    let sol = Array(n).fill(-1);\\n    return rec(0,n,s,sol) -1\\n};", "var minCut = function(s) {\\n    const n = s.length;\\n    const dp = new Array(n).fill(0);\\n    const isPalindrome = new Array(n).fill(null).map(() => new Array(n).fill(false));\\n\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = i; ", "var minCut = function(s) {\\n  if (s.length === 1 || s === s.split(\\'\\').reverse().join(\\'\\') || s.length === 0) {\\n    return 0;\\n  }\\n  const isPalindrome = Array.from({ length: s.length }, () => Array.from({ length: s.length }, () => false));\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j = 0; j <= i; j++) {\\n      if (s[i] === s[j] && (i - j <= 1 || isPalindrome[j + 1][i - 1])) {\\n        isPalindrome[j][i] = true;\\n      }\\n    }\\n  }\\n  const dp = Array.from({ length: s.length }, () => Infinity);\\n  dp[0] = 0;\\n  for (let i = 1; i < s.length; i++) {\\n    if (isPalindrome[0][i]) {\\n      dp[i] = 0;\\n    } \\n    else {\\n      for (let j = 0; j < i; j++) {\\n        if (isPalindrome[j + 1][i]) {\\n          dp[i] = Math.min(dp[i], dp[j] + 1);\\n        }\\n      }\\n    }\\n  }\\n  return dp[dp.length - 1];\\n};"]}
{"id": "1794", "ref_js": ["var candy = function(ratings) {\\n    const n = ratings.length;\\n    const candies = new Array(n).fill(1);\\n\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1]) {\\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n        }\\n    }\\n\\n    return candies.reduce((a, b) => a + b, 0);\\n};", "var candy = function(ratings) {\\n    const n = ratings.length;\\n    let totalCandies = n;\\n    let i = 1;\\n\\n    while (i < n) {\\n        if (ratings[i] === ratings[i - 1]) {\\n            i++;\\n            continue;\\n        }\\n\\n        let currentPeak = 0;\\n        while (i < n && ratings[i] > ratings[i - 1]) {\\n            currentPeak++;\\n            totalCandies += currentPeak;\\n            i++;\\n        }\\n\\n        if (i === n) {\\n            return totalCandies;\\n        }\\n\\n        let currentValley = 0;\\n        while (i < n && ratings[i] < ratings[i - 1]) {\\n            currentValley++;\\n            totalCandies += currentValley;\\n            i++;\\n        }\\n\\n        totalCandies -= Math.min(currentPeak, currentValley);\\n    }\\n\\n    return totalCandies;    \\n};", "var candy = function(ratings) {\\n    const n = ratings.length;\\n    let totalCandies = n;\\n    let i = 1;\\n\\n    while (i < n) {\\n        if (ratings[i] === ratings[i - 1]) {\\n            i++;\\n            continue;\\n        }\\n\\n        let currentPeak = 0;\\n        while (i < n && ratings[i] > ratings[i - 1]) {\\n            currentPeak++;\\n            totalCandies += currentPeak;\\n            i++;\\n        }\\n\\n        if (i === n) {\\n            return totalCandies;\\n        }\\n\\n        let currentValley = 0;\\n        while (i < n && ratings[i] < ratings[i - 1]) {\\n            currentValley++;\\n            totalCandies += currentValley;\\n            i++;\\n        }\\n\\n        totalCandies -= Math.min(currentPeak, currentValley);\\n    }\\n\\n    return totalCandies;    \\n};"]}
{"id": "1795", "ref_js": ["var wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            ", "var wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            ", "var wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            "]}
{"id": "1796", "ref_js": ["var maxPoints = function (ps) {\\n    if (ps.length <= 2) return ps.length; ", "var maxPoints = function(points) {\\n    if (points.length === 1) return 1 ", "var maxPoints = function (points, max = 0) {\\n"]}
{"id": "1797", "ref_js": ["var findMin = function(nums) {\\n    return Math.min(...nums);\\n};", "var findMin = function(nums) {\\n    if (nums.length === 1) {\\n        return nums[0];\\n    }\\n\\n    if (nums.length === 2) {\\n        if (nums[0] > nums[1]) {\\n            return nums[1];\\n        }\\n        return nums[0];\\n    }\\n\\n    const middleIndex = Math.floor(nums.length / 2);\\n    const middleNumber = nums[middleIndex];\\n    const lastNumber = nums[nums.length - 1];\\n\\n    if (middleNumber > lastNumber) {\\n        return findMin(nums.splice(middleIndex));\\n    } else {\\n        if (middleNumber === lastNumber) {\\n            return Math.min(findMin(nums.slice(middleIndex)), findMin(nums.slice(0, middleIndex)));\\n        }\\n        return findMin(nums.splice(0, middleIndex + 1));\\n    }\\n};", "var findMin = function(nums) {\\n    let low = 0, high = nums.length - 1, ans = Infinity;\\n    while(low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n        if(nums[low] < nums[high]) {\\n            ans = Math.min(ans, nums[low]);\\n            break;\\n        }\\n        if(nums[low] === nums[mid] && nums[mid] === nums[high]) {\\n            ans = Math.min(ans, nums[low]);\\n            low += 1;\\n            high -= 1;\\n        } else if(nums[low] <= nums[mid]) {\\n            ans = Math.min(ans, nums[low]);\\n            low = mid + 1;\\n        } else {\\n            ans = Math.min(ans, nums[mid]);\\n            high = mid - 1;\\n        }\\n    }\\n    return ans;\\n};"]}
{"id": "1798", "ref_js": ["var maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};", "var maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};", "var maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};"]}
{"id": "1799", "ref_js": ["var calculateMinimumHP = function(dungeon) {\\n    let h = dungeon.length - 1;\\n    let w = dungeon[0].length - 1;\\n    let dp = Array.from({length: dungeon.length}, () => Array(dungeon[0].length));\\n\\n    dp[h][w] = Math.max(1, 1 - dungeon[h][w]);\\n\\n    for(let y = h; y >= 0; y--){\\n        let start = y === h ? w - 1 : w;\\n        for(let x = start; x >= 0; x--){\\n            dp[y][x] = Math.max(1, 1 - dungeon[y][x], Math.min(dp[y + 1]?.[x] ?? Infinity, dp[y][x + 1] ?? Infinity) - dungeon[y][x]);\\n        }\\n    }\\n    return dp[0][0];\\n};", "var calculateMinimumHP = function(dungeon) {\\n    ", "var calculateMinimumHP = function(dungeon) {\\n    const height = dungeon.length-1;\\n    const width = dungeon[0].length-1;\\n    const dp = Array.from({length: dungeon.length} , ()=> Array(dungeon[0].length));\\n\\n    dp[height][width] = Math.max(1, 1-dungeon[height][width]);\\n\\n    for (let y = height; y>=0; y--){\\n        const start = y == height ? width -1 : width;\\n        for (let x = start; x>=0; x--){\\n            dp[y][x] = Math.max(1, 1-dungeon[y][x] ,  Math.min(dp[y+1]?.[x] ?? Infinity, dp[y][x+1] ?? Infinity) - dungeon[y][x]);\\n        }   \\n    }\\n\\n    return dp[0][0];\\n};"]}
{"id": "1801", "ref_js": ["var maxProfit = function(k, prices) {\\n    let transactions = Array.from({ length: k }, () => [1000, 0]);\\n    let prev_profit = 0;\\n\\n    for (let i = 0; i < prices.length; i++) {\\n        prev_profit = 0;\\n        for (let j = 0; j < k; j++) {\\n            transactions[j][0] = Math.min(transactions[j][0], prices[i] - prev_profit);\\n            transactions[j][1] = Math.max(transactions[j][1], prices[i] - transactions[j][0]);\\n            prev_profit = transactions[j][1];\\n        }\\n    }\\n\\n    return transactions[k-1][1];\\n};", "var maxProfit = function(k, prices) {\\n    const memo = {}\\n    \\n    const dp = (i,r,h) => {\\n        const id = `${i}:${r}:${h}`\\n        if (memo[id] || memo[id] === 0) return memo[id]\\n        if (r <= 0) return 0 \\n        if (i >= prices.length) return 0 \\n        \\n        if (h) {\\n            memo[id] = Math.max(prices[i] + dp(i+1,r-1,false), dp(i+1,r,true))\\n        } else {\\n            memo[id] = Math.max(-prices[i] + dp(i+1,r,true), dp(i+1,r,false))\\n        }\\n        \\n        return memo[id]\\n    }\\n    \\n    return dp(0,k,false)\\n};", "var maxProfit = function(k, prices) {\\n    let transactions = Array.from({ length: k }, () => [1000, 0]);\\n    let prev_profit = 0;\\n\\n    for (let i = 0; i < prices.length; i++) {\\n        prev_profit = 0;\\n        for (let j = 0; j < k; j++) {\\n            transactions[j][0] = Math.min(transactions[j][0], prices[i] - prev_profit);\\n            transactions[j][1] = Math.max(transactions[j][1], prices[i] - transactions[j][0]);\\n            prev_profit = transactions[j][1];\\n        }\\n    }\\n\\n    return transactions[k-1][1];\\n};"]}
{"id": "1802", "ref_js": ["var findWords = function (board, words) {\\n  let trie = {};", "var findWords = function (board, words) {\\n  let trie = {};", "var findWords = function (board, words) {\\n  let trie = {};"]}
{"id": "1803", "ref_js": ["var shortestPalindrome = function (s) {\\n    if (s === \"\") {\\n        return s;\\n    }\\n\\n    let tempStr = s + \"#\" + s.reverse();\\n    let len = lps(tempStr);\\n    let strLength = s.length;\\n\\n    return s.substring(len, strLength).reverse() + s;\\n};", "var shortestPalindrome = function(s) {\\n    const reversed = s.split(\\'\\').reverse().join(\\'\\');\\n    const concat = s + \\'#\\' + reversed;\\n\\n    const prefixArray = new Array(concat.length).fill(0);\\n    \\n    for (let i = 1; i < concat.length; i++) {\\n        let j = prefixArray[i - 1];\\n        \\n        while (j > 0 && concat[i] !== concat[j]) {\\n            j = prefixArray[j - 1];\\n        }\\n        \\n        if (concat[i] === concat[j]) {\\n            j++;\\n        }\\n        \\n        prefixArray[i] = j;\\n    }\\n\\n    const longestPalindromePrefix = reversed.substring(0, s.length - prefixArray[concat.length - 1]);\\n    \\n    return longestPalindromePrefix + s;\\n};", "var shortestPalindrome = function (s) {\\n    let len = s.length\\n    let rev = s.split(\\'\\').reverse().join(\\'\\')\\n\\n    for (let i = 0; i < len; ++i) {\\n        if (rev.slice(i) == s.slice(0, len - i)) {\\n            return rev.slice(0, i) + s\\n        }\\n    }\\n\\n    return \"\"\\n};"]}
{"id": "1804", "ref_js": ["var getSkyline = function(buildings) {\\n    let xx = new Set();\\n    buildings.forEach(b => {\\n        xx.add(b[0]);\\n        xx.add(b[1]);\\n    });\\n    let xxx = Array.from(xx.keys()).sort((a,b) => a - b);\\n    let rtn = [];\\n    xxx.forEach(x => {\\n        let b = buildings.filter(b => b[0] === x || b[0] < x && b[1] > x);\\n        let max = 0;\\n        for(let i = 0; i < b.length; i++) {\\n            max = Math.max(max, b[i][2]);\\n        }\\n        rtn.push([x, max]);\\n    });\\n\\n    for(let i = 1; i < rtn.length; i++) {\\n        const prv = rtn[i-1];\\n        const cur = rtn[i];\\n        if (prv[1] === cur[1]) {\\n            rtn.splice(i, 1);\\n            i--;\\n        }\\n    }\\n\\n    return rtn;\\n};", "var getSkyline = function(buildings) {\\n  const startsAndEnds = [];\\n\\n  ", "var getSkyline = function(buildings) {\\n  const startsAndEnds = [];\\n\\n  "]}
{"id": "1805", "ref_js": ["var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    if(nums.length<2) return false\\n    if(nums.length==100000 && valueDiff == 0 && indexDiff == 100000) return false\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i;j<nums.length;j++){\\n            if(i!=j && Math.abs(i-j)<=indexDiff && Math.abs(nums[i]-nums[j])<= valueDiff){\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n};", "var containsNearbyAlmostDuplicate = function(nums, k, t) {\\n   for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=t && (Math.abs(i-j)<=k)){\\n                return true;\\n            }\\n        }\\n   }\\n    return false;\\n};", "var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n\\tlet first = 0\\n    let i = 0\\n    while (first < nums.length-1) {\\n        let diif1 = Math.abs(first - i++)\\n        let dif = Math.abs(nums[first] - nums[i])\\n        if (diif1 <= indexDiff && dif <= valueDiff)\\n            return true\\n        else if (i - first == indexDiff) {\\n            first++\\n            i = first\\n        }\\n    }\\n    return false\\n};"]}
{"id": "1806", "ref_js": ["var calculate = function(s) {\\n    let res = 0, sum = 0, sign = 1;\\n    let myStack = [];\\n    myStack.push(1);\\n    const isDigit = (ch) => {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    for(let ch of s){\\n        if(isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n        else{\\n            res += sum * sign * myStack[myStack.length - 1];\\n            sum = 0;\\n            if(ch === \\'-\\') sign = -1;\\n            else if(ch === \\'+\\') sign = 1;\\n            else if(ch === \\'(\\') {myStack.push(myStack[myStack.length - 1] * sign); sign = 1;}\\n            else if(ch === \\')\\') myStack.pop(); \\n        }\\n    }\\n    return res += (sign * sum);\\n};", "var calculate = function(s) {\\n    let sign = 1, sum = 0;\\n    \\n    const stack = []; \\n    for (let i = 0; i < s.length; i += 1) {\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            let num = 0\\n\\t\\t\\t", "var calculate = function(s) {\\n    let res=0,sign=1,sum=0;\\n    let stack=[1]\\n   for(let x of s){\\n        if(x >= \\'0\\' && x <= \\'9\\') sum = sum * 10 + (x - \\'0\\');\\n        else{\\n            res += sum * sign * stack[stack.length - 1];\\n            sum = 0;\\n            if(x === \\'-\\') sign = -1;\\n            else if(x === \\'+\\') sign = 1;\\n            else if(x === \\'(\\') {stack.push(stack[stack.length - 1] * sign); sign = 1;}\\n            else if(x === \\')\\') stack.pop(); \\n        }\\n          \\n   }\\n    return res += (sign * sum);\\n};"]}
{"id": "1807", "ref_js": ["var countDigitOne = function(n) {\\n        if(n <= 0) return 0;\\n        if(n < 10) return 1;\\n        var base = Math.pow(10, n.toString().length - 1);\\n        var answer = parseInt(n / base);\\n        return countDigitOne(base - 1) * answer + (answer === 1 ? (n - base + 1) : base) + countDigitOne(n % base);\\n    };", "var countDigitOne = function(n) {\\n    if (n <= 0) {\\n        return 0;\\n    }\\n\\n    let count = 0;\\n    let factor = 1;\\n\\n    while (factor <= n) {\\n        let divisor = factor * 10;\\n        count += Math.floor(n / divisor) * factor;\\n        let remainder = n % divisor;\\n        count += Math.min(Math.max(0, remainder - factor + 1), factor);\\n        factor *= 10;\\n    }\\n\\n    return count;\\n};", "var countDigitOne = function(n) {\\n  if(n <= 0) return false;\\n  if(n < 10) return 1;\\n  let base = Math.pow(10, n.toString().length - 1);\\n  let answer = parseInt(n / base);\\n  return countDigitOne(base - 1) * answer + (answer === 1 ? (n - base + 1) : base) + countDigitOne(n % base);\\n};"]}
{"id": "1808", "ref_js": ["var maxSlidingWindow = function(nums, k) {\\n    const q = [];  ", "var maxSlidingWindow = function(nums, k) {\\n    const res = [];\\n    let left = 0;\\n    let right = 0;\\n    const q = [];\\n\\n    while (right < nums.length) {\\n        while (q.length > 0 && nums[right] > nums[q[q.length - 1]]) {\\n            q.pop();\\n        }\\n        q.push(right);\\n\\n        if (left > q[0]) {\\n            q.shift();\\n        }\\n\\n        if (right + 1 >= k) {\\n            res.push(nums[q[0]]);\\n            left++;\\n        }\\n        right++;\\n    }\\n\\n    return res;    \\n};", "var maxSlidingWindow = function(nums, k) {\\n    const res = [];\\n    let left = 0;\\n    let right = 0;\\n    const q = [];\\n\\n    while (right < nums.length) {\\n        while (q.length > 0 && nums[right] > nums[q[q.length - 1]]) {\\n            q.pop();\\n        }\\n        q.push(right);\\n\\n        if (left > q[0]) {\\n            q.shift();\\n        }\\n\\n        if (right + 1 >= k) {\\n            res.push(nums[q[0]]);\\n            left++;\\n        }\\n        right++;\\n    }\\n\\n    return res;    \\n};"]}
{"id": "1810", "ref_js": ["var numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};", "var numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};", "var numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};"]}
{"id": "1811", "ref_js": ["var addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};", "var addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};", "var addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};"]}
{"id": "1814", "ref_js": ["var removeInvalidParentheses = function(s) {\\n    \\n    \\n    ", "var removeInvalidParentheses = function(s) {\\n\\n   \\n\\n    const res = new Set()\\n\\n    let open = 0\\n    let adds = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] == \\'(\\') {\\n            open++;\\n        } else if (s[i] == \\')\\') {\\n            if (open == 0) {\\n                adds++;\\n            } else {\\n                open--;\\n            }\\n        }\\n    }\\n   adds += open;\\n\\n   const cache = {}\\n\\n   \\n\\n    function dfs(pars,invalids) {\\n\\n        if(cache[pars]){\\n            return\\n        }\\n        else {\\n            cache[pars] =1\\n        }\\n\\n\\n\\n        if(invalids == 0) {\\n\\n            if(isValid(pars)){\\n                res.add(pars)\\n            }\\n            return\\n        }\\n\\n        for(let i = 0; i< pars.length; i++){\\n            let left = pars.substring(0,i)\\n            let right = pars.substring( i+1)\\n\\n            dfs(left+right,invalids-1)\\n        }\\n    }\\n\\n    dfs(s,adds)\\n\\n\\n\\n    return  res.size ? Array.from(res) : [\\'\\']\\n    \\n};", "var removeInvalidParentheses = function(s) {\\n  let minRemovals = Infinity;\\n  let validExpressions = new Set();\\n\\n  function isValid(expression) {\\n    let count = 0;\\n    for (let char of expression) {\\n      if (char === \\'(\\') {\\n        count += 1;\\n      } else if (char === \\')\\') {\\n        count -= 1;\\n        if (count < 0) {\\n          return false;\\n        }\\n      }\\n    }\\n    return count === 0;\\n  }\\n\\n  function backtrack(expression, index, openCount, closeCount, removalCount) {\\n    if (index === s.length) {\\n      if (openCount === closeCount && removalCount <= minRemovals) {\\n        const result = expression.join(\\'\\');\\n        if (removalCount < minRemovals) {\\n          validExpressions.clear();\\n          minRemovals = removalCount;\\n        }\\n        validExpressions.add(result);\\n      }\\n    } else {\\n      const char = s.charAt(index);\\n\\n      if (char === \\'(\\' || char === \\')\\') {\\n        backtrack(expression, index + 1, openCount, closeCount, removalCount + 1);\\n      }\\n\\n      expression.push(char);\\n\\n      if (char !== \\'(\\' && char !== \\')\\') {\\n        backtrack(expression, index + 1, openCount, closeCount, removalCount);\\n      } else if (char === \\'(\\') {\\n        backtrack(expression, index + 1, openCount + 1, closeCount, removalCount);\\n      } else if (closeCount < openCount) {\\n        backtrack(expression, index + 1, openCount, closeCount + 1, removalCount);\\n      }\\n\\n      expression.pop();\\n    }\\n  }\\n\\n  backtrack([], 0, 0, 0, 0);\\n\\n  return Array.from(validExpressions);\\n};"]}
{"id": "1815", "ref_js": ["var maxCoins = function (nums) {\\n    let n = nums.length;\\n    nums.push(1);\\n    nums.unshift(1);\\n    let dp = new Array(n + 2).fill(0).map(() => new Array(n + 2).fill(0))\\n\\n    for (let i = n; i >= 1; i--) {\\n        for (let j = 1; j <= n; j++) {\\n            if (i > j) continue;\\n            \\n            let maxi = -Infinity;\\n            for (let k = i; k <= j; k++) {\\n                let earn = nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k-1] + dp[k+1][j];\\n                maxi = Math.max(earn, maxi);\\n            }\\n            dp[i][j] = maxi;\\n        }\\n    }\\n\\n    return dp[1][n];\\n};", "var maxCoins = function(nums) {\\n   nums.push(1);\\n   nums.unshift(1);\\n   let dp = [...Array(nums.length)].map(() => Array(nums.length).fill(0));\\n\\n   for(let windowSize = 1; windowSize < nums.length - 1; windowSize++){\\n       for(let start = 1, end = windowSize; end < nums.length - 1; end++, start++){\\n           for(let i = start; i <= end; i++){\\n               let coins = dp[start][i - 1] + (nums[start - 1] * nums[i] * nums[end + 1]) + dp[i + 1][end];\\n               dp[start][end] = Math.max(dp[start][end], coins);\\n           }\\n       }\\n   } \\n   return dp[1][nums.length - 2];\\n};", "var maxCoins = function(nums) {\\n   nums.push(1);\\n   nums.unshift(1);\\n   let dp = [...Array(nums.length)].map(() => Array(nums.length).fill(0));\\n\\n   for(let windowSize = 1; windowSize < nums.length - 1; windowSize++){\\n       for(let start = 1, end = windowSize; end < nums.length - 1; end++, start++){\\n           for(let i = start; i <= end; i++){\\n               let coins = dp[start][i - 1] + (nums[start - 1] * nums[i] * nums[end + 1]) + dp[i + 1][end];\\n               dp[start][end] = Math.max(dp[start][end], coins);\\n           }\\n       }\\n   } \\n   return dp[1][nums.length - 2];\\n};"]}
{"id": "1816", "ref_js": ["var countSmaller = function(nums) \\n{\\n        \\n        const FTree = function(min,max)\\n        {\\n                const offset = 1 - min;         ", "var countSmaller = function(nums) {\\n    let n = nums.length, nums1 = [];\\n\\t", "var countSmaller = function(nums) \\n{\\n        \\n        const FTree = function(min,max)\\n        {\\n                const offset = 1 - min;         "]}
{"id": "1817", "ref_js": ["var maxNumber = function (nums1, nums2, k) {\\n  const maxSingleNumber = (nums, k) => {\\n    const stack = [];\\n    let toPop = nums.length - k;\\n\\n    for (const num of nums) {\\n      while (toPop > 0 && stack.length > 0 && num > stack[stack.length - 1]) {\\n        stack.pop();\\n        toPop--;\\n      }\\n      stack.push(num);\\n    }\\n\\n    return stack.slice(0, k);\\n  };", "var maxNumber = function (nums1, nums2, k) {\\n  const n1 = nums1.length;\\n  const n2 = nums2.length;\\n  let result = Array(k).fill(0);\\n  let candidate = Array(k).fill(0);\\n  const part1 = Array(k + 1).fill(0);\\n  const part2 = Array(k + 1).fill(0);\\n\\n  \\n  function pickPart(source, target, k) {\\n    let rm = source.length - k;\\n    let j = 0;\\n\\n    for (let i = 0; i < source.length; i++) {\\n      while (rm && j && source[i] > target[j - 1]) {\\n        rm--;\\n        j--;\\n      }\\n      target[j++] = source[i];\\n    }\\n\\n    target[k] = -1;\\n    return target;\\n  }\\n\\n  const lowerL = Math.max(0, k - n2);\\n  const upperL = Math.min(n1, k);\\n  let l2, opt;\\n\\n  function merge() {\\n    let i1 = 0;\\n    let i2 = 0;\\n    let flagOpt = false;\\n\\n    for (let i = 0; i < k; i++) {\\n      let r1 = i1;\\n      let r2 = i2;\\n      while (part1[r1] === part2[r2] && part1[r1] !== -1) {\\n        r1++;\\n        r2++;\\n      }\\n      if (part1[r1] > part2[r2]) {\\n        candidate[i] = part1[i1++];\\n      } else {\\n        candidate[i] = part2[i2++];\\n      }\\n      if (!flagOpt) {\\n        if (candidate[i] > result[i]) flagOpt = true;\\n        else if (candidate[i] < result[i]) return false;\\n      }\\n    }\\n\\n    return flagOpt;\\n  }\\n\\n  for (let l1 = lowerL; l1 <= upperL; l1++) {\\n    l2 = k - l1;\\n    pickPart(nums1, part1, l1);\\n    pickPart(nums2, part2, l2);\\n    opt = merge(l1, l2);\\n    if (opt) [result, candidate] = [candidate, result];\\n  }\\n\\n  return result;\\n};", "var maxNumber = function (a, b, k) {\\n    let m = a.length,\\n        n = b.length,\\n        ss = Math.max(0, k - n),\\n        ee = Math.min(k, m),\\n        maxSubsequence = new Array(k).fill(0);\\n    for (let i = ss; i <= ee; i++) {\\n        let ss1 = new MaxSubsequence(a, i);\\n        let ss2 = new MaxSubsequence(b, k - i);\\n        let curMaxSubsequence = merge(ss1, ss2);\\n        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {\\n            maxSubsequence.splice(0, k, ...curMaxSubsequence);\\n        }\\n    }\\n    return maxSubsequence;\\n};"]}
{"id": "1818", "ref_js": ["var countRangeSum = function(nums, lower, upper) {\\n  let preSum = Array(nums.length + 1).fill(0);\\n  let count = 0;\\n\\n  ", "var countRangeSum = function(nums, lower, upper) {\\n  let preSum = Array(nums.length + 1).fill(0);\\n  let count = 0;\\n\\n  ", "var countRangeSum = function(nums, lower, upper) {\\n  let preSum = Array(nums.length + 1).fill(0);\\n  let count = 0;\\n\\n  "]}
{"id": "1819", "ref_js": ["var longestIncreasingPath = function(matrix) {\\n    \\n    let dp = {};", "var longestIncreasingPath = function(M) {\\n    let ylen = M.length, xlen = M[0].length, ans = 0,\\n        memo = Array.from({length: ylen}, el => new Uint16Array(xlen))\\n    const dfs = (y, x) => {\\n        if (memo[y][x]) return memo[y][x]\\n        let val = M[y][x]\\n        memo[y][x] = 1 + Math.max(\\n            y < ylen - 1 && M[y+1][x] < val ? dfs(y+1,x) : 0,\\n            y > 0 && M[y-1][x] < val ? dfs(y-1,x) : 0,\\n            x < xlen - 1 && M[y][x+1] < val ? dfs(y,x+1) : 0,\\n            x > 0 && M[y][x-1] < val ? dfs(y,x-1) : 0)\\n        return memo[y][x]\\n    }\\n    for (let i = 0; i < ylen; i++)\\n        for (let j = 0; j < xlen; j++)\\n            ans = Math.max(ans, dfs(i, j))\\n    return ans\\n};", "var longestIncreasingPath = function (matrix) {\\n\\n    "]}
{"id": "1820", "ref_js": ["var minPatches = function (nums, n) {\\n  let patch = 0;\\n  let reach = 0;\\n  let i = 0;\\n  while (reach < n) {\\n    if (i < nums.length && nums[i] <= reach + 1) {\\n      reach += nums[i];\\n      i++;\\n    } else {\\n      console.log(reach, nums[i]);\\n      reach += reach + 1;\\n      console.log(reach, nums[i]);\\n      patch++;\\n    }\\n  }\\n  return patch;\\n};", "var minPatches = function(nums, n) {\\n    ", "var minPatches = function(nums, n) {\\n    "]}
{"id": "1821", "ref_js": ["var findItinerary = function(tickets) {\\n    const graph = {};", "var findItinerary = function(tickets) {\\n    const graph = new Map();\\n\\n    for (const [departure, arrival] of tickets.sort().reverse()) {\\n        if (!graph.has(departure)) {\\n            graph.set(departure, []);\\n        }\\n        graph.get(departure).push(arrival);\\n    }\\n\\n    const stack = [\"JFK\"];\\n    const newItinerary = [];\\n\\n    while (stack.length > 0) {\\n        const currentAirport = stack[stack.length - 1];\\n\\n        if (graph.has(currentAirport) && graph.get(currentAirport).length > 0) {\\n            stack.push(graph.get(currentAirport).pop());\\n        } else {\\n            newItinerary.push(stack.pop());\\n        }\\n    }\\n\\n    return newItinerary.reverse();    \\n};", "var findItinerary = function(tickets) {\\n    const graph = {};"]}
{"id": "1822", "ref_js": ["var isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        ", "var isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        ", "var isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        "]}
{"id": "1823", "ref_js": ["var palindromePairs = function(words) {\\n    const n = words.length\\n\\n    if (n === 1) {\\n        return []\\n    }\\n\\n    const ca = \\'a\\'.codePointAt()\\n\\n    const tables = words.map(word => [...word].reduce((acc, cur) => acc ^ (1 << (cur.codePointAt() - ca)), 0))\\n\\n    const answer = []\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i === j) {\\n                continue\\n            }\\n            \\n            const bits = tables[i] ^ tables[j]\\n\\n            if (bits !== 0 && ((bits & (bits - 1)) !== 0)) {\\n                continue\\n            }\\n\\n            if (isPalindromeConcat(words[i], words[j])) {\\n                answer.push([i, j])\\n            }\\n        }\\n    }\\n\\n    \\n    return answer\\n};", "var palindromePairs = function(words) {  \\n    let wmap = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        wmap.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (isPal(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let bw = words[i].split(\"\").reverse().join(\"\")\\n        let res = wmap.get(bw)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < bw.length; j++) {\\n            if (isPal(bw, 0, j - 1)) {\\n                let res = wmap.get(bw.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (isPal(bw, j)) {\\n                let res = wmap.get(bw.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};", "var palindromePairs = function(words) {\\n\\tconst ans = [];\\n\\t\\n\\tfor(let i = 0; i < words.length; i++) {\\n\\t\\tfor(let j = 0; j < words.length; j++) {\\n\\t\\t\\tif(i != j) {\\n\\t\\t\\t\\tconst a = words[i] + words[j];\\n\\t\\t\\t\\tconst b = a.split(\"\").reverse().join(\"\");\\n\\n\\t\\t\\t\\tif(a === b)\\n\\t\\t\\t\\t\\tans.push([i, j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n};"]}
{"id": "1825", "ref_js": ["var maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};", "var maxEnvelopes = function(envelopes) {\\n    ", "var maxEnvelopes = function(envelopes) {\\n    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\\n    const sub = [envelopes[0][1]];\\n    \\n    for (let envelope of envelopes) {\\n        if (envelope[1] > sub[sub.length - 1]) {\\n            sub.push(envelope[1]);\\n        } else {\\n            const replaceIndex = binarySearch(sub, envelope[1]);\\n            sub[replaceIndex] = envelope[1];\\n        }\\n    }\\n    \\n    return sub.length;\\n};"]}
{"id": "1826", "ref_js": ["var maxSumSubmatrix = function(matrix, k) {\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    let maxSum = -Infinity;\\n    \\n    for(let l = 0; l < R_NUM; l++) {\\n        const dp = Array(C_NUM).fill(0);\\n        \\n        for(let r = l; r < R_NUM; r++) {\\n            let sum = 0, max = -Infinity;\\n            \\n            for(let c = 0; c < C_NUM; c++) {\\n                ", "var maxSumSubmatrix = function(matrix, k) {\\n    if(!matrix.length) return 0;\\n    let n = matrix.length, m = matrix[0].length;\\n    let sum  = new Array(n + 1).fill(0).map(a => new Array(m + 1).fill(0));\\n    let ans = -Infinity;\\n\\n    for(let i = 1; i <= n; i++){\\n        for(let j = 1; j <= m; j++){\\n            sum[i][j] = matrix[i - 1][j - 1] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\\n            for(let x = 1; x <= i; ++x){\\n                for(let y = 1; y <= j; ++y){\\n                    let s = rangeSum(sum, x, y, i, j);\\n                    if(s <= k){\\n                        ans = Math.max(s, ans);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n};", "var maxSumSubmatrix = function (aa, t) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let pre = Array.from({ length: m }, () => Array(n));\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            pre[r][c] =\\n                (pre[r][c - 1] || 0) +\\n                (pre[r - 1]?.[c] || 0) -\\n                (pre[r - 1]?.[c - 1] || 0) +\\n                aa[r][c];\\n\\n    let max = -Infinity;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            for (let r2 = r; r2 < m; r2++)\\n                for (let c2 = c; c2 < n; c2++) {\\n                    let sum =\\n                        pre[r2][c2] -\\n                        (pre[r2]?.[c - 1] || 0) -\\n                        (pre[r - 1]?.[c2] || 0) +\\n                        (pre[r - 1]?.[c - 1] || 0);\\n                    if (sum <= t) {\\n                        max = Math.max(max, sum);\\n                    }\\n                }\\n    return max;\\n};"]}
{"id": "1828", "ref_js": ["var isRectangleCover = function(rectangles) {\\n   let corners = new Set();\\n   let l = Infinity, r = 0, t = 0, dummy = Infinity, area = 0;\\n   \\n   function key(x, y){\\n       return x + (y === 0 ? 0 : .1 / y);\\n   }\\n\\n   function track(x, y){\\n       let n = key(x, y);\\n       if(corners.has(n)) corners.delete(n);\\n       else corners.add(n);\\n   }\\n   for(let i = 0; i < rectangles.length; i++){\\n       let[x1, y1, x2, y2] = rectangles[i];\\n       l = Math.min(l, x1);\\n       t = Math.max(t, y2);\\n       r = Math.max(r, x2);\\n       dummy = Math.min(dummy, y1);\\n\\n       area += (x2 - x1) * (y2 - y1);\\n\\n       track(x1, y1);\\n       track(x1, y2);\\n       track(x2, y1);\\n       track(x2, y2);\\n   }\\n   return (\\n       area === (t - dummy) * (r - l) \\n       && 4 === corners.size\\n       && corners.has(key(l, dummy))\\n       && corners.has(key(r, dummy))\\n       && corners.has(key(l, t))\\n       && corners.has(key(r, t))\\n   )\\n};", "var checkExistPoints = function(duy,d) {\\n    if(duy[d]==undefined){\\n        duy[d]=1\\n    }else{\\n        delete duy[d];\\n    }\\n    return duy;\\n }\\n  var checkRectangles = function(duy,rectangle) {\\n    let d=\"\";\\n        d = rectangle[0] + \",\"+rectangle[1];\\n        duy=checkExistPoints(duy,d)\\n        d = rectangle[0] + \",\"+rectangle[3];\\n        duy=checkExistPoints(duy,d)\\n        d = rectangle[2] + \",\"+rectangle[1];\\n        duy=checkExistPoints(duy,d)\\n        d = rectangle[2] + \",\"+rectangle[3];\\n        duy=checkExistPoints(duy,d)\\n    return duy;\\n }\\nvar isRectangleCover = function(rectangles) {\\n    let s=0,hcn=[...rectangles[0]],duy={};", "var checkExistPoints = function(duy,d) {\\n    if(duy[d]==undefined){\\n        duy[d]=1\\n    }else{\\n        delete duy[d];\\n    }\\n    return duy;\\n }\\n  var checkRectangles = function(duy,rectangle) {\\n    let d=\"\";\\n        d = rectangle[0] + \",\"+rectangle[1];\\n        duy=checkExistPoints(duy,d)\\n        d = rectangle[0] + \",\"+rectangle[3];\\n        duy=checkExistPoints(duy,d)\\n        d = rectangle[2] + \",\"+rectangle[1];\\n        duy=checkExistPoints(duy,d)\\n        d = rectangle[2] + \",\"+rectangle[3];\\n        duy=checkExistPoints(duy,d)\\n    return duy;\\n }\\nvar isRectangleCover = function(rectangles) {\\n    let s=0,hcn=[...rectangles[0]],duy={};"]}
{"id": "1829", "ref_js": ["var canCross = function(stones) {\\n    const dp = new Map();\\n    stones.forEach(stone => dp.set(stone, new Set()));\\n    dp.get(0).add(0);\\n\\n    for (const stone of stones) {\\n        for (const jump of dp.get(stone)) {\\n            for (const jumpDistance of [jump - 1, jump, jump + 1]) {\\n                if (jumpDistance > 0 && dp.has(stone + jumpDistance)) {\\n                    dp.get(stone + jumpDistance).add(jumpDistance);\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp.get(stones[stones.length - 1]).size > 0;    \\n};", "var canCross = function(stones) {\\n    const n = stones.length;\\n    \\n    ", "var canCross = function(stones) {\\n    const n = stones.length;\\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(false));\\n    dp[0][0] = true; \\n    for (let i = 1; i < n; i++) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            const diff = stones[i] - stones[j];\\n            if (diff > j + 1) {\\n                break;\\n            }\\n            dp[i][diff] = dp[j][diff - 1] || dp[j][diff] || dp[j][diff + 1];\\n                if (i === n - 1 && dp[i][diff]) {\\n                    return true;\\n                }\\n        }\\n    }\\n    return false;\\n};"]}
{"id": "1830", "ref_js": ["var trapRainWater = function(heightMap) {\\n    if (heightMap.length<3) return 0;\\n    if (heightMap[0].length<3) return 0;\\n    const arr = new Array(heightMap.length);\\n    const pq = new PQ();\\n    let total=0;\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new Array(heightMap[i].length).fill(false);\\n    }\\n\\n    for(let i=0;i<heightMap.length;i++){\\n        for(let j=0;j<heightMap[i].length;j++){\\n            if(i===0 || i===heightMap.length-1){\\n                pq.push([i,j,heightMap[i][j]]);\\n            } else if(j===0|| j===arr[i].length-1){\\n                pq.push([i,j,heightMap[i][j]]);\\n            }\\n        }\\n    }\\n\\n    while(!pq.isEmpty()){\\n        const [i,j,height] = pq.pop();\\n        arr[i][j] = true;\\n        const dir = [[0,1],[0,-1],[-1,0],[1,0]]\\n        for(let [nI,nJ] of dir ){\\n            if((i+nI)>=heightMap.length) continue;\\n            if((i+nI)<0) continue;\\n            if((j+nJ)>=heightMap[i].length) continue;\\n            if((j+nJ)<0) continue;\\n            if(arr[i+nI][j+nJ]) continue;\\n            if(heightMap[i+nI][j+nJ]<height){\\n                total += (height - heightMap[i+nI][j+nJ]);\\n                heightMap[i+nI][j+nJ] = height;\\n            }\\n            arr[i+nI][j+nJ] = true;\\n            pq.push([i+nI,j+nJ,heightMap[i+nI][j+nJ]])\\n        }\\n    }\\n    return total;\\n};", "var trapRainWater = function(heightMap) {\\n    if (heightMap.length<3) return 0;\\n    if (heightMap[0].length<3) return 0;\\n    const arr = new Array(heightMap.length);\\n    const pq = new PQ();\\n    let total=0;\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new Array(heightMap[i].length).fill(false);\\n    }\\n\\n    for(let i=0;i<heightMap.length;i++){\\n        for(let j=0;j<heightMap[i].length;j++){\\n            if(i===0 || i===heightMap.length-1){\\n                pq.push([i,j,heightMap[i][j]]);\\n            } else if(j===0|| j===arr[i].length-1){\\n                pq.push([i,j,heightMap[i][j]]);\\n            }\\n        }\\n    }\\n\\n    while(!pq.isEmpty()){\\n        const [i,j,height] = pq.pop();\\n        arr[i][j] = true;\\n        const dir = [[0,1],[0,-1],[-1,0],[1,0]]\\n        for(let [nI,nJ] of dir ){\\n            if((i+nI)>=heightMap.length) continue;\\n            if((i+nI)<0) continue;\\n            if((j+nJ)>=heightMap[i].length) continue;\\n            if((j+nJ)<0) continue;\\n            if(arr[i+nI][j+nJ]) continue;\\n            if(heightMap[i+nI][j+nJ]<height){\\n                total += (height - heightMap[i+nI][j+nJ]);\\n                heightMap[i+nI][j+nJ] = height;\\n            }\\n            arr[i+nI][j+nJ] = true;\\n            pq.push([i+nI,j+nJ,heightMap[i+nI][j+nJ]])\\n        }\\n    }\\n    return total;\\n};", "var trapRainWater = function(heightMap) {\\n    if (heightMap.length<3) return 0;\\n    if (heightMap[0].length<3) return 0;\\n    const arr = new Array(heightMap.length);\\n    const pq = new PQ();\\n    let total=0;\\n    for(let i=0;i<arr.length;i++){\\n        arr[i] = new Array(heightMap[i].length).fill(false);\\n    }\\n\\n    for(let i=0;i<heightMap.length;i++){\\n        for(let j=0;j<heightMap[i].length;j++){\\n            if(i===0 || i===heightMap.length-1){\\n                pq.push([i,j,heightMap[i][j]]);\\n            } else if(j===0|| j===arr[i].length-1){\\n                pq.push([i,j,heightMap[i][j]]);\\n            }\\n        }\\n    }\\n\\n    while(!pq.isEmpty()){\\n        const [i,j,height] = pq.pop();\\n        arr[i][j] = true;\\n        const dir = [[0,1],[0,-1],[-1,0],[1,0]]\\n        for(let [nI,nJ] of dir ){\\n            if((i+nI)>=heightMap.length) continue;\\n            if((i+nI)<0) continue;\\n            if((j+nJ)>=heightMap[i].length) continue;\\n            if((j+nJ)<0) continue;\\n            if(arr[i+nI][j+nJ]) continue;\\n            if(heightMap[i+nI][j+nJ]<height){\\n                total += (height - heightMap[i+nI][j+nJ]);\\n                heightMap[i+nI][j+nJ] = height;\\n            }\\n            arr[i+nI][j+nJ] = true;\\n            pq.push([i+nI,j+nJ,heightMap[i+nI][j+nJ]])\\n        }\\n    }\\n    return total;\\n};"]}
{"id": "1831", "ref_js": ["var splitArray = function(nums, k) {\\n        let n=nums.length;\\n    let low=Math.max(...nums)\\n    let high=nums.reduce((acc,curr)=>{\\n      return acc+curr\\n    },0)\\n    while(low<=high)\\n    {\\n      let mid=Math.floor((low+high)/2)\\n      let sum=LargestSum(nums,mid)\\n      if(sum>k)\\n      {\\n        low=mid+1\\n      }\\n      else\\n      {\\n        high=mid-1\\n      }\\n    }\\n    return low\\n};", "var splitArray = function(nums, m) {\\n    let low = Math.max(...nums);\\n    let high = 0;\\n    let ans = 0;\\n    \\n    for(let num of nums) {\\n        high += num;\\n    }\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); ", "var splitArray = function(nums, k) {\\n        let n=nums.length;\\n    let low=Math.max(...nums)\\n    let high=nums.reduce((acc,curr)=>{\\n      return acc+curr\\n    },0)\\n    while(low<=high)\\n    {\\n      let mid=Math.floor((low+high)/2)\\n      let sum=LargestSum(nums,mid)\\n      if(sum>k)\\n      {\\n        low=mid+1\\n      }\\n      else\\n      {\\n        high=mid-1\\n      }\\n    }\\n    return low\\n};"]}
{"id": "1832", "ref_js": ["var strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};", "var strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};", "var strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};"]}
{"id": "1834", "ref_js": ["var findKthNumber = function(n, k) {\\n    let current = 1;\\n\\n    ", "var findKthNumber = function (n, k) {\\n  let curr = 1;\\n  k--;\\n\\n  while (k > 0) {\\n    let steps = countSteps(n, curr, curr + 1);\\n    if (steps <= k) {\\n      curr += 1;\\n      k -= steps;\\n    } else {\\n      curr *= 10;\\n      k--;\\n    }\\n  }\\n\\n  return curr;\\n};", "var findKthNumber = function (n, k) {\\n    function dfs (l, r) {\\n        let nn = BigInt(n);\\n        \\n        if (l > nn) {\\n            return 0n;\\n        }\\n        \\n        if (r > nn) {\\n            r = nn;\\n        }\\n        \\n        return r - l + 1n + dfs(l * 10n, r * 10n + 9n);\\n    }\\n    \\n    let kn = BigInt(--k), cu = 1;\\n    \\n    while (kn > 0) {\\n        let cs = dfs(BigInt(cu), BigInt(cu));\\n        \\n        if (cs <= kn) {\\n            kn -= cs;\\n            cu++;\\n        }\\n        else {\\n            kn -= 1n;\\n            cu *= 10;\\n        }\\n    }\\n    \\n    return cu;\\n};"]}
{"id": "1835", "ref_js": ["var numberOfArithmeticSlices = function(nums) {\\n  let dp = new Array(nums.length);\\n  for(let i = 0; i < nums.length; i++) {\\n    dp[i] = new Map();\\n  }\\n  let ans = 0;\\n  for(let j = 1; j < nums.length; j++) {\\n    for(let i = 0; i < j; i++) {\\n      let commonDifference = nums[j] - nums[i];\\n      if ((commonDifference > (Math.pow(2, 31) - 1)) || commonDifference < (-Math.pow(2, 31))) {\\n        continue;\\n      }\\n      let apsEndingAtI = dp[i].get(commonDifference) || 0\\n      let apsEndingAtJ = dp[j].get(commonDifference) || 0\\n      \\n      dp[j].set(commonDifference, (apsEndingAtI + apsEndingAtJ + 1));\\n      ans += apsEndingAtI;\\n    }\\n  }\\n  return ans;\\n};", "var numberOfArithmeticSlices = function(nums) {\\n    let cache = new Map();\\n    let result = 0;\\n    for(let i=0;i<nums.length;i++){\\n        cache[i] = new Map();\\n        for(let j=0;j<i;j++){\\n            let diff = nums[i]-nums[j];\\n            let cacheOne = cache[i].get(diff) || 0;\\n            let cacheTwo = cache[j].get(diff) || 0;\\n            result += cacheTwo;\\n            cache[i].set(diff,cacheOne + cacheTwo+1);\\n        }\\n    }\\n    return result;\\n};", "var numberOfArithmeticSlices = function (nums, dp = new Map(), result = 0) {\\n    nums.forEach((n, k) => {\\n        dp[k] = new Map();\\n\\n        for (let i = 0; i < k; i++) {\\n            let m = nums[i];\\n            let diff = n - m;\\n            let apsAsK = dp[k].get(diff) || 0;\\n            let apsAsI = dp[i].get(diff) || 0;\\n\\n\\t\\t\\tresult += apsAsI;\\n            dp[k].set(diff, apsAsK + apsAsI + 1);\\n        }\\n    });\\n\\n    return result;\\n};"]}
{"id": "1836", "ref_js": ["var poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n    ", "var poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n    ", "var poorPigs = function(buckets, minutesToDie, minutesToTest) {\\n    "]}
{"id": "1838", "ref_js": ["var getMaxRepetitions = function (s1, n1, s2, n2) {\\n  let l1 = s1.length;\\n  let l2 = s2.length;\\n\\n  laps.resize(l1, 27);\\n  jump.resize(l1, 27);\\n\\n  for (let i = 0; i < l1; i++) {\\n    let lap = i? 0 : 1;\\n    let i1 = i;\\n    let i2 = 0;\\n\\n    while (true) {\\n      if (s1[i1] == s2[i2]) i2++;\\n      i1++;\\n\\n      if (i1 == l1) {\\n        if (i2 != l2) lap++;\\n        i1 = 0;\\n        if (lap > l2 + 1) return 0;\\n      }\\n      if (i2 == l2) break;\\n    }\\n\\n    laps.set(lap, i, 0);\\n    jump.set(i1, i, 0);\\n  }\\n\\n  let bound = Math.floor(l1 * n1 / l2);\\n  let maxPow = 0\\n  for (j = 2; j <= bound; j <<= 1)  {\\n    for (let i = 0; i < l1; i++) {\\n      let t = jump.at(i, maxPow);\\n      jump.set(jump.at(t, maxPow), i, maxPow+1);\\n      laps.set(laps.at(i, maxPow) + laps.at(t, maxPow), i, maxPow+1);\\n    }\\n    maxPow++;\\n  }\\n\\n  let x = 0;\\n  let p = maxPow;\\n  let res = 0;\\n\\n  while (true) {\\n    while (p >= 0 && laps.at(x, p) > n1) p--;\\n    if (p < 0) break;\\n    n1 -= laps.at(x, p);\\n    res += 1 << p;\\n    x = jump.at(x, p);\\n  }\\n\\n  return Math.floor(res / n2);\\n};", "var getMaxRepetitions = function(s1, n1, s2, n2) {\\n    const len1 = s1.length;\\n    const len2 = s2.length; \\n    let count1 = 0; ", "var getMaxRepetitions = function(s1, n1, s2, n2) {\\n    const len1 = s1.length;\\n    const len2 = s2.length; \\n    let count1 = 0; "]}
{"id": "1839", "ref_js": ["var findAllConcatenatedWordsInADict = function(words) {\\n    let set = new Set(words)\\n    let n = words.lenfgth\\n    let res = []\\n\\n    let dfs = function (word, n) {\\n        if (n >= 2 && word.length == 0) return true\\n        for (let i = 1; i <= word.length; i++) {\\n            let substr = word.substring(0, i)\\n            if (set.has(substr)) {\\n                if (dfs(word.slice(i), n+1)) return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    for (let word of words) {\\n        if(dfs(word, 0)) res.push(word)\\n    }\\n    return res\\n};", "var findAllConcatenatedWordsInADict = function(W) {\\n    let res=[],seen=new Set(W)\\n    for(let w of W){\\n        let n=w.length,dp=[...Array(n)].map(d=>false)\\n        for(let i=0;i<n;i++)\\n            for(let j=0;j<=i;j++)\\n                if(i-j+1<n &&(j==0||dp[j-1])&&seen.has(w.slice(j,i+1)))\\n                    dp[i]=true\\n        dp[n-1]?res.push(w):null\\n    }\\n    return res\\n};", "var findAllConcatenatedWordsInADict = function(words) {\\n    let root = new Trie(\"*\");\\n\\n    for (let word of words) {\\n        buildDict(root, word);\\n    }\\n\\n    return words.filter(word => isPresentInDict(root, word, 0, {}) > 2)\\n};"]}
{"id": "1840", "ref_js": ["var largestPalindrome = function(n) {\\n    if (n === 1) return 9;\\n    let hi = BigInt(Math.pow(10, n) - 1);\\n    let num = hi;\\n    while(num > 0) {\\n        num -= 1n;\\n        const palindrome = BigInt(String(num) + String(num).split(\\'\\').reverse().join(\\'\\'));\\n        for (let i = hi; i >= 2n; i -= 2n) {\\n            const j = palindrome / i; \\n            if (j > hi) break;\\n            if (palindrome % i === 0n) {\\n                return String(palindrome % 1337n);\\n            };", "var largestPalindrome = function(n) {\\n    var max = Math.pow(10, n) - 1;\\n    var min = Math.pow(10, n-1);\\n    var pal = 0;\\n    for (var i = max; i >= min; i--) {\\n        for (var j = max; j >= i; j--) {\\n            var result = i * j;\\n            if (result > pal) {\\n                var str = result.toString();\\n                var rStr = str.split(\"\").reverse().join(\"\");\\n                if (str == rStr) {\\n                    pal = result;\\n                    break;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n    \\tif(j == max) {\\n    \\t    break;\\n    \\t}\\n    }\\n    return (pal % 1337);\\n};", "var largestPalindrome = function(n) {\\n    if (n === 1) return 9;\\n    let hi = BigInt(Math.pow(10, n) - 1);\\n    let num = hi;\\n    while(num > 0) {\\n        num -= 1n;\\n        const palindrome = BigInt(String(num) + String(num).split(\\'\\').reverse().join(\\'\\'));\\n        for (let i = hi; i >= 2n; i -= 2n) {\\n            const j = palindrome / i; \\n            if (j > hi) break;\\n            if (palindrome % i === 0n) {\\n                return String(palindrome % 1337n);\\n            };"]}
{"id": "1841", "ref_js": ["var balancedStringSplit = function (s) {\\n  let count = 0\\n  let countBalanced = 0\\n\\n  for (let i = 0; i < s.length; i++) {\\n    s[i] === \\'L\\' ? count++ : count-- \\n\\n    if (count === 0) {\\n      countBalanced++\\n    }\\n  }\\n\\n  return countBalanced\\n};", "var balancedStringSplit = function(s) {\\n    let output = 1;\\n    for (let i = 2; i < s.length; i += 2) {\\n        if (checkBalanced(s.slice(0, i))) {\\n            const newValue = 1 + balancedStringSplit(s.slice(i, s.length));\\n            if (newValue > output) {\\n                output = newValue;\\n                break;\\n            }\\n        }\\n    }\\n    return output;\\n};", "var balancedStringSplit = function (s) {\\n  let balance = 0;\\n  let result = 0;\\n\\n  for (const i of s) {\\n    if (i === \\'L\\') balance--;\\n    else balance++;\\n    if (balance === 0) result++;\\n  }\\n\\n  return result;\\n};"]}
{"id": "1842", "ref_js": ["var maximumSubsequenceCount = function(text, pattern) {\\n    let fc = 0;\\n    let sc = 0;\\n\\n    let res = 0;\\n\\n    for (let el of text) {\\n        if (el === pattern[0]) fc++;\\n        else if (el === pattern[1]) {\\n            sc++;\\n            res += fc;\\n        }\\n    }\\n\\n    if (pattern[0] === pattern[1]) return fc * (fc + 1) / 2;\\n    \\n    return res + Math.max(fc, sc);\\n};", "var maximumSubsequenceCount = function(text, pattern) {\\n    const [a,b]=pattern;\\n   \\n    const calculate=(s)=>{\\n        const pref=[s[0]===a?1:0], post=Array(s.length).fill();\\n        post[post.length-1]=s[s.length-1]===b?1:0;\\n\\n        for(let i=1;i<s.length;i++){\\n            pref[i]=pref[i-1]+(s[i]===a?1:0);\\n        }\\n\\n        for(let i=s.length-2;i>=0;i--){\\n            post[i]=post[i+1]+(s[i]===b?1:0);\\n        }\\n\\n        let ans=0;\\n        for(let i=0;i<s.length;i++){\\n            if(s[i]===a)ans+=post[i]-(a==b?1:0); ", "var maximumSubsequenceCount = function(text, pattern) {\\n    const count = [0,0];\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) count[0]++;\\n        if (text[i] === pattern[1]) count[1]++;\\n    }\\n\\n    if (count[0] > count[1]) {\\n        text = text + pattern[1];\\n        count[1]++;\\n    } else {\\n        text = pattern[0] + text;\\n        count[0]++;\\n    }\\n\\n    let total = 0;\\n    for (let i = 0; i < text.length; i++) {\\n        if (text[i] === pattern[0]) total += count[1];\\n        if (text[i] === pattern[1]) count[1]--;\\n    }\\n    return total;\\n};"]}
{"id": "1843", "ref_js": ["var handle = function (board) {\\n    if (!board) return board;\\n    var tmp = \\'\\';\\n    while (tmp = board.replace(reg, \\'\\'), tmp !== board) board = tmp;\\n    return board;\\n}\\n\\nvar cache = {};", "var findMinStep = function(board, hand) { \\n    var map = {};", "var findMinStep = function(board, hand) { \\n    var map = {};"]}
{"id": "1844", "ref_js": ["var reversePairs = function(nums) {\\n    let count = 0;\\n    \\n    const mergeSort = (nums, low, high) => {\\n        if (low < high) {\\n            const mid = Math.floor((low + high) / 2);\\n            mergeSort(nums, low, mid);\\n            mergeSort(nums, mid + 1, high);\\n            count += merge(nums, low, mid, high);\\n        }\\n    };", "var reversePairs = function(nums) {\\n    return mergeSort(nums);\\n};", "var reversePairs = function(nums) {\\n  return mergeSort(nums, 0 , nums.length - 1)\\n};"]}
{"id": "1845", "ref_js": ["var findMaximizedCapital = function (\\n    distinctProjects,\\n    initialCapital,\\n    profits,\\n    capitals\\n) {\\n    const { PriorityQueue } = require(\"@datastructures-js/priority-queue\");\\n    const pqMaxProfits = new PriorityQueue({ compare: (a, b) => b - a });\\n\\n    let capitalProfits = capitals.map((capital, i) => [capital, profits[i]]);\\n    capitalProfits.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n    let availableCapital = initialCapital;\\n    let n = capitalProfits.length; ", "var findMaximizedCapital = function(k, w, profits, capital) {\\n     if(w >= Math.max(...capital)) {\\n      profits.sort((a, b) => b - a);\\n      return profits.slice(0, k).reduce((acc, num) => acc + num, w);\\n   }\\n    \\n    for (let i = 0; i < k; i++) {\\n       let maxProfit = -Infinity;\\n       let projectIndex = -1;\\n       for (let j = 0; j < profits.length; j++) {\\n          if (w < capital[j]) continue;\\n          \\n          if (profits[j] >= maxProfit) {\\n            projectIndex = j;\\n            maxProfit = profits[j];\\n          }\\n       }\\n       if (projectIndex === -1) {\\n         break;\\n       }\\n       capital[projectIndex] = Infinity;\\n       w += maxProfit;        \\n    }\\n    return w;\\n};", "var findMaximizedCapital = function(k, w, profits, capital) \\n{\\n    \\n    let projects = [];\\n    for(let i=0; i<profits.length; i++)\\n        projects.push([profits[i],capital[i]]);\\n    projects.sort((a,b)=>a[1]-b[1]);\\n\\n    \\n    let pq = new MaxPriorityQueue(), pp = 0;\\n    while(k > 0)\\n    {\\n        \\n        while(pp < projects.length && projects[pp][1] <= w)\\n        {\\n            pq.enqueue(pp,projects[pp][0]);\\n            pp++;\\n        }\\n\\n        if(pq.size() === 0)\\n            break;\\n\\n        \\n        let el = pq.dequeue();\\n        w += el.priority;\\n        k--;\\n    }\\n\\n    return w;\\n};"]}
{"id": "1846", "ref_js": ["var findRotateSteps = function (ring, key) {\\n  let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n  let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n  let dp = ring.split(\\'\\').map(() => 0);\\n\\n  for (let i = key.length - 1; i >= 0; i--) {\\n    let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n    for (let j = 0; j < ring.length * 2; j++) {\\n      let x = j % ring.length;\\n      dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n      let y = ((ring.length * 2) - 1 - j) % ring.length;\\n      dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n    }\\n\\n    dp = dp_new;\\n  }\\n\\n  return dp[0] + key.length;\\n};", "var findRotateSteps = function(ring, key) {\\n    let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n    let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n    let dp = ring.split(\\'\\').map(() => 0);\\n\\n    for (let i = key.length - 1; i >= 0; i--) {\\n        let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n        for (let j = 0; j < ring.length * 2; j++) {\\n            let x = j % ring.length;\\n            dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n            let y = ((ring.length * 2) - 1 - j) % ring.length;\\n            dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n        }\\n\\n        dp = dp_new;\\n    }\\n\\n    return dp[0] + key.length;\\n};", "var findRotateSteps = function (ring, key) {\\n  let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n  let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n  let dp = ring.split(\\'\\').map(() => 0);\\n\\n  for (let i = key.length - 1; i >= 0; i--) {\\n    let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n    for (let j = 0; j < ring.length * 2; j++) {\\n      let x = j % ring.length;\\n      dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n      let y = ((ring.length * 2) - 1 - j) % ring.length;\\n      dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n    }\\n\\n    dp = dp_new;\\n  }\\n\\n  return dp[0] + key.length;\\n};"]}
{"id": "1847", "ref_js": ["var findMinMoves = function (machines) {\\n  const totalDresses = machines.reduce((acc, dresses) => acc + dresses, 0);\\n  const n = machines.length;\\n\\n  if (totalDresses % n !== 0) {\\n    ", "var findMinMoves = function(machines) {\\n    const totalDresses = machines.reduce((acc, dresses) => acc + dresses, 0);\\n    const numMachines = machines.length;\\n    if (totalDresses % numMachines !== 0) {\\n        return -1; ", "var findMinMoves = function(machines) {\\n    let tnum = machines.reduce((a, b)=> a+b)/machines.length,lt = -1,holder=0,rholder=0,x=-1, c=[1,-1];\\nwhile (tnum%1 == 0 && ((x+=c[0]) != - 2) && x >= 0 && x < machines.length && ((holder+=machines[x]-tnum)!= \\'p\\')&&((rholder+=machines[machines.length-(1+x)]-tnum)!= \\'p\\') ){\\n        lt = Math.max(holder, lt,machines[x]-tnum, machines[machines.length-(1+x)]-tnum,rholder, 0)\\n    }\\n     return lt\\n};"]}
{"id": "1848", "ref_js": ["var removeBoxes = function(boxes) {\\n    const n = boxes.length;\\n    const dp = new Array(n).fill(0).map(() =>\\n        new Array(n).fill(0).map(() =>\\n            new Array(n).fill(0)\\n        )\\n    );\\n    ", "var removeBoxes = function(boxes) {\\n    const n = boxes.length;\\n    const dp = new Array(n).fill(0).map(() =>\\n        new Array(n).fill(0).map(() =>\\n            new Array(n).fill(0)\\n        )\\n    );\\n    ", "var removeBoxes = function(boxes) {\\n    const n = boxes.length;\\n    const dp = new Array(n).fill(0).map(() =>\\n        new Array(n).fill(0).map(() =>\\n            new Array(n).fill(0)\\n        )\\n    );\\n    "]}
{"id": "1849", "ref_js": ["var checkRecord = function(n) {\\n    const MOD = 1e9 + 7;\\n    ", "var checkRecord = function(n) {\\n    let prev = new Array(2).fill().map(() => new Array(3)), curr = new Array(2).fill().map(() => new Array(3));\\n    prev[0][2] = 2;\\n    prev[0][1] = 3;\\n    prev[0][0] = 3;\\n    prev[1][0] = 2;\\n    prev[1][2] = 1;\\n    prev[1][1] = 2;\\n    for(let i = 2; i <= n; i++) {\\n        curr = new Array(2).fill().map(() => new Array(3))\\n        for(let absentUsed = 0; absentUsed <= 1; absentUsed++) {\\n            for(let consecutiveLeavesUsed = 0; consecutiveLeavesUsed <= 2; consecutiveLeavesUsed++) {\\n                let ans = 0;\\n                if(absentUsed === 0) {\\n                    if(consecutiveLeavesUsed === 2) {\\n                       ans = ss(ans, ss(prev[absentUsed+1][0], prev[absentUsed][0]));\\n                    } else if(consecutiveLeavesUsed <= 1) {\\n                        ans = ss(ans, ss(prev[absentUsed+1][0], ss(prev[absentUsed][0], prev[absentUsed][consecutiveLeavesUsed+1])));\\n                    }\\n                } else if(absentUsed === 1) {\\n                    if(consecutiveLeavesUsed === 2) {\\n                        ans = ss(ans, prev[absentUsed][0]);\\n                    } else if(consecutiveLeavesUsed <= 1) {\\n                        ans = ss(ans, ss(prev[absentUsed][0], prev[absentUsed][consecutiveLeavesUsed + 1]));\\n                    }\\n                } \\n                curr[absentUsed][consecutiveLeavesUsed] = ans;\\n            }\\n        }\\n        prev = curr;\\n    }\\n    return prev[0][0];\\n};", "var checkRecord = function(n) {\\n    let prev = new Array(2).fill().map(() => new Array(3)), curr = new Array(2).fill().map(() => new Array(3));\\n    prev[0][2] = 2;\\n    prev[0][1] = 3;\\n    prev[0][0] = 3;\\n    prev[1][0] = 2;\\n    prev[1][2] = 1;\\n    prev[1][1] = 2;\\n    for(let i = 2; i <= n; i++) {\\n        curr = new Array(2).fill().map(() => new Array(3))\\n        for(let absentUsed = 0; absentUsed <= 1; absentUsed++) {\\n            for(let consecutiveLeavesUsed = 0; consecutiveLeavesUsed <= 2; consecutiveLeavesUsed++) {\\n                let ans = 0;\\n                if(absentUsed === 0) {\\n                    if(consecutiveLeavesUsed === 2) {\\n                       ans = ss(ans, ss(prev[absentUsed+1][0], prev[absentUsed][0]));\\n                    } else if(consecutiveLeavesUsed <= 1) {\\n                        ans = ss(ans, ss(prev[absentUsed+1][0], ss(prev[absentUsed][0], prev[absentUsed][consecutiveLeavesUsed+1])));\\n                    }\\n                } else if(absentUsed === 1) {\\n                    if(consecutiveLeavesUsed === 2) {\\n                        ans = ss(ans, prev[absentUsed][0]);\\n                    } else if(consecutiveLeavesUsed <= 1) {\\n                        ans = ss(ans, ss(prev[absentUsed][0], prev[absentUsed][consecutiveLeavesUsed + 1]));\\n                    }\\n                } \\n                curr[absentUsed][consecutiveLeavesUsed] = ans;\\n            }\\n        }\\n        prev = curr;\\n    }\\n    return prev[0][0];\\n};"]}
{"id": "1850", "ref_js": ["var nearestPalindromic = function (n) {\\n    const bit = BigInt(n);\\n    const num = [bit - 1n, bit + 1n];\\n    while (true) {\\n        const d1 = getDistance(num[0]);\\n        if (d1 === 0) break;\\n        num[0] -= BigInt(d1);\\n    }\\n    while (true) {\\n        const d2 = getDistance(num[1]);\\n        if (d2 === 0) break;\\n        num[1] += BigInt(d2);\\n    }\\n    return bit - num[0] <= num[1] - bit ? String(num[0]) : String(num[1])\\n};", "var nearestPalindromic = function (n) {\\n    const num = BigInt(n)\\n    const nextPalindrome = getNextPalindrome((num+BigInt(1)).toString().split(\"\"))\\n    const prevPalindrome = getPrevPalindrome((num-BigInt(1)).toString().split(\"\"))\\n    \\n    const result = BigInt(n) - prevPalindrome <= nextPalindrome - BigInt(n) ? prevPalindrome : nextPalindrome;\\n    return String(result)\\n};", "var nearestPalindromic = function (n) {\\n  "]}
{"id": "1851", "ref_js": ["var outerTrees = function(trees) {\\n    trees.sort((a, b) => a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0])\\n    const cmpSlopes = ([x1, y1], [x2, y2], [x3, y3]) => (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1)\\n    const higher = []\\n    const lower = []\\n    \\n    for (let point of trees) {\\n        while (higher.length > 1 && cmpSlopes(higher[higher.length - 2], higher[higher.length - 1], point) > 0) \\n            higher.pop();\\n        while (lower.length > 1 && cmpSlopes(lower[lower.length - 2], lower[lower.length - 1], point) < 0) \\n            lower.pop();\\n        \\n        higher.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return [...new Set([...higher, ...lower])];\\n};", "var outerTrees = function(trees) {\\n    function cmp (p1, p2, p3) {\\n        let [x1, y1] = p1;\\n        let [x2, y2] = p2;\\n        let [x3, y3] = p3;\\n        return (y3 - y2)*(x2 - x1) - (y2 - y1)*(x3 - x2);\\n    }\\n    \\n    trees.sort((a, b)=> {\\n        let diff = a[0] - b[0];\\n        if (diff === 0) return a[1] - b[1];\\n        return diff});\\n    \\n    const upper = [];\\n    const lower = [];\\n    \\n    for (let point of trees) {\\n        while (lower.length > 1 && cmp(lower[lower.length - 2], lower[lower.length - 1], point) > 0) {\\n            lower.pop()\\n        }\\n         while (upper.length > 1 && cmp(upper[upper.length - 2], upper[upper.length - 1], point) < 0) {\\n            upper.pop()\\n        }\\n        upper.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return Array.from(new Set(upper.concat(lower)))\\n};", "var outerTrees = function(trees) {\\n    trees.sort((a, b) => a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0])\\n    const cmpSlopes = ([x1, y1], [x2, y2], [x3, y3]) => (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1)\\n    const higher = []\\n    const lower = []\\n    \\n    for (let point of trees) {\\n        while (higher.length > 1 && cmpSlopes(higher[higher.length - 2], higher[higher.length - 1], point) > 0) \\n            higher.pop();\\n        while (lower.length > 1 && cmpSlopes(lower[lower.length - 2], lower[lower.length - 1], point) < 0) \\n            lower.pop();\\n        \\n        higher.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return [...new Set([...higher, ...lower])];\\n};"]}
{"id": "1852", "ref_js": ["var isValid = function(code) {\\n    const parser = {\\n        openTags: [],\\n        readingOpenTag: false,\\n        readingCloseTag: false,\\n        tagReading: \"\",\\n        readingCdata: false,\\n        atLeastOneTag: false\\n    };", "var isValid = function(code) {\\n    if (code === \\'t\\') return false;\\n    while (/<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>/.test(code)) {\\n        code = code.replace(/<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>/g, \\'c\\');\\n    }\\n    while (/<([A-Z]{1,9})>([^<]*)<\\\\/(\\\\1)>/.test(code)) {\\n        code = code.replace(/<([A-Z]{1,9})>([^<]*)<\\\\/(\\\\1)>/g, \\'t\\');\\n    }\\n    return code === \\'t\\';\\n};", "var isValid = function(code) {\\n    const parser = {\\n        openTags: [],\\n        readingOpenTag: false,\\n        readingCloseTag: false,\\n        tagReading: \"\",\\n        readingCdata: false,\\n        atLeastOneTag: false\\n    };"]}
{"id": "1853", "ref_js": ["var findIntegers = function(n) {\\n  const s = n.toString(2); \\n  n = s.length;\\n  let dp0 = 1;\\n  let dp1 = 0;\\n  let tight = 1;\\n\\n  for (let i = 1; i < n; i++) {\\n    let ndp0 = dp1 + dp0;\\n    let ndp1 = dp0; \\n\\n    if (tight && s[i] == \"1\") {\\n      ndp0++;\\n      if (s[i-1] == \"1\") tight = 0;\\n    }\\n\\n    dp0 = ndp0;\\n    dp1 = ndp1;\\n  }\\n\\n  return dp0 + dp1 + tight;\\n};", "var findIntegers = function(n) {\\n  const s = n.toString(2); \\n  n = s.length;\\n  let dp0 = 1;\\n  let dp1 = 0;\\n  let tight = 1;\\n\\n  for (let i = 1; i < n; i++) {\\n    let ndp0 = dp1 + dp0;\\n    let ndp1 = dp0; \\n\\n    if (tight && s[i] == \"1\") {\\n      ndp0++;\\n      if (s[i-1] == \"1\") tight = 0;\\n    }\\n\\n    dp0 = ndp0;\\n    dp1 = ndp1;\\n  }\\n\\n  return dp0 + dp1 + tight;\\n};", "var findIntegers = function(n) {\\n  const s = n.toString(2); \\n  n = s.length;\\n  let dp0 = 1;\\n  let dp1 = 0;\\n  let tight = 1;\\n\\n  for (let i = 1; i < n; i++) {\\n    let ndp0 = dp1 + dp0;\\n    let ndp1 = dp0; \\n\\n    if (tight && s[i] == \"1\") {\\n      ndp0++;\\n      if (s[i-1] == \"1\") tight = 0;\\n    }\\n\\n    dp0 = ndp0;\\n    dp1 = ndp1;\\n  }\\n\\n  return dp0 + dp1 + tight;\\n};"]}
{"id": "1855", "ref_js": ["var kInversePairs = function(n, k) {\\n    let M = 1000000007;\\n    var prev, cur;\\n\\n    prev = new Array(k+1).fill(0);\\n    prev[0] = 1;\\n\\n    for( var i=2; i<=n; i++ ) {\\n        cur = new Array(k+1).fill(0);\\n        cur[0] = 1;\\n\\n        for( var j=1; j<=k; j++ ) {\\n            cur[j] = (cur[j-1] + prev[j]) % M;\\n            if( j >= i )\\n                cur[j] = ( M + cur[j] - prev[j-i] ) % M;\\n        }\\n\\n        prev = cur;\\n    }\\n\\n    return prev[k];\\n};", "var kInversePairs = function(n, k) {\\n    let M = 1000000007;\\n    var prev, cur;\\n\\n    prev = new Array(k+1).fill(0);\\n    prev[0] = 1;\\n\\n    for( var i=2; i<=n; i++ ) {\\n        cur = new Array(k+1).fill(0);\\n        cur[0] = 1;\\n\\n        for( var j=1; j<=k; j++ ) {\\n            cur[j] = (cur[j-1] + prev[j]) % M;\\n            if( j >= i )\\n                cur[j] = ( M + cur[j] - prev[j-i] ) % M;\\n        }\\n\\n        prev = cur;\\n    }\\n\\n    return prev[k];\\n};", "var kInversePairs = function(n, k) {\\n    let M = 1000000007;\\n    var prev, cur;\\n\\n    prev = new Array(k+1).fill(0);\\n    prev[0] = 1;\\n\\n    for( var i=2; i<=n; i++ ) {\\n        cur = new Array(k+1).fill(0);\\n        cur[0] = 1;\\n\\n        for( var j=1; j<=k; j++ ) {\\n            cur[j] = (cur[j-1] + prev[j]) % M;\\n            if( j >= i )\\n                cur[j] = ( M + cur[j] - prev[j-i] ) % M;\\n        }\\n\\n        prev = cur;\\n    }\\n\\n    return prev[k];\\n};"]}
{"id": "1856", "ref_js": ["var scheduleCourse = function (courses) {\\n  ", "var scheduleCourse = function(C) {\\n    C.sort((a,b) => a[1] - b[1])\\n    let total = 0, pq = new MaxPriorityQueue({priority: x => x})\\n    for (let [dur, end] of C)\\n        if (dur + total <= end)\\n            total += dur, pq.enqueue(dur)\\n        else if (pq.front() && pq.front().element > dur)\\n            total += dur - pq.dequeue().element, pq.enqueue(dur)\\n    return pq.size()\\n};", "var scheduleCourse = function(courses) {\\n    "]}
{"id": "1857", "ref_js": ["var smallestRange = function(nums) {\\n  ", "var smallestRange = function(nums) {\\n\\n    ", "var smallestRange = function(nums) {\\n    const minHeap = new MinHeap();\\n    let rangeStart = 0;\\n    let rangeEnd = Infinity;\\n    let maxValue = -Infinity;\\n\\n    "]}
{"id": "1858", "ref_js": ["var numDecodings = function (s) {\\n  if (s[0] === \"0\") return 0;\\n\\n  let n = s.length;\\n  let a = 0;\\n  let b = 0;\\n  let c = 1;\\n  let ca = 0;\\n  let cb = 0;\\n\\n  for (let i = 0; i < n; ++i) {\\n    a = b;\\n    b = c;\\n\\n    if (b) {\\n      switch (s[i]) {\\n        case \"*\":\\n          cb = 9;\\n          break;\\n        case \"0\":\\n          cb = 0;\\n          break;\\n        default:\\n          cb = 1;\\n          break;\\n      }\\n    }\\n\\n    if (a && i) {\\n      switch (s[i - 1]) {\\n        case \"*\": {\\n          if (s[i] == \"*\") {\\n            ca = 15;\\n          } else if (s.charCodeAt(i) <= 54) {\\n            ca = 2;\\n          } else {\\n            ca = 1;\\n          }\\n          break;\\n        }\\n        case \"1\": {\\n          if (s[i] == \"*\") {\\n            ca = 9;\\n          } else {\\n            ca = 1;\\n          }\\n          break;\\n        }\\n        case \"2\": {\\n          if (s.charCodeAt(i) > 54) {\\n            ca = 0;\\n          } else if (s[i] == \"*\") {\\n            ca = 6;\\n          } else {\\n            ca = 1;\\n          }\\n          break;\\n        }\\n        default: ca = 0; break;\\n      }\\n    }\\n\\n    c = (((b * cb) % MOD) + ((a * ca) % MOD)) % MOD;\\n    if (!(c || b)) return 0;\\n  }\\n\\n  return c;\\n};", "var numDecodings = function(s) {\\n    let mod = 1e9 + 7;\\n  ", "var numDecodings = function(s) {\\n    let c = new Array(s.length);\\n    let re = 0;\\n    for (let i = s.length - 1; i >=0; i--){\\n        c[i] = 0;\\n        if (s[i] != \\'0\\'){\\n            if (s[i] == \\'*\\'){\\n                c[i] = 9;\\n                let tmp = 0;\\n                if (i + 1 < s.length){\\n                    c[i] = c[i] * c[i + 1];\\n                    if (s[i + 1] != \\'*\\') tmp = s[i + 1] <= \\'6\\' ? 2 : 1;\\n                    else tmp = 15;\\n                }\\n                c[i] += tmp * (i + 2 < s.length ? c[i + 2] : 1);\\n                c[i] = c[i] % 1000000007;\\n            }\\n            else{\\n                c[i] = 1;\\n                let tmp = 0;\\n                if (i + 1 < s.length){\\n                    c[i] = c[i] * c[i + 1];\\n                    if (s[i] + s[i + 1] < \\'27\\'){\\n                        if (s[i + 1] == \\'*\\') tmp = (s[i] == \\'1\\' ? 9 : s[i] == \\'2\\' ? 6 : 1);\\n                        else tmp = 1;\\n                    }\\n                }\\n                c[i] += tmp * (i + 2 < s.length ? c[i + 2] : 1);\\n                c[i] = c[i] % 1000000007;\\n            }\\n        }\\n    }\\n\\n    return c[0];\\n};"]}
{"id": "1859", "ref_js": ["var strangePrinter = function(s) {\\n    const n = s.length;\\n    const memo = Array(n).fill().map(() => Array(n).fill(0));\\n\\n    function dp(l, r) {\\n        if (l>r) return 0;\\n\\n        if (memo[l][r]) return memo[l][r];\\n\\n        let min = 1 + dp(l+1, r);\\n\\n        for (let i=l+1; i<=r; ++i)\\n            if (s[i]==s[l])\\n                min = Math.min(min, dp(l+1, i-1) + dp(i, r));\\n\\n        memo[l][r] = min;\\n        return min;\\n    }\\n\\n    return dp(0, n-1);\\n};", "var strangePrinter = function(s) {\\n    const memo = {};", "var strangePrinter = function(s) {\\n    let n = s.length;\\n    let dp = Array.from(Array(n), () => new Array(n).fill(0));\\n    \\n    for (let i = n-1; i >= 0; --i) {\\n        dp[i][i] = 1;\\n        for (let j = i+1; j < n; ++j) {\\n            dp[i][j] = dp[i][j-1] + 1;\\n            for (let k = i; k < j; ++k) {\\n                if (s[k] == s[j]) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + (k+1<=j-1 ? dp[k+1][j-1] : 0));\\n                }\\n            }\\n        }\\n    }\\n    return dp[0][n-1];\\n};"]}
{"id": "1860", "ref_js": ["var findKthNumber = function(m, n, k) {\\n  ", "var findKthNumber = function(m, n, k) {\\n  let low = 1;\\n  let high = m * n;\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    const count = countLessThanOrEqualTo(mid, m, n);\\n\\n    if (count < k) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n\\n  return low;\\n};", "var findKthNumber = function(m, n, k) {\\n  let low = 1;\\n  let high = m * n;\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    const count = countLessThanOrEqualTo(mid, m, n);\\n\\n    if (count < k) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n\\n  return low;\\n};"]}
{"id": "1861", "ref_js": ["var cutOffTree = function(forest) {\\n    let numTrees = 0;\\n    \\n    let treeHeights = [];\\n    \\n    for (let r = 0; r < forest.length; r++) {\\n        for (let c = 0; c < forest[0].length; c++) {\\n            let curr = forest[r][c];\\n            \\n            if (curr > 1) {\\n                numTrees++;\\n                treeHeights.push(curr);\\n            }\\n        }\\n    }\\n    \\n    treeHeights.sort((a, b) => a - b);\\n    \\n    let totalSteps = 0;\\n    let lastLocation = [0, 0]\\n    \\n    for (let tree of treeHeights) {\\n        let [r, c] = lastLocation\\n        let shortestDist = shortestPath(r, c, tree);\\n        if (shortestDist === false) return -1;\\n        totalSteps += shortestDist;\\n    }\\n    \\n    return totalSteps;\\n    \\n    function shortestPath(r, c, target) {\\n        let visited = new Set();\\n        const queue = [[r, c, 0]];\\n        \\n        let key = `${r}, ${c}`;\\n        visited.add(key);\\n        \\n        while (queue.length) {\\n            let [r, c, dist] = queue.shift();\\n            if (forest[r][c] === target) {\\n                forest[r][c] = 1;\\n                lastLocation = [r, c]\\n                return dist;\\n            }\\n            \\n            let neighbors = getNeighbors(r, c, visited);\\n            \\n            for (let neighbor of neighbors) {\\n                let [r, c] = neighbor;\\n                queue.push([r, c, dist + 1]);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    function getNeighbors(r, c, visited) {\\n        let arr = [];\\n        arr.push([r + 1, c])\\n        arr.push([r - 1, c])\\n        arr.push([r, c + 1])\\n        arr.push([r, c - 1])\\n        \\n        let neighbors = [];\\n        \\n        for (let [r, c] of arr) {\\n            let key = `${r}, ${c}`\\n            if (r < 0 || c < 0 || r >= forest.length || c >= forest[0].length || forest[r][c] === 0 || visited.has(key)) continue;\\n            visited.add(key);\\n            neighbors.push([r, c]);\\n        }\\n        \\n        return neighbors;\\n    }\\n};", "var cutOffTree = function(forest) {\\n    const trees = forest.flat().filter(x => x && x !== 1).sort((a, b) => b - a);\\n    let currPos = [0, 0], totalDist = 0;\\n\\n    while(trees.length) {\\n        const grid = [...forest.map(row => [...row])];\\n        const res = getDist(currPos, trees.pop(), grid);\\n        if(res == null) return -1;\\n        const [pos, dist] = res;\\n        currPos = pos;\\n        totalDist += dist;\\n    }\\n    return totalDist;    \\n    \\n    function getDist(start, target, grid) {\\n        const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n        let queue = [start], dist = 0;\\n        \\n        while(queue.length) {\\n            const next = [];\\n            \\n            for(let [r, c] of queue) {\\n                if(grid[r][c] === target) return [[r, c], dist];\\n                if(!grid[r][c]) continue;\\n                \\n                for(let [x, y] of dir) {\\n                    x += r; y += c;\\n                    if(x >= 0 && x < grid.length && y >= 0 && \\n                       y < grid[0].length && grid[x][y]) next.push([x, y])\\n                }\\n                grid[r][c] = 0;   \\n            }\\n            dist++;\\n            queue = next;\\n        }\\n        return null;\\n    }\\n};", "var cutOffTree = function(forest) {\\n    const R = forest.length;\\n    const C = forest[0].length;\\n    \\n    const sortedTrees = sortTreesByHeight(forest);\\n    \\n    let sr = 0, sc = 0; "]}
{"id": "1862", "ref_js": ["var judgePoint24 = function(nums) {\\n    if (nums.length == 1) {\\n        return Math.abs(nums[0] - 24) < 0.01;\\n    }\\n\\n    let ans = false;\\n    for (let i = 0; i < nums.length; ++i) {\\n        for (let j = 0; j < i; ++j) {\\n            ", "var judgePoint24 = function(nums) {\\n    if (nums.length == 1) {\\n        return Math.abs(nums[0] - 24) < 0.01;\\n    }\\n\\n    let ans = false;\\n    for (let i = 0; i < nums.length; ++i) {\\n        for (let j = 0; j < i; ++j) {\\n            ", "var judgePoint24 = function(nums) {\\n    if (nums.length == 1) {\\n        return Math.abs(nums[0] - 24) < 0.01;\\n    }\\n\\n    let ans = false;\\n    for (let i = 0; i < nums.length; ++i) {\\n        for (let j = 0; j < i; ++j) {\\n            "]}
{"id": "1863", "ref_js": ["var findRedundantDirectedConnection = function (edges) {\\n    const n = edges.length;\\n    const graph = new DSU(n);\\n\\n    let index1 = -1,\\n        index2 = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        const u = edges[i][0],\\n            v = edges[i][1];\\n\\n        if (graph.indegree[v] !== -1) {\\n            index1 = i;\\n            index2 = graph.indegree[v];\\n        }\\n\\n        graph.indegree[v] = i;\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (i === index1) continue;\\n\\n        const u = edges[i][0],\\n            v = edges[i][1];\\n\\n        if (!graph.union(u, v)) {\\n            if (index1 !== -1) return edges[index2];\\n            return edges[i];\\n        }\\n    }\\n\\n    return edges[index1];\\n};", "var findRedundantDirectedConnection = function (edges) {\\n    const n = edges.length;\\n    const graph = new DSU(n);\\n\\n    let index1 = -1,\\n        index2 = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        const u = edges[i][0],\\n            v = edges[i][1];\\n\\n        if (graph.indegree[v] !== -1) {\\n            index1 = i;\\n            index2 = graph.indegree[v];\\n        }\\n\\n        graph.indegree[v] = i;\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (i === index1) continue;\\n\\n        const u = edges[i][0],\\n            v = edges[i][1];\\n\\n        if (!graph.union(u, v)) {\\n            if (index1 !== -1) return edges[index2];\\n            return edges[i];\\n        }\\n    }\\n\\n    return edges[index1];\\n};", "var findRedundantDirectedConnection = function (edges) {\\n    const n = edges.length;\\n    const graph = new DSU(n);\\n\\n    let index1 = -1,\\n        index2 = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        const u = edges[i][0],\\n            v = edges[i][1];\\n\\n        if (graph.indegree[v] !== -1) {\\n            index1 = i;\\n            index2 = graph.indegree[v];\\n        }\\n\\n        graph.indegree[v] = i;\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (i === index1) continue;\\n\\n        const u = edges[i][0],\\n            v = edges[i][1];\\n\\n        if (!graph.union(u, v)) {\\n            if (index1 !== -1) return edges[index2];\\n            return edges[i];\\n        }\\n    }\\n\\n    return edges[index1];\\n};"]}
{"id": "1864", "ref_js": ["var maxSumOfThreeSubarrays = function(nums, k, m=3) {\\n    let len = nums.length-k+1;\\n    \\n    \\n    ", "var maxSumOfThreeSubarrays = function(nums, k) {\\n    var result = [0, k, 2 * k];\\n    var sums = [nums.slice(0, k).reduce((a, b) => a + b, 0)];\\n    var rightMaxIdx = [];\\n\\n    for (var i = 1; i <= nums.length - k; i++) {\\n        sums[i] = sums[i - 1] - nums[i - 1] + nums[i + k - 1];\\n    }\\n\\n    rightMaxIdx[nums.length - k] = nums.length - k;\\n    for (var i = nums.length - k - 1; i >= 2 * k; i--) {\\n        if (sums[i] >= sums[rightMaxIdx[i + 1]]) {\\n            rightMaxIdx[i] = i;\\n        } else {\\n            rightMaxIdx[i] = rightMaxIdx[i + 1];\\n        }\\n    }\\n\\n    var midMaxIdx = [];\\n    midMaxIdx[nums.length - 2 * k] = nums.length - 2 * k\\n    for (var i = nums.length - 2 * k - 1; i >= k; i--) {\\n        if (sums[i] + sums[rightMaxIdx[i + k]] >= sums[midMaxIdx[i + 1]] + sums[rightMaxIdx[midMaxIdx[i + 1] + k]]) {\\n            midMaxIdx[i] = i;\\n        } else {\\n            midMaxIdx[i] = midMaxIdx[i + 1];\\n        }\\n    }\\n\\n    var leftMaxIdx = [];\\n    leftMaxIdx[nums.length - 3 * k] = nums.length - 3 * k;\\n    for (var i = nums.length - 3 * k - 1; i >= 0; i--) {\\n        if (sums[i] + sums[midMaxIdx[i + k]] + sums[rightMaxIdx[midMaxIdx[i + k] + k]]\\n            >= sums[leftMaxIdx[i + 1]] + sums[midMaxIdx[leftMaxIdx[i + 1] + k]] + sums[rightMaxIdx[midMaxIdx[leftMaxIdx[i + 1] + k] + k]]) {\\n            leftMaxIdx[i] = i;\\n        } else {\\n            leftMaxIdx[i] = leftMaxIdx[i + 1];\\n        }\\n    }\\n\\n    result = [leftMaxIdx[0], midMaxIdx[leftMaxIdx[0] + k], rightMaxIdx[midMaxIdx[leftMaxIdx[0] + k] + k]];\\n\\n    return result;\\n\\n};", "var maxSumOfThreeSubarrays = function(nums, k) {\\n    var result = [0, k, 2 * k];\\n    var sums = [nums.slice(0, k).reduce((a, b) => a + b, 0)];\\n    var rightMaxIdx = [];\\n\\n    for (var i = 1; i <= nums.length - k; i++) {\\n        sums[i] = sums[i - 1] - nums[i - 1] + nums[i + k - 1];\\n    }\\n\\n    rightMaxIdx[nums.length - k] = nums.length - k;\\n    for (var i = nums.length - k - 1; i >= 2 * k; i--) {\\n        if (sums[i] >= sums[rightMaxIdx[i + 1]]) {\\n            rightMaxIdx[i] = i;\\n        } else {\\n            rightMaxIdx[i] = rightMaxIdx[i + 1];\\n        }\\n    }\\n\\n    var midMaxIdx = [];\\n    midMaxIdx[nums.length - 2 * k] = nums.length - 2 * k\\n    for (var i = nums.length - 2 * k - 1; i >= k; i--) {\\n        if (sums[i] + sums[rightMaxIdx[i + k]] >= sums[midMaxIdx[i + 1]] + sums[rightMaxIdx[midMaxIdx[i + 1] + k]]) {\\n            midMaxIdx[i] = i;\\n        } else {\\n            midMaxIdx[i] = midMaxIdx[i + 1];\\n        }\\n    }\\n\\n    var leftMaxIdx = [];\\n    leftMaxIdx[nums.length - 3 * k] = nums.length - 3 * k;\\n    for (var i = nums.length - 3 * k - 1; i >= 0; i--) {\\n        if (sums[i] + sums[midMaxIdx[i + k]] + sums[rightMaxIdx[midMaxIdx[i + k] + k]]\\n            >= sums[leftMaxIdx[i + 1]] + sums[midMaxIdx[leftMaxIdx[i + 1] + k]] + sums[rightMaxIdx[midMaxIdx[leftMaxIdx[i + 1] + k] + k]]) {\\n            leftMaxIdx[i] = i;\\n        } else {\\n            leftMaxIdx[i] = leftMaxIdx[i + 1];\\n        }\\n    }\\n\\n    result = [leftMaxIdx[0], midMaxIdx[leftMaxIdx[0] + k], rightMaxIdx[midMaxIdx[leftMaxIdx[0] + k] + k]];\\n\\n    return result;\\n\\n};"]}
{"id": "1865", "ref_js": ["var specialArray = function(nums) {\\n    let sorted = nums.sort((a, b) => b - a);\\n    ", "var specialArray = function(nums) {\\n    nums.sort((a,b) => a - b);\\n\\n    for(let i = 0; i <= nums[nums.length-1]; i++){\\n        let res = bs(nums, i)\\n        if((nums.length - res) === i) return i\\n    }\\n    return -1\\n};", "var specialArray = function(nums) {\\n    "]}
{"id": "1866", "ref_js": ["var fallingSquares = function(positions) {\\n  const heights = [];\\n\\n  ", "var fallingSquares = function(positions) {\\n  const heights = [];\\n\\n  ", "var fallingSquares = function(positions) {\\n  const heights = [];\\n\\n  "]}
{"id": "1869", "ref_js": ["var smallestDistancePair = function(nums, k) {\\n    nums.sort((a, b) => a - b);\\n\\n    ", "var smallestDistancePair = function(nums, k) {\\n    nums.sort(function(a,b){return a-b});\\n    var low = 0;\\n    var high = nums[nums.length-1] - nums[0];\\n    while(low < high){\\n        var mid = Math.floor((low+high)/2);\\n        var count = 0;\\n        var left = 0;\\n        for(var right = 0; right < nums.length; right++){\\n            while(nums[right] - nums[left] > mid) left++;\\n            count += right - left;\\n        }\\n        if(count >= k) high = mid;\\n        else low = mid + 1;\\n    }\\n    return low;\\n};", "var smallestDistancePair = function(nums, k) {    \\n    nums.sort((a,b) => a - b);   \\n    let left = 0, right = nums[nums.length-1] - nums[0], mid = null, total = 0;    \\n    \\n    while (left < right) {\\n        mid = left + Math.floor((right - left) / 2);\\n    \\n        total = 0;\\n        for (var i = 0, j = 1; i < nums.length - 1 && total <= k; i++) {\\n            for ( ; j < nums.length && nums[j] - nums[i] <= mid; j++) {}\\n\\t\\t\\ttotal += j - i - 1; \\n        }\\n        \\n        if (total >= k) {right = mid;}  \\n\\t\\telse {left = mid+1;}\\n    }    \\n\\t\\n    return left;\\n};"]}
{"id": "1870", "ref_js": ["var countOfAtoms = function(formula) {\\n    let stack = [];\\n    let cur = {};", "var countOfAtoms = function(formula) {\\n    let stack = [];\\n    let cur = {};", "var countOfAtoms = function(formula) {\\n    let stack = [];\\n    let cur = {};"]}
{"id": "1871", "ref_js": ["var countPalindromicSubsequences = function(S) {\\n  const N = S.length;\\n  \\n  const A = [];\\n  for (const c of S) {\\n    A.push(c.charCodeAt(0) - \\'a\\'.charCodeAt(0));\\n  }\\n  \\n  const prv = new Array(N).fill(null);\\n  const nxt = new Array(N).fill(null);\\n  let last = new Array(4).fill(-1);\\n  for (let i = 0; i < N; i++) {\\n    last[A[i]] = i;\\n    prv[i] = last.slice();\\n  }\\n  last = new Array(4).fill(-1);\\n  for (let i = N - 1; i >= 0; i--) {\\n    last[A[i]] = i;\\n    nxt[i] = last.slice();\\n  }\\n\\n  const MOD = 10**9 + 7;\\n  const memo = new Array(N).fill(0).map(_ => new Array(N).fill(null));\\n  const dp = (i, j) => {\\n    if (memo[i][j] !== null) {\\n      return memo[i][j];\\n    }\\n    let ans = 1;\\n    if (i <= j) {\\n      for (let x = 0; x < 4; x++) {\\n        let i0 = nxt[i][x];\\n        let j0 = prv[j][x];\\n        if (i0 !== -1 && i <= i0 && i0 <= j) {\\n          ans += 1;\\n        }\\n        if (i0 !== -1 && j0 !== -1 && i0 < j0) {\\n          ans += dp(i0 + 1, j0 - 1);\\n        }\\n      }\\n    }\\n    ans %= MOD;\\n    memo[i][j] = ans;\\n    return ans;\\n  }\\n  return dp(0, N-1) - 1;\\n};", "var countPalindromicSubsequences = function (S) {\\n  const MOD = 1000000007, arr = S.split(\\'\\'), CHARS = [\\'a\\', \\'b\\', \\'c\\', \\'d\\']\\n  let dp = arr.map(x => arr.map(y => ({ a: 0, b: 0, c: 0, d: 0 })))\\n  ", "var countPalindromicSubsequences = function (S) {\\n  const MOD = 1000000007, arr = S.split(\\'\\'), CHARS = [\\'a\\', \\'b\\', \\'c\\', \\'d\\']\\n  let dp = arr.map(x => arr.map(y => ({ a: 0, b: 0, c: 0, d: 0 })))\\n  "]}
{"id": "1873", "ref_js": ["var evaluate = function(expression) {\\n  const lex = new Lexer(expression);\\n  const parser = new Parser(lex);\\n  \\n  return parser.expression();\\n};", "var evaluate = function (expression) {\\n  vars.clear();\\n\\n  function saveVar(varName, value) {\\n    if (!vars.has(varName)) vars.set(varName, [value]);\\n    vars.get(varName).push(value);\\n  }\\n\\n  function getVar(varName) {\\n    const history = vars.get(varName);\\n    return history[history.length - 1];\\n  }\\n\\n  function popVar(varName) {\\n    vars.get(varName).pop();\\n  }\\n\\n  function isNumberChar(c) {\\n    if (!c) return false;\\n    const cc = c.charCodeAt();\\n    return 48 <= cc && cc <= 57;\\n  }\\n\\n  function isAlphaChar(c) {\\n    const cc = c.charCodeAt();\\n    return 97 <= cc && cc <= 122;\\n  }\\n\\n  function getCurFn() {\\n    return fns[fns.length - 1];\\n  }\\n\\n  function checkVarResolvable() {\\n    const fn = getCurFn();\\n    if (fn.name !== \"l\") return true;\\n    return stack[stack.length - 1] !== \"(\";\\n  }\\n\\n  for (let i = 0; i < expression.length; i++) {\\n    if (expression[i] === \"(\") {\\n      let newFn = {\\n        name: undefined,\\n      };", "var evaluate = function(expression) {\\n  const lex = new Lexer(expression);\\n  const parser = new Parser(lex);\\n  \\n  return parser.expression();\\n};"]}
{"id": "1874", "ref_js": ["var cherryPickup = function(grid) {\\n    let N = grid.length;\\n    let dp = new Array(N).fill().map(()=>new Array(N).fill().map(()=>new Array(N).fill(-1)));\\n    return Math.max(0, pickup(0, 0, 0, grid, N, dp));\\n};", "var cherryPickup = function (grid) {\\n  let n = grid.length;\\n  let maxR = 2 * n - 2;\\n\\n  let cur = [[grid[0][0]]];\\n  let pre = [];\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] < 0) grid[i][j] = noo;\\n    }\\n  }\\n\\n  function set(arr, x, d, v) {\\n    while (arr.length <= x) arr.push([]);\\n    while (arr[x].length <= d) arr[x].push(0);\\n    arr[x][d] = v;\\n  }\\n\\n  function opt(arr, x, d, v) {\\n    while (arr.length <= x) arr.push([]);\\n    while (arr[x].length <= d) arr[x].push(0);\\n    arr[x][d] = Math.max(arr[x][d], v);\\n  }\\n\\n  function inGrid(x, y) {\\n    return x >= 0 && x < n && y >= 0 && y < n;\\n  }\\n\\n  for (let r = 1; r <= maxR; r++) {\\n    let temp = pre;\\n    pre = cur;\\n    cur = temp;\\n\\n    let minX = Math.max(0, r - n + 1);\\n    let maxX = Math.min(n - 1, r);\\n\\n    for (let x1 = minX; x1 <= maxX; x1++) {\\n      set(cur, x1, 0, noo);\\n      let y1 = r - x1;\\n      let g1 = grid[x1][y1];\\n\\n      if (inGrid(x1 - 1, y1)) opt(cur, x1, 0, pre[x1 - 1][0] + g1);\\n      if (inGrid(x1, y1 - 1)) opt(cur, x1, 0, pre[x1][0] + g1);\\n      if (inGrid(x1 - 1, y1 - 1)) opt(cur, x1, 0, pre[x1 - 1][1] + g1);\\n\\n      for (let x2 = x1 + 1; x2 <= maxX; x2++) {\\n        let y2 = r - x2;\\n        let g2 = grid[x2][y2];\\n        let d = x2 - x1;\\n        let g = g1 + g2;\\n\\n        set(cur, x1, d, noo);\\n\\n        if (inGrid(x1-1, y1) && inGrid(x2-1, y2)) opt(cur, x1, d, pre[x1-1][d] + g);\\n        if (inGrid(x1, y1-1) && inGrid(x2, y2-1)) opt(cur, x1, d, pre[x1][d] + g);\\n        if (inGrid(x1-1, y1) && inGrid(x2, y2-1)) opt(cur, x1, d, pre[x1-1][d+1] + g);\\n        if (inGrid(x1, y1-1) && inGrid(x2-1, y2)) opt(cur, x1, d, pre[x1][d-1] + g);\\n      }\\n    }\\n  }\\n\\n  return Math.max(cur[n-1][0], 0);\\n};", "var cherryPickup = function(grid) {\\n    let rows = grid.length;\\n    let cols = grid[0].length;\\n\\n    const memo = new Map();\\n\\n    const inBounds = (r,c) => {\\n        if(r >= 0 && c >= 0 && r < rows && c < cols)\\n            return true;\\n        return false;\\n    }\\n\\n    let end = false;\\n    const helper = (r1, c1,r2,c2) => {\\n        if(!inBounds(r1, c1) || !inBounds(r2, c2) || grid[r1][c1] === -1 || grid[r2][c2] === -1)\\n            return -Infinity;\\n\\n        if(r1 === rows - 1 && c1 === cols - 1) {\\n            end = true;\\n            return grid[r1][c1];\\n        }\\n\\n        if(r2 === rows - 1 && c2 === cols - 1) {\\n            end = true;\\n            return grid[r2][c2];\\n        }\\n            \\n\\n        let key = `${r1}#${c1}#${r2}#${c2}`;\\n\\n        if(memo.has(key))\\n            return memo.get(key);\\n\\n        let c = 0;\\n        if(r1 === r2 && c1 === c2) {\\n            c += grid[r1][c1];\\n        } else {\\n            c = c + grid[r1][c1] + grid[r2][c2];\\n        }\\n\\n        let op1 = helper(r1, c1 + 1, r2, c2 + 1); "]}
{"id": "1876", "ref_js": ["var containVirus = function (isInfected) {\\n  let n = isInfected[0].length;\\n  let m = isInfected.length;\\n  let label = 0;\\n  let res = 0;\\n\\n  function bfs(ir, ic, label) {\\n    qr.enqueue(ir);\\n    qc.enqueue(ic);\\n    let labelState = (label << 3) | 2;\\n    isInfected[ir][ic] = labelState;\\n    initLabel(label);\\n\\n    while (qr.size) {\\n      let r = qr.dequeue();\\n      let c = qc.dequeue();\\n\\n      for (let i = 0; i < 4; i++) {\\n        let rr = r + DIR_R[i];\\n        let cc = c + DIR_C[i];\\n        let state = isInfected[rr]?.[cc];\\n        if (state == undefined) continue;\\n\\n        switch (state & 7) {\\n          case 0: {\\n            isInfected[rr][cc] = (label << 3) | 3;\\n            fences[label]++;\\n            threats[label]++;\\n            break;\\n          }\\n          case 1: {\\n            qr.enqueue(rr);\\n            qc.enqueue(cc);\\n            isInfected[rr][cc] = labelState;\\n            break;\\n          }\\n          case 3: {\\n            fences[label]++;\\n            if ((state >> 3) != label) {\\n              threats[label]++;\\n              isInfected[rr][cc] = (label << 3) | 3;\\n            }\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function isStillThreaten(r, c, lockedLabel) {\\n    for (let i = 0; i < 4; i++) {\\n      let rr = r + DIR_R[i];\\n      let cc = c + DIR_C[i];\\n      let state = isInfected[rr]?.[cc];\\n      if ((state & 7) == 2 && (state >> 3) != lockedLabel) return true;\\n    }\\n  }\\n\\n  while (true) {\\n    label = 0;\\n    let lockedLabel = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if (isInfected[r][c] == 1) {\\n          bfs(r, c, label);\\n          if (threats[label] > threats[lockedLabel]) lockedLabel = label;\\n          label++;\\n        }\\n      }\\n    }\\n\\n    if (!label) return res;\\n\\n    res += fences[lockedLabel];\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if ((isInfected[r][c] & 7) == 3) {\\n          if (isStillThreaten(r, c, lockedLabel)) isInfected[r][c] = 1;\\n          else isInfected[r][c] = 0;\\n        }\\n      }\\n    }\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        let state = isInfected[r][c];\\n        if ((state & 7) == 2) {\\n          if ((state >> 3) == lockedLabel) isInfected[r][c] = 4;\\n          else isInfected[r][c] = 1;\\n        }\\n      }\\n    }\\n  }\\n};", "var containVirus = function(grid) {\\n    const R = grid.length\\n    const C = grid[0].length\\n    const DIRS = [[1,0],[0,1],[-1,0],[0,-1]]\\n    let res = 0\\n    \\n while(true) {\\n    const visited = new Set() \\n    const pq = new Heap((a,b) => b.futureInfected.size - a.futureInfected.size)\\n    \\n    for(let i = 0; i < R; i++) {\\n        for(let j = 0; j < C; j++) {\\n            if(!visited.has([i,j].join(\\',\\')) && grid[i][j]===1) {\\n                const cluster = new Cluster()\\n                dfs(i,j, cluster)\\n                \\n                pq.add(cluster)\\n            }\\n        }\\n    }\\n     \\n    if(pq.size===0) return res \\n     const top = pq.pop()[0] ", "var containVirus = function (isInfected) {\\n  let n = isInfected[0].length;\\n  let m = isInfected.length;\\n  let label = 0;\\n  let res = 0;\\n\\n  function bfs(ir, ic, label) {\\n    qr.enqueue(ir);\\n    qc.enqueue(ic);\\n    let labelState = (label << 3) | 2;\\n    isInfected[ir][ic] = labelState;\\n    initLabel(label);\\n\\n    while (qr.size) {\\n      let r = qr.dequeue();\\n      let c = qc.dequeue();\\n\\n      for (let i = 0; i < 4; i++) {\\n        let rr = r + DIR_R[i];\\n        let cc = c + DIR_C[i];\\n        let state = isInfected[rr]?.[cc];\\n        if (state == undefined) continue;\\n\\n        switch (state & 7) {\\n          case 0: {\\n            isInfected[rr][cc] = (label << 3) | 3;\\n            fences[label]++;\\n            threats[label]++;\\n            break;\\n          }\\n          case 1: {\\n            qr.enqueue(rr);\\n            qc.enqueue(cc);\\n            isInfected[rr][cc] = labelState;\\n            break;\\n          }\\n          case 3: {\\n            fences[label]++;\\n            if ((state >> 3) != label) {\\n              threats[label]++;\\n              isInfected[rr][cc] = (label << 3) | 3;\\n            }\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function isStillThreaten(r, c, lockedLabel) {\\n    for (let i = 0; i < 4; i++) {\\n      let rr = r + DIR_R[i];\\n      let cc = c + DIR_C[i];\\n      let state = isInfected[rr]?.[cc];\\n      if ((state & 7) == 2 && (state >> 3) != lockedLabel) return true;\\n    }\\n  }\\n\\n  while (true) {\\n    label = 0;\\n    let lockedLabel = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if (isInfected[r][c] == 1) {\\n          bfs(r, c, label);\\n          if (threats[label] > threats[lockedLabel]) lockedLabel = label;\\n          label++;\\n        }\\n      }\\n    }\\n\\n    if (!label) return res;\\n\\n    res += fences[lockedLabel];\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        if ((isInfected[r][c] & 7) == 3) {\\n          if (isStillThreaten(r, c, lockedLabel)) isInfected[r][c] = 1;\\n          else isInfected[r][c] = 0;\\n        }\\n      }\\n    }\\n\\n    for (let r = 0; r < m; r++) {\\n      for (let c = 0; c < n; c++) {\\n        let state = isInfected[r][c];\\n        if ((state & 7) == 2) {\\n          if ((state >> 3) == lockedLabel) isInfected[r][c] = 4;\\n          else isInfected[r][c] = 1;\\n        }\\n      }\\n    }\\n  }\\n};"]}
{"id": "1877", "ref_js": ["var digitCount = function(num) {\\n\\n    if(num==0){\\n        return false\\n    }else if(num==21200||num==2020){\\n        return true\\n    }\\n\\n    for(let i=0;i<num.length;i++){\\n            let count=0;\\n        for(let j=0;j<num.length;j++){\\n            if(i==num[j]&&i!=j){\\n                count++\\n            }\\n        }\\n        if(count!=num[i]){\\n            return false\\n        }\\n        \\n    }\\n    return true\\n    \\n};", "var digitCount = function(num) {\\n    let map = new Map();\\n    \\n  \\n    for( let i = 0; i < num.length; i++) {\\n    let count = 0\\n     for(let j = 0; j < num.length; j++) {\\n         if(i.toString() === num[j]){\\n             count++\\n            }\\n        }\\n        map.set(i,count)\\n        \\n        if(map.get(i) != num[i]) {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};", "var digitCount = function(num) {\\n    const arr= Array(num.length).fill(0)\\n    for(let elem of num){\\n        arr[elem]++\\n    }\\n    return arr.join(\\'\\') == num\\n};"]}
{"id": "1878", "ref_js": ["var intersectionSizeTwo = function(intervals) {\\n    const sortedIntervals = intervals.sort(sortEndsThenStarts)\\n    let currentTail = []\\n    let answer = 0\\n    sortedIntervals.forEach(interval => {\\n        const start = interval[0]\\n        const end = interval[1]\\n        const startPoint = currentTail[0]\\n        const lastPoint = currentTail[1]\\n        \\n        if (!currentTail.length || lastPoint < start){\\n            currentTail = [end -1, end]\\n            answer += 2\\n        } else if ( startPoint < start){\\n            currentTail = [currentTail[1], end]\\n            answer += 1\\n        }\\n\\n    })\\n    return answer\\n\\n};", "var intersectionSizeTwo = function (intervals) {\\n  ", "var intersectionSizeTwo = function (intervals) {\\n  "]}
{"id": "1879", "ref_js": ["var makeLargestSpecial = function (S) {\\n  let t = S\\n  while (true) {\\n    let t1 = largest(t)\\n    if (t1 == t) return t\\n    t = t1\\n  }\\n  function largest(S) {\\n    let arr = S.split(\\'\\').map(x => Number.parseInt(x)),\\n      num = Number.parseInt(S, 2), rtn = S\\n    for (let firstEndIndex = 1; firstEndIndex < S.length - 2; firstEndIndex++) {\\n      for (let lLength = 2; lLength < firstEndIndex + 2; lLength += 2) {\\n        let firstStartIndex = firstEndIndex - lLength + 1\\n        if (!isSpecial(firstStartIndex, firstEndIndex)) continue\\n        for (let rLength = 2; rLength < S.length - firstEndIndex; rLength += 2) {\\n          let secondStartIndex = firstEndIndex + 1, secondEndIndex = firstEndIndex + rLength\\n          if (!isSpecial(secondStartIndex, secondEndIndex)) continue\\n          let str = [...arr.slice(0, firstStartIndex),\\n          ...arr.slice(secondStartIndex, secondEndIndex + 1),\\n          ...arr.slice(firstStartIndex, firstEndIndex + 1),\\n          ...arr.slice(secondEndIndex + 1)].join(\\'\\')\\n          let newNum = Number.parseInt(str, 2)\\n          if (newNum > num) {\\n            num = newNum\\n            rtn = str\\n          }\\n        }\\n      }\\n    }\\n    return rtn\\n\\n    function isSpecial(start, end) {\\n      let t = 0\\n      for (let i = start; i <= end; i++) {\\n        t += arr[i] == 1 ? 1 : -1\\n        if (t < 0) return false ", "var makeLargestSpecial = function(s) {\\n  return recurse(s);\\n  \\n  function recurse(s) {\\n    let i = 0, res = [], bal = 0;\\n    for (let j = 0; j < s.length; j++) {\\n      if (s[j] === \\'1\\') bal++;\\n      else bal--;\\n      if (bal === 0) { ", "var makeLargestSpecial = function(s) {\\n  return recurse(s);\\n  \\n  function recurse(s) {\\n    let i = 0, res = [], bal = 0;\\n    for (let j = 0; j < s.length; j++) {\\n      if (s[j] === \\'1\\') bal++;\\n      else bal--;\\n      if (bal === 0) { "]}
{"id": "1880", "ref_js": ["var minSwapsCouples = function(row) {\\n    const n = row.length / 2;\\n    const uf = new UnionFind(n);\\n    ", "var minSwapsCouples = function(row) {\\n    let res = 0\\n    for(i=0;i<row.length-1;i+=2) {\\n        let pair=0\\n        if(row[i]%2===0) {pair=row[i]+1}\\n        else pair=row[i]-1\\n        if(row[i+1]===pair) continue\\n        for(j=i;j<row.length;j++) {\\n            if(row[j]===pair) {\\n                row[j]=row[i+1]\\n                row[i+1]=pair\\n                res++\\n                break\\n            }\\n        }\\n    }\\n    return res\\n};", "var minSwapsCouples = function(row) {\\n    let currentPositions = [];\\n\\n    for(let i=0;i<row.length;i++){\\n        currentPositions[row[i]]=i;\\n    }\\n\\n    let swapCount = 0;\\n\\n\\n     for(let j=0;j<row.length;j+=2) "]}
{"id": "1881", "ref_js": ["var maxChunksToSorted = function(arr) {\\n  let stack = [arr[0]]; ", "var maxChunksToSorted = function(arr) {\\n        let sortArr = [...arr].sort((a,b)=> a-b);\\n        let sum1 = 0, sum2 = 0, count = 0;\\n        for (let i = 0; i< arr.length; i++){\\n            sum1+= arr[i];\\n            sum2+= sortArr[i];\\n            if (sum1==sum2){\\n                count += 1;\\n                sum1 = 0;\\n                sum2 = 0;\\n            }   \\n        }       \\n        return count   \\n};", "var maxChunksToSorted = function(arr) {\\n  let stack = [arr[0]]; "]}
{"id": "1882", "ref_js": ["var basicCalculatorIV = function (expression, evalvars, evalints) {\\n  let tokens = toTokens(expression).map(x => /^\\\\d+$/.test(x) ? parseInt(x) : x),\\n    vals = toVarDic(evalvars, evalints),\\n    index = 0;\\n\\n  let exp = nextExp();\\n  return exp.toArray();\\n\\n  function nextExp() {\\n    if (index >= tokens.length) return new Exp();\\n    let [exp, op1] = [nextUnit(), nextOperator()];\\n    if (!op1 || op1 === \\')\\') return exp;\\n    let exp1 = nextUnit();\\n    while (true) {\\n      let op2 = nextOperator();\\n      if (!op2 || op2 === \\')\\') return dealDefault();\\n      let exp2 = nextUnit();\\n      switch (op2) {\\n        case \\'+\\':\\n        case \\'-\\':\\n          exp = dealDefault();\\n          op1 = op2;\\n          exp1 = exp2;\\n          continue;\\n        case \\'*\\':\\n          exp1 = exp1.product(exp2);\\n          continue;\\n        default:\\n          return dealDefault();\\n      }\\n    }\\n\\n    function dealDefault() {\\n      switch (op1) {\\n        case \\'+\\':\\n          return exp.add(exp1);\\n        case \\'-\\':\\n          let expz = exp1.product(new Exp([new Unit(-1, [])]));\\n          return exp.add(expz);\\n        case \\'*\\':\\n          return exp.product(exp1);\\n      }\\n    }\\n  }\\n\\n  function nextUnit() {\\n    if (index >= tokens.length) return new Exp();\\n    let rtn;\\n    if (tokens[index] === \\'(\\') {\\n      index++;\\n      return nextExp();\\n    } else if (Number.isInteger(tokens[index])) {\\n      rtn = new Exp([new Unit(tokens[index], [])]);\\n    } else if (vals.has(tokens[index])) {\\n      rtn = new Exp([new Unit(vals.get(tokens[index]), [])]);\\n    } else {\\n      rtn = new Exp([new Unit(1, [tokens[index]])]);\\n    }\\n    index++;\\n    return rtn;\\n  }\\n\\n  function nextOperator() {\\n    if (index >= tokens.length) return undefined;\\n    let op = tokens[index];\\n    index++;\\n    return op;\\n  }\\n};", "var basicCalculatorIV = function (expression, evalvars, evalints) {\\n  let tokens = toTokens(expression)\\n    .map(x => /^\\\\d+$/.test(x) ? Number.parseInt(x) : x),\\n    vals = toVarDic(evalvars, evalints), i = 0\\n\\n  let exp = nextExp()\\n  return exp.toArray()\\n\\n\\n  function nextExp() {\\n    if (i >= tokens.length) return undefined\\n    let [exp, op1] = [nextUnit(), nextOperator()]\\n    if (!op1 || op1 == \\')\\') return exp\\n    let exp1 = nextUnit()\\n    while (true) {\\n      let op2 = nextOperator()\\n      if (!op2 || op2 == \\')\\') return dealDefault()\\n      let exp2 = nextUnit()\\n      switch (op2) {\\n        case \\'+\\':\\n        case \\'-\\':\\n          exp = dealDefault()\\n          op1 = op2\\n          exp1 = exp2\\n          continue\\n        case \\'*\\':\\n          exp1 = exp1.product(exp2)\\n          continue\\n        default:\\n          return dealDefault()\\n      }\\n      function dealDefault() {\\n        switch (op1) {\\n          case \\'+\\':\\n            return exp.add(exp1)\\n          case \\'-\\':\\n            let expz = exp1.product(new Exp([new Unit(-1, [])]))\\n            return exp.add(expz)\\n          case \\'*\\':\\n            return exp.product(exp1)\\n        }\\n        debugger\\n      }\\n    }\\n  }\\n\\n  \\n  function nextUnit() {\\n    if (i >= tokens.length) return undefined\\n    let rtn\\n    if (tokens[i] == \\'(\\') {\\n      i++\\n      return nextExp()\\n    }\\n    else if (Number.isInteger(tokens[i])) rtn = new Exp([\\n      new Unit(tokens[i], [])\\n    ])\\n    else if (vals.has(tokens[i])) rtn = new Exp([\\n      new Unit(vals.get(tokens[i]), [])\\n    ])\\n    else rtn = new Exp([\\n      new Unit(1, [tokens[i]])\\n    ])\\n    i++\\n    return rtn\\n  }\\n  function nextOperator() {\\n    if (i >= tokens.length) return undefined\\n    let op = tokens[i]\\n    i++\\n    return op\\n  }\\n};", "var basicCalculatorIV = function (expression, evalvars, evalints) {\\n  let tokens = toTokens(expression)\\n    .map(x => /^\\\\d+$/.test(x) ? Number.parseInt(x) : x),\\n    vals = toVarDic(evalvars, evalints), i = 0\\n\\n  let exp = nextExp()\\n  return exp.toArray()\\n\\n\\n  function nextExp() {\\n    if (i >= tokens.length) return undefined\\n    let [exp, op1] = [nextUnit(), nextOperator()]\\n    if (!op1 || op1 == \\')\\') return exp\\n    let exp1 = nextUnit()\\n    while (true) {\\n      let op2 = nextOperator()\\n      if (!op2 || op2 == \\')\\') return dealDefault()\\n      let exp2 = nextUnit()\\n      switch (op2) {\\n        case \\'+\\':\\n        case \\'-\\':\\n          exp = dealDefault()\\n          op1 = op2\\n          exp1 = exp2\\n          continue\\n        case \\'*\\':\\n          exp1 = exp1.product(exp2)\\n          continue\\n        default:\\n          return dealDefault()\\n      }\\n      function dealDefault() {\\n        switch (op1) {\\n          case \\'+\\':\\n            return exp.add(exp1)\\n          case \\'-\\':\\n            let expz = exp1.product(new Exp([new Unit(-1, [])]))\\n            return exp.add(expz)\\n          case \\'*\\':\\n            return exp.product(exp1)\\n        }\\n        debugger\\n      }\\n    }\\n  }\\n\\n  \\n  function nextUnit() {\\n    if (i >= tokens.length) return undefined\\n    let rtn\\n    if (tokens[i] == \\'(\\') {\\n      i++\\n      return nextExp()\\n    }\\n    else if (Number.isInteger(tokens[i])) rtn = new Exp([\\n      new Unit(tokens[i], [])\\n    ])\\n    else if (vals.has(tokens[i])) rtn = new Exp([\\n      new Unit(vals.get(tokens[i]), [])\\n    ])\\n    else rtn = new Exp([\\n      new Unit(1, [tokens[i]])\\n    ])\\n    i++\\n    return rtn\\n  }\\n  function nextOperator() {\\n    if (i >= tokens.length) return undefined\\n    let op = tokens[i]\\n    i++\\n    return op\\n  }\\n};"]}
{"id": "1883", "ref_js": ["var slidingPuzzle = function(board) {\\n    let visit = new Set();\\n    let res = 0;\\n    let dupL = board[0].join(\"\");\\n    let dupR = board[1].join(\"\");\\n    let dup = dupL + dupR;\\n    if(dup === \"123450\"){\\n        return res;\\n    }\\n    visit.add(dup);\\n    let queue = [];\\n    queue.push(dup);\\n    while(queue.length > 0){\\n        let niv = queue.length;\\n        res++;\\n        while(niv > 0){\\n            let temp = queue.shift();\\n            for(let i = 0; i <= 5; i++){\\n                if(temp[i] === \"0\"){\\n                    if(i < 5 && i !== 2){\\n                        let rev = temp.slice(0, i);\\n                        rev += temp.charAt(i + 1);\\n                        rev += temp.charAt(i);\\n                        rev += temp.slice(i + 2);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    if(i > 0 && i !== 3){\\n                        let rev = temp.slice(0, i - 1);\\n                        rev += temp.charAt(i);\\n                        rev += temp.charAt(i - 1);\\n                        rev += temp.slice(i + 1);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    if(i < 3){\\n                        let rev = temp.slice(0, i);\\n                        rev += temp.charAt(i + 3);\\n                        rev += temp.slice(i + 1, i + 3);\\n                        rev += temp.charAt(i);\\n                        rev += temp.slice(i + 4);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    if(i > 2){\\n                        let rev = temp.slice(0, i - 3);\\n                        rev += temp.charAt(i);\\n                        rev += temp.slice(i - 2, i);\\n                        rev += temp.charAt(i - 3);\\n                        rev += temp.slice(i + 1);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n            niv--;\\n        }\\n    }\\n    return -1;\\n};", "var slidingPuzzle = function(board) {\\n    let visited = new Set();\\n\\n    let serialize = (b) => [...b[0], ...b[1]].join(\\',\\');\\n\\n    let findZero = (b) => {\\n        for (let i = 0; i < 2; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (b[i][j] === 0) {\\n                    return [i, j];\\n                }\\n            }\\n        }\\n    };", "var slidingPuzzle = function(board) {\\n    let visit = new Set();\\n    let res = 0;\\n    let dupL = board[0].join(\"\");\\n    let dupR = board[1].join(\"\");\\n    let dup = dupL + dupR;\\n    if(dup === \"123450\"){\\n        return res;\\n    }\\n    visit.add(dup);\\n    let queue = [];\\n    queue.push(dup);\\n    while(queue.length > 0){\\n        let niv = queue.length;\\n        res++;\\n        while(niv > 0){\\n            let temp = queue.shift();\\n            for(let i = 0; i <= 5; i++){\\n                if(temp[i] === \"0\"){\\n                    if(i < 5 && i !== 2){\\n                        let rev = temp.slice(0, i);\\n                        rev += temp.charAt(i + 1);\\n                        rev += temp.charAt(i);\\n                        rev += temp.slice(i + 2);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    if(i > 0 && i !== 3){\\n                        let rev = temp.slice(0, i - 1);\\n                        rev += temp.charAt(i);\\n                        rev += temp.charAt(i - 1);\\n                        rev += temp.slice(i + 1);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    if(i < 3){\\n                        let rev = temp.slice(0, i);\\n                        rev += temp.charAt(i + 3);\\n                        rev += temp.slice(i + 1, i + 3);\\n                        rev += temp.charAt(i);\\n                        rev += temp.slice(i + 4);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    if(i > 2){\\n                        let rev = temp.slice(0, i - 3);\\n                        rev += temp.charAt(i);\\n                        rev += temp.slice(i - 2, i);\\n                        rev += temp.charAt(i - 3);\\n                        rev += temp.slice(i + 1);\\n                        if(rev === \"123450\"){\\n                            return res;\\n                        }\\n                        if(!visit.has(rev)){\\n                            visit.add(rev);\\n                            queue.push(rev);\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n            niv--;\\n        }\\n    }\\n    return -1;\\n};"]}
{"id": "1884", "ref_js": ["var swimInWater = function(grid) {\\n    let pq = new MinPriorityQueue(),\\n        N = grid.length - 1, ans = grid[0][0], i = 0, j = 0\\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            pq.enqueue((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = pq.dequeue().element\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};", "var swimInWater = function(grid) {\\n    let n = grid.length;\\n    \\n    if (n === 1) return grid[0][0];\\n    \\n    let visited = Array(n).fill(false).map(() => Array(n).fill(false));\\n    \\n    let minH = new MinPriorityQueue({priority: x => x.time});\\n    \\n    minH.enqueue({time: grid[0][0], row: 0, col: 0});\\n    \\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    \\n    while(!minH.isEmpty()) {\\n        let {time, row, col} = minH.dequeue().element;\\n        \\n        if (row === n - 1 && col === n - 1) return time;\\n        \\n        for (let [dx, dy] of directions) {\\n            dx += row;\\n            dy += col;\\n            if (dx < 0 || dy < 0 || dx >= n || dy >= n || visited[dx][dy]) continue;\\n            visited[dx][dy] = true;\\n            minH.enqueue({time: Math.max(time, grid[dx][dy]), row: dx, col: dy});\\n        }\\n    }\\n};", "var swimInWater = function(grid) {\\n    let visited = new Set(), time = 0, N = grid.length;\\n    let dirs = [[-1,0], [0,-1], [0,1],[1,0]];\\n    \\n    const dfs = (r, c) => {\\n        if(r < 0 || r > N -1 || c < 0 || c > N -1 || time < grid[r][c] || visited.has(r*N + c)) return;\\n        visited.add(r * N + c);\\n        for(let [rr, cc] of dirs) \\n            dfs(r + rr, c + cc);\\n    };"]}
{"id": "1885", "ref_js": ["var reachingPoints = function(sx, sy, tx, ty) {\\n\\n    if(sx>tx || sy>ty) return false;\\n    if(sx==tx) return (ty-sy)%sx==0;\\n    if(sy==ty) return (tx-sx)%sy==0;\\n\\n    if(tx>ty) return reachingPoints(sx, sy, tx%ty, ty);\\n    else if(tx<ty) return reachingPoints(sx, sy, tx, ty%tx);\\n    else return false;\\n    \\n};", "var reachingPoints = function (sx, sy, tx, ty) {\\n  while (tx >= 1 && ty >= 1) {\\n    if (sx === tx) return ty >= sy && (ty - sy) % tx === 0;\\n    if (sy === ty) return tx >= sx && (tx - sx) % ty === 0;\\n\\n    if (tx >= ty) tx %= ty;\\n    else if (ty > tx) ty %= tx;\\n  }\\n  return false;\\n};", "var reachingPoints = function (sx, sy, tx, ty) {\\n  while (tx >= 1 && ty >= 1) {\\n    if (sx === tx) return ty >= sy && (ty - sy) % tx === 0;\\n    if (sy === ty) return tx >= sx && (tx - sx) % ty === 0;\\n\\n    if (tx >= ty) tx %= ty;\\n    else if (ty > tx) ty %= tx;\\n  }\\n  return false;\\n};"]}
{"id": "1886", "ref_js": ["var movesToChessboard = function(board) {\\n    const boardSize = board.length;\\n    const boardSizeIsEven = boardSize % 2 === 0;\\n       \\n    if(!canBeTransformed(board)) return -1;\\n    \\n    ", "var movesToChessboard = function(board) {\\n    const boardSize = board.length;\\n    const boardSizeIsEven = boardSize % 2 === 0;\\n       \\n    if(!canBeTransformed(board)) return -1;\\n    \\n    ", "var movesToChessboard = function(board) {\\n    const boardSize = board.length;\\n    const boardSizeIsEven = boardSize % 2 === 0;\\n       \\n    if(!canBeTransformed(board)) return -1;\\n    \\n    "]}
{"id": "1887", "ref_js": ["var preimageSizeFZF = function (K) {\\n  \\n\\n  ", "var preimageSizeFZF = function (K) {\\n  \\n\\n  ", "var preimageSizeFZF = function (K) {\\n  \\n\\n  "]}
{"id": "1888", "ref_js": ["var replaceWords = function(dictionary, sentence) {\\n    const arr = sentence.split(\\' \\');\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let word of dictionary) {\\n            if (arr[i].startsWith(word)) {\\n                arr[i] = word;\\n            }\\n        }\\n    }\\n    return arr.join(\\' \\');\\n};", "var replaceWords = function(dictionary, sentence) {\\n    let wordArr = sentence.split(\" \");\\n    wordArr = wordArr.map(w => {\\n        for(let i = 0; i <= dictionary.length - 1; i++) {\\n            if (w.indexOf(dictionary[i]) === 0) {\\n                w = dictionary[i];\\n            }\\n        }\\n        return w;\\n    })\\n    return wordArr.reduce((str, word) => str += `${word} `, \"\").trim();\\n};", "var replaceWords = function(dictionary, sentence) {\\n    const sentArr = sentence.split(\\' \\');\\n    for(let i=0; i<sentArr.length; i++) {\\n        for(dict of dictionary) {\\n            if(sentArr[i].indexOf(dict) === 0) {\\n               sentArr[i] = dict;\\n            }\\n        }\\n    }\\n    const ans = sentArr.join(\" \");\\n    return ans;\\n};"]}
{"id": "1889", "ref_js": ["var minSwap = function(A, B) {\\n\\n        const N = A.length;\\n        const swap = new Array(N).fill(1);\\n        const not_swap = new Array(N).fill(0);\\n\\n        for (let i = 1; i < N; i++) {\\n            not_swap[i] = swap[i] = N;\\n\\n            if (A[i - 1] < A[i] && B[i - 1] < B[i]) {\\n                swap[i] = swap[i - 1] + 1;\\n                not_swap[i] = not_swap[i - 1];\\n            }\\n\\n            if (A[i - 1] < B[i] && B[i - 1] < A[i]) {\\n                swap[i] = Math.min(swap[i], not_swap[i - 1] + 1); \\n", "var minSwap = function(nums1, nums2) {\\n    const n = nums1.length;\\n    let swap = new Array(n).fill(n);\\n    let noSwap = new Array(n).fill(n);\\n    \\n    swap[0] = 1;\\n    noSwap[0] = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\\n            noSwap[i] = noSwap[i - 1];\\n            swap[i] = swap[i - 1] + 1;\\n        }\\n\\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\\n            swap[i] = Math.min(swap[i], noSwap[i - 1] + 1);\\n            noSwap[i] = Math.min(noSwap[i], swap[i - 1]);\\n        }\\n    }\\n\\n    return Math.min(swap[n - 1], noSwap[n - 1]);\\n};", "var swap = function(prev1, prev2) {\\n  return [prev2, prev1];\\n}\\n\\n"]}
{"id": "1890", "ref_js": ["var hitBricks = function(grid, hits) {\\n    let output = []\\n    for (let i = 0; i < hits.length; i++) {\\n        let map = {};", "var hitBricks = function(grid, hits) {\\n    let output = []\\n    for (let i = 0; i < hits.length; i++) {\\n        let map = {};", "var hitBricks = function(grid, hits) {\\n    let output = []\\n    for (let i = 0; i < hits.length; i++) {\\n        let map = {};"]}
{"id": "1891", "ref_js": ["var splitArraySameAverage = function(A) {\\n    const total = A.reduce((acc, cur) => {\\n        acc += cur;\\n        return acc;\\n    }, 0);\\n    const avg = total/A.length;\\n    \\n\\t", "var splitArraySameAverage = function(A) {\\n    const total = A.reduce((acc, cur) => {\\n        acc += cur;\\n        return acc;\\n    }, 0);\\n    const avg = total/A.length;\\n    \\n\\t", "var splitArraySameAverage = function(A) {\\n    const total = A.reduce((acc, cur) => {\\n        acc += cur;\\n        return acc;\\n    }, 0);\\n    const avg = total/A.length;\\n    \\n\\t"]}
{"id": "1892", "ref_js": ["var xorGame = function (nums) {\\n  let xor = 0;\\n  for (const num of nums) {\\n    xor ^= num;\\n  }\\n\\n  return xor === 0 || nums.length % 2 === 0;\\n};", "var xorGame = function(nums) {\\n    ", "var xorGame = function (a) {\\n    let xor = a.reduce((x, e) => x ^ e, 0);\\n\\n    "]}
{"id": "1893", "ref_js": ["var numBusesToDestination = function(routes, S, T) {\\n    if (S === T) return 0\\n    let visited = new Set();\\n    visited.add(S)\\n    let added = true\\n    let count = 0\\n    \\n    while(added){\\n        added = false ", "var numBusesToDestination = function(routes, source, target) {\\n    const stopToBuses = new Map();\\n\\n    for (let busId = 0; busId < routes.length; busId++) {\\n        const route = routes[busId];\\n        for (const stop of route) {\\n            if (!stopToBuses.has(stop)) {\\n                stopToBuses.set(stop, []);\\n            }\\n            stopToBuses.get(stop).push(busId);\\n        }\\n    }\\n\\n    if (!stopToBuses.has(source) || !stopToBuses.has(target)) {\\n        return -1;\\n    }\\n\\n    if (source === target) {\\n        return 0;\\n    }\\n\\n    const queue = [source];\\n    const busesTaken = new Set();\\n    const stopsVisited = new Set();\\n    let res = 0;\\n\\n    while (queue.length > 0) {\\n        res++;\\n        const stopsToProcess = queue.length;\\n\\n        for (let i = 0; i < stopsToProcess; i++) {\\n            const currentStop = queue.shift();\\n\\n            for (const busId of stopToBuses.get(currentStop) || []) {\\n                if (busesTaken.has(busId)) {\\n                    continue;\\n                }\\n\\n                busesTaken.add(busId);\\n\\n                for (const nextStop of routes[busId]) {\\n                    if (stopsVisited.has(nextStop)) {\\n                        continue;\\n                    }\\n\\n                    if (nextStop === target) {\\n                        return res;\\n                    }\\n\\n                    queue.push(nextStop);\\n                    stopsVisited.add(nextStop);\\n                }\\n            }\\n        }\\n    }\\n\\n    return -1;    \\n};", "var numBusesToDestination = function(routes, S, T) {\\n    if (S === T) return 0\\n    let visited = new Set();\\n    visited.add(S)\\n    let added = true\\n    let count = 0\\n    \\n    while(added){\\n        added = false "]}
{"id": "1894", "ref_js": ["var racecar = function(target) {\\n    let dp = Array(target + 1);\\n    for (let i = 1; i <= target; i++) {\\n        dp[i] = Number.MAX_SAFE_INTEGER;\\n        let j = 1, cnt1 = 1;\\n        for (; j < i; j = (1 << cnt1) - 1) {\\n            for (let k = 0, cnt2 = 0; k < j; k = (1 << cnt2) - 1) {\\n                dp[i] = Math.min(dp[i], cnt1 + 1 + cnt2 + 1 + dp[i - (j - k)]);\\n                cnt2++;\\n            }\\n            cnt1++;\\n        }\\n        dp[i] = Math.min(dp[i], cnt1 + (i == j ? 0 : 1 + dp[j - i]));\\n    }\\n    return dp[target];\\n};", "var racecar = function(target) {\\n    const queue = [[0, 0, 1]];\\n    const visited = new Set();\\n    while(queue.length > 0){\\n        const [moves, position, speed] = queue.shift();\\n        if(position === target) return moves;\\n        \\n        if(visited.has(`${position},${speed}`)) continue\\n        else visited.add(`${position},${speed}`)\\n        \\n        ", "var racecar = function(target) {\\n    const queue = [[0, 0, 1]];\\n    const visited = new Set();\\n    while(queue.length > 0){\\n        const [moves, position, speed] = queue.shift();\\n        if(position === target) return moves;\\n        \\n        if(visited.has(`${position},${speed}`)) continue\\n        else visited.add(`${position},${speed}`)\\n        \\n        "]}
{"id": "1895", "ref_js": ["var largestIsland = function(grid) {\\n    let m = grid.length; let n = grid[0].length;\\n\\n    ", "var largestIsland = function(grid) {\\n    const n = grid.length - 1;\\n    const visited = Array.from(Array(n+1),() => Array(n+1).fill(false));\\n    ", "var largestIsland = function(grid) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    const n = (rows * cols) - 1;\\n\\n    const parent = [];\\n    const sizes = [];\\n\\n    for (let i = 0; i <= n; i++) { \\n        parent[i] = i;\\n        sizes[i] = 0;\\n    }\\n\\n    "]}
{"id": "1896", "ref_js": ["var uniqueLetterString = function(s) {\\n    let result = 0;\\n    const n = s.length;\\n    const hash = {};", "var uniqueLetterString = function(s) {\\n    let currentUniqueCount = 0;\\n    let lastPositionSeen = new Map();\\n    let contributions = new Map();\\n    let answer = 0;\\n    \\n    for (let x = 0; x < s.length; x++) {\\n        \\n        const char = s[x];\\n        const prevContributions = contributions.has(char) ? contributions.get(char) : 0;\\n        const newContributions = x + 1 - (lastPositionSeen.has(char) ? lastPositionSeen.get(char) + 1 : 0);\\n        \\n        currentUniqueCount = currentUniqueCount - prevContributions + newContributions;\\n        \\n        contributions.set(char, newContributions);\\n        lastPositionSeen.set(char, x);\\n\\n        answer += currentUniqueCount;\\n    }\\n    \\n    return answer;\\n};", "var uniqueLetterString = function(s) {\\n    let result = 0;\\n    const n = s.length;\\n    const hash = {};"]}
{"id": "1897", "ref_js": ["var consecutiveNumbersSum = function (n) {\\n  function sum_of_1st_n_numbers(n) {\\n    return (n * (n + 1)) / 2;\\n  }\\n  let count = 0;\\n  for (let len = 1; sum_of_1st_n_numbers(len - 1) < n; len++) {\\n    let remaining = n - sum_of_1st_n_numbers(len - 1);\\n    let divisible = remaining % len === 0;\\n    if (divisible) count++;\\n  }\\n  return count;\\n};", "var consecutiveNumbersSum = function(n) {\\n    let count = 1;\\n    for(let k = 2; k*(k-1) < 2*n; k++){\\n        if( (2*n+k*(1-k) ) % (2*k) == 0){\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n};", "var consecutiveNumbersSum = function(n) {\\n    let result = 1;\\n    for (let i = 2; i <= n; i++) {\\n        if (n / i < Math.floor((i + 1) / 2)) break;\\n        if (i % 2) {\\n            if (n % i === 0) result++;\\n        } else {\\n            if ((n / i) * 10 - Math.floor(n / i) * 10 === 5) result++;\\n        }\\n    }\\n    return result;\\n};"]}
{"id": "1898", "ref_js": ["var sumOfDistancesInTree = function(n, edges) {\\n    let adj = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Array()\\n    }\\n\\n    for (let e of edges) {\\n        adj[e[0]].push(e[1]);\\n        adj[e[1]].push(e[0])\\n    }\\n\\n    let count = new Array(n).fill(1);\\n    let ans = new Array(n).fill(0)\\n    let dfs1 = function(node, parent) {\\n        for (let child of adj[node]){\\n            if (child != parent) {\\n                dfs1(child, node)\\n                count[node] += count[child]\\n                ans[node] += ans[child] + count[child]\\n            }\\n        }\\n    }\\n\\n    let dfs2 = function(node, parent) {\\n        for (let child of adj[node]) {\\n            if (child != parent) {\\n                ans[child] = n - count[child] + ans[node] - count[child]\\n                dfs2(child, node)\\n            }\\n        }\\n    }\\n\\n    dfs1(0,-1)\\n    dfs2(0,-1)\\n    return ans;\\n};", "var sumOfDistancesInTree = function(n, edges) {\\n    let graph = new Array(n).fill().map(() => new Array());\\n\\n    for (let [s, t] of edges) {\\n        graph[s].push(t);\\n        graph[t].push(s);\\n    }\\n\\n    let count = new Array(n).fill(1);\\n    let ans = new Array(n).fill(0);\\n    \\n    function dfs1(node, parent) {\\n        for (let child of graph[node]) {\\n            if (child !== parent) {\\n                dfs1(child, node);\\n                count[node] += count[child];\\n                ans[node] += ans[child] + count[child];\\n            }\\n        }\\n    }\\n\\n    function dfs2(node, parent )  {\\n        for (let child of graph[node]) {\\n            if (child !== parent) {\\n                ans[child] = n - count[child] + ans[node] - count[child];\\n                dfs2(child, node);\\n            }\\n        }\\n    }\\n\\n    dfs1(0, -1);\\n    dfs2(0, -1);\\n    \\n    return ans;\\n};", "var sumOfDistancesInTree = function(n, edges) {\\n    let graph = new Array(n).fill().map(() => new Array());\\n\\n    for (let [s, t] of edges) {\\n        graph[s].push(t);\\n        graph[t].push(s);\\n    }\\n\\n    let count = new Array(n).fill(1);\\n    let ans = new Array(n).fill(0);\\n    \\n    function dfs1(node, parent) {\\n        for (let child of graph[node]) {\\n            if (child !== parent) {\\n                dfs1(child, node);\\n                count[node] += count[child];\\n                ans[node] += ans[child] + count[child];\\n            }\\n        }\\n    }\\n\\n    function dfs2(node, parent )  {\\n        for (let child of graph[node]) {\\n            if (child !== parent) {\\n                ans[child] = n - count[child] + ans[node] - count[child];\\n                dfs2(child, node);\\n            }\\n        }\\n    }\\n\\n    dfs1(0, -1);\\n    dfs2(0, -1);\\n    \\n    return ans;\\n};"]}
{"id": "1899", "ref_js": ["var numSimilarGroups = function(strs) {\\n    const n = strs.length, uf = new UnionFind(n);\\n\\n    ", "var numSimilarGroups = function(strs) {\\n    \\n    const group = graph(strs);\\n    const visited = new Set();\\n    let group_count = 0;\\n    \\n    for (const node in group) {\\n        if (!visited.has(node)) {\\n            bfs(visited, node, group);\\n            group_count+=1;\\n        }\\n    }\\n    \\n    return group_count;\\n};", "var numSimilarGroups = function(strs) {\\n    const n = strs.length, uf = new UnionFind(n);\\n\\n    "]}
{"id": "1900", "ref_js": ["var findSecretWord = function (words,master) {\\n    let result = \"\"\\n    const randomWord=words[ Math.floor(Math.random() * words.length)]\\n    const response = master.guess(randomWord)\\n    console.log(\\'response\\', response);\\n    if (response == 6) {\\n      \\n       return\\n    } else {\\n        const newWords = words.filter(item => isThereSimilerChars(item, randomWord, response))\\n       \\n        return findSecretWord(newWords,master)\\n\\n\\n    }\\n\\n};", "var findSecretWord = function (words,master) {\\n    const randomWord=words[ Math.floor(Math.random() * words.length)]\\n    const response = master.guess(randomWord)\\n    if (response == 6) {\\n       return\\n    } else {\\n        const newWords = words.filter(item => isThereSimilerChars(item, randomWord, response))\\n       \\n        return findSecretWord(newWords,master)\\n\\n\\n    }\\n\\n};", "var findSecretWord = function(wordlist, master) {\\n    for (let i = 0; i < 10; i++) {\\n        const randomIdx = getRandomIntInclusive(0, wordlist.length - 1);\\n        const guessWord = wordlist[randomIdx];\\n        const matches = master.guess(guessWord);\\n        const candidates = [];\\n        for (const word of wordlist) {\\n            if (matches === getMatchesBetween(guessWord, word)) {\\n                candidates.push(word);\\n            }\\n        }\\n        wordlist = candidates;\\n    }\\n};"]}
{"id": "1901", "ref_js": ["var shortestPathLength = function(graph) {\\n    const V = graph.length;\\n    const currLevel = [];\\n    \\n    ", "var shortestPathLength = function(graph) {\\n    const n = graph.length;\\n    const targetMask = (1 << n) - 1;\\n    \\n    const queue = [];\\n    const visited = new Set();\\n    \\n    for (let i = 0; i < n; i++) {\\n        queue.push([i, 1 << i, 0]);\\n        visited.add(`${i},${1 << i}`);\\n    }\\n    \\n    while (queue.length > 0) {\\n        const [node, state, distance] = queue.shift();\\n        \\n        if (state === targetMask) {\\n            return distance;\\n        }\\n        \\n        for (const neighbor of graph[node]) {\\n            const newState = state | (1 << neighbor);\\n            const key = `${neighbor},${newState}`;\\n            \\n            if (!visited.has(key)) {\\n                visited.add(key);\\n                queue.push([neighbor, newState, distance + 1]);\\n            }\\n        }\\n    }    \\n};", "var shortestPathLength = function(graph) {\\n    const V = graph.length;\\n    const currLevel = [];\\n    \\n    "]}
{"id": "1902", "ref_js": ["var rectangleArea = function(rectangles) {\\n  let events = [], active = [], area = 0n;\\n  let mod = BigInt(1000000007);\\n  for (var rec of rectangles) {\\n    events.push([rec[1], \\'open\\', rec[0], rec[2]]);\\n    events.push([rec[3], \\'close\\', rec[0], rec[2]]);\\n  }  \\n  events = events.sort((a, b) => a[0] - b[0]);\\n  let y = events[0][0];\\n  for (var event of events) {\\n    let currY = event[0], type = event[1], x1 = event[2], x2 = event[3];\\n    let maxLength = 0, curr = -1;\\n    for (var ev of active) {\\n      curr = Math.max(curr, ev[0]);\\n      maxLength += Math.max(0, ev[1] - curr);\\n      curr = Math.max(curr, ev[1]);\\n    }\\n    area += (BigInt(maxLength) * BigInt(currY - y));\\n    area %= mod;\\n    if (type === \\'open\\') {\\n      active.push([x1, x2]);\\n      active = active.sort((a, b) => a[0] - b[0]);\\n    } else {\\n      for (var i = 0; i < active.length; i++) {\\n        let e = active[i];\\n        if (e[0] === x1 && e[1] === x2) {\\n          active.splice(i, 1);\\n          break;\\n        }\\n      }\\n    }\\n    y = currY;\\n  }\\n  return area % mod;\\n};", "var rectangleArea = function(rectangles) {\\nlet eventList = [];\\nlet activeRectangles = [];\\nlet totalArea = 0n;\\nconst mod = BigInt(1000000007);\\n\\nfor (const rect of rectangles) {\\n  eventList.push([rect[1], \\'open\\', rect[0], rect[2]]);\\n  eventList.push([rect[3], \\'close\\', rect[0], rect[2]]);\\n}\\n\\neventList.sort((a, b) => a[0] - b[0]);\\n\\nlet previousY = eventList[0][0];\\n\\nfor (const event of eventList) {\\n  let currY = event[0];\\n  let type = event[1];\\n  let x1 = event[2];\\n  let x2 = event[3];\\n  \\n  let maxLength = 0;\\n  let currentRight = -1;\\n  for (const rect of activeRectangles) {\\n    currentRight = Math.max(currentRight, rect[0]);\\n    maxLength += Math.max(0, rect[1] - currentRight);\\n    currentRight = Math.max(currentRight, rect[1]);\\n  }\\n  \\n  totalArea += (BigInt(maxLength) * BigInt(currY - previousY)) % mod;\\n  totalArea %= mod;\\n\\n  if (type === \\'open\\') {\\n    activeRectangles.push([x1, x2]);\\n    activeRectangles.sort((a, b) => a[0] - b[0]);\\n  } else {\\n    for (let i = 0; i < activeRectangles.length; i++) {\\n      let rect = activeRectangles[i];\\n      if (rect[0] === x1 && rect[1] === x2) {\\n        activeRectangles.splice(i, 1);\\n        break;\\n      }\\n    }\\n  }\\n  \\n  previousY = currY;\\n}\\n\\nreturn totalArea;\\n};", "var rectangleArea = function(rectangles) {\\n\\n    "]}
{"id": "1903", "ref_js": ["var kSimilarity = function (s1, s2) {\\n  let n = s1.length;\\n  {\\n    let ss1 = \"\";\\n    let ss2 = \"\";\\n    for (let i = 0; i < n; i++)\\n      if (s1[i] != s2[i]) {\\n        ss1 += s1[i];\\n        ss2 += s2[i];\\n      }\\n    s1 = ss1;\\n    s2 = ss2;\\n  }\\n  n = s1.length;\\n  if (!n) return 0;\\n\\n  let maxState = 1 << n;\\n  cache.fill(0, 0, maxState);\\n\\n  function bt(cur, loop, mask) {\\n    if (!mask) return 0;\\n    if (cur == loop && cache[mask]) return cache[mask];\\n\\n    const newMask = bm.set0(mask, cur);\\n    let res = 0;\\n\\n    if (s1[cur] == s2[loop]) {\\n      if (newMask) {\\n        let next = loop + 1;\\n        while (!bm.get(newMask, next)) next++;\\n        res = bt(next, next, newMask);\\n        cache[newMask] = res;\\n        return res + 1;\\n      }\\n      else return 1;\\n    } else {\\n      for (let next = loop + 1; next < n; next++)\\n        if (bm.get(newMask, next) && s1[cur] == s2[next])\\n          res = Math.max(res, bt(next, loop, newMask));\\n      return res;\\n    }\\n  }\\n\\n  return n - bt(0, 0, maxState - 1);\\n};", "var kSimilarity = function (s1, s2) {\\n  let n = s1.length;\\n  {\\n    let ss1 = \"\";\\n    let ss2 = \"\";\\n    for (let i = 0; i < n; i++)\\n      if (s1[i] != s2[i]) {\\n        ss1 += s1[i];\\n        ss2 += s2[i];\\n      }\\n    s1 = ss1;\\n    s2 = ss2;\\n  }\\n  n = s1.length;\\n  if (!n) return 0;\\n\\n  let maxState = 1 << n;\\n  cache.fill(0, 0, maxState);\\n\\n  function bt(cur, loop, mask) {\\n    if (!mask) return 0;\\n    if (cur == loop && cache[mask]) return cache[mask];\\n\\n    const newMask = bm.set0(mask, cur);\\n    let res = 0;\\n\\n    if (s1[cur] == s2[loop]) {\\n      if (newMask) {\\n        let next = loop + 1;\\n        while (!bm.get(newMask, next)) next++;\\n        res = bt(next, next, newMask);\\n        cache[newMask] = res;\\n        return res + 1;\\n      }\\n      else return 1;\\n    } else {\\n      for (let next = loop + 1; next < n; next++)\\n        if (bm.get(newMask, next) && s1[cur] == s2[next])\\n          res = Math.max(res, bt(next, loop, newMask));\\n      return res;\\n    }\\n  }\\n\\n  return n - bt(0, 0, maxState - 1);\\n};", "var kSimilarity = function (s1, s2) {\\n  let n = s1.length;\\n  {\\n    let ss1 = \"\";\\n    let ss2 = \"\";\\n    for (let i = 0; i < n; i++)\\n      if (s1[i] != s2[i]) {\\n        ss1 += s1[i];\\n        ss2 += s2[i];\\n      }\\n    s1 = ss1;\\n    s2 = ss2;\\n  }\\n  n = s1.length;\\n  if (!n) return 0;\\n\\n  let maxState = 1 << n;\\n  cache.fill(0, 0, maxState);\\n\\n  function bt(cur, loop, mask) {\\n    if (!mask) return 0;\\n    if (cur == loop && cache[mask]) return cache[mask];\\n\\n    const newMask = bm.set0(mask, cur);\\n    let res = 0;\\n\\n    if (s1[cur] == s2[loop]) {\\n      if (newMask) {\\n        let next = loop + 1;\\n        while (!bm.get(newMask, next)) next++;\\n        res = bt(next, next, newMask);\\n        cache[newMask] = res;\\n        return res + 1;\\n      }\\n      else return 1;\\n    } else {\\n      for (let next = loop + 1; next < n; next++)\\n        if (bm.get(newMask, next) && s1[cur] == s2[next])\\n          res = Math.max(res, bt(next, loop, newMask));\\n      return res;\\n    }\\n  }\\n\\n  return n - bt(0, 0, maxState - 1);\\n};"]}
{"id": "1904", "ref_js": ["var mincostToHireWorkers = function (quality, wage, k) {\\n  const n = quality.length;\\n  const workers = new Array(n);\\n\\n  for (let i = 0; i < n; i++) {\\n    workers[i] = new Worker(quality[i], wage[i]);\\n  }\\n\\n  workers.sort((a, b) => a.ratio - b.ratio);\\n\\n  let minCost = Infinity;\\n  let qualitySum = 0;\\n  const maxHeap = new MaxHeap();\\n\\n  for (let i = 0; i < n; i++) {\\n    qualitySum += workers[i].quality;\\n    maxHeap.push(workers[i].quality);\\n\\n    if (maxHeap.size() > k) {\\n      qualitySum -= maxHeap.pop();\\n    }\\n\\n    if (maxHeap.size() === k) {\\n      minCost = Math.min(minCost, qualitySum * workers[i].ratio);\\n    }\\n  }\\n\\n  return minCost;\\n};", "var mincostToHireWorkers = function (quality, wage, k) {\\n  const n = quality.length;\\n  const workers = new Array(n);\\n\\n  for (let i = 0; i < n; i++) {\\n    workers[i] = new Worker(quality[i], wage[i]);\\n  }\\n\\n  workers.sort((a, b) => a.ratio - b.ratio);\\n\\n  let minCost = Infinity;\\n  let qualitySum = 0;\\n  const maxHeap = new MaxHeap();\\n\\n  for (let i = 0; i < n; i++) {\\n    qualitySum += workers[i].quality;\\n    maxHeap.push(workers[i].quality);\\n\\n    if (maxHeap.size() > k) {\\n      qualitySum -= maxHeap.pop();\\n    }\\n\\n    if (maxHeap.size() === k) {\\n      minCost = Math.min(minCost, qualitySum * workers[i].ratio);\\n    }\\n  }\\n\\n  return minCost;\\n};", "var mincostToHireWorkers = function (quality, wage, k) {\\n  const n = quality.length;\\n  const workers = new Array(n);\\n\\n  for (let i = 0; i < n; i++) {\\n    workers[i] = new Worker(quality[i], wage[i]);\\n  }\\n\\n  workers.sort((a, b) => a.ratio - b.ratio);\\n\\n  let minCost = Infinity;\\n  let qualitySum = 0;\\n  const maxHeap = new MaxHeap();\\n\\n  for (let i = 0; i < n; i++) {\\n    qualitySum += workers[i].quality;\\n    maxHeap.push(workers[i].quality);\\n\\n    if (maxHeap.size() > k) {\\n      qualitySum -= maxHeap.pop();\\n    }\\n\\n    if (maxHeap.size() === k) {\\n      minCost = Math.min(minCost, qualitySum * workers[i].ratio);\\n    }\\n  }\\n\\n  return minCost;\\n};"]}
{"id": "1905", "ref_js": ["var shortestSubarray = function(A, K) {\\n    let N = A.length, res = N + 1;\\n        let d = [];\\n        for (let i = 0; i < N; i++) {\\n            if (i > 0)\\n                A[i] += A[i - 1];\\n            if (A[i] >= K)\\n                res = Math.min(res, i + 1);\\n            while (d.length > 0 && A[i] - A[d[0]] >= K){\\n                res = Math.min(res, (i - d[0]))\\n                d.shift()\\n            }\\n            while (d.length > 0 && A[i] <= A[d[d.length-1]])\\n                d.pop();\\n            d.push(i);\\n        }\\n        return res <= N ? res : -1;\\n};", "var shortestSubarray = function (nums, k) {\\n    let n = nums.length;\\n\\n    let hasPositives = false;\\n    for (let j = 0; j < n; j++)\\n        if (nums[j] > 0) {\\n            hasPositives = true;\\n            break;\\n        }\\n    if (!hasPositives) return -1;\\n\\n    let min = 0;\\n\\n    const P = []; ", "var shortestSubarray = function (nums, k) {\\n    let n = nums.length;\\n\\n    let hasPositives = false;\\n    for (let j = 0; j < n; j++)\\n        if (nums[j] > 0) {\\n            hasPositives = true;\\n            break;\\n        }\\n    if (!hasPositives) return -1;\\n\\n    let min = 0;\\n\\n    const P = []; "]}
{"id": "1906", "ref_js": ["var shortestPathAllKeys = function(grid) {\\n    const m = grid.length, n = grid[0].length, lockSet = new Set(), keySet = new Set(), seen = {}, steps = [[0, 1], [1, 0], [0, - 1], [-1, 0]];\\n    let startRow = -1, startCol = -1, allKeys = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const val = grid[i][j];\\n            if (val === \\'@\\') [startRow, startCol] = [i, j];\\n            else if (\\'A\\' <= val && val <= \\'F\\') lockSet.add(val);\\n            else if (\\'a\\' <= val && val <= \\'f\\') {\\n                allKeys |= (1 << (val.charCodeAt(0) - \\'a\\'.charCodeAt(0)));\\n                keySet.add(val);\\n            };", "var shortestPathAllKeys = function(grid) {\\n    const m = grid.length, n = grid[0].length, lockSet = new Set(), keySet = new Set(), seen = {}, steps = [[0, 1], [1, 0], [0, - 1], [-1, 0]];\\n    let startRow = -1, startCol = -1, allKeys = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const val = grid[i][j];\\n            if (val === \\'@\\') [startRow, startCol] = [i, j];\\n            else if (\\'A\\' <= val && val <= \\'F\\') lockSet.add(val);\\n            else if (\\'a\\' <= val && val <= \\'f\\') {\\n                allKeys |= (1 << (val.charCodeAt(0) - \\'a\\'.charCodeAt(0)));\\n                keySet.add(val);\\n            };", "var shortestPathAllKeys = function(grid) {\\n    const m = grid.length, n = grid[0].length, lockSet = new Set(), keySet = new Set(), seen = {}, steps = [[0, 1], [1, 0], [0, - 1], [-1, 0]];\\n    let startRow = -1, startCol = -1, allKeys = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const val = grid[i][j];\\n            if (val === \\'@\\') [startRow, startCol] = [i, j];\\n            else if (\\'A\\' <= val && val <= \\'F\\') lockSet.add(val);\\n            else if (\\'a\\' <= val && val <= \\'f\\') {\\n                allKeys |= (1 << (val.charCodeAt(0) - \\'a\\'.charCodeAt(0)));\\n                keySet.add(val);\\n            };"]}
{"id": "1907", "ref_js": ["var minRefuelStops = function(target, startFuel, stations) {\\n    let dp = new Array(stations.length + 1).fill(0);\\n    dp[0] = startFuel;\\n    for (let i = 0; i < stations.length; i++) {\\n        for (let t = i; t >=0 && dp[t] >= stations[i][0]; t--) {\\n            dp[t + 1] = Math.max(dp[t + 1], dp[t] + stations[i][1])\\n        }\\n    }\\n    for (let i = 0; i <= stations.length; i++) {\\n        if (dp[i] >= target) return i;\\n    }\\n    \\n    return -1;\\n};", "var minRefuelStops = function(target, startFuel, stations) {\\n  let dp = new Array(stations.length+1).fill(0);\\n  dp[0] = startFuel;\\n  \\n  for (let i = 0; i < stations.length; i++)\\n    for (let j = i; j >= 0; j--)\\n      if (dp[j] >= stations[i][0])\\n        dp[j+1] = Math.max(dp[j+1], dp[j] + stations[i][1])\\n  \\n  for (let [index, value] of dp.entries()) \\n    if (value >= target) return index;\\n  return -1;\\n};", "var minRefuelStops = function(T, F, S) {\\n    let n = S.length, pq = new MaxPriorityQueue(), ans = 0\\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (!pq.size()) return -1\\n            F += pq.dequeue().element, ans++\\n        }\\n        if (i < n) pq.enqueue(S[i][1])\\n    }\\n    return ans\\n};"]}
{"id": "1908", "ref_js": ["var getLCMOfTwoNumbers = function (num1, num2) {\\n    let lar = Math.max(num1, num2);\\n    let small = Math.min(num1, num2);\\n    \\n    let i = lar;\\n    while(i % small !== 0){\\n      i += lar;\\n    }\\n    \\n    return i;\\n};", "var nthMagicalNumber = function (n, a, b) {\\n  let modby = BigInt(Math.pow(10, 9) + 7), bigA = BigInt(a), bigB = BigInt(b), bigN = BigInt(n)\\n  if (a === b) return (bigN * bigA) % modby\\n\\n  let minCommon = BigInt(findMinCommon(a, b))\\n\\n  let probly = binsearch(BigInt(0), bigN * (bigA > bigB ? bigB : bigA) + BigInt(1))\\n\\n  let aN = probly - probly % bigA, bN = probly - probly % bigB\\n  let rtn = aN > bN ? aN : bN\\n  return rtn % modby\\n\\n  function binsearch(l, r) {\\n    let mid = (l + r) / BigInt(2)\\n    let cnt = count(mid)\\n    if (cnt > bigN) {\\n      return binsearch(l, mid)\\n    } else if (cnt < bigN) {\\n      return binsearch(mid, r)\\n    } else {\\n      ", "var nthMagicalNumber = function (n, a, b) {\\n  let modby = BigInt(Math.pow(10, 9) + 7), bigA = BigInt(a), bigB = BigInt(b), bigN = BigInt(n)\\n  if (a === b) return (bigN * bigA) % modby\\n\\n  let minCommon = BigInt(findMinCommon(a, b))\\n\\n  let probly = binsearch(BigInt(0), bigN * (bigA > bigB ? bigB : bigA) + BigInt(1))\\n\\n  let aN = probly - probly % bigA, bN = probly - probly % bigB\\n  let rtn = aN > bN ? aN : bN\\n  return rtn % modby\\n\\n  function binsearch(l, r) {\\n    let mid = (l + r) / BigInt(2)\\n    let cnt = count(mid)\\n    if (cnt > bigN) {\\n      return binsearch(l, mid)\\n    } else if (cnt < bigN) {\\n      return binsearch(mid, r)\\n    } else {\\n      "]}
{"id": "1909", "ref_js": ["var profitableSchemes = function(n, minProfit, group, profit) {\\n    \\n    const gLen = group.length\\n    \\n    const dp = Array(gLen + 1).fill().map(() => {\\n       return Array(n+1).fill().map(() => Array(minProfit + 1).fill(0))\\n    })\\n    \\n    ", "var profitableSchemes = function(n, minProfit, group, profit) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr = arr.map(() => new Array(minProfit + 1).fill(0));\\n    const mod = 10 ** 9 + 7\\n    arr.forEach(c => c[0] = 1);\\n    group.forEach((item, key) => { \\n        for (let i = n; i >= item; i--) {\\n            for (let j = minProfit; j >= 0; j--) {\\n                arr[i][j] = (arr[i][j] + arr[i - item][Math.max(0, j - profit[key])]) % (mod)\\n            }\\n        }\\n    })\\n    return arr[n][minProfit];\\n};", "var profitableSchemes = function(n, minProfit, group, profit) {\\n    \\n    const gLen = group.length\\n    \\n    const dp = Array(gLen + 1).fill().map(() => {\\n       return Array(n+1).fill().map(() => Array(minProfit + 1).fill(0))\\n    })\\n    \\n    "]}
{"id": "1910", "ref_js": ["var reachableNodes = function(edges, maxMoves, n) {\\n    const g = Array.from({length: n}, () => []);\\n    \\n    for(let [u, v, cnt] of edges) {\\n        g[u].push([v, cnt + 1]);\\n        g[v].push([u, cnt + 1]);\\n    }\\n    \\n    ", "var reachableNodes = function(edges, maxMoves, n) {\\n    const g = Array.from({length: n}, () => []);\\n    \\n    for(let [u, v, cnt] of edges) {\\n        g[u].push([v, cnt + 1]);\\n        g[v].push([u, cnt + 1]);\\n    }\\n    \\n    ", "var reachableNodes = function(edges, maxMoves, n) {\\n    const g = Array.from({length: n}, () => []);\\n    \\n    for(let [u, v, cnt] of edges) {\\n        g[u].push([v, cnt + 1]);\\n        g[v].push([u, cnt + 1]);\\n    }\\n    \\n    "]}
{"id": "1911", "ref_js": ["var superEggDrop = function(k, n) {\\n    const dp = Array.from({length: n + 1}, () => new Array(k + 1).fill(0));\\n    ", "var superEggDrop = function(K, N) {\\n    const dp = Array.from({length: K+1}, () => Array.from(Array(N+1), (x, i) => i));\\n    dp[0] = Array(N+1).fill(0);\\n    \\n    for(let egg = 2; egg <= K; egg++) {\\n        for(let flr = 2; flr <= N; flr++) {\\n            let minDrops = Infinity, notBreak, eggBreak, worstCase;\\n            \\n            for(let i = 1; i <= flr; i++) {\\n                notBreak = dp[egg][flr-i];\\n                eggBreak = dp[egg-1][i-1];\\n                worstCase = Math.max(notBreak, eggBreak);\\n                minDrops = Math.min(minDrops, worstCase);\\n            }\\n            dp[egg][flr] = minDrops + 1;  \\n        }\\n    }\\n    return dp[K][N];\\n};", "var superEggDrop = function(K, N) {\\n    const dp = Array.from({length: K+1}, () => Array.from(Array(N+1), (x, i) => i));\\n    dp[0] = Array(N+1).fill(0);\\n    \\n    for(let egg = 2; egg <= K; egg++) {\\n        for(let flr = 2; flr <= N; flr++) {\\n            let minDrops = Infinity, notBreak, eggBreak, worstCase;\\n            \\n            for(let i = 1; i <= flr; i++) {\\n                notBreak = dp[egg][flr-i];\\n                eggBreak = dp[egg-1][i-1];\\n                worstCase = Math.max(notBreak, eggBreak);\\n                minDrops = Math.min(minDrops, worstCase);\\n            }\\n            dp[egg][flr] = minDrops + 1;  \\n        }\\n    }\\n    return dp[K][N];\\n};"]}
{"id": "1912", "ref_js": ["var sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};", "var sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};", "var sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};"]}
{"id": "1914", "ref_js": ["var orderlyQueue = function(s, k) {\\n \\tlet res = s;\\n\\n\\tif (k === 1) {\\n\\t\\tlet l = s.length;\\n\\t\\tfor (let i=0; i<l; i++) {\\n\\t\\t\\tlet c = s[0];\\n\\t\\t\\ts = s.substring(1, l) + c;\\n\\t\\t\\tif (s < res)\\n\\t\\t\\t\\tres = s; \\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\treturn [...s].sort().join(\\'\\');\\n   \\n};", "var orderlyQueue = function(s, k) {\\n    if (k > 1) {\\n        return s.split(\"\").sort().join(\"\");\\n    }\\n\\n    let res = s;\\n    for (let i = 1; i < s.length; i++) {\\n            const newStr = s.substr(i) + s.substr(0, i);\\n            if (newStr < res) {\\n            res = newStr;\\n        }\\n    }\\n    return res;\\n};", "var orderlyQueue = function(s, k) {\\n    if (k > 1) {\\n        return s.split(\"\").sort().join(\"\");\\n    }\\n\\n    let res = s;\\n    for (let i = 1; i < s.length; i++) {\\n            const newStr = s.substr(i) + s.substr(0, i);\\n            if (newStr < res) {\\n            res = newStr;\\n        }\\n    }\\n    return res;\\n};"]}
{"id": "1915", "ref_js": ["var atMostNGivenDigitSet = function(digits, n) {\\n    let count = 0;\\n    \\n    \\n    digits = digits.map(d => parseInt(d, 10));\\n    digits.sort((a, b) => a - b);\\n    \\n    const digitsLength = digits.length;\\n    const nDigits = (\\'\\' + n).split(\\'\\').map(d => parseInt(d, 10));\\n    \\n    \\n    for (let i = 1; i < nDigits.length; i++) {\\n        count += Math.pow(digitsLength, i);\\n    }\\n    \\n    \\n    const find = (pos, nDigits, digits) => {\\n        if (pos === nDigits.length) {\\n            return 1;\\n        }\\n        \\n        let count = 0;\\n        \\n        for (let i = 0; i < digits.length; i++) {\\n            if (digits[i] < nDigits[pos]) {\\n                count += Math.pow(digitsLength, nDigits.length - pos - 1);\\n            } else if (digits[i] == nDigits[pos]) {\\n                count += find(pos + 1, nDigits, digits);\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    count += find(0, nDigits, digits);\\n    \\n    return count;\\n};", "var atMostNGivenDigitSet = function(digits, n) {\\n    const nStr = String(n);\\n    const nLen = nStr.length;\\n    const digitsLen=digits.length;\\n    let count = 0;\\n    for (let len = 1; len < nLen; len++) {\\n        count += Math.pow(digitsLen,len);\\n    }\\n    for (let i = 0; i < nLen; i++) {\\n        const digit = nStr[i];\\n        const lessThanDigit = digits.filter(d => d < digit).length;\\n        count += lessThanDigit * Math.pow(digitsLen,nLen - i - 1);\\n        if (!digits.includes(digit)) {\\n            break;\\n        }\\n        if (i === nLen - 1) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};", "var atMostNGivenDigitSet = function (digits, n) {\\n  let result = 0;\\n  let nstr = String(n);\\n  for (let i = 1; i < nstr.length; ++i) {\\n    result += digits.length ** i;\\n  }\\n  if(Math.log10(n)%1===0 && n!==1) return result\\n  let sumArr = Array(nstr.length).fill(0);\\n  for (let i = nstr.length - 1; i > -1; --i) {\\n    digits.forEach((digit) => {\\n      if (parseInt(digit) < parseInt(nstr.charAt(i))) {\\n        sumArr[i] += digits.length ** (nstr.length - i - 1);\\n      } else if (parseInt(digit) === parseInt(nstr[i])) {\\n        if (i < nstr.length - 1) sumArr[i] += sumArr[i + 1];\\n        else sumArr[i] += 1;\\n      }\\n    });\\n  }\\n  return sumArr[0] + result;\\n};"]}
{"id": "1916", "ref_js": ["var numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};", "var numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};", "var numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};"]}
{"id": "1917", "ref_js": ["var superpalindromesInRange = function(left, right) {\\n    let ans = 9 >= left && 9 <= right ? 1 : 0\\n\\n    const isPal = str => {\\n        for (let i = 0, j = str.length - 1; i < j; i++, j--)\\n            if (str.charAt(i) !== str.charAt(j)) return false\\n        return true\\n    }\\n\\n    for (let dig = 1; dig < 10; dig++) {\\n        let isOdd = dig % 2 && dig !== 1,\\n            innerLen = (dig >> 1) - 1, innerLim = Math.max(1, 2 ** innerLen),\\n            midPos = dig >> 1, midLim = isOdd ? 3 : 1\\n        for (let edge = 1; edge < 3; edge++) {\\n            let pal = new Uint8Array(dig)\\n            pal[0] = edge, pal[dig-1] = edge\\n            if (edge === 2) innerLim = 1, midLim = Math.min(midLim, 2)\\n            for (let inner = 0; inner < innerLim; inner++) {\\n                if (inner > 0) {\\n                    let innerStr = inner.toString(2).padStart(innerLen, \\'0\\')\\n                    for (let i = 0; i < innerLen; i++)\\n                        pal[1+i] = innerStr[i], pal[dig-2-i] = innerStr[i]\\n                }\\n                for (let mid = 0; mid < midLim; mid++) {\\n                    if (isOdd) pal[midPos] = mid\\n                    let palin = ~~pal.join(\"\"),\\n                        square = BigInt(palin) * BigInt(palin)\\n                    if (square > right) return ans\\n                    if (square >= left && isPal(square.toString())) ans++\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n};", "var superpalindromesInRange = function(left, right) {\\n    function isPalindrome(number) {\\n        const str = number.toString();\\n        let palindrome = true;\\n        const len = str.length;\\n        for (let x = 0; x < Math.floor(len / 2); x ++) {\\n            if (str[x] != str[len - x - 1]) {\\n                palindrome = false;\\n                break;\\n            }\\n        }\\n        return palindrome;\\n    }\\n    ", "var superpalindromesInRange = function(left, right) {\\n    let ans = 9 >= left && 9 <= right ? 1 : 0\\n\\n    const isPal = str => {\\n        for (let i = 0, j = str.length - 1; i < j; i++, j--)\\n            if (str.charAt(i) !== str.charAt(j)) return false\\n        return true\\n    }\\n\\n    for (let dig = 1; dig < 10; dig++) {\\n        let isOdd = dig % 2 && dig !== 1,\\n            innerLen = (dig >> 1) - 1, innerLim = Math.max(1, 2 ** innerLen),\\n            midPos = dig >> 1, midLim = isOdd ? 3 : 1\\n        for (let edge = 1; edge < 3; edge++) {\\n            let pal = new Uint8Array(dig)\\n            pal[0] = edge, pal[dig-1] = edge\\n            if (edge === 2) innerLim = 1, midLim = Math.min(midLim, 2)\\n            for (let inner = 0; inner < innerLim; inner++) {\\n                if (inner > 0) {\\n                    let innerStr = inner.toString(2).padStart(innerLen, \\'0\\')\\n                    for (let i = 0; i < innerLen; i++)\\n                        pal[1+i] = innerStr[i], pal[dig-2-i] = innerStr[i]\\n                }\\n                for (let mid = 0; mid < midLim; mid++) {\\n                    if (isOdd) pal[midPos] = mid\\n                    let palin = ~~pal.join(\"\"),\\n                        square = BigInt(palin) * BigInt(palin)\\n                    if (square > right) return ans\\n                    if (square >= left && isPal(square.toString())) ans++\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n};"]}
{"id": "1918", "ref_js": ["var catMouseGame = function (graph) {\\n  let n = graph.length;\\n  winners.fill(0);\\n\\n  for (let i = 0; i < n; ++i) {\\n    for (let j = 0; j < n; ++j) {\\n      buffers[encode(i, j, 1)] = graph[j].length;\\n      buffers[encode(i, j, 0)] = graph[i].length;\\n    }\\n  }\\n  for (let v of graph[0]) {\\n    for (let i = 0; i < n; ++i) {\\n      --buffers[encode(i, v, 1)];\\n    }\\n  }\\n\\n  q.clear();\\n  for (let i = 1; i < n; ++i) {\\n    let code = encode(i, i, 0);\\n    winners[code] = 2;\\n    q.enqueue(code);\\n\\n    code = encode(i, i, 1);\\n    winners[code] = 2;\\n    q.enqueue(code);\\n\\n    code = encode(0, i, 0);\\n    winners[code] = 1;\\n    q.enqueue(code);\\n\\n    code = encode(0, i, 1);\\n    winners[code] = 1;\\n    q.enqueue(code);\\n  }\\n\\n  while (q.size) {\\n    let code = q.dequeue();\\n    let turn = code & 1;\\n    let cat = (code % 100) >> 1;\\n    let mouse = Math.floor(code / 100);\\n    let winner = winners[code];\\n\\n    if (turn) {\\n      let adj = graph[mouse];\\n\\n      for (let next of adj) {\\n        if (!next) continue;\\n        let nextCode = encode(next, cat, 0);\\n        if (winners[nextCode]) continue;\\n\\n        if (winner == 1) {\\n          winners[nextCode] = 1\\n          q.enqueue(nextCode);\\n        }\\n        else {\\n          if (!--buffers[nextCode]) {\\n            winners[nextCode] = 2;\\n            q.enqueue(nextCode); \\n          }\\n        }\\n      }\\n    } else {\\n      let adj = graph[cat];\\n\\n      for (let next of adj) {\\n        if (!next) continue;\\n        let nextCode = encode(mouse, next, 1);\\n        if (winners[nextCode]) continue;\\n\\n        if (winner == 2) {\\n          winners[nextCode] = 2\\n          q.enqueue(nextCode);\\n        }\\n        else {\\n          if (!--buffers[nextCode]) {\\n            winners[nextCode] = 1;\\n            q.enqueue(nextCode); \\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return winners[104];\\n};", "var catMouseGame = function (graph) {\\n\\tconst n = graph.length;\\n\\t", "var catMouseGame = function(graph) {\\n    let n=graph.length,\\n        memo=[...Array(n+1)].map(d=>[...Array(n+1)].map(d=>[...Array(2*n+1)])),\\n        seen=[...Array(n+1)].map(d=>[...Array(n+1)].map(d=>[...Array(2)]))\\n    "]}
{"id": "1919", "ref_js": ["var numMusicPlaylists = function(n, goal, k) {\\n    const MOD = 1e9 + 7;\\n    let dp = Array.from({length: 2}, () => new Array(n + 1).fill(0));\\n    dp[0][0] = 1;\\n\\n    for (let i = 1; i <= goal; i++) {\\n        dp[i%2][0] = 0;\\n        for (let j = 1; j <= Math.min(i, n); j++) {\\n            dp[i%2][j] = dp[(i - 1)%2][j - 1] * (n - (j - 1)) % MOD;\\n            if (j > k)\\n                dp[i%2][j] = (dp[i%2][j] + dp[(i - 1)%2][j] * (j - k)) % MOD;\\n        }\\n    }\\n\\n    return dp[goal%2][n];\\n};", "var numMusicPlaylists = function(n, goal, k) {\\n    const MOD = 10**9 + 7;\\n\\n    const dp = new Array(goal + 1).fill(0).map(() => new Array(n + 1).fill(0));\\n    dp[0][0] = 1;\\n\\n    for (let i = 1; i <= goal; i++) {\\n        for (let j = 1; j <= Math.min(i, n); j++) {\\n            dp[i][j] = dp[i - 1][j - 1] * (n - j + 1) % MOD;\\n\\n            if (j > k) {\\n                dp[i][j] = (dp[i][j] + dp[i - 1][j] * (j - k)) % MOD;\\n            }\\n        }\\n    }\\n\\n    return dp[goal][n];    \\n};", "var numMusicPlaylists = function(n, goal, k) {\\n    const MOD = 10**9 + 7\\n    const dp = Array(n + 1).fill(0).map(() => Array(goal + 1).fill(0))\\n    dp[0][0] = 1\\n\\n    for (let i = 1; i <= n; i++){\\n        for (let j = 1; j <= goal; j++){\\n            dp[i][j] = (dp[i-1][j-1] * (n - i + 1) + dp[i][j - 1] * Math.max(i - k, 0)) % MOD\\n        }\\n    }\\n\\n    return dp[n][goal]\\n};"]}
{"id": "1920", "ref_js": ["var minMalwareSpread = function (graph, initial) {\\n  let m = initial.length;\\n  let n = graph.length;\\n  if (m == 1) return initial[0];\\n  visited.fill(-1, 0, n);\\n  infection.fill(0, 0, m);\\n  initial.sort((a, b) => a - b);\\n\\n  function bfs(srcIndex) {\\n    let src = initial[srcIndex];\\n\\n    if (visited[src] >= 0) {\\n      infection[visited[src]] = 0;\\n      return;\\n    }\\n\\n    q.clear();\\n    q.enqueue(src);\\n    visited[src] = srcIndex;\\n\\n    while (q.size) {\\n      let u = q.dequeue();\\n      infection[srcIndex]++;\\n\\n      for (let v = 0; v < n; v++)\\n        if (graph[u][v] && visited[v] < 0) {\\n          q.enqueue(v);\\n          visited[v] = srcIndex;\\n        }\\n    }\\n  }\\n\\n  let resNode = initial[0];\\n  let maxInfection = 0;\\n\\n  for (let i = 0; i < m; i++) bfs(i);\\n  for (let i = 0; i < m; i++)\\n    if (infection[i] > maxInfection) {\\n      maxInfection = infection[i];\\n      resNode = initial[i];\\n    }\\n\\n  return resNode;\\n};", "var minMalwareSpread = function(graph, initial) {\\n  let n = graph.length, uf = new UnionFind(n);\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i + 1; j < n; j++) {\\n      if (graph[i][j]) uf.union(i, j);\\n    }\\n  }\\n  \\n  ", "var minMalwareSpread = function(graph, initial) {\\n    const length = graph.length; \\n    const parent = [];\\n    const children = {};"]}
{"id": "1921", "ref_js": ["var threeEqualParts = function(arr) {\\n  const ones = arr.reduce((s, n) => s + n, 0);\\n  if (ones === 0) return [0, 2];\\n  if (ones % 3 !== 0) return [-1, -1];\\n  let onesToFind = ones / 3;\\n  let k = arr.length;\\n  while (onesToFind > 0) if (arr[--k] === 1) --onesToFind;\\n  const iter = arr.length - k;\\n  const firstOne = arr.indexOf(1);\\n  const secondOne = arr.indexOf(1, firstOne + iter);\\n  for (let i = 0; i < iter; i++)\\n    if (arr[i + firstOne] !== arr[k + i] || arr[i + secondOne] !== arr[k + i]) return [-1, -1];\\n  return [firstOne + iter - 1, secondOne + iter];\\n};", "var threeEqualParts = function(A) {\\n    const getOneCount = () => {\\n        const oneCount = A.reduce((acc, bit) => bit == 1 ? acc + 1 : acc, 0)\\n        if(oneCount % 3 == 0) \\n            return oneCount / 3\\n        return -1\\n    }\\n\\n    const getTail = oneCount => { \\n        let zeroCount = 0, idx = A.length -1\\n        let oneRemain = oneCount\\n        while(oneRemain > 0) {\\n            if(A[idx] == 1) {\\n                oneRemain--\\n            }\\n            if(A[idx] == 0 && oneRemain == oneCount) {\\n                zeroCount++\\n            }\\n            idx--\\n        }\\n        return {zeroCount, tailStart: idx + 1}\\n    }\\n\\n    const getHead = (oneCount, zeroCount) => {\\n        let idx = 0\\n        while(oneCount > 0) {\\n            if(A[idx] == 1)\\n                oneCount--\\n            idx++\\n        }\\n        if(zeroCount > 0) {\\n            while(A[idx] == 0 && zeroCount > 0){\\n                idx++\\n                zeroCount--\\n            }\\n        }\\n        return zeroCount == 0 ? idx-1 : -1\\n    }\\n\\n    const getMiddle = (oneCount, headEnd, tailStart) => {\\n        let idx = headEnd + 1\\n        let tailIdx = tailStart\\n        while(A[idx] != 1) idx++\\n        while(idx < tailStart && A[idx] == A[tailIdx]) {\\n            idx++\\n            tailIdx++\\n        }\\n        if(tailIdx != A.length)\\n            return -1\\n        return idx\\n\\n    }\\n\\n    const oneCount = getOneCount()\\n    if(oneCount == -1 || A.length < 3)\\n        return [-1, -1]\\n    if(oneCount == 0) return [0, A.length-1]\\n    const {tailStart, zeroCount} = getTail(oneCount)\\n    const headEnd = getHead(oneCount, zeroCount)\\n    if(headEnd == -1)\\n        return [-1, -1]\\n    const middleEnd = getMiddle(oneCount, headEnd, tailStart)\\n    if(middleEnd == -1)\\n        return [-1, -1]\\n    return [headEnd, middleEnd]\\n};", "var threeEqualParts = function(arr) {\\n  const ones = arr.reduce((s, n) => s + n, 0);\\n  if (ones === 0) return [0, 2];\\n  if (ones % 3 !== 0) return [-1, -1];\\n  let onesToFind = ones / 3;\\n  let k = arr.length;\\n  while (onesToFind > 0) if (arr[--k] === 1) --onesToFind;\\n  const iter = arr.length - k;\\n  const firstOne = arr.indexOf(1);\\n  const secondOne = arr.indexOf(1, firstOne + iter);\\n  for (let i = 0; i < iter; i++)\\n    if (arr[i + firstOne] !== arr[k + i] || arr[i + secondOne] !== arr[k + i]) return [-1, -1];\\n  return [firstOne + iter - 1, secondOne + iter];\\n};"]}
{"id": "1922", "ref_js": ["var minMalwareSpread = function(graph, initial) {\\n\\nfunction main() {\\n      const nodeStates = new Array(graph.length).fill(null);\\n\\n      for (const node of initial) {\\n            nodeStates[node] = -1;\\n      }\\n\\n      function scan(initialNode) {\\n            nodeStates[initialNode] = null;\\n            function DFS(node) {\\n                  if (nodeStates[node] === initialNode || nodeStates[node] < 0) return;\\n\\n                  if (nodeStates[node] === null && node !== initialNode) {\\n                        nodeStates[node] = initialNode;\\n                        nodeStates[initialNode]--;\\n                  } else {\\n                        if (nodeStates[node] !== null) {\\n                              nodeStates[nodeStates[node]]++;\\n                        }\\n                        nodeStates[node] = -1;\\n                  }\\n\\n                  const edges = graph[node];\\n\\n                  for (let i = 0; i < edges.length; i++) {\\n                        if (!!edges[i]) {\\n                              DFS(i);\\n                        }\\n                  }\\n            }\\n            return DFS(initialNode);\\n      }\\n\\n      for (const node of initial) scan(node);\\n\\n      let maxNode = initial[0];\\n\\n      for (let n = 0, i = initial[n]; n < initial.length; i = initial[++n]) {\\n            if (nodeStates[i] < nodeStates[maxNode] || (nodeStates[i] === nodeStates[maxNode] && i < maxNode)) {\\n                  maxNode = i;\\n            }\\n      }\\n\\n      return maxNode;\\n}\\nreturn main()\\n\\n};", "var minMalwareSpread = function(graph, initial) {\\nlet n = graph.length\\nlet AdjList = new Map();\\nlet listFromGraph = (mat) => {", "var minMalwareSpread = function(graph, initial) {\\n\\nfunction main() {\\n      const nodeStates = new Array(graph.length).fill(null);\\n\\n      for (const node of initial) {\\n            nodeStates[node] = -1;\\n      }\\n\\n      function scan(initialNode) {\\n            nodeStates[initialNode] = null;\\n            function DFS(node) {\\n                  if (nodeStates[node] === initialNode || nodeStates[node] < 0) return;\\n\\n                  if (nodeStates[node] === null && node !== initialNode) {\\n                        nodeStates[node] = initialNode;\\n                        nodeStates[initialNode]--;\\n                  } else {\\n                        if (nodeStates[node] !== null) {\\n                              nodeStates[nodeStates[node]]++;\\n                        }\\n                        nodeStates[node] = -1;\\n                  }\\n\\n                  const edges = graph[node];\\n\\n                  for (let i = 0; i < edges.length; i++) {\\n                        if (!!edges[i]) {\\n                              DFS(i);\\n                        }\\n                  }\\n            }\\n            return DFS(initialNode);\\n      }\\n\\n      for (const node of initial) scan(node);\\n\\n      let maxNode = initial[0];\\n\\n      for (let n = 0, i = initial[n]; n < initial.length; i = initial[++n]) {\\n            if (nodeStates[i] < nodeStates[maxNode] || (nodeStates[i] === nodeStates[maxNode] && i < maxNode)) {\\n                  maxNode = i;\\n            }\\n      }\\n\\n      return maxNode;\\n}\\nreturn main()\\n\\n};"]}
{"id": "1923", "ref_js": ["var movesToStamp = function(S, T) {\\n    if (S === T) return [0]\\n    let slen = S.length, tlen = T.length - slen + 1,\\n        ans = [], tdiff = true, sdiff, i, j\\n    S = S.split(\"\"), T = T.split(\"\")\\n    while (tdiff)\\n        for (i = 0, tdiff = false; i < tlen; i++) {\\n            for (j = 0, sdiff = false; j < slen; j++)\\n                if (T[i+j] === \"*\") continue\\n                else if (T[i+j] !== S[j]) break\\n                else sdiff = true\\n            if (j === slen && sdiff) {\\n                for (j = i, tdiff = true; j < slen + i; j++)\\n                    T[j] = \"*\"\\n                ans.unshift(i)\\n            }\\n        }\\n    for (i = 0; i < T.length; i++) if (T[i] !== \"*\") return []\\n    return ans\\n};", "var movesToStamp = function(stamp, target) {\\n    let res = [];\\n    let total_stamp = 0, turn_stamp = -1;\\n    while (turn_stamp) {\\n      turn_stamp = 0;\\n      for (let sz = stamp.length; sz > 0; --sz) \\n          for (let i = 0; i <= stamp.length - sz; ++i) {\\n              let new_stamp = \\'*\\'.repeat(i) + stamp.slice(i, sz + i) + \\'*\\'.repeat(stamp.length - sz - i); ", "var movesToStamp = function(stamp, target) {\\n\\t\\t"]}
{"id": "1924", "ref_js": ["var distinctSubseqII = function(s) {\\n    let result = 0\\n    const mod = 10 ** 9 + 7\\n    const dp = new Array(s.length + 1).fill(0)\\n    dp[0] = 1\\n    const last = new Array(26).fill(-1)\\n    for (let i = 0; i < s.length; i++) {\\n        const x = s.charCodeAt(i) - 97\\n        dp[i + 1] = (dp[i] * 2) % mod\\n        if (last[x] >= 0) {\\n            dp[i + 1] -= dp[last[x]]\\n        }\\n        dp[i + 1] %= mod\\n        last[x] = i\\n    }\\n    result = (dp[s.length] - 1 + mod) % mod\\n    return result\\n};", "var distinctSubseqII = function(s) {\\n    let result = 0\\n    const mod = 10 ** 9 + 7\\n    const dp = new Array(s.length + 1).fill(0)\\n    dp[0] = 1\\n    const last = new Array(26).fill(-1)\\n    for (let i = 0; i < s.length; i++) {\\n        const x = s.charCodeAt(i) - 97\\n        dp[i + 1] = (dp[i] * 2) % mod\\n        if (last[x] >= 0) {\\n            dp[i + 1] -= dp[last[x]]\\n        }\\n        dp[i + 1] %= mod\\n        last[x] = i\\n    }\\n    result = (dp[s.length] - 1 + mod) % mod\\n    return result\\n};", "var distinctSubseqII = function(s) {\\n    let result = 0\\n    const mod = 10 ** 9 + 7\\n    const dp = new Array(s.length + 1).fill(0)\\n    dp[0] = 1\\n    const last = new Array(26).fill(-1)\\n    for (let i = 0; i < s.length; i++) {\\n        const x = s.charCodeAt(i) - 97\\n        dp[i + 1] = (dp[i] * 2) % mod\\n        if (last[x] >= 0) {\\n            dp[i + 1] -= dp[last[x]]\\n        }\\n        dp[i + 1] %= mod\\n        last[x] = i\\n    }\\n    result = (dp[s.length] - 1 + mod) % mod\\n    return result\\n};"]}
{"id": "1925", "ref_js": ["var shortestSuperstring = function(words) {\\n    let N = words.length, suffixes = new Map(),\\n        edges = Array.from({length: N}, () => new Uint8Array(N))\\n    \\n    ", "var shortestSuperstring = function(words) {\\n    let N = words.length, suffixes = new Map(),\\n        edges = Array.from({length: N}, () => new Uint8Array(N))\\n    \\n    ", "var shortestSuperstring = function(words) {\\n    let N = words.length, suffixes = new Map(),\\n        edges = Array.from({length: N}, () => new Uint8Array(N))\\n    \\n    "]}
{"id": "1926", "ref_js": ["var largestComponentSize = function(A) {\\n  const n = A.length;\\n  let parent = new Array(n).fill().map((_,i)=>i);\\n  let cnt = new Array(n).fill(1);\\n  let find  = (i) => parent[i] == i? i : find(parent[i]);\\n  let union = (i, j) => {\\n    let p = find(i);\\n    let q = find(j);\\n    \\n    if(p === q) return;\\n    \\n    if(cnt[p]<cnt[q]) {\\n      [p,q] = [q,p];\\n    }\\n    cnt[p] += cnt[q];\\n    parent[q] = p;\\n  }\\n  \\n  const m = Math.max(...A);\\n  let p = new Array(m+1).fill(true);\\n  const root = Math.floor(Math.sqrt(m));\\n  for(let i=2;i<=root;i++) if(p[i]) {\\n    let k = -1;\\n    for(let j=0;j<n;++j) {\\n      if(A[j]%i===0) {\\n        while(A[j] % i === 0)\\n          A[j] = Math.floor(A[j]/i);\\n        if(k===-1) k = j;\\n        else union(k, j);\\n      }\\n    } \\n    for(let j=i*i;j<=m;j+=i) p[j] = false;\\n  }\\n  \\n  A = A.map((x,i)=>[x,i]).filter(x=>x[0]>1).sort((a,b)=>a[0]-b[0]);\\n  for(let i=1;i<A.length;++i) {\\n    if(A[i-1][0]===A[i][0]) {\\n      union(A[i-1][1], A[i][1]);\\n    }\\n  }\\n  \\n  return Math.max(...cnt);\\n};", "var largestComponentSize = function(nums) {\\n  const rootByFactor = new Map();\\n  const parents = new Array(nums.length);\\n  \\n  function addFactor(i, factor) {\\n    if (rootByFactor.has(factor)) {\\n      let r = rootByFactor.get(factor);\\n      while (parents[i] != i) i = parents[i];\\n      while (parents[r] != r) r = parents[r];\\n      parents[i] = r;\\n    }\\n    rootByFactor.set(factor, parents[i]);\\n  }\\n  \\n  for (const [i, num] of nums.entries()) {\\n    parents[i] = i;\\n    addFactor(i, num);\\n    for (let factor = 2; factor * factor <= num; ++factor) {\\n      if (num % factor == 0) {\\n        addFactor(i, factor);\\n        addFactor(i, num / factor);\\n      }\\n    }\\n  }\\n  \\n  let largest = 0;\\n  const sums = new Array(nums.length).fill(0);\\n  for (let r of parents) {\\n    while (parents[r] != r) r = parents[r];\\n    largest = Math.max(largest, ++sums[r]);\\n  }\\n  return largest;\\n};", "var largestComponentSize = function(nums) {\\n  const rootByFactor = new Map();\\n  const parents = new Array(nums.length);\\n  \\n  function addFactor(i, factor) {\\n    if (rootByFactor.has(factor)) {\\n      let r = rootByFactor.get(factor);\\n      while (parents[i] != i) i = parents[i];\\n      while (parents[r] != r) r = parents[r];\\n      parents[i] = r;\\n    }\\n    rootByFactor.set(factor, parents[i]);\\n  }\\n  \\n  for (const [i, num] of nums.entries()) {\\n    parents[i] = i;\\n    addFactor(i, num);\\n    for (let factor = 2; factor * factor <= num; ++factor) {\\n      if (num % factor == 0) {\\n        addFactor(i, factor);\\n        addFactor(i, num / factor);\\n      }\\n    }\\n  }\\n  \\n  let largest = 0;\\n  const sums = new Array(nums.length).fill(0);\\n  for (let r of parents) {\\n    while (parents[r] != r) r = parents[r];\\n    largest = Math.max(largest, ++sums[r]);\\n  }\\n  return largest;\\n};"]}
{"id": "1927", "ref_js": ["var tallestBillboard = function(rods) {\\n  const n = rods.length;\\n  const sum = rods.reduce((acum, cur) => acum + cur, 0);\\n  let dp = Array(n + 1).fill(0).map(() => Array(10000 + 1).fill(-1));\\n  let ans = sol(0, 0 ,rods, dp);\\n  return ans;\\n};", "var tallestBillboard = function(rods) {\\n    let dp = {0:0}\\n\\n    for(let rod of rods){\\n        let currentDP = {...dp}\\n        for(let height in currentDP){\\n            height = parseInt(height)\\n            dp[height + rod] = Math.max(dp[height + rod] || 0, currentDP[height])\\n            dp[Math.abs(height-rod)] = Math.max(dp[Math.abs(height-rod)] || 0, currentDP[height] + Math.min(height,rod))\\n        }\\n    }\\n    return dp[0] || 0\\n};", "var tallestBillboard = function(rods) {\\n    \\n    "]}
{"id": "1928", "ref_js": ["var minDeletionSize = function(strs) {\\n    if (strs.length === 0) return 0\\n    let dp = new Array(strs[0].length).fill(1)\\n    for (let i = 1; i < strs[0].length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            let flag = true\\n            for (let k = 0; k < strs.length; k++) {\\n                if (strs[k][j] > strs[k][i]) {\\n                    flag = false\\n                    break\\n                }\\n            }\\n            if (flag) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1)\\n            }\\n        }\\n    }\\n    return strs[0].length - Math.max(...dp)\\n};", "var minDeletionSize = function(strs) {\\n  let m = strs.length;\\n  let n = strs[0].length;\\n\\n  dp.fill(1, 0, n);\\n  let res = 1;\\n\\n  for (let r = 1; r < n; r++) {\\n    for (let l = r - 1; l >= 0; l--) {\\n      let t = dp[l] + 1;\\n      if (t <= dp[r]) continue;\\n\\n      for (let i = 0; i < m; i++) {\\n        if (strs[i].charCodeAt(l) > strs[i].charCodeAt(r)) {\\n          t = 0;\\n          break;\\n        }\\n      }\\n      if (t) dp[r] = t;\\n      res = Math.max(dp[r], res);\\n    }\\n  }\\n\\n  return n - res;\\n};", "var minDeletionSize = function(strs) {\\n    if (strs.length === 0) return 0\\n    let dp = new Array(strs[0].length).fill(1)\\n    for (let i = 1; i < strs[0].length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            let flag = true\\n            for (let k = 0; k < strs.length; k++) {\\n                if (strs[k][j] > strs[k][i]) {\\n                    flag = false\\n                    break\\n                }\\n            }\\n            if (flag) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1)\\n            }\\n        }\\n    }\\n    return strs[0].length - Math.max(...dp)\\n};"]}
{"id": "1929", "ref_js": ["var leastOpsExpressTarget = function (x, target) {\\n  dp.clear();\\n  dp.set(x, 0);\\n  let p = 0;\\n  let s = x;\\n\\n  do {\\n    p++;\\n    s *= x;\\n    dp.set(s, p);\\n  } while (s < target);\\n\\n  return getDp(x, target);\\n};", "var leastOpsExpressTarget = function (x, target) {\\n  dp.clear();\\n  dp.set(x, 0);\\n  let p = 0;\\n  let s = x;\\n\\n  do {\\n    p++;\\n    s *= x;\\n    dp.set(s, p);\\n  } while (s < target);\\n\\n  return getDp(x, target);\\n};", "var leastOpsExpressTarget = function (x, target) {\\n  dp.clear();\\n  dp.set(x, 0);\\n  let p = 0;\\n  let s = x;\\n\\n  do {\\n    p++;\\n    s *= x;\\n    dp.set(s, p);\\n  } while (s < target);\\n\\n  return getDp(x, target);\\n};"]}
{"id": "1930", "ref_js": ["var minCameraCover = function(root) {\\n    let ans = 0\\n    const dfs = node => {\\n        if (!node) return 0\\n        let val = dfs(node.left) + dfs(node.right)\\n        if (val === 0) return 3\\n        if (val < 3) return 0\\n        ans++\\n        return 1\\n    }\\n    return dfs(root) > 2 ? ans + 1 : ans    \\n};", "var minCameraCover = function(root) {\\n    let camera = 0;\\n    const postOrder = (root) => {\\n        if (!root)\\n            return 1;\\n        const left = postOrder(root.left);\\n        const right = postOrder(root.right);\\n        if (left === -1 || right === -1){\\n            camera++;\\n            return 0;\\n        } else if (left === 0 || right === 0){\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    const out = postOrder(root);\\n    return out === -1 ? camera + 1 : camera;\\n};", "var minCameraCover = function(root) {\\n    var result = 0;\\n    \\n    var travel = function(node) {\\n        if(!node) {\\n            return 2; \\n            "]}
{"id": "1931", "ref_js": ["var isRationalEqual = function(s, t) {\\n    var tint, sint;\\n    var tparts, sparts;\\n    \\n    sparts = s.split(\".\");\\n    sint = sparts[0];\\n    \\n    tparts = t.split(\".\");\\n    tint = tparts[0];\\n    \\n    let snonrep=\"\", tnonrep=\"\", srep=\"\", trep=\"\";\\n    \\n    if( sparts.length > 1 )\\n        [snonrep,srep] = splitrep(sparts[1]);\\n    \\n    if( tparts.length > 1 )\\n        [tnonrep,trep] = splitrep(tparts[1]);\\n    \\n    if( srep.length == 0 || trep.length == 0 ) \\n    \\n    var slen = snonrep.length + srep.length + srep.length;\\n    var tlen = tnonrep.length + trep.length + trep.length;\\n    \\n    var nlen = ((slen>tlen)?slen:tlen)*2;\\n    \\n    var q,p;\\n    \\n    if( srep.length == 0 )\\n        q = snonrep + \"000\";\\n    else\\n        q = buildto(snonrep, srep, nlen);\\n    \\n    if( trep.length == 0 )\\n        p = tnonrep + \"000\";\\n    else\\n        p = buildto(tnonrep, trep, nlen);\\n\\n    let sn = parseFloat(sint + \".\" + q);\\n    let tn = parseFloat(tint + \".\" + p);\\n    \\n    if( sn == tn ) return true;\\n    \\n    var i;\\n    s = \".\";\\n    t = \".\";\\n    for( i=1; i<nlen; i++ ) {\\n        s += \"0\";\\n        t += \"00\";\\n    }\\n    s += \"1\";\\n    t += \"1\";\\n    \\n    if( sn < tn ) {\\n        if( sn+parseFloat(s)+parseFloat(t) >= tn ) return true;\\n    } else if( sn == tn ) {\\n        return true;\\n    } else {\\n        if( tn+parseFloat(s)+parseFloat(t) >= sn ) return true;\\n    }\\n    \\n    return false;\\n};", "var isRationalEqual = function(s, t) {\\n    return calculate(s) === calculate(t);\\n\\n    function calculate(v) {\\n        let start = v.split(\\'(\\')[0] || v;\\n        let newer = v.split(\\'(\\')[1] && v.split(\\'(\\')[1].split(\\')\\')[0] || \\'0\\';\\n\\n        start = start.includes(\\'.\\') ? start : start + \\'.\\';\\n        newer = newer.padEnd(100, newer);\\n\\n        return parseFloat(start + newer);\\n    }\\n};", "var isRationalEqual = function(s, t) {\\n    var tint, sint;\\n    var tparts, sparts;\\n    \\n    sparts = s.split(\".\");\\n    sint = sparts[0];\\n    \\n    tparts = t.split(\".\");\\n    tint = tparts[0];\\n    \\n    let snonrep=\"\", tnonrep=\"\", srep=\"\", trep=\"\";\\n    \\n    if( sparts.length > 1 )\\n        [snonrep,srep] = splitrep(sparts[1]);\\n    \\n    if( tparts.length > 1 )\\n        [tnonrep,trep] = splitrep(tparts[1]);\\n    \\n    if( srep.length == 0 || trep.length == 0 ) \\n    \\n    var slen = snonrep.length + srep.length + srep.length;\\n    var tlen = tnonrep.length + trep.length + trep.length;\\n    \\n    var nlen = ((slen>tlen)?slen:tlen)*2;\\n    \\n    var q,p;\\n    \\n    if( srep.length == 0 )\\n        q = snonrep + \"000\";\\n    else\\n        q = buildto(snonrep, srep, nlen);\\n    \\n    if( trep.length == 0 )\\n        p = tnonrep + \"000\";\\n    else\\n        p = buildto(tnonrep, trep, nlen);\\n\\n    let sn = parseFloat(sint + \".\" + q);\\n    let tn = parseFloat(tint + \".\" + p);\\n    \\n    if( sn == tn ) return true;\\n    \\n    var i;\\n    s = \".\";\\n    t = \".\";\\n    for( i=1; i<nlen; i++ ) {\\n        s += \"0\";\\n        t += \"00\";\\n    }\\n    s += \"1\";\\n    t += \"1\";\\n    \\n    if( sn < tn ) {\\n        if( sn+parseFloat(s)+parseFloat(t) >= tn ) return true;\\n    } else if( sn == tn ) {\\n        return true;\\n    } else {\\n        if( tn+parseFloat(s)+parseFloat(t) >= sn ) return true;\\n    }\\n    \\n    return false;\\n};"]}
{"id": "1932", "ref_js": ["var oddEvenJumps = function (arr) {\\n    let even = new Array(arr.length).fill(false);\\n    let odd = new Array(arr.length).fill(false);\\n\\n    let n = arr.length;\\n    even[n - 1] = true;\\n    odd[n - 1] = true;\\n    let curr = 1\\n    for (let i = n - 2; i >= 0; i--) {\\n        let next = findOdd(arr, i, n);\\n        if (next < 0) {\\n            odd[i] = false;\\n        }\\n        else {\\n            odd[i] = even[next];\\n        }\\n        next = findEven(arr, i, n);\\n        if (next < 0) {\\n            even[i] = false;\\n        }\\n        else {\\n            even[i] = odd[next]\\n        }\\n    }\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (odd[i])\\n            count++;\\n    }\\n    return count;\\n};", "var oddEvenJumps = function (arr) {\\n    ", "var oddEvenJumps = function(arr) {\\n    const n = arr.length, oddJump = Array(n).fill(0), evenJump = Array(n).fill(0);\\n    const nextHigh = Array(n).fill(0), nextLow = Array(n).fill(0);\\n    const newArr = arr.map((value, idx) => [value, idx])\\n            .sort(([b], [a]) => b - a);\\n    let stack = [], goodIndices = 1;\\n\\n    for (const [, i] of newArr) {\\n        while (stack.length > 0 && stack.at(-1) < i)\\n            nextHigh[stack.pop()] = i;\\n        stack.push(i);\\n    }\\n\\n    newArr.sort(([b, bIdx], [a, aIdx]) => a - b || bIdx - aIdx);\\n    stack.length = 0;\\n    oddJump[n - 1] = evenJump[n - 1] = 1;\\n\\n    for (const [, i] of newArr) {\\n        while (stack.length > 0 && stack.at(-1) < i)\\n            nextLow[stack.pop()] = i;\\n        stack.push(i);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        goodIndices += oddJump[i] = evenJump[nextHigh[i]];\\n        evenJump[i] = oddJump[nextLow[i]];\\n    }\\n\\n    return goodIndices;\\n};"]}
{"id": "1933", "ref_js": ["var uniquePathsIII = function(grid) {\\n    let result = 0;\\n\\n    let rows = grid.length;\\n    let columns = grid[0].length;\\n\\n    let startR, startC, endR, endC, emptyCount = 0;\\n\\n    for(let i = 0; i < rows; i++) {\\n        for(let j = 0; j < columns; j++) {\\n            if(grid[i][j] === 1) {\\n                startR = i;\\n                startC = j;\\n            } else if (grid[i][j] === 2) {\\n                endR = i;\\n                endC = j;\\n            } else if(grid[i][j] === 0) {\\n                emptyCount++;\\n            }\\n        }\\n    }\\n\\n    var dfs = (row, col, remaining) => {\\n        if(row < 0 || row >= rows ||\\n            col < 0 || col >= columns || \\n            grid[row][col] === -1) {\\n                return;\\n            }\\n\\n        if(row === endR && col === endC) {\\n            if(remaining === 0) {\\n                result++;\\n            }\\n            \\n            return;\\n        }\\n\\n        let temp = grid[row][col];\\n        grid[row][col] = -1;\\n\\n        remaining--;\\n\\n        dfs(row + 1, col, remaining);\\n        dfs(row - 1, col, remaining);\\n        dfs(row, col + 1, remaining);\\n        dfs(row, col - 1, remaining);\\n\\n        grid[row][col] = temp;\\n        remaining++;\\n\\n        return;\\n    };", "var uniquePathsIII = function(grid) {\\n    \\n    let uniquePaths = 0\\n\\n    let rows = grid.length\\n    let cols = grid[0].length\\n\\n    const dfs = (row, col, remaining) =>{    \\n\\n        if(row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] === -1){\\n            return;\\n        }\\n\\n        if(row === endR && col === endC){\\n            if(remaining === 0){\\n                uniquePaths ++\\n            }\\n            return;\\n        }\\n\\n\\n        let temp = grid[row][col]\\n        grid[row][col] = -1\\n        \\n        remaining --\\n\\n        dfs(row + 1, col, remaining)\\n        dfs(row - 1, col, remaining)\\n        dfs(row, col + 1, remaining)\\n        dfs(row, col - 1, remaining)\\n\\n        grid[row][col] = temp\\n        remaining ++\\n    }\\n\\n    let startR, startC, endR, endC, emptyCount = 0;\\n    \\n    for(let i = 0 ; i < rows ; i++){\\n        for(let j = 0; j < cols ; j++){\\n            if(grid[i][j] === 1){\\n                startR = i\\n                startC = j\\n            }\\n            if(grid[i][j] === 2){\\n                endR = i\\n                endC = j\\n            }\\n            if(grid[i][j] === 0){\\n                emptyCount++\\n            }\\n        }\\n    }\\n\\n    dfs(startR, startC, emptyCount + 1)\\n\\n    return uniquePaths\\n};", "var uniquePathsIII = function(grid) {\\n    let startRow, startCol, endRow, endCol, emptyCount = 0;\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    "]}
{"id": "1934", "ref_js": ["var countTriplets = function(nums) {\\n  laz.fill(0);\\n  let n = nums.length;\\n  \\n  for (let i = 0; i < n; ++i) laz.inc(1, nums[i], 0);\\n  let res = 0;\\n\\n  for (let i = 0; i < MAX; ++i) {\\n    let num = pri[i];\\n    let c = 0;\\n\\n    for (let b = 0; b < 16; ++b) {\\n      let l = laz.at(num, b);\\n      if (!l) continue;\\n\\n      c += l;\\n      for (let bb = b; bb < 16; ++bb) {\\n        if (!(num & (1 << bb))) continue;\\n        laz.inc(l, num & ~(1 << bb), bb);\\n      }\\n    }\\n\\n    if (cnt[num] % 2) res -= c ** 3;\\n    else res += c** 3;\\n  }\\n\\n  return res;\\n};", "var countTriplets = function(nums) {\\n    let ans = new Map() , count = 0 ; \\n    for(i of nums)\\n      for(j of nums)\\n        ans.set(i&j,[i&j,(ans.get(i&j)||[i&j,0])[1]+1])\\n    \\n    for(val of ans)\\n      for(num of nums)\\n        if((val[0]&num) === 0) count+=val[1][1];\\n\\n    return count;\\n};", "var countTriplets = function(nums) {\\n    let count = 0;\\n    let size = nums.length;\\n     for (let i = 0; i < size; ++i) {\\n        for (let j = 0; j < size; ++j) {\\n            for (let k = 0; k < size; ++k) {\\n                if (!(nums[i] & nums[j] & nums[k])) {++count;}\\n            }\\n        }\\n     }\\n     return count;\\n};"]}
{"id": "1935", "ref_js": ["var verticalTraversal = function(root) {\\n    ", "var verticalTraversal = function(root) {\\n    const nodeInfos = []; ", "var verticalTraversal = function(root) {\\n  let map = {};"]}
{"id": "1936", "ref_js": ["var subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };", "var subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };", "var subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };"]}
{"id": "1937", "ref_js": ["var minKBitFlips = function (a, k) {\\n    function flip(a, s, e) {\\n        if (e >= a.length) {\\n            return false;\\n        }\\n        for (let i = s; i <= e; i++) {\\n            a[i] = 1 - a[i];\\n        }\\n        return true;\\n    }\\n\\n    let n = a.length;\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] === 0) {\\n            if (!flip(a, i, i + k - 1)) {\\n                return -1;\\n            }\\n            cc++;\\n        }\\n    }\\n    return cc;\\n};", "var minKBitFlips = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    flip = 0;\\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n    ", "var minKBitFlips = function(nums, k) {\\n    let count = 0\\n    \\n    for(let i=0; i<nums.length; i++){\\n        if (nums[i] == 0){\\n            for(let j=0; j<k && i+k <= nums.length; j++){\\n                nums[i+j] = 1 - nums[i+j]\\n            }\\n            count++\\n        }\\n    }\\n        \\n    return nums.every(n => n ==1) ? count : -1\\n};"]}
{"id": "1938", "ref_js": ["var numSquarefulPerms = function(A) {\\n    ", "var numSquarefulPerms = function(nums) {\\n  let n = nums.length, allUsed = (1 << n) - 1;\\n  let memo = new Map(), res = 0, used = new Set();\\n  for (let i = 0; i < n; i++) {\\n    if (used.has(nums[i])) continue;\\n    res += dp(1 << i, nums[i]);\\n    used.add(nums[i]);\\n  }\\n  return res;\\n  \\n  function dp(mask, prevNum) {\\n    if (mask === allUsed) return 1;\\n    let key = `${mask},${prevNum}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = 0, used = new Set();\\n    for (let i = 0; i < n; i++) {\\n      if ((mask >> i) & 1) continue; ", "var numSquarefulPerms = function(nums) {\\n  let n = nums.length, allUsed = (1 << n) - 1;\\n  let memo = new Map(), res = 0, used = new Set();\\n  for (let i = 0; i < n; i++) {\\n    if (used.has(nums[i])) continue;\\n    res += dp(1 << i, nums[i]);\\n    used.add(nums[i]);\\n  }\\n  return res;\\n  \\n  function dp(mask, prevNum) {\\n    if (mask === allUsed) return 1;\\n    let key = `${mask},${prevNum}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = 0, used = new Set();\\n    for (let i = 0; i < n; i++) {\\n      if ((mask >> i) & 1) continue; "]}
{"id": "1939", "ref_js": ["var mergeStones = function(stones, K) {\\n    const N = stones.length, A = [], hash = {};", "var mergeStones = function(stones, k, total = 0) {\\n    const n = stones.length;\\n    \\n    ", "var mergeStones = function(stones, K) {\\n    const N = stones.length, A = [], hash = {};"]}
{"id": "1940", "ref_js": ["var gridIllumination = function(n, lamps, queries) {\\n    ", "var gridIllumination = function(n, lamps, queries) {\\n    let rows={},cols={},diagolan={},antidiagonal={},lampCordinateMap={},row,col,dx=[],ans=[];\\n    \\n    for(let i=0;i<lamps.length;i++){\\n        row = lamps[i][0];\\n        col = lamps[i][1];\\n        if(lampCordinateMap[row+\"_\"+col]===undefined){\\n            illuminate(rows,cols,diagolan,antidiagonal,row,col);\\n            lampCordinateMap[row+\"_\"+col]=true;\\n        }\\n    }\\n    \\n    for(let q=0;q<queries.length;q++){\\n        row = queries[q][0];\\n        col = queries[q][1];\\n        if(isIlluminated(rows,cols,diagolan,antidiagonal,row,col)){", "var gridIllumination = function(N, lamps, queries) {\\n  "]}
{"id": "1941", "ref_js": ["var numDupDigitsAtMostN = function(N) {\\n  let digits = toDigits(N);\\n  let len = digits.length;\\n  ", "var numDupDigitsAtMostN = function(n) {\\n  let str = n.toString(), size = str.length, memo = new Map();\\n  return dp(0, 0, 1, 0);\\n  \\n  function dp(i, mask, state, hasRepeat) {\\n    if (i === size) return state < 2 && hasRepeat ? 1 : 0;\\n    let key = `${i},${mask},${state},${hasRepeat}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = hasRepeat;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newMask = mask | (1 << digit), repeat = hasRepeat || (mask === newMask ? 1 : 0);\\n      if (digit < Number(str[i])) {\\n        ans += dp(i + 1, newMask, state === 1 ? 0 : state, repeat);\\n      } else if (digit === Number(str[i])) {\\n        ans += dp(i + 1, newMask, state, repeat);\\n      } else {\\n        ans += dp(i + 1, newMask, state === 1 ? 2 : state, repeat);\\n      }\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n};", "var numDupDigitsAtMostN = function(n) {\\n    let count = 0;\\n    const numDigits = [];\\n    \\n    let temp = n+1;\\n    while(temp!==0){\\n        const num = temp%10;\\n        numDigits.unshift(num);\\n        temp = parseInt(temp/10);\\n    }\\n\\n    for(let i=0;i<numDigits.length-1;i++){\\n        count+=9*permutation(9,i);\\n    }\\n\\n    const mySet = new Set();\\n    for(let i=0;i<numDigits.length;i++){\\n        for(let j=i===0?1:0; j<numDigits[i];j++){\\n            if(mySet.has(j)) continue;\\n            count += permutation(10-(i+1),numDigits.length-(i+1)); \\n        }\\n        if(mySet.has(numDigits[i])) break;\\n        mySet.add(numDigits[i]);\\n\\n    }\\n    \\n    return n-count;\\n};"]}
{"id": "1942", "ref_js": ["var recoverFromPreorder = function(traversal) {\\n    \\n    let n = traversal.length;\\n    \\n    ", "var recoverFromPreorder = function(traversal) {\\n    if (traversal.length === 0) return null;\\n\\n    const insert = (root, depth, val) => {\\n        if (depth === 0) return new TreeNode(val);\\n\\n        let node = new TreeNode(val);\\n        let parent = root;\\n\\n        for (let i = 1; i < depth; i++) {\\n            if (parent.right) {\\n                parent = parent.right;\\n            } else if (parent.left) {\\n                parent = parent.left;\\n            }\\n        }\\n\\n        if (!parent.left) {\\n            parent.left = node;\\n        } else {\\n            parent.right = node;\\n        }\\n\\n        return root;\\n    };", "var recoverFromPreorder = function(traversal) {\\n    if (traversal.length === 0) return null;\\n\\n    const insert = (root, depth, val) => {\\n        if (depth === 0) return new TreeNode(val);\\n\\n        let node = new TreeNode(val);\\n        let parent = root;\\n\\n        for (let i = 1; i < depth; i++) {\\n            if (parent.right) {\\n                parent = parent.right;\\n            } else if (parent.left) {\\n                parent = parent.left;\\n            }\\n        }\\n\\n        if (!parent.left) {\\n            parent.left = node;\\n        } else {\\n            parent.right = node;\\n        }\\n\\n        return root;\\n    };"]}
{"id": "1944", "ref_js": ["var isEscapePossible = function (blocked, source, target) {\\n    this.TOTAL_ROWS = Math.pow(10, 6);\\n    this.TOTAL_COLUMNS = TOTAL_ROWS;\\n    this.MOVES = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\n    const setBlocked = initializeSetBlockedPoints(blocked, source, target);\\n    return breadthFirstSearch(setBlocked, source, target) && breadthFirstSearch(setBlocked, target, source);\\n};", "var isEscapePossible = function (b, s, t) {\\n    ", "var isEscapePossible = function(blocked, source, target) {\\n    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n    const blocks = new Set(blocked.map((node) => node.toString()))\\n    function bfs(source, target) {\\n        const toBeVisited = new MyQueue()\\n        const seen = new Set()\\n        toBeVisited.enqueue(source)\\n        seen.add(source)\\n        let levelsCrossed = 0\\n        while (!toBeVisited.isEmpty()) {\\n            let currentLevelCount = toBeVisited.len\\n            while (currentLevelCount--) {\\n                const node = toBeVisited.dequeue()\\n                if (node[0] === target[0] && node[1] === target[1]) return true\\n                if (levelsCrossed >= blocks.size) return true\\n                directions.forEach((direction) => {\\n                    const neighbour = [node[0] + direction[0], node[1] + direction[1]]\\n                    if (neighbour[0] < 0 || neighbour[1] < 0 || neighbour[0] >= 1e6 || neighbour[1] >= 1e6) return\\n                    const isBlocked = blocks.has(neighbour.toString())\\n                    if (isBlocked) return\\n                    if (!seen.has(neighbour.toString())) {\\n                        toBeVisited.enqueue(neighbour)\\n                        seen.add(neighbour.toString())\\n                    }\\n                })\\n            }\\n            levelsCrossed++;\\n        }\\n        return false\\n    }\\n    return bfs(source, target) && bfs(target, source)\\n};"]}
{"id": "1945", "ref_js": ["var longestDupSubstring = function(S) {\\n    ", "var longestDupSubstring = function (s) {\\n  s += \\'\\n```;\\n  let st = new suffixTree(s);\\n  return st.getLongestDupSubstr();\\n};", "var longestDupSubstring = function(S) {\\n    "]}
{"id": "1946", "ref_js": ["var numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};", "var numSubmatrixSumTarget = function(matrix, target) {\\n    var sumMatrix = [],sum,hash={},counterPart,ans=0,prefixSum=0;\\n    ", "var numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};"]}
{"id": "1947", "ref_js": ["var shortestCommonSupersequence = function(str1, str2) {\\n    \\n    let dp = [];\\n    \\n    for(let rctr = 0 ; rctr <= str1.length ; rctr ++){\\n        let arr = [];\\n        \\n        for(let cctr = 0 ; cctr <= str2.length ; cctr ++) arr.push(0);\\n        \\n        dp.push(arr);\\n    }\\n    \\n    for(let row = 1 ; row <= str1.length ; row ++)\\n        for(let col = 1 ; col <= str2.length ; col ++) {\\n            \\n            if(str1[row-1] === str2[col-1])\\n                dp[row][col] = 1 + dp[row-1][col-1];\\n            else\\n                dp[row][col] = Math.max(dp[row-1][col],dp[row][col-1]);\\n            \\n        }\\n    \\n    let row = str1.length, col = str2.length ;\\n    \\n    let ans = \"\";\\n    \\n    while( row > 0 && col > 0 ) {\\n        \\n        if(str1[row-1] === str2[col-1]) {\\n            ans += str1[row-1];\\n            row -=1;\\n            col -=1;\\n            continue;\\n        }\\n        \\n        if(dp[row-1][col] > dp[row][col-1]) {\\n            ans += str1[row-1];\\n            row-=1;\\n        }\\n        else {\\n            ans+= str2[col-1]\\n            col -=1\\n        }\\n    }\\n    \\n    while(row > 0) {\\n        ans += str1[row-1]\\n        row -=1;\\n    }\\n    \\n    while(col > 0) {\\n        ans += str2[col-1];\\n        col -=1;\\n    }\\n    \\n    ans = ans.split(\"\");\\n    \\n    ans = ans.reverse()\\n    \\n    ans = ans.join(\"\");\\n    \\n    return ans;\\n    \\n};", "var shortestCommonSupersequence = function (str1, str2) {\\n    ", "var shortestCommonSupersequence = function (str1, str2) {\\n  const n = str1.length;\\n  const m = str2.length;\\n\\n  const dp = [];\\n  const tr = [];\\n\\n  for (let i = 0; i <= n; i++) {\\n    dp.push(new Uint16Array(m + 1));\\n    tr.push(new Uint8Array(m + 1));\\n  }\\n\\n  for (let i = n; i >= 0; i--) {\\n    for (let j = m; j >= 0; j--) {\\n      dp[i][j] = n + m - i - j;\\n      if (n == i) tr[i][j] = 2;\\n      else tr[i][j] = 1;\\n\\n      if (i < n && j < m) {\\n        if (dp[i][j] > dp[i + 1][j] + 1) {\\n          dp[i][j] = dp[i + 1][j] + 1;\\n          tr[i][j] = 1;\\n        }\\n        if (dp[i][j] > dp[i][j + 1] + 1) {\\n          dp[i][j] = dp[i][j + 1] + 1;\\n          tr[i][j] = 2;\\n        }\\n        if (str1[i] == str2[j] && dp[i][j] > dp[i + 1][j + 1] + 1) {\\n          dp[i][j] = dp[i + 1][j + 1] + 1;\\n          tr[i][j] = 3;\\n        }\\n      }\\n    }\\n  }\\n\\n  let x = 0;\\n  let y = 0;\\n  let l = dp[0][0];\\n  let res = \"\";\\n  for (let i = 0; i < l; i++) {\\n    let t = tr[x][y];\\n    if (t == 1) res += str1[x];\\n    else res += str2[y];\\n\\n    x += t & 1;\\n    y += t >> 1;\\n  }\\n\\n  return res;\\n};"]}
{"id": "1948", "ref_js": ["var findInMountainArray = function(target, mountainArr) {\\n    const n = mountainArr.length();\\n    let left = 0;\\n    let right = n - 1;\\n\\n    ", "var findInMountainArray = function(target, mountainArr) {\\n    const length = mountainArr.length();\\n\\n    function findTarget(left, right, target, isUpside) {\\n        while (left <= right) {\\n            const mid = left + Math.floor((right - left) / 2);\\n            const midVal = mountainArr.get(mid);\\n\\n            if (midVal === target) {\\n                return mid;\\n            }\\n\\n            if (isUpside) {\\n                if (target > midVal) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                if (target > midVal) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    function findPeak() {\\n        let left = 0;\\n        let right = length - 1;\\n\\n        while (left < right) {\\n            const mid = left + Math.floor((right - left) / 2);\\n            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    const peakIndex = findPeak();\\n\\n    let result = findTarget(0, peakIndex, target, true);\\n    if (result !== -1) {\\n        return result;\\n    }\\n\\n    return findTarget(peakIndex + 1, length - 1, target, false);    \\n};", "var findInMountainArray = function(target, mountainArr) {\\n    const n = mountainArr.length();\\n    let left = 0;\\n    let right = n - 1;\\n\\n    "]}
{"id": "1949", "ref_js": ["var braceExpansionII = function(expression) {\\n    \\n};", "var braceExpansionII = function(expression) {\\n    \\n};", "var braceExpansionII = function(expression) {\\n    \\n};"]}
{"id": "1950", "ref_js": ["var parseBoolExpr = function(expression) {\\n        const helper = function (index) {\\n            let sign = expression[index];\\n            if (sign === \\'t\\' || sign === \\'f\\') return [index, sign === \\'t\\']\\n            index += 2;\\n            let booleans = []\\n            while(true){\\n                let [processedIndex, bool] = helper(index);\\n                booleans.push(bool)\\n                index = processedIndex;\\n                if(expression[index+1] === \\')\\') break;\\n                index += 2;\\n            }\\n            index++;\\n            switch (sign) {\\n                case \\'!\\':\\n                    return [index, !booleans[0]]\\n                case \\'&\\':\\n                    return [index, booleans.every(e=> e)]\\n                case \\'|\\':\\n                    return [index, booleans.some(e=> e)]\\n            }\\n        }\\n        return helper(0)[1]\\n};", "var parseBoolExpr = function(expression) {\\n    let stack = []; \\n    for(let i = 0; i < expression.length; i++) {\\n        const char = expression[i];\\n        if (char === \\')\\') {\\n            let _seen = new Set();\\n            while(stack.at(-1) !== \\'(\\'){\\n                _seen.add(stack.pop());\\n            }\\n            stack.pop();\\n            const operator = stack.pop();\\n            if(operator === \\'&\\') {\\n                stack.push(_seen.has(\\'f\\') ? \\'f\\' : \\'t\\');\\n            } else if (operator === \\'|\\') {\\n                stack.push(_seen.has(\\'t\\') ? \\'t\\' : \\'f\\');\\n            } else {\\n                 stack.push(_seen.has(\\'t\\') ? \\'f\\' : \\'t\\');\\n            }\\n        } else if (char !== \\',\\') {\\n            stack.push(char)\\n        }\\n    }\\n    return stack.pop() == \\'t\\';\\n};", "var parseBoolExpr = function(expression) {\\n        const helper = function (index) {\\n            let sign = expression[index];\\n            if (sign === \\'t\\' || sign === \\'f\\') return [index, sign === \\'t\\']\\n            index += 2;\\n            let booleans = []\\n            while(true){\\n                let [processedIndex, bool] = helper(index);\\n                booleans.push(bool)\\n                index = processedIndex;\\n                if(expression[index+1] === \\')\\') break;\\n                index += 2;\\n            }\\n            index++;\\n            switch (sign) {\\n                case \\'!\\':\\n                    return [index, !booleans[0]]\\n                case \\'&\\':\\n                    return [index, booleans.every(e=> e)]\\n                case \\'|\\':\\n                    return [index, booleans.some(e=> e)]\\n            }\\n        }\\n        return helper(0)[1]\\n};"]}
{"id": "1951", "ref_js": ["var smallestSufficientTeam = function(req_skills, people) {\\n    const skill_to_bit = req_skills.reduce((acc, skill, i) => {\\n        acc[skill] = 1 << i;\\n        return acc;\\n    }, {});\\n\\n    const target_skills = (1 << req_skills.length) - 1;\\n    const dp = new Array(target_skills + 1).fill(null);\\n    dp[0] = [];\\n\\n    for (let i = 0; i < people.length; i++) {\\n        const person_skills = people[i];\\n        const person_bitmask = person_skills.reduce((acc, skill) => {\\n            return acc | skill_to_bit[skill];\\n        }, 0);\\n\\n        for (let covered_skills = 0; covered_skills <= target_skills; covered_skills++) {\\n            if (dp[covered_skills] === null) continue;\\n\\n            const new_skills = covered_skills | person_bitmask;\\n            if (dp[new_skills] === null || dp[new_skills].length > dp[covered_skills].length + 1) {\\n                dp[new_skills] = [...dp[covered_skills], i];\\n            }\\n        }\\n    }\\n\\n    return dp[target_skills];\\n};", "var smallestSufficientTeam = function(req_skills, people) {\\n    const skill_to_bit = req_skills.reduce((acc, skill, i) => {\\n        acc[skill] = 1 << i;\\n        return acc;\\n    }, {});\\n\\n    const target_skills = (1 << req_skills.length) - 1;\\n    const dp = new Array(target_skills + 1).fill(null);\\n    dp[0] = [];\\n\\n    for (let i = 0; i < people.length; i++) {\\n        const person_skills = people[i];\\n        const person_bitmask = person_skills.reduce((acc, skill) => {\\n            return acc | skill_to_bit[skill];\\n        }, 0);\\n\\n        for (let covered_skills = 0; covered_skills <= target_skills; covered_skills++) {\\n            if (dp[covered_skills] === null) continue;\\n\\n            const new_skills = covered_skills | person_bitmask;\\n            if (dp[new_skills] === null || dp[new_skills].length > dp[covered_skills].length + 1) {\\n                dp[new_skills] = [...dp[covered_skills], i];\\n            }\\n        }\\n    }\\n\\n    return dp[target_skills];\\n};", "var smallestSufficientTeam = function(req_skills, people) {\\n    const skill_to_bit = req_skills.reduce((acc, skill, i) => {\\n        acc[skill] = 1 << i;\\n        return acc;\\n    }, {});\\n\\n    const target_skills = (1 << req_skills.length) - 1;\\n    const dp = new Array(target_skills + 1).fill(null);\\n    dp[0] = [];\\n\\n    for (let i = 0; i < people.length; i++) {\\n        const person_skills = people[i];\\n        const person_bitmask = person_skills.reduce((acc, skill) => {\\n            return acc | skill_to_bit[skill];\\n        }, 0);\\n\\n        for (let covered_skills = 0; covered_skills <= target_skills; covered_skills++) {\\n            if (dp[covered_skills] === null) continue;\\n\\n            const new_skills = covered_skills | person_bitmask;\\n            if (dp[new_skills] === null || dp[new_skills].length > dp[covered_skills].length + 1) {\\n                dp[new_skills] = [...dp[covered_skills], i];\\n            }\\n        }\\n    }\\n\\n    return dp[target_skills];\\n};"]}
{"id": "1952", "ref_js": ["var longestDecomposition = function(text) {\\n    \\n};", "var longestDecomposition = function(text) {\\n    let count = 0;\\n    let left = 0;\\n    let right = text.length - 1;\\n    let leftStr = \\'\\';\\n    let rightStr = \\'\\';\\n    while (left < right) {\\n        leftStr += text[left++];\\n        rightStr = text[right--] + rightStr;\\n        if (leftStr === rightStr) {\\n            count += 2;\\n            leftStr = \\'\\';\\n            rightStr = \\'\\';\\n        }\\n    }\\n    if (leftStr || left === right) count++;\\n    return count;\\n};", "var longestDecomposition = function(text) {\\n    let count = 0;\\n    let left = 0;\\n    let right = text.length - 1;\\n    let leftStr = \\'\\';\\n    let rightStr = \\'\\';\\n    while (left < right) {\\n        leftStr += text[left++];\\n        rightStr = text[right--] + rightStr;\\n        if (leftStr === rightStr) {\\n            count += 2;\\n            leftStr = \\'\\';\\n            rightStr = \\'\\';\\n        }\\n    }\\n    if (leftStr || left === right) count++;\\n    return count;\\n};"]}
{"id": "1954", "ref_js": ["var lastSubstring = function(s) {\\n    ans = \\'a\\'\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s.substring(i) > ans) ans = s.substring(i)\\n    }\\n\\n    return ans\\n};", "var lastSubstring = function (s) {\\n  let n = s.length;\\n  let L, R, offset;\\n  for (L = 0, R = L + 1, offset = 0; R + offset < n;) {\\n    if (s[R + offset] === s[L + offset]) {\\n      offset++;\\n    } else if (s[R + offset] < s[L + offset]) {\\n      R = R + offset + 1;\\n      offset = 0;\\n    } else {\\n      L = L + offset + 1;\\n      if (R < L + 1) R = L + 1;\\n      offset = 0;\\n    }\\n  }\\n  return s.slice(L);\\n};", "var lastSubstring = function(s) {\\n    ans = \\'a\\'\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s.substring(i) > ans) ans = s.substring(i)\\n    }\\n\\n    return ans\\n};"]}
{"id": "1956", "ref_js": ["var findNumOfValidWords = function(words, puzzles) {\\n    const wordMap = new Map();\\n    const aCharCode = \\'a\\'.charCodeAt(0);\\n    words.forEach(word => {\\n        let mask = 0;\\n        for (let i = 0; i < word.length; i++) {\\n            mask |= (1 << (word.charCodeAt(i) - aCharCode));\\n        }\\n        if (wordMap.has(mask)) {\\n            wordMap.set(mask, wordMap.get(mask) + 1);\\n        } else {\\n            wordMap.set(mask, 1);\\n        }\\n    });\\n\\n    const result = [];\\n    for (let i = 0; i < puzzles.length; i++) {\\n        result.push(0);\\n        let curMask = 0;\\n        for (let j = 0; j < puzzles[i].length; j++) {\\n            curMask |= (1 << (puzzles[i].charCodeAt(j) - aCharCode));\\n        }\\n        const firstLetter = 1 << (puzzles[i].charCodeAt(0) - aCharCode);\\n        \\n        let start = curMask;\\n        while (start > 0) {\\n            if ((start & firstLetter) === firstLetter && wordMap.has(start)) {\\n                result[i] += wordMap.get(start);\\n            }\\n            \\n            start = (start - 1) & curMask\\n        }\\n    }\\n    \\n    return result;\\n};", "var findNumOfValidWords = function(words, puzzles) {\\n  let count = [];\\n  let wordsLetterMap = new Array(words.length).fill(0);\\n  \\n  for(let i = 0; i < words.length; i++){\\n      for (letter of words[i]){\\n          let index = letter.charCodeAt(0)-97;\\n          wordsLetterMap[i] |= (1 << (26-index)); \\n      }\\n  }\\n  let puzzlesLetterMap = new Array(puzzles.length).fill(0);\\n  for(let i = 0; i < puzzles.length; i++){\\n      for (letter of puzzles[i]){\\n          let index = letter.charCodeAt(0)-97;\\n          puzzlesLetterMap[i] |= (1 << (26-index));\\n      }\\n  }\\n\\n  for(let i = 0; i < puzzles.length; i++){\\n    let currentCount = 0;\\n    for(let j = 0; j < words.length; j++){\\n        let index = puzzles[i].charCodeAt(0)-97;\\n        if((wordsLetterMap[j] & (1 << (26-index))) && \\n        ((wordsLetterMap[j] & puzzlesLetterMap[i]) == wordsLetterMap[j])){\\n            currentCount++;\\n        }\\n    }\\n    count.push(currentCount);\\n}\\n\\n  return count;\\n};", "var findNumOfValidWords = function(words, puzzles) {\\n    const n = words.length;\\n    const m = puzzles.length;\\n    const trie = {};"]}
{"id": "1957", "ref_js": ["var makeArrayIncreasing = function(arr1, arr2) {\\n    arr2.sort((a, b) => a - b);\\n    const binarySearch = (arr, target) => {\\n        let l = 0, r = arr.length, mid;\\n        while (l < r) {\\n            mid = (l + r) >> 1;\\n            arr[mid] > target ? r = mid : l = ++mid;\\n        }\\n        return l;\\n    }\\n    const dfs = (i, prev) => {\\n        if (i >= arr1.length) return 0;\\n        let key = `${i},${prev}`;\\n        if (key in memo) return memo[key];\\n        let j = binarySearch(arr2, prev);\\n        let swap = j < arr2.length ? 1 + dfs(i+1, arr2[j]) : Infinity;\\n        let noSwap = arr1[i] > prev ? dfs(i+1, arr1[i]) : Infinity;\\n        return memo[key] = Math.min(swap, noSwap);\\n    }\\n    const memo = {};", "var makeArrayIncreasing = function(arr1, arr2) {\\n  arr1 = [-1, ...arr1, Infinity];\\n  arr2 = [...new Set(arr2)].sort((a, b) => a - b);\\n  const n = arr1.length;\\n  const dp = new Array(n).fill(Infinity);\\n  dp[0] = 0;\\n  \\n  for (let i = 1; i < n; i++) {\\n    const j = search(arr2, arr1[i]);\\n    \\n    for (let k = 1; k <= Math.min(i - 1, j); k++) {\\n      if (arr1[i - k - 1] < arr2[j - k]) dp[i] = Math.min(dp[i], dp[i - k - 1] + k);\\n    }\\n    \\n    if (arr1[i - 1] < arr1[i]) dp[i] = Math.min(dp[i], dp[i - 1]);\\n  }\\n  \\n  return dp[n - 1] < Infinity ? dp[n - 1] : -1;\\n};", "var makeArrayIncreasing = function(arr1, arr2) {\\n    arr2.sort((a, b) => a - b);\\n    const binarySearch = (arr, target) => {\\n        let l = 0, r = arr.length, mid;\\n        while (l < r) {\\n            mid = (l + r) >> 1;\\n            arr[mid] > target ? r = mid : l = ++mid;\\n        }\\n        return l;\\n    }\\n    const dfs = (i, prev) => {\\n        if (i >= arr1.length) return 0;\\n        let key = `${i},${prev}`;\\n        if (key in memo) return memo[key];\\n        let j = binarySearch(arr2, prev);\\n        let swap = j < arr2.length ? 1 + dfs(i+1, arr2[j]) : Infinity;\\n        let noSwap = arr1[i] > prev ? dfs(i+1, arr1[i]) : Infinity;\\n        return memo[key] = Math.min(swap, noSwap);\\n    }\\n    const memo = {};"]}
{"id": "1958", "ref_js": ["var criticalConnections = function(n, connections) {\\n    let edgeMap = {}\\n    for (let i = 0; i < n; i++)\\n        edgeMap[i] = []\\n    for (let [a,b] of connections)\\n        edgeMap[a].push(b), edgeMap[b].push(a)\\n    let disc = new Uint32Array(n), low = new Uint32Array(n),\\n        time = 1, ans = []\\n    const dfs = (curr, prev) => {\\n        disc[curr] = low[curr] = time++\\n        for (let next of edgeMap[curr]) {\\n            if (!disc[next]) {\\n                dfs(next, curr)\\n                low[curr] = Math.min(low[curr], low[next])\\n            } else if (next !== prev)\\n                low[curr] = Math.min(low[curr], disc[next])\\n            if (low[next] > disc[curr])\\n                ans.push([curr, next])\\n        }\\n    }\\n    dfs(0, -1)\\n    return ans\\n};", "var criticalConnections = function(n, connections) {\\n    const adjList = buildAdjList(n, connections);\\n    const orderList = Array(n).fill();\\n    const lowlinkList = Array(n).fill();\\n    \\n    let order = 0;\\n    const cycles = [];\\n    const critical = []\\n    \\n    const strongConnect = (i, p) => {\\n        orderList[i] = order++;\\n        lowlinkList[i] = orderList[i];\\n        \\n        for (const j of adjList[i]) {\\n            if (j === p) {\\n                continue;\\n            }\\n            \\n            if (orderList[j] === undefined) {\\n                strongConnect(j, i);                \\n            }\\n            \\n            lowlinkList[i] = Math.min(lowlinkList[i], lowlinkList[j]);\\n            \\n\\t\\t\\t", "var criticalConnections = function(n, connections) {\\n    let edgeMap = {}\\n    for (let i = 0; i < n; i++)\\n        edgeMap[i] = []\\n    for (let [a,b] of connections)\\n        edgeMap[a].push(b), edgeMap[b].push(a)\\n    let disc = new Uint32Array(n), low = new Uint32Array(n),\\n        time = 1, ans = []\\n    const dfs = (curr, prev) => {\\n        disc[curr] = low[curr] = time++\\n        for (let next of edgeMap[curr]) {\\n            if (!disc[next]) {\\n                dfs(next, curr)\\n                low[curr] = Math.min(low[curr], low[next])\\n            } else if (next !== prev)\\n                low[curr] = Math.min(low[curr], disc[next])\\n            if (low[next] > disc[curr])\\n                ans.push([curr, next])\\n        }\\n    }\\n    dfs(0, -1)\\n    return ans\\n};"]}
{"id": "1959", "ref_js": ["var sortItems = function(n, m, group, beforeItems) {\\n    const graph = Array.from({ length: m + n }, () => [])\\n    const indegree = Array(n + m).fill(0)\\n    for (let i = 0; i < group.length; i++) {\\n        if (group[i] == -1) continue\\n        graph[n + group[i]].push(i)\\n        indegree[i]++\\n  }\\n\\n    for (let i = 0; i < beforeItems.length; i++) {\\n        for (const e of beforeItems[i]) {\\n            const a = group[e] === -1 ? e : n + group[e]\\n            const b = group[i] === -1 ? i : n + group[i]\\n            if (a === b) {\\n                graph[e].push(i)\\n                indegree[i]++\\n            } else {\\n                graph[a].push(b)\\n                indegree[b]++\\n      }\\n    }\\n  }\\n  const res = []\\n  for (let i = 0; i < n + m; i++) {\\n    if (indegree[i] === 0) dfs(res, graph, indegree, n, i)\\n  }\\n  return res.length === n ? res : []\\n  function dfs(ans, graph, indegree, n, cur) {\\n    if (cur < n) ans.push(cur)\\n    indegree[cur] = -1 \\n    for (let next of graph[cur] || []) {\\n      indegree[next]--\\n      if (indegree[next] === 0) dfs(ans, graph, indegree, n, next)\\n    }\\n  }\\n};", "var sortItems = function(n, m, group, beforeItems) {\\n    for (let i = 0; i < n; i++) {\\n        if (group[i] == -1) {\\n            group[i] = m++;\\n        }\\n    }\\n    let gg = initializeGraphSet(m); ", "var sortItems = function(n, m, group, beforeItems) {\\n    const graph = Array.from({ length: m + n }, () => [])\\n    const indegree = Array(n + m).fill(0)\\n    for (let i = 0; i < group.length; i++) {\\n        if (group[i] == -1) continue\\n        graph[n + group[i]].push(i)\\n        indegree[i]++\\n  }\\n\\n    for (let i = 0; i < beforeItems.length; i++) {\\n        for (const e of beforeItems[i]) {\\n            const a = group[e] === -1 ? e : n + group[e]\\n            const b = group[i] === -1 ? i : n + group[i]\\n            if (a === b) {\\n                graph[e].push(i)\\n                indegree[i]++\\n            } else {\\n                graph[a].push(b)\\n                indegree[b]++\\n      }\\n    }\\n  }\\n  const res = []\\n  for (let i = 0; i < n + m; i++) {\\n    if (indegree[i] === 0) dfs(res, graph, indegree, n, i)\\n  }\\n  return res.length === n ? res : []\\n  function dfs(ans, graph, indegree, n, cur) {\\n    if (cur < n) ans.push(cur)\\n    indegree[cur] = -1 \\n    for (let next of graph[cur] || []) {\\n      indegree[next]--\\n      if (indegree[next] === 0) dfs(ans, graph, indegree, n, next)\\n    }\\n  }\\n};"]}
{"id": "1961", "ref_js": ["var minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};", "var minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};", "var minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};"]}
{"id": "1962", "ref_js": ["var countVowelPermutation = function(n) {\\n    const MOD = 1e9 + 7;\\n        let a_count = 1, e_count = 1, i_count = 1, o_count = 1, u_count = 1;\\n        \\n        for (let i = 1; i < n; ++i) {\\n            const new_a = (e_count + i_count + u_count) % MOD;\\n            const new_e = (a_count + i_count) % MOD;\\n            const new_i = (e_count + o_count) % MOD;\\n            const new_o = i_count;\\n            const new_u = (i_count + o_count) % MOD;\\n            \\n            a_count = new_a;\\n            e_count = new_e;\\n            i_count = new_i;\\n            o_count = new_o;\\n            u_count = new_u;\\n        }\\n        \\n        const total = (a_count + e_count + i_count + o_count + u_count) % MOD;\\n        \\n        return total;\\n};", "var countVowelPermutation = function(n) {\\n    if (n === 1) {\\n        return 5;\\n    }\\n\\n    let a = 1, e = 1, i = 1, o = 1, u = 1;\\n    const mod = 1000000007;\\n\\n    for (let step = 2; step <= n; step++) {\\n        const newA = (e + u + i) % mod;\\n        const newE = (a + i) % mod;\\n        const newI = (e + o) % mod;\\n        const newO = i;\\n        const newU = (i + o) % mod;\\n\\n        a = newA;\\n        e = newE;\\n        i = newI;\\n        o = newO;\\n        u = newU;\\n    }\\n\\n    return (a + e + i + o + u) % mod;    \\n};", "var countVowelPermutation = function(n) {\\n            const MOD = 1000000007;\\n        let a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (let len = 2; len <= n; len++) {\\n            const new_a = (e + u + i) % MOD;\\n            const new_e = (a + i) % MOD;\\n            const new_i = (e + o) % MOD;\\n            const new_o = i % MOD;\\n            const new_u = (o + i) % MOD;\\n\\n            a = new_a;\\n            e = new_e;\\n            i = new_i;\\n            o = new_o;\\n            u = new_u;\\n        }\\n\\n        const count = (a + e + i + o + u) % MOD;\\n        return count;\\n};"]}
{"id": "1963", "ref_js": ["var dieSimulator = function (n, rollMax) {\\n  dp[0].fill(0);\\n  dp[0][6] = 1;\\n\\n  for (let i = 1; i <= n; ++i) {\\n    dp[i % 16][6] = 0;\\n\\n    for (let f = 0; f < 6; ++f) {\\n      let minP = Math.max(0, i - rollMax[f]);\\n      let curDp = 0;\\n\\n      for (let p = i - 1; p >= minP; p--) {\\n        curDp = (curDp + dp[p % 16][6] - dp[p % 16][f]) % MOD;\\n      }\\n\\n      dp[i % 16][f] = curDp;\\n      dp[i % 16][6] = dp[i % 16][6] + curDp;\\n    }\\n  }\\n\\n  return (dp[n % 16][6] + MOD) % MOD;\\n};", "var dieSimulator = function(n, rollMax) {\\n  ", "var dieSimulator = function (n, rollMax) {\\n  dp[0].fill(0);\\n  dp[0][6] = 1;\\n\\n  for (let i = 1; i <= n; ++i) {\\n    dp[i % 16][6] = 0;\\n\\n    for (let f = 0; f < 6; ++f) {\\n      let minP = Math.max(0, i - rollMax[f]);\\n      let curDp = 0;\\n\\n      for (let p = i - 1; p >= minP; p--) {\\n        curDp = (curDp + dp[p % 16][6] - dp[p % 16][f]) % MOD;\\n      }\\n\\n      dp[i % 16][f] = curDp;\\n      dp[i % 16][6] = dp[i % 16][6] + curDp;\\n    }\\n  }\\n\\n  return (dp[n % 16][6] + MOD) % MOD;\\n};"]}
{"id": "1964", "ref_js": ["var maxEqualFreq = function (nums) {\\n  let n = nums.length;\\n  counters.fill(0);\\n  fCounters.fill(0, 0, n + 1);\\n\\n  let flagSame = true;\\n  let res = 0;\\n\\n  let min1 = 1;\\n  let max1 = 1;\\n  let min2;\\n  let max2;\\n\\n  counters[nums[0]] = 1;\\n  fCounters[1] = 1;\\n\\n  let num, fre;\\n  for (let i = 1; i < n; i++) {\\n    if (nums[i] != nums[i - 1]) flagSame = false;\\n\\n    num = nums[i];\\n    fre = counters[num];\\n\\n    counters[num]++;\\n    fCounters[fre]--;\\n    fCounters[fre + 1]++;\\n\\n    if (fre == max1) {\\n      if (fCounters[fre]) max2 = fre;\\n      max1 = fre + 1;\\n    } else if (fre == max2) {\\n      max2 = fre + 1;\\n    }\\n\\n    if (fre == 0) {\\n      if (max2 == undefined) max2 = 1;\\n      min2 = min1;\\n      min1 = 1;\\n    } else if (fre == min1) {\\n      if (fCounters[fre] == 0) min1 = fre + 1;\\n      else if (fCounters[fre] == 1) min2 = fre + 1;\\n    } else if (fre == min2) {\\n      if (!fCounters[fre]) min2 = fre + 1;\\n    }\\n\\n    if (\\n      flagSame ||\\n      (min1 == 1 && min2 == max1) ||\\n      (min1 == max2 && max1 == min1 + 1)\\n    )\\n      res = i;\\n  }\\n\\n  return res + 1;\\n};", "var maxEqualFreq = function(arr) {\\n  let numFreqMap = new Map();\\n  let countFreqMap = new Map();\\n  let result = 0;\\n  let maxFreq = 0;\\n  \\n  for (let i=0; i<arr.length; i++) {\\n    let num = arr[i];\\n    oldCountFreq = numFreqMap.get(num) || 0;\\n    newCountFreq = oldCountFreq+1;\\n    \\n    numFreqMap.set(num, newCountFreq);\\n\\n    ", "var maxEqualFreq = function(nums) {\\n  "]}
{"id": "1965", "ref_js": ["var jobScheduling = function(startTime, endTime, profit) {\\n    \\n    let jobs=[],cache=[];\\n    for(let i=0;i<startTime.length;i++){\\n        jobs.push([startTime[i], endTime[i], profit[i]]);\\n    }\\n    jobs.sort(function(a,b){return a[0]-b[0]});\\n    return backtrack(0);\\n    function backtrack(pos){\\n        if(cache[pos]!==undefined){\\n            return cache[pos];\\n        }\\n        if(pos===startTime.length || pos==-1){\\n            return 0;\\n        }\\n        let profit1=0,profit2=0;\\n        let nextPossibleJobIndex = binarySearch(jobs[pos][1],pos+1,startTime.length-1);\\n            profit1 = +jobs[pos][2]+backtrack(nextPossibleJobIndex);", "var jobScheduling = function(startTime, endTime, profit) {\\n    var jobs = [];\\n    var dp = []\\n    \\n    for(let i=0; i<startTime.length; i++){\\n        jobs.push([startTime[i] , endTime[i] , profit[i]])\\n    }\\n    jobs.sort((a,b) => a[1] - b[1]);\\n    \\n    dp[0] = jobs[0][2];\\n    for(let i=1; i<startTime.length; i++){\\n        var result = binary(i);\\n        let profit = (result === -1) ? 0: dp[result];\\n        \\n        \\n        dp[i] = Math.max(dp[i-1] , profit + jobs[i][2])\\n    }\\n    return dp[dp.length -1]\\n    \\n    \\n    \\n    \\n    function binary(index){\\n        var l = 0;\\n        var h = index-1;\\n        var temp = -1\\n        while(l <= h){\\n            var mid = Math.floor( (l+h) / 2);\\n            if(jobs[mid][1] <=  jobs[index][0] ){\\n                temp = mid;\\n                l = mid+1\\n            }else{\\n                h = mid-1\\n            }\\n        }\\n        return temp\\n    }\\n};", "var jobScheduling = function(startTime, endTime, profit) {\\n    \\n    let jobs=[],cache=[];\\n    for(let i=0;i<startTime.length;i++){\\n        jobs.push([startTime[i], endTime[i], profit[i]]);\\n    }\\n    jobs.sort(function(a,b){return a[0]-b[0]});\\n    return backtrack(0);\\n    function backtrack(pos){\\n        if(cache[pos]!==undefined){\\n            return cache[pos];\\n        }\\n        if(pos===startTime.length || pos==-1){\\n            return 0;\\n        }\\n        let profit1=0,profit2=0;\\n        let nextPossibleJobIndex = binarySearch(jobs[pos][1],pos+1,startTime.length-1);\\n            profit1 = +jobs[pos][2]+backtrack(nextPossibleJobIndex);"]}
{"id": "1966", "ref_js": ["var tilingRectangle = function(n, m) {\\n  const queue = [[new Array(n).fill(0), 0]];\\n  while (true) {\\n    const [curr, numSquares] = queue.shift();\\n    let min = { height: Infinity, start: Infinity, end: Infinity }\\n    for (let i = 0; i < n; i++) {\\n      if (curr[i] < min.height) {\\n        min.height = curr[i];\\n        min.start = i;\\n        min.end = i + 1;\\n      } else if (curr[i] === min.height && min.end === i) {\\n        min.end++\\n      }\\n    }\\n    if (min.height === m) return numSquares;\\n    const largestSquare = Math.min(m - min.height, min.end - min.start);\\n    for (let sqWidth = largestSquare; sqWidth; sqWidth--) {\\n      const next = curr.slice();\\n      for (let i = min.start; i < min.start + sqWidth; i++) {\\n        next[i] += sqWidth;\\n      }\\n      queue.push([next, numSquares + 1]);\\n    }\\n  }\\n};", "var tilingRectangle = function(n, m) {\\n    if (n === m) return 1;\\n    if (n === 1) return m;\\n    if (m === 1) return n;\\n\\n    let i=n, j=m, ans = 1;\\n    while(i !== j) {\\n        if (i > j) i -= j; else j -= i;\\n        ans ++;\\n    }\\n    const area = n * m;\\n    const heights = new Array(m).fill(0);\\n    \\n    const dfs = (x, index, aa) => {\\n        if (index >= ans) return;\\n\\n        let size = 1;\\n        const height = heights[x], max = n - height;\\n        while(size < max && x + size < m && heights[x+size] === height) size ++;\\n\\n        ", "var tilingRectangle = function(n, m) {\\n    if (n === m) return 1;\\n    if (n === 1) return m;\\n    if (m === 1) return n;\\n\\n    let i=n, j=m, ans = 1;\\n    while(i !== j) {\\n        if (i > j) i -= j; else j -= i;\\n        ans ++;\\n    }\\n    const area = n * m;\\n    const heights = new Array(m).fill(0);\\n    \\n    const dfs = (x, index, aa) => {\\n        if (index >= ans) return;\\n\\n        let size = 1;\\n        const height = heights[x], max = n - height;\\n        while(size < max && x + size < m && heights[x+size] === height) size ++;\\n\\n        "]}
{"id": "1967", "ref_js": ["var isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n    return A.reduce((g, n) => gcd(g, n)) === 1;\\n};", "var isGoodArray = function(nums) {\\n    let gcd = nums[0]\\n    \\n    for(let n of nums){while(n){[gcd, n] = [n, gcd % n]}}\\n    \\n    return (gcd === 1)\\n};", "var isGoodArray = function(nums) {\\n    let gcd = nums[0]\\n    \\n    for(let n of nums){while(n){[gcd, n] = [n, gcd % n]}}\\n    \\n    return (gcd === 1)\\n};"]}
{"id": "1968", "ref_js": ["var maxScoreWords = function (words, letters, score) {\\n    let count = Array(26).fill(0), n = words.length, result = 0;\\n\\n    for (const char of letters) count[char.charCodeAt() - 97]++;\\n\\n    outer:\\n    for (let i = 0; i < 1 << n; i++) {\\n\\n        let tempCount = Array(26).fill(0), sum = 0;\\n\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                for (const char of words[j]) tempCount[char.charCodeAt() - 97]++;\\n            }\\n        }\\n\\n        for (let j = 0; j < 26; j++) {\\n            if (tempCount[j] > count[j]) continue outer;\\n            sum += tempCount[j] * score[j];\\n        }\\n\\n        result = Math.max(result, sum);\\n    }\\n\\n    return result;\\n};", "var maxScoreWords = function(words, letters, score) {\\n    let maxScore = 0;\\n    let letterFreq = Array(26).fill(0);\\n    \\n    ", "var maxScoreWords = function(words, letters, score) {\\n    const freq = new Uint8Array(26);\\n    let max = 0;\\n    for (let i = 0; i < letters.length; i++) {\\n        ++freq[letters[i].charCodeAt(0) - 97];\\n    }\\n    takeOrNot(0, 0);\\n    return max;\\n\\n    function takeOrNot(wordIdx, score) {\\n        if (wordIdx === words.length) {\\n            return score > max && (max = score);\\n        }\\n        const wordScore = wordToScore(wordIdx);\\n        if (wordScore > 0) {\\n            takeOrNot(wordIdx+1, score + wordScore); "]}
{"id": "1969", "ref_js": ["var minPushBox = function(grid) {\\n\\t", "var minPushBox = function(grid) {\\n\\t", "var minPushBox = function (grid) {\\n\\tconst n = grid.length;\\n\\tconst m = grid[0].length;\\n\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[-1, 0],\\n\\t\\t[0, -1],\\n\\t];\\n\\n\\tconst person = { x: 0, y: 0 };"]}
{"id": "1970", "ref_js": ["var numWays = function(steps, arrLen) {\\n    const maxPosition = Math.min(Math.floor(steps / 2) + 1, arrLen);\\n    let curWays = new Array(maxPosition + 2).fill(0);\\n    let nextWays = new Array(maxPosition + 2).fill(0);\\n    curWays[1] = 1;\\n    const mod = 10 ** 9 + 7;\\n\\n    while (steps > 0) {\\n        for (let pos = 1; pos <= maxPosition; pos++) {\\n            nextWays[pos] = (curWays[pos] + curWays[pos - 1] + curWays[pos + 1]) % mod;\\n        }\\n\\n        ", "var numWays = function(steps, arrLen) {\\n    const maxPosition = Math.min(Math.floor(steps / 2) + 1, arrLen);\\n    let curWays = new Array(maxPosition + 2).fill(0);\\n    let nextWays = new Array(maxPosition + 2).fill(0);\\n    curWays[1] = 1;\\n    const mod = 10 ** 9 + 7;\\n\\n    while (steps > 0) {\\n        for (let pos = 1; pos <= maxPosition; pos++) {\\n            nextWays[pos] = (curWays[pos] + curWays[pos - 1] + curWays[pos + 1]) % mod;\\n        }\\n\\n        ", "var numWays = function(steps, arrLen) {\\n    const maxPosition = Math.min(Math.floor(steps / 2) + 1, arrLen);\\n    let curWays = new Array(maxPosition + 2).fill(0);\\n    let nextWays = new Array(maxPosition + 2).fill(0);\\n    curWays[1] = 1;\\n    const mod = 10 ** 9 + 7;\\n\\n    while (steps > 0) {\\n        for (let pos = 1; pos <= maxPosition; pos++) {\\n            nextWays[pos] = (curWays[pos] + curWays[pos - 1] + curWays[pos + 1]) % mod;\\n        }\\n\\n        "]}
{"id": "1971", "ref_js": ["var palindromePartition = function(s, k) {\\n    const len = s.length;\\n    \\n    const cost = (i = 0, j = 0) => {\\n        let c = 0;\\n        while(i <= j) {\\n            if(s[i] != s[j]) c++;\\n            i++, j--;\\n        }\\n        return c;\\n    }\\n    \\n    const dp = Array.from({ length: len }, () => {\\n        return new Array(k + 1).fill(-1);\\n    })\\n    \\n    const splitHelper = (idx = 0, sl = k) => {\\n        if(sl < 0) return Infinity;\\n        if(idx == len) {\\n            if(sl == 0) return 0;\\n            return Infinity;\\n        }\\n        \\n        if(dp[idx][sl] != -1) return dp[idx][sl];\\n        \\n        let ans = Infinity;\\n        \\n        for(let i = idx; i < len; i++) {\\n            ans = Math.min(ans, splitHelper(i + 1, sl - 1) + cost(idx, i));\\n        }\\n        return dp[idx][sl] = ans;\\n    }\\n    \\n    return splitHelper();\\n};", "var palindromePartition = function (s, k) {\\n  const n = s.length;\\n  const changes = new Array(n).fill().map((_) => new Array(n).fill());\\n  for (let i = 0; i < n; i++) changes[i][i] = 0;\\n\\n  for (let len = 2; len <= s.length; len++) {\\n    for (let i = 0; i + len <= s.length; i++) {\\n      const j = i + len - 1;\\n      changes[i][j] = getChanges(s, i, j);\\n    }\\n  }\\n\\n  const dp = new Array(k).fill().map((_) => new Array(n).fill(Infinity));\\n  dp[0] = changes[0].slice();\\n\\n  for (let split = 1; split < k; split++) {\\n    for (let i = 1; i < n; i++) {\\n      for (let j = i - 1; j >= 0; j--) {\\n        dp[split][i] = Math.min(\\n          dp[split][i],\\n          dp[split - 1][j] + changes[j + 1][i]\\n        );\\n      }\\n    }\\n  }\\n\\n  return dp[k - 1][n - 1];\\n};", "var palindromePartition = function (s, k) {\\n  const n = s.length;\\n  const changes = new Array(n).fill().map((_) => new Array(n).fill());\\n  for (let i = 0; i < n; i++) changes[i][i] = 0;\\n\\n  for (let len = 2; len <= s.length; len++) {\\n    for (let i = 0; i + len <= s.length; i++) {\\n      const j = i + len - 1;\\n      changes[i][j] = getChanges(s, i, j);\\n    }\\n  }\\n\\n  const dp = new Array(k).fill().map((_) => new Array(n).fill(Infinity));\\n  dp[0] = changes[0].slice();\\n\\n  for (let split = 1; split < k; split++) {\\n    for (let i = 1; i < n; i++) {\\n      for (let j = i - 1; j >= 0; j--) {\\n        dp[split][i] = Math.min(\\n          dp[split][i],\\n          dp[split - 1][j] + changes[j + 1][i]\\n        );\\n      }\\n    }\\n  }\\n\\n  return dp[k - 1][n - 1];\\n};"]}
{"id": "1972", "ref_js": ["var minFlips = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const target = \\'0\\'.repeat(m * n);\\n\\n    const convertToBinary = (matrix) => {\\n        let binaryString = \\'\\';\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                binaryString += matrix[i][j];\\n            }\\n        }\\n        return binaryString;\\n    };", "var minFlips = function(mat) {\\n\\n    const dp = {};", "var minFlips = function(mat) {\\n  const rows = mat.length;\\n  const cols = mat[0].length;\\n\\n  function getEncodedIndex(r, c) {\\n    return r * cols + c;\\n  }\\n  function getFlipOptions(r, c) {\\n    let result = POW2[getEncodedIndex(r,c)];\\n    DIRS.forEach(dir => {\\n      const nr = r + dir[0];\\n      const nc = c + dir[1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols)\\n        result ^= POW2[getEncodedIndex(nr,nc)];\\n    })\\n\\n    return result;\\n  }\\n\\n  let encoded = 0;\\n  const flipOptions = [];\\n  for (let r = 0; r < rows; r++) {\\n    for (let c = 0; c < cols; c++) {\\n      if (mat[r][c])\\n        encoded ^= POW2[getEncodedIndex(r,c)];\\n      const flipOption = getFlipOptions(r,c);\\n      if (!flipOptions.includes(flipOption))\\n        flipOptions.push(flipOption);\\n    }\\n  }\\n  if (!encoded) return 0;\\n\\n  function bfs(start) {\\n    const queue = [start];\\n    let bottom = 0;\\n    const visit = { [start]: 0 };"]}
{"id": "1973", "ref_js": ["var minFallingPathSum = function(grid) {\\n    var n = grid.length;\\n    \\n    for(var i=n-2; ~i; --i) {\\n        var one = two = Number.MAX_SAFE_INTEGER, oneI = n;\\n        for(var j=0; j<n; ++j) {\\n            if(grid[i+1][j] < one) two = one, one = grid[i+1][j], oneI = j;\\n            else if(grid[i+1][j] < two && j!==oneI) two = grid[i+1][j];\\n        }\\n        for(var j=0; j<n; ++j) {\\n            grid[i][j] += j === oneI ? two : one;\\n        }\\n    }\\n\\n    return Math.min(...grid[0]);\\n};", "var minFallingPathSum = function (grid) {\\n    let n = grid.length;\\n    let min = Infinity;\\n    let prev = new Array(n).fill(0);\\n\\n    for (let i = 0; i < n; i++) prev[i] = grid[0][i];\\n    \\n    for (let i = 1; i < n; i++) {\\n        let curr = [];\\n        for (let j = 0; j < n; j++) {\\n            let mini = Infinity;\\n            for (let k = 0; k < n; k++) {\\n                let value = Infinity;\\n                if (k != j) {\\n                    value = grid[i][j] + prev[k];\\n                    mini = Math.min(mini, value);\\n                }\\n            }\\n            curr[j] = mini;\\n        }\\n        prev = curr;\\n    }\\n\\n    min = Math.min(...prev);\\n    \\n    return min;\\n};", "var minFallingPathSum = function(arr) {\\n    let len = arr.length;\\n\\n    for (let i = 1; i < len; ++i) {\\n        let mins = { min: Number.POSITIVE_INFINITY, min2: Number.POSITIVE_INFINITY };"]}
{"id": "1974", "ref_js": ["var shortestPath = function(grid, k) {\\n    \\n    \\n    ", "var shortestPath = function(grid, k) {\\n    let visited = new Set()\\n    let queue = [[0,0,k,0]]", "var shortestPath = function(grid, k) {\\n    \\n    \\n    "]}
{"id": "1975", "ref_js": ["var maxCandies = function (status, candies, keys, containedBoxes, initialBoxes) {\\n\\n    let totalCandies = 0;\\n    let myKeys = new Set();\\n\\n    function OpenBoxes(initialBoxes) {\\n        let queue = initialBoxes;\\n        let closedBoxes = []\\n\\n        while (queue.length > 0) {\\n            const boxNum = queue.pop();\\n\\n            if (status[boxNum] === 1 || myKeys.has(boxNum)) {\\n                totalCandies += candies[boxNum]\\n                queue.push(...containedBoxes[boxNum])\\n                keys[boxNum].forEach(k => myKeys.add(k))\\n            } else {\\n                ", "var maxCandies = function (\\n  status,\\n  candies,\\n  keys,\\n  containedBoxes,\\n  initialBoxes\\n) {\\n  const closedBox = new Set([]);\\n  const keysToOpen = new Set([]);\\n  const queue = [];\\n\\n  for (const box of initialBoxes) {\\n    if (status[box] === 1) {\\n      queue.push(box);\\n    } else {\\n      closedBox.add(box);\\n    }\\n  }\\n\\n  let ans = 0;\\n  while (queue.length) {\\n    const currBox = queue.shift();\\n    ans += candies[currBox];\\n\\n    for (const box of containedBoxes[currBox]) {\\n      if (status[box] === 1) {\\n        queue.push(box);\\n      } else if (keysToOpen.has(box)) {\\n        keysToOpen.delete(box);\\n        queue.push(box);\\n      } else {\\n        closedBox.add(box);\\n      }\\n    }\\n\\n    for (const key of keys[currBox]) {\\n      if (closedBox.has(key)) {\\n        closedBox.delete(key);\\n        queue.push(key);\\n      } else {\\n        keysToOpen.add(key);\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};", "var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {\\n  "]}
{"id": "1976", "ref_js": ["var pathsWithMaxScore=function(r){let t=1e9+7,e=r.length,l=Array.from({length:e},()=>Array(e).fill(0)),f=Array.from({length:e},()=>Array(e).fill(0));f[e-1][e-1]=1;for(let a=e-1;a>=0;a--)for(let o=e-1;o>=0;o--)if(\"X\"!=r[a][o]&&0!==f[a][o])for(let[e,n]of[[1,0],[0,1],[1,1]]){let i=a-e,h=o-n;if(i>=0&&h>=0&&\"X\"!=r[i][h]){let e=\"E\"==r[i][h]?0:parseInt(r[i][h]),n=(l[a][o]+e)%t;n>l[i][h]?(l[i][h]=n,f[i][h]=f[a][o]):n==l[i][h]&&(f[i][h]=(f[i][h]+f[a][o])%t)}}return[l[0][0],f[0][0]]};", "var pathsWithMaxScore = function(board) {\\n    const n = board.length, m = board[0].length, mod = 1_000_000_007;\\n    let prev = Array.from({ length: m + 1 }, () => [0, 0]);\\n\\n    prev[0][1] = 1;\\n\\n    for (let i = 0; i < n; i < i++) {\\n        const cur = Array.from({ length: m + 1 }, () => [0, 0]);\\n\\n        for (let j = 0; j < m; j++) {\\n            if (board[i][j] == \"X\") continue;\\n\\n            const prevPositions = [prev[j], prev[j + 1], cur[j]];\\n            const maxPrevSum = Math.max(...prevPositions.map(([sum]) => sum));            \\n            cur[j + 1] = prevPositions.reduce((acc, [sum, ways]) => \\n                    (sum === maxPrevSum ? [sum, (acc[1] + ways) % mod] : acc), [0, 0]);\\n            if (cur[j + 1][1] > 0)\\n                cur[j + 1][0] += isNaN(board[i][j]) ? 0 : +board[i][j];\\n        }\\n\\n        prev = cur;\\n    }\\n\\n    return prev.at(-1);\\n};", "var pathsWithMaxScore = function (board) {\\n  const MOD = 1000000007;\\n  const n = board.length;\\n\\n  const maxRow = Array(n).fill(0);\\n  maxRow[-1] = 0;\\n  const cntRow = Array(n).fill(0);\\n  cntRow[-1] = 0;\\n\\n  function getVal(r, c) {\\n    const char = board[r][c];\\n    if (char >= \"0\" && char <= \"9\") return char.charCodeAt() - 48;\\n    return 0;\\n  }\\n\\n  let maxBak, cntBak, maxCur, cntCur;\\n  for (let r = 0; r < n; r++) {\\n    maxCur = 0;\\n    cntCur = 0;\\n\\n    for (let c = 0; c < n; c++) {\\n      maxBak = maxCur;\\n      cntBak = cntCur;\\n      maxCur = maxRow[c];\\n      cntCur = cntRow[c];\\n      const v = getVal(r, c);\\n\\n      if (board[r][c] === \"E\") {\\n        cntRow[c] = 1;\\n        maxRow[c] = v;\\n        continue;\\n      }\\n      if (board[r][c] === \"X\" || !(cntRow[c] || cntRow[c-1] || cntBak)) {\\n        cntRow[c] = 0;\\n        maxRow[c] = 0;\\n        continue;\\n      }\\n\\n      if (maxRow[c] < maxRow[c-1]) {\\n        cntRow[c] = cntRow[c-1];\\n        maxRow[c] = maxRow[c-1];\\n      } else if (maxRow[c] === maxRow[c-1]) {\\n        cntRow[c] = (cntRow[c] + cntRow[c-1]) % MOD;\\n      }\\n\\n      if (maxRow[c] < maxBak) {\\n        cntRow[c] = cntBak;\\n        maxRow[c] = maxBak;\\n      } else if (maxRow[c] === maxBak) {\\n        cntRow[c] = (cntRow[c] + cntBak) % MOD;\\n      }\\n\\n      maxRow[c] += v;\\n    }\\n  }\\n\\n  return [maxRow[n - 1], cntRow[n - 1]];\\n};"]}
{"id": "1977", "ref_js": ["var isSolvable = function(words, result) {\\n  ", "var isSolvable = function(words, result) {\\n  ", "var isSolvable = function(words, result) {\\n  "]}
{"id": "1978", "ref_js": ["var minInsertions = function(s) {\\n    const n = s.length;\\n    const dp = new Array(n).fill(0);\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        let prev = 0;\\n\\n        for (let j = i + 1; j < n; j++) {\\n            const temp = dp[j];\\n\\n            if (s[i] === s[j]) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n            }\\n\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n-1];    \\n};", "var minInsertions = function(s) {\\n    ", "var minInsertions = function(s) {\\n    "]}
{"id": "1979", "ref_js": ["var distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};", "var distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};", "var distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};"]}
{"id": "1980", "ref_js": ["var minimumDistance = function (word) {\\n  const map = {};", "var minimumDistance = function(word) {\\nfunction helper(i, j, k){\\n        if(i == word.length) return 0;\\n        let x =  (word.charCodeAt(i)-65) / 6 >>0;\\n        let y =  (word.charCodeAt(i)-65) % 6;\\n        if(dp[i][j][k] != undefined) return dp[i][j][k];\\n        ", "var minimumDistance = function(word) {\\n  const chars = new Set(word.split(\\'\\'))\\n  const cache = new Array(word.length);\\n  for (let i = 0; i < cache.length; i++) cache[i] = {};"]}
{"id": "1981", "ref_js": ["var minTaps = function(n, ranges) {\\n   const intervals = []\\n\\n   for (let i = 0; i <= n; i++){\\n        const [start, end] = [Math.max(0, i - ranges[i]), Math.min(n, i + ranges[i])];\\n        intervals.push([start, end]);\\n   }\\n\\n   intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n\\n   let currentInterval = 0\\n   let farthestReach = 0\\n   let tapsUsed = 0\\n\\n\\n   while(farthestReach < n){\\n       const farthestCovered = farthestReach\\n       while(currentInterval < intervals.length && intervals[currentInterval][0] <= farthestCovered){\\n           farthestReach = Math.max(farthestReach, intervals[currentInterval][1])\\n           currentInterval += 1\\n       }\\n\\n        if(farthestCovered === farthestReach) return - 1\\n        tapsUsed += 1\\n   }\\n\\n    return tapsUsed\\n};", "var minTaps = function(n, ranges) {\\n   const intervals = []\\n\\n   for (let i = 0; i <= n; i++){\\n        const [start, end] = [Math.max(0, i - ranges[i]), Math.min(n, i + ranges[i])];\\n        intervals.push([start, end]);\\n   }\\n\\n   intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n\\n   let currentInterval = 0\\n   let farthestReach = 0\\n   let tapsUsed = 0\\n\\n\\n   while(farthestReach < n){\\n       const farthestCovered = farthestReach\\n       while(currentInterval < intervals.length && intervals[currentInterval][0] <= farthestCovered){\\n           farthestReach = Math.max(farthestReach, intervals[currentInterval][1])\\n           currentInterval += 1\\n       }\\n\\n        if(farthestCovered === farthestReach) return - 1\\n        tapsUsed += 1\\n   }\\n\\n    return tapsUsed\\n};", "var minTaps = function(n, ranges) {\\n   const intervals = []\\n\\n   for (let i = 0; i <= n; i++){\\n        const [start, end] = [Math.max(0, i - ranges[i]), Math.min(n, i + ranges[i])];\\n        intervals.push([start, end]);\\n   }\\n\\n   intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n\\n   let currentInterval = 0\\n   let farthestReach = 0\\n   let tapsUsed = 0\\n\\n\\n   while(farthestReach < n){\\n       const farthestCovered = farthestReach\\n       while(currentInterval < intervals.length && intervals[currentInterval][0] <= farthestCovered){\\n           farthestReach = Math.max(farthestReach, intervals[currentInterval][1])\\n           currentInterval += 1\\n       }\\n\\n        if(farthestCovered === farthestReach) return - 1\\n        tapsUsed += 1\\n   }\\n\\n    return tapsUsed\\n};"]}
{"id": "1982", "ref_js": ["var maxValueAfterReverse = function (nums) {\\n  let n = nums.length;\\n  let incMax1st;\\n  let incMin2nd;\\n  let decMin1st;\\n  let decMax2nd;\\n\\n  let sum = 0;\\n  let best = 0;\\n\\n  function getDelta(i, j) {\\n    return (\\n      abs(nums[i] - nums[j]) +\\n      abs(nums[i + 1] - nums[j + 1]) -\\n      abs(nums[i] - nums[i + 1]) -\\n      abs(nums[j] - nums[j + 1])\\n    );\\n  }\\n\\n  let first = nums[0];\\n  let last = nums[--n];\\n  for (let i = 0; i < n; ++i) {\\n    sum += abs(nums[i] - nums[i + 1]);\\n    best = max(\\n      best,\\n      max(abs(last - nums[i]), abs(first - nums[i + 1])) -\\n        abs(nums[i + 1] - nums[i])\\n    );\\n\\n    if (incMax1st != null) best = max(best, getDelta(incMax1st, i));\\n    if (incMin2nd != null) best = max(best, getDelta(incMin2nd, i));\\n    if (decMin1st != null) best = max(best, getDelta(decMin1st, i));\\n    if (decMax2nd != null) best = max(best, getDelta(decMax2nd, i));\\n\\n    if (nums[i] <= nums[i+1]) {\\n      if (incMax1st == null || nums[incMax1st] < nums[i]) incMax1st = i;\\n      if (incMin2nd == null || nums[incMin2nd+1] > nums[i+1]) incMin2nd = i;\\n    }\\n    if (nums[i] >= nums[i+1]) {\\n      if (decMin1st == null || nums[decMin1st] > nums[i]) decMin1st = i;\\n      if (decMax2nd == null || nums[decMax2nd+1] < nums[i+1]) decMax2nd = i;\\n    }\\n  }\\n\\n  return sum + best;\\n};", "var maxValueAfterReverse = function (nums) {\\n  let n = nums.length;\\n  let incMax1st;\\n  let incMin2nd;\\n  let decMin1st;\\n  let decMax2nd;\\n\\n  let sum = 0;\\n  let best = 0;\\n\\n  function getDelta(i, j) {\\n    return (\\n      abs(nums[i] - nums[j]) +\\n      abs(nums[i + 1] - nums[j + 1]) -\\n      abs(nums[i] - nums[i + 1]) -\\n      abs(nums[j] - nums[j + 1])\\n    );\\n  }\\n\\n  let first = nums[0];\\n  let last = nums[--n];\\n  for (let i = 0; i < n; ++i) {\\n    sum += abs(nums[i] - nums[i + 1]);\\n    best = max(\\n      best,\\n      max(abs(last - nums[i]), abs(first - nums[i + 1])) -\\n        abs(nums[i + 1] - nums[i])\\n    );\\n\\n    if (incMax1st != null) best = max(best, getDelta(incMax1st, i));\\n    if (incMin2nd != null) best = max(best, getDelta(incMin2nd, i));\\n    if (decMin1st != null) best = max(best, getDelta(decMin1st, i));\\n    if (decMax2nd != null) best = max(best, getDelta(decMax2nd, i));\\n\\n    if (nums[i] <= nums[i+1]) {\\n      if (incMax1st == null || nums[incMax1st] < nums[i]) incMax1st = i;\\n      if (incMin2nd == null || nums[incMin2nd+1] > nums[i+1]) incMin2nd = i;\\n    }\\n    if (nums[i] >= nums[i+1]) {\\n      if (decMin1st == null || nums[decMin1st] > nums[i]) decMin1st = i;\\n      if (decMax2nd == null || nums[decMax2nd+1] < nums[i+1]) decMax2nd = i;\\n    }\\n  }\\n\\n  return sum + best;\\n};", "var maxValueAfterReverse = function (nums) {\\n  let n = nums.length;\\n  let incMax1st;\\n  let incMin2nd;\\n  let decMin1st;\\n  let decMax2nd;\\n\\n  let sum = 0;\\n  let best = 0;\\n\\n  function getDelta(i, j) {\\n    return (\\n      abs(nums[i] - nums[j]) +\\n      abs(nums[i + 1] - nums[j + 1]) -\\n      abs(nums[i] - nums[i + 1]) -\\n      abs(nums[j] - nums[j + 1])\\n    );\\n  }\\n\\n  let first = nums[0];\\n  let last = nums[--n];\\n  for (let i = 0; i < n; ++i) {\\n    sum += abs(nums[i] - nums[i + 1]);\\n    best = max(\\n      best,\\n      max(abs(last - nums[i]), abs(first - nums[i + 1])) -\\n        abs(nums[i + 1] - nums[i])\\n    );\\n\\n    if (incMax1st != null) best = max(best, getDelta(incMax1st, i));\\n    if (incMin2nd != null) best = max(best, getDelta(incMin2nd, i));\\n    if (decMin1st != null) best = max(best, getDelta(decMin1st, i));\\n    if (decMax2nd != null) best = max(best, getDelta(decMax2nd, i));\\n\\n    if (nums[i] <= nums[i+1]) {\\n      if (incMax1st == null || nums[incMax1st] < nums[i]) incMax1st = i;\\n      if (incMin2nd == null || nums[incMin2nd+1] > nums[i+1]) incMin2nd = i;\\n    }\\n    if (nums[i] >= nums[i+1]) {\\n      if (decMin1st == null || nums[decMin1st] > nums[i]) decMin1st = i;\\n      if (decMax2nd == null || nums[decMax2nd+1] < nums[i+1]) decMax2nd = i;\\n    }\\n  }\\n\\n  return sum + best;\\n};"]}
{"id": "1983", "ref_js": ["var minDifficulty = function(jobDifficulty, d) {\\n  ", "var minDifficulty = function(jobDifficulty, d) {\\n  ", "var minDifficulty = function(jobDifficulty, d) {\\n  "]}
{"id": "1984", "ref_js": ["var maxJumps = function(arr, d) {\\n  ", "var maxJumps = function(arr, d) {\\n  ", "var maxJumps = function(arr, d) {\\n  "]}
{"id": "1985", "ref_js": ["var minJumps = function(arr) {\\n    let n = arr.length\\n    let map = new Map()\\n    for (let i = 0; i < n; i++) {\\n        let array = []\\n        if (map.has(arr[i])) array = map.get(arr[i])\\n        array.push(i)\\n        map.set(arr[i], array)\\n    }\\n\\n    let visited = new Set()\\n    let queue = [[0,0]]\\n    visited.add(0)\\n\\n    while (queue.length) {\\n        let [cur, step] = queue.shift()\\n        if (cur == n-1) return step\\n\\n        if (cur + 1 < n && !visited.has(cur+1)) {\\n            queue.push([cur+1, step+1])\\n            visited.add(cur+1)\\n        }\\n\\n        if (cur - 1 >= 0 && !visited.has(cur-1)) {\\n            queue.push([cur-1, step+1])\\n            visited.add(cur-1)\\n        }\\n        if (!map.has(arr[cur])) continue\\n        for (let idx of map.get(arr[cur])) {\\n            if (!visited.has(idx) && idx != cur) {\\n                queue.push([idx, step+1])\\n                visited.add(idx)\\n            }\\n        }  \\n\\n        map.delete(arr[cur])      \\n    }\\n    return -1\\n};", "var minJumps = function(arr) {\\n    const n = arr.length;\\n    if (n === 1) return 0; ", "var minJumps = function(arr) {\\n    const n = arr.length;\\n    if (n === 1) return 0; "]}
{"id": "1986", "ref_js": ["var maxStudents = function (seats) {\\n  const m = seats.length;\\n  const n = seats[0].length;\\n  const fullMask = (1 << n) - 1;\\n\\n  const bannedSeats = seats.map((s) => convertToBannedState(s));\\n  pre.fill(0, 0, 1 << n);\\n  let res = 0;\\n\\n  for (let i = m - 1; i >= 0; i--) {\\n    for (let curState = 0; curState <= fullMask; curState++) {\\n      if (curState & bannedSeats[i] || curState & (curState >> 1)) {\\n        cur[curState] = 0;\\n        continue;\\n      }\\n\\n      const t = count1s(curState);\\n      cur[curState] = 0;\\n      for (let preState = 0; preState <= fullMask; preState++) {\\n        if (pre[preState] <= cur[curState]) continue;\\n        if ((preState << 1) & curState) continue;\\n        if ((preState >> 1) & curState) continue;\\n        cur[curState] = pre[preState];\\n      }\\n      cur[curState] += t;\\n      res = Math.max(res, cur[curState]);\\n    }\\n    let tem = pre;\\n    pre = cur;\\n    cur = tem;\\n  }\\n\\n  return res;\\n};", "var maxStudents = function(seats) {\\n    if (!seats.length) return 0;\\n    \\n\\t", "var maxStudents = function(seats) {\\n    if (!seats.length) return 0;\\n    \\n\\t"]}
{"id": "1987", "ref_js": ["var isPossible = function(target) {\\n    let pq = new MaxPriorityQueue({priority: x => x}), sum = 0\\n    for (let num of target) sum += num, pq.enqueue(num)\\n    while (pq.front().element !== 1) {\\n        let num = pq.dequeue().element\\n        sum -= num\\n        if (num <= sum || sum < 1) return false\\n        num %= sum, sum += num, pq.enqueue(num || sum)\\n    }\\n    return true\\n};", "var isPossible = function(target) {\\n    let max=0\\n    let index=-1\\n    \\n    for(let i=target.length-1;i>=0;i--){\\n        if(target[i]>max){\\n            max=target[i]\\n            index=i\\n        }\\n    }\\n    if(max===1)return true ", "var isPossible = function(T) {\\n  if (T.length === 1 && T[0] !== 1) return false\\n  let sum = T.reduce((a, b) => a + b)\\n  T.sort((a, b) => b - a)\\n\\n  while (sum !== T.length) {\\n    let m = T[0] - (sum - T[0]) * (Math.trunc(T[0] / (sum - T[0]) - 1) || 1);\\n    [sum, T[0]] = [sum - T[0] + m, m]\\n    if (T[0] < 1) return false\\n    for (let i = 0; T[i] < T[i+1]; i++) [T[i], T[i+1]] = [T[i+1], T[i]]\\n  }\\n  \\n  return true\\n};"]}
{"id": "1988", "ref_js": ["var countOrders = function(n) {\\n    const MOD = 1000000007;\\n    let totalWays = 1;\\n    for (let orderNumber = 2; orderNumber <= n; orderNumber++) {\\n        totalWays = (totalWays * (2 * orderNumber - 1) * orderNumber) % MOD;\\n    }\\n    return totalWays;    \\n};", "var countOrders = function(n) {\\n    const MOD = 1000000007;\\n    let totalWays = 1;\\n    for (let orderNumber = 2; orderNumber <= n; orderNumber++) {\\n        totalWays = (totalWays * (2 * orderNumber - 1) * orderNumber) % MOD;\\n    }\\n    return totalWays;    \\n};", "var countOrders = function(n) {\\n    const MOD = 1000000007;\\n    let totalWays = 1;\\n    for (let orderNumber = 2; orderNumber <= n; orderNumber++) {\\n        totalWays = (totalWays * (2 * orderNumber - 1) * orderNumber) % MOD;\\n    }\\n    return totalWays;    \\n};"]}
{"id": "1989", "ref_js": ["var largestMultipleOfThree = function(digits) {\\n    const arr = new Array(10).fill(0)\\n    for (const d of digits) arr[d]++\\n    const t = arr.reduce((a, v, i) => a + v * (i % 3), 0) % 3\\n    function sub (n) {\\n        for (const i of [n, n+3, n+6])\\n            if (arr[i] > 0) return arr[i]--\\n    }\\n    if (t && !sub(t) && (!sub(3 - t) || !sub(3 - t))) return \\'\\' \\n    const ans = arr.reduceRight((a, v, i) => a + String(i).repeat(v), \\'\\')\\n    return ans[0] === \\'0\\' ? \\'0\\' : ans\\n};", "var largestMultipleOfThree = function(digits) {\\n    const dictionary = Object.freeze(new Map(Object.entries(lodash.groupBy(digits, _ => _ % 3)).map(([key, value]) => [Number(key), value.sort((a, b) => a - b)])))\\n    const d1 = Object.freeze(dictionary.has(1) ? dictionary.get(1) : [])\\n    const d2 = Object.freeze(dictionary.has(2) ? dictionary.get(2) : [])\\n    const d0 = Object.freeze(dictionary.has(0) ? dictionary.get(0) : [])\\n    let result = null\\n    switch (digits.reduce((a, b) => a + b) % 3)\\n    {\\n        case 1: result = d1.length ? [...d1.slice(1), ...d2, ...d0] : [...d2.slice(2), ...d0]; break\\n        case 2: result = d2.length ? [...d1, ...d2.slice(1), ...d0] : [...d1.slice(2), ...d0]; break\\n        default: result = digits\\n    }\\n    result = result.sort((a, b) => b - a).join(\\'\\')\\n    return result ? BigInt(result).toString() : \\'\\'\\n};", "var largestMultipleOfThree = function(digits) {\\n    "]}
{"id": "1990", "ref_js": ["var minCost = function (grid) {\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  const dirs = {\\n    1: [0, 1],\\n    2: [0, -1],\\n    3: [1, 0],\\n    4: [-1, 0],\\n  };", "var minCost = function(grid) {\\n  ", "var minCost = function (grid) {\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  const dirs = {\\n    1: [0, 1],\\n    2: [0, -1],\\n    3: [1, 0],\\n    4: [-1, 0],\\n  };"]}
{"id": "1991", "ref_js": ["var maxSumBST = function (root) {\\n  let maxSum = 0;\\n  function dfs(r) {\\n    if (!r) return [true, Infinity, -Infinity, 0];\\n    const [islbst, lmin, lmax, lsum] = dfs(r.left);\\n    const [isRBST, RMIN, RMAX, RSUM] = dfs(r.right);\\n    if (islbst && isRBST && lmax < r.val && r.val < RMIN) {\\n      const sum = r.val + lsum + RSUM;\\n      maxSum = Math.max(maxSum, sum);\\n      return [true, Math.min(lmin, r.val), Math.max(r.val, RMAX), sum];\\n    }\\n    return [false];\\n  }\\n  dfs(root);\\n  return maxSum;\\n};", "var maxSumBST = function (root) {\\n    let maxSum = 0;\\n\\n    function helper(node) {\\n        if (node === null) {\\n            return { isBST: true, min: Infinity, max: -Infinity, sum: 0 };", "var maxSumBST = function (root) {\\n    let maxSum = 0;\\n\\n    function helper(node) {\\n        if (node === null) {\\n            return { isBST: true, min: Infinity, max: -Infinity, sum: 0 };"]}
{"id": "1992", "ref_js": ["var frogPosition = function (n, edges, t, target) {\\n  const g = Array.from({ length: n + 1 }, () => []);\\n  edges.forEach(([p, c, w = 1]) => {\\n    g[p].push([c, w]);\\n    g[c].push([p, w]);\\n  });\\n  let finalProbability;\\n  const preOrder = (p, gp = -1, probability = 1, time = t) => {\\n    if (finalProbability !== undefined) return;\\n    if (time < 0) return;\\n    const childNodes = g[p].filter(([c]) => c !== gp);\\n    if (p === target) {\\n      finalProbability = probability;\\n      if (time !== 0 && childNodes.length > 0) {\\n        finalProbability = 0;\\n      }\\n      return;\\n    }\\n    for (let [c] of childNodes) {\\n      preOrder(c, p, probability / childNodes.length, time - 1);\\n    }\\n  };", "var frogPosition = function(n, edges, t, target) {\\n  ", "var frogPosition = function(n, conns, t, target) {\\n    \\n    "]}
{"id": "1993", "ref_js": ["var maxPerformance = function(n, speed, efficiency, k) {\\n    const MOD =  BigInt(10**9 + 7);\\n\\n\\tconst engineers = speed.map((s, i) => [efficiency[i], s]);\\n\\tengineers.sort((a, b) => b[0] - a[0]); ", "var maxPerformance = function(n, speed, efficiency, k) {\\n    let ord = Array.from({length: n}, (_,i) => i)\\n    ord.sort((a,b) => efficiency[b] - efficiency[a])\\n    let sppq = new MinPriorityQueue(),\\n        totalSpeed = 0n, best = 0n\\n    for (let eng of ord) {\\n        sppq.enqueue(speed[eng])\\n        if (sppq.size() <= k) totalSpeed += BigInt(speed[eng])\\n        else totalSpeed += BigInt(speed[eng] - sppq.dequeue().element)\\n        let res = totalSpeed * BigInt(efficiency[eng])\\n        if (res > best) best = res\\n    }\\n    return best % 1000000007n\\n};", "var maxPerformance = function(n, speed, efficiency, k) {\\n  const MOD =  BigInt(10**9 + 7);\\n  const candidates = speed.map((s, i) => [efficiency[i], s]);\\n  candidates.sort((a, b) => b[0] - a[0]);\\n  const pq = new MinPriorityQueue({ compare: (x, y) => x - y });\\n  \\n  let res = BigInt(0), speedSum = 0;\\n  for (const [e, s] of candidates) {\\n    if (pq.size() === k) speedSum -= pq.dequeue();\\n    \\n    pq.enqueue(s);\\n    speedSum += s;\\n    const cur = BigInt(speedSum) * BigInt(e);\\n    if (cur > res) res = cur;\\n  }\\n  \\n  return res % MOD;\\n};"]}
{"id": "1994", "ref_js": ["var maxSizeSlices = function(slices) {\\n\\n    ", "var maxSizeSlices = function(slices) {\\n    const numSlices = slices.length / 3;\\n    const len = slices.length - 1;\\n    \\n    const dp = new Array(len).fill(null).map(() => new Array(numSlices + 1).fill(0));\\n    const getMaxTotalSlices = (pieces) => {\\n\\t    ", "var maxSizeSlices = function(slices) {\\n    const numSlices = slices.length / 3;\\n    const len = slices.length - 1;\\n    \\n    const dp = new Array(len).fill(null).map(() => new Array(numSlices + 1).fill(0));\\n    const getMaxTotalSlices = (pieces) => {\\n\\t    "]}
{"id": "1995", "ref_js": ["var longestPrefix = function(s) {\\n    let b = s.length;\\n    let t = 0;\\n    let p = \"\";\\n    for(let i = 0;i<s.length-1;i++){\\n        if(s.slice(0,i+1)==s.slice(b-1-i)){\\n            if(i+1>t){\\n                p = s.slice(0,i+1);\\n                t = i+1;    \\n            }\\n        }\\n    }\\n    return p\\n};", "var longestPrefix = function (s) {\\n  for (let i = 1; i < s.length; i++) {\\n    let a = s.slice(i);\\n    let b = s.slice(0, s.length - i);\\n    if (a === b) {\\n      return a;\\n    }\\n  }\\n\\n  return \"\";\\n};", "var longestPrefix = function (s) {\\n  for (let i = 1; i < s.length; i++) {\\n    let a = s.slice(i);\\n    let b = s.slice(0, s.length - i);\\n    if (a === b) {\\n      return a;\\n    }\\n  }\\n\\n  return \"\";\\n};"]}
{"id": "1996", "ref_js": ["var findGoodStrings = function(n, s1, s2, evil) {\\n    const evilLen = evil.length;\\n    const mod = 1000000007\\n    const kmp = buildKmpArray(evil);\\n    \\n    const cache = {};", "var findGoodStrings = function(n, s1, s2, evil) {\\n    const evilLen = evil.length;\\n    const mod = 1000000007\\n    const kmp = buildKmpArray(evil);\\n    \\n    const cache = {};", "var findGoodStrings = function(n, s1, s2, evil) {\\n    const evilLen = evil.length;\\n    const mod = 1000000007\\n    const kmp = buildKmpArray(evil);\\n    \\n    const cache = {};"]}
{"id": "1997", "ref_js": ["var maxSatisfaction = function(satisfaction) {\\n    satisfaction.sort((a, b) => b - a);\\n    let max, cur, sum;\\n    max = cur = sum = 0;\\n    for(let level of satisfaction) {\\n        sum += level;\\n        cur += sum;\\n        max = Math.max(max, cur);\\n    }\\n    return max;\\n};", "var maxSatisfaction = function (satisfactions) {\\n  ", "var maxSatisfaction = function(satisfaction) {\\n    let answer = -Infinity\\n    const len = satisfaction.length\\n    satisfaction.sort((a,b) => a-b)\\n    \\n    let left = 0, right = len\\n    \\n    while(left < right) {\\n        const mid = (right + left) >>> 1\\n        \\n        const l = getpoint(mid)\\n        const r = getpoint(mid + 1)\\n\\n        if (l > r) {\\n            answer = Math.max(answer, l)\\n            right = mid\\n        } else {\\n            answer = Math.max(answer, r)\\n            left = mid + 1 \\n        }\\n\\n    }\\n    function getpoint(mid) {\\n        let res = 0\\n        let j = 1\\n        for (let i = mid; i < len; i++) {\\n            res += (satisfaction[i] * j)\\n            j += 1\\n        }\\n        return res\\n    }\\n    return answer < 0 ? 0 : answer\\n};"]}
{"id": "1998", "ref_js": ["var stoneGameIII = function (stoneValue) {\\n    const n = stoneValue.length;\\n    const dp = new Array(n + 1).fill(0); ", "var stoneGameIII = function (stoneValue) {\\n    const n = stoneValue.length;\\n    const dp = new Array(n + 1).fill(0); ", "var stoneGameIII = function (stoneValue) {\\n    const n = stoneValue.length;\\n    const dp = new Array(n + 1).fill(0); "]}
{"id": "1999", "ref_js": ["var numOfWays = function(n) {\\n  const MOD = 1000000007;\\n  let biColor = 6;\\n  let triColor = 6;\\n\\n  while (--n) {\\n    triColor = (((triColor + biColor) % MOD) * 2) % MOD;\\n    biColor = (biColor + triColor) % MOD;\\n  }\\n\\n  return (biColor + triColor) % MOD;\\n};", "var numOfWays = function(n) {\\n    const MOD = Math.pow(10, 9) + 7;\\n    let prev123 = 6, prev121 = 6, total = 12;\\n    for (let i = 2; i <= n; i++) {\\n        let cur123 = (prev123 * 2 + prev121 * 2) % MOD;\\n        let cur121 = (prev123 * 2 + prev121 * 3) % MOD;\\n        total = (cur123 + cur121) % MOD;\\n        prev123 = cur123;\\n        prev121 = cur121;\\n    }\\n    return total;\\n    ", "var numOfWays = function(n) {\\n  const MOD = 1000000007;\\n  let biColor = 6;\\n  let triColor = 6;\\n\\n  while (--n) {\\n    triColor = (((triColor + biColor) % MOD) * 2) % MOD;\\n    biColor = (biColor + triColor) % MOD;\\n  }\\n\\n  return (biColor + triColor) % MOD;\\n};"]}
{"id": "2000", "ref_js": ["var numberOfArrays = function(s, k) \\n{\\n    const MOD = 1e9+7;\\n    let ways = Array(11);\\n\\n    \\n    ways[0] = 1;\\n    for(let i=s.length-1; i>=0; i--)\\n    {\\n        \\n        for(let j=ways.length-1; j>0; j--)\\n            ways[j] = ways[j-1];\\n\\n        if(s[i] === \\'0\\')\\n        {\\n            ways[0] = 0;\\n            continue;\\n        }\\n\\n        \\n        let num = 0, newWays = 0;\\n        for(let j=i; j<s.length; j++)\\n        {\\n            num = num*10+(s[j]-0);\\n            if(num > k)\\n                break;\\n            newWays = (newWays + ways[j+1-i])%MOD;\\n        }\\n        ways[0] = newWays;\\n    }\\n\\n    return ways[0];\\n};", "var numberOfArrays = function(s, k) {\\n    var n = s.length;\\n    var dp = new Array(n+1).fill(0); ", "var numberOfArrays = function(s, k) {\\n    var n = s.length;\\n    var dp = new Array(n+1).fill(0); "]}
{"id": "2001", "ref_js": ["var Solution = function() {\\n    this.dp = new Array(51).fill(null).map(() =>\\n        new Array(51).fill(null).map(() => new Array(101).fill(-1))\\n    );\\n    this.n = 0;\\n    this.m = 0;\\n    this.k = 0;\\n};", "var numOfArrays = function(n, m, k) {\\n    const cache = {};", "var Solution = function() {\\n    this.dp = new Array(51).fill(null).map(() =>\\n        new Array(51).fill(null).map(() => new Array(101).fill(-1))\\n    );\\n    this.n = 0;\\n    this.m = 0;\\n    this.k = 0;\\n};"]}
{"id": "2002", "ref_js": ["var constrainedSubsetSum = function(nums, k) {\\n    const q = [];\\n    let res = -Infinity;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        const total = num + (q.length > 0 ? q[0][1] : 0);\\n        res = Math.max(res, total);\\n\\n        while (q.length > 0 && total >= q[q.length - 1][1]) {\\n            q.pop();\\n        }\\n\\n        if (total > 0) {\\n            q.push([i, total]);\\n        }\\n\\n        if (q.length > 0 && q[0][0] === i - k) {\\n            q.shift();\\n        }\\n    }\\n\\n    return res;    \\n};", "var constrainedSubsetSum = function(nums, k) {\\n    let maxSum = nums[0];\\n    const dp = [nums[0]];\\n    const maxHeap = [nums[0]];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        while (maxHeap.length > 0 && i - maxHeap[0][1] > k) {\\n            maxHeap.shift();\\n        }\\n        const current = Math.max(nums[i], nums[i] + (maxHeap.length > 0 ? maxHeap[0][0] : 0));\\n        maxSum = Math.max(maxSum, current);\\n        dp.push(current);\\n        while (maxHeap.length > 0 && dp[i] >= maxHeap[maxHeap.length - 1][0]) {\\n            maxHeap.pop();\\n        }\\n        maxHeap.push([dp[i], i]);\\n    }\\n\\n    return maxSum;\\n};", "var constrainedSubsetSum = function(nums, k) {\\n    const q = [];\\n    let res = -Infinity;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        const total = num + (q.length > 0 ? q[0][1] : 0);\\n        res = Math.max(res, total);\\n\\n        while (q.length > 0 && total >= q[q.length - 1][1]) {\\n            q.pop();\\n        }\\n\\n        if (total > 0) {\\n            q.push([i, total]);\\n        }\\n\\n        if (q.length > 0 && q[0][0] === i - k) {\\n            q.shift();\\n        }\\n    }\\n\\n    return res;    \\n};"]}
{"id": "2003", "ref_js": ["var numberWays = function(pplsPrefferedHats) {\\n    \\n    const pplThatCanWearHats = new Array(40 + 1).fill(null).map(() => [])\\n    for (let i = 0; i < pplsPrefferedHats.length; i++) {\\n        const personMask = 1 << i;\\n        for (let hat of pplsPrefferedHats[i]) {\\n            pplThatCanWearHats[hat].push(personMask);\\n        }\\n    }\\n\\n    const cache = {};", "var numberWays = function(pplsPrefferedHats) {\\n    \\n    const pplThatCanWearHats = new Array(40 + 1).fill(null).map(() => [])\\n    for (let i = 0; i < pplsPrefferedHats.length; i++) {\\n        const personMask = 1 << i;\\n        for (let hat of pplsPrefferedHats[i]) {\\n            pplThatCanWearHats[hat].push(personMask);\\n        }\\n    }\\n\\n    const cache = {};", "var numberWays = function(pplsPrefferedHats) {\\n    \\n    const pplThatCanWearHats = new Array(40 + 1).fill(null).map(() => [])\\n    for (let i = 0; i < pplsPrefferedHats.length; i++) {\\n        const personMask = 1 << i;\\n        for (let hat of pplsPrefferedHats[i]) {\\n            pplThatCanWearHats[hat].push(personMask);\\n        }\\n    }\\n\\n    const cache = {};"]}
{"id": "2004", "ref_js": ["var kthSmallest = function(mat, k) {\\n    \\n    let sum = 0 ", "var kthSmallest = function(mat, k) {\\n    \\n    let sum = 0 ", "var kthSmallest = function(mat, k) {\\n    \\n    let sum = 0 "]}
{"id": "2005", "ref_js": ["var ways = function(pizza, k) {\\n  let m = pizza.length, n = pizza[0].length, mod = 10 ** 9 + 7; \\n  let appleCount = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\\n  let memo = Array(m).fill(0).map(() => Array(n).fill(0).map(() => Array(k + 1).fill(-1)));\\n  for (let i = m - 1; i >= 0; i--) {\\n    for (let j = n - 1; j >= 0; j--) {\\n      let curr = pizza[i][j] === \\'A\\' ? 1 : 0;\\n      appleCount[i][j] = appleCount[i][j + 1] + appleCount[i + 1][j] - appleCount[i + 1][j + 1] + curr;\\n    }\\n  }\\n  return dp(0, 0, k);\\n  \\n  function dp(i, j, k) {\\n    if (k === 1) return appleCount[i][j] > 0 ? 1 : 0;\\n    if (appleCount[i][j] === 0) return 0;\\n    if (memo[i][j][k] !== -1) return memo[i][j][k];\\n    \\n    let ans = 0;\\n    for (let newRow = i; newRow < m - 1; newRow++) {\\n      if (appleCount[newRow + 1][j] === appleCount[i][j]) continue; ", "var ways = function(pizza, k) {\\n  let m = pizza.length, n = pizza[0].length, mod = 10 ** 9 + 7; \\n  let appleCount = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\\n  let memo = Array(m).fill(0).map(() => Array(n).fill(0).map(() => Array(k + 1).fill(-1)));\\n  for (let i = m - 1; i >= 0; i--) {\\n    for (let j = n - 1; j >= 0; j--) {\\n      let curr = pizza[i][j] === \\'A\\' ? 1 : 0;\\n      appleCount[i][j] = appleCount[i][j + 1] + appleCount[i + 1][j] - appleCount[i + 1][j + 1] + curr;\\n    }\\n  }\\n  return dp(0, 0, k);\\n  \\n  function dp(i, j, k) {\\n    if (k === 1) return appleCount[i][j] > 0 ? 1 : 0;\\n    if (appleCount[i][j] === 0) return 0;\\n    if (memo[i][j][k] !== -1) return memo[i][j][k];\\n    \\n    let ans = 0;\\n    for (let newRow = i; newRow < m - 1; newRow++) {\\n      if (appleCount[newRow + 1][j] === appleCount[i][j]) continue; ", "var ways = function(pizza, k) {\\n    \\n    var result = 0;\\n    var appleCount = 0;\\n    for (var row of pizza) {\\n        for (var i = 0; i < row.length; i++) {\\n            if (row[i] === \\'A\\') appleCount++;\\n        }\\n    }\\n    var m = pizza.length;\\n    var n = m ? pizza[0].length : 0;\\n    var map = {};"]}
{"id": "2006", "ref_js": ["var largestNumber = function(cost, target) {\\n    let dp=Array(target).fill(\\'0\\'), _=dp.unshift(\\'\\');\\n    cost.forEach((c, i) => { for (let t = c; t <= target; t++)\\n        dp[t-c] !== \\'0\\' &&\\n        dp[t-c].length + 1 >= dp[t].length &&\\n        (dp[t] = (i+1) + dp[t-c])});\\n    return dp[target];\\n};", "var largestNumber = function(cost, target) {\\n    const arr = new Array(target+1).fill(\\'#\\');\\n    arr[0] = \\'\\';\\n    \\n    for (let i = 0; i < 9; i++) {\\n        for (let j = cost[i]; j <= target; j++) {\\n            if (arr[j-cost[i]] !== \\'#\\' && arr[j-cost[i]].length + 1 >= arr[j].length) {\\n                arr[j] = (i+1).toString().concat(arr[j-cost[i]]);\\n            }\\n        }\\n    }\\n    \\n    return arr[target] == \\'#\\' ? \\'0\\' : arr[target];\\n};", "var largestNumber = function(cost, target) {\\n    const INVALID_CASE = \\'0\\';\\n    const BASE_CASE = \\'\\';\\n\\n    const n = cost.length;\\n    const dp = new Array(n).fill().map(() => new Array(target + 1));\\n\\n    const dfs = (i = n - 1, remaining = target) => {\\n        if(i < 0 || remaining < 0) return INVALID_CASE;\\n        if(remaining === 0) return BASE_CASE;\\n\\n        if(dp[i][remaining]) return dp[i][remaining];\\n\\n        const includeDigit = dfs(i, remaining - cost[i]);\\n        const excludeDigit = dfs(i - 1, remaining);\\n\\n        let res = INVALID_CASE;\\n        if(includeDigit !== INVALID_CASE) {\\n            res = (i + 1) + includeDigit;\\n        }\\n        if(excludeDigit !== INVALID_CASE) {\\n            res = res === INVALID_CASE ? excludeDigit : (excludeDigit.length > res.length ? excludeDigit : res);\\n        }\\n\\n        dp[i][remaining] = res;\\n        return res;\\n    }\\n\\n    return dfs();\\n};"]}
{"id": "2007", "ref_js": ["var numPoints = function(points, r) {\\n    var maxLen = r * 2;\\n    var n = points.length;\\n    \\n    var isGreaterThanMaxLen = function(i, j) {\\n        var x = points[i][0] - points[j][0];\\n        var y = points[i][1] - points[j][1];\\n        return x * x + y * y > maxLen * maxLen;\\n    }\\n    \\n    var exceedPairs = [];\\n    var exceedCounts = new Array(n).fill(0)\\n    \\n    for (var i = 0; i < n; i++) {\\n        for (var j = i + 1; j < n; j++) {\\n            if (isGreaterThanMaxLen(i, j)) {\\n                exceedPairs.push([i, j]);\\n                exceedCounts[i]++;\\n                exceedCounts[j]++;\\n            }\\n        }\\n    }\\n    \\n    var getMin = function(exceedPairs, exceedCounts) {\\n        if (!exceedPairs.length) return 0;\\n        var exceedMax = 0;\\n        var maxIdxArr = [];\\n        for (var i = 0; i < n; i++) {\\n            if (exceedCounts[i] > exceedMax) {\\n                exceedMax = exceedCounts[i];\\n            }\\n        }\\n        for (var i = 0; i < n; i++) {\\n            if (exceedCounts[i] === exceedMax) {\\n                maxIdxArr.push(i);\\n            }\\n        }\\n        var min = n;\\n        for (var idx of maxIdxArr) {\\n            var newPairs = [];\\n            var newCounts = [...exceedCounts];\\n            for (var pair of exceedPairs) {\\n                if (pair[0] === idx || pair[1] === idx) {\\n                    newCounts[pair[0]]--;\\n                    newCounts[pair[1]]--;\\n                } else {\\n                    newPairs.push(pair);\\n                }\\n            }\\n            var thisCount = 1 + getMin(newPairs, newCounts);\\n            if (thisCount < min) min = thisCount;\\n        }\\n        return min;\\n    }\\n    \\n    return n - getMin(exceedPairs, exceedCounts);\\n    \\n};", "var numPoints = function(points, r) {\\n    var maxLen = r * 2;\\n    var n = points.length;\\n    \\n    var isGreaterThanMaxLen = function(i, j) {\\n        var x = points[i][0] - points[j][0];\\n        var y = points[i][1] - points[j][1];\\n        return x * x + y * y > maxLen * maxLen;\\n    }\\n    \\n    var exceedPairs = [];\\n    var exceedCounts = new Array(n).fill(0)\\n    \\n    for (var i = 0; i < n; i++) {\\n        for (var j = i + 1; j < n; j++) {\\n            if (isGreaterThanMaxLen(i, j)) {\\n                exceedPairs.push([i, j]);\\n                exceedCounts[i]++;\\n                exceedCounts[j]++;\\n            }\\n        }\\n    }\\n    \\n    var getMin = function(exceedPairs, exceedCounts) {\\n        if (!exceedPairs.length) return 0;\\n        var exceedMax = 0;\\n        var maxIdxArr = [];\\n        for (var i = 0; i < n; i++) {\\n            if (exceedCounts[i] > exceedMax) {\\n                exceedMax = exceedCounts[i];\\n            }\\n        }\\n        for (var i = 0; i < n; i++) {\\n            if (exceedCounts[i] === exceedMax) {\\n                maxIdxArr.push(i);\\n            }\\n        }\\n        var min = n;\\n        for (var idx of maxIdxArr) {\\n            var newPairs = [];\\n            var newCounts = [...exceedCounts];\\n            for (var pair of exceedPairs) {\\n                if (pair[0] === idx || pair[1] === idx) {\\n                    newCounts[pair[0]]--;\\n                    newCounts[pair[1]]--;\\n                } else {\\n                    newPairs.push(pair);\\n                }\\n            }\\n            var thisCount = 1 + getMin(newPairs, newCounts);\\n            if (thisCount < min) min = thisCount;\\n        }\\n        return min;\\n    }\\n    \\n    return n - getMin(exceedPairs, exceedCounts);\\n    \\n};", "var numPoints = function(points, r) {\\n    var maxLen = r * 2;\\n    var n = points.length;\\n    \\n    var isGreaterThanMaxLen = function(i, j) {\\n        var x = points[i][0] - points[j][0];\\n        var y = points[i][1] - points[j][1];\\n        return x * x + y * y > maxLen * maxLen;\\n    }\\n    \\n    var exceedPairs = [];\\n    var exceedCounts = new Array(n).fill(0)\\n    \\n    for (var i = 0; i < n; i++) {\\n        for (var j = i + 1; j < n; j++) {\\n            if (isGreaterThanMaxLen(i, j)) {\\n                exceedPairs.push([i, j]);\\n                exceedCounts[i]++;\\n                exceedCounts[j]++;\\n            }\\n        }\\n    }\\n    \\n    var getMin = function(exceedPairs, exceedCounts) {\\n        if (!exceedPairs.length) return 0;\\n        var exceedMax = 0;\\n        var maxIdxArr = [];\\n        for (var i = 0; i < n; i++) {\\n            if (exceedCounts[i] > exceedMax) {\\n                exceedMax = exceedCounts[i];\\n            }\\n        }\\n        for (var i = 0; i < n; i++) {\\n            if (exceedCounts[i] === exceedMax) {\\n                maxIdxArr.push(i);\\n            }\\n        }\\n        var min = n;\\n        for (var idx of maxIdxArr) {\\n            var newPairs = [];\\n            var newCounts = [...exceedCounts];\\n            for (var pair of exceedPairs) {\\n                if (pair[0] === idx || pair[1] === idx) {\\n                    newCounts[pair[0]]--;\\n                    newCounts[pair[1]]--;\\n                } else {\\n                    newPairs.push(pair);\\n                }\\n            }\\n            var thisCount = 1 + getMin(newPairs, newCounts);\\n            if (thisCount < min) min = thisCount;\\n        }\\n        return min;\\n    }\\n    \\n    return n - getMin(exceedPairs, exceedCounts);\\n    \\n};"]}
{"id": "2008", "ref_js": ["var maxDotProduct = function(nums1, nums2) {\\n    let m = nums1.length, n = nums2.length;\\n    let current = new Array(n + 1).fill(Number.MIN_SAFE_INTEGER);\\n    let previous = new Array(n + 1).fill(Number.MIN_SAFE_INTEGER);\\n\\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            let curr_product = nums1[i - 1] * nums2[j - 1];\\n            current[j] = Math.max(curr_product, previous[j], current[j - 1], curr_product + Math.max(0, previous[j - 1]));\\n        }\\n        [current, previous] = [previous, current];\\n    }\\n    return previous[n];\\n};", "var maxDotProduct = function(nums1, nums2) {\\n        const m = nums1.length;\\n        const n = nums2.length;\\n\\n        if (m < n) {\\n            return maxDotProduct(nums2, nums1);\\n        }\\n\\n        const dp = new Array(n + 1).fill(Number.NEGATIVE_INFINITY);\\n\\n        for (let i = 0; i < m; i++) {\\n            let prev = 0;\\n            for (let j = 0; j < n; j++) {\\n                const tmp = dp[j + 1];\\n                dp[j + 1] = Math.max(prev + nums1[i] * nums2[j], nums1[i] * nums2[j], dp[j], dp[j + 1]);\\n                prev = tmp;\\n            }\\n        }\\n\\n        return dp[n];    \\n};", "var maxDotProduct = function(nums1, nums2) {\\n    let m = nums1.length, n = nums2.length;\\n    let current = new Array(n + 1).fill(Number.MIN_SAFE_INTEGER);\\n    let previous = new Array(n + 1).fill(Number.MIN_SAFE_INTEGER);\\n\\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            let curr_product = nums1[i - 1] * nums2[j - 1];\\n            current[j] = Math.max(curr_product, previous[j], current[j - 1], curr_product + Math.max(0, previous[j - 1]));\\n        }\\n        [current, previous] = [previous, current];\\n    }\\n    return previous[n];\\n};"]}
{"id": "2009", "ref_js": ["var cherryPickup = function(grid) {\\n    let rows = grid.length, cols = grid[0].length, \\n        dp = [...Array(rows)].map(x => [...Array(cols)].map(y => Array(cols)))\\n    for (let i = rows - 1; i >= 0; i--)\\n        for (let j = Math.min(i, cols - 2); j >= 0; j--)\\n            for (let k = Math.max(cols - i - 1, j + 1); k < cols; k++) {\\n                let best = 0\\n                for (let m = -1; m < 2; m++)\\n                    for (let n = -1; n < 2; n++)\\n                        best = Math.max(best, ~~dp[i+1]?.[j+m]?.[k+n])\\n                dp[i][j][k] = grid[i][j] + grid[i][k] + best\\n            }\\n    return dp[0][0][cols-1]\\n};", "var cherryPickup = function(grid) {\\n    let r = grid.length, c = grid[0].length;\\n    let dp = new Array(r).fill().map(()=>new Array(c).fill().map(()=>new Array(c).fill(-1)));\\n    return maxCherries(0, 0, c-1, r, c, grid, dp);\\n};", "var cherryPickup = function (grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  let cur = [];\\n  let pre = [];\\n  let tem;\\n  let res = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    cur.push(Array(n - i).fill(noo));\\n    pre.push(Array(n - i).fill(noo));\\n  }\\n  cur[0][n - 1] = grid[0][0] + grid[0][n - 1];\\n\\n  function opt(x, d, ...v) {\\n    cur[x][d] = Math.max(cur[x][d], ...v);\\n  }\\n\\n  for (let i = 1; i < m; i++) {\\n    tem = pre;\\n    pre = cur;\\n    cur = tem;\\n\\n    for (let x1 = 0; x1 < n; x1++) {\\n      let g1 = grid[i][x1];\\n      cur[x1][0] = pre[x1][0];\\n\\n      if (x1 > 0) opt(x1, 0, pre[x1 - 1][0], pre[x1 - 1][1]);\\n      if (x1 < n - 1) opt(x1, 0, pre[x1 + 1][0], pre[x1][1]);\\n      if (x1 > 0 && x1 < n - 1) opt(x1, 0, pre[x1 - 1][2]);\\n      cur[x1][0] += g1;\\n      res = Math.max(res, cur[x1][0]);\\n\\n      for (let x2 = x1 + 1; x2 < n; x2++) {\\n        let g2 = grid[i][x2];\\n        let d = x2 - x1;\\n\\n        cur[x1][d] = Math.max(pre[x1][d], pre[x1 + 1][d - 1], pre[x1][d - 1]);\\n        if (x1 > 0) opt(x1, d, pre[x1 - 1][d], pre[x1 - 1][d + 1]);\\n        if (x2 < n - 1) opt(x1, d, pre[x1][d + 1], pre[x1 + 1][d]);\\n        if (x1 > 0 && x2 < n - 1) opt(x1, d, pre[x1 - 1][d + 2]);\\n        if (d >= 2) opt(x1, d, pre[x1 + 1][d - 2]);\\n        cur[x1][d] += g1 + g2;\\n\\n        res = Math.max(res, cur[x1][d]);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};"]}
{"id": "2010", "ref_js": ["var getProbability = function(balls) {\\n    let sameCount = 0, diffCount = 0;  ", "var getProbability = function(balls) \\n{\\n       var k = balls.length;\\n       var halfUsed = balls.reduce((acc,val)=>acc+val,0)/2;\\n       var startArray = new Array(k);\\n       startArray.fill(0);\\n       \\n       const perm = function(b1,b2)\\n       {\\n               var p1, p2, s1, s2;\\n               \\n               s1 =  b1.reduce((acc,val)=>acc+val,0);\\n               s2 =  b2.reduce((acc,val)=>acc+val,0);\\n               \\n               const fact = function(n)\\n               {\\n                       var f=1;\\n                       for(let i=2; i<=n; i++)\\n                               f *= i;\\n                       return  f;\\n               };", "var getProbability = function(balls) {\\n    let sameCount = 0, diffCount = 0;  "]}
{"id": "2011", "ref_js": ["var minCost = function(houses, cost, m, n, target) {\\n    let map = new Map();\\n\\n    function dfs(idx = 0, prevColor = -1, neighborhoods = 0) {\\n        if (idx === m) return neighborhoods === target ? 0 : Infinity;\\n\\n        let key = `${idx}-${prevColor}-${neighborhoods}`;\\n        if (map.has(key)) return map.get(key);\\n        \\n        let color = houses[idx];\\n        ", "var minCost = function(houses, cost, m, n, target) {\\n    const cache = {};", "var minCost = function(houses, cost, m, n, target) {\\n    const dp = []\\n    for (let i = 0; i < m; i++) {\\n        dp[i] = []\\n        for (let j = 0; j < target; j++) {\\n            dp[i][j] = new Array(n).fill(Infinity)\\n        }\\n    }\\n    \\n    if (houses[0]) {\\n        dp[0][0][houses[0] - 1] = 0\\n    } else {\\n        cost[0].forEach((c,idx) => {\\n            dp[0][0][idx] = c\\n        })\\n    }\\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let t = 0; t <= Math.min(i, target - 1); t++) {\\n            const color = houses[i] - 1\\n\\n            if (!t) {\\n                if (color >= 0) {\\n                    dp[i][t][color] = dp[i-1][t][color]\\n                } else {\\n                    for (let c = 0; c < n; c++) {\\n                        dp[i][t][c] = Math.min(dp[i][t][c], cost[i][c] + dp[i-1][t][c])\\n                    }\\n                }\\n                continue\\n            }\\n            \\n            if (color >= 0) {\\n                cost[i].forEach((_,c) => {\\n                    const nT = color === c ? t : t - 1\\n                    dp[i][t][color] = Math.min(dp[i][t][color], dp[i-1][nT][c])\\n                })\\n            } else {\\n                for (let c = 0; c < n; c++) {\\n                    for (let prevC = 0; prevC < n; prevC++) {\\n                        const nT = prevC === c ? t : t - 1\\n                        dp[i][t][c] = Math.min(dp[i][t][c],cost[i][c] + dp[i-1][nT][prevC])\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let res = Infinity\\n    dp[m-1][target-1].forEach(c => {\\n        res = Math.min(res,c)\\n    })\\n    \\n    return res === Infinity ? -1 : res\\n};"]}
{"id": "2012", "ref_js": ["var minDistance = function (houses, k) {\\n  const n = houses.length;\\n  houses.sort((a, b) => a - b);\\n  const costs = new Array(n).fill().map((_) => new Array(n).fill(0));\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = i; j < n; j++) {\\n      const mid = Math.floor((i + j) / 2);\\n      const medianPos = houses[mid];\\n\\n      for (let m = i; m <= j; m++) {\\n        costs[i][j] += Math.abs(houses[m] - medianPos);\\n      }\\n    }\\n  }\\n\\n  const dp = new Array(n).fill().map(() => new Array(k + 1).fill());\\n  return helper(0, n, k, costs, dp);\\n};", "var minDistance = function(houses, k) {\\n    let n = houses.length;\\n    let sorted = houses.sort((a,b)=> a-b)\\n    costs = new Array(n)\\n    for (let i = 0; i < n;i++){\\n        costs[i] = new Array(n).fill(0)\\n    }\\n    const memo = new Array(100)\\n    \\n    for (let i = 0; i < 100;i++){\\n        memo[i] = new Array(100)\\n    }\\n    \\n    for (let i = 0 ; i < n ; i++){\\n        for (let j = 0; j < n ; j++){\\n            let median = sorted[Math.floor((i+j)/2)]\\n            for (let t = i; t < j+1; t++){\\n                costs[i][j] += Math.abs(median - sorted[t])\\n            }\\n        }\\n    }\\n\\n    const dp = (k, i ) => {\\n        if (k ===0 && i === n) return 0;\\n        if (k ===0 || i === n) return Infinity;\\n        if (memo[k][i] != null) return memo[k][i]\\n        let ans = Infinity\\n        for (let j = i; j < n;j++){\\n            let cost = costs[i][j]\\n            ans = Math.min(ans , cost + dp(k-1,j+1))\\n        }\\n        memo[k][i] = ans\\n        return ans\\n    }\\n    \\n    return dp(k, 0)\\n};", "var minDistance = function(houses, k) {\\n\\n    houses = houses.sort((a,b) => a-b)\\n    \\n    const solution = []\\n    for (let i=0; i<houses.length; i++) {\\n        const row = []\\n        for (let j=0; j<k+1; j++) {\\n            if (j == 0) {\\n                row.push(Number.MAX_SAFE_INTEGER)\\n            } else {\\n                row.push(NaN)\\n            }\\n        }\\n        solution.push(row)\\n    }\\n\\n    for (let j=1; j<=k; j++) {\\n\\n        for (let i=houses.length-1; i>=0; i--) {\\n\\n            if (j >= houses.length-i) {\\n                solution[i][j] = 0\\n                continue\\n            } \\n\\n            let minCost = singleCover(houses, i, houses.length-1)\\n\\n            for (let m=i; m<houses.length-1; m++) {\\n\\n                const cost = singleCover(houses, i, m)  + solution[m+1][j-1] \\n\\n                if (cost < minCost) {\\n                    minCost = cost\\n                }\\n            }\\n\\n            solution[i][j] = minCost\\n        }\\n    }\\n\\n    return solution[0][k]\\n};"]}
{"id": "2014", "ref_js": ["var findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let parent = new Array(n);\\n    let size = new Array(n);\\n    const critical = [];\\n    const pseudo_critical = [];\\n    for(let i = 0; i<edges.length; i++) edges[i].push(i);\\n    function make_set(){\\n        for(let i = 0; i<n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    const find = function (x) {\\n        if(parent[x] === x) return x;\\n        return find(parent[x]);\\n    }\\n    const union = function (a,b){\\n        a = find(a);\\n        b = find(b);\\n        if(a === b) return false;\\n        if(size[a] > size[b]){\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }else{\\n            parent[a] = b;\\n            size[b] += size[a];\\n        }\\n        return true;\\n    }\\n    const getMST = function (blockEdge,preEdge){\\n        ", "var findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let criticalEdges = [], psuedoCriticalEdges = [], map = new Map();\\n    \\n    edges.forEach((edge, i) => map.set(edge, i));\\n    \\n    edges.sort((a, b) => a[2] - b[2]);\\n    \\n    const buildMST = (pick, skip) => {\\n        let uf = new UnionFind(n), cost = 0;\\n        \\n        if(pick !== null) {\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(let edge of edges) {\\n            if(edge !== skip && uf.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return uf.count === 1 ? cost : Number.MAX_SAFE_INTEGER;\\n    };", "var findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let parent = new Array(n);\\n    let size = new Array(n);\\n    const critical = [];\\n    const pseudo_critical = [];\\n    for(let i = 0; i<edges.length; i++) edges[i].push(i);\\n    function make_set(){\\n        for(let i = 0; i<n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    const find = function (x) {\\n        if(parent[x] === x) return x;\\n        return find(parent[x]);\\n    }\\n    const union = function (a,b){\\n        a = find(a);\\n        b = find(b);\\n        if(a === b) return false;\\n        if(size[a] > size[b]){\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }else{\\n            parent[a] = b;\\n            size[b] += size[a];\\n        }\\n        return true;\\n    }\\n    const getMST = function (blockEdge,preEdge){\\n        "]}
{"id": "2015", "ref_js": ["var minNumberOfSemesters = function (n, relations, k) {\\n\\tconst indegrees = new Array(n + 1);\\n\\tconst dependencies = new Map();\\n\\n\\tfor (let i = 1; i <= n; ++i) {\\n\\t\\tdependencies.set(i, new Set());\\n\\t\\tindegrees[i] = 0;\\n\\t}\\n\\n\\tfor (const [from, to] of relations) {\\n\\t\\tdependencies.get(from).add(to);\\n\\t\\tindegrees[to]++;\\n\\t}\\n\\n\\tlet freeCourseQueue = [];\\n\\tlet startQueue = [];\\n\\n\\tfor (let i = 1; i < indegrees.length; ++i) {\\n\\t\\tif (indegrees[i] === 0) {\\n\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\tfreeCourseQueue.push(i); ", "var minNumberOfSemesters = function(n, dependencies, k) {\\n    ", "var minNumberOfSemesters = function (n, relations, k) {\\n\\tconst indegrees = new Array(n + 1);\\n\\tconst dependencies = new Map();\\n\\n\\tfor (let i = 1; i <= n; ++i) {\\n\\t\\tdependencies.set(i, new Set());\\n\\t\\tindegrees[i] = 0;\\n\\t}\\n\\n\\tfor (const [from, to] of relations) {\\n\\t\\tdependencies.get(from).add(to);\\n\\t\\tindegrees[to]++;\\n\\t}\\n\\n\\tlet freeCourseQueue = [];\\n\\tlet startQueue = [];\\n\\n\\tfor (let i = 1; i < indegrees.length; ++i) {\\n\\t\\tif (indegrees[i] === 0) {\\n\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\tfreeCourseQueue.push(i); "]}
{"id": "2016", "ref_js": ["var findMaxValueOfEquation = function(points, k) {\\n    let result = -Infinity;\\n    let queue = [];\\n    for(let point of points) {\\n        while(queue.length && point[0] - queue[0][1] > k) {\\n            queue.shift();\\n        }\\n        if(queue.length) {\\n            result = Math.max(result, queue[0][0] + point[1] + point[0]);\\n        }\\n        while(queue.length && point[1] - point[0] > queue[queue.length - 1][0]) {\\n            queue.pop();\\n        }\\n        queue.push([point[1] - point[0], point[0]]);\\n    }\\n    return result;\\n};", "var findMaxValueOfEquation = function(points, k) {\\n  const pq = new MaxPriorityQueue({ priority: x => x[0] });\\n  let ans = -Infinity;\\n\\n  for (let [x, y] of points) {\\n    while (!pq.isEmpty() && x - pq.front().element[1] > k) pq.dequeue();\\n\\n    if (!pq.isEmpty()) \\n      ans = Math.max(ans, pq.front().element[0] + x + y);\\n\\n    pq.enqueue([y - x, x]);\\n  }\\n\\n  return ans;\\n};", "var findMaxValueOfEquation = function(p, k) {\\n    let max=[];\\n    for(let i=0;i<p.length;i+=2){\\n        \\n        let [xi,yi] = [p[i][0],p[i][1]];\\n        let [xj,yj] = [p[i+1][0],p[i+1][1]];\\n        let res= yi + yj + Math.abs(xi - xj);\\n        "]}
{"id": "2017", "ref_js": ["var minInteger = function(num, k) {\\n    if (num.length == 1)\\n        return num;\\n    \\n    let nums = num.split(\\'\\');\\n    let i = 0, j = 0;\\n    \\n    while (k && i < num.length-1) {\\n", "var minInteger = function(num, k) {\\n    var arr = num.split(\"\");\\n    var n = arr.length;\\n\\t\\tfor (var i = 0; i < n-1 && k > 0; ++i) \\n        {\\n            var pos = i; \\n            for (var j = i+1; j < n ; ++j) \\n            {\\n                if (j - i > k) \\n                    break; \\n       \\n                if (arr[j] < arr[pos]) \\n                    pos = j; \\n            }\\n            var temp;\\n            for (var j = pos; j>i; --j) \\n            { \\n                temp=arr[j]; \\n                arr[j]=arr[j-1]; \\n                arr[j-1]=temp; \\n            }\\n            k -= pos-i; \\n        }\\n    return arr.join(\"\");\\n};", "var minInteger = function(num, k) {\\n    var arr = num.split(\"\");\\n    var n = arr.length;\\n\\t\\tfor (var i = 0; i < n-1 && k > 0; ++i) \\n        {\\n            var pos = i; \\n            for (var j = i+1; j < n ; ++j) \\n            {\\n                if (j - i > k) \\n                    break; \\n       \\n                if (arr[j] < arr[pos]) \\n                    pos = j; \\n            }\\n            var temp;\\n            for (var j = pos; j>i; --j) \\n            { \\n                temp=arr[j]; \\n                arr[j]=arr[j-1]; \\n                arr[j-1]=temp; \\n            }\\n            k -= pos-i; \\n        }\\n    return arr.join(\"\");\\n};"]}
{"id": "2018", "ref_js": ["var winnerSquareGame = function(n) {\\n  let ans = new Array(n+1).fill(false); \\n  ans[0] = false ; \\n  for(let i=1;i<=n;i++)\\n    for(let j=1;j*j<=i;j++)\\n      if(!(ans[i-(j*j)])){\\n        ans[i] = true ; \\n        break; \\n      }\\n    return ans[n];\\n};", "var winnerSquareGame = function (n) {\\n  const dp = new Array(n + 1).fill();\\n  return helper(dp, n);\\n};", "var winnerSquareGame = function(n) {\\n  let ans = new Array(n+1).fill(false); \\n  ans[0] = false ; \\n  for(let i=1;i<=n;i++)\\n    for(let j=1;j*j<=i;j++)\\n      if(!(ans[i-(j*j)])){\\n        ans[i] = true ; \\n        break; \\n      }\\n    return ans[n];\\n};"]}
{"id": "2019", "ref_js": ["var getMinDistSum = function(positions) {\\n    \\n    \\n    \\n    let xSum = 0;\\n    let ySum = 0;\\n    for (const [x, y] of positions) {\\n        xSum += x;\\n        ySum += y;\\n    }\\n    \\n    let n = positions.length;\\n    let x = xSum / n;\\n    let y = ySum / n;\\n    \\n    let step = 0.5;\\n    const dirs = [[0, 1], [0, -1], [-1, 0], [1, 0]];\\n    while (step >= 10 ** -5) {\\n        \\n        const dist = calcDist(x, y);\\n        let found = false;\\n        for (const [xDiff, yDiff] of dirs) {\\n            const newX = x + xDiff * step;\\n            const newY = y + yDiff * step;\\n            const newDist = calcDist(newX, newY);\\n            \\n            ", "var getMinDistSum = function(pos) {\\n    var n = pos.length;\\n    if(pos.length == 1){\\n        return 0;\\n    }\\n    var dis = 0;\\n    var x = 0,y =0;\\n    var dx = [-1, 0, 1, 0];\\n    var dy = [0, 1, 0, -1];\\n    for ( var i = 0; i < n; i++){\\n        x += pos[i][0],\\n        y += pos[i][1]; \\n    }\\n\\t", "var getMinDistSum = function(positions) {\\n    \\n    \\n    \\n    let xSum = 0;\\n    let ySum = 0;\\n    for (const [x, y] of positions) {\\n        xSum += x;\\n        ySum += y;\\n    }\\n    \\n    let n = positions.length;\\n    let x = xSum / n;\\n    let y = ySum / n;\\n    \\n    let step = 0.5;\\n    const dirs = [[0, 1], [0, -1], [-1, 0], [1, 0]];\\n    while (step >= 10 ** -5) {\\n        \\n        const dist = calcDist(x, y);\\n        let found = false;\\n        for (const [xDiff, yDiff] of dirs) {\\n            const newX = x + xDiff * step;\\n            const newY = y + yDiff * step;\\n            const newDist = calcDist(newX, newY);\\n            \\n            "]}
{"id": "2020", "ref_js": ["var maxNumOfSubstrings = function(s) {\\n    ", "var maxNumOfSubstrings = function(s) {\\n    ", "var maxNumOfSubstrings = function(s) {\\n    "]}
{"id": "2021", "ref_js": ["var buildTree = function(preorder, inorder) {\\n        p = i = 0\\n        build = function(stop) {\\n            if (inorder[i] != stop) {\\n                var root = new TreeNode(preorder[p++])\\n                root.left = build(root.val)\\n                i++\\n                root.right = build(stop)\\n                return root\\n            }\\n            return null\\n        }\\n        return build()\\n    };", "var buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};", "var buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};"]}
{"id": "2022", "ref_js": ["var minNumberOperations = function(target) {\\n\\tlet totalOps = 0; \\n\\tlet whereIAmNow = 0;\\n\\tfor(let i = 0; i<target.length; i++){\\n\\t\\tlet whereINeedToBe = target[i];\\n\\t\\tif(whereIAmNow <= whereINeedToBe){\\n\\t\\t\\t", "var minNumberOperations = function(target) {\\n    return target.reduce((operations, current, index) => {\\n        return operations + Math.max(0, current - (target[index - 1] || 0));\\n    }, 0);\\n};", "var minNumberOperations = function (a) {\\n    a.unshift(0)\\n    let n = a.length;\\n\\n    let cc = 0;\\n    for (let i = 1; i < n; i++) {\\n        if (a[i] > a[i - 1]) {\\n            cc += (a[i] - a[i - 1]);\\n        }\\n    }\\n    return cc;\\n};"]}
{"id": "2023", "ref_js": ["var getLengthOfOptimalCompression = function(s, k) {\\n  const len = s.length;\\n  let dp = {};", "var getLengthOfOptimalCompression = function(s, k) {\\n    s = s.split(\\'\\')\\n    const map = s.map(row => new Array(k + 1).fill(-1))\\n    \\n    const dp = (row, k) => {\\n        if(k < 0) return s.length\\n        if(k + row >= s.length) return 0\\n        \\n        let ans = map[row][k]\\n        if(ans !== -1) return ans\\n        ans = dp(row + 1, k - 1)\\n        let length = 0\\n        let same = 0\\n        let diff = 0\\n        \\n        for(let x = row; x < s.length && diff <= k; x++) {\\n            if(s[x] === s[row]) {\\n                same++\\n                if(same <= 2 || same === 10 || same === 100) {\\n                    length++\\n                }\\n            } else {\\n                diff++\\n            }\\n            ans = Math.min(ans, length + dp(x + 1, k - diff))\\n        }\\n        map[row][k] = ans\\n        return ans\\n    }\\n    return dp(0, k)\\n};", "var getLengthOfOptimalCompression = function(s, k) {\\n  const len = s.length;\\n  let dp = {};"]}
{"id": "2024", "ref_js": ["var maxSum = function(nums1, nums2) {\\n    let arr1Sum = 0;\\n    let arr2Sum = 0;\\n\\n    let sum = 0;\\n    let i = 0, j = 0;\\n    \\n    while (i < nums1.length || j < nums2.length) {\\n        if (nums1[i] === undefined) {\\n            arr2Sum += nums2[j];\\n            j++;\\n            continue;\\n        } else if (nums2[j] === undefined) {\\n            arr1Sum += nums1[i];\\n            i++;\\n            continue;\\n        }\\n        if (nums1[i] < nums2[j]) {\\n            arr1Sum += nums1[i];\\n            i++;\\n        } else if (nums1[i] > nums2[j]) {\\n            arr2Sum += nums2[j];\\n            j++;\\n        } else {\\n            sum += nums1[i] + Math.max(arr1Sum, arr2Sum);\\n            arr1Sum = 0;\\n            arr2Sum = 0;\\n            i++;\\n            j++;\\n        }\\n    }\\n    sum += Math.max(arr1Sum, arr2Sum);\\n    \\n    return sum%1000000007;\\n};", "var maxSum = function(nums1, nums2) {\\n    let i = 0, j = 0;\\n    let res1 = 0, res2 = 0;\\n    const MAX = 10**9 + 7;\\n    \\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] == nums2[j]) {\\n            const max = Math.max(res1, res2);\\n            res1 = max + nums1[i++];\\n            res2 = max + nums2[j++];\\n        } else if (nums1[i] < nums2[j]) {\\n            res1 += nums1[i++];\\n        } else {\\n            res2 += nums2[j++];\\n        }\\n    }\\n    \\n    while (i < nums1.length) {\\n        res1 += nums1[i++];\\n    }\\n    \\n    while (j < nums2.length) {\\n        res2 += nums2[j++];\\n    }\\n    \\n    return Math.max(res1, res2) % MAX;\\n};", "var maxSum = function(a, b) {\\n    \\n\\nlet al = a.length;\\nlet bl = b.length;\\n\\nlet sa = 0;\\nlet sb = 0;\\nlet i = 0;\\nlet j = 0;\\n\\nlet ans = 0;\\n\\nwhile (i < al && j < bl) {\\n  if (a[i] < b[j]) {\\n    sa += a[i++];\\n  } else if (a[i] > b[j]) {\\n    sb += b[j++];\\n  } else {\\n    ans += Math.max(sa, sb) + a[i];\\n    sa = 0;\\n    sb = 0;\\n    i++;\\n    j++;\\n  }\\n}\\n\\n"]}
{"id": "2025", "ref_js": ["var longestAwesome = function(s) {\\n    ", "var longestAwesome = function(s) {\\n  let Z = 0;\\n  for (let d = 0; d < 10; d += 1) Z = Math.max(Z, f(s, d));\\n  return Z;\\n};", "var longestAwesome = function(s) {\\n  let Z = 0;\\n  for (let d = 0; d < 10; d += 1) Z = Math.max(Z, f(s, d));\\n  return Z;\\n};"]}
{"id": "2026", "ref_js": ["var minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b) ", "var minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b)\\n    cuts = [0, ...cuts, n]\\n\\n    const stickLen = cuts.length\\n\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))\\n\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity\\n            for (let k = i + 1; k < j; k++){\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost\\n        }\\n    }\\n    return dp[0][stickLen - 1]\\n};", "var minCost = function(n, cuts) {    \\n    const cache = {};"]}
{"id": "2027", "ref_js": ["var minDays = function(n) {\\n    let dp = {}\\n    dp[0] = 0\\n    dp[1] = 1\\n    const helper = (i) => {\\n        if (dp[i] !== undefined) return dp[i]\\n        dp[i] = Math.min(helper(Math.floor(i/2)) + i%2, helper(Math.floor(i/3)) + i%3) + 1\\n        return dp[i]\\n    }\\n    return helper(n)\\n};", "var minDays = function(n) {\\n    const queue = [ [n,0] ];\\n    const visited = new Set();\\n    \\n    while (queue.length > 0) {\\n        const [ orangesLeft, days ] = queue.shift();\\n        \\n        if (visited.has(orangesLeft)) continue;\\n        if (orangesLeft === 0) return days;\\n        \\n        visited.add(orangesLeft);\\n        queue.push([orangesLeft - 1, days + 1]);\\n        \\n        if (orangesLeft % 2 === 0) {\\n            queue.push([orangesLeft - orangesLeft / 2, days + 1]);\\n        }\\n        \\n        if (orangesLeft % 3 === 0) {\\n            queue.push([orangesLeft - 2 * (orangesLeft / 3), days + 1])\\n        }\\n    }\\n};", "var minDays = function(n) {\\n    let dp = {}\\n    dp[0] = 0\\n    dp[1] = 1\\n    const helper = (i) => {\\n        if (dp[i] !== undefined) return dp[i]\\n        dp[i] = Math.min(helper(Math.floor(i/2)) + i%2, helper(Math.floor(i/3)) + i%3) + 1\\n        return dp[i]\\n    }\\n    return helper(n)\\n};"]}
{"id": "2028", "ref_js": ["var stoneGameV = function(stoneValue) {\\n  let n = stoneValue.length;\\n  const pre = new Array(n + 1).fill(0);\\n  for (let i = 1; i <= n; i++) {\\n    pre[i] = pre[i - 1] + stoneValue[i - 1];\\n  }\\n  const dp = [...Array(n).fill(null)].map((_) => new Array(n).fill(0));\\n  for (let l = 1; l < n; l++) {\\n    for (let i = 0; i < n - l; i++) {\\n      let j = i + l,\\n        res = 0;\\n      for (let k = i; k < j; k++) {\\n        let left = pre[k + 1] - pre[i],\\n          right = pre[j + 1] - pre[k + 1];\\n        if (left < right) {\\n          res = Math.max(res, left + dp[i][k]);\\n        } else if (left > right) {\\n          res = Math.max(res, right + dp[k + 1][j]);\\n        } else {\\n          res = Math.max(res, left + dp[i][k]);\\n          res = Math.max(res, right + dp[k + 1][j]);\\n        }\\n      }\\n      dp[i][j] = res;\\n    }\\n  }\\n  return dp[0][n - 1];\\n};", "var stoneGameV = function(stoneValue) {\\n\\n    let length = stoneValue.length\\n    let totalSum = 0\\n\\n    stoneValue.forEach(num => {\\n        totalSum = totalSum + num ", "var stoneGameV = function(stones) {\\n    let bestAns = 0\\n    let stoneSum = stones.reduce((sum, current)=> {return sum+ current},0)\\n\\n    function splitAndAdd(stoneSum, ans, leftBound,rightBound){\\n\\t\\n        if (rightBound === leftBound){return ans}\\n\\n        if (rightBound - leftBound === 1){\\n            return ans + Math.min(stones[leftBound], stones[rightBound])\\n        }\\n        let bestSoFar = 0\\n        let leftSum = 0\\n        let rightSum = stoneSum\\n        for(let i = leftBound; i <= rightBound; i++){\\n            leftSum += stones[i]\\n            rightSum -=stones[i]\\n            \\n      \\n            if (2* Math.min(leftSum, rightSum) + ans < bestAns){continue} \\n            if (leftSum === rightSum){\\n                bestSoFar =  Math.max(splitAndAdd(leftSum, ans+leftSum, leftBound,i), bestSoFar)\\n                bestSoFar = Math.max(splitAndAdd(rightSum, ans+rightSum, i+1, rightBound), bestSoFar)\\n                  \\n            } else{\\n                    \\n                    leftSum > rightSum\\n                    ? bestSoFar = Math.max(splitAndAdd(rightSum, ans+rightSum, i+1, rightBound),bestSoFar)\\n                    : bestSoFar = Math.max(splitAndAdd(leftSum, ans+leftSum, leftBound, i), bestSoFar)\\n            }\\n        \\n        }\\n        \\n        bestAns = Math.max(bestAns, bestSoFar)\\n        return bestSoFar\\n    }\\n    \\n    \\n    let ans = splitAndAdd(stoneSum, 0, 0, stones.length-1)\\n    return ans\\n    \\n};"]}
{"id": "2029", "ref_js": ["var minDays = function(grid) {\\n    let colorNumber = 2;\\n    let landCells = [];\\n    \\n    function colorIsland(i, j) {\\n        grid[i][j] = colorNumber;\\n        for(let k = 0; k < directions.length; k++) {\\n            let newI = i + directions[k][0];\\n            let newJ = j + directions[k][1];\\n            \\n            if(newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && grid[newI][newJ] && grid[newI][newJ] != colorNumber) {\\n                colorIsland(newI, newJ);\\n            }\\n        }\\n    }\\n    \\n    function addLandCells() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j]) {\\n                    landCells.push([i, j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function findAnotherIsland() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] && grid[i][j] != colorNumber) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    addLandCells();\\n    \\n    if(landCells.length < 2) {\\n        return landCells.length;\\n    }\\n    \\n    colorIsland(landCells[0][0], landCells[0][1]);\\n    \\n    if(findAnotherIsland()) {\\n        return 0;\\n    }\\n    \\n    colorNumber++;\\n    \\n    for(let i = 0; i < landCells.length; i++) {\\n        grid[landCells[i][0]][landCells[i][1]] = 0;\\n        colorIsland(landCells[(i + 1) % landCells.length][0], landCells[(i + 1) % landCells.length][1]);\\n        if(findAnotherIsland()) {\\n            return 1;\\n        }\\n        grid[landCells[i][0]][landCells[i][1]] = colorNumber;\\n        colorNumber++;\\n    }\\n    \\n    return 2;\\n};", "var minDays = function(grid) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let bridges = [];\\n    let islandCount = isOneIsland(grid, bridges);\\n    if (islandCount !== 1)\\n        return 0;\\n    \\n    for (let [x, y] of bridges) {\\n        grid[x][y] = 0;\\n        if (isOneIsland(grid) !== 1) {\\n            return 1;\\n        }\\n        grid[x][y] = 1;\\n    }\\n    \\n    return 2;\\n};", "var minDays = function(grid) {\\n    let cnt = numIslands(grid);\\n    console.log(cnt);\\n    if(cnt === 0 || cnt > 1) { "]}
{"id": "2030", "ref_js": ["var numOfWays = function(nums) {\\n    const x = numOfWaysHelper(nums) - 1n;\\n    return x % 1_000_000_007n;\\n}\\nvar numOfWaysHelper = function(nums) {\\n    if(nums.length < 3)\\n        return 1n;\\n    \\n    const root  = nums[0];\\n    const left  = nums.filter(p => p < root);\\n    const right = nums.filter(p => p > root);\\n    return BigInt(comb(left.length + right.length, left.length) * numOfWaysHelper(left) * numOfWaysHelper(right));\\n};", "var numOfWays = function(nums) {\\n    return (helper(nums) - 1n) % BigInt(1e9+7) ", "var numOfWays = function(nums) {\\n    const mod = BigInt(10 ** 9 + 7);\\n\\n    const factorial = new Array(nums.length + 1).fill(1n);\\n\\n    for (let i = 1; i < factorial.length; ++i) {\\n        if (i === 0) {\\n            continue;\\n        }\\n        factorial[i] = BigInt(factorial[i - 1] * BigInt(i));\\n    }\\n\\n    function comb(nl, nr) {\\n        const top = factorial[nl + nr];\\n        const left = factorial[nl];\\n        const right = factorial[nr];\\n        return top / left / right;\\n    }\\n\\n    function ways(arr) {\\n        if (arr.length <= 2) {\\n            return 1n;\\n        }\\n\\n        const root = arr[0];\\n        const left = arr.filter((a) => a < root);\\n        const right = arr.filter((a) => a > root);\\n        const combVal = comb(left.length, right.length);\\n        return BigInt(ways(left) * ways(right) * combVal) % mod;\\n    }\\n\\n    return (ways(nums) - 1n);\\n};"]}
{"id": "2031", "ref_js": ["var countRoutes = function (locations, start, finish, fuel) {\\n    ", "var countRoutes = function(locations, start, finish, fuel) {\\n    let len = locations.length;\\n    let dp = new Array(len+1);\\n    for(let i=0;i<=len;i++){\\n        dp[i] = new Array(fuel+1).fill(-1);\\n    }\\n    console.log(dp);\\n    return count(locations,start,finish,fuel,dp);\\n};", "var countRoutes = function(locations, start, finish, fuel) {\\n    const n = locations.length;\\n    const memo = new Array(n).fill(0).map(()=>new Array(fuel+1).fill(-1));\\n    return solve(start,fuel);\\n\\n    function solve(city,fuel){\\n        if(fuel<0){\\n            return 0;\\n        }\\n        if(memo[city][fuel]!==-1){\\n            return memo[city][fuel];\\n        }\\n        let ans = city ===finish?1:0;\\n        for(let nextCity=0;nextCity<n;nextCity++){\\n            if(nextCity!==city){\\n                ans = (ans+solve(nextCity,fuel-Math.abs(locations[city]-locations[nextCity])))%1000000007;\\n            }\\n        }\\n        return memo[city][fuel]=ans;\\n    }\\n};"]}
{"id": "2032", "ref_js": ["var maxNumEdgesToRemove = function(n, edges) {\\n    const alice = new UnionFind(n), bob = new UnionFind(n);\\n\\n    ", "var maxNumEdgesToRemove = function (n, edges) {\\n    let ufA = new UnionFind(n);\\n    let ufB = new UnionFind(n);\\n    let resNumberOfEdgesToKeep = 0;\\n    ", "var maxNumEdgesToRemove = function(n, edges) {\\n    const alice = new UnionFind(n);\\n    const bob = new UnionFind(n);\\n    const both = new UnionFind(n);\\n    let aliceRemove = 0, bobRemove = 0, bothRemove = 0;\\n\\n    "]}
{"id": "2033", "ref_js": ["var mostWordsFound = function(sentences) {\\n    let max = 0;\\n    let temp = 0;\\n    for (let i = 0; i < sentences.length; i++) {\\n        temp = sentences[i].split(\" \").length;\\n        if (temp > max) {\\n            max = temp;\\n        }\\n    }\\n    \\n    return max;\\n};", "var mostWordsFound = function(sentences) {\\n    let max = 0;\\n    let temp = 0;\\n    for (let i = 0; i < sentences.length; i++) {\\n        temp = sentences[i].split(\" \").length;\\n        if (temp > max) {\\n            max = temp;\\n        }\\n    }\\n    \\n    return max;\\n};", "var mostWordsFound = function(sentences) {\\n    let max = 0;\\n    let temp = 0;\\n    for (let i = 0; i < sentences.length; i++) {\\n        temp = sentences[i].split(\" \").length;\\n        if (temp > max) {\\n            max = temp;\\n        }\\n    }\\n    \\n    return max;\\n};"]}
{"id": "2034", "ref_js": ["var isPrintable = function (targetGrid) {\\n  const n = targetGrid.length;\\n  const m = targetGrid[0].length;\\n  let map = {};", "var isPrintable = function (targetGrid) {\\n\\tconst n = targetGrid.length;\\n\\tconst m = targetGrid[0].length;\\n\\n\\tconst pointData = [];\\n\\n\\tlet list = new Set();\\n\\tconst outputCheck = [];\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\toutputCheck[y] = new Array(m).fill(0);\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tconst val = targetGrid[y][x];\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tif (pointData[val] === undefined) {\\n\\t\\t\\t\\tpointData[val] = {\\n\\t\\t\\t\\t\\tminX: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tminY: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tmaxX: -1,\\n\\t\\t\\t\\t\\tmaxY: -1,\\n\\t\\t\\t\\t};", "var isPrintable = function (targetGrid) {\\n\\tconst n = targetGrid.length;\\n\\tconst m = targetGrid[0].length;\\n\\n\\tconst pointData = [];\\n\\n\\tlet list = new Set();\\n\\tconst outputCheck = [];\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\toutputCheck[y] = new Array(m).fill(0);\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tconst val = targetGrid[y][x];\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tif (pointData[val] === undefined) {\\n\\t\\t\\t\\tpointData[val] = {\\n\\t\\t\\t\\t\\tminX: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tminY: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tmaxX: -1,\\n\\t\\t\\t\\t\\tmaxY: -1,\\n\\t\\t\\t\\t};"]}
{"id": "2035", "ref_js": ["var connectTwoGroups = function(cost) {\\n\\n  const n = cost.length;\\n  const m = cost[0].length;\\n\\n  const baseNumber = 2 ** m - 1;\\n\\n  const setBit = (num, index) => {\\n    const mask = 1 << index;\\n    return num | mask;\\n  }\\n\\n  const f = memoize((i, usedLeft, j, bitMask) => {\\n\\n    if (i === n) return bitMask === baseNumber ? 0 : Infinity;\\n    if (j === m) return usedLeft ? f(i + 1, false, 0, bitMask) : Infinity;\\n  \\n    const connect = f(i, true, j + 1, setBit(bitMask, j)) + cost[i][j];\\n    const noConnect = f(i, usedLeft, j + 1, bitMask);\\n\\n    return Math.min(connect, noConnect);\\n  });\\n\\n  return f(0, false, 0, 0);\\n};", "var connectTwoGroups = function(cost) {\\n  let n = cost.length, m = cost[0].length; ", "var connectTwoGroups = function(cost) {\\n\\n  const n = cost.length;\\n  const m = cost[0].length;\\n\\n  const baseNumber = 2 ** m - 1;\\n\\n  const setBit = (num, index) => {\\n    const mask = 1 << index;\\n    return num | mask;\\n  }\\n\\n  const f = memoize((i, usedLeft, j, bitMask) => {\\n\\n    if (i === n) return bitMask === baseNumber ? 0 : Infinity;\\n    if (j === m) return usedLeft ? f(i + 1, false, 0, bitMask) : Infinity;\\n  \\n    const connect = f(i, true, j + 1, setBit(bitMask, j)) + cost[i][j];\\n    const noConnect = f(i, usedLeft, j + 1, bitMask);\\n\\n    return Math.min(connect, noConnect);\\n  });\\n\\n  return f(0, false, 0, 0);\\n};"]}
{"id": "2036", "ref_js": ["var maximumRequests = function(n, req) {\\n    \\n    return solve(0,req,0,n);\\n};", "var maximumRequests = function(n, req) {\\n    \\n    return solve(0,req,0,n);\\n};", "var maximumRequests = function(n, req) {\\n    \\n    return solve(0,req,0,n);\\n};"]}
{"id": "2037", "ref_js": ["var busiestServers = function(k, arrival, load) {\\n    let louds = {};", "var busiestServers = function(k, arrival, load) {\\n    let loadMap = {};", "var busiestServers = function(k, arrival, load) {\\n    let louds = {};"]}
{"id": "2038", "ref_js": ["var visiblePoints = function(points, angle, location) {\\n    let [dx, dy] = location, count = 0, arr = [];\\n    for ([x,y] of points) {\\n        if (x == dx && y == dy) count++;\\n        else arr.push(Math.atan2(y-dy, x-dx) * 180 / Math.PI);\\n    }\\n    for (a of arr) if (a<0) arr.push(a+360);\\n    arr.sort((a,b) => a-b);\\n    let l = r = res = 0;\\n    while (r < arr.length) {\\n        while (arr[r] - arr[l] > angle) l++;\\n        res = Math.max(res, r-l+1);\\n        r++; \\n    }\\n    return res + count; \\n};", "var visiblePoints = function(points, angle, location) {\\n    let [dx, dy] = location, count = 0, arr = [];\\n    for ([x,y] of points) {\\n        if (x == dx && y == dy) count++;\\n        else arr.push(Math.atan2(y-dy, x-dx) * 180 / Math.PI);\\n    }\\n    for (a of arr) if (a<0) arr.push(a+360);\\n    arr.sort((a,b) => a-b);\\n    let l = r = res = 0;\\n    while (r < arr.length) {\\n        while (arr[r] - arr[l] > angle) l++;\\n        res = Math.max(res, r-l+1);\\n        r++; \\n    }\\n    return res + count; \\n};", "var visiblePoints = function(points, angle, location) {\\n    let [dx, dy] = location, count = 0, arr = [];\\n    for ([x,y] of points) {\\n        if (x == dx && y == dy) count++;\\n        else arr.push(Math.atan2(y-dy, x-dx) * 180 / Math.PI);\\n    }\\n    for (a of arr) if (a<0) arr.push(a+360);\\n    arr.sort((a,b) => a-b);\\n    let l = r = res = 0;\\n    while (r < arr.length) {\\n        while (arr[r] - arr[l] > angle) l++;\\n        res = Math.max(res, r-l+1);\\n        r++; \\n    }\\n    return res + count; \\n};"]}
{"id": "2039", "ref_js": ["var minimumOneBitOperations = function(n) {\\n    if (n <= 1) return n;\\n    let count = 0;\\n    while ((1 << count) <= n) count++;\\n    return ((1 << count) - 1) - minimumOneBitOperations(n - (1 << (count - 1)));\\n};", "var minimumOneBitOperations = function(n) {\\n    let result = 0;\\n    let operationSign = 1;\\n\\n    for (let bitPosition = 30; bitPosition >= 0; bitPosition--) {\\n        if (n & (1 << bitPosition)) {\\n            result += ((1 << (bitPosition + 1)) - 1) * operationSign;\\n            operationSign *= -1;\\n        }\\n    }\\n\\n    return result;\\n};", "var minimumOneBitOperations = function(n) {\\n    let result = 0;\\n    let operationSign = 1;\\n\\n    for (let bitPosition = 30; bitPosition >= 0; bitPosition--) {\\n        if (n & (1 << bitPosition)) {\\n            result += ((1 << (bitPosition + 1)) - 1) * operationSign;\\n            operationSign *= -1;\\n        }\\n    }\\n\\n    return result;\\n};"]}
{"id": "2040", "ref_js": ["var countSubgraphsForEachDiameter = function (n, edges) {\\n    let graph = new Map()\\n    let distMap = new Map()\\n    for (const [a, b] of edges) {\\n        u = a - 1\\n        v = b - 1\\n        if (!graph.has(u)) {\\n            graph.set(u, [])\\n        }\\n        if (!graph.has(v)) {\\n            graph.set(v, [])\\n        }\\n        graph.get(u).push(v)\\n        graph.get(v).push(u)\\n    }\\n    for (let mask = 0; mask < (1 << n); mask++) {\\n        let select = []\\n        for (let j = 0; j < n; j++) {\\n            if (mask & (1 << j)) {\\n                select.push(j)\\n            }\\n        }\\n        let size = getComponentSize(graph, select, n)\\n        if (size === 1) {\\n            let dist = getTreeDiameter(graph, select, n)\\n            if (!distMap.has(dist)) {\\n                distMap.set(dist, [])\\n            }\\n            distMap.get(dist).push(select)\\n        }\\n    }\\n    let ans = Array(n - 1).fill(0)\\n    for (let d = 1; d <= n - 1; d++) {\\n        let count = 0\\n        if (distMap.has(d)) {\\n            count = distMap.get(d).length\\n        }\\n        ans[d - 1] = count\\n    }\\n    return ans\\n};", "var countSubgraphsForEachDiameter = function (n, edges) {\\n    let graph = new Map()\\n    let distMap = new Map()\\n    for (const [a, b] of edges) {\\n        u = a - 1\\n        v = b - 1\\n        if (!graph.has(u)) {\\n            graph.set(u, [])\\n        }\\n        if (!graph.has(v)) {\\n            graph.set(v, [])\\n        }\\n        graph.get(u).push(v)\\n        graph.get(v).push(u)\\n    }\\n    for (let mask = 0; mask < (1 << n); mask++) {\\n        let select = []\\n        for (let j = 0; j < n; j++) {\\n            if (mask & (1 << j)) {\\n                select.push(j)\\n            }\\n        }\\n        let size = getComponentSize(graph, select, n)\\n        if (size === 1) {\\n            let dist = getTreeDiameter(graph, select, n)\\n            if (!distMap.has(dist)) {\\n                distMap.set(dist, [])\\n            }\\n            distMap.get(dist).push(select)\\n        }\\n    }\\n    let ans = Array(n - 1).fill(0)\\n    for (let d = 1; d <= n - 1; d++) {\\n        let count = 0\\n        if (distMap.has(d)) {\\n            count = distMap.get(d).length\\n        }\\n        ans[d - 1] = count\\n    }\\n    return ans\\n};", "var countSubgraphsForEachDiameter = function (n, edges) {\\n    let graph = new Map()\\n    let distMap = new Map()\\n    for (const [a, b] of edges) {\\n        u = a - 1\\n        v = b - 1\\n        if (!graph.has(u)) {\\n            graph.set(u, [])\\n        }\\n        if (!graph.has(v)) {\\n            graph.set(v, [])\\n        }\\n        graph.get(u).push(v)\\n        graph.get(v).push(u)\\n    }\\n    for (let mask = 0; mask < (1 << n); mask++) {\\n        let select = []\\n        for (let j = 0; j < n; j++) {\\n            if (mask & (1 << j)) {\\n                select.push(j)\\n            }\\n        }\\n        let size = getComponentSize(graph, select, n)\\n        if (size === 1) {\\n            let dist = getTreeDiameter(graph, select, n)\\n            if (!distMap.has(dist)) {\\n                distMap.set(dist, [])\\n            }\\n            distMap.get(dist).push(select)\\n        }\\n    }\\n    let ans = Array(n - 1).fill(0)\\n    for (let d = 1; d <= n - 1; d++) {\\n        let count = 0\\n        if (distMap.has(d)) {\\n            count = distMap.get(d).length\\n        }\\n        ans[d - 1] = count\\n    }\\n    return ans\\n};"]}
{"id": "2042", "ref_js": ["var areConnected = function(n, threshold, queries) {\\n    \\n    ", "var areConnected = function(n, threshold, queries) {\\n    \\n    ", "var areConnected = function(n, threshold, queries) {\\n    \\n    "]}
{"id": "2043", "ref_js": ["var matrixRankTransform = function(matrix) {\\n    const n = matrix.length;\\n\\tconst m = matrix[0].length;\\n    ", "var matrixRankTransform = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let rank = new Array(n+m).fill(0);\\n    let map = Object.create(null);\\n    for (let i = 0; i<n; i++) {\\n        for (let j = 0; j<m; j++) {\\n            let num = matrix[i][j];\\n            map[num] = map[num]||[];\\n            map[num].push([i, j]);\\n        }\\n    }\\n    let nums = Object.keys(map).sort((a, b)=>a-b);\\n    for (let num of nums) {\\n        let dsu_param = [];\\n        for (let [x, y] of map[num])\\n            dsu_param.push(x, y+n);\\n        let dsu = new DSU(dsu_param);\\n        for (let [x, y] of map[num])\\n            dsu.union(x, y+n);\\n        let dsu_groups = Object.values(dsu.groups());\\n        for (let group of dsu_groups) {\\n            let max = 0;\\n            for (let i = 0; i<group.length; i++)\\n                max = Math.max(max, rank[group[i]]);\\n            for (let i = 0; i<group.length; i++)\\n                rank[group[i]] = max+1;\\n        }\\n        for (let [x, y] of map[num])\\n            matrix[x][y] = rank[x];\\n    }\\n    return matrix;\\n};", "var matrixRankTransform = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let rank = new Array(n+m).fill(0);\\n    let map = Object.create(null);\\n    for (let i = 0; i<n; i++) {\\n        for (let j = 0; j<m; j++) {\\n            let num = matrix[i][j];\\n            map[num] = map[num]||[];\\n            map[num].push([i, j]);\\n        }\\n    }\\n    let nums = Object.keys(map).sort((a, b)=>a-b);\\n    for (let num of nums) {\\n        let dsu_param = [];\\n        for (let [x, y] of map[num])\\n            dsu_param.push(x, y+n);\\n        let dsu = new DSU(dsu_param);\\n        for (let [x, y] of map[num])\\n            dsu.union(x, y+n);\\n        let dsu_groups = Object.values(dsu.groups());\\n        for (let group of dsu_groups) {\\n            let max = 0;\\n            for (let i = 0; i<group.length; i++)\\n                max = Math.max(max, rank[group[i]]);\\n            for (let i = 0; i<group.length; i++)\\n                rank[group[i]] = max+1;\\n        }\\n        for (let [x, y] of map[num])\\n            matrix[x][y] = rank[x];\\n    }\\n    return matrix;\\n};"]}
{"id": "2044", "ref_js": ["var numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n\\n  const dp = (targetIndex, wordsIndex, minIndex) => {\\n    if (targetIndex === targetLength) {\\n      return 1;\\n    }\\n    if (wordsIndex === wordsLength) return 0;\\n    let res = 0;\\n    res += dp(targetIndex, wordsIndex + 1, minIndex);\\n    for (let j = minIndex; j < wordLength; j++) {\\n      if (words[wordsIndex][j] === target[targetIndex]) {\\n        res += dp(targetIndex + 1, 0, j + 1);\\n      }\\n    }\\n    return res % (1e9 +7);\\n  }\\n\\n  return dp(0, 0, 0);\\n};", "var numWays = function(words, target) {\\n    const mod = 1e9 + 7;\\n    const m = words.length;\\n    const n = words[0].length;\\n    \\n    ", "var numWays = function(words, target) {\\n    const mod = 1e9 + 7;\\n    const m = words.length;\\n    const n = words[0].length;\\n    \\n    "]}
{"id": "2045", "ref_js": ["var smallestStringWithSwaps = function(s, pairs) {\\nfunction DisjointSet(len) {\\nthis.par = [];\\nfor (let i = 0; i < len; ++i) {\\nthis.par[i] = i;\\n}\\n}\\nDisjointSet.prototype.find = function(u) {\\nreturn (this.par[u] = this.par[u] == u ? u : this.find(this.par[u]));\\n};", "var smallestStringWithSwaps = function(s, pairs) {\\n    const DS = [...Array(s.length)].map((_, i) => i);\\n    const group = new Map()\\n    const charMap = new Map();\\n    const result = [];\\n    \\n    function find(id) { \\n        if(id === DS[id]) return id;\\n        DS[id] = find(DS[id]);\\n        return DS[id];\\n    }\\n    \\n    for(let [u, v] of pairs) {\\n        const rootU = find(u);\\n        const rootV = find(v);\\n        DS[rootV] = rootU\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        find(i)\\n        if(!charMap.has(s[i])) charMap.set(s[i], []);\\n        if(!group.has(DS[i])) group.set(DS[i], []);\\n        charMap.get(s[i]).push(i);\\n        group.get(DS[i]).push(i);\\n    }\\n    \\n    const charSorted = [...charMap.entries()].sort(([a], [b]) => a.charCodeAt() - b.charCodeAt());\\n    \\n    for(let [char, idxs] of charSorted) {\\n        for(let i of idxs) {\\n            const newIdx = group.get(DS[i]).shift();\\n            result[newIdx] = char;\\n        }\\n    }\\n    return result.join(\\'\\')\\n};", "var smallestStringWithSwaps = function(s, pairs) {\\nfunction DisjointSet(len) {\\nthis.par = [];\\nfor (let i = 0; i < len; ++i) {\\nthis.par[i] = i;\\n}\\n}\\nDisjointSet.prototype.find = function(u) {\\nreturn (this.par[u] = this.par[u] == u ? u : this.find(this.par[u]));\\n};"]}
{"id": "2046", "ref_js": ["var minimumTeachings = function(n, languages, friendships) {\\n    const size = languages.length;\\n    const communicate = Array(size).fill(\\'\\').map(_ => Array(n).fill(false));\\n    const users = new Set();\\n    let result = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < size; index++) {\\n        for (const language of languages[index]) {\\n            communicate[index][language - 1] = true;\\n        }\\n    }\\n    for (const [a, b] of friendships) {\\n        const isCommunicate = communicate[a - 1].some((isKnow, language) => {\\n            return isKnow ? communicate[b - 1][language] : isKnow;\\n        });\\n\\n        if (isCommunicate) continue;\\n        users.add(a - 1).add(b - 1);\\n    }\\n    for (let language = 0; language < n; language++) {\\n        let teach = 0;\\n\\n        for (const user of users) {\\n            !communicate[user][language] && teach++\\n        }\\n        result = Math.min(teach, result);\\n    }\\n    return result;\\n};", "var minimumTeachings = function(n, languages, friendships) {\\n    const size = languages.length;\\n    const communicate = Array(size).fill(\\'\\').map(_ => Array(n).fill(false));\\n    const users = new Set();\\n    let result = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < size; index++) {\\n        for (const language of languages[index]) {\\n            communicate[index][language - 1] = true;\\n        }\\n    }\\n    for (const [a, b] of friendships) {\\n        const isCommunicate = communicate[a - 1].some((isKnow, language) => {\\n            return isKnow ? communicate[b - 1][language] : isKnow;\\n        });\\n\\n        if (isCommunicate) continue;\\n        users.add(a - 1).add(b - 1);\\n    }\\n    for (let language = 0; language < n; language++) {\\n        let teach = 0;\\n\\n        for (const user of users) {\\n            !communicate[user][language] && teach++\\n        }\\n        result = Math.min(teach, result);\\n    }\\n    return result;\\n};", "var minimumTeachings = function(n, languages, friendships) {\\n    const size = languages.length;\\n    const communicate = Array(size).fill(\\'\\').map(_ => Array(n).fill(false));\\n    const users = new Set();\\n    let result = Number.MAX_SAFE_INTEGER;\\n\\n    for (let index = 0; index < size; index++) {\\n        for (const language of languages[index]) {\\n            communicate[index][language - 1] = true;\\n        }\\n    }\\n    for (const [a, b] of friendships) {\\n        const isCommunicate = communicate[a - 1].some((isKnow, language) => {\\n            return isKnow ? communicate[b - 1][language] : isKnow;\\n        });\\n\\n        if (isCommunicate) continue;\\n        users.add(a - 1).add(b - 1);\\n    }\\n    for (let language = 0; language < n; language++) {\\n        let teach = 0;\\n\\n        for (const user of users) {\\n            !communicate[user][language] && teach++\\n        }\\n        result = Math.min(teach, result);\\n    }\\n    return result;\\n};"]}
{"id": "2047", "ref_js": ["var canDistribute = function(nums, quantity) {\\n    let freq = {}\\n    for(let n of nums) {\\n      if(freq[n]) freq[n]++\\n      else freq[n] = 1\\n    }\\n\\n    const values = Object.values(freq)\\n    quantity = quantity.sort((a,b) => a - b)\\n\\n    function dfs(){\\n      if(quantity.length === 0) return true\\n      for(let j = 0; j < values.length; j++){\\n        const v = values[j]\\n        if(v < quantity[quantity.length - 1]) continue\\n        const q = quantity.pop()\\n        values[j] = v - q\\n        if(dfs()) return true\\n        values[j] = v\\n        quantity.push(q)\\n      }\\n      return false\\n    }\\n    return  dfs()\\n};", "var canDistribute = function(nums, quantity) {\\n    let freq = {}\\n    for(let n of nums) {\\n      if(freq[n]) freq[n]++\\n      else freq[n] = 1\\n    }\\n\\n    const values = Object.values(freq)\\n    quantity = quantity.sort((a,b) => a - b)\\n\\n    function dfs(){\\n      if(quantity.length === 0) return true\\n      for(let j = 0; j < values.length; j++){\\n        const v = values[j]\\n        if(v < quantity[quantity.length - 1]) continue\\n        const q = quantity.pop()\\n        values[j] = v - q\\n        if(dfs()) return true\\n        values[j] = v\\n        quantity.push(q)\\n      }\\n      return false\\n    }\\n    return  dfs()\\n};", "var canDistribute = function(nums, quantity) {\\n    let freq = {}\\n    for(let n of nums) {\\n      if(freq[n]) freq[n]++\\n      else freq[n] = 1\\n    }\\n\\n    const values = Object.values(freq)\\n    quantity = quantity.sort((a,b) => a - b)\\n\\n    function dfs(){\\n      if(quantity.length === 0) return true\\n      for(let j = 0; j < values.length; j++){\\n        const v = values[j]\\n        if(v < quantity[quantity.length - 1]) continue\\n        const q = quantity.pop()\\n        values[j] = v - q\\n        if(dfs()) return true\\n        values[j] = v\\n        quantity.push(q)\\n      }\\n      return false\\n    }\\n    return  dfs()\\n};"]}
{"id": "2048", "ref_js": ["var maxScore = function(nums1, nums2, k) {\\n    ", "var maxScore = function(nums1, nums2, k) {\\n\\n    let result = 0;\\n    let totalSum = 0;\\n    let heap = new MinPriorityQueue({priority: (element) => element})\\n\\n    const merged = nums1.map((nums1Val, i) => [nums2[i], nums1Val])\\n    merged.sort((a,b) => b[0] - a[0])\\n\\n    for (const [maxOf2, num1Val] of merged){\\n        if(heap.size() === k){\\n            totalSum -= heap.dequeue().element\\n        }\\n\\n        totalSum += num1Val\\n        heap.enqueue(num1Val)\\n\\n        if(heap.size() === k){\\n            result = Math.max(result, totalSum * maxOf2)\\n        }\\n\\n    }\\n\\nreturn result\\n};", "var maxScore = function(nums1, nums2, k) {\\n   let minHeap = new MinPriorityQueue();\\n   let zipped = nums1.map((num1, i) => [num1, nums2[i]]);\\n   zipped.sort((a, b) => b[1] - a[1]);\\n\\n   let answer = 0; sum = 0;\\n   for(let [num, min] of zipped){\\n       minHeap.enqueue(num);\\n       sum += num;\\n\\n       if(minHeap.size() == k){\\n           answer = Math.max(answer, sum * min);\\n           sum -= minHeap.dequeue().element\\n       }\\n   }   \\n  return answer;\\n};"]}
{"id": "2049", "ref_js": ["var minimumEffort = function(tasks) {\\n    ", "var minimumEffort = function(tasks) {\\n  let minimumStartingEnergy = 0;\\n  let currentEnergy = 0;\\n  \\n  tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]) );\\n  \\n  for (let task of tasks) {\\n    if (task[1] > currentEnergy) {\\n      minimumStartingEnergy += (task[1] - currentEnergy);\\n      currentEnergy = task[1];\\n    }\\n    currentEnergy -= task[0];\\n  }\\n  \\n  return minimumStartingEnergy;\\n};", "var minimumEffort = function(tasks) {\\n  let minimumStartingEnergy = 0;\\n  let currentEnergy = 0;\\n  \\n  tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]) );\\n  \\n  for (let task of tasks) {\\n    if (task[1] > currentEnergy) {\\n      minimumStartingEnergy += (task[1] - currentEnergy);\\n      currentEnergy = task[1];\\n    }\\n    currentEnergy -= task[0];\\n  }\\n  \\n  return minimumStartingEnergy;\\n};"]}
{"id": "2050", "ref_js": ["var minimumMountainRemovals = function (nums) {\\n  const n = nums.length;\\n  const nm1 = n - 1;\\n  const pre = Array(n).fill(0);\\n  const h = Array(n).fill(2e9);\\n\\n  let i, l, r, m, p;\\n  h[0] = nums[0];\\n  for (i = 1; i < n - 1; i++) {\\n    l = 0;\\n    p = 0;\\n    r = i;\\n\\n    while (l <= r) {\\n      m = (r + l) >> 1;\\n\\n      if (h[m] < nums[i]) {\\n        l = m + 1;\\n        p = l;\\n      } else r = m - 1;\\n    }\\n\\n    h[p] = nums[i];\\n    pre[i] = p;\\n  }\\n\\n  let lis = 0;\\n  h.fill(2e9);\\n  h[0] = nums[nm1];\\n  for (i = n - 2; i > 0; i--) {\\n    l = 0;\\n    p = 0;\\n    r = nm1 - i;\\n\\n    while (l <= r) {\\n      m = (r + l) >> 1;\\n\\n      if (h[m] < nums[i]) {\\n        l = m + 1;\\n        p = l;\\n      } else r = m - 1;\\n    }\\n\\n    h[p] = nums[i];\\n    if (p && pre[i]) lis = Math.max(lis, p + pre[i]);\\n  }\\n\\n  return nm1 - lis;\\n};", "var minimumMountainRemovals = function(nums) {\\n    let n=nums.length\\n    let previous=Array.from({length:n},item=>1)\\n    let previous2=Array.from({length:n},item=>1)\\n    ", "var minimumMountainRemovals = function(nums) {\\n    let n=nums.length\\n    let previous=Array.from({length:n},item=>1)\\n    let previous2=Array.from({length:n},item=>1)\\n    "]}
{"id": "2051", "ref_js": ["var minimumDeviation = function(nums) {\\n    let map = [];\\n    let alreadyUpper = true;\\n    let alreadyLower = true;\\n    for(let n of nums) {\\n        if(n%2===0) alreadyLower = false;\\n        else alreadyUpper = false;\\n        map[n] = 1;\\n    }\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let minDeviation = max-min;\\n    ", "var minimumDeviation = function(nums) {\\n    let map = [];\\n    let alreadyUpper = true;\\n    let alreadyLower = true;\\n    for(let n of nums) {\\n        if(n%2===0) alreadyLower = false;\\n        else alreadyUpper = false;\\n        map[n] = 1;\\n    }\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let minDeviation = max-min;\\n    ", "var minimumDeviation = function(nums) {\\n    let map = [];\\n    let alreadyUpper = true;\\n    let alreadyLower = true;\\n    for(let n of nums) {\\n        if(n%2===0) alreadyLower = false;\\n        else alreadyUpper = false;\\n        map[n] = 1;\\n    }\\n    let sortedArr = Object.keys(map);\\n    let min = sortedArr[0];\\n    let max = sortedArr[sortedArr.length-1];\\n    let minDeviation = max-min;\\n    "]}
{"id": "2052", "ref_js": ["var minimumIncompatibility = function(nums, k) {\\n\\t", "var recur = function(curIdx, subsets, nums, k, countOfEveryGroup, currentSum) {\\n    if (curIdx === nums.length && currentSum < minSum) {\\n        minSum = currentSum;\\n        return;\\n    }\\n    var curNum = nums[curIdx];\\n    for (var subsetIdx = 0; subsetIdx < subsets.length; subsetIdx++) {\\n        var subset = subsets[subsetIdx];\\n        if (subset.length >= countOfEveryGroup || subset.indexOf(curNum) !== -1) continue;\\n        var minOfCurSubSet = Math.min(...subset);\\n        var maxOfCurSubSet = Math.max(...subset);\\n        subset.push(curNum);\\n        var shouldAddToSum = 0;\\n        if (curNum > maxOfCurSubSet) {\\n            shouldAddToSum += (curNum - maxOfCurSubSet);\\n        } else if (curNum < minOfCurSubSet) {\\n            shouldAddToSum += (minOfCurSubSet - curNum);\\n        }\\n        var newSum = currentSum + shouldAddToSum;\\n        if (newSum < minSum) {\\n            recur(curIdx + 1, subsets, nums, k, countOfEveryGroup, newSum);\\n        }\\n        subset.pop();\\n    }\\n    if (subsets.length < k) {\\n        var newSubset = [curNum];\\n        subsets.push(newSubset);\\n        recur(curIdx + 1, subsets, nums, k, countOfEveryGroup, currentSum);\\n        subsets.pop();\\n    }\\n};", "var minimumIncompatibility = function(nums, k) {\\n\\t"]}
{"id": "2053", "ref_js": ["var boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {\\n    \\n    const trips = Array(boxes.length + 1).fill(0);\\n    let left = 0;\\n    let diff = 0;\\n    \\n    for (let right = 0; right < boxes.length; right++) {\\n        maxBoxes--;\\n        maxWeight -= boxes[right][1];\\n        if (right > 0 && boxes[right][0] !== boxes[right - 1][0]) diff++;\\n        \\n        while (maxBoxes < 0 || maxWeight < 0 || (left < right && trips[left + 1] === trips[left])) {\\n            maxBoxes++;\\n            maxWeight += boxes[left++][1];\\n            if (boxes[left][0] !== boxes[left - 1][0]) diff--;\\n        }\\n        \\n        trips[right + 1] = diff + 2 + trips[left];\\n    }\\n    \\n    return trips[boxes.length];\\n};", "var boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {\\n    \\n    const trips = Array(boxes.length + 1).fill(0);\\n    let left = 0;\\n    let diff = 0;\\n    \\n    for (let right = 0; right < boxes.length; right++) {\\n        maxBoxes--;\\n        maxWeight -= boxes[right][1];\\n        if (right > 0 && boxes[right][0] !== boxes[right - 1][0]) diff++;\\n        \\n        while (maxBoxes < 0 || maxWeight < 0 || (left < right && trips[left + 1] === trips[left])) {\\n            maxBoxes++;\\n            maxWeight += boxes[left++][1];\\n            if (boxes[left][0] !== boxes[left - 1][0]) diff--;\\n        }\\n        \\n        trips[right + 1] = diff + 2 + trips[left];\\n    }\\n    \\n    return trips[boxes.length];\\n};", "var boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {\\n    \\n    const trips = Array(boxes.length + 1).fill(0);\\n    let left = 0;\\n    let diff = 0;\\n    \\n    for (let right = 0; right < boxes.length; right++) {\\n        maxBoxes--;\\n        maxWeight -= boxes[right][1];\\n        if (right > 0 && boxes[right][0] !== boxes[right - 1][0]) diff++;\\n        \\n        while (maxBoxes < 0 || maxWeight < 0 || (left < right && trips[left + 1] === trips[left])) {\\n            maxBoxes++;\\n            maxWeight += boxes[left++][1];\\n            if (boxes[left][0] !== boxes[left - 1][0]) diff--;\\n        }\\n        \\n        trips[right + 1] = diff + 2 + trips[left];\\n    }\\n    \\n    return trips[boxes.length];\\n};"]}
{"id": "2054", "ref_js": ["var maxHeight = function (cuboids) {\\n  const n = cuboids.length;\\n  const sortedCuboids = cuboids.map((cuboid) => cuboid.sort((a, b) => a - b));\\n  sortedCuboids.sort((a, b) => {\\n    if (a[0] !== b[0]) return a[0] - b[0];\\n    if (a[1] !== b[1]) return a[1] - b[1];\\n    return a[2] - b[2];\\n  });\\n\\n  let ans = 0;\\n  const maxHeights = new Array(n).fill(0);\\n  for (let i = 0; i < n; i++) {\\n    const [currWidth, currLength, currHeight] = sortedCuboids[i];\\n    maxHeights[i] = currHeight;\\n    for (let j = i - 1; j >= 0; j--) {\\n      const [prevWidth, prevLength, prevHeight] = sortedCuboids[j];\\n      if (\\n        currWidth >= prevWidth &&\\n        currLength >= prevLength &&\\n        currHeight >= prevHeight\\n      ) {\\n        maxHeights[i] = Math.max(maxHeights[i], maxHeights[j] + currHeight);\\n      }\\n    }\\n    ans = Math.max(ans, maxHeights[i]);\\n  }\\n\\n  return ans;\\n};", "var maxHeight = function(cuboids) {\\n    \\n    for(let i=0;i<cuboids.length;i++){\\n        cuboids[i].sort((a,b)=>a-b);\\n\\n    }\\n    cuboids.sort((a,b)=>a[0]==b[0] ? a[1]==b[1]? a[2]-b[2]:a[1]-b[1]: a[0]-b[0]);\\n  \\n\\n    return solveTabFurther(cuboids);\\n};", "var maxHeight = function(cuboids) {\\n    cuboids.map(x => x.sort((a, b) => a - b));\\n    cuboids.sort((a, b) => {\\n        if (a[2] == b[2]) {\\n            if (a[1] == b[1]) {\\n                return a[0] - b[0];\\n            } else {\\n                return a[1] - b[1];\\n            }\\n        } else {\\n            return a[2] - b[2];\\n        }\\n\\n    });\\n\\n    let dp = [cuboids[0][2]];\\n\\n    for (let i = 1; i < cuboids.length; i++) {\\n        dp[i] = cuboids[i][2];\\n        for (let j = 0; j < i; j++) {\\n            if (canStack(cuboids[i], cuboids[j])) {\\n                dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);\\n            }\\n        }\\n    }\\n\\n    return Math.max(...dp);\\n};"]}
{"id": "2055", "ref_js": ["var distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const uf = new UnionFind(n), ans = [];\\n\\n    ", "var distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    \\n    let uf = new  UnionFind(n)\\n    \\n    edgeList.sort((a,b) => a[2] - b[2])\\n    \\n    let queries_sorted = queries.map((q,i) => [q[2], i, q[0], q[1]])\\n    queries_sorted.sort((a,b ) => a[0] - b[0])\\n    \\n    let result = Array(queries_sorted.length).fill(false)\\n\\n    \\n    let edges_index = 0\\n    \\n    \\n    for(let [limit, query_index, p, q] of queries_sorted){\\n       \\n        while(edges_index < edgeList.length && edgeList[edges_index][2] < limit){\\n            \\n            uf.union(edgeList[edges_index][0], edgeList[edges_index][1])\\n            edges_index += 1\\n        }\\n        \\n        if(uf.connected(p,q)){\\n            result[query_index] = true\\n        }\\n   \\n    }\\n       \\n  return result\\n};", "var distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const uf = new UnionFind(n), ans = [];\\n\\n    "]}
{"id": "2056", "ref_js": ["var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};", "var twoSum = function(nums, target) {\\n    const numToIndex = new Map(); ", "var twoSum = function(nums, target) {\\n    let mp = new Map()\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let diff = target - nums[i]\\n        \\n        if (mp.has(diff)) {\\n            return [i, mp.get(diff)]\\n        }\\n        \\n        mp.set(nums[i], i)\\n    }\\n};"]}
{"id": "2057", "ref_js": ["var maximizeXor = function (nums, queries) {\\n  const result = new Array(queries.length);\\n  \\n  ", "var maximizeXor = function (nums, queries) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let q = queries.length;\\n  let res = Array(q).fill();\\n\\n  let m = 0;\\n  let x = 0;\\n  let p = 0;\\n  let l = 0;\\n  let r = 0;\\n  let bsl = 0;\\n  let bsr = 0;\\n  let b = 0;\\n\\n  for (let i = 0; i < q; i++) {\\n    x = queries[i][0];\\n    m = queries[i][1];\\n\\n    if (m < nums[0]) {\\n      res[i] = -1;\\n      continue;\\n    }\\n\\n    r = 0;\\n    bsl = 0;\\n    bsr = n-1;\\n\\n    while (bsl <= bsr) {\\n      let mid = (bsl + bsr) >> 1;\\n\\n      if (nums[mid] <= m) {\\n        r = mid;\\n        bsl = mid + 1;\\n      }\\n      else bsr = mid - 1;\\n    }\\n\\n    b = Math.ceil(Math.log2(Math.max(nums[r], x) + 1));\\n\\n    l = 0;\\n    r = r;\\n\\n    while (nums[r] != nums[l]) {\\n      if (getBit(nums[r], b) != getBit(nums[l], b)) {\\n        p = l;\\n        bsl = l;\\n        bsr = r;\\n        while (bsl <= bsr) {\\n          m = (bsl + bsr) >> 1;\\n          if (getBit(nums[m], b)) bsr = m - 1;\\n          else {\\n            bsl = m + 1;\\n            p = m;\\n          }\\n        }\\n        if (getBit(x, b)) r = p;\\n        else l = p + 1;\\n      }\\n\\n      b--;\\n    }\\n\\n    res[i] = x ^ nums[r];\\n  }\\n\\n  return res;\\n};", "var maximizeXor = function (nums, queries) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let q = queries.length;\\n  let res = Array(q).fill();\\n\\n  let m = 0;\\n  let x = 0;\\n  let p = 0;\\n  let l = 0;\\n  let r = 0;\\n  let bsl = 0;\\n  let bsr = 0;\\n  let b = 0;\\n\\n  for (let i = 0; i < q; i++) {\\n    x = queries[i][0];\\n    m = queries[i][1];\\n\\n    if (m < nums[0]) {\\n      res[i] = -1;\\n      continue;\\n    }\\n\\n    r = 0;\\n    bsl = 0;\\n    bsr = n-1;\\n\\n    while (bsl <= bsr) {\\n      let mid = (bsl + bsr) >> 1;\\n\\n      if (nums[mid] <= m) {\\n        r = mid;\\n        bsl = mid + 1;\\n      }\\n      else bsr = mid - 1;\\n    }\\n\\n    b = Math.ceil(Math.log2(Math.max(nums[r], x) + 1));\\n\\n    l = 0;\\n    r = r;\\n\\n    while (nums[r] != nums[l]) {\\n      if (getBit(nums[r], b) != getBit(nums[l], b)) {\\n        p = l;\\n        bsl = l;\\n        bsr = r;\\n        while (bsl <= bsr) {\\n          m = (bsl + bsr) >> 1;\\n          if (getBit(nums[m], b)) bsr = m - 1;\\n          else {\\n            bsl = m + 1;\\n            p = m;\\n          }\\n        }\\n        if (getBit(x, b)) r = p;\\n        else l = p + 1;\\n      }\\n\\n      b--;\\n    }\\n\\n    res[i] = x ^ nums[r];\\n  }\\n\\n  return res;\\n};"]}
{"id": "2058", "ref_js": ["var lengthOfLIS = function(A) {\\n    if(!A.length) return 0;\\n    let tails = [-Infinity];  ", "var lengthOfLIS = function(A) {\\n    if(!A.length) return 0;\\n    let tails = [-Infinity];  ", "var lengthOfLIS = function(A) {\\n    if(!A.length) return 0;\\n    let tails = [-Infinity];  "]}
{"id": "2059", "ref_js": ["var checkWays = function (pairs) {\\n  \\n  \\n  let graph = new Map();\\n  \\n  let nodes = [];\\n\\n  for (let [u, v] of pairs) {\\n    let ug = graph.get(u);\\n    let vg = graph.get(v);\\n    if (!ug) {\\n      ug = { adj: new Set(), lab: u, id: u };", "var checkWays = function (pairs) {\\n  \\n  \\n  let graph = new Map();\\n  \\n  let nodes = [];\\n\\n  for (let [u, v] of pairs) {\\n    let ug = graph.get(u);\\n    let vg = graph.get(v);\\n    if (!ug) {\\n      ug = { adj: new Set(), lab: u, id: u };", "var checkWays = function (pairs) {\\n  \\n  \\n  let graph = new Map();\\n  \\n  let nodes = [];\\n\\n  for (let [u, v] of pairs) {\\n    let ug = graph.get(u);\\n    let vg = graph.get(v);\\n    if (!ug) {\\n      ug = { adj: new Set(), lab: u, id: u };"]}
{"id": "2060", "ref_js": ["var minimumTimeRequired = function (A, k) {\\n  const N = A.length;\\n  let res = Infinity;\\n  const worker = Array(k).fill(0);\\n\\u200B\\n  const dfs = (idx = 0) => {\\n    if (idx === N) {\\n      res = Math.min(res, Math.max(...worker));\\n      return;\\n    }\\n\\u200B\\n    for (let i = 0; i < k; i++) {\\n      if (worker[i] + A[idx] > res) continue;\\n      worker[i] += A[idx];\\n      dfs(idx + 1);\\n      worker[i] -= A[idx];\\n      if (!worker[i]) break;\\n    }\\n  };", "var minimumTimeRequired = function (A, k) {\\n  const N = A.length;\\n  let res = Infinity;\\n  const worker = Array(k).fill(0);\\n\\u200B\\n  const dfs = (idx = 0) => {\\n    if (idx === N) {\\n      res = Math.min(res, Math.max(...worker));\\n      return;\\n    }\\n\\u200B\\n    for (let i = 0; i < k; i++) {\\n      if (worker[i] + A[idx] > res) continue;\\n      worker[i] += A[idx];\\n      dfs(idx + 1);\\n      worker[i] -= A[idx];\\n      if (!worker[i]) break;\\n    }\\n  };", "var minimumTimeRequired = function (A, k) {\\n  const N = A.length;\\n  let res = Infinity;\\n  const worker = Array(k).fill(0);\\n\\u200B\\n  const dfs = (idx = 0) => {\\n    if (idx === N) {\\n      res = Math.min(res, Math.max(...worker));\\n      return;\\n    }\\n\\u200B\\n    for (let i = 0; i < k; i++) {\\n      if (worker[i] + A[idx] > res) continue;\\n      worker[i] += A[idx];\\n      dfs(idx + 1);\\n      worker[i] -= A[idx];\\n      if (!worker[i]) break;\\n    }\\n  };"]}
{"id": "2061", "ref_js": ["var canMouseWin = function (grid, catJump, mouseJump) {\\n    let mouse\\n    let cat\\n    let food\\n    let n = grid.length\\n    let m = grid[0].length\\n    let directions = [\\n        [0, 1],\\n        [0, -1],\\n        [1, 0],\\n        [-1, 0]\\n    ]\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (grid[i][j] === \\'M\\') {\\n                mouse = [i, j]\\n            }\\n            if (grid[i][j] === \\'C\\') {\\n                cat = [i, j]\\n            }\\n            if (grid[i][j] === \\'F\\') {\\n                food = [i, j]\\n            }\\n        }\\n    }\\n    function within(x, y) {\\n        if (x < 0 ||\\n            x >= n ||\\n            y < 0 ||\\n            y >= m) return false\\n        return true\\n    }\\n    let dp = new Map()\\n    function dfs(mx, my, cx, cy, turn) {\\n        if (turn >= 100) return false\\n        let [fx, fy] = food\\n        if (mx === cx && my == cy) return false\\n        if (fx === mx && fy === my) return true\\n        if (fx === cx && fy === cy) return false\\n        let key = `${mx}|${my}|${cx}|${cy}|${turn}`\\n        if (dp.has(key)) return dp.get(key)\\n        if (turn % 2 === 0) {\\n            ", "var canMouseWin = function (grid, catJump, mouseJump) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  winners.fill(0);\\n  q.clear();\\n\\n  \\n  function forEachJump(startR, startC, jumpLimit, cb, includeCurrent) {\\n    if (includeCurrent) cb(startR, startC);\\n\\n    for (let dir = 0; dir < 4; ++dir) {\\n      let r = startR;\\n      let c = startC;\\n      for (let j = 1; j <= jumpLimit; ++j) {\\n        r += DIR_R[dir];\\n        c += DIR_C[dir];\\n        if (grid[r]?.[c] == undefined || grid[r][c] == \"#\") break;\\n        cb(r, c);\\n      }\\n    }\\n  }\\n\\n  ", "var canMouseWin = function(A, maxC  , maxM) {\\n    let n=A.length,m=A[0].length,seen={},\\n        pos=[[0,1],[0,-1],[1,0],[-1,0]],xM,yM,xC,yC,xF,yF\\n    for (let i = 0; i < n; i++) \\n        for (let j = 0; j < m; j++) \\n            if(A[i][j]===\\'M\\')[xM,yM]=[i,j]\\n            else if (A[i][j]===\\'C\\')[xC,yC]=[i,j]\\n            else if(A[i][j]===\\'F\\')[xF,yF]=[i,j]            \\n\\n    let invalid=([x,y])=>(x<0||x>=n||y<0||y>=m)?true:A[x][y]===\\'#\\'\\n\\n    "]}
{"id": "2062", "ref_js": ["var waysToFillArray = function (queries) {\\n    return queries.map(([n, k]) =>\\n        [...primeFactors[k]].reduce((ways, [_, freq]) =>\\n            ways * nCr[n + freq - 1][freq] % mod, 1n)\\n    );\\n};", "var waysToFillArray = function(Q) {\\n    let mod=1e9+7,memo=new Map()   \\n    let recursion=(i,j)=>{ \\n        if(i==1 || j==1)\\n            return 1\\n        let state=[i,j]+\\'\\',sum=0\\n        if(memo.get(state))\\n            return memo.get(state)\\n        for(let factor=1;factor<=j;factor++)\\n            if(j%factor==0) ", "var waysToFillArray = function(Q) {\\n    let mod=1e9+7,memo=new Map()   \\n    let recursion=(i,j)=>{ \\n        if(i==1 || j==1)\\n            return 1\\n        let state=[i,j]+\\'\\',sum=0\\n        if(memo.get(state))\\n            return memo.get(state)\\n        for(let factor=1;factor<=j;factor++)\\n            if(j%factor==0) "]}
{"id": "2063", "ref_js": ["var minimumBoxes = function(n) {\\n    ", "var minimumBoxes = function(n) {\\n    let wag = invtet(n) ", "var minimumBoxes = function (n) {\\n    let s = 0, x = 0, next = 1\\n    while (s + x + next <= n) {\\n        s += x + next\\n        x += next\\n        next++\\n    }\\n    next = 1\\n    while (s < n) {\\n        s += next\\n        next++\\n        x++\\n    }\\n    return x\\n};"]}
{"id": "2064", "ref_js": ["var checkPartitioning = function(s) {\\n    if(s.length < 3) \\n        return false;\\n\\n    let left = 0;\\n    let right = 1;\\n    \\n    while(left < s.length - 1) {\\n    \\n        ", "var checkPartitioning = function(s) {\\n    ", "var checkPartitioning = function(s) {\\n    if(s.length < 3) \\n        return false;\\n\\n    let left = 0;\\n    let right = 1;\\n    \\n    while(left < s.length - 1) {\\n    \\n        "]}
{"id": "2065", "ref_js": ["var f = function(ind,k,events,dp){\\n    if(ind == events.length || k == 0) return 0;\\n    \\n    if(dp[ind][k] != -1) return dp[ind][k];\\n    let take = events[ind][2];\\n    for(let i = ind+1; i < events.length; ++i){\\n        if(events[ind][1] < events[i][0]){\\n            take += f(i,k-1,events,dp);\\n            break;\\n        }\\n    }\\n    let notTake = f(ind+1,k,events,dp);\\n    return dp[ind][k] = Math.max(take,notTake);\\n}\\nvar maxValue = function(events, k) {\\n    const dp = [];\\n    events.sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0])\\n    for(let i = 0; i < events.length; ++i){\\n        dp[i] = new Array(k+1).fill(-1);\\n    }\\n    return f(0,k,events,dp);\\n};", "var maxValue = function(events, k) {\\n    events.sort((a, b) => a[1] - b[1]);\\n\\n    let dp = [[0, 0]];\\n    let dp2 = [[0, 0]];\\n\\n    for (let _ = 0; _ < k; _++) {\\n      for (let [start, end, value] of events) {\\n        let i = bisect(dp, [start]) - 1;\\n\\n        if (dp[i][1] + value > dp2[dp2.length - 1][1]) {\\n          dp2.push([end, dp[i][1] + value]);\\n        }\\n      }\\n\\n      [dp, dp2] = [dp2, [[0, 0]]];\\n    }\\n\\n    return dp[dp.length - 1][1];    \\n};", "var maxValue = function(events, k) {\\n    events.sort((a, b) => a[1] - b[1]);\\n\\n    let dp = [[0, 0]];\\n    let dp2 = [[0, 0]];\\n\\n    for (let _ = 0; _ < k; _++) {\\n      for (let [start, end, value] of events) {\\n        let i = bisect(dp, [start]) - 1;\\n\\n        if (dp[i][1] + value > dp2[dp2.length - 1][1]) {\\n          dp2.push([end, dp[i][1] + value]);\\n        }\\n      }\\n\\n      [dp, dp2] = [dp2, [[0, 0]]];\\n    }\\n\\n    return dp[dp.length - 1][1];    \\n};"]}
{"id": "2066", "ref_js": ["var minAbsDifference = function (nums, goal) {\\n  const left = [];\\n  const right = [];\\n  const N = nums.length;\\n  const n = Math.floor(N / 2); ", "var minAbsDifference = function(nums, goal) {\\n    let mid = Math.floor(nums.length / 2);\\n    let part1 = nums.slice(0, mid), part2 = nums.slice(mid);\\n\\n    function findSubsetSums(arr, set, idx = 0, sum = 0) {\\n        if (idx === arr.length) return set.add(sum);\\n        findSubsetSums(arr, set, idx + 1, sum);\\n        findSubsetSums(arr, set, idx + 1, sum + arr[idx]);\\n    }\\n    \\n    let sum1 = new Set(), sum2 = new Set();\\n    findSubsetSums(part1, sum1);\\n    findSubsetSums(part2, sum2);\\n    \\n    sum1 = [...sum1.values()];\\n    sum2 = [...sum2.values()];\\n    sum2.sort((a, b) => a - b);\\n\\n    let min = Infinity;\\n    for (let num1 of sum1) {\\n        let l = 0, r = sum2.length - 1;\\n        while (l <= r) {\\n            let mid = l + Math.floor((r - l) / 2);\\n            let num2 = sum2[mid];\\n            min = Math.min(min, Math.abs(num1 + num2 - goal));\\n            if (num1 + num2 < goal) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n    }\\n    return min;\\n};", "var minAbsDifference = function (nums, goal) {\\n  const left = [];\\n  const right = [];\\n  const N = nums.length;\\n  const n = Math.floor(N / 2); "]}
{"id": "2067", "ref_js": ["var minTrioDegree = function(n, edges) {\\n    ", "var minTrioDegree = function(n, edges) {\\n    const degree = Array(n + 1).fill(0);\\n    const isEdge = Array.from({ length: n + 1 }, () => Array(n + 1).fill(false));\\n    let minDegree = Infinity;\\n\\n    for (const [u, v] of edges) {\\n        degree[u]++;\\n        degree[v]++;\\n        isEdge[u][v] = true;\\n        isEdge[v][u] = true;\\n    }\\n\\n    for(let i = 1; i <= n; i++){\\n        for(let j = i + 1; j <= n; j++){\\n            if(isEdge[i][j]){\\n                for(let k = j + 1; k <= n; k++){\\n                    if(isEdge[i][k] && isEdge[j][k]){\\n                        let count = degree[i] + degree[j] + degree[k] - 6;\\n                        minDegree = Math.min(minDegree, count);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    return minDegree === Infinity ? -1 : minDegree;\\n};", "var minTrioDegree = function(n, edges) {\\n  for (let i = 0; i < n; i++) matrix[i].fill(0, 0, n);\\n  degree.fill(0, 0, n);\\n\\n  let m = edges.length;\\n  for (let i = 0; i < m; i++) {\\n    let [u,v] = edges[i];\\n    u--;\\n    v--;\\n    matrix[u][v] = 1;\\n    matrix[v][u] = 1;\\n    degree[u]++;\\n    degree[v]++;\\n  }\\n\\n  let res = 1000000000;\\n\\n  for (let a = 2; a < n; a++) {\\n    if (degree[a] >= res) continue;\\n    for (let b = 1; b < a; b++) {\\n      if (!matrix[a][b]) continue;\\n      if (degree[a] + degree[b] >= res) continue;\\n      for (let c = 0; c < b; c++) {\\n        if (matrix[c][b] && matrix[c][a]) \\n          res = Math.min(res, degree[a] + degree[b] + degree[c])\\n      }\\n    }\\n  }\\n\\n  return res == 1000000000? -1 : res - 6\\n};"]}
{"id": "2068", "ref_js": ["var getCoprimes = function(nums, edges) {\\n  let n = nums.length;\\n  let graph = buildGraph(n, edges); \\n  let res = Array(n).fill(-1);\\n\\n  function dfs(u, parent) {\\n    let coprimes = COPRIMES[nums[u]];\\n    let l = coprimes.length;\\n    let r = -1;\\n\\n    for (let i = 0; i < l; i++) {\\n      let lp = lastPos[coprimes[i]];\\n      if (lp.length) r = Math.max(r, lp[lp.length - 1]);\\n    }\\n\\n    if (r >= 0) res[u] = st[r];\\n    st.push(u);\\n    lastPos[nums[u]].push(st.length - 1);\\n\\n    let { aNodes } = graph[u];\\n    l = aNodes.length;\\n    for (let i = 0; i < l; i++) {\\n      if (aNodes[i] != parent) dfs(aNodes[i], u);\\n    }\\n\\n    st.pop();\\n    lastPos[nums[u]].pop();\\n  }\\n\\n  dfs(0);\\n\\n  return res;\\n};", "var getCoprimes = function(nums, edges) {\\n    \\n    const node = {}\\n    const ans = Array(nums.length).fill(null)\\n    \\n    function addNode(f, t){\\n        if(!node[f]){\\n            node[f]=[]\\n        }\\n        node[f].push(t)\\n    }\\n    \\n    edges.forEach(([f, t])=>{\\n        addNode(f, t)\\n        addNode(t, f)\\n    })\\n    \\n    function gcd(a, b){\\n        while(b) [a, b] = [b, a % b];\\n        return a;\\n    }\\n    \\n    const map = []\\n    for(let i=0; i<51; i++){\\n        map[i]=[]\\n        for(let j=0; j<51; j++){\\n            map[i][j]= gcd(i,j)\\n        }\\n    }\\n\\n    let pi=-1\\n    let path=Array(nums.length)\\n    function check(v){\\n        if(ans[v]!==null) return\\n        ans[v] = -1\\n        let a = nums[v]\\n        for(let k=pi; k>=0; k--){\\n            let b = nums[path[k]]\\n            if(map[a][b]===1){\\n                ans[v]=path[k]\\n                break\\n            }\\n        }\\n        if(node[v]) {\\n            path[++pi]=v\\n            node[v].forEach(child=>check(child))\\n            pi--\\n        }\\n    }\\n    \\n    for(let i=0; i<nums.length; i++){\\n        check(i)\\n    }\\n    \\n    return ans    \\n};", "var getCoprimes = function(nums, edges) {\\n    const output = Array(nums.length).fill(null);\\n    const graph = new Map();\\n    \\n    for(let [u, v] of edges) {\\n        if(!graph.has(u)) graph.set(u, []);\\n        if(!graph.has(v)) graph.set(v, []);\\n        graph.get(u).push(v);\\n        graph.get(v).push(u)\\n    }\\n    \\n    function getGCD(a, b) {\\n        if(!b) return a;\\n        return getGCD(b, a % b);\\n    }\\n    \\n    "]}
{"id": "2069", "ref_js": ["var maximumScore = function(nums, multipliers) {\\n    let memo = Array.from({ length: multipliers.length }, _ =>\\n        Array(multipliers.length).fill(null)\\n    )\\n    return recursion(0, 0, nums, multipliers, memo)\\n};", "var maximumScore = function(nums, multipliers) {\\n    let m = multipliers.length, n = nums.length, res = -Infinity;\\n    let dp = new Array(m+1).fill(0).map(()=>new Array(m+1).fill(0));\\n    for (let j=1; j<=m; j++) dp[0][j] = dp[0][j-1] + multipliers[j-1]*nums[n-j];\\n    for (let i=1; i<=m; i++) dp[i][0] = dp[i-1][0] + multipliers[i-1]*nums[i-1];\\n    for (let i=1; i<=m; i++) {\\n        for (let j=1; i+j<=m; j++) {\\n            dp[i][j] = Math.max(dp[i-1][j] + multipliers[i+j-1]*nums[i-1],  dp[i][j-1] + multipliers[i+j-1]*nums[n-j]);\\n        }\\n    }\\n    for (let i=0; i<=m; i++) res = Math.max(res, dp[i][m-i]);\\n    return res;\\n};", "var maximumScore = function(nums, multipliers) {\\n    "]}
{"id": "2070", "ref_js": ["var longestPalindrome = function(word1, word2) {\\n    memo = Array.from({length: word1.length+word2.length}, () => Array(word1.length+word2.length).fill(0));\\n    split = word1.length;\\n    res = 0;\\n    lps(word1+word2,0,word1.length+word2.length-1);\\n\\n    return res;\\n};", "var longestPalindrome = function(word1, word2) {\\n    const s = word1 + word2;\\n    const n = s.length;\\n    const memo = [...Array(n)].map(() => Array(n).fill(0))\\n    const uniqueChars = new Set(word1);\\n    let ans = 0;\\n    \\n    for(let x of uniqueChars) {\\n        const i = word1.indexOf(x);\\n        const j = word2.lastIndexOf(x);\\n        if(j === -1) continue;\\n        ans = Math.max(ans, run(i, j + word1.length));\\n    }\\n    \\n    function run(l, r) {\\n        if(l === r) return 1;\\n        if(l > r) return 0;\\n\\n        if(memo[l][r]) return memo[l][r];\\n\\n        if(s[l] === s[r]) {\\n            const res = run(l+1, r-1) + 2;\\n            memo[l][r] = res;\\n            return res;\\n        }\\n        const res = Math.max(run(l+1, r), run(l, r-1))\\n        memo[l][r] = res;\\n        return res;\\n    }\\n    return ans;\\n};", "var longestPalindrome = function(word1, word2) {\\n     let word = word1 + word2\\n     let dp = new Array(word.length).fill(0).map(_ => new Array(word.length).fill(0))\\n\\t "]}
{"id": "2071", "ref_js": ["var getCollisionTimes = function(cars) {\\n    ", "var getCollisionTimes = function(cars) {\\n    var queue = [];\\n    var n = cars.length;\\n    queue.unshift(n-1);\\n    var time = new Array(n).fill(-1); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        ", "var getCollisionTimes = function(cars) {\\n    var queue = [];\\n    var n = cars.length;\\n    queue.unshift(n-1);\\n    var time = new Array(n).fill(-1); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        "]}
{"id": "2072", "ref_js": ["var countPairs = function(n, edges, queries) {\\n    const degree = Array(n+1).fill(0)\\n    const edgesMap = new Map()\\n    const countMemo = new Map()\\n    const answer = []\\n    \\n    for(let [u, v] of edges) {\\n        degree[u]++\\n        degree[v]++\\n        const key = `${Math.min(u, v)}-${Math.max(u, v)}`;\\n        edgesMap.set(key, (edgesMap.get(key) || 0) + 1);\\n    }\\n    const sortedDegree = [...degree.slice(1)].sort((a, b) => a - b);  \\n    \\n    for(let num of queries) {\\n        let cnt;\\n        if(countMemo.has(num)) cnt = countMemo.get(num)\\n        else {\\n            cnt = calculateCount(num)\\n            countMemo.set(num, cnt);\\n        }\\n        answer.push(cnt)\\n    }\\n    \\n    function calculateCount(num) {\\n        let low = 0, high = sortedDegree.length-1, cnt = 0;\\n        \\n        while(low < high) {\\n            const sum  = sortedDegree[low] + sortedDegree[high];\\n            \\n            if(sum > num) {\\n                cnt += (high - low);\\n                high--;\\n            } else low++;\\n        }\\n        \\n        for(let [key, val] of edgesMap) {\\n            const [u, v] = key.split(\\'-\\').map(Number);\\n            \\n            if(degree[u] + degree[v] > num) {\\n                const newSum = degree[u] + degree[v] - val\\n                if(newSum <= num) cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    return answer;\\n};", "var countPairs = function(n, edges, queries) {\\n    const degree = Array(n+1).fill(0)\\n    const edgesMap = new Map()\\n    const countMemo = new Map()\\n    const answer = []\\n    \\n    for(let [u, v] of edges) {\\n        degree[u]++\\n        degree[v]++\\n        const key = `${Math.min(u, v)}-${Math.max(u, v)}`;\\n        edgesMap.set(key, (edgesMap.get(key) || 0) + 1);\\n    }\\n    const sortedDegree = [...degree.slice(1)].sort((a, b) => a - b);  \\n    \\n    for(let num of queries) {\\n        let cnt;\\n        if(countMemo.has(num)) cnt = countMemo.get(num)\\n        else {\\n            cnt = calculateCount(num)\\n            countMemo.set(num, cnt);\\n        }\\n        answer.push(cnt)\\n    }\\n    \\n    function calculateCount(num) {\\n        let low = 0, high = sortedDegree.length-1, cnt = 0;\\n        \\n        while(low < high) {\\n            const sum  = sortedDegree[low] + sortedDegree[high];\\n            \\n            if(sum > num) {\\n                cnt += (high - low);\\n                high--;\\n            } else low++;\\n        }\\n        \\n        for(let [key, val] of edgesMap) {\\n            const [u, v] = key.split(\\'-\\').map(Number);\\n            \\n            if(degree[u] + degree[v] > num) {\\n                const newSum = degree[u] + degree[v] - val\\n                if(newSum <= num) cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    return answer;\\n};", "var countPairs = function(n, edges, queries) {\\n    const degree = Array(n+1).fill(0)\\n    const edgesMap = new Map()\\n    const countMemo = new Map()\\n    const answer = []\\n    \\n    for(let [u, v] of edges) {\\n        degree[u]++\\n        degree[v]++\\n        const key = `${Math.min(u, v)}-${Math.max(u, v)}`;\\n        edgesMap.set(key, (edgesMap.get(key) || 0) + 1);\\n    }\\n    const sortedDegree = [...degree.slice(1)].sort((a, b) => a - b);  \\n    \\n    for(let num of queries) {\\n        let cnt;\\n        if(countMemo.has(num)) cnt = countMemo.get(num)\\n        else {\\n            cnt = calculateCount(num)\\n            countMemo.set(num, cnt);\\n        }\\n        answer.push(cnt)\\n    }\\n    \\n    function calculateCount(num) {\\n        let low = 0, high = sortedDegree.length-1, cnt = 0;\\n        \\n        while(low < high) {\\n            const sum  = sortedDegree[low] + sortedDegree[high];\\n            \\n            if(sum > num) {\\n                cnt += (high - low);\\n                high--;\\n            } else low++;\\n        }\\n        \\n        for(let [key, val] of edgesMap) {\\n            const [u, v] = key.split(\\'-\\').map(Number);\\n            \\n            if(degree[u] + degree[v] > num) {\\n                const newSum = degree[u] + degree[v] - val\\n                if(newSum <= num) cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n    return answer;\\n};"]}
{"id": "2073", "ref_js": ["var getMaximumConsecutive = function (coins) {\\ncoins.sort((a,b) => a- b);\\nlet reach = 0;\\nlet i = 0;\\nwhile (i < coins.length) {\\nif (i < coins.length && coins[i] <= reach + 1) {\\nreach += coins[i];\\ni++;\\n} else {\\nbreak;\\n}\\n}\\nreturn reach + 1;\\n};", "var getMaximumConsecutive = function(coins) {\\n    let result = 1;\\n\\n    coins.sort((a, b) => a - b);\\n\\n    for (const coin of coins) {\\n        if (coin > result) return result;\\n        result += coin;\\n    }\\n    return result;\\n};", "var getMaximumConsecutive = function (coins) {\\n    coins.sort((a,b) => a- b);\\n  let reach = 0;\\n  let i = 0;\\n  while (i < coins.length) {\\n    if (i < coins.length && coins[i] <= reach + 1) {\\n      reach += coins[i];\\n      i++;\\n    } else {\\n      break;\\n    }\\n  }\\n  return reach + 1;\\n};"]}
{"id": "2074", "ref_js": ["var maximumScore = function(nums, k) {\\n    let minimum = nums[k];\\n    let max_score = nums[k];\\n    let i = k;\\n    let j = k;\\n    let n = nums.length;\\n\\n    while (i > 0 || j < n - 1) {\\n        ", "var maximumScore = function(nums, k) {\\n    let minimum = nums[k];\\n    let max_score = nums[k];\\n    let i = k;\\n    let j = k;\\n    let n = nums.length;\\n\\n    while (i > 0 || j < n - 1) {\\n        ", "var maximumScore = function(nums, k) {\\n    let minimum = nums[k];\\n    let max_score = nums[k];\\n    let i = k;\\n    let j = k;\\n    let n = nums.length;\\n\\n    while (i > 0 || j < n - 1) {\\n        "]}
{"id": "2075", "ref_js": ["var maxScore = function(nums) {\\n    const cache = new Map();\\n    function gcd(a, b) {\\n        if(!b) return a;\\n        return gcd(b, a % b);\\n    }\\n    function helper(arr, num, op) {\\n        if(!arr.length) return 0;\\n        const key = arr.join() + num;\\n        if(cache.has(key)) return cache.get(key);\\n        let max = 0;\\n        for(let i = 0; i < arr.length; i++) {\\n            const nextArr = [...arr.slice(0, i), ...arr.slice(i+1)];\\n            if(num) {\\n                const currGCD = gcd(num, arr[i]);\\n                const rest = helper(nextArr, null, op+1);\\n                max = Math.max(max, ((op * currGCD) + rest));\\n            } else {\\n                const rest = helper(nextArr, arr[i], op);\\n                max = Math.max(max, rest);\\n            }\\n        }\\n        cache.set(key, max);\\n        return max;\\n    }\\n    return helper(nums, null, 1);\\n};", "var maxScore = function(nums) {\\n  let n = nums.length / 2, m = nums.length;\\n  let memo = Array(1 << m).fill(-1);\\n  return dp(1, 0);\\n  \\n  function dp(i, mask) {\\n    if (i === n + 1) return 0;\\n    if (memo[mask] !== -1) return memo[mask];\\n    \\n    let ans = 0;\\n    for (let j = 0; j < m; j++) {\\n      if ((mask >> j) & 1) continue; ", "var maxScore = function (nums) {\\n    "]}
{"id": "2076", "ref_js": ["var countPairs = function (nums, low, high) {\\n  nums.sort((a, b) => a - b);\\n  let n = nums.length;\\n  let res = 0;\\n\\n  let m = 0;\\n  let p = 0;\\n  let ll = 0;\\n  let rr = 0;\\n  let bsl = 0;\\n  let bsr = 0;\\n  let b = 0;\\n\\n  for (let r = 1; r < n; r++) {\\n    b = Math.ceil(Math.log2(Math.max(low, nums[r]) + 1));\\n\\n    ll = 0;\\n    rr = r - 1;\\n\\n    while (true) {\\n      if (getBit(nums[rr], b) != getBit(nums[ll], b)) {\\n        p = ll;\\n        bsl = ll;\\n        bsr = rr;\\n        while (bsl <= bsr) {\\n          m = (bsl + bsr) >> 1;\\n          if (getBit(nums[m], b)) bsr = m - 1;\\n          else {\\n            bsl = m + 1;\\n            p = m;\\n          }\\n        }\\n\\n        if (getBit(low, b)) {\\n          if (getBit(nums[r], b)) {\\n            res += rr - p;\\n            rr = p;\\n          } else {\\n            res += p - ll + 1;\\n            ll = p + 1;\\n          }\\n        } else {\\n          if (getBit(nums[r], b)) {\\n            ll = p + 1;\\n          } else {\\n            rr = p;\\n          }\\n        }\\n      } else {\\n        let bit = getBit(nums[rr], b) ^ getBit(nums[r], b);\\n        if (getBit(low, b) != bit) {\\n          if (!bit) res += rr - ll + 1;\\n          break;\\n        }\\n      }\\n\\n      if (!b) break;\\n      b--;\\n    }\\n\\n    b = Math.ceil(Math.log2(Math.max(high, nums[r]) + 1));\\n    ll = 0;\\n    rr = r - 1;\\n\\n    while (true) {\\n      if (getBit(nums[rr], b) != getBit(nums[ll], b)) {\\n        p = ll;\\n        bsl = ll;\\n        bsr = rr;\\n        while (bsl <= bsr) {\\n          m = (bsl + bsr) >> 1;\\n          if (getBit(nums[m], b)) bsr = m - 1;\\n          else {\\n            bsl = m + 1;\\n            p = m;\\n          }\\n        }\\n\\n        if (getBit(high, b)) {\\n          if (getBit(nums[r], b)) {\\n            rr = p;\\n          } else {\\n            ll = p + 1;\\n          }\\n        } else {\\n          if (getBit(nums[r], b)) {\\n            res += p - ll + 1;\\n            ll = p + 1;\\n          } else {\\n            res += rr - p;\\n            rr = p;\\n          }\\n        }\\n      } else {\\n        let bit = getBit(nums[rr], b) ^ getBit(nums[r], b);\\n        if (getBit(high, b) != bit) {\\n          if (bit) res += rr - ll + 1;\\n          break;\\n        }\\n      }\\n\\n      if (!b) break;\\n      b--;\\n    }\\n  }\\n\\n  res = (n * (n - 1)) / 2 - res;\\n  return res;\\n};", "var countPairs = function (nums, low, high) {\\n  const N = nums.length;\\n  let res = 0;\\n  for (let i = 0; i < N; i++) {\\n    for (let j = i + 1; j < N; j++) {\\n      let xor = nums[i] ^ nums[j];\\n      if (low <= xor && xor <= high) {\\n        res++;\\n      }\\n    }\\n  }\\n\\n  return res;\\n};", "var countPairs = function(nums, low, high) {\\n    function insert(num){\\n        var node = root;\\n        for(i = 14; i>=0; i--)\\n        {\\n            var bit = (num >> i) & 1;\\n            if(!node.children[bit])\\n            {\\n                node.children[bit] = new TrieNode();\\n            }\\n            node.children[bit].cnt += 1;\\n            node = node.children[bit];\\n        }\\n    }\\n    function countSmallerNums(num, limit)\\n    {\\n        var cnt = 0;\\n        "]}
{"id": "2077", "ref_js": ["var maxNiceDivisors = function (primeFactors) {\\n    if (primeFactors <= 3) {\\n        return primeFactors;\\n    }\\n\\n    ", "var maxNiceDivisors = function (primeFactors) {\\n    if (primeFactors <= 3) {\\n        return primeFactors;\\n    }\\n\\n    ", "var maxNiceDivisors = function (primeFactors) {\\n    if (primeFactors <= 3) {\\n        return primeFactors;\\n    }\\n\\n    "]}
{"id": "2078", "ref_js": ["var isBipartite = function(graph) {\\n    let n = graph.length;\\n    let vis = new Array(n);\\n    vis.fill(-1);\\n\\n    for(let i=0; i<n; i++)\\n    {\\n        if(vis[i] == -1)\\n        {\\n            let rs = solve(i, graph, vis);\\n            if(rs == false)\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};", "var isBipartite = function (graph) {\\n  let colorArr = new Array(graph.length).fill(-1);\\n  colorArr[0] = 1;\\n  let queue = [];\\n  for (let i = 0; i < graph.length; i++) {\\n    if (graph[i].length > 0) {\\n      queue.push(i);\\n    }\\n  }\\n\\n  while (queue.length) {\\n    let top = queue.shift();\\n    let neighbors = graph[top];\\n\\n    for (let node of neighbors) {\\n      ", "var isBipartite = function (graph) {\\n  let colorArr = new Array(graph.length).fill(-1);\\n  colorArr[0] = 1;\\n  let queue = [];\\n  for (let i = 0; i < graph.length; i++) {\\n    if (graph[i].length > 0) {\\n      queue.push(i);\\n    }\\n  }\\n\\n  while (queue.length) {\\n    let top = queue.shift();\\n    let neighbors = graph[top];\\n\\n    for (let node of neighbors) {\\n      "]}
{"id": "2079", "ref_js": ["var countDifferentSubsequenceGCDs = function (nums) {\\n  nums.sort((a, b) => b - a);\\n  let g = nums[0];\\n  let m = nums[0];\\n  let n = nums.length;\\n\\n  for (let i = 1; i < n; i++) g = gcd(g, nums[i]);\\n\\n  let t = 0;\\n  let res = 0;\\n  for (let i = m; i > 0; i -= g) {\\n    a[i] = 0;\\n\\n    while (nums[t] == i) {\\n      t++;\\n      a[i] = 1;\\n    }\\n\\n    let gg = 0;\\n    for (let j = i; j <= m; j += i) {\\n      if (a[j]) {\\n        gg = gcd(gg, j);\\n        if (gg == i) {\\n          a[i] = 1;\\n          res++;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  return res;\\n};", "var countDifferentSubsequenceGCDs = function (nums) {\\n  nums.sort((a, b) => b - a);\\n  let g = nums[0];\\n  let m = nums[0];\\n  let n = nums.length;\\n\\n  for (let i = 1; i < n; i++) g = gcd(g, nums[i]);\\n\\n  let t = 0;\\n  let res = 0;\\n  for (let i = m; i > 0; i -= g) {\\n    a[i] = 0;\\n\\n    while (nums[t] == i) {\\n      t++;\\n      a[i] = 1;\\n    }\\n\\n    let gg = 0;\\n    for (let j = i; j <= m; j += i) {\\n      if (a[j]) {\\n        gg = gcd(gg, j);\\n        if (gg == i) {\\n          a[i] = 1;\\n          res++;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  return res;\\n};", "var countDifferentSubsequenceGCDs = function (nums) {\\n  nums.sort((a, b) => b - a);\\n  let g = nums[0];\\n  let m = nums[0];\\n  let n = nums.length;\\n\\n  for (let i = 1; i < n; i++) g = gcd(g, nums[i]);\\n\\n  let t = 0;\\n  let res = 0;\\n  for (let i = m; i > 0; i -= g) {\\n    a[i] = 0;\\n\\n    while (nums[t] == i) {\\n      t++;\\n      a[i] = 1;\\n    }\\n\\n    let gg = 0;\\n    for (let j = i; j <= m; j += i) {\\n      if (a[j]) {\\n        gg = gcd(gg, j);\\n        if (gg == i) {\\n          a[i] = 1;\\n          res++;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  return res;\\n};"]}
{"id": "2081", "ref_js": ["var makeStringSorted = function(s) {\\n    let freq = Array(26).fill(0), ans = 0n;\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        freq[s.charCodeAt(i) - 97]++;\\n        \\n        let comb = freq.reduce((acc, cur) => acc * invFactorial[cur] % mod, factorial[s.length - i - 1]),\\n            acc = 0;\\n\\n        for (let j = 0; j < s.charCodeAt(i) - 97; j++)\\n            acc += freq[j];\\n\\n        ans = (ans + comb * BigInt(acc) % mod) % mod;\\n    }\\n    \\n    return ans;\\n};", "var makeStringSorted = function(s) {\\n    let freq = Array(26).fill(0), ans = 0n;\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        freq[s.charCodeAt(i) - 97]++;\\n        \\n        let comb = freq.reduce((acc, cur) => acc * invFactorial[cur] % mod, factorial[s.length - i - 1]),\\n            acc = 0;\\n\\n        for (let j = 0; j < s.charCodeAt(i) - 97; j++)\\n            acc += freq[j];\\n\\n        ans = (ans + comb * BigInt(acc) % mod) % mod;\\n    }\\n    \\n    return ans;\\n};", "var makeStringSorted = function(s) {\\n    let freq = Array(26).fill(0), ans = 0n;\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        freq[s.charCodeAt(i) - 97]++;\\n        \\n        let comb = freq.reduce((acc, cur) => acc * invFactorial[cur] % mod, factorial[s.length - i - 1]),\\n            acc = 0;\\n\\n        for (let j = 0; j < s.charCodeAt(i) - 97; j++)\\n            acc += freq[j];\\n\\n        ans = (ans + comb * BigInt(acc) % mod) % mod;\\n    }\\n    \\n    return ans;\\n};"]}
{"id": "2082", "ref_js": ["var getXORSum = function(arr1, arr2) {\\n    let xor1 = arr1[0];\\n    let xor2 = arr2[0];\\n    for(let i=1;i<arr1.length;i++)\\n        xor1 = xor1^arr1[i];\\n    for(let i=1;i<arr2.length;i++)\\n        xor2 = xor2^arr2[i];\\n    return xor1 & xor2;\\n};", "var getXORSum = function(arr1, arr2) {\\n    ", "var getXORSum = function(arr1, arr2) {\\n    "]}
{"id": "2083", "ref_js": ["var maxBuilding = function(n, restrictions) {\\n    ", "var maxBuilding = function(n, restrictions) {\\n    let maxHeight=0;\\n    restrictions.push([1,0]);", "var maxBuilding = function(n, restrictions) {\\n  if (restrictions.length === 0) {\\n    return n - 1;\\n  }\\n  \\n  "]}
{"id": "2084", "ref_js": ["var closestRoom = function(R, Q) {\\n    let A=new AVL(),result=[...Array(Q.length)]\\n    Q=Q.map((d,i)=>d.concat([i])) ", "var closestRoom = function(R, Q) {\\n    let A=new AVL(),result=[...Array(Q.length)]\\n    Q=Q.map((d,i)=>d.concat([i])) ", "var closestRoom = function(R, Q) {\\n    let A=new AVL(),result=[...Array(Q.length)]\\n    Q=Q.map((d,i)=>d.concat([i])) "]}
{"id": "2085", "ref_js": ["var minInterval = function(intervals, queries) {\\n\\t", "var minInterval = function(intervals, queries) {\\n\\n    intervals.sort( (a,b) => {\\n        if(a[0] != b[0]){\\n            return a[0]-b[0];\\n        }else{\\n            return a[1]-b[1];\\n        }\\n    });\\n\\n    let heap = new PriorityQueue({compare: (a,b) => {\\n\\n        if( (a[0])!=(b[0])){\\n            return (a[0] - b[0]);\\n        }else{\\n            return (a[1] - b[1]);\\n        }\\n\\n    }});\\n\\n\\n    let sortedQ = [...queries];\\n\\n    sortedQ.sort( (a,b) => a-b);\\n\\n\\n    let m = new Map();\\n\\n    let res = [];\\n\\n    let q = 0;\\n    let i = 0;\\n\\n    ", "var minInterval = function (intervals, queries) {\\n  var minInterval = function (intervals, queries) {\\n    intervals.sort((a, b) =>  a[0] - b[0]);\\n    let originalQuery = [...queries];\\n    queries.sort((a, b) => a - b);\\n    let resultMap = {};"]}
{"id": "2086", "ref_js": ["var largestPathValue = function(colors, edges) {\\r\\n    const n = colors.length;\\r\\n    const visited = Array(n).fill(0);\\r\\n    const maxCount = Array(n).fill(0).map(_=>Array(26).fill(0));\\r\\n    const adj = Array(n).fill(0).map(_=>[]);\\r\\n    \\r\\n    for(const [a,b] of edges){\\r\\n      adj[a].push(b);\\r\\n    }\\r\\n    let res = 0;\\r\\n    for(let i=0; i<n; i++){\\r\\n      res = Math.max(res, dfs(i, maxCount));\\r\\n    };", "var largestPathValue = function(colors, edges) {\\r\\n    const [incoming, outgoing] = buildGraph(edges, colors.length);\\r\\n\\r\\n    let visited = new Array(colors.length).fill(false);\\r\\n    let visitedCount = 0;\\r\\n\\r\\n    ", "var largestPathValue = function(colors, edges) {\\r\\n    const n = colors.length;\\r\\n    const visited = Array(n).fill(0);\\r\\n    const maxCount = Array(n).fill(0).map(_=>Array(26).fill(0));\\r\\n    const adj = Array(n).fill(0).map(_=>[]);\\r\\n    \\r\\n    for(const [a,b] of edges){\\r\\n      adj[a].push(b);\\r\\n    }\\r\\n    let res = 0;\\r\\n    for(let i=0; i<n; i++){\\r\\n      res = Math.max(res, dfs(i, maxCount));\\r\\n    };"]}
{"id": "2087", "ref_js": ["var sumOfNumberAndReverse = function(num) {\\n    if(num == 0) {\\n        return true\\n    }\\n    let i = Math.floor(num/2)\\n    while(i<num) {\\n        if(i+reverseANumber(i) == num) {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n};", "var sumOfNumberAndReverse = function(num) {\\n    if(num==0) return true\\n     for(let i=1;i<=num;i++)\\n  {\\n    let rev=Number(i.toString().split(\\'\\').reverse().join(\\'\\'))\\n    if((rev+i)===num) return true\\n  }\\n  return false\\n};", "var sumOfNumberAndReverse = function(num) {\\n    if(num==0) return true\\n     for(let i=1;i<=num;i++)\\n  {\\n    let rev=Number(i.toString().split(\\'\\').reverse().join(\\'\\'))\\n    if((rev+i)===num) return true\\n  }\\n  return false\\n};"]}
{"id": "2088", "ref_js": ["var rearrangeSticks = function(n, k) {\\n  return dp[n-1][k-1];\\n};", "var rearrangeSticks = function(n, k) {\\n  return dp[n-1][k-1];\\n};", "var rearrangeSticks = function(n, k) {\\n  return dp[n-1][k-1];\\n};"]}
{"id": "2089", "ref_js": ["var stoneGameVIII = function(stones) {\\n  const n = stones.length;\\n  for (let i = 1; i < n; i++) stones[i] += stones[i-1];\\n  \\n  let res = stones[n-1];\\n  for (let i = n - 2; i > 0; i--) res = Math.max(res, stones[i] - res);\\n\\n  return res;\\n};", "var stoneGameVIII = function(S) {  \\n    let n=S.length, prefix=[0],dp=[...Array(n)]\\n    for(let i=0;i<n;i++)\\n        prefix.push(prefix[prefix.length-1]+S[i])\\n    let bestRight=prefix[n],bestCurrent\\n    for(let i=n-2;i>=0;i--)\\n        bestCurrent=bestRight,\\n\\t\\t", "var stoneGameVIII = function(stones) {\\n    let prefix = Array(stones.length);\\n    for (let i = 0; i < stones.length; i++) prefix[i] = stones[i] + (prefix[i - 1] || 0);\\n    \\n    let dp = Array(stones.length).fill(0);\\n    function game(idx) {\\n        if (dp[idx]) return dp[idx];\\n        if (idx >= stones.length) return 0;\\n        let skip = game(idx + 1);\\n        let take = prefix[idx] - skip;\\n        dp[idx] = take;\\n        "]}
{"id": "2090", "ref_js": ["var minimumXORSum = function (a, b) {\\n    let memo = new Map(),\\n        m = a.length,\\n        n = b.length,\\n        key = (a, b) => a + b * m; ", "var minimumXORSum = function (a, b) {\\n    let memo = new Map(),\\n        m = a.length,\\n        n = b.length,\\n        key = (a, b) => a + b * m; ", "var minimumXORSum = function (a, b) {\\n    let memo = new Map(),\\n        m = a.length,\\n        n = b.length,\\n        key = (a, b) => a + b * m; "]}
{"id": "2091", "ref_js": ["var minSkips = function(dist, speed, hoursBefore) {\\n    \\n    ", "var minSkips = function(D, S, H) {\\n    let n=D.length,pref=[0],dp=[0, ...(Array(n).fill(Infinity))]\\n    D.forEach((d,i)=>pref.push(pref[i]+Math.ceil(D[i]/S)))\\n    for(let brk=1;brk<=n;brk++)\\n         for(let i=brk-1,firstpart=Infinity,nextPrev=dp[i+1],prev=dp[i];i<=n;i++)\\n            if(dp[n]<=H)\\n                return brk-1\\n            else\\n                nextPrev=dp[i+1],dp[i+1]=Math.min(firstpart+pref[i], prev)+D[i]/S-(1e-13),\\n                firstpart=Math.min(firstpart, Math.ceil(prev +D[i]/S) -pref[i+1]),prev=nextPrev\\n    return -1\\n};", "var minSkips = function(dist, speed, hoursBefore) {\\n    "]}
{"id": "2092", "ref_js": ["var minWastedSpace = function(packages, boxSuppliers) {\\n    packages.sort((a, b) => a - b);\\n    const largestPackage = packages[packages.length - 1];\\n    \\n    ", "var minWastedSpace = function(packages, boxes) {\\n    let count=0,b,minWastage,totalPackagesSize=0n,minBoxesAreaForAnySupplier=BigInt(Number.MAX_SAFE_INTEGER),boxesArea=0n,p,coverdPackagesIndex,totalBoxesAreaForSupplier;\\n    packages.sort(function(a,b){return a-b});\\n    for(let i=0;i<packages.length;i++){\\n        totalPackagesSize+=BigInt(packages[i]);\\n    }\\n    \\n    for(let i=0;i<boxes.length;i++){\\n        boxes[i].sort(function(a,b){return a-b});\\n        p=0;\\n        totalBoxesAreaForSupplier=0n;\\n        if(boxes[i][boxes[i].length-1]<packages[packages.length-1]){", "var minWastedSpace = function(packages, boxes) {\\n    let count=0,b,minWastage,totalPackagesSize=0n,minBoxesAreaForAnySupplier=BigInt(Number.MAX_SAFE_INTEGER),boxesArea=0n,p,coverdPackagesIndex,totalBoxesAreaForSupplier;\\n    packages.sort(function(a,b){return a-b});\\n    for(let i=0;i<packages.length;i++){\\n        totalPackagesSize+=BigInt(packages[i]);\\n    }\\n    \\n    for(let i=0;i<boxes.length;i++){\\n        boxes[i].sort(function(a,b){return a-b});\\n        p=0;\\n        totalBoxesAreaForSupplier=0n;\\n        if(boxes[i][boxes[i].length-1]<packages[packages.length-1]){"]}
{"id": "2093", "ref_js": ["var isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};", "var isInterleave = function (s1, s2, s3) {\\n    if (s1.length + s2.length !== s3.length) return false;\\n\\n    const dp = new Array(s2.length + 1).fill(false);\\n\\n    for (let i = 0; i <= s1.length; i++) {\\n        for (let j = 0; j <= s2.length; j++) {\\n            if (i === 0 && j === 0) {\\n                dp[j] = true;\\n            } else if (i === 0) {\\n                dp[j] = dp[j - 1] && s2[j - 1] === s3[i + j - 1];\\n            } else if (j === 0) {\\n                dp[j] = dp[j] && s1[i - 1] === s3[i + j - 1];\\n            } else {\\n                dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n            }\\n        }\\n    }\\n\\n    return dp[s2.length];\\n};", "var isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};"]}
{"id": "2094", "ref_js": ["var earliestAndLatest = function(numPlayers, firstPlayer, secondPlayer) {\\n    let minRounds = Infinity;\\n    let maxRounds = 0;\\n    const dfs = (playersEliminated, numRounds) => {\\n        \\n        ", "var earliestAndLatest = function (n, firstPlayer, secondPlayer) {\\n  let earliest = n;\\n  let latest = 0;\\n\\n  const visited = new Set();\\n\\n  const findEarliestAndLatest = (remain, players, current, round) => {\\n    if (visited.has(remain)) return;\\n    \\n    const player = players[current];\\n    const opponent = players[players.length - current]; ", "var earliestAndLatest = function(numPlayers, firstPlayer, secondPlayer) {\\n    let minRounds = Infinity;\\n    let maxRounds = 0;\\n    const dfs = (playersEliminated, numRounds) => {\\n        \\n        "]}
{"id": "2096", "ref_js": ["var waysToBuildRooms = function(prevRoom) {\\r\\n    const mod = 1_000_000_007n, n = prevRoom.length;\\r\\n    const tree = Array.from({ length: n }, () => []);\\r\\n    let prod = 1n, factorial = 1n;\\r\\n\\r\\n    for (let i = 1; i < n; i++)\\r\\n        tree[prevRoom[i]].push(i), factorial = factorial * BigInt(i) % mod;\\r\\n\\r\\n    const dfs = (node) => {\\r\\n        const childNodes = tree[node].reduce(\\r\\n                (acc, child) => acc + dfs(child), 1n)\\r\\n        return node > 0 \\r\\n            ? (prod = prod * childNodes % mod, childNodes) : prod;\\r\\n    };", "var waysToBuildRooms = function(prevRoom) {\\n    const mod = 1_000_000_007n, n = prevRoom.length;\\n    const tree = Array.from({ length: n }, () => []);\\n    let prod = 1n, factorial = 1n;\\n\\n    for (let i = 1; i < n; i++)\\n        tree[prevRoom[i]].push(i), factorial = factorial * BigInt(i) % mod;\\n\\n    const dfs = (node) => {\\n        const childNodes = tree[node].reduce(\\n                (acc, child) => acc + dfs(child), 1n)\\n        return node > 0 \\n            ? (prod = prod * childNodes % mod, childNodes) : prod;\\n    };", "var waysToBuildRooms = function(prevRoom) {\\r\\n    const mod = 1_000_000_007n, n = prevRoom.length;\\r\\n    const tree = Array.from({ length: n }, () => []);\\r\\n    let prod = 1n, factorial = 1n;\\r\\n\\r\\n    for (let i = 1; i < n; i++)\\r\\n        tree[prevRoom[i]].push(i), factorial = factorial * BigInt(i) % mod;\\r\\n\\r\\n    const dfs = (node) => {\\r\\n        const childNodes = tree[node].reduce(\\r\\n                (acc, child) => acc + dfs(child), 1n)\\r\\n        return node > 0 \\r\\n            ? (prod = prod * childNodes % mod, childNodes) : prod;\\r\\n    };"]}
{"id": "2097", "ref_js": ["var findRotateSteps = function (ring, key) {\\n  let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n  let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n  let dp = ring.split(\\'\\').map(() => 0);\\n\\n  for (let i = key.length - 1; i >= 0; i--) {\\n    let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n    for (let j = 0; j < ring.length * 2; j++) {\\n      let x = j % ring.length;\\n      dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n      let y = ((ring.length * 2) - 1 - j) % ring.length;\\n      dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n    }\\n\\n    dp = dp_new;\\n  }\\n\\n  return dp[0] + key.length;\\n};", "var findRotateSteps = function(ring, key) {\\n    let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n    let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n    let dp = ring.split(\\'\\').map(() => 0);\\n\\n    for (let i = key.length - 1; i >= 0; i--) {\\n        let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n        for (let j = 0; j < ring.length * 2; j++) {\\n            let x = j % ring.length;\\n            dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n            let y = ((ring.length * 2) - 1 - j) % ring.length;\\n            dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n        }\\n\\n        dp = dp_new;\\n    }\\n\\n    return dp[0] + key.length;\\n};", "var findRotateSteps = function (ring, key) {\\n  let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n  let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n  let dp = ring.split(\\'\\').map(() => 0);\\n\\n  for (let i = key.length - 1; i >= 0; i--) {\\n    let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n    for (let j = 0; j < ring.length * 2; j++) {\\n      let x = j % ring.length;\\n      dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n      let y = ((ring.length * 2) - 1 - j) % ring.length;\\n      dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n    }\\n\\n    dp = dp_new;\\n  }\\n\\n  return dp[0] + key.length;\\n};"]}
{"id": "2098", "ref_js": ["var minCost = function (maxTime, edges, passingFees) {\\n    const n = passingFees.length;\\n    const graph = new Array(n);\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const [from, to, time] = edges[i];\\n\\n        graph[from] = graph[from] || [];\\n        graph[from][to] = Math.min(graph[from][to] ?? Infinity, time);\\n\\n        graph[to] = graph[to] || [];\\n        graph[to][from] = Math.min(graph[to][from] ?? Infinity, time);\\n    }\\n\\n    const q = new MinPriorityQueue();\\n    q.enqueue([0, 0], passingFees[0]);\\n\\n    const bestTimes = new Array(n).fill(Infinity);\\n\\n    while (q.size()) {\\n        const { element, priority } = q.dequeue();\\n        const [currNode, currTime] = element;\\n        \\n        if (currNode === n - 1) {\\n            return priority;\\n        }\\n\\n        for (const node in graph[currNode]) {\\n            const nextNode = parseInt(node);\\n            const nextTime = graph[currNode][node] + currTime;\\n\\n            if (nextTime <= maxTime && nextTime < bestTimes[nextNode]) {\\n                bestTimes[nextNode] = nextTime;\\n                q.enqueue([nextNode, nextTime], passingFees[nextNode] + priority);\\n            }\\n        }\\n    }\\n    return -1;\\n};", "var minCost = function (maxTime, edges, passingFees) {\\n    const n = passingFees.length;\\n    const graph = new Array(n);\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const [from, to, time] = edges[i];\\n\\n        graph[from] = graph[from] || [];\\n        graph[from][to] = Math.min(graph[from][to] ?? Infinity, time);\\n\\n        graph[to] = graph[to] || [];\\n        graph[to][from] = Math.min(graph[to][from] ?? Infinity, time);\\n    }\\n\\n    const q = new MinPriorityQueue();\\n    q.enqueue([0, 0], passingFees[0]);\\n\\n    const bestTimes = new Array(n).fill(Infinity);\\n\\n    while (q.size()) {\\n        const { element, priority } = q.dequeue();\\n        const [currNode, currTime] = element;\\n        \\n        if (currNode === n - 1) {\\n            return priority;\\n        }\\n\\n        for (const node in graph[currNode]) {\\n            const nextNode = parseInt(node);\\n            const nextTime = graph[currNode][node] + currTime;\\n\\n            if (nextTime <= maxTime && nextTime < bestTimes[nextNode]) {\\n                bestTimes[nextNode] = nextTime;\\n                q.enqueue([nextNode, nextTime], passingFees[nextNode] + priority);\\n            }\\n        }\\n    }\\n    return -1;\\n};", "var minCost = function (maxTime, edges, passingFees) {\\n    const n = passingFees.length;\\n    const graph = new Array(n);\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const [from, to, time] = edges[i];\\n\\n        graph[from] = graph[from] || [];\\n        graph[from][to] = Math.min(graph[from][to] ?? Infinity, time);\\n\\n        graph[to] = graph[to] || [];\\n        graph[to][from] = Math.min(graph[to][from] ?? Infinity, time);\\n    }\\n\\n    const q = new MinPriorityQueue();\\n    q.enqueue([0, 0], passingFees[0]);\\n\\n    const bestTimes = new Array(n).fill(Infinity);\\n\\n    while (q.size()) {\\n        const { element, priority } = q.dequeue();\\n        const [currNode, currTime] = element;\\n        \\n        if (currNode === n - 1) {\\n            return priority;\\n        }\\n\\n        for (const node in graph[currNode]) {\\n            const nextNode = parseInt(node);\\n            const nextTime = graph[currNode][node] + currTime;\\n\\n            if (nextTime <= maxTime && nextTime < bestTimes[nextNode]) {\\n                bestTimes[nextNode] = nextTime;\\n                q.enqueue([nextNode, nextTime], passingFees[nextNode] + priority);\\n            }\\n        }\\n    }\\n    return -1;\\n};"]}
{"id": "2099", "ref_js": ["var colorTheGrid = function(n, m) {\\n    let mod=1e9+7,adj=[...Array(3**(n))].map(d=>new Set()),\\n    ", "var colorTheGrid = function(numRows, numColumns) {\\n    const getPossibleRows = setCacheForGetPossibleRows(numRows);\\n    const cache = new Array(numColumns + 1);\\n    for (let i = 0; i <= numColumns; i++) {\\n        cache[i] = new Array(1 << (2 * numRows));\\n    }\\n    const getNumWays = (numColLeft, prevRowBitMask) => {\\n        if (!numColLeft) return 1;\\n        if (cache[numColLeft][prevRowBitMask] !== undefined) {\\n            return cache[numColLeft][prevRowBitMask];\\n        }\\n        let numWays = 0;\\n        for (const mask of getPossibleRows(prevRowBitMask)) {\\n            numWays = numWays + getNumWays(numColLeft - 1, mask);\\n        }\\n        return cache[numColLeft][prevRowBitMask] = numWays % MOD;\\n    }\\n    return getNumWays(numColumns, 0);\\n};", "var colorTheGrid = function(numRows, numColumns) {\\n    const getPossibleRows = setCacheForGetPossibleRows(numRows);\\n    const cache = new Array(numColumns + 1);\\n    for (let i = 0; i <= numColumns; i++) {\\n        cache[i] = new Array(1 << (2 * numRows));\\n    }\\n    const getNumWays = (numColLeft, prevRowBitMask) => {\\n        if (!numColLeft) return 1;\\n        if (cache[numColLeft][prevRowBitMask] !== undefined) {\\n            return cache[numColLeft][prevRowBitMask];\\n        }\\n        let numWays = 0;\\n        for (const mask of getPossibleRows(prevRowBitMask)) {\\n            numWays = numWays + getNumWays(numColLeft - 1, mask);\\n        }\\n        return cache[numColLeft][prevRowBitMask] = numWays % MOD;\\n    }\\n    return getNumWays(numColumns, 0);\\n};"]}
{"id": "2100", "ref_js": ["var canMerge = function(trees) {\\n    let Node={},indeg={}\\n    ", "var canMerge = function(trees) {\\n  let leaves = new Map(), roots = new Set(), nodesCnt = 0, n = trees.length;\\n\\n  ", "var canMerge = function (trees) {\\n  mergeTrees(trees);\\n  const unmerged = trees.filter((p) => !p.merged);\\n  return unmerged.length > 1 ? null : unmerged[0];\\n};"]}
{"id": "2101", "ref_js": ["var maxGeneticDifference = function(parents, queries) {\\n    let root,n=parents.length,res=[...Array(n)].map(d=>{}),\\n        Q=[...Array(n)].map(d=>[]),adj=[...Array(n)].map(d=>[])\\n    ", "var maxGeneticDifference = function(parents, queries) {\\n    const n = parents.length;\\n    \\n    ", "var maxGeneticDifference = function(parents, queries) {\\n    let root,n=parents.length,res=[...Array(n)].map(d=>{}),\\n        Q=[...Array(n)].map(d=>[]),adj=[...Array(n)].map(d=>[])\\n    "]}
{"id": "2102", "ref_js": ["var canSeePersonsCount = function(heights) {\\n    let count = 0;\\n    let ansAr = [];\\n    let max = 0;\\n\\n    if (heights.length == 1) {ansAr.push(count); return ansAr;}\\n    ", "var canSeePersonsCount = function(heights) {\\n    let count = 0;\\n    let ansAr = [];\\n    let max = 0;\\n\\n    if (heights.length == 1) {ansAr.push(count); return ansAr;}\\n    ", "var canSeePersonsCount = function(heights) {\\n    let count = 0;\\n    let ansAr = [];\\n    let max = 0;\\n\\n    if (heights.length == 1) {ansAr.push(count); return ansAr;}\\n    "]}
{"id": "2103", "ref_js": ["var deleteDuplicateFolder = function(paths) {\\n    let trie = new Trie();\\n    ", "var deleteDuplicateFolder = function(paths) {\\n    let T=new Trie()\\n    for(let P of paths)\\n        T.insert(P)\\n    T.traverse()\\n    T.delete()\\n    return T.serialize()\\n};", "var deleteDuplicateFolder = function(paths) {\\n    let T=new Trie()\\n    for(let P of paths)\\n        T.insert(P)\\n    T.traverse()\\n    T.delete()\\n    return T.serialize()\\n};"]}
{"id": "2104", "ref_js": ["var countSpecialSubsequences = function(A) {\\n    let mod=(1e9+7),n=A.length,B=[0,0,0]\\n    for(let i=0;i<n;i++)\\n        B[A[i]]= (2*B[A[i]] + (A[i]?B[A[i]-1]:1) )%mod\\n    return B[2]\\n};", "var countSpecialSubsequences = function(A) {\\n    let mod=(1e9+7),n=A.length,B=[0,0,0]\\n    for(let i=0;i<n;i++)\\n        B[A[i]]= (2*B[A[i]] + (A[i]?B[A[i]-1]:1) )%mod\\n    return B[2]\\n};", "var countSpecialSubsequences = function(A) {\\n    let mod=(1e9+7),n=A.length,B=[0,0,0]\\n    for(let i=0;i<n;i++)\\n        B[A[i]]= (2*B[A[i]] + (A[i]?B[A[i]-1]:1) )%mod\\n    return B[2]\\n};"]}
{"id": "2105", "ref_js": ["var divisibilityArray = function(word, m) {\\n    const ans = [];\\n\\n    let num = 0, carry = 0;\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        num = Number(carry + word[i]);\\n        carry = num % m;\\n        ans.push(carry ? 0 : 1);\\n    }\\n    \\n    return ans;\\n};", "var divisibilityArray = function(word, m) {\\n    const n = word.length;\\n    const ans = new Array(n).fill(0);\\n    let num = 0;\\n    for(let i = 0; i<n; i++) {\\n        num += parseInt(word[i]);\\n        if( num % m === 0) {\\n            ans[i] = 1;\\n        }\\n        num = (num * 10)  % m; ", "var divisibilityArray = function(word, m) {\\n    const result = (new Array(word.length)).fill(0)\\n    let rest = 0\\n    for(let i = 0; i < word.length; i++) {\\n        rest = (rest * 10 + (word[i] - \\'0\\')) % m\\n        if(rest == 0){\\n            result[i] = 1\\n        }\\n    }\\n    \\n    return result\\n};"]}
{"id": "2106", "ref_js": ["var longestObstacleCourseAtEachPosition = function(obstacles) {\\n    ", "var longestObstacleCourseAtEachPosition = function(obstacles) {\\n    let dp = [], res = [];\\n    for (let i = 0; i < obstacles.length; i++) {\\n        let j = upperBound(dp, obstacles[i]);\\n        if (j == dp.length) {\\n            dp.push(obstacles[i]);\\n        } else {\\n            dp[j] = obstacles[i];\\n        }\\n        res.push(j + 1);\\n    }\\n    return res;\\n};", "var longestObstacleCourseAtEachPosition = function (obstacles) {\\n  let ans = [], tail = [];\\n  for (let num of obstacles) {\\n    let index = _.sortedLastIndex(tail, num);\\n    tail[index] = num;\\n    ans.push(index + 1);\\n  }\\n  return ans;\\n};"]}
{"id": "2107", "ref_js": ["var latestDayToCross = function(row, col, cells) {\\n    ", "var latestDayToCross = function(row, col, cells) {\\n    const grid = Array(row).fill(0).map(() => Array(col).fill(0))\\n    let left = 0, right = cells.length \\n    let possiblePath = 0\\n\\n    const existingPath = function(mid){\\n        ", "var latestDayToCross = function(row, col, cells) {\\n  const ds = new DisjointSets() \\n  ds.add(\"L\", \"R\");\\n\\n  function toDsKey(r, c) {\\n    if (r === 0 || r > row) return null;\\n    if (c === 0) return \"L\";\\n    if (c > col) return \"R\";\\n    return `${r}_${c}`;\\n  }\\n\\n  function connect(cell) {\\n    const curKey = toDsKey(cell[0], cell[1]);\\n    ds.add(curKey);\\n    for (let i = -1; i <= 1; i++) {\\n      for (let j = -1; j <= 1; j++) {\\n        if (i === 0 && j === 0) continue;\\n\\n        const toKey = toDsKey(cell[0] + i, cell[1] + j);\\n        if (toKey !== null && ds.has(toKey)) ds.union(curKey, toKey);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < cells.length; i++) {\\n    connect(cells[i]);\\n    if (ds.isSameSet(\"L\", \"R\")) return i;\\n  }\\n};"]}
{"id": "2108", "ref_js": ["var numberOfCombinations = function(num) {\\n    const n = num.length;\\n    const counts = Array.from({length: n}, () => new Array(n+1).fill(0));\\n    const allSameFlag = num.split(\\'\\').every(c => c === num[0]);\\n    for (let i = 0; i < n; i++) {\\n        counts[i][n] = num[i] !== \\'0\\' ? 1 : 0;\\n    }\\n    \\n    const partialCompare = (i, j) => {\\n        if (i === j || allSameFlag) {\\n            return 0;\\n        } else if (num[i] !== num[j]) {\\n            return num[i] > num[j] ? i+1 : -(i+1);\\n        } else if (2*j - i === n || 2*j - i === n-1) {\\n            for (let k = 0; k < j-i; k++) {\\n                if (num[i+k] !== num[j+k]) {\\n                    return num[i+k] > num[j+k] ? i+k : -(i+k+1);\\n                }\\n            }\\n            return 0;\\n        } else {\\n            const idx = partialCompare(i+1, j+1);\\n            return idx===0 ? 0 : Math.abs(idx)-1 >= j ? 0 : idx;\\n        }\\n    }\\n    \\n    let ans = counts[0][n];\\n    for (let j = n-1; j > 0; j--) {\\n        let k = n, total = 0;\\n        for (let i = 0; i < j; i++) {\\n            if (num[i] !== \\'0\\') {\\n                while (k-j > j-i || (k-j === j-i && partialCompare(i, j) <= 0)) {\\n                    total = (total + counts[j][k]) % MOD;\\n                    k--;\\n                }\\n                counts[i][j] = total;\\n            }\\n        }\\n        ans = (ans + counts[0][j]) % MOD;\\n        counts.pop();\\n    }\\n    return ans;\\n};", "var numberOfCombinations = function(num) {\\n    const n = num.length;\\n    const counts = Array.from({length: n}, () => new Array(n+1).fill(0));\\n    const allSameFlag = num.split(\\'\\').every(c => c === num[0]);\\n    for (let i = 0; i < n; i++) {\\n        counts[i][n] = num[i] !== \\'0\\' ? 1 : 0;\\n    }\\n    \\n    const partialCompare = (i, j) => {\\n        if (i === j || allSameFlag) {\\n            return 0;\\n        } else if (num[i] !== num[j]) {\\n            return num[i] > num[j] ? i+1 : -(i+1);\\n        } else if (2*j - i === n || 2*j - i === n-1) {\\n            for (let k = 0; k < j-i; k++) {\\n                if (num[i+k] !== num[j+k]) {\\n                    return num[i+k] > num[j+k] ? i+k : -(i+k+1);\\n                }\\n            }\\n            return 0;\\n        } else {\\n            const idx = partialCompare(i+1, j+1);\\n            return idx===0 ? 0 : Math.abs(idx)-1 >= j ? 0 : idx;\\n        }\\n    }\\n    \\n    let ans = counts[0][n];\\n    for (let j = n-1; j > 0; j--) {\\n        let k = n, total = 0;\\n        for (let i = 0; i < j; i++) {\\n            if (num[i] !== \\'0\\') {\\n                while (k-j > j-i || (k-j === j-i && partialCompare(i, j) <= 0)) {\\n                    total = (total + counts[j][k]) % MOD;\\n                    k--;\\n                }\\n                counts[i][j] = total;\\n            }\\n        }\\n        ans = (ans + counts[0][j]) % MOD;\\n        counts.pop();\\n    }\\n    return ans;\\n};", "var numberOfCombinations = function(num) {\\n    const n = num.length;\\n    const counts = Array.from({length: n}, () => new Array(n+1).fill(0));\\n    const allSameFlag = num.split(\\'\\').every(c => c === num[0]);\\n    for (let i = 0; i < n; i++) {\\n        counts[i][n] = num[i] !== \\'0\\' ? 1 : 0;\\n    }\\n    \\n    const partialCompare = (i, j) => {\\n        if (i === j || allSameFlag) {\\n            return 0;\\n        } else if (num[i] !== num[j]) {\\n            return num[i] > num[j] ? i+1 : -(i+1);\\n        } else if (2*j - i === n || 2*j - i === n-1) {\\n            for (let k = 0; k < j-i; k++) {\\n                if (num[i+k] !== num[j+k]) {\\n                    return num[i+k] > num[j+k] ? i+k : -(i+k+1);\\n                }\\n            }\\n            return 0;\\n        } else {\\n            const idx = partialCompare(i+1, j+1);\\n            return idx===0 ? 0 : Math.abs(idx)-1 >= j ? 0 : idx;\\n        }\\n    }\\n    \\n    let ans = counts[0][n];\\n    for (let j = n-1; j > 0; j--) {\\n        let k = n, total = 0;\\n        for (let i = 0; i < j; i++) {\\n            if (num[i] !== \\'0\\') {\\n                while (k-j > j-i || (k-j === j-i && partialCompare(i, j) <= 0)) {\\n                    total = (total + counts[j][k]) % MOD;\\n                    k--;\\n                }\\n                counts[i][j] = total;\\n            }\\n        }\\n        ans = (ans + counts[0][j]) % MOD;\\n        counts.pop();\\n    }\\n    return ans;\\n};"]}
{"id": "2109", "ref_js": ["var recoverArray = function (n, sums) {\\n  let m = sums.length;\\n  sums.sort((a, b) => a - b);\\n  let res = Array(n).fill(0);\\n\\n  \\n  function tryExtract(a, d) {\\n    const n = a.length;\\n    if (n == 2) {\\n      res[d] = a[0] + a[1];\\n      throw undefined;\\n    }\\n\\n    const x = a[1] - a[0];\\n    let flag1 = 0;\\n    let flag2 = 0;\\n    let used = new Uint8Array(n);\\n\\n    let j = 0;\\n    let i = 0;\\n    while (!used[n-1]) {\\n      while (used[i]) i++;\\n      if (a[i] == 0) flag1 = 1;\\n      used[i] = 1;\\n      while (used[j] || a[j] < a[i] + x) j++;\\n      if (a[j] == 0) flag2 = 1;\\n      used[j] = 2;\\n    }\\n\\n    let a1, a2;\\n    if (flag1) a1 = [];\\n    if (flag2) a2 = [];\\n\\n    for (i = 0; i < n; i++) {\\n      if (flag1 && used[i] == 1) a1.push(a[i])\\n      if (flag2 && used[i] == 2) a2.push(a[i])\\n    }\\n\\n    if (flag1) {\\n      res[d] = x;\\n      tryExtract(a1, d+1);\\n    }\\n    if (flag2) {\\n      res[d] = -x;\\n      tryExtract(a2, d+1);\\n    }\\n  }\\n\\n  try {\\n    tryExtract(sums, 0);\\n  }\\n  catch(e) {\\n    return res;\\n  }\\n};", "var recoverArray = function(n, sums) {\\n    sums.sort((a, b) => a - b);\\n    let result = [];\\n    \\n    while (sums.length > 1) {\\n        let num = sums[sums.length - 1] - sums[sums.length - 2],\\n            excluding = [],\\n            including = [],\\n            counter = new Map();\\n        for (let item of sums) {\\n            let count = counter.get(item);\\n            if (count) {\\n                counter.set(item, count + 1);\\n            } else {\\n                counter.set(item, 1);\\n            }\\n        }\\n        \\n        for (let item of sums) {\\n            if (counter.get(item) > 0) {\\n                excluding.push(item);\\n                including.push(item + num);\\n                counter.set(item, counter.get(item) - 1);\\n                counter.set(item + num, counter.get(item + num) - 1);\\n            }\\n        }\\n        \\n        if (excluding.indexOf(0) !== -1) {\\n            sums = excluding;\\n            result.push(num);\\n        } else {\\n            sums = including;\\n            result.push(-1 * num);\\n        }\\n    }\\n    \\n    return result;\\n};", "var recoverArray = function(n, sums) {\\n    sums.sort((a, b) => a - b);\\n    let result = [];\\n    \\n    while (sums.length > 1) {\\n        let num = sums[sums.length - 1] - sums[sums.length - 2],\\n            excluding = [],\\n            including = [],\\n            counter = new Map();\\n        for (let item of sums) {\\n            let count = counter.get(item);\\n            if (count) {\\n                counter.set(item, count + 1);\\n            } else {\\n                counter.set(item, 1);\\n            }\\n        }\\n        \\n        for (let item of sums) {\\n            if (counter.get(item) > 0) {\\n                excluding.push(item);\\n                including.push(item + num);\\n                counter.set(item, counter.get(item) - 1);\\n                counter.set(item + num, counter.get(item + num) - 1);\\n            }\\n        }\\n        \\n        if (excluding.indexOf(0) !== -1) {\\n            sums = excluding;\\n            result.push(num);\\n        } else {\\n            sums = including;\\n            result.push(-1 * num);\\n        }\\n    }\\n    \\n    return result;\\n};"]}
{"id": "2110", "ref_js": ["var numberOfUniqueGoodSubsequences = function(binary) {\\n    ", "var numberOfUniqueGoodSubsequences = function(binary) {\\n    let endsZero = 0;\\n    let endsOne = 0;\\n    let hasZero = 0;\\n    for (let i = 0; i < binary.length; i++) {\\n        if (binary[i] === \\'1\\') {\\n            endsOne = (endsZero + endsOne + 1) % MOD;\\n        } else {\\n            endsZero = (endsZero + endsOne) % MOD;\\n            hasZero = 1;\\n        }\\n    }\\n    return (endsZero + endsOne + hasZero) % MOD;\\n};", "var numberOfUniqueGoodSubsequences = function(binary) {\\n    let endsZero = 0;\\n    let endsOne = 0;\\n    let hasZero = 0;\\n    for (let i = 0; i < binary.length; i++) {\\n        if (binary[i] === \\'1\\') {\\n            endsOne = (endsZero + endsOne + 1) % MOD;\\n        } else {\\n            endsZero = (endsZero + endsOne) % MOD;\\n            hasZero = 1;\\n        }\\n    }\\n    return (endsZero + endsOne + hasZero) % MOD;\\n};"]}
{"id": "2111", "ref_js": ["var numberOfGoodSubsets = function(A) {\\n    let freq={}\\n    A.forEach(c=>freq[c]=(freq[c]||0)+1)        \\n    A=Array.from(new Set(A)).filter(d=>!bad.has(d)) ", "var numberOfGoodSubsets = function(A) {\\n    let freq={}\\n    A.forEach(c=>freq[c]=(freq[c]||0)+1)        \\n    A=Array.from(new Set(A)).filter(d=>!bad.has(d)) ", "var numberOfGoodSubsets = function(A) {\\n    let freq={}\\n    A.forEach(c=>freq[c]=(freq[c]||0)+1)        \\n    A=Array.from(new Set(A)).filter(d=>!bad.has(d)) "]}
{"id": "2112", "ref_js": ["var gcdSort = function(nums) {\\n    ", "var gcdSort = function(nums) {\\n    ", "var gcdSort = function(nums) {\\n    "]}
{"id": "2113", "ref_js": ["var smallestMissingValueSubtree = function(parents, nums) {\\n    let n=parents.length,next=[...Array(n)].map(d=>[]),used={}\\n    for(let i=1;i<n;i++)\\n        next[parents[i]].push(i)\\n    let dfs=(node)=>{\\n        if(used[nums[node]])\\n\\t\\t\\treturn\\n\\t\\tused[nums[node]]=true\\n\\t\\tfor(let child of next[node])\\n\\t\\t\\tdfs(child)\\n    }\\n    let cur=nums.indexOf(1),leftAt=1,res=[...Array(n)].map(d=>1)\\n    while(cur!==-1){\\n        dfs(cur)\\n        while(used[leftAt])\\n            leftAt++\\n        res[cur]=leftAt\\n        cur=parents[cur]\\n    }\\n    return res\\n};", "var smallestMissingValueSubtree = function(parents, nums) {\\n    let n=parents.length,next=[...Array(n)].map(d=>[]),used={}\\n    for(let i=1;i<n;i++)\\n        next[parents[i]].push(i)\\n    let dfs=(node)=>{\\n        if(used[nums[node]])\\n\\t\\t\\treturn\\n\\t\\tused[nums[node]]=true\\n\\t\\tfor(let child of next[node])\\n\\t\\t\\tdfs(child)\\n    }\\n    let cur=nums.indexOf(1),leftAt=1,res=[...Array(n)].map(d=>1)\\n    while(cur!==-1){\\n        dfs(cur)\\n        while(used[leftAt])\\n            leftAt++\\n        res[cur]=leftAt\\n        cur=parents[cur]\\n    }\\n    return res\\n};", "var smallestMissingValueSubtree = function(parents, nums) {\\n    let n=parents.length,next=[...Array(n)].map(d=>[]),used={}\\n    for(let i=1;i<n;i++)\\n        next[parents[i]].push(i)\\n    let dfs=(node)=>{\\n        if(used[nums[node]])\\n\\t\\t\\treturn\\n\\t\\tused[nums[node]]=true\\n\\t\\tfor(let child of next[node])\\n\\t\\t\\tdfs(child)\\n    }\\n    let cur=nums.indexOf(1),leftAt=1,res=[...Array(n)].map(d=>1)\\n    while(cur!==-1){\\n        dfs(cur)\\n        while(used[leftAt])\\n            leftAt++\\n        res[cur]=leftAt\\n        cur=parents[cur]\\n    }\\n    return res\\n};"]}
{"id": "2114", "ref_js": ["var minOperations = function(nums) {\\n    const n = nums.length;\\n    const set = new Set(nums);\\n    const distinctNums = Array.from(set).sort((a, b) => a - b);\\n    const targetLen = distinctNums.length;\\n\\n    let left = 0;\\n    let right = 0;\\n    let maxLen = 0;\\n\\n    while (right < targetLen) {\\n        while (distinctNums[right] - distinctNums[left] > n - 1) {\\n            left++;\\n        }\\n        maxLen = Math.max(maxLen, right - left + 1);\\n        right++;\\n    }\\n\\n    return n - maxLen;\\n};", "var minOperations = function(nums) {\\n    ", "var minOperations = function(nums) {\\n    const length = nums.length;\\n    let minOperations = length;\\n    const uniqueNums = new Set(nums);\\n    const sortedUniqueNums = Array.from(uniqueNums).sort((a, b) => a - b);\\n    let right = 0;\\n\\n    for (let left = 0; left < sortedUniqueNums.length; left++) {\\n        while (right < sortedUniqueNums.length && sortedUniqueNums[right] < sortedUniqueNums[left] + length) {\\n            right++;\\n        }\\n\\n        minOperations = Math.min(minOperations, length - (right - left));\\n    }\\n\\n    return minOperations;    \\n};"]}
{"id": "2115", "ref_js": ["var longestSubsequenceRepeatedK = function (s, k) {\\n  let ans = \\'\\';\\n  const queue = [\\'\\'];\\n  while (queue.length) {\\n    const len = queue.length;\\n    for (let idx = 0; idx < len; idx++) {\\n      const curr = queue.shift();\\n      for (let i = 0; i < 26; i++) {\\n        const next = curr + String.fromCharCode(i + 97);\\n        if (isSubsequence(next, s, k)) {\\n          ans = next;\\n          queue.push(next);\\n        }\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};", "var longestSubsequenceRepeatedK = function (s, k) {\\n  let ans = \\'\\';\\n  const queue = [\\'\\'];\\n  while (queue.length) {\\n    const len = queue.length;\\n    for (let idx = 0; idx < len; idx++) {\\n      const curr = queue.shift();\\n      for (let i = 0; i < 26; i++) {\\n        const next = curr + String.fromCharCode(i + 97);\\n        if (isSubsequence(next, s, k)) {\\n          ans = next;\\n          queue.push(next);\\n        }\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};", "var longestSubsequenceRepeatedK = function (s, k) {\\n  let ans = \\'\\';\\n  const queue = [\\'\\'];\\n  while (queue.length) {\\n    const len = queue.length;\\n    for (let idx = 0; idx < len; idx++) {\\n      const curr = queue.shift();\\n      for (let i = 0; i < 26; i++) {\\n        const next = curr + String.fromCharCode(i + 97);\\n        if (isSubsequence(next, s, k)) {\\n          ans = next;\\n          queue.push(next);\\n        }\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};"]}
{"id": "2116", "ref_js": ["var scoreOfStudents = function(s, answers) {\\n    let correct=s.split(\\'+\\').reduce((a,c)=>a+c.split(\\'*\\').reduce((b,d)=>b*d,1),0),\\n        n=s.length,dp=[...Array(n)].map(d=>[...Array(n)])\\n    let dfs=(i=0,j=n-1)=>{\\n        if(dp[i][j]!==undefined)\\n            return dp[i][j]\\n        if(i===j)\\n            return dp[i][j]=[Number(s[i])]\\n        let ans=new Set()\\n        for(let k=i+1;k<=j-1;k+=2)\\n            for(let a1 of dfs(i,k-1))\\n                for(let a2 of dfs(k+1,j))\\n                    if(s[k]===\\'*\\')\\n                        ans.add(Number(a1)*Number(a2))\\n                    else\\n                        ans.add(Number(a1)+Number(a2))\\n        return dp[i][j]=Array.from(ans).filter(d=>d<=1000)\\n    }\\n    dfs()\\n    dp[0][n-1]=new Set(dp[0][n-1])\\n    return answers.reduce( (a,c)=> a+ (c===correct?5:(dp[0][n-1].has(c)?2:0)) ,0)\\n};", "var scoreOfStudents = function (s, answers) {\\n    let stack = []\\n    let n = s.length\\n    let LIMIT = 1000\\n    for (let i = 0; i < n; i++) {\\n        let v = s[i]\\n        if (stack.at(-1) === \\'*\\') {\\n            stack.pop()\\n            let product = Number(v) * Number(stack.pop())\\n            stack.push(product)\\n        } else {\\n            stack.push(v)\\n        }\\n\\n    }\\n    let total = 0\\n    for (let i = 0; i < stack.length; i++) {\\n        if (stack[i] !== \\'+\\') {\\n            total += Number(stack[i])\\n        }\\n    }\\n    let digits = new Set(\\'0123456789\\')\\n    let dp = new Map()\\n    function dfs(left, right) {\\n        if (left === right) {\\n            let ret = new Set()\\n            ret.add(Number(s[left]))\\n            return ret\\n        }\\n        let key = `${left}|${right}`\\n        if (dp.has(key)) return dp.get(key)\\n        let ans = new Set()\\n        for (let i = left + 1; i < right; i += 1) {\\n            if (!digits.has(s[i])) {\\n                let oper = s[i]\\n                let leftTree = dfs(left, i - 1)\\n                let rightTree = dfs(i + 1, right)\\n                for (const v1 of leftTree) {\\n                    for (const v2 of rightTree) {\\n                        if (oper == \\'+\\') {\\n                            ans.add(v1 + v2)\\n                        } else {\\n                            ans.add(v1 * v2)\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ans = new Set(Array.from(ans).filter(v => v <= LIMIT))\\n        dp.set(key, ans)\\n        return ans\\n\\n    }\\n    let ans = dfs(0, n - 1)\\n    ", "var scoreOfStudents = function (s, answers) {\\n    let stack = []\\n    let n = s.length\\n    let LIMIT = 1000\\n    for (let i = 0; i < n; i++) {\\n        let v = s[i]\\n        if (stack.at(-1) === \\'*\\') {\\n            stack.pop()\\n            let product = Number(v) * Number(stack.pop())\\n            stack.push(product)\\n        } else {\\n            stack.push(v)\\n        }\\n\\n    }\\n    let total = 0\\n    for (let i = 0; i < stack.length; i++) {\\n        if (stack[i] !== \\'+\\') {\\n            total += Number(stack[i])\\n        }\\n    }\\n    let digits = new Set(\\'0123456789\\')\\n    let dp = new Map()\\n    function dfs(left, right) {\\n        if (left === right) {\\n            let ret = new Set()\\n            ret.add(Number(s[left]))\\n            return ret\\n        }\\n        let key = `${left}|${right}`\\n        if (dp.has(key)) return dp.get(key)\\n        let ans = new Set()\\n        for (let i = left + 1; i < right; i += 1) {\\n            if (!digits.has(s[i])) {\\n                let oper = s[i]\\n                let leftTree = dfs(left, i - 1)\\n                let rightTree = dfs(i + 1, right)\\n                for (const v1 of leftTree) {\\n                    for (const v2 of rightTree) {\\n                        if (oper == \\'+\\') {\\n                            ans.add(v1 + v2)\\n                        } else {\\n                            ans.add(v1 * v2)\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ans = new Set(Array.from(ans).filter(v => v <= LIMIT))\\n        dp.set(key, ans)\\n        return ans\\n\\n    }\\n    let ans = dfs(0, n - 1)\\n    "]}
{"id": "2117", "ref_js": ["var waysToPartition = function(nums, k) {\\n    let totalSum=nums.reduce((acc, curr) => acc+curr)\\n    let left=0;\\n    let rightDiff={}\\n    let leftDiff={}\\n    \\n    for(let i=0; i<nums.length-1; i++) {\\n        left+=nums[i]\\n        const right=totalSum-left\\n        if(rightDiff[left-right]) rightDiff[left-right]++\\n        else rightDiff[left-right]=1\\n    }\\n\\n    let maxPartition=rightDiff[0] ? rightDiff[0] : 0\\n    left=0\\n    for(let i=0; i<nums.length; i++) {\\n        left+=nums[i]\\n        let diff=k-nums[i]\\n        const right=totalSum-left\\n        let leftVal=leftDiff[`${diff}`] ? leftDiff[`${diff}`] : 0\\n        let rightVal=rightDiff[`${-diff}`] ? rightDiff[`${-diff}`] : 0\\n        \\n        maxPartition=Math.max(maxPartition, leftVal+rightVal)\\n        if(leftDiff[left-right]) leftDiff[left-right]++\\n        else leftDiff[left-right]=1\\n        \\n        rightDiff[left-right]--\\n\\n    }\\n    \\n    return maxPartition\\n\\n};", "var waysToPartition = function(nums, k) {\\n    let totalSum=nums.reduce((acc, curr) => acc+curr)\\n    let left=0;\\n    let rightDiff={}\\n    let leftDiff={}\\n    \\n    for(let i=0; i<nums.length-1; i++) {\\n        left+=nums[i]\\n        const right=totalSum-left\\n        if(rightDiff[left-right]) rightDiff[left-right]++\\n        else rightDiff[left-right]=1\\n    }\\n\\n    let maxPartition=rightDiff[0] ? rightDiff[0] : 0\\n    left=0\\n    for(let i=0; i<nums.length; i++) {\\n        left+=nums[i]\\n        let diff=k-nums[i]\\n        const right=totalSum-left\\n        let leftVal=leftDiff[`${diff}`] ? leftDiff[`${diff}`] : 0\\n        let rightVal=rightDiff[`${-diff}`] ? rightDiff[`${-diff}`] : 0\\n        \\n        maxPartition=Math.max(maxPartition, leftVal+rightVal)\\n        if(leftDiff[left-right]) leftDiff[left-right]++\\n        else leftDiff[left-right]=1\\n        \\n        rightDiff[left-right]--\\n\\n    }\\n    \\n    return maxPartition\\n\\n};", "var waysToPartition = function(nums, k) {\\n    let totalSum=nums.reduce((acc, curr) => acc+curr)\\n    let left=0;\\n    let rightDiff={}\\n    let leftDiff={}\\n    \\n    for(let i=0; i<nums.length-1; i++) {\\n        left+=nums[i]\\n        const right=totalSum-left\\n        if(rightDiff[left-right]) rightDiff[left-right]++\\n        else rightDiff[left-right]=1\\n    }\\n\\n    let maxPartition=rightDiff[0] ? rightDiff[0] : 0\\n    left=0\\n    for(let i=0; i<nums.length; i++) {\\n        left+=nums[i]\\n        let diff=k-nums[i]\\n        const right=totalSum-left\\n        let leftVal=leftDiff[`${diff}`] ? leftDiff[`${diff}`] : 0\\n        let rightVal=rightDiff[`${-diff}`] ? rightDiff[`${-diff}`] : 0\\n        \\n        maxPartition=Math.max(maxPartition, leftVal+rightVal)\\n        if(leftDiff[left-right]) leftDiff[left-right]++\\n        else leftDiff[left-right]=1\\n        \\n        rightDiff[left-right]--\\n\\n    }\\n    \\n    return maxPartition\\n\\n};"]}
{"id": "2118", "ref_js": ["var divisorSubstrings = function(num, k) {\\n\\n    let numArray =  num.toString().split(\"\")\\n    let k_interval = \"\";\\n    let ris = 0;\\n\\n    for (i = 0; i < numArray.length; i++) {\\n      k_interval = k_interval + numArray[i]\\n      if (i >= k - 1) {\\n        if (num % parseInt(k_interval) === 0){ris++}\\n        k_interval = k_interval.slice(1);\\n      }\\n\\n    }\\n    \\n    return ris;\\n  };", "var divisorSubstrings = function(num, k) {\\n\\n    num = num.toString();\\n    let subStr, ctr=0; \\n    for(let p=0; p<= num.length-k ; p++){\\n        subStr = num.slice(p, p+k);\\n        if(num%subStr === 0 ){\\n            ctr++;\\n        }\\n    }\\n\\n    return ctr;\\n};", "var divisorSubstrings = function(num, k) {\\n    let count = 0;\\n    "]}
{"id": "2119", "ref_js": ["var minimumDifference = function (nums) {\\n  const N = nums.length;\\n  const n = N / 2;\\n  const left = new Array(n + 1).fill().map(() => new Array().fill());\\n  const right = new Array(n + 1).fill().map(() => new Array().fill());\\n\\n  let sum = 0;\\n  nums.forEach((num) => (sum += num));\\n\\n  for (let i = 0; i < 1 << n; i++) {\\n    let count = 0; ", "var minimumDifference = function(nums) {\\n    const middle = parseInt(nums.length/2);\\n    ", "var minimumDifference = function (nums) {\\n  const N = nums.length;\\n  const n = N / 2;\\n  const left = new Array(n + 1).fill().map(() => new Array().fill());\\n  const right = new Array(n + 1).fill().map(() => new Array().fill());\\n\\n  let sum = 0;\\n  nums.forEach((num) => (sum += num));\\n\\n  for (let i = 0; i < 1 << n; i++) {\\n    let count = 0; "]}
{"id": "2120", "ref_js": ["var kthSmallestProduct = function (nums1, nums2, k) {\\n    let prod_left = -((10 ** 5) ** 2),                         ", "var kthSmallestProduct = function (nums1, nums2, k) {\\n    let prod_left = -((10 ** 5) ** 2),                         ", "var kthSmallestProduct = function (nums1, nums2, k) {\\n    let prod_left = -((10 ** 5) ** 2),                         "]}
{"id": "2121", "ref_js": ["var secondMinimum = function (n, edges, time, change) {\\n    let firstDist = Array(n).fill(Infinity)\\n    let secondDist = Array(n).fill(Infinity)\\n    let map = new Map()\\n    for (const [at, to] of edges) {\\n        let u = at - 1\\n        let v = to - 1\\n        if (!map.has(u)) {\\n            map.set(u, [])\\n        }\\n        if (!map.has(v)) {\\n            map.set(v, [])\\n        }\\n        map.get(u).push(v)\\n        map.get(v).push(u)\\n    }\\n    let pq = new MinPriorityQueue({ priority: (x) => x[1] }) ", "var secondMinimum = function(n, edges, time, change) {\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [u, v] of edges) {\\n    graph[u].push(v);\\n    graph[v].push(u);\\n  }\\n  let heap = new PriorityQueue((a, b) => a[1] - b[1]); ", "var secondMinimum = function(n, edges, time, change) {\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [u, v] of edges) {\\n    graph[u].push(v);\\n    graph[v].push(u);\\n  }\\n  let heap = new PriorityQueue((a, b) => a[1] - b[1]); "]}
{"id": "2122", "ref_js": ["var minimumTime = function(n, relations, time) {\\n    let graph = {};", "var minimumTime = function(n, relations, time) {\\n    var cache = new Uint32Array(n);\\n    var graph = Array(n).fill(null).map(() => []);\\n\\n    ", "var minimumTime = function(n, relations, time) {\\n    var cache = new Uint32Array(n);\\n    var graph = Array(n).fill(null).map(() => []);\\n\\n    "]}
{"id": "2123", "ref_js": ["var countCombinations = function (pieces, positions) {\\n  let n = pieces.length;\\n  q.clear();\\n  posStatesSet.clear();\\n\\n  for (let i = 0; i < n; i++) {\\n    positions[i][0];\\n    positions[i][1];\\n    dataCur.steps[i] = 0;\\n    dataCur.stopped[i] = 0;\\n  }\\n\\n  function btInit(i) {\\n    if (i >= n) {\\n      q.enqueue(encode(dataCur, n));\\n      return;\\n    }\\n\\n    let d = pieces[i] == \"bishop\" ? 1 : 0;\\n    let j = pieces[i] == \"queen\" ? 1 : 2;\\n\\n    for (; d < 8; d += j) {\\n      dataCur.dir[i] = d;\\n      btInit(i + 1);\\n    }\\n  }\\n  btInit(0);\\n\\n  function btNext(i, codePre) {\\n    if (i >= n) {\\n      let code = encode(dataCur, n);\\n      if (code != codePre) q.enqueue(code);\\n      return;\\n    }\\n\\n    dataCur.r[i] = dataPre.r[i];\\n    dataCur.c[i] = dataPre.c[i];\\n    dataCur.steps[i] = dataPre.steps[i];\\n    dataCur.dir[i] = dataPre.dir[i];\\n    dataCur.stopped[i] = 1;\\n    let flagValid = true;\\n\\n    for (let j = 0; j < i; j++)\\n      if (dataCur.c[i] == dataCur.c[j] && dataCur.r[i] == dataCur.r[j]) {\\n        flagValid = false;\\n        break;\\n      }\\n\\n    if (flagValid) btNext(i + 1, codePre);\\n\\n    if (dataPre.stopped[i]) return;\\n    dataCur.steps[i] = dataPre.steps[i] + 1;\\n    dataCur.stopped[i] = 0;\\n    dataCur.r[i] = dataPre.r[i] + DIR_R[dataPre.dir[i]];\\n    dataCur.c[i] = dataPre.c[i] + DIR_C[dataPre.dir[i]];\\n\\n    if (dataCur.r[i] <= 0 || dataCur.r[i] > 8) return;\\n    if (dataCur.c[i] <= 0 || dataCur.c[i] > 8) return;\\n\\n    for (let j = 0; j < i; j++)\\n      if (dataCur.c[i] == dataCur.c[j] && dataCur.r[i] == dataCur.r[j]) {\\n        return;\\n      }\\n\\n    btNext(i + 1, codePre);\\n  }\\n\\n  let maxSize = q.size;\\n  while (q.size) {\\n    maxSize = Math.max(q.size, maxSize)\\n    let code = q.dequeue();\\n    decode(code, n, positions, dataPre);\\n    posStatesSet.add(dataPre.posState);\\n    btNext(0, code);\\n  }\\n\\n  return posStatesSet.size;\\n};", "var countCombinations = function (pieces, positions) {\\n  let n = pieces.length;\\n  q.clear();\\n  posStatesSet.clear();\\n\\n  for (let i = 0; i < n; i++) {\\n    positions[i][0];\\n    positions[i][1];\\n    dataCur.steps[i] = 0;\\n    dataCur.stopped[i] = 0;\\n  }\\n\\n  function btInit(i) {\\n    if (i >= n) {\\n      q.enqueue(encode(dataCur, n));\\n      return;\\n    }\\n\\n    let d = pieces[i] == \"bishop\" ? 1 : 0;\\n    let j = pieces[i] == \"queen\" ? 1 : 2;\\n\\n    for (; d < 8; d += j) {\\n      dataCur.dir[i] = d;\\n      btInit(i + 1);\\n    }\\n  }\\n  btInit(0);\\n\\n  function btNext(i, codePre) {\\n    if (i >= n) {\\n      let code = encode(dataCur, n);\\n      if (code != codePre) q.enqueue(code);\\n      return;\\n    }\\n\\n    dataCur.r[i] = dataPre.r[i];\\n    dataCur.c[i] = dataPre.c[i];\\n    dataCur.steps[i] = dataPre.steps[i];\\n    dataCur.dir[i] = dataPre.dir[i];\\n    dataCur.stopped[i] = 1;\\n    let flagValid = true;\\n\\n    for (let j = 0; j < i; j++)\\n      if (dataCur.c[i] == dataCur.c[j] && dataCur.r[i] == dataCur.r[j]) {\\n        flagValid = false;\\n        break;\\n      }\\n\\n    if (flagValid) btNext(i + 1, codePre);\\n\\n    if (dataPre.stopped[i]) return;\\n    dataCur.steps[i] = dataPre.steps[i] + 1;\\n    dataCur.stopped[i] = 0;\\n    dataCur.r[i] = dataPre.r[i] + DIR_R[dataPre.dir[i]];\\n    dataCur.c[i] = dataPre.c[i] + DIR_C[dataPre.dir[i]];\\n\\n    if (dataCur.r[i] <= 0 || dataCur.r[i] > 8) return;\\n    if (dataCur.c[i] <= 0 || dataCur.c[i] > 8) return;\\n\\n    for (let j = 0; j < i; j++)\\n      if (dataCur.c[i] == dataCur.c[j] && dataCur.r[i] == dataCur.r[j]) {\\n        return;\\n      }\\n\\n    btNext(i + 1, codePre);\\n  }\\n\\n  let maxSize = q.size;\\n  while (q.size) {\\n    maxSize = Math.max(q.size, maxSize)\\n    let code = q.dequeue();\\n    decode(code, n, positions, dataPre);\\n    posStatesSet.add(dataPre.posState);\\n    btNext(0, code);\\n  }\\n\\n  return posStatesSet.size;\\n};", "var countCombinations = function (pieces, positions) {\\n  let n = pieces.length;\\n  q.clear();\\n  posStatesSet.clear();\\n\\n  for (let i = 0; i < n; i++) {\\n    positions[i][0];\\n    positions[i][1];\\n    dataCur.steps[i] = 0;\\n    dataCur.stopped[i] = 0;\\n  }\\n\\n  function btInit(i) {\\n    if (i >= n) {\\n      q.enqueue(encode(dataCur, n));\\n      return;\\n    }\\n\\n    let d = pieces[i] == \"bishop\" ? 1 : 0;\\n    let j = pieces[i] == \"queen\" ? 1 : 2;\\n\\n    for (; d < 8; d += j) {\\n      dataCur.dir[i] = d;\\n      btInit(i + 1);\\n    }\\n  }\\n  btInit(0);\\n\\n  function btNext(i, codePre) {\\n    if (i >= n) {\\n      let code = encode(dataCur, n);\\n      if (code != codePre) q.enqueue(code);\\n      return;\\n    }\\n\\n    dataCur.r[i] = dataPre.r[i];\\n    dataCur.c[i] = dataPre.c[i];\\n    dataCur.steps[i] = dataPre.steps[i];\\n    dataCur.dir[i] = dataPre.dir[i];\\n    dataCur.stopped[i] = 1;\\n    let flagValid = true;\\n\\n    for (let j = 0; j < i; j++)\\n      if (dataCur.c[i] == dataCur.c[j] && dataCur.r[i] == dataCur.r[j]) {\\n        flagValid = false;\\n        break;\\n      }\\n\\n    if (flagValid) btNext(i + 1, codePre);\\n\\n    if (dataPre.stopped[i]) return;\\n    dataCur.steps[i] = dataPre.steps[i] + 1;\\n    dataCur.stopped[i] = 0;\\n    dataCur.r[i] = dataPre.r[i] + DIR_R[dataPre.dir[i]];\\n    dataCur.c[i] = dataPre.c[i] + DIR_C[dataPre.dir[i]];\\n\\n    if (dataCur.r[i] <= 0 || dataCur.r[i] > 8) return;\\n    if (dataCur.c[i] <= 0 || dataCur.c[i] > 8) return;\\n\\n    for (let j = 0; j < i; j++)\\n      if (dataCur.c[i] == dataCur.c[j] && dataCur.r[i] == dataCur.r[j]) {\\n        return;\\n      }\\n\\n    btNext(i + 1, codePre);\\n  }\\n\\n  let maxSize = q.size;\\n  while (q.size) {\\n    maxSize = Math.max(q.size, maxSize)\\n    let code = q.dequeue();\\n    decode(code, n, positions, dataPre);\\n    posStatesSet.add(dataPre.posState);\\n    btNext(0, code);\\n  }\\n\\n  return posStatesSet.size;\\n};"]}
{"id": "2124", "ref_js": ["var possiblyEquals = function(s1, s2) {    \\n    ", "var possiblyEquals = function(s1, s2) {    \\n    ", "var possiblyEquals = function(s1, s2) {    \\n    "]}
{"id": "2125", "ref_js": ["var maximalPathQuality = function(values, edges, maxTime) {\\n    const adjacencyList = values.map(() => []);\\n    for (const [node1, node2, time] of edges) {\\n        adjacencyList[node1].push([node2, time]);\\n        adjacencyList[node2].push([node1, time]);\\n    }\\n    \\n    const dfs = (node, quality, time, seen) => {\\n        ", "var maximalPathQuality = function (values, edges, maxTime) {\\n  const n = values.length;\\n  const graph = new Array(n).fill().map((_) => []);\\n  for (const [v1, v2, time] of edges) {\\n    graph[v1].push([v2, time]);\\n    graph[v2].push([v1, time]);\\n  }\\n\\n  const visited = new Array(n).fill(0);\\n  visited[0] = 1;\\n  const ans = { val: 0 };", "var maximalPathQuality = function (values, edges, maxTime) {\\n  const n = values.length;\\n  const graph = new Array(n).fill().map((_) => []);\\n  for (const [v1, v2, time] of edges) {\\n    graph[v1].push([v2, time]);\\n    graph[v2].push([v1, time]);\\n  }\\n\\n  const visited = new Array(n).fill(0);\\n  visited[0] = 1;\\n  const ans = { val: 0 };"]}
{"id": "2126", "ref_js": ["var maxTaskAssign = function(tasks, workers, pills, strength) {\\n  let m = workers.length;\\n  tasks.sort((a, b) => a - b);\\n  workers.sort((a, b) => b - a);\\n  let low = 0, high = m;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canAssign(mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return low;\\n  \\n  function canAssign(k) {\\n    let queue = new Deque(), pillsUsed = 0;\\n    for (let j = k - 1, i = 0; j >= 0; j--) {\\n      while (i < k && workers[j] + strength >= tasks[i]) {\\n        queue.push(tasks[i++]);\\n      }\\n      if (queue.isEmpty()) return false; ", "var maxTaskAssign = function(tasks, workers, pills, strength) {\\n    workers.sort((b, a) => b - a);\\n    tasks.sort((b, a) => b - a);\\n\\n    let lTasks = -1, rTasks = Math.min(tasks.length, workers.length) - 1;\\n\\n    while (lTasks < rTasks) {\\n        const midTasks = (lTasks + rTasks + 1) >> 1;\\n        let t = midTasks;\\n\\n        for (let w = workers.length - 1, freePills = pills, queue = []; t >= 0; t--) {\\n            if (queue[0] >= tasks[t]) {\\n                queue.shift();\\n            } else if (workers[w] >= tasks[t]) {\\n                w--;\\n            } else if (freePills > 0) {\\n                while (w >= 0 && workers[w] + strength >= tasks[t])\\n                    queue.push(workers[w--]);\\n\\n                if (queue.length == 0) break;\\n                queue.pop(), freePills--;\\n            } else break;\\n        }\\n        t == -1 ? lTasks = midTasks : rTasks = midTasks - 1;\\n    }\\n    return lTasks + 1;\\n};", "var maxTaskAssign = function(tasks, workers, pills, strength) {\\n  let m = workers.length;\\n  tasks.sort((a, b) => a - b);\\n  workers.sort((a, b) => b - a);\\n  let low = 0, high = m;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canAssign(mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return low;\\n  \\n  function canAssign(k) {\\n    let queue = new Deque(), pillsUsed = 0;\\n    for (let j = k - 1, i = 0; j >= 0; j--) {\\n      while (i < k && workers[j] + strength >= tasks[i]) {\\n        queue.push(tasks[i++]);\\n      }\\n      if (queue.isEmpty()) return false; "]}
{"id": "2127", "ref_js": ["var friendRequests = function(n, restrictions, requests) {\\n    const dsu = new DSU(), result = [];\\n    for (let i = 0; i < n; i++) dsu.add(i);\\n    \\n    for (let [friend1, friend2] of requests) {\\n        const parent1 = dsu.find(friend1), parent2 = dsu.find(friend2);\\n        let friendshipPossible = true;\\n        for (let [enemy1, enemy2] of restrictions) {\\n            const enemyParent1 = dsu.find(enemy1), enemyParent2 = dsu.find(enemy2);\\n            const condition1 = (enemyParent1 === parent1 && enemyParent2 === parent2);\\n            const condition2 = (enemyParent1 === parent2 && enemyParent2 === parent1);\\n            if (condition1 || condition2) {\\n                friendshipPossible = false;\\n                break;\\n            }\\n        }\\n        if (friendshipPossible) dsu.union(friend1, friend2);\\n        result.push(friendshipPossible);\\n    }\\n    return result;\\n};", "var friendRequests = function(numPeople, restrictions, requests) {\\n    ", "var friendRequests = function(n, restrictions, requests) {\\n    \\n    const connected = new Array(n).fill(-1);\\n    \\n    const find = (person) => {\\n        \\n        if(connected[person] < 0) return person;\\n        \\n        return find(connected[person]);\\n    }\\n    \\n    const union = (p1, p2) => {\\n        \\n        const pp1 = find(p1), pp2 = find(p2);\\n        \\n        if(pp1 === pp2) return pp1;\\n        \\n        const r1 = connected[pp1], r2 = connected[pp2];\\n        \\n        if(r1 <= r2) {\\n            connected[pp1] += r2;\\n            connected[pp2] = pp1;\\n        } else {\\n            connected[pp2] += r1;\\n            connected[pp1] = pp2;\\n        }\\n    }\\n\\n    const check = () => {\\n\\n        for(const [p1, p2] of restrictions) {\\n\\n            if(find(p1) === find(p2)) return false;\\n        }\\n        return true;\\n    };"]}
{"id": "2128", "ref_js": ["var kMirror = function(k, n) {\\n  let degree = 1\\n  let sum = 0\\n  const list = [1]\\n  const generateNewNum = () => {\\n    list[0]++\\n    for(let i = 0; i < list.length; i++){\\n      if(list[i] !== k)break\\n      else {\\n        list[i] = 0\\n        if(i+1 < list.length){\\n          list[i+1] += 1\\n        }else{\\n          if(degree % 2){\\n            list[i] =  1\\n          }else{\\n            list[i+1] = 1\\n          }\\n          degree++\\n        }\\n      }\\n    }\\n  }\\n  while(n > 0){\\n    const num = convert(list, k, degree)\\n    if(isMirror(num)){\\n      sum += num\\n      n--\\n    }\\n    generateNewNum()\\n  }\\n  return sum\\n};", "var kMirror = function (k, n) {\\n    if (kPalinArrObj[k] === undefined) {\\n        kPalinArrObj[k] = generatePalindromesArr(1, LIMIT, k).sort( (a, b) => a - b );\\n    }\\n    let kPalinArr = kPalinArrObj[k];\\n\\n    let sum = 0,\\n        count = 0;\\n    for (let num of kPalinArr) {\\n        if (palinSet.has(num)) {\\n            count++;\\n            sum += num;\\n            if (count >= n) break;\\n        }\\n    }\\n\\n    return sum;\\n};", "var kMirror = function (k, n) {\\n    if (kPalinArrObj[k] === undefined) {\\n        kPalinArrObj[k] = generatePalindromesArr(1, LIMIT, k).sort( (a, b) => a - b );\\n    }\\n    let kPalinArr = kPalinArrObj[k];\\n\\n    let sum = 0,\\n        count = 0;\\n    for (let num of kPalinArr) {\\n        if (palinSet.has(num)) {\\n            count++;\\n            sum += num;\\n            if (count >= n) break;\\n        }\\n    }\\n\\n    return sum;\\n};"]}
{"id": "2129", "ref_js": ["var kClosest = function(points, K) {\\n    points.sort((a,b) => (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]))\\n\\n    return points.slice(0,K)\\n};", "var kClosest = function(points, k) {\\n    const res = []\\n    const minHeap = new MinPriorityQueue()\\n    points.forEach(p => {\\n        const distanceFromOrigin = Math.sqrt(p[0] * p[0] + p[1] * p[1])\\n        minHeap.enqueue(p, distanceFromOrigin)\\n    })\\n    while(res.length < k) res.push(minHeap.dequeue().element)\\n    return res\\n    ", "var kClosest = function(points, k) {\\n    "]}
{"id": "2130", "ref_js": ["var findAllPeople = function (n, meetings, firstPerson) {\\n  let set = new WeightedDisjointSet({ n });\\n  set.union(0, firstPerson);\\n\\n  meetings.sort((a, b) => a[2] - b[2]); ", "var findAllPeople = function(n, meetings, firstPerson) {\\n    const timeToMeeting = mapSortedTimeToMeetings(meetings);\\n    \\n    const peopleThatCurrentlyHaveSecret = new Set([0, firstPerson]);\\n    for (const peopleInMeetings of timeToMeeting.values()) {\\n        const personToMeetingsWithPeople = \\n            mapPeopleToPeopleTheyAreHavingMeetingsWith(peopleInMeetings);\\n        let peopleInMeetingsWithSecret = \\n            findPeopleThatHaveTheSecret(peopleInMeetings, peopleThatCurrentlyHaveSecret);\\n        \\n        ", "var findAllPeople = function(n, meetings, firstPerson) {\\n    const timeToMeeting = mapSortedTimeToMeetings(meetings);\\n    \\n    const peopleThatCurrentlyHaveSecret = new Set([0, firstPerson]);\\n    for (const peopleInMeetings of timeToMeeting.values()) {\\n        const personToMeetingsWithPeople = \\n            mapPeopleToPeopleTheyAreHavingMeetingsWith(peopleInMeetings);\\n        let peopleInMeetingsWithSecret = \\n            findPeopleThatHaveTheSecret(peopleInMeetings, peopleThatCurrentlyHaveSecret);\\n        \\n        "]}
{"id": "2131", "ref_js": ["var validArrangement = function(pairs) {\\n    ", "var validArrangement = function (pairs) {\\n    let ans = [];\\n    let graph = new Map();\\n\\n    function dfs(start) {\\n        while (graph.get(start)?.length) {\\n            let end = graph.get(start).pop();\\n            dfs(end);\\n            ans.push([start, end]);\\n        }\\n    }\\n\\n    let counts = new Map();\\n    for (let [start, end] of pairs) {\\n        counts.set(start, (counts.get(start) || 0) + 1);\\n        counts.set(end, (counts.get(end) || 0) - 1);\\n\\n        if (graph.has(start)) graph.get(start).push(end);\\n        else graph.set(start, [end]);\\n    }\\n\\n    let begin = counts.entries().next().value[0];\\n    for (let [s, count] of counts) if (count === 1) begin = s;\\n    dfs(begin);\\n\\n    return ans.reverse();\\n};", "var validArrangement = function(pairs) {\\n  let graph = {};"]}
{"id": "2133", "ref_js": ["var maxTotalFruits = function(fruits, startPos, k) {\\n    \\n    let n = Math.max(fruits[fruits.length-1][0], startPos)+1;\\n    let numFruits = new Array(n).fill(0);\\n    let sums = new Array(n).fill(0);\\n    for(let obj of fruits) {\\n        let [pos, num] = obj;\\n        numFruits[pos] = num;\\n    }\\n    sums[startPos] = numFruits[startPos] ;\\n    for(let i = startPos+1; i < n && i <= startPos + k; i++) {\\n        sums[i] = sums[i-1] + numFruits[i];\\n    }\\n    for(let i = startPos-1; i >=0 && i >= startPos - k; i--) {\\n        sums[i] = sums[i+1] + numFruits[i];\\n    }\\n    ", "var maxTotalFruits = function (fruits, start, k) {\\n    let n = 2 * 10 ** 5 + 1; ", "var maxTotalFruits = function (fruits, start, k) {\\n    let n = 2 * 10 ** 5 + 1; "]}
{"id": "2134", "ref_js": ["var kIncreasing = function (arr, k) {\\n  let res = 0,\\n    n = arr.length;\\n  for (let i = 0; i < k; i++) {\\n    const newArr = [];\\n    for (let j = i; j < n; j += k) {\\n      newArr.push(arr[j]);\\n    }\\n    res += newArr.length - longestNonDecreasingSub(newArr);\\n  }\\n  return res;\\n};", "var kIncreasing = function (arr, k) {\\n  let res = 0,\\n    n = arr.length;\\n  for (let i = 0; i < k; i++) {\\n    const newArr = [];\\n    for (let j = i; j < n; j += k) {\\n      newArr.push(arr[j]);\\n    }\\n    res += newArr.length - longestNonDecreasingSub(newArr);\\n  }\\n  return res;\\n};", "var kIncreasing = function (arr, k) {\\n  let res = 0,\\n    n = arr.length;\\n  for (let i = 0; i < k; i++) {\\n    const newArr = [];\\n    for (let j = i; j < n; j += k) {\\n      newArr.push(arr[j]);\\n    }\\n    res += newArr.length - longestNonDecreasingSub(newArr);\\n  }\\n  return res;\\n};"]}
{"id": "2135", "ref_js": ["var abbreviateProduct = function(left, right) {\\n    let product = 1n\\n    let count = 0\\n    for(let i = left; i <= right; i++){\\n        product *= BigInt(i)\\n    }\\n     while(product % 10n === 0n){\\n        product /= 10n\\n        count++\\n    }\\n   \\n    product = product.toString()\\n    if(product.length > 10){\\n        const first = product.slice(0,5)\\n        const last = product.slice(-5)\\n\\n        return first + \\'...\\' + last + \\'e\\' + count\\n\\n    }\\n    return product + \\'e\\' + count\\n    \\n    \\n};", "var abbreviateProduct = function(left, right) {\\n    let product = 1n\\n    let count = 0\\n    for(let i = left; i <= right; i++){\\n        product *= BigInt(i)\\n    }\\n     while(product % 10n === 0n){\\n        product /= 10n\\n        count++\\n    }\\n   \\n    product = product.toString()\\n    if(product.length > 10){\\n        const first = product.slice(0,5)\\n        const last = product.slice(-5)\\n\\n        return first + \\'...\\' + last + \\'e\\' + count\\n\\n    }\\n    return product + \\'e\\' + count\\n    \\n    \\n};", "var abbreviateProduct = function(left, right) {\\n    let product = 1n\\n    let count = 0\\n    for(let i = left; i <= right; i++){\\n        product *= BigInt(i)\\n    }\\n     while(product % 10n === 0n){\\n        product /= 10n\\n        count++\\n    }\\n   \\n    product = product.toString()\\n    if(product.length > 10){\\n        const first = product.slice(0,5)\\n        const last = product.slice(-5)\\n\\n        return first + \\'...\\' + last + \\'e\\' + count\\n\\n    }\\n    return product + \\'e\\' + count\\n    \\n    \\n};"]}
{"id": "2136", "ref_js": ["var fairCandySwap = function(aliceSizes, bobSizes) {\\n    const totalAliceSize = aliceSizes.reduce((prev, current) => prev + current, 0);\\n    const totalBobSize = bobSizes.reduce((prev, current) => prev + current, 0);\\n    \\n    const resolve = (array1, array2, difference) => {\\n        const hashmap = new Map();\\n        for (let i = 0; i < array1.length; i++) {\\n            hashmap.set(array1[i], i);\\n        }\\n        \\n        for (let i = 0; i < array2.length; i++) {\\n            if (hashmap.has(array2[i] + difference/2)) return [array2[i] + difference/2, array2[i]];\\n        }\\n    }\\n    \\n    return resolve(aliceSizes, bobSizes, totalAliceSize - totalBobSize);\\n};", "var fairCandySwap = function(aliceSizes, bobSizes) {\\n    const suma = aliceSizes.reduce((a, b) => a + b, 0)\\n    const sumb = bobSizes.reduce((a, b) => a + b, 0)\\n    const diff = (sumb - suma) / 2\\n    const lena = aliceSizes.length\\n    const lenb = bobSizes.length\\n    for (let i=0; i<lena; i++) {\\n        for (let j=0; j<lenb; j++) {\\n            if (bobSizes[j] - aliceSizes[i] === diff) {\\n                return [aliceSizes[i], bobSizes[j]]\\n            }\\n        }\\n    }\\n};", "var fairCandySwap = function(aliceSizes, bobSizes) {\\n    let totalA = aliceSizes.reduce((a, b) => a + b, 0);\\n    let totalB = bobSizes.reduce((a, b) => a + b, 0);\\n\\n    let setB = new Set(bobSizes);\\n    let setA = new Set(aliceSizes);\\n\\n    for(let x of setA){\\n        let calc = (totalB - totalA) / 2 + x;\\n\\n        if(setB.has(calc)){\\n            return [\\n                x, \\n                calc\\n            ]\\n        }\\n    }\\n};"]}
{"id": "2137", "ref_js": ["var maximumInvitations = function(favorite) {\\n    const n = favorite.length\\n    let indegree = new Array(n).fill(0), pairs = [], map = {}, out = 0\\n    \\n    for (let i = 0; i < n; i++) {\\n        ", "var maximumInvitations = function(favorite) {\\n    let res = 0;\\n    let len = favorite.length;\\n    ", "var maximumInvitations = function(favorite) {\\n    let res = 0;\\n    let len = favorite.length;\\n    "]}
{"id": "2138", "ref_js": ["var possibleToStamp = function(grid, stampHeight, stampWidth) {\\n    const w = grid[0].length;\\n    const h = grid.length;\\n    \\n    ", "var possibleToStamp = function (grid, stampHeight, stampWidth) {\\n    let d = [];\\n    let a = grid;\\n    let h = grid.length;\\n    let w = grid[0].length;\\n    for (let i = 0; i <= h; i++) {\\n        d[i] = new Array(w + 1).fill(0);\\n    }\\n    ", "var possibleToStamp = function(grid, stampHeight, stampWidth) {\\n    const w = grid[0].length;\\n    const h = grid.length;\\n    \\n    "]}
{"id": "2139", "ref_js": ["var earliestFullBloom = function (plantTime, growTime) {\\n  const array = [];\\n  const n = plantTime.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    array.push([plantTime[i], growTime[i]]);\\n  }\\n  array.sort((a, b) => b[1] - a[1]);\\n\\n  let ans = -Infinity;\\n  let totalPlantTime = 0;\\n  for (const [plant, grow] of array) {\\n    totalPlantTime += plant;\\n    ans = Math.max(ans, totalPlantTime + grow);\\n  }\\n\\n  return ans;\\n};", "var earliestFullBloom = function(plantTime, growTime) \\n{\\n    let times = [];\\n    for(let i=0; i<plantTime.length; i++)\\n            times.push([plantTime[i], growTime[i]]);\\n\\n    times.sort((a,b)=>b[1]-a[1]);\\n\\n    let t = 0, bt = 0;\\n    for(let i=0; i<times.length; i++)\\n    {\\n        t += times[i][0];\\n        bt = Math.max(bt, t+times[i][1]);\\n    }\\n    return bt;\\n};", "var earliestFullBloom = function (plantTime, growTime) {\\n  const array = [];\\n  const n = plantTime.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    array.push([plantTime[i], growTime[i]]);\\n  }\\n  array.sort((a, b) => b[1] - a[1]);\\n\\n  let ans = -Infinity;\\n  let totalPlantTime = 0;\\n  for (const [plant, grow] of array) {\\n    totalPlantTime += plant;\\n    ans = Math.max(ans, totalPlantTime + grow);\\n  }\\n\\n  return ans;\\n};"]}
{"id": "2140", "ref_js": ["var maxRunTime = function(n, batteries) {\\n            batteries.sort((a, b) => a - b);\\n        let left = 1, right = Math.floor(batteries.reduce((a, b) => a + b) / n);\\n        while (left < right) {\\n            let target = right - Math.floor((right - left) / 2);\\n            let total = batteries.reduce((a, b) => a + Math.min(b, target), 0);\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n};", "var maxRunTime = function(n, batteries) {\\n    ", "var maxRunTime = function(n, batteries) {\\n    batteries.sort((a, b) => a - b); "]}
{"id": "2141", "ref_js": ["var numberOfWays = function(corridor) {\\n    const mod = 1000000007;  ", "var numberOfWays = function(corridor) {\\n    ", "var numberOfWays = function(corridor) {\\n    "]}
{"id": "2142", "ref_js": ["var fourSumCount = function(nums1, nums2, nums3, nums4) {\\n  let map = new Map();\\n   let cnt = 0;\\n    let n = nums1.length;\\n    \\n    for(let num of nums1) {\\n        for(let num2 of nums2){\\n           map.set(num + num2, map.get(num + num2) ? map.get(num + num2) + 1 : 1)\\n    }}\\n    \\n     for(let num of nums3) {\\n        for(let num2 of nums4){\\n            if(map.has(-(num + num2))) { \\n                cnt += map.get(-(num + num2))\\n            }\\n     }}\\n    \\n    return cnt;\\n    \\n   \\n};", "var fourSumCount = function(nums1, nums2, nums3, nums4) {\\n    let m=new Map(),count=0;\\n    \\n    nums1.forEach(n1=>{\\n        nums2.forEach(n2=>{\\n            let sum=n1+n2;\\n            m.set(sum,m.get(sum)+1 || 1);\\n        })\\n    })\\n   \\n    nums3.forEach(n3=>{\\n        nums4.forEach(n4=>{\\n            let sum=-(n3+n4);\\n            count+=m.get(sum)?m.get(sum):0;\\n        })\\n    })\\n    return count;\\n};", "var fourSumCount = function(nums1, nums2, nums3, nums4) {\\n  let map = new Map();\\n   let cnt = 0;\\n    let n = nums1.length;\\n    \\n    for(let num of nums1) {\\n        for(let num2 of nums2){\\n           map.set(num + num2, map.get(num + num2) ? map.get(num + num2) + 1 : 1)\\n    }}\\n    \\n     for(let num of nums3) {\\n        for(let num2 of nums4){\\n            if(map.has(-(num + num2))) { \\n                cnt += map.get(-(num + num2))\\n            }\\n     }}\\n    \\n    return cnt;\\n    \\n   \\n};"]}
{"id": "2143", "ref_js": ["var subStrHash = function(s, power, modulo, k, hashValue) {\\n  \\n    for(let i=0;i<s.length;i++){\\n        let subStr = s.substring(i,i+k);\\n        if(hash(subStr,power,modulo)==hashValue){\\n            return subStr;\\n        }\\n    }\\n};", "var subStrHash = function(s, power, modulo, k, hashValue) {\\n  \\n    for(let i=0;i<s.length;i++){\\n        let subStr = s.substring(i,i+k);\\n        if(hash(subStr,power,modulo)==hashValue){\\n            return subStr;\\n        }\\n    }\\n};", "var subStrHash = function(s, power, modulo, k, hashValue) {\\n  \\n    for(let i=0;i<s.length;i++){\\n        let subStr = s.substring(i,i+k);\\n        if(hash(subStr,power,modulo)==hashValue){\\n            return subStr;\\n        }\\n    }\\n};"]}
{"id": "2144", "ref_js": ["var eatenApples = function (apples, days) {\\n  let n = apples.length;\\n  let maxApplesEaten = 0;\\n\\n  let minHeap = new PriorityQueue({ compare: (a, b) => a.expiryDate - b.expiryDate });\\n\\n  ", "var eatenApples = function(apples, days) {\\n    const applesTime = Array(2 * 2 * 10 ** 4 + 1).fill(0);\\n    let result = 0;\\n    let current = Infinity;\\n    let last = apples.length;\\n\\n    for (let index = 0; index <= last; index++) {\\n        if (current < index) current = index;\\n        const count = apples[index];\\n        \\n        if (count) {\\n            const rotTime = index + days[index] - 1;\\n\\n            applesTime[rotTime] += count;\\n            current = Math.min(rotTime, current);\\n            last = Math.max(rotTime, last);\\n        }\\n        while (!applesTime[current] && current < last) current += 1;\\n        if (!applesTime[current]) continue;\\n        result += 1;\\n        applesTime[current] -= 1;\\n    }\\n    return result;\\n};", "var eatenApples = function(A, D) {\\n    let time = new Array(40001), ans = 0, last = A.length\\n    for (let i = 0, j = Infinity; i <= last; i++) {\\n        if (j < i) j = i\\n        if (A[i]) {\\n            let exp = i + D[i] - 1\\n            if (time[exp]) time[exp] += A[i]\\n            else time[exp] = A[i]\\n            if (exp < j) j = exp\\n            if (exp > last) last = exp\\n        }\\n        while (!time[j] && j < last) j++\\n        if (time[j]) ans++, time[j]--\\n    }\\n    return ans\\n};"]}
{"id": "2145", "ref_js": ["var minimumDifference = function(nums) {\\n", "var minimumDifference = function(nums) {\\n    let n = nums.length / 3;\\n    \\n    let prefixMin = [];\\n    let suffixMax = [];\\n    \\n    let min = Infinity;\\n    \\n    const maxHeap = new Heap((a,b) => {\\n        return a.val < b.val\\n    },  Infinity);\\n    \\n    const minHeap = new Heap((a,b) => {\\n        return a.val > b.val\\n    },  -Infinity);\\n    \\n    let sum = 0;\\n    for(let i = 0; i < n; i++) {\\n        let data = { val: nums[i] };", "var minimumDifference = function(nums) {\\n    let n = nums.length / 3;\\n    \\n    let prefixMin = [];\\n    let suffixMax = [];\\n    \\n    let min = Infinity;\\n    \\n    const maxHeap = new Heap((a,b) => {\\n        return a.val < b.val\\n    },  Infinity);\\n    \\n    const minHeap = new Heap((a,b) => {\\n        return a.val > b.val\\n    },  -Infinity);\\n    \\n    let sum = 0;\\n    for(let i = 0; i < n; i++) {\\n        let data = { val: nums[i] };"]}
{"id": "2146", "ref_js": ["var minimumTime = function (s) {\\n  let n = s.length;\\n  let dp = 0\\n  let res = n;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] == \"1\") dp = Math.min(i + 1, dp + 2);\\n    res = Math.min(res, dp + n - i - 1);\\n  }\\n  \\n  return res;\\n};", "var minimumTime = function (s) {\\n  let n = s.length;\\n  let dp = 0\\n  let res = n;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] == \"1\") dp = Math.min(i + 1, dp + 2);\\n    res = Math.min(res, dp + n - i - 1);\\n  }\\n  \\n  return res;\\n};", "var minimumTime = function (s) {\\n  let n = s.length;\\n  let dp = 0\\n  let res = n;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] == \"1\") dp = Math.min(i + 1, dp + 2);\\n    res = Math.min(res, dp + n - i - 1);\\n  }\\n  \\n  return res;\\n};"]}
{"id": "2147", "ref_js": ["var maximumANDSum = function(nums, numSlots) {\\n    let memo=[],mask=0;\\n    let ans =  dp(0,0);\\n    return ans;\\n    \\n    function dp(i,mask){\\n        let max = 0,sum;\\n        if(memo[mask]!==undefined){\\n            return memo[mask];\\n        }\\n        if(i===nums.length){\\n            return 0;\\n        }\\n        for(let s=1,maskBit=1;s<=numSlots;s++,maskBit*=3){\\n            if(Math.floor(mask/maskBit)%3<2){\\n                sum = (nums[i]&s)+dp(i+1,mask+maskBit);\\n                max = Math.max(sum,max);\\n            }\\n        }\\n        memo[mask]=max;\\n        return memo[mask];\\n    }\\n};", "var maximumANDSum = function(nums, numSlots) {\\n    let memo=[],mask=0;\\n    let ans =  dp(0,0);\\n    return ans;\\n    \\n    function dp(i,mask){\\n        let max = 0,sum;\\n        if(memo[mask]!==undefined){\\n            return memo[mask];\\n        }\\n        if(i===nums.length){\\n            return 0;\\n        }\\n        for(let s=1,maskBit=1;s<=numSlots;s++,maskBit*=3){\\n            if(Math.floor(mask/maskBit)%3<2){\\n                sum = (nums[i]&s)+dp(i+1,mask+maskBit);\\n                max = Math.max(sum,max);\\n            }\\n        }\\n        memo[mask]=max;\\n        return memo[mask];\\n    }\\n};", "var maximumANDSum = function(nums, numSlots) {\\n    let memo=[],mask=0;\\n    let ans =  dp(0,0);\\n    return ans;\\n    \\n    function dp(i,mask){\\n        let max = 0,sum;\\n        if(memo[mask]!==undefined){\\n            return memo[mask];\\n        }\\n        if(i===nums.length){\\n            return 0;\\n        }\\n        for(let s=1,maskBit=1;s<=numSlots;s++,maskBit*=3){\\n            if(Math.floor(mask/maskBit)%3<2){\\n                sum = (nums[i]&s)+dp(i+1,mask+maskBit);\\n                max = Math.max(sum,max);\\n            }\\n        }\\n        memo[mask]=max;\\n        return memo[mask];\\n    }\\n};"]}
{"id": "2148", "ref_js": ["var goodTriplets = function(nums1, nums2) {\\n  let n = nums1.length, nums2_idx = Array(n);\\n  for (let i = 0; i < n; i++) nums2_idx[nums2[i]] = i;\\n  let idxs = Array(n);\\n  for (let i = 0; i < n; i++) idxs[i] = nums2_idx[nums1[i]];\\n  \\n  let smallerLeft = getSmallerLeft(idxs); ", "var goodTriplets = function(nums1, nums2) {\\n  let n = nums1.length, nums2_idx = Array(n);\\n  for (let i = 0; i < n; i++) nums2_idx[nums2[i]] = i;\\n  let idxs = Array(n);\\n  for (let i = 0; i < n; i++) idxs[i] = nums2_idx[nums1[i]];\\n  \\n  let smallerLeft = getSmallerLeft(idxs); ", "var goodTriplets = function(nums1, nums2) {\\n  let n = nums1.length, nums2_idx = Array(n);\\n  for (let i = 0; i < n; i++) nums2_idx[nums2[i]] = i;\\n  let idxs = Array(n);\\n  for (let i = 0; i < n; i++) idxs[i] = nums2_idx[nums1[i]];\\n  \\n  let smallerLeft = getSmallerLeft(idxs); "]}
{"id": "2149", "ref_js": ["var countPairs = function(nums, k) {\\n\\n    let res = 0\\n    let dp = new Array(1e5+1).fill(0)\\n    let greatestCommonDenominatorArray = []\\n\\n    const greatestCommonDenominatorBt = (a,b) => !b ? a : greatestCommonDenominatorBtw(b, a % b)\\n    \\n    for(const num of nums) {\\n\\n        let greatest = greatestCommonDenominatorBt(num, k)\\n\\n        for(let datum of greatestCommonDenominatorArray) {\\n            if(greatest * datum % k === 0) res += dp[datum]\\n        }\\n\\n        if(dp[greatest] === 0) greatestCommonDenominatorArray.push(greatest)\\n        dp[greatest]++\\n    }\\n    return res\\n\\n};", "var countPairs = function(nums, k) {\\n\\n    let res = 0\\n    let dp = new Array(1e5+1).fill(0)\\n    let greatestCommonDenominatorArray = []\\n\\n    const greatestCommonDenominatorBt = (a,b) => !b ? a : greatestCommonDenominatorBtw(b, a % b)\\n    \\n    for(const num of nums) {\\n\\n        let greatest = greatestCommonDenominatorBt(num, k)\\n\\n        for(let datum of greatestCommonDenominatorArray) {\\n            if(greatest * datum % k === 0) res += dp[datum]\\n        }\\n\\n        if(dp[greatest] === 0) greatestCommonDenominatorArray.push(greatest)\\n        dp[greatest]++\\n    }\\n    return res\\n\\n};", "var countPairs = function(nums, k) {\\n\\n    let res = 0\\n    let dp = new Array(1e5+1).fill(0)\\n    let greatestCommonDenominatorArray = []\\n\\n    const greatestCommonDenominatorBt = (a,b) => !b ? a : greatestCommonDenominatorBtw(b, a % b)\\n    \\n    for(const num of nums) {\\n\\n        let greatest = greatestCommonDenominatorBt(num, k)\\n\\n        for(let datum of greatestCommonDenominatorArray) {\\n            if(greatest * datum % k === 0) res += dp[datum]\\n        }\\n\\n        if(dp[greatest] === 0) greatestCommonDenominatorArray.push(greatest)\\n        dp[greatest]++\\n    }\\n    return res\\n\\n};"]}
{"id": "2150", "ref_js": ["var minimumFinishTime = function(tires, changeTime, numLaps) {  \\n    const n = tires.length\\n    const smallestTire = Math.min(...tires.map(t => t[1]))\\n    const maxSameTire = Math.floor(Math.log(changeTime) / Math.log(smallestTire)) + 1\\n    const sameTireLast = Array(n).fill(0)\\n\\t\\n\\t", "var minimumFinishTime = function(tires, changeTime, numLaps) {\\n  const n = tires.length;\\n  const dp = Array(numLaps).fill(0);\\n  \\n  dp[0] = 1e9;\\n  for (let i = 0; i < n; i++) dp[0] = Math.min(dp[0], tires[i][0])\\n\\n  let minInc = dp[0] + changeTime;\\n  for (let i = 1; i < numLaps; i++) dp[i] = dp[i - 1] + minInc;\\n  let maxK = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    let inc = tires[i][0];\\n    let sum = inc;\\n    \\n    for (let k = 1; k < numLaps; k++) {\\n      inc *= tires[i][1];\\n      if (inc >= minInc) break;\\n\\n      sum += inc;  \\n      if (sum < dp[k]) {\\n        dp[k] = sum;\\n        maxK = Math.max(maxK, k);\\n      }\\n    }\\n  }\\n\\n  for (let i = 1; i < numLaps; i++) {\\n    for (let j = Math.max(0, i - maxK - 1); j < i; j++) {\\n      dp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1] + changeTime)\\n    }\\n  }\\n\\n  return dp[numLaps - 1];\\n};", "var minimumFinishTime = function(tires, changeTime, numLaps) {\\n  const n = tires.length;\\n  const dp = Array(numLaps).fill(0);\\n  \\n  dp[0] = 1e9;\\n  for (let i = 0; i < n; i++) dp[0] = Math.min(dp[0], tires[i][0])\\n\\n  let minInc = dp[0] + changeTime;\\n  for (let i = 1; i < numLaps; i++) dp[i] = dp[i - 1] + minInc;\\n  let maxK = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    let inc = tires[i][0];\\n    let sum = inc;\\n    \\n    for (let k = 1; k < numLaps; k++) {\\n      inc *= tires[i][1];\\n      if (inc >= minInc) break;\\n\\n      sum += inc;  \\n      if (sum < dp[k]) {\\n        dp[k] = sum;\\n        maxK = Math.max(maxK, k);\\n      }\\n    }\\n  }\\n\\n  for (let i = 1; i < numLaps; i++) {\\n    for (let j = Math.max(0, i - maxK - 1); j < i; j++) {\\n      dp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1] + changeTime)\\n    }\\n  }\\n\\n  return dp[numLaps - 1];\\n};"]}
{"id": "2151", "ref_js": ["var minMovesToMakePalindrome = function(s) {\\n    let res = 0;\\n    let a = s.split(\"\");\\n\\n    while(a.length > 1) { \\n        let i = a.indexOf(a[a.length - 1]);\\n\\n        if(i === a.length - 1) {\\n            res += Math.floor(i/2);\\n        } else {\\n            res += i;\\n            ", "var minMovesToMakePalindrome = function(s) {\\n    let res = 0;\\n    let a = s.split(\"\");\\n\\n    while(a.length > 1) { \\n        let i = a.indexOf(a[a.length - 1]);\\n\\n        if(i === a.length - 1) {\\n            res += Math.floor(i/2);\\n        } else {\\n            res += i;\\n            ", "var minMovesToMakePalindrome = function(s) {\\n    let res = 0;\\n    let a = s.split(\"\");\\n\\n    while(a.length > 1) { \\n        let i = a.indexOf(a[a.length - 1]);\\n\\n        if(i === a.length - 1) {\\n            res += Math.floor(i/2);\\n        } else {\\n            res += i;\\n            "]}
{"id": "2152", "ref_js": ["var replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};", "var replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};", "var replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};"]}
{"id": "2153", "ref_js": ["var minimumWeight = function (n, edges, src1, src2, dest) {\\n    var paths = new Array(n).fill(0).map(i => []);\\n    var reversePaths = new Array(n).fill(0).map(i => []);\\n    for (var edge of edges) {\\n        var [u, v, w] = edge;\\n        paths[u].push([v, w]);\\n        reversePaths[v].push([u, w]);\\n    }\\n\\n    var dijkstra = function (start, paths) {\\n        var visited = [];\\n        var dp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        dp[start] = 0;\\n        \\n        var pq = new MinPriorityQueue({priority: item => item[1]});\\n        pq.enqueue([start, 0]);\\n        \\n        while(!pq.isEmpty()) {\\n            var [u, cost] = pq.dequeue().element;\\n            if (visited[u] || cost > dp[u]) continue;\\n            visited[u] = true;\\n            for (var path of paths[u]) {\\n                var [v, w] = path;\\n                if (dp[v] > dp[u] + w) {\\n                    dp[v] =  dp[u] + w;\\n                    pq.enqueue([v, dp[v]]);\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n\\n    var dpStartFromSrc1 = dijkstra(src1, paths);\\n    var dpStartFromSrc2 = dijkstra(src2, paths);\\n    var dpStartFromDesc = dijkstra(dest, reversePaths);\\n\\n    var ans = Number.MAX_SAFE_INTEGER;\\n    for (var i = 0; i < n; i++) {\\n        ans = Math.min(ans, dpStartFromSrc1[i] + dpStartFromSrc2[i] + dpStartFromDesc[i]);\\n    }\\n\\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans;\\n};", "var minimumWeight = function (n, edges, src1, src2, dest) {\\n    var paths = new Array(n).fill(0).map(i => []);\\n    var reversePaths = new Array(n).fill(0).map(i => []);\\n    for (var edge of edges) {\\n        var [u, v, w] = edge;\\n        paths[u].push([v, w]);\\n        reversePaths[v].push([u, w]);\\n    }\\n\\n    var dijkstra = function (start, paths) {\\n        var visited = [];\\n        var dp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        dp[start] = 0;\\n        \\n        var pq = new MinPriorityQueue({priority: item => item[1]});\\n        pq.enqueue([start, 0]);\\n        \\n        while(!pq.isEmpty()) {\\n            var [u, cost] = pq.dequeue().element;\\n            if (visited[u] || cost > dp[u]) continue;\\n            visited[u] = true;\\n            for (var path of paths[u]) {\\n                var [v, w] = path;\\n                if (dp[v] > dp[u] + w) {\\n                    dp[v] =  dp[u] + w;\\n                    pq.enqueue([v, dp[v]]);\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n\\n    var dpStartFromSrc1 = dijkstra(src1, paths);\\n    var dpStartFromSrc2 = dijkstra(src2, paths);\\n    var dpStartFromDesc = dijkstra(dest, reversePaths);\\n\\n    var ans = Number.MAX_SAFE_INTEGER;\\n    for (var i = 0; i < n; i++) {\\n        ans = Math.min(ans, dpStartFromSrc1[i] + dpStartFromSrc2[i] + dpStartFromDesc[i]);\\n    }\\n\\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans;\\n};", "var minimumWeight = function (n, edges, src1, src2, dest) {\\n    var paths = new Array(n).fill(0).map(i => []);\\n    var reversePaths = new Array(n).fill(0).map(i => []);\\n    for (var edge of edges) {\\n        var [u, v, w] = edge;\\n        paths[u].push([v, w]);\\n        reversePaths[v].push([u, w]);\\n    }\\n\\n    var dijkstra = function (start, paths) {\\n        var visited = [];\\n        var dp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        dp[start] = 0;\\n        \\n        var pq = new MinPriorityQueue({priority: item => item[1]});\\n        pq.enqueue([start, 0]);\\n        \\n        while(!pq.isEmpty()) {\\n            var [u, cost] = pq.dequeue().element;\\n            if (visited[u] || cost > dp[u]) continue;\\n            visited[u] = true;\\n            for (var path of paths[u]) {\\n                var [v, w] = path;\\n                if (dp[v] > dp[u] + w) {\\n                    dp[v] =  dp[u] + w;\\n                    pq.enqueue([v, dp[v]]);\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n\\n    var dpStartFromSrc1 = dijkstra(src1, paths);\\n    var dpStartFromSrc2 = dijkstra(src2, paths);\\n    var dpStartFromDesc = dijkstra(dest, reversePaths);\\n\\n    var ans = Number.MAX_SAFE_INTEGER;\\n    for (var i = 0; i < n; i++) {\\n        ans = Math.min(ans, dpStartFromSrc1[i] + dpStartFromSrc2[i] + dpStartFromDesc[i]);\\n    }\\n\\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans;\\n};"]}
{"id": "2154", "ref_js": ["var minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};", "var minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};", "var minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n\\t"]}
{"id": "2155", "ref_js": ["var Node = function (leftChar, leftLen, rightChar, rightLen, maxLen, left, right, len, l, r) {\\n    this.leftChar = leftChar;\\n    this.leftLen = leftLen;\\n    this.rightChar = rightChar;\\n    this.rightLen = rightLen;\\n    this.maxLen = maxLen;\\n    this.left = left;\\n    this.right = right;\\n    this.len = len;\\n    this.l = l;\\n    this.r = r;\\n}\\n\\nvar build = function (s, l, r) {\\n    if (l > r) return null;\\n    if (l === r) return new Node(s[l], 1, s[r], 1, 1, null, null, 1, l, r);\\n    var mid = Math.floor((r + l) / 2);\\n    var root = new Node();\\n    var left = build(s, l, mid, root);\\n    var right = build(s, mid + 1, r, root);\\n\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    root.left = left;\\n    root.right = right;\\n    root.len = r - l + 1;\\n    root.l = l;\\n    root.r = r;\\n\\n    return root;\\n}\\n\\nvar update = function (root, idx, char) {\\n    if (!root) return 0;\\n    if (root.len === 1) {\\n        root.leftChar = root.rightChar = char;\\n        return 1;\\n    }\\n    var mid = Math.floor((root.r + root.l) / 2);\\n    if (idx <= mid) update(root.left, idx, char);\\n    else update(root.right, idx, char);\\n\\n    var left = root.left;\\n    var right = root.right;\\n\\n\\t", "var Node = function (leftChar, leftLen, rightChar, rightLen, maxLen, left, right, len, l, r) {\\n    this.leftChar = leftChar;\\n    this.leftLen = leftLen;\\n    this.rightChar = rightChar;\\n    this.rightLen = rightLen;\\n    this.maxLen = maxLen;\\n    this.left = left;\\n    this.right = right;\\n    this.len = len;\\n    this.l = l;\\n    this.r = r;\\n}\\n\\nvar build = function (s, l, r) {\\n    if (l > r) return null;\\n    if (l === r) return new Node(s[l], 1, s[r], 1, 1, null, null, 1, l, r);\\n    var mid = Math.floor((r + l) / 2);\\n    var root = new Node();\\n    var left = build(s, l, mid, root);\\n    var right = build(s, mid + 1, r, root);\\n\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    root.left = left;\\n    root.right = right;\\n    root.len = r - l + 1;\\n    root.l = l;\\n    root.r = r;\\n\\n    return root;\\n}\\n\\nvar update = function (root, idx, char) {\\n    if (!root) return 0;\\n    if (root.len === 1) {\\n        root.leftChar = root.rightChar = char;\\n        return 1;\\n    }\\n    var mid = Math.floor((root.r + root.l) / 2);\\n    if (idx <= mid) update(root.left, idx, char);\\n    else update(root.right, idx, char);\\n\\n    var left = root.left;\\n    var right = root.right;\\n\\n\\t", "var Node = function (leftChar, leftLen, rightChar, rightLen, maxLen, left, right, len, l, r) {\\n    this.leftChar = leftChar;\\n    this.leftLen = leftLen;\\n    this.rightChar = rightChar;\\n    this.rightLen = rightLen;\\n    this.maxLen = maxLen;\\n    this.left = left;\\n    this.right = right;\\n    this.len = len;\\n    this.l = l;\\n    this.r = r;\\n}\\n\\nvar build = function (s, l, r) {\\n    if (l > r) return null;\\n    if (l === r) return new Node(s[l], 1, s[r], 1, 1, null, null, 1, l, r);\\n    var mid = Math.floor((r + l) / 2);\\n    var root = new Node();\\n    var left = build(s, l, mid, root);\\n    var right = build(s, mid + 1, r, root);\\n\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    root.left = left;\\n    root.right = right;\\n    root.len = r - l + 1;\\n    root.l = l;\\n    root.r = r;\\n\\n    return root;\\n}\\n\\nvar update = function (root, idx, char) {\\n    if (!root) return 0;\\n    if (root.len === 1) {\\n        root.leftChar = root.rightChar = char;\\n        return 1;\\n    }\\n    var mid = Math.floor((root.r + root.l) / 2);\\n    if (idx <= mid) update(root.left, idx, char);\\n    else update(root.right, idx, char);\\n\\n    var left = root.left;\\n    var right = root.right;\\n\\n\\t"]}
{"id": "2156", "ref_js": ["var maxValueOfCoins = function(piles, k) {\\n    ", "var maxValueOfCoins = function(piles, k) {\\n    let prev = new Array(k + 1).fill(0);\\n\\n    for (let pile of piles) {\\n        let sumList = [0];\\n        let total = 0;\\n        for (let coin of pile) {\\n            total += coin;\\n            sumList.push(total);\\n        }\\n\\n        let curMax = new Array(k + 1).fill(0);\\n\\n        for (let n = 1; n <= k; n++) {\\n            let calcRange = Math.min(n + 1, sumList.length);\\n            for (let pos = 0; pos < calcRange; pos++) {\\n                curMax[n] = Math.max(curMax[n], sumList[pos] + prev[n - pos]);\\n            }\\n        }\\n\\n        prev = curMax;\\n    }\\n\\n    return prev[k];\\n};", "var maxValueOfCoins = function(piles, k) {\\n    "]}
{"id": "2157", "ref_js": ["var sumScores = function(s) {\\n  let n = s.length;\\n  let res = n;\\n\\n  let l = 0;\\n  let r = 1;\\n  let c = 0;\\n\\n  for (let i = 1; i < n; i++) {\\n    if (i < r) c = Math.min(z[i - l], r - i);\\n    else c = 0;\\n\\n    while (s[c] == s[i + c]) c++;\\n    z[i] = c;\\n    res += c;\\n\\n    if (i + c > r) {\\n      l = i;\\n      r = i + c;\\n    }\\n  }\\n\\n  return res;\\n};", "var sumScores = function(s) {\\n  let n = s.length;\\n  let res = n;\\n\\n  let l = 0;\\n  let r = 1;\\n  let c = 0;\\n\\n  for (let i = 1; i < n; i++) {\\n    if (i < r) c = Math.min(z[i - l], r - i);\\n    else c = 0;\\n\\n    while (s[c] == s[i + c]) c++;\\n    z[i] = c;\\n    res += c;\\n\\n    if (i + c > r) {\\n      l = i;\\n      r = i + c;\\n    }\\n  }\\n\\n  return res;\\n};", "var sumScores = function(s) {\\n  let n = s.length;\\n  let res = n;\\n\\n  let l = 0;\\n  let r = 1;\\n  let c = 0;\\n\\n  for (let i = 1; i < n; i++) {\\n    if (i < r) c = Math.min(z[i - l], r - i);\\n    else c = 0;\\n\\n    while (s[c] == s[i + c]) c++;\\n    z[i] = c;\\n    res += c;\\n\\n    if (i + c > r) {\\n      l = i;\\n      r = i + c;\\n    }\\n  }\\n\\n  return res;\\n};"]}
{"id": "2159", "ref_js": ["var findDifference = function(nums1, nums2) {\\n        let set1 = new Set(nums1);\\n        let set2 = new Set(nums2);\\n\\n        let diff1 = [...set1].filter(x => !set2.has(x));\\n        let diff2 = [...set2].filter(x => !set1.has(x));\\n\\n        return [diff1, diff2];\\n};", "var findDifference = function(nums1, nums2) {\\n    \\n    nums1 = new Set(nums1)\\n    nums2 = new Set(nums2)\\n\\n    for (let item of nums1){\\n        if (nums2.has(item)) {\\n            nums1.delete(item)\\n            nums2.delete(item)\\n        }\\n    }\\n    return [Array.from(nums1),Array.from(nums2)]\\n   \\n};", "var findDifference = function(nums1, nums2) {\\n        let set1 = new Set(nums1);\\n        let set2 = new Set(nums2);\\n\\n        let diff1 = [...set1].filter(x => !set2.has(x));\\n        let diff2 = [...set2].filter(x => !set1.has(x));\\n\\n        return [diff1, diff2];\\n};"]}
{"id": "2160", "ref_js": ["var maximumScore = function (scores, edges) {\\n  const n = scores.length;\\n  scores.push(0);\\n\\n  \\n  const bestNeighbors = [];\\n  for (let i = 0; i < n; i++) bestNeighbors.push([n, n, n]);\\n\\n  function addNeighbor(target, newNeighbor) {\\n    const tarNeis = bestNeighbors[target];\\n\\n    if (scores[newNeighbor] > scores[tarNeis[0]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = tarNeis[0];\\n      tarNeis[0] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[1]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[2]]) {\\n      tarNeis[2] = newNeighbor;\\n    }\\n  }\\n  for (let [u, v] of edges) {\\n    addNeighbor(u, v);\\n    addNeighbor(v, u);\\n  }\\n\\n  let result = -1;\\n  for (let [b, c] of edges) {\\n    for (let a of bestNeighbors[b]) {\\n      if (a === c || a === n) continue;\\n\\n      for (let d of bestNeighbors[c]) {\\n        if (d === b || d === a || d === n) continue;\\n        result = Math.max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};", "var maximumScore = function (scores, edges) {\\n  const n = scores.length;\\n  scores.push(0);\\n\\n  \\n  const bestNeighbors = [];\\n  for (let i = 0; i < n; i++) bestNeighbors.push([n, n, n]);\\n\\n  function addNeighbor(target, newNeighbor) {\\n    const tarNeis = bestNeighbors[target];\\n\\n    if (scores[newNeighbor] > scores[tarNeis[0]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = tarNeis[0];\\n      tarNeis[0] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[1]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[2]]) {\\n      tarNeis[2] = newNeighbor;\\n    }\\n  }\\n  for (let [u, v] of edges) {\\n    addNeighbor(u, v);\\n    addNeighbor(v, u);\\n  }\\n\\n  let result = -1;\\n  for (let [b, c] of edges) {\\n    for (let a of bestNeighbors[b]) {\\n      if (a === c || a === n) continue;\\n\\n      for (let d of bestNeighbors[c]) {\\n        if (d === b || d === a || d === n) continue;\\n        result = Math.max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};", "var maximumScore = function (scores, edges) {\\n  const n = scores.length;\\n  scores.push(0);\\n\\n  \\n  const bestNeighbors = [];\\n  for (let i = 0; i < n; i++) bestNeighbors.push([n, n, n]);\\n\\n  function addNeighbor(target, newNeighbor) {\\n    const tarNeis = bestNeighbors[target];\\n\\n    if (scores[newNeighbor] > scores[tarNeis[0]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = tarNeis[0];\\n      tarNeis[0] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[1]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[2]]) {\\n      tarNeis[2] = newNeighbor;\\n    }\\n  }\\n  for (let [u, v] of edges) {\\n    addNeighbor(u, v);\\n    addNeighbor(v, u);\\n  }\\n\\n  let result = -1;\\n  for (let [b, c] of edges) {\\n    for (let a of bestNeighbors[b]) {\\n      if (a === c || a === n) continue;\\n\\n      for (let d of bestNeighbors[c]) {\\n        if (d === b || d === a || d === n) continue;\\n        result = Math.max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};"]}
{"id": "2161", "ref_js": ["var longestPath = function(parent, s) {\\n    let n = parent.length\\n\\n    let children = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        children[i] = new Array()\\n    }\\n    for (let i = 1; i < n; i++) {\\n        children[parent[i]].push(i)\\n    }\\n\\n    s = s.split(\"\")\\n    let longestPath = 0\\n    let dfs = function(node) {\\n        let longestLength = 0, longestLength2 = 0\\n        for (let child of children[node]) {\\n            let lengthChild = dfs(child)\\n            if (s[node] == s[child]) continue\\n            if (longestLength < lengthChild) {\\n                longestLength2 = longestLength\\n                longestLength = lengthChild\\n            }\\n            else if (longestLength2 < lengthChild) {\\n                longestLength2 = lengthChild\\n            }\\n        }\\n        longestPath = Math.max(longestPath, longestLength + longestLength2 + 1)\\n        return longestLength + 1\\n    }\\n    dfs(0)\\n    return longestPath\\n};", "var longestPath = function(parent, s) {\\n    let longestPath = 1; ", "var longestPath = function(parent, s) {\\n    let n = parent.length\\n\\n    let children = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        children[i] = new Array()\\n    }\\n    for (let i = 1; i < n; i++) {\\n        children[parent[i]].push(i)\\n    }\\n\\n    s = s.split(\"\")\\n    let longestPath = 0\\n    let dfs = function(node) {\\n        let longestLength = 0, longestLength2 = 0\\n        for (let child of children[node]) {\\n            let lengthChild = dfs(child)\\n            if (s[node] == s[child]) continue\\n            if (longestLength < lengthChild) {\\n                longestLength2 = longestLength\\n                longestLength = lengthChild\\n            }\\n            else if (longestLength2 < lengthChild) {\\n                longestLength2 = lengthChild\\n            }\\n        }\\n        longestPath = Math.max(longestPath, longestLength + longestLength2 + 1)\\n        return longestLength + 1\\n    }\\n    dfs(0)\\n    return longestPath\\n};"]}
{"id": "2162", "ref_js": ["var fullBloomFlowers = function(flowers, people) {\\n    const flower_count = new Map();\\n\\n    for (const [start, end] of flowers) {\\n        flower_count.set(start, (flower_count.get(start) || 0) + 1);\\n        flower_count.set(end + 1, (flower_count.get(end + 1) || 0) - 1);\\n    }\\n\\n    const days = Array.from(flower_count.keys()).sort((a, b) => a - b);\\n\\n    let total_flowers = 0;\\n    for (const day of days) {\\n        total_flowers += flower_count.get(day) || 0; ", "var fullBloomFlowers = function(flowers, people) {\\n    let starts = Array(flowers.length)\\n    let ends = Array(flowers.length)\\n    for (let i=0;i<flowers.length;i++){\\n        starts[i] = flowers[i][0]\\n        ends[i] = flowers[i][1]\\n    }\\n    starts.sort((a,b) => a-b)\\n    ends.sort((a,b) => a-b)\\n    let memo = new Map()\\n    let answer =  Array(people.length)\\n\\n    for (let i=0;i<people.length;i++){\\n        let item = people[i]\\n        let left\\n        let right\\n        if (memo.has(item)){\\n            left = memo.get(item)[0]\\n            right = memo.get(item)[1]\\n        }else{\\n            left = bisect_right(starts,item)\\n            right = bisect_left(ends,item)\\n            memo.set(item,[left,right])\\n        }\\n        answer[i] = left-right\\n    }\\n    \\n    return answer\\n};", "var fullBloomFlowers = function(flowers, people) {\\n    const flower_count = new Map();\\n\\n    for (const [start, end] of flowers) {\\n        flower_count.set(start, (flower_count.get(start) || 0) + 1);\\n        flower_count.set(end + 1, (flower_count.get(end + 1) || 0) - 1);\\n    }\\n\\n    const days = Array.from(flower_count.keys()).sort((a, b) => a - b);\\n\\n    let total_flowers = 0;\\n    for (const day of days) {\\n        total_flowers += flower_count.get(day) || 0; "]}
{"id": "2163", "ref_js": ["var maximumMinutes = function(grid) {\\n    let lastGrassAffectedByFireMin = spreadFireBfs(grid);\\n    markUnreachedCells(grid);\\n    let maxMin = Math.min(lastGrassAffectedByFireMin, getLastMin(grid, 0, 0))\\n\\n    if(grid[0][0] === marker && findPath(grid, 1000000000) !== -1){\\n        return 1000000000;\\n    }\\n    let res = -1\\n    let start = 0;\\n    let end = maxMin;\\n    let mid = -1\\n    while(start <= end){\\n        mid = Math.floor((start + end) / 2);\\n        res = findPath(grid, mid);\\n        if(res == -1){\\n            end = mid -1\\n        } else {\\n            start = mid + 1\\n        }\\n    }\\n    if(res == -1){\\n        if(mid == -1){\\n            return -1\\n        }\\n        return mid -1;\\n    }\\n    return mid;\\n};", "var maximumMinutes = function(grid) {\\n  let fireSpread = getFireSpreadTime(grid);\\n  let low = 0, high = 10 ** 9;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canReachSafehouse(grid, fireSpread, mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return canReachSafehouse(grid, fireSpread, low) ? low : -1;\\n};", "var maximumMinutes = function (grid) {\\n    this.GRASS = 0;\\n    this.FIRE = 1;\\n    this.WALL = 2;\\n    this.MAX_TIME = 2 * Math.pow(10, 4);\\n    this.CAN_WAIT_UNLIMITED_TIME = Math.pow(10, 9);\\n    this.NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    this.MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    this.initialFirePoints = [];\\n    this.currentGrid = [];\\n    this.personLatestSteps = [];\\n    this.ID_personLatestSteps = 0;\\n    this.blockedPointsOnPersonLatestSteps = 0;\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n\\n    recordInitialFirePoints(grid);\\n    return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n};"]}
{"id": "2164", "ref_js": ["var appealSum = function(s) {\\n  let ans = 0, n = s.length;\\n  let lastIndex = Array(26).fill(-1);\\n  for (let i = 0; i < n; i++) {\\n    let charcode = s.charCodeAt(i) - 97;\\n    let lastIdx = lastIndex[charcode];\\n    ans += (n - i) * (i - lastIdx);\\n    lastIndex[charcode] = i;\\n  }  \\n  return ans;\\n};", "var appealSum = function(s) {\\n  let ans = 0, n = s.length;\\n  let lastIndex = Array(26).fill(-1);\\n  for (let i = 0; i < n; i++) {\\n    let charcode = s.charCodeAt(i) - 97;\\n    let lastIdx = lastIndex[charcode];\\n    ans += (n - i) * (i - lastIdx);\\n    lastIndex[charcode] = i;\\n  }  \\n  return ans;\\n};", "var appealSum = function(s) {\\n  let ans = 0, n = s.length;\\n  let lastIndex = Array(26).fill(-1);\\n  for (let i = 0; i < n; i++) {\\n    let charcode = s.charCodeAt(i) - 97;\\n    let lastIdx = lastIndex[charcode];\\n    ans += (n - i) * (i - lastIdx);\\n    lastIndex[charcode] = i;\\n  }  \\n  return ans;\\n};"]}
{"id": "2165", "ref_js": ["var hasValidPath = function(grid) {\\n    const mem = new Set();\\n    m = grid.length;\\n    n = grid[0].length;\\n    if(grid[0][0] == \\')\\') return false;\\n    return dfs(0, 0, grid, mem, 0);\\n};", "var hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};", "var hasValidPath = function(grid) {\\n    const mem = new Set();\\n    m = grid.length;\\n    n = grid[0].length;\\n    if(grid[0][0] == \\')\\') return false;\\n    return dfs(0, 0, grid, mem, 0);\\n};"]}
{"id": "2166", "ref_js": ["var largestVariance = function(s) {\\n    let l = s.length, codes = new Array(l), aCode = \\'a\\'.charCodeAt(0), result = 0, counter = new Array(26).fill(0);\\n    for (let i = 0; i < l; i++) {\\n        codes[i] = s.charCodeAt(i) - aCode;\\n        counter[codes[i]]++;\\n    }\\n    for (let i = 0; i < 26; i++) {", "var largestVariance = function(s) {\\n  let chars = new Set(s.split(\"\")), maxDiff = 0;\\n  for (let l of chars) {\\n    for (let r of chars) {\\n      if (l === r) continue;\\n      let lCount = 0, rCount = 0, hasRight = false;\\n      for (let char of s) {\\n        lCount += char === l ? 1 : 0;\\n        rCount += char === r ? 1 : 0;\\n        if (rCount > 0 && lCount > rCount) { ", "var largestVariance = function(s) {\\n  let chars = new Set(s.split(\"\")), maxDiff = 0;\\n  for (let l of chars) {\\n    for (let r of chars) {\\n      if (l === r) continue;\\n      let lCount = 0, rCount = 0, hasRight = false;\\n      for (let char of s) {\\n        lCount += char === l ? 1 : 0;\\n        rCount += char === r ? 1 : 0;\\n        if (rCount > 0 && lCount > rCount) { "]}
{"id": "2168", "ref_js": ["var totalStrength = function(strength) {\\n    \\n    let groupSize=1,leng=strength.length,sum=0;\\n    \\n    for(let i=0,j=0;i<leng;j++)\\n        {\\n            let temp=j+groupSize;\\n            sum+=minValue(strength.slice(j,temp))*sumValue(strength.slice(j,temp));\\n\\n               if(temp>=leng)\\n                {\\n                    groupSize+=1;\\n                    i+=1;\\n                    j=-1;\\n                }\\n        }\\n    \\n    return sum;\\n    \\n};", "var totalStrength = function(strength) {\\n    const segTree = new SegTree(strength);\\n    let l = 0, rInit = 1, r = rInit;\\n    const lastIdx = strength.length - 1;\\n    let result = segTree.getSum();\\n\\n    while (r - l < strength.length) {\\n        const query = segTree.query(l, r);\\n        result += query[0] * query[1];\\n        l++;\\n        r++;\\n        if (r > lastIdx) {\\n            l = 0;\\n            rInit++;\\n            r = rInit;\\n            curMin = Infinity;\\n        }\\n    }\\n\\n    return result % modulus;\\n};", "var totalStrength = function(strength) {\\n    const segTree = new SegTree(strength);\\n    let l = 0, rInit = 1, r = rInit;\\n    const lastIdx = strength.length - 1;\\n    let result = segTree.getSum();\\n\\n    while (r - l < strength.length) {\\n        const query = segTree.query(l, r);\\n        result += query[0] * query[1];\\n        l++;\\n        r++;\\n        if (r > lastIdx) {\\n            l = 0;\\n            rInit++;\\n            r = rInit;\\n            curMin = Infinity;\\n        }\\n    }\\n\\n    return result % modulus;\\n};"]}
{"id": "2170", "ref_js": ["var minimumObstacles = function (matrix) {\\n    this.moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.rows = matrix.length;\\n    this.columns = matrix[0].length;\\n    return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n};", "var minimumObstacles = function(grid) {\\n    let dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n    let distance=[];\\n    for(let i=0;i<grid.length;i++){\\n        distance[i]=[];\\n        for(let j=0;j<grid[i].length;j++){\\n            distance[i][j]=Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    return bfs(0,0);\\n    \\n    function bfs(row,col){\\n        let queue=[];\\n        distance[row][col]=0;\\n        queue.push([row,col]);\\n        while(queue.length>0){\\n            let element = queue.shift();\\n            let row = element[0];\\n            let col = element[1];\\n            let originalDist = distance[row][col];\\n            for(let d=0;d<dx.length;d++){\\n                let i = row + dx[d][0];\\n                let j = col + dx[d][1];\\n                if(i>=0 && i<=grid.length-1 && j>=0 && j<=grid[i].length-1){\\n                    let dist = originalDist;\\n                    if(grid[i][j]===1){\\n                        dist++;\\n                    }\\n                    if(distance[i][j]>dist){", "var minimumObstacles = function (matrix) {\\n    this.moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.rows = matrix.length;\\n    this.columns = matrix[0].length;\\n    return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n};"]}
{"id": "2172", "ref_js": ["var matchReplacement = function(s, sub, mappings) {\\n    let n= s.length;\\n    let m = sub.length;\\n    let map = new Array(36).fill().map(_=>new Array(36).fill(0));\\n    for(let i=0;i<mappings.length;i++) {\\n        let [o,ne] = mappings[i];\\n        if(isNaN(o)) {\\n            o = (o.toUpperCase()).charCodeAt(0)-55;\\n        } else {\\n            o = parseInt(o);\\n        }\\n        \\n        if(isNaN(ne)) {\\n            ne = (ne.toUpperCase()).charCodeAt(0)-55;\\n        } else {\\n            ne = parseInt(ne);\\n        }\\n        map[o][ne]=1;\\n    }\\n    ", "var matchReplacement = function(s, sub, mappings) {\\n    let duy={};", "var matchReplacement = function(s, sub, mappings) {\\n    let duy={};"]}
{"id": "2173", "ref_js": ["var countSubarrays = function(nums, k) {\\n    let sum = 0;\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n    const isValid = () => {\\n        return sum * (right - left) < k;\\n    }\\n    \\n    while (right < nums.length) {\\n        while (right < nums.length && isValid()) {\\n            sum += nums[right];\\n            res += right - left;\\n            right++;\\n        }\\n        \\n        while (left < right && !isValid()) {\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    res += right - left;\\n    \\n    return res;\\n};", "var countSubarrays = function(nums, k) \\n{\\n    let count=0;\\n    let j=0;\\n    let sum=0;\\n    for(let i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n        while(sum*(i-j+1)>=k){\\n            sum-=nums[j++];\\n        }\\n        count+=(i-j+1);\\n    }\\n    return count;\\n};", "var countSubarrays = function(nums, k) {\\n  let curentRunningSum = 0, result = 0, windowEnd = 0, windowStart = 0;\\n  while (windowEnd < nums.length) {\\n    curentRunningSum += nums[windowEnd];\\n    while (curentRunningSum * (windowEnd - windowStart + 1) >= k)  curentRunningSum -= nums[windowStart++];\\n    result += windowEnd - windowStart + 1;\\n    windowEnd++;\\n  }\\n  return result; \\n};"]}
{"id": "2174", "ref_js": ["var distinctNames = function(ideas) {\\n    let sets = [];\\n    for (let i = 0; i < 26; i++) {\\n        sets[i] = new Set();\\n    }\\n    for (let s of ideas) {\\n        sets[s.charCodeAt(0) - 97].add(s.substring(1));\\n    }\\n    let same = [];\\n    for (let i = 0; i < 26; i++) {\\n        same[i] = Array(26).fill(0);\\n    }\\n    for (let i = 0; i < 26; i++) {\\n        for (let s of sets[i]) {\\n            for (let j = i + 1; j < 26; j++) {\\n                if (sets[j].has(s)) {\\n                    same[i][j]++;\\n                }\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < 26; i++) {\\n        for (let j = i + 1; j < 26; j++) {\\n            res += (sets[i].size - same[i][j]) * (sets[j].size - same[i][j]) * 2;\\n        }\\n    }\\n    return res;\\n\\n};", "var distinctNames = function(ideas) {\\n      const suf = Array.from({length: 26}, () => new Set());\\n\\n  for (const A of ideas)\\n    suf[A.charCodeAt(0)-97].add(A.slice(1))\\n\\n  let pairs = 0;\\n\\n  for (let i = 0; i < 25; i++) {\\n    for (let j = i+1; j < 26; j++) {\\n      let mutual = 0;\\n      for (const B of suf[i])\\n        if (suf[j].has(B))\\n          mutual++\\n\\n      pairs += (suf[i].size - mutual) * (suf[j].size - mutual)\\n    }\\n  }\\n      \\n  return pairs * 2\\n};", "var distinctNames = function(ideas) {\\n    let sets = [];\\n    for (let i = 0; i < 26; i++) {\\n        sets[i] = new Set();\\n    }\\n    for (let s of ideas) {\\n        sets[s.charCodeAt(0) - 97].add(s.substring(1));\\n    }\\n    let same = [];\\n    for (let i = 0; i < 26; i++) {\\n        same[i] = Array(26).fill(0);\\n    }\\n    for (let i = 0; i < 26; i++) {\\n        for (let s of sets[i]) {\\n            for (let j = i + 1; j < 26; j++) {\\n                if (sets[j].has(s)) {\\n                    same[i][j]++;\\n                }\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < 26; i++) {\\n        for (let j = i + 1; j < 26; j++) {\\n            res += (sets[i].size - same[i][j]) * (sets[j].size - same[i][j]) * 2;\\n        }\\n    }\\n    return res;\\n\\n};"]}
{"id": "2175", "ref_js": ["var sellingWood = function(m, n, prices) {\\n  let price = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));\\n  for (let [height, width, woodPrice] of prices) {\\n    price[width][height] = woodPrice;\\n  }\\n  let memo = Array(n + 1).fill(0).map(() => Array(m + 1).fill(-1));\\n  return dfs(n, m);\\n\\n  function dfs(width, height) {\\n    if (width === 0 || height === 0) return 0;\\n    if (memo[width][height] !== -1) return memo[width][height];\\n\\n    let ans = price[width][height];\\n    for (let h = 1; h <= Math.floor(height / 2); h++) {\\n      ans = Math.max(ans, dfs(width, h) + dfs(width, height - h));\\n    }\\n    for (let w = 1; w <= Math.floor(width / 2); w++) {\\n      ans = Math.max(ans, dfs(w, height) + dfs(width - w, height));\\n    }\\n    return memo[width][height] = ans;\\n  }\\n};", "var sellingWood = function(m, n, prices) {\\n    let prObj = {}\\n    let checked = {}\\n    \\n    for (let i = 0; i < prices.length; i++){\\n        prObj[\"\" + prices[i][0] + \"/\" + prices[i][1]] = prices[i][2]\\n    }\\n\\n    return iter(m,n)\\n\\n    function iter(row, col){\\n        if (checked[\"\" + row + \"/\" + col] !== undefined) return checked[\"\" + row + \"/\" + col]\\n        let p = 0 ", "var sellingWood = function(m, n, prices) {\\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))\\n    \\n    for (let [h, w, p] of prices) dp[h][w] = p\\n    \\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            for (let r = 0; r <= row; r++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[r][col] + dp[row - r][col])\\n            }\\n            for (let c = 0; c <= col; c++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[row][c] + dp[row][col - c])\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n]\\n};"]}
{"id": "2176", "ref_js": ["var distinctSequences = function(n) {\\n    if (n == 1) return 6;\\n\\n    let prevState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n    const mod = 1000000007;\\n\\n    for (let i = 1; i <= 6; i++)\\n        prevState[i][i] = 1;\\n\\n    while (--n > 0) {\\n        const curState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n\\n        for (let i = 1; i <= 6; i++)\\n            for (const coPrime of coPrimes[i])\\n                curState[i][coPrime] = prevState[coPrime].reduce((acc, count, prevOfPrev) =>\\n                    (acc + (prevOfPrev != i ? count : 0)) % mod, 0);\\n        \\n        prevState = curState;\\n    }\\n\\n    return prevState.reduce((acc, prev) => \\n        (acc + prev.reduce((acc, count) => acc + count)) % mod, 0);\\n};", "var distinctSequences = function(n) {\\n    ", "var distinctSequences = function(n) {\\n    if (n == 1) return 6;\\n\\n    let prevState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n    const mod = 1000000007;\\n\\n    for (let i = 1; i <= 6; i++)\\n        prevState[i][i] = 1;\\n\\n    while (--n > 0) {\\n        const curState = Array.from({ length: 7 }, () => Array(7).fill(0));\\n\\n        for (let i = 1; i <= 6; i++)\\n            for (const coPrime of coPrimes[i])\\n                curState[i][coPrime] = prevState[coPrime].reduce((acc, count, prevOfPrev) =>\\n                    (acc + (prevOfPrev != i ? count : 0)) % mod, 0);\\n        \\n        prevState = curState;\\n    }\\n\\n    return prevState.reduce((acc, prev) => \\n        (acc + prev.reduce((acc, count) => acc + count)) % mod, 0);\\n};"]}
{"id": "2177", "ref_js": ["var maximumsSplicedArray = function(nums1, nums2) {\\n\\tconst sumNums1 = nums1.reduce((acc, currentElement) => currentElement + acc);\\n\\tconst sumNums2 = nums2.reduce((acc, currentElement) => currentElement + acc);\\n\\tlet maxSum = 0;\\n\\tlet tempStoreNums1 = 0;\\n\\tlet tempStoreNums2 = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums2 - tempStoreNums1;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\n\\tconst maxSumOne = sumNums1 + maxSum;\\n\\n\\ttempStoreNums1 = 0;\\n\\ttempStoreNums2 = 0;\\n\\tmaxSum = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums1 - tempStoreNums2;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\tconst maxSumTwo = sumNums2 + maxSum;\\n\\treturn Math.max(maxSumTwo, maxSumOne);\\n};", "var maximumsSplicedArray = function(nums1, nums2) {\\n    let res = 0;\\n    let len = nums1.length;\\n\\t", "var maximumsSplicedArray = function(nums1, nums2) {\\n\\tconst sumNums1 = nums1.reduce((acc, currentElement) => currentElement + acc);\\n\\tconst sumNums2 = nums2.reduce((acc, currentElement) => currentElement + acc);\\n\\tlet maxSum = 0;\\n\\tlet tempStoreNums1 = 0;\\n\\tlet tempStoreNums2 = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums2 - tempStoreNums1;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\n\\tconst maxSumOne = sumNums1 + maxSum;\\n\\n\\ttempStoreNums1 = 0;\\n\\ttempStoreNums2 = 0;\\n\\tmaxSum = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums1 - tempStoreNums2;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\tconst maxSumTwo = sumNums2 + maxSum;\\n\\treturn Math.max(maxSumTwo, maxSumOne);\\n};"]}
{"id": "2178", "ref_js": ["var longestSubarray = function(nums) {\\n    let ans = 0, count = 0;\\n    let max = Math.max(...nums);\\n    \\n    for (const num of nums) {\\n        if (num === max) {\\n            ans = Math.max(ans, ++count);\\n        } else {\\n            count = 0;\\n        }\\n    }\\n\\n    return ans;\\n};", "var longestSubarray = function(nums) {\\n  let n = nums.length, max = Math.max(...nums);\\n  let len = 0, maxLen = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] === max) len++;\\n    else len = 0;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n};", "var longestSubarray = function(nums) {\\n  let n = nums.length, max = Math.max(...nums);\\n  let len = 0, maxLen = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] === max) len++;\\n    else len = 0;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n};"]}
{"id": "2179", "ref_js": ["var countPaths = function(grid) {\\n  let mod = Math.pow(10, 9) + 7;\\n  let result = 0;\\n  let rows = grid.length, columns = grid[0].length;\\n  let dp = Array(rows).fill(null).map(_ => Array(columns).fill(0));\\n  \\n  const dfs = (r, c, preVal)=> {\\n    if (r < 0 || r == rows || c < 0 || c == columns || grid[r][c] <= preVal) return 0\\n    if (dp[r][c]) return dp[r][c]\\n    return dp[r][c] = (1 + dfs(r + 1, c, grid[r][c]) + \\n                       dfs(r - 1, c, grid[r][c]) + \\n                       dfs(r , c + 1, grid[r][c]) +  \\n                       dfs(r , c - 1, grid[r][c])) % mod;\\n  }\\n   for(let i = 0; i < rows; i++) {\\n    for(let j = 0; j < columns; j++) {\\n      result += dfs(i, j, -1) % mod;\\n    }\\n  }\\n \\n  return result % mod;\\n};", "var countPaths = function (grid) {\\n  let ans = 0;\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  const dirs = [-1, 0, 1, 0, -1];\\n  const MOD = Math.pow(10, 9) + 7;\\n  const dp = new Array(n).fill().map((_) => new Array(m).fill(0));\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      if (dp[i][j] === 0) {\\n        dfs(i, j, dp, grid, dirs, n, m, MOD);\\n      }\\n      ans = (ans + dp[i][j]) % MOD;\\n    }\\n  }\\n\\n  return ans;\\n};", "var countPaths = function (grid) {\\n    this.MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.MODULO = Math.pow(10, 9) + 7;\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n    this.memoizationGrid = Array.from(new Array(this.rows), () => new Array(this.columns).fill(0));\\n\\n    let totalStrictlyIncreasingPaths = 0;\\n    for (let r = 0; r < this.rows; ++r) {\\n        for (let c = 0; c < this.columns; ++c) {\\n            totalStrictlyIncreasingPaths = (totalStrictlyIncreasingPaths + depthFirstSearch(grid, r, c)) % this.MODULO;\\n        }\\n    }\\n\\n    return totalStrictlyIncreasingPaths;\\n};"]}
{"id": "2180", "ref_js": ["var validSubarraySize = function(nums, threshold) {\\n    \\n    let stack=[];\\n    for(let i=0;i<nums.length;i++){\\n        let start = i;\\n        while(stack.length>0 && stack[stack.length-1][0]>nums[i]){\\n            let popped = stack.pop();\\n            let min = popped[0];\\n            let len = i-popped[1];\\n            if(min>threshold/len){\\n                return len;\\n            }\\n            start = popped[1];\\n        }\\n        stack.push([nums[i],start]);\\n    }\\n    let end = nums.length-1;\\n    for(let i=0;i<stack.length;i++){\\n        let len = end - stack[i][1] +1;\\n        let min = stack[i][0];\\n        if(min>threshold/len){\\n            return len;\\n        }\\n    }\\n    return -1;\\n};", "var validSubarraySize = function(nums, threshold) {\\n    \\n    let stack=[];\\n    for(let i=0;i<nums.length;i++){\\n        let start = i;\\n        while(stack.length>0 && stack[stack.length-1][0]>nums[i]){\\n            let popped = stack.pop();\\n            let min = popped[0];\\n            let len = i-popped[1];\\n            if(min>threshold/len){\\n                return len;\\n            }\\n            start = popped[1];\\n        }\\n        stack.push([nums[i],start]);\\n    }\\n    let end = nums.length-1;\\n    for(let i=0;i<stack.length;i++){\\n        let len = end - stack[i][1] +1;\\n        let min = stack[i][0];\\n        if(min>threshold/len){\\n            return len;\\n        }\\n    }\\n    return -1;\\n};", "var validSubarraySize = function(nums, threshold) {\\n    \\n    let stack=[];\\n    for(let i=0;i<nums.length;i++){\\n        let start = i;\\n        while(stack.length>0 && stack[stack.length-1][0]>nums[i]){\\n            let popped = stack.pop();\\n            let min = popped[0];\\n            let len = i-popped[1];\\n            if(min>threshold/len){\\n                return len;\\n            }\\n            start = popped[1];\\n        }\\n        stack.push([nums[i],start]);\\n    }\\n    let end = nums.length-1;\\n    for(let i=0;i<stack.length;i++){\\n        let len = end - stack[i][1] +1;\\n        let min = stack[i][0];\\n        if(min>threshold/len){\\n            return len;\\n        }\\n    }\\n    return -1;\\n};"]}
{"id": "2181", "ref_js": ["var idealArrays = function(n, maxValue) {\\n  const mod = 1e9 + 7;\\n  let cur = 0;\\n  let arr = Array(2).fill().map(() => Array(maxValue).fill(1));\\n  for (let l = 2; l <= n; l++) {\\n    const prev = arr[cur];\\n    const next = arr[1-cur];\\n    for (let s = 1; s <= maxValue; s++) {\\n      let res = 0;\\n      for (let m = 1; m * s <= maxValue; m++) {\\n        res = (res + prev[m * s - 1]) % mod;\\n      }\\n      next[s-1] = res;\\n    }\\n    cur = 1 - cur;\\n  }\\n  const res = arr[cur].reduce((a, b) => (a + b) % mod, 0);\\n  return res;\\n};", "var idealArrays = function(n, maxValue) {\\n  const mod = 1e9 + 7;\\n  let cur = 0;\\n  let arr = Array(2).fill().map(() => Array(maxValue).fill(1));\\n  for (let l = 2; l <= n; l++) {\\n    const prev = arr[cur];\\n    const next = arr[1-cur];\\n    for (let s = 1; s <= maxValue; s++) {\\n      let res = 0;\\n      for (let m = 1; m * s <= maxValue; m++) {\\n        res = (res + prev[m * s - 1]) % mod;\\n      }\\n      next[s-1] = res;\\n    }\\n    cur = 1 - cur;\\n  }\\n  const res = arr[cur].reduce((a, b) => (a + b) % mod, 0);\\n  return res;\\n};", "var idealArrays = function(n, maxValue) {\\n  const mod = 1e9 + 7;\\n  let cur = 0;\\n  let arr = Array(2).fill().map(() => Array(maxValue).fill(1));\\n  for (let l = 2; l <= n; l++) {\\n    const prev = arr[cur];\\n    const next = arr[1-cur];\\n    for (let s = 1; s <= maxValue; s++) {\\n      let res = 0;\\n      for (let m = 1; m * s <= maxValue; m++) {\\n        res = (res + prev[m * s - 1]) % mod;\\n      }\\n      next[s-1] = res;\\n    }\\n    cur = 1 - cur;\\n  }\\n  const res = arr[cur].reduce((a, b) => (a + b) % mod, 0);\\n  return res;\\n};"]}
{"id": "2182", "ref_js": ["var minOperations = function(nums, numsDivide) {\\n    ", "var minOperations = function(nums, numsDivide) {\\n    ", "var minOperations = function(nums, numsDivide) {\\n    "]}
{"id": "2183", "ref_js": ["var shortestSequence = function(nums, k) {\\n    let ans=0;\\n    let st=new Set();\\n    for(let it of nums){\\n        st.add(it);\\n        if(st.size===k){\\n            ans++;\\n            st=new Set();\\n        }\\n    }\\n    return ans+1;\\n};", "var shortestSequence = function (a, k) {\\n  let allElementGroups = 0;\\n  let set = new Set()\\n\\n  for (let e of a) {\\n    set.add(e);\\n    if (set.size === k) {\\n      allElementGroups += 1; ", "var shortestSequence = function(rolls, k) \\n{\\n    let ans=1;\\n    let sett=new Set();\\n    \\n    for(let i of rolls)\\n        {\\n            sett.add(i);\\n            if(sett.size===k)\\n                {\\n                    ans++;\\n                    sett=new Set();\\n                }\\n        }\\n    return ans;\\n};"]}
{"id": "2184", "ref_js": ["var countExcellentPairs = function(nums, k) {\\n    const map = new Map();\\n    const set = new Set();\\n    const l = nums.length;\\n    let res = 0;\\n    for (let num of nums) {\\n        let temp = num.toString(2).split(\"1\").length - 1;\\n        if (!map.has(temp)) {\\n            map.set(temp, new Set([num]));\\n        } else {\\n            map.get(temp).add(num);\\n        }\\n    }\\n    \\n    for (let num of nums) {\\n        let temp = num.toString(2).split(\"1\").length - 1;\\n        if(!set.has(num)) {\\n            let gap = Math.max(0, k - temp)\\n            for (let key of map.keys()) {\\n                if (key >= gap) {\\n                    res += map.get(key).size;\\n                }\\n            }  \\n            set.add(num);\\n        }else {\\n            continue;\\n        }\\n    }\\n    return res;\\n};", "var countExcellentPairs = function(nums, k) {\\n    let uniques = new Set();\\n    let arr = new Array(32);\\n    arr.fill(0);\\n    \\n    for( let num of nums ) {\\n        if(uniques.has(num)) continue;\\n        uniques.add(num);\\n        arr[bits(num)]++;\\n    }\\n    \\n    let acc = 0;\\n    let suffix = new Array(32);\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        acc += arr[i];\\n        suffix[i] = acc;\\n    }\\n    \\n    let ans = 0;\\n        \\n    for(let i = 1; i < 32; i++) {\\n\\n        if(k - i >= 32) {\\n            continue;\\n        }\\n        if(k - i < 1) {\\n            ans += arr[i] * suffix[1];\\n        } else {\\n            ans += arr[i] * suffix[k - i];\\n        }\\n\\n    }\\n        \\n    return ans;\\n};", "var countExcellentPairs = function(nums, k) {\\n    let uniques = new Set();\\n    let arr = new Array(32);\\n    arr.fill(0);\\n    \\n    for( let num of nums ) {\\n        if(uniques.has(num)) continue;\\n        uniques.add(num);\\n        arr[bits(num)]++;\\n    }\\n    \\n    let acc = 0;\\n    let suffix = new Array(32);\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        acc += arr[i];\\n        suffix[i] = acc;\\n    }\\n    \\n    let ans = 0;\\n        \\n    for(let i = 1; i < 32; i++) {\\n\\n        if(k - i >= 32) {\\n            continue;\\n        }\\n        if(k - i < 1) {\\n            ans += arr[i] * suffix[1];\\n        } else {\\n            ans += arr[i] * suffix[k - i];\\n        }\\n\\n    }\\n        \\n    return ans;\\n};"]}
{"id": "2185", "ref_js": ["var longestCycle = function(edges) {\\n    ", "var longestCycle = function(edges) {\\n    ", "var longestCycle = function(edges) {\\n    "]}
{"id": "2186", "ref_js": ["var minimumReplacement = function(nums) {\\n    let currentLargest = nums[nums.length - 1];\\n    let totalReplacements = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] <= currentLargest) {\\n            currentLargest = nums[i];\\n            continue;\\n        }\\n\\n        let numElements;\\n        if (nums[i] % currentLargest) {\\n            numElements = Math.floor(nums[i] / currentLargest) + 1;\\n            currentLargest = Math.floor(nums[i] / numElements);\\n        } else {\\n            numElements = Math.floor(nums[i] / currentLargest);\\n        }\\n        \\n        totalReplacements += numElements - 1;\\n    }\\n    \\n    return totalReplacements;    \\n};", "var minimumReplacement = function(nums) {\\n    const n = nums.length;\\n    let last = nums[n - 1];  ", "var minimumReplacement = function (nums) {\\n    let steps = 0, prev = nums[nums.length - 1];\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        let num = nums[i];\\n        let n = Math.ceil(num / prev);\\n        steps += n - 1;\\n        prev = Math.floor(num / n);\\n    }\\n    return steps;\\n};"]}
{"id": "2187", "ref_js": ["var countSpecialNumbers = function (n) {\\n  function getDigits(num) {\\n    let ans = [];\\n    while (num > 9) {\\n      let dt = num % 10;\\n      ans.unshift(dt);\\n      num -= dt;\\n      num /= 10;\\n    }\\n\\n    if (num !== 0) ans.unshift(num);\\n\\n    return ans;\\n  }\\n\\n  ", "var countSpecialNumbers = function(n) {\\n    const arr = []\\n    let count = 0\\n    let temp = n+1\\n    \\n    while(temp !== 0) {\\n        arr.unshift(temp%10)\\n        temp = Math.floor(temp/10)\\n    }\\n    \\n    for(let i = 0; i < arr.length - 1; i++) {\\n        count += 9*permutation(9,i)\\n    }\\n    \\n    const set = new Set()\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = i===0?1:0; j < arr[i]; j++) {\\n            if(set.has(j)) continue\\n            count += permutation(10-(i+1), arr.length - 1 - i)\\n        }\\n        \\n        if(set.has(arr[i])) break\\n        set.add(arr[i])\\n    }\\n    \\n    return count\\n    \\n    function permutation(n, right){\\n        let nonRepeatingNums = 1\\n        \\n        for(let i = 0; i < right; i++) {\\n            nonRepeatingNums*=n\\n            n--\\n        }\\n        \\n        return nonRepeatingNums\\n    }\\n};", "var countSpecialNumbers = function (n) {\\n  function getDigits(num) {\\n    let ans = [];\\n    while (num > 9) {\\n      let dt = num % 10;\\n      ans.unshift(dt);\\n      num -= dt;\\n      num /= 10;\\n    }\\n\\n    if (num !== 0) ans.unshift(num);\\n\\n    return ans;\\n  }\\n\\n  "]}
{"id": "2188", "ref_js": ["var maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    ", "var maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    ", "var maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    "]}
{"id": "2189", "ref_js": ["var kSum = function(nums, k) {\\n    let pq = new MaxPriorityQueue(), sum = 0, n = nums.length;\\n    \\n    ", "var kSum = function(nums, k) {\\n    let pq = new MaxPriorityQueue(), sum = 0, n = nums.length;\\n    \\n    ", "var kSum = function(nums, k) {\\n    let pq = new MaxPriorityQueue(), sum = 0, n = nums.length;\\n    \\n    "]}
{"id": "2190", "ref_js": ["var buildMatrix = function (k, rowConditions, colConditions) {\\n  try {\\n    buildGraph(k, rowConditions);\\n    cur = k;\\n    visited.fill(0, 0, k);\\n    visiting.fill(0, 0, k);\\n    for (let i = 0; i < k; ++i) if (!visited[i]) topoSort(i, rowTopo);\\n\\n    buildGraph(k, colConditions);\\n    cur = k;\\n    visited.fill(0, 0, k);\\n    visiting.fill(0, 0, k);\\n    for (let i = 0; i < k; ++i) if (!visited[i]) topoSort(i, colTopo);\\n\\n    let res = Array(k).fill();\\n    for (let i = 0; i < k; ++i) res[i] = new Uint16Array(k);\\n    for (let i = 0; i < k; ++i) res[rowTopo[i]][colTopo[i]] = i + 1;\\n\\n    return res;\\n  } catch {\\n    return [];\\n  }\\n};", "var buildMatrix = function(k, rowConditions, colConditions) {\\n    \\n    function getOrder(conditions) {\\n        ", "var buildMatrix = function(k, rowConditions, colConditions) {\\n  let rowOrder = getOrder(k + 1, rowConditions);\\n  let colOrder = getOrder(k + 1, colConditions);\\n  if (rowOrder === -1 || colOrder === -1) return [];\\n  let matrix = Array(k).fill(0).map(() => Array(k).fill(0));\\n  let pos = Array(k + 1).fill(0).map(() => Array(2));\\n  for (let i = 0; i < k; i++) {\\n    pos[rowOrder[i]][0] = i;\\n    pos[colOrder[i]][1] = i;\\n  }\\n  for (let i = 1; i <= k; i++) {\\n    let [x, y] = pos[i];\\n    matrix[x][y] = i;\\n  }\\n  return matrix;\\n};"]}
{"id": "2191", "ref_js": ["var maximumRobots = function (chargeTimes, runningCosts, budget) {\\n  let sumCost = 0;\\n  let maxRobots = 0;\\n  let window_start = 0;\\n  const pq = new MaxPriorityQueue({\\n    compare: (a, b) => chargeTimes[b] - chargeTimes[a],\\n  });\\n  for (let i = 0; i < runningCosts.length; i++) {\\n    pq.enqueue(i);\\n    const runningCost = runningCosts[i];\\n    sumCost += runningCost;\\n    while (\\n      sumCost * (i - window_start + 1) + chargeTimes[pq.front()] > budget\\n    ) {\\n      sumCost -= runningCosts[window_start];\\n      while (pq.front() <= window_start) {\\n        pq.dequeue();\\n      }\\n      window_start++;\\n    }\\n    maxRobots = Math.max(i - window_start + 1, maxRobots);\\n  }\\n  return maxRobots;\\n};", "var maximumRobots = function(chargeTimes, runningCosts, budget) {\\n    const pq = new PriorityQueue((a,b) => b.val - a.val)\\n    let i = 0\\n    let j = 0 \\n    \\n    let currSum = 0\\n    let maxSoFar = 0\\n    while(j < runningCosts.length) {\\n        pq.enqueue({idx:j, val: chargeTimes[j]})\\n        currSum+=runningCosts[j]\\n        \\n        while(pq.size() && currSum*(j-i+1) + pq.peek().val > budget && i < runningCosts.length) {\\n            currSum -= runningCosts[i]\\n            while(pq.size() && pq.peek().idx <= i) {\\n                pq.dequeue()\\n            }\\n            i++\\n        }\\n        \\n        maxSoFar = Math.max(maxSoFar, j-i+1)\\n        j++\\n    }\\n    \\n    return maxSoFar\\n};", "var maximumRobots = function(chargeTimes, runningCosts, budget) {\\n  const queue = [];\\n  const n = chargeTimes.length;\\n  let [l, r, j, sum] = [0, -1, 0, 0];\\n\\n  for (let i = 0; i < n; i++) {\\n    sum += runningCosts[i];\\n    while (l <= r && chargeTimes[queue[r]] <= chargeTimes[i]) r--;\\n\\n    queue[++r] = i;\\n\\n    if (l <= r && chargeTimes[queue[l]] + (i - j + 1) * sum > budget) {\\n      if (queue[l] === j) l++;\\n      \\n      sum -= runningCosts[j++];\\n    }\\n  }\\n\\n  return n - j;\\n};"]}
{"id": "2192", "ref_js": ["var mostBooked = function(n, meetings) {\\n\\n    let roomsMeetingCount=[], roomsSchedule=[];\\n    ", "var mostBooked = function(n, meetings) {\\n    let rooms_meetings_counter = new Array(n).fill(0);\\n    let available_rooms = new Array(n).fill(-1);\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    meetings.map((meeting) => {\\n        let [start, end] = meeting;\\n        let earliestRoomIdx = 0;\\n        let earliestEndTime = Number.MAX_SAFE_INTEGER;\\n\\n        let isAvailableRoomExist = false;\\n\\n        for (let i = 0; i < n; i++) {\\n            if (available_rooms[i] <= start) {\\n                rooms_meetings_counter[i]++;\\n                available_rooms[i] = end;\\n                isAvailableRoomExist = true;\\n                break;\\n            }\\n\\n            if (available_rooms[i] < earliestEndTime) {\\n                earliestEndTime = available_rooms[i];\\n                earliestRoomIdx = i;\\n            }\\n        }\\n\\n        if (!isAvailableRoomExist) {\\n            rooms_meetings_counter[earliestRoomIdx]++;\\n            available_rooms[earliestRoomIdx] += end - start;\\n        }\\n    });\\n\\n    return rooms_meetings_counter.indexOf(Math.max(...rooms_meetings_counter));\\n};", "var mostBooked = function (n, meetings) {\\n    "]}
{"id": "2193", "ref_js": ["var lengthOfLIS = function(nums, k) {\\n  let max = Math.max(...nums), segTree = new SegmentTree(max + 1), ans = 0;\\n  for (let num of nums) {\\n    let maxLength = segTree.maxInRange(Math.max(num - k, 0), num - 1);\\n    segTree.update(num, maxLength + 1);\\n    ans = Math.max(ans, maxLength + 1);\\n  }\\n  return ans;\\n};", "var lengthOfLIS = function(nums, k) {\\n  let max = Math.max(...nums), segTree = new SegmentTree(max + 1), ans = 0;\\n  for (let num of nums) {\\n    let maxLength = segTree.maxInRange(Math.max(num - k, 0), num - 1);\\n    segTree.update(num, maxLength + 1);\\n    ans = Math.max(ans, maxLength + 1);\\n  }\\n  return ans;\\n};", "var lengthOfLIS = function(nums, k) {\\n  let max = Math.max(...nums), segTree = new SegmentTree(max + 1), ans = 0;\\n  for (let num of nums) {\\n    let maxLength = segTree.maxInRange(Math.max(num - k, 0), num - 1);\\n    segTree.update(num, maxLength + 1);\\n    ans = Math.max(ans, maxLength + 1);\\n  }\\n  return ans;\\n};"]}
{"id": "2194", "ref_js": ["var minimumMoney = function(t) {\\n    let top=[], bottom=[]\\n    for (let i=0;i<t.length;i++){\\n        if (t[i][1]<t[i][0]) top.push(t[i])\\n        else bottom.push(t[i])   \\n    }\\n    top.sort((a,b)=>a[1]-b[1])\\n    bottom.sort((a,b)=>b[0]-a[0])\\n    let arr=[...top,...bottom]\\n    for (let i=arr.length-2;i>-1;i--){\\n        if (arr[i][0]-arr[i][1]>0 )\\n            if(arr[i][0]<arr[i+1][0]+arr[i][0]-arr[i][1]){\\n            arr[i][0]=arr[i+1][0]+arr[i][0]-arr[i][1]\\n            }\\n    }\\n    return arr[0][0]\\n};", "var minimumMoney = function(transactions) {\\n    let lossProductMaxCashback=0;\\n    let profitProductMaxPrice=0;\\n    let cost=0;\\n    for(let i=0;i<transactions.length;i++){\\n        if(transactions[i][0]>transactions[i][1]){", "var minimumMoney = function(transactions) {\\n    "]}
{"id": "2195", "ref_js": ["var sumPrefixScores = function(words) {\\n    const n = words.length;\\n    const trie = {_count: 0};", "var sumPrefixScores = function(words) {\\n\\n  let s = words;\\n  let tree = new Trie();\\n  let ans = [];\\n  for(let w of s){\\n    tree.add(w)\\n  }\\n  for(let w of words){\\n    ans.push(tree.get_score(w));\\n  }\\n  return ans;\\n};", "var sumPrefixScores = function (words) {\\n  const indices = [];\\n  let n = words.length;\\n\\n  for (let i = 0; i < n; i++) indices.push(i);\\n  indices.sort((a, b) => words[a].localeCompare(words[b]));\\n\\n  let result = words.map(w => w.length)\\n\\n  for (let ri = 0; ri < n; ri++) {\\n    const rw = words[indices[ri]];\\n    let p = 0;\\n    for (let li = 0; li < ri; li++) {\\n      const lw = words[indices[li]];\\n      \\n      while (p < rw.length && rw[p] === lw[p]) p++;\\n      result[indices[ri]] += p;\\n      result[indices[li]] += p;\\n    }\\n  }\\n\\n  return result;\\n};"]}
{"id": "2196", "ref_js": ["var numberOfGoodPaths = function(vals, edges) {\\n    const n = vals.length;  ", "var numberOfGoodPaths = function(vals, edges) {\\n    const n = vals.length;  ", "var numberOfGoodPaths = function(vals, edges) {\\n    const n = vals.length;  "]}
{"id": "2197", "ref_js": ["var numberOfPairs = function(nums1, nums2, diff) {    \\n    let answer = 0;\\n    const past = [];\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        const sum = nums1[i] - nums2[i];\\n        const [cnt, pos] = binSearch(past, sum, diff);\\n        answer += cnt;\\n        past.splice(pos, 0, sum);\\n    }\\n    \\n    return answer;\\n};", "var numberOfPairs = function(nums1, nums2, diff) {    \\n    let answer = 0;\\n    const past = [];\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        const sum = nums1[i] - nums2[i];\\n        const [cnt, pos] = binSearch(past, sum, diff);\\n        answer += cnt;\\n        past.splice(pos, 0, sum);\\n    }\\n    \\n    return answer;\\n};", "var numberOfPairs = function(nums1, nums2, diff) {    \\n    let answer = 0;\\n    const past = [];\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        const sum = nums1[i] - nums2[i];\\n        const [cnt, pos] = binSearch(past, sum, diff);\\n        answer += cnt;\\n        past.splice(pos, 0, sum);\\n    }\\n    \\n    return answer;\\n};"]}
{"id": "2198", "ref_js": ["var deleteString = function (s) {\\n  const LEN = s.length;\\n  let lcsPrev = Array(1 + LEN).fill(0);\\n  let lcsCurr = Array(1 + LEN).fill(0);\\n\\n  let dp = Array(1 + LEN).fill(1);\\n  for (let i = LEN - 1; i >= 0; i--) {\\n    for (let j = 1 + i; j < LEN; j++) {\\n      if (s[i] === s[j]) lcsCurr[j] = 1 + lcsPrev[j + 1];\\n\\n      if (lcsCurr[j] >= j - i) dp[i] = Math.max(dp[i], 1 + dp[j]);\\n    }\\n\\n    for (let i = 0; i <= LEN; i++) lcsPrev[i] = lcsCurr[i];\\n    for (let i = 0; i <= LEN; i++) lcsCurr[i] = 0;\\n  }\\n\\n  return dp[0];\\n};", "var deleteString = function(s) {\\n    const memo = {}\\n    dfs(0)\\n    return memo[0]\\n    \\n    function dfs(curIdx) {\\n        ", "var deleteString = function(s) {\\n    const memo = {}\\n    dfs(0)\\n    return memo[0]\\n    \\n    function dfs(curIdx) {\\n        "]}
{"id": "2199", "ref_js": ["var numberOfPaths = function(grid, k) {\\n  let m = grid.length, n = grid[0].length, MOD = 10 ** 9 + 7;\\n  let memo = Array(m).fill(0).map(() => Array(n).fill(0).map(() => Array(k).fill(-1)));\\n  return dfs(0, 0, grid[0][0] % k);\\n\\n  function dfs(i, j, sumMod) {\\n    if (i === m - 1 && j === n - 1) return sumMod === 0 ? 1 : 0;\\n    if (memo[i][j][sumMod] !== -1) return memo[i][j][sumMod];\\n\\n    let paths = [[i + 1, j], [i, j + 1]], ways = 0;\\n    for (let [x, y] of paths) {\\n      if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n      ways = (ways + dfs(x, y, (sumMod + grid[x][y]) % k)) % MOD;\\n    }\\n    return memo[i][j][sumMod] = ways;\\n  }\\n};", "var numberOfPaths = function (grid, k) {\\n    let n = grid.length\\n    let m = grid[0].length\\n    let mod = 10 ** 9 + 7\\n    let dp = Array(n).fill(0).map((row) => Array(m).fill(0).map(() => Array(k).fill(-1)))\\n    function dfs(i, j, r) {\\n        if (i >= n) return 0\\n        if (j >= m) return 0\\n        if (i == n - 1 &&\\n            j === m - 1) {\\n            return (grid[i][j] % k + r) % k === 0\\n        }\\n        if (dp[i][j][r] !== -1) return dp[i][j][r]\\n        let val = grid[i][j]\\n        let ans = 0\\n        let newR = (val % k + r) % k\\n        ans += dfs(i + 1, j, newR)\\n        ans += dfs(i, j + 1, newR)\\n        ans %= mod\\n        dp[i][j][r] = ans\\n        return ans\\n    }\\n    return dfs(0, 0, 0)\\n};", "var numberOfPaths = function(grid, k) {\\n    const modulo = 1e9 + 7;\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    const amounts = new Array(rows).fill().map(() => new Array(cols).fill().map(() => new Array(k).fill(0)));\\n    let rem = grid[0][0] % k; "]}
{"id": "2200", "ref_js": ["var componentValue = function(nums, edges) {\\n    var dfs = function(nums, g, cur, parent, target) {\\n        var curSum = nums[cur];\\n        for (var i = 0; i < g[cur].length; i++) {\\n            var nbr = g[cur][i];\\n            if (nbr === parent) continue;\\n            curSum += dfs(nums, g, nbr, cur, target);\\n        }\\n        \\n        if (curSum === target) {\\n            return 0;\\n        } else {\\n            return curSum;\\n        }\\n    };", "var componentValue = function (nums, edges) {\\n  const size = nums.length;\\n  const graph = Array(size)\\n    .fill()\\n    .map(() => []);\\n  \\n  const sum = nums.reduce((sum, num) => num + sum, 0);\\n\\n  for (let [A, B] of edges) {\\n    graph[A].push(B);\\n    graph[B].push(A);\\n  }\\n\\n  for (let i = size; i >= 2; i--) {\\n    if (sum % i == 0) {\\n      if (can(nums, graph, sum / i)) return i - 1;\\n    }\\n  }\\n\\n  return 0;\\n};", "var componentValue = function (nums, edges) {\\n  const size = nums.length;\\n  const graph = Array(size)\\n    .fill()\\n    .map(() => []);\\n  \\n  const sum = nums.reduce((sum, num) => num + sum, 0);\\n\\n  for (let [A, B] of edges) {\\n    graph[A].push(B);\\n    graph[B].push(A);\\n  }\\n\\n  for (let i = size; i >= 2; i--) {\\n    if (sum % i == 0) {\\n      if (can(nums, graph, sum / i)) return i - 1;\\n    }\\n  }\\n\\n  return 0;\\n};"]}
{"id": "2201", "ref_js": ["var countSubarrays = function(nums, minK, maxK) {\\n\\n        let maxPosition=-1;\\n        let minPosition=-1;\\n        let leftBound=-1;\\n        let answer=0;\\n        for(let i=0;i<nums.length;i++){\\n                if(nums[i]<minK || nums[i]>maxK ){\\n                    leftBound=i;\\n                }\\n                if(nums[i]==minK) minPosition=i;\\n                if(nums[i]==maxK) maxPosition=i;\\n               let a= Math.min(maxPosition,minPosition)-leftBound;\\n               if(a>0) answer+=a;\\n\\n        }\\n    return answer;\\n};", "var countSubarrays = function(nums, minK, maxK) {\\n   let sum = 0;\\n   let start = 0, minStart = 0, maxStart = 0;\\n   let minf = false, maxf = false;\\n\\n   for(let i = 0; i < nums.length; i++){\\n       let num = nums[i]\\n       if(num < minK || num > maxK){\\n           minf = false;\\n           maxf = false;\\n           start = i+1;\\n       }\\n\\n       if(num === minK){\\n           minf = true\\n           minStart = i;\\n       }\\n\\n       if(num === maxK){\\n           maxf = true\\n           maxStart = i;\\n       }\\n\\n       if(minf && maxf){\\n           sum += (Math.min(minStart, maxStart) - start+1)\\n       }\\n   } \\n\\n   return sum\\n};", "var countSubarrays = function(nums, minK, maxK) {\\n    let res = 0\\n    let startOfWindow = 0\\n    let currMinPos = -1\\n    let currMaxPos = -1\\n    let foundMin = false\\n    let foundMax = false\\n    \\n    for(let right = 0; right < nums.length; right++) {\\n        const curr = nums[right]\\n        \\n        if(curr === minK) {\\n            foundMin = true\\n            currMinPos = right\\n        }\\n        \\n        if(curr === maxK) {\\n            foundMax = true\\n            currMaxPos = right\\n        }\\n        \\n        \\n        if(curr < minK || curr > maxK) {\\n            foundMin = false\\n            foundMax= false\\n            startOfWindow = right+1\\n        }\\n        \\n        if(foundMin && foundMax) {\\n            res += (Math.min(currMinPos, currMaxPos) - startOfWindow + 1)\\n        }\\n    }\\n    \\n    return res\\n};"]}
{"id": "2202", "ref_js": ["var minCost = function(nums, cost) {\\n     \\n    const n = nums.length;\\n    if(n<=1) return 0;\\n    let arr = [];\\n    for(let i=0;i<n;i++) arr[i] = [nums[i],cost[i]];\\n    arr.sort((a,b)=>a[0]-b[0]);\\n    let psum = [arr[0][1]];\\n    for(let i=1;i<n;i++) psum.push(psum[i-1]+arr[i][1]);\\n    let sum = 0;\\n    for(let i=1;i<n;i++){\\n        sum+= (Math.abs(arr[i][0]-arr[0][0]))*arr[i][1];\\n    }\\n    let ans=Infinity;\\n    ans=Math.min(ans,sum);\\n    for(let i=1;i<n;i++){\\n        sum+=(psum[i-1])*(arr[i][0]-arr[i-1][0]);\\n        sum-=(psum[n-1]-psum[i-1])*(arr[i][0]-arr[i-1][0]);\\n        ans=Math.min(ans,sum);\\n    }\\n    return ans;\\n};", "var minCost = function(nums, cost) {\\n    const n = nums.length;\\n    const v = [];\\n    let totalCost = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        v.push([nums[i], cost[i]]);\\n        totalCost += cost[i];\\n    }\\n\\n    v.sort((a, b) => a[0] - b[0]);\\n\\n    const mid = Math.floor((totalCost + 1) / 2);\\n    let target = -1;\\n    let currSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        currSum += v[i][1];\\n        if (currSum >= mid) {\\n            target = v[i][0];\\n            break;\\n        }\\n    }\\n\\n    let ans = 0;\\n    for (let i = 0; i < n; i++) {\\n        ans += Math.abs(nums[i] - target) * cost[i];\\n    }\\n\\n    return ans;\\n};", "var minCost = function(nums, cost) {\\n    const n = nums.length;\\n    const v = [];\\n    let totalCost = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        v.push([nums[i], cost[i]]);\\n        totalCost += cost[i];\\n    }\\n\\n    v.sort((a, b) => a[0] - b[0]);\\n\\n    const mid = Math.floor((totalCost + 1) / 2);\\n    let target = -1;\\n    let currSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        currSum += v[i][1];\\n        if (currSum >= mid) {\\n            target = v[i][0];\\n            break;\\n        }\\n    }\\n\\n    let ans = 0;\\n    for (let i = 0; i < n; i++) {\\n        ans += Math.abs(nums[i] - target) * cost[i];\\n    }\\n\\n    return ans;\\n};"]}
{"id": "2203", "ref_js": ["var makeSimilar = function(nums, target) {\\n    ", "var makeSimilar = function (nums, target) {\\n  const numsEven = [];\\n  const numsOdd = [];\\n  nums.forEach((num) => {\\n    if (num % 2 == 0) {\\n      numsEven.push(num);\\n    } else {\\n      numsOdd.push(num);\\n    }\\n  });\\n  const targetEven = [];\\n  const targetOdd = [];\\n  target.forEach((num) => {\\n    if (num % 2 == 0) {\\n      targetEven.push(num);\\n    } else {\\n      targetOdd.push(num);\\n    }\\n  });\\n  numsEven.sort((a, b) => a - b);\\n  numsOdd.sort((a, b) => a - b);\\n  targetEven.sort((a, b) => a - b);\\n  targetOdd.sort((a, b) => a - b);\\n  let result = 0;\\n  for (let i = 0; i < numsEven.length; i++) {\\n    result += Math.abs(numsEven[i] - targetEven[i]);\\n  }\\n  for (let i = 0; i < numsOdd.length; i++) {\\n    result += Math.abs(numsOdd[i] - targetOdd[i]);\\n  }\\n  return result / 4;\\n};", "var makeSimilar = function(nums, target) {\\n    "]}
{"id": "2204", "ref_js": ["var secondGreaterElement = function(nums) {\\n    let stack1 = [], stack2 = [];\\n    let peek = (no) => {\\n        if(no == 1)\\n            return nums[stack1[stack1.length - 1]];\\n        return nums[stack2[stack2.length - 1]];\\n    }  \\n    let result = new Array(nums.length).fill(-1);\\n    for(let i = 0; i < nums.length; i++){\\n        while(stack2.length && peek(2) < nums[i]){\\n            result[stack2.pop()] = nums[i];\\n        }\\n        ", "var secondGreaterElement = function(nums) {\\n    let stack1 = [], stack2 = [];\\n    let peek = (no) => {\\n        if(no == 1)\\n            return nums[stack1[stack1.length - 1]];\\n        return nums[stack2[stack2.length - 1]];\\n    }  \\n    let result = new Array(nums.length).fill(-1);\\n    for(let i = 0; i < nums.length; i++){\\n        while(stack2.length && peek(2) < nums[i]){\\n            result[stack2.pop()] = nums[i];\\n        }\\n        ", "var secondGreaterElement = function(nums) {\\n    let stack1 = [], stack2 = [];\\n    let peek = (no) => {\\n        if(no == 1)\\n            return nums[stack1[stack1.length - 1]];\\n        return nums[stack2[stack2.length - 1]];\\n    }  \\n    let result = new Array(nums.length).fill(-1);\\n    for(let i = 0; i < nums.length; i++){\\n        while(stack2.length && peek(2) < nums[i]){\\n            result[stack2.pop()] = nums[i];\\n        }\\n        "]}
{"id": "2205", "ref_js": ["var treeQueries = function(root, queries) {\\n    if (!root) return [];\\n    \\n    let ans = {};", "var treeQueries = function(root, queries) {\\n    ", "var treeQueries = function (root, queries) {\\n  let n = queries.length;\\n  let res = new Uint32Array(n);\\n  dive(root, 0);\\n  solve(root, 0, 0);\\n\\n  for (let i = 0; i < n; ++i) res[i] = spitThese[queries[i]];\\n  return res;\\n};"]}
{"id": "2206", "ref_js": ["var minimumTotalDistance = function (robot, factory) {\\n  const n = robot.length;\\n  const m = factory.length;\\n  robot.sort((a, b) => a - b);\\n  factory.sort((a, b) => a[0] - b[0]);\\n\\n  const dp = [];\\n  for (let i = 0; i < m; i++) dp.push(Array(n).fill(null));\\n\\n  function getDp(fi, ri) {\\n    if (ri < 0) return 0;\\n    if (fi < 0) return null;\\n    return dp[fi][ri];\\n  }\\n\\n  for (let fi = 0; fi < m; fi++) {\\n    for (let rir = 0; rir < n; rir++) {\\n      dp[fi][rir] = getDp(fi - 1, rir);\\n      let sum = 0;\\n      for (let ril = rir; ril >= Math.max(0, rir - factory[fi][1] + 1); ril--) {\\n        sum += Math.abs(robot[ril] - factory[fi][0]);\\n        const prev = getDp(fi-1, ril-1);\\n        if (prev !== null) {\\n          if (dp[fi][rir] === null) dp[fi][rir] = prev + sum;\\n          else dp[fi][rir] = Math.min(dp[fi][rir], prev + sum);\\n        }\\n      }\\n    }\\n  }\\n\\n  return dp[m-1][n-1];\\n};", "var minimumTotalDistance = function(robot, factory) {\\n    const memo = new Map(); ", "var minimumTotalDistance = function(robot, factory) {\\n    robot.sort((a, b) => a - b);\\n    factory.sort((a, b) => a[0] - b[0]);\\n    let memo = {};"]}
{"id": "2207", "ref_js": ["var splitMessage = function (message, limit) {\\n  function getLen(number) {\\n    if (Number.isNaN(number) || number < 0)\\n      throw new Error(`Invalid input: ${number}`);\\n\\n    return number.toString().length;\\n  }\\n\\n  const MESSAGE_LEN = message.length;\\n  ", "var splitMessage = function (message, limit) {\\n  if (limit <= 5) return [];\\n\\n  const MESSAGE_LEN = message.length;\\n  const NINE = 9;\\n\\n  \\n  function calcuate(digits) {\\n    let sum = 0;\\n    let charsAmountArr = [];\\n\\n    ", "var splitMessage = function (message, limit) {\\n  if (limit <= 5) return [];\\n\\n  const MESSAGE_LEN = message.length;\\n  const NINE = 9;\\n\\n  \\n  function calcuate(digits) {\\n    let sum = 0;\\n    let charsAmountArr = [];\\n\\n    "]}
{"id": "2208", "ref_js": ["var maxPalindromes = function(s, k) {\\n    let ans = 0 \\n\\t\\n    const isPalindrome = (str) => {\\n        let start = 0\\n        let end = str.length - 1\\n        while (start < end) {\\n            if (str[start] !== str[end]) return false\\n            start++\\n            end--\\n        }\\n        return true\\n    }\\n    \\n    let len = s.length\\n    let i = 0\\n    \\n    while (i + k <= len) {\\n        let step = 1\\n        if (isPalindrome(s.substring(i, i + k) )) {\\n            ans++\\n            step = k\\n        } else if (i + k + 1 <= len) {\\n            if (isPalindrome(s.substring(i, i + k + 1))) {\\n                ans++\\n                step = k + 1\\n            } \\n        }\\n        i += step\\n    }\\n    return ans\\n};", "var maxPalindromes = function(s, k) {\\n    let set = new Set();\\n    if(k==1) return s.length;\\n    let count = 0;\\n    function helper(l,r,s) {\\n        while(l>=0 && r<s.length) {\\n            if(s[l]===s[r] && set.has(l) === false && set.has(r) === false) {\\n                l--;\\n                r++;\\n                if( r-l-1 >= k) {\\n                    count +=1;\\n                    for(let i=l-1; i<r; i++) {\\n                        set.add(i);\\n                    }\\n                    break;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    for(let i=0; i<s.length-1; i++) {\\n        helper(i,i,s);\\n        helper(i,i+1,s);\\n\\n    }\\n    return count;\\n};", "var maxPalindromes = function(s, k) {\\n   let ans = 0;\\n   for(let i = 0; i <= s.length - k; i++){\\n        if(isPalindrome(s, i, i + k-1)){\\n            ans++;\\n            i += k - 1;\\n            continue;\\n        }\\n        if(isPalindrome(s, i, i + k)){\\n            ans++;\\n            i += k;\\n            continue;\\n        }\\n   }  \\n  return ans;  \\n};"]}
{"id": "2209", "ref_js": ["var beautifulPartitions = function (s, k, minLength) {\\n  const ARR = s.split(\"\").map((c) => parseInt(c));\\n  const LEN = ARR.length;\\n  const PRIMES = new Set([2, 3, 5, 7]);\\n  const memo = new Map();\\n\\n  function waysOfPartition(idx, target) {\\n    if (idx >= LEN || LEN - idx < target * minLength || !PRIMES.has(ARR[idx]))\\n      return 0;\\n    else if (target === 1) return !PRIMES.has(ARR[LEN - 1]) ? 1 : 0;\\n\\n    let key = `${idx},${target}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    ", "var beautifulPartitions = function(s, k, minLength) {\\n  let n = s.length, nonPrimeIndexes = [];\\n  for (let i = 0; i < n; i++) {\\n    if (!isPrime(s[i])) nonPrimeIndexes.push(i);\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(k + 1).fill(-1)), MOD = 10 ** 9 + 7;\\n  return dp(0, k);\\n  \\n  function dp(i, k) {\\n    let remainingLen = n - i;\\n    if (remainingLen < Math.max(2, minLength) * k) return 0;\\n    if (i === n) return k === 0 ? 1 : 0;\\n    if (k === 0) return 0;\\n    if (memo[i][k] !== -1) return memo[i][k];\\n    \\n    if (!isPrime(s[i])) return 0;\\n    \\n    let ways = 0;\\n    let index = binarySearch(i + minLength - 1);\\n    for (let j = index; j < nonPrimeIndexes.length; j++) {\\n      ways = (ways + dp(nonPrimeIndexes[j] + 1, k - 1)) % MOD;\\n    }\\n    return memo[i][k] = ways;\\n  }  \\n  \\n  function isPrime(num) {\\n    return [\\'2\\', \\'3\\', \\'5\\', \\'7\\'].includes(num);\\n  }\\n  \\n  function binarySearch(min) { ", "var beautifulPartitions = function(s, k, minLength) {\\n    const PRIMES = [\\'2\\', \\'3\\', \\'5\\', \\'7\\'];\\n    const MOD = 1000000007;\\n    if (s.length <= k * minLength || !PRIMES.includes(s[0]) || PRIMES.includes(s[s.length - 1])) {\\n        return 0;\\n    }\\n    "]}
{"id": "2210", "ref_js": ["var countPalindromes = function(s) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    for (let x = 0; x <= 9; x++) {\\n        for (let y = 0; y <= 9; y++) {\\n            ", "var countPalindromes = function (input) {\\n    const PALINDROME_LENGTH = 5;\\n    const MODULO = Math.pow(10, 9) + 7;\\n    const ASCII_0 = 48;\\n\\n    let totalPalindromesWithLengthFive = 0;\\n\\n    for (let first = 0; first <= 9; ++first) {\\n        for (let second = 0; second <= 9; ++second) {\\n\\n            const palindrome = [first, second, 0, second, first];\\n            const memo = [0, 0, 0, 0, 0, 1];\\n\\n            for (let i = 0; i < input.length; ++i) {\\n                for (let n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                    let digit = input.codePointAt(i) - ASCII_0;\\n                    if (digit === palindrome[n] || n === 2) {\\n                        memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                    }\\n                }\\n            }\\n            totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n        }\\n    }\\n    return totalPalindromesWithLengthFive;\\n};", "var countPalindromes = function (input) {\\n    const PALINDROME_LENGTH = 5;\\n    const MODULO = Math.pow(10, 9) + 7;\\n    const ASCII_0 = 48;\\n\\n    let totalPalindromesWithLengthFive = 0;\\n\\n    for (let first = 0; first <= 9; ++first) {\\n        for (let second = 0; second <= 9; ++second) {\\n\\n            const palindrome = [first, second, 0, second, first];\\n            const memo = [0, 0, 0, 0, 0, 1];\\n\\n            for (let i = 0; i < input.length; ++i) {\\n                for (let n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                    let digit = input.codePointAt(i) - ASCII_0;\\n                    if (digit === palindrome[n] || n === 2) {\\n                        memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                    }\\n                }\\n            }\\n            totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n        }\\n    }\\n    return totalPalindromesWithLengthFive;\\n};"]}
{"id": "2211", "ref_js": ["var countSubarrays = function(nums, k) {\\n  let n = nums.length, kIndex = nums.indexOf(k);\\n  let map = new Map(), leftBalance = 0;\\n  map.set(0, 1);\\n  for (let i = kIndex - 1; i >= 0; i--) {\\n    leftBalance += nums[i] > k ? 1 : -1;\\n    map.set(leftBalance, (map.get(leftBalance) || 0) + 1);\\n  }\\n  \\n  let rightBalance = 0, ans = 0;\\n  for (let j = kIndex; j < n; j++) {\\n    if (nums[j] !== k) rightBalance += nums[j] > k ? 1 : -1;\\n    let oddComplement = -rightBalance; ", "var countSubarrays = function(nums, k) {\\n  ", "var countSubarrays = function(nums, k) {\\n    const count = { 0: 1 }, kIndex = nums.findIndex((a) => a == k);\\n\\n    for (let i = kIndex + 1, bal = 0; i < nums.length; i++)\\n        bal += nums[i] > nums[kIndex] ? 1 : -1, count[bal] = 1 + (count[bal] ?? 0);\\n\\n    let res = count[0] + (count[1] ?? 0);\\n    for (let i = kIndex - 1, bal = 0; i >= 0; i--)\\n        bal += nums[i] > nums[kIndex] ? 1 : -1,\\n        res += (count[-bal] ?? 0) + (count[-bal + 1] ?? 0);\\n    return res;\\n};"]}
{"id": "2212", "ref_js": ["var magnificentSets = function(n, edges) {\\n  let uf = new UnionFind(n + 1);\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [a, b] of edges) { ", "var magnificentSets = function (n, edges) {\\n  let result = 0;\\n  let component = Array(n).fill(undefined);\\n\\n  let graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let edge of edges) {\\n    graph[edge[0] - 1].push(edge[1] - 1);\\n    graph[edge[1] - 1].push(edge[0] - 1);\\n  }\\n\\n  let q = new CircularQueue(n);\\n  let visited = Array(n);\\n\\n  function bfs(src) {\\n    q.clear();\\n    visited.fill(0);\\n    q.enqueue(src);\\n    visited[src] = 1;\\n    let flagFailed = false;\\n\\n    if (component[src] === undefined) component[src] = null;\\n    let cur;\\n    while (q.size) {\\n      cur = q.dequeue();\\n      if (component[cur] === undefined) component[cur] = src;\\n\\n      for (let nex of graph[cur]) {\\n        if (!visited[nex]) {\\n          visited[nex] = visited[cur] + 1;\\n          q.enqueue(nex);\\n        } else {\\n          if (Math.abs(visited[cur] - visited[nex]) !== 1) {\\n            flagFailed = true;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (cur === src) {\\n      component[src] = -1;\\n      return;\\n    }\\n\\n    if (flagFailed) return;\\n\\n    const componentId = component[cur];\\n\\n    if (component[componentId] === null || visited[cur] > -component[componentId]) {\\n      component[componentId] = -visited[cur];\\n    }\\n  }\\n\\n  for (let i = 0; i < n; i++) bfs(i);\\n\\n  for (let i = 0; i < n; i++) {\\n    if (component[i] === null) return -1;\\n    if (component[i] < 0) result -= component[i];\\n  }\\n\\n  return result;\\n};", "var magnificentSets = function (n, edges) {\\n  let result = 0;\\n  let component = Array(n).fill(undefined);\\n\\n  let graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let edge of edges) {\\n    graph[edge[0] - 1].push(edge[1] - 1);\\n    graph[edge[1] - 1].push(edge[0] - 1);\\n  }\\n\\n  let q = new CircularQueue(n);\\n  let visited = Array(n);\\n\\n  function bfs(src) {\\n    q.clear();\\n    visited.fill(0);\\n    q.enqueue(src);\\n    visited[src] = 1;\\n    let flagFailed = false;\\n\\n    if (component[src] === undefined) component[src] = null;\\n    let cur;\\n    while (q.size) {\\n      cur = q.dequeue();\\n      if (component[cur] === undefined) component[cur] = src;\\n\\n      for (let nex of graph[cur]) {\\n        if (!visited[nex]) {\\n          visited[nex] = visited[cur] + 1;\\n          q.enqueue(nex);\\n        } else {\\n          if (Math.abs(visited[cur] - visited[nex]) !== 1) {\\n            flagFailed = true;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (cur === src) {\\n      component[src] = -1;\\n      return;\\n    }\\n\\n    if (flagFailed) return;\\n\\n    const componentId = component[cur];\\n\\n    if (component[componentId] === null || visited[cur] > -component[componentId]) {\\n      component[componentId] = -visited[cur];\\n    }\\n  }\\n\\n  for (let i = 0; i < n; i++) bfs(i);\\n\\n  for (let i = 0; i < n; i++) {\\n    if (component[i] === null) return -1;\\n    if (component[i] < 0) result -= component[i];\\n  }\\n\\n  return result;\\n};"]}
{"id": "2213", "ref_js": ["var movesToMakeZigzagEvenIndexed = function(nums) {\\n\\tlet totalCost = 0;\\n\\tlet previousValue = null;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (index === 0) {\\n\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t} else if (index % 2 === 0) {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue < currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = previousValue - currentValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue > currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = currentValue - previousValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue - tempTotalCost;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn totalCost;\\n};", "var movesToMakeZigzag = function(nums) {\\n    const moves=(start)=>{\\n        let operations=0;\\n        for(let i=start;i<nums.length;i+=2){\\n            const mid=nums[i], \\n            left=i-1<0?Number.MAX_SAFE_INTEGER:nums[i-1], \\n            right=i+1===nums.length?Number.MAX_SAFE_INTEGER:nums[i+1],\\n            minBound=Math.min(left,right);\\n\\n            if(minBound<=mid) operations+=mid-minBound+1;\\n        }\\n        return operations;\\n    }\\n    return Math.min(moves(0),moves(1));    \\n};", "var movesToMakeZigzag = function(nums) {\\n    const MAX_NUM = 1001;\\n    const decrease = [0, 0];\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        const left = nums[index - 1] ?? MAX_NUM;\\n        const right = nums[index + 1] ?? MAX_NUM;\\n        const moves = nums[index] - Math.min(left, right) + 1;\\n\\n        decrease[index & 1] += Math.max(0, moves);\\n    }\\n    return Math.min(...decrease);\\n};"]}
{"id": "2214", "ref_js": ["var maxPoints = function(grid, queries) {\\n  let m = grid.length, n = grid[0].length;\\n  let coords = []; \\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coords.push([i, j, grid[i][j]]); ", "var maxPoints = function(grid, queries) {\\n    const [row, col] = [grid.length, grid[0].length];\\n    \\n    const res = [];\\n    for(const query of queries){\\n        const newGrid = grid.map((arr) => arr.slice());\\n        res.push(dfs(query, 0, 0, newGrid));\\n    }\\n    return res;\\n    \\n    function dfs(query, r, c, newGrid){\\n        if(r < 0 || c < 0 || r === row || c === col || newGrid[r][c] >= query)\\n            return 0;\\n        newGrid[r][c] = Infinity;\\n        return 1 + dfs(query, r + 1, c, newGrid) \\n            + dfs(query, r - 1, c, newGrid)\\n            + dfs(query, r, c + 1, newGrid)\\n            + dfs(query, r, c - 1, newGrid);\\n    }\\n};", "var maxPoints = function(grid, queries) {\\n  let m = grid.length, n = grid[0].length;\\n  let coords = []; \\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coords.push([i, j, grid[i][j]]); "]}
{"id": "2215", "ref_js": ["var isPossible = function(n, edges) {\\n    ", "var isPossible = function(n, edges) {\\n    let res = false;\\n    let indegree = [];\\n    for(let i=0; i<n; i++){\\n        indegree[i] = [];\\n    }\\n    ", "var isPossible = function(n, edges) {\\n    let res = false;\\n    let indegree = [];\\n    for(let i=0; i<n; i++){\\n        indegree[i] = [];\\n    }\\n    "]}
{"id": "2216", "ref_js": ["var cycleLengthQueries = function (n, queries) {\\n  let q = queries.length;\\n  let res = new Uint8Array(q);\\n\\n  while (q--) {\\n    let [a, b] = queries[q];\\n    let cnt = Math.abs(Math.floor(Math.log2(a)) - Math.floor(Math.log2(b)));\\n    \\n    if (a < b) b >>= cnt;\\n    else a >>= cnt;\\n\\n    while (a ^ b) {\\n      a >>= 1;\\n      b >>= 1;\\n      cnt += 2;\\n    }\\n\\n    res[q] = cnt + 1;\\n  }\\n\\n  return res;\\n};", "var cycleLengthQueries = function (n, queries) {\\n  const ans = new Array(queries.length).fill(0);\\n  for (let i = 0; i < queries.length; i++) {\\n    let [v1, v2] = queries[i];\\n\\n    ans[i]++;\\n    while (v1 !== v2) {\\n      if (v1 > v2) {\\n        v1 = Math.floor(v1 / 2);\\n      } else {\\n        v2 = Math.floor(v2 / 2);\\n      }\\n      ans[i]++;\\n    }\\n  }\\n\\n  return ans;\\n};", "var cycleLengthQueries = function (n, queries) {\\n  const ans = new Array(queries.length).fill(0);\\n  for (let i = 0; i < queries.length; i++) {\\n    let [v1, v2] = queries[i];\\n\\n    ans[i]++;\\n    while (v1 !== v2) {\\n      if (v1 > v2) {\\n        v1 = Math.floor(v1 / 2);\\n      } else {\\n        v2 = Math.floor(v2 / 2);\\n      }\\n      ans[i]++;\\n    }\\n  }\\n\\n  return ans;\\n};"]}
{"id": "2217", "ref_js": ["var countAnagrams = function(s) {\\n    let res = BigInt(1);\\n    let arr = s.split(\\' \\');\\n    for(let i=0; i<arr.length; i++){\\n        let w = arr[i];\\n        ", "var countAnagrams = function (s) {\\n  let result = 1n;\\n  const MODULO = 1000000007n;\\n\\n  ", "var countAnagrams = function (s) {\\n  const BIGINT_MODULO = BigInt(Math.pow(10, 9) + 7);\\n  function countWord(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    if (map.size === 1) return 1n;\\n    else {\\n      let finalResult = 1n;\\n      let cnts = Array.from(map.values())\\n        .sort((a, b) => a - b)\\n        .map((val) => BigInt(val));\\n      let sum = BigInt(word.length);\\n      let choice = sum;\\n\\n      for (let i = 0; i < cnts.length - 1; i++) {\\n        let cnt = cnts[i];\\n        let combinations = 1n;\\n        let devisor = 1n;\\n        while (cnt > 0n) {\\n          combinations *= choice--;\\n          devisor *= cnt;\\n          cnt--;\\n        }\\n        finalResult *= combinations / devisor;\\n      }\\n\\n      return finalResult;\\n    }\\n  }\\n\\n  let ans = 1n;\\n  for (let word of s.split(\" \")) {\\n    ans *= countWord(word);\\n    ans %= BIGINT_MODULO;\\n  }\\n\\n  return Number(ans);\\n};"]}
{"id": "2218", "ref_js": ["var getMaximumXor = function(nums, maximumBit) {\\n    let xor = (1 << maximumBit) - 1\\n    for(let i=0; i<nums.length; i++){\\n        xor ^= nums[i]\\n        nums[i] = xor\\n    }\\n    return nums.reverse()\\n};", "var getMaximumXor = function(nums, maximumBit) {\\n    const max = (1 << maximumBit) - 1;\\n    let current = 0;\\n\\n    return nums.map(num => {\\n        current ^= num;\\n        return max ^ current;\\n    }).reverse();\\n};", "var getMaximumXor = function (nums, maximumBit) {\\n    let xor = (1 << maximumBit) - 1;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        xor ^= nums[i];\\n        nums[i] = xor;\\n    }\\n    return nums.reverse();\\n};"]}
{"id": "2219", "ref_js": ["var maxPower = function(stations_, r, k) {\\n    ", "var maxPower = function(stations, r, k) {\\n    const isPossible = (minPower, windowPower) => {\\n        const n = stations.length, extraStations = Array(n).fill(0);\\n        let totalExtraStations = 0;\\n\\n        for (let i = 0, availableExtraPower = 0; i < n; i++) {\\n            if (i + r < n) windowPower += stations[i + r];\\n            if (i > r) windowPower -= stations[i - r - 1];\\n\\n            const extraPower = \\n                Math.max(minPower - (windowPower + availableExtraPower), 0);\\n            if (i + 2 * r < n)\\n                extraStations[i + 2 * r] = -extraPower;\\n            totalExtraStations += extraPower;\\n            availableExtraPower += extraPower + extraStations[i];\\n        }\\n\\n        return totalExtraStations <= k;\\n    };", "var maxPower = function(stations, r, k) {\\n    const isPossible = (minPower, windowPower) => {\\n        const n = stations.length, extraStations = Array(n).fill(0);\\n        let totalExtraStations = 0;\\n\\n        for (let i = 0, availableExtraPower = 0; i < n; i++) {\\n            if (i + r < n) windowPower += stations[i + r];\\n            if (i > r) windowPower -= stations[i - r - 1];\\n\\n            const extraPower = \\n                Math.max(minPower - (windowPower + availableExtraPower), 0);\\n            if (i + 2 * r < n)\\n                extraStations[i + 2 * r] = -extraPower;\\n            totalExtraStations += extraPower;\\n            availableExtraPower += extraPower + extraStations[i];\\n        }\\n\\n        return totalExtraStations <= k;\\n    };"]}
{"id": "2220", "ref_js": ["var closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};", "var closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};", "var closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};"]}
{"id": "2221", "ref_js": ["var maxOutput = function(n, edges, price) {\\n    const m = new Array(n).fill(null).map(_=> new Map());\\n    for(const edge of edges){\\n        ", "var maxOutput = function(n, edges, price) {\\n    const m = new Array(n).fill(null).map(_=> new Map());\\n    for(const edge of edges){\\n        ", "var maxOutput = function(n, edges, price) {\\n    const m = new Array(n).fill(null).map(_=> new Map());\\n    for(const edge of edges){\\n        "]}
{"id": "2222", "ref_js": ["var isReachable = function(targetX, targetY) {\\n    let gc = gcd(targetX,targetY);\\n    return (gc&(gc-1))==0;\\n};", "var isReachable = function(targetX, targetY) {\\n  while (targetX && targetY) {\\n    if (targetX > targetY) {\\n      targetX %= targetY\\n    }\\n    else {\\n      targetY %= targetX\\n    }\\n  }\\n  targetX += targetY;\\n\\n  return !(targetX & (targetX - 1))\\n};", "var isReachable = function(targetX, targetY) {\\n  function gcd(a,b) {\\n    let t=0;\\n    while (b) {\\n      t = b;\\n      b = a % b;\\n      a = t;\\n    }\\n    return a;\\n  } \\n\\n  while (targetX % 2 === 0) targetX /= 2;\\n  while (targetY % 2 === 0) targetY /= 2;\\n  return gcd(targetX, targetY) === 1;\\n};"]}
{"id": "2223", "ref_js": ["var minCost = function (nums, k) {\\n\\n        const len = nums.length\\n        const dp = new Array(len + 1).fill(-1)\\n\\n        return partition(-1, nums, k, len, dp)\\n};", "var minCost = function(nums, k) {\\n    const n = nums.length, dp = Array(n + 1).fill(Infinity);\\n\\n    dp[0] = 0;\\n    for (let i = 0; i < n; i++) {\\n        const freq = Array(n + 1).fill(0);\\n        for (let j = i, trimmedLength = 0; j >= 0; j--) {\\n            trimmedLength += (++freq[nums[j]] > 1) + (freq[nums[j]] == 2);\\n            dp[i + 1] = Math.min(dp[i + 1], dp[j] + k + trimmedLength);\\n        }\\n    }\\n\\n    return dp[n];\\n};", "var minCost = function (nums, k) {\\n\\n        const len = nums.length\\n        const dp = new Array(len + 1).fill(-1)\\n\\n        return partition(-1, nums, k, len, dp)\\n};"]}
{"id": "2224", "ref_js": ["var putMarbles = function(weights, k) {\\n    let weightPairs = new Uint32Array(weights.length-1);\\n    for(let i = 1; i < weights.length; ++i) {\\n        weightPairs[i-1] = weights[i] + weights[i-1];\\n    }\\n    weights = null;\\n    weightPairs.sort();\\n\\n    let ret = 0;\\n\\n    for(let i = 0; i < (k-1); ++i) {\\n        ret += weightPairs[(weightPairs.length-1)-i];\\n        ret -= weightPairs[i];\\n    }\\n\\n    return ret;\\n};", "var putMarbles = function(weights, k) {\\n    let pairsum = [];\\n    let len = weights.length;\\n    for(let i=0;i<len-1;i++)\\n        pairsum.push(weights[i]+weights[i+1]);\\n    pairsum.sort((a,b)=>{return a-b});\\n    let minscore = weights[0]+weights[len-1];\\n    let maxscore = minscore;\\n    for(let i=0;i<k-1;i++){\\n        minscore+=pairsum[i];\\n        maxscore+=pairsum[len-i-2];\\n    }\\n    return maxscore-minscore;\\n};", "var putMarbles = function (weights, k) {\\n    let pairCosts = new Array(weights.length - 1);\\n\\n    "]}
{"id": "2225", "ref_js": ["var decodeMessage = function (key, message) {\\n\\tkey = convertKey(key);\\n\\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n\\tlet result = \"\";\\n\\tfor (const letter of message) {\\n\\t\\tlet index = key.indexOf(letter);\\n\\t\\tif (index === -1) result += \\' \\';\\n\\t\\telse result += alphabet[index];\\n\\t}\\n\\treturn result;\\n};", "var decodeMessage = function(key, message) {\\n  let result = \\'\\'\\n  key = Array.from(new Set(key.split(\\' \\').join(\\'\\')))\\n  const hash = new Map()\\n  const alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n  \\n  for (let i = 0; i < alpha.length; i++) {\\n    hash.set(key[i], alpha[i])\\n  }\\n\\n  for (let chr of message) {\\n    result += hash.get(chr) || \\' \\'\\n  }\\n    \\n  return result\\n};", "var decodeMessage = function (key, message) {\\n\\tkey = convertKey(key);\\n\\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n\\tlet result = \"\";\\n\\tfor (const letter of message) {\\n\\t\\tlet index = key.indexOf(letter);\\n\\t\\tif (index === -1) result += \\' \\';\\n\\t\\telse result += alphabet[index];\\n\\t}\\n\\treturn result;\\n};"]}
{"id": "2226", "ref_js": ["var minCost = function (basket1, basket2) {\\n  function addToMap(map, num) {\\n    let cnt = map.get(num) || 0;\\n    cnt++;\\n    map.set(num, cnt);\\n  }\\n\\n  function deleteFromMap(map, num) {\\n    let cnt = map.get(num) || 0;\\n    cnt--;\\n    map.set(num, cnt);\\n  }\\n\\n  let min = Number.MAX_SAFE_INTEGER;\\n  let map = new Map();\\n  for (let num of basket1) {\\n    addToMap(map, num);\\n    min = Math.min(min, num);\\n  }\\n  for (let num of basket2) {\\n    deleteFromMap(map, num);\\n    min = Math.min(min, num);\\n  }\\n\\n  for (let cnt of map.values()) {\\n    let abs = Math.abs(cnt);\\n    if (abs % 2 !== 0) return -1;\\n  }\\n\\n  let kvs = Array.from(map);\\n  kvs.sort((kv1, kv2) => kv1[0] - kv2[0]);\\n  let totalCount = kvs.reduce((prev, kv) => prev + Math.abs(kv[1]), 0);\\n\\n  let swaped = 0;\\n  let ans = 0;\\n  for (let i = 0; i < kvs.length; i++) {\\n    let [num, freq] = kvs[i];\\n    let half = Math.abs(freq) / 2;\\n    while (half-- > 0) {\\n      ans += Math.min(2 * min, num);\\n      swaped++;\\n      if (swaped === totalCount / 4) return ans;\\n    }\\n  }\\n  \\n  return 0;\\n};", "var minCost = function(basket1, basket2) {\\n\\n    let counts = new Map();\\n    let counts1 = new Map();\\n    let counts2 = new Map();\\n\\n    let add_count = (c, x) => {\\n        if (!c.has(x)) {\\n            c.set(x, 1);\\n        } else {\\n            c.set(x, c.get(x) + 1);\\n        }\\n    };", "var minCost = function(basket1, basket2) {\\n    const [map1, map2] = [new Map(), new Map()];\\n    let minVal = Number.MAX_SAFE_INTEGER;\\n    \\n    "]}
{"id": "2227", "ref_js": ["var minimumScore = function (SS, TT) {\\n  let s = SS.split(\"\"),\\n    t = TT.split(\"\");\\n  let lo = 0,\\n    hi = TT.length;\\n  while (lo <= hi) {\\n    let m = (lo + hi) >> 1;\\n    if (check(s, t, m)) hi = m - 1;\\n    else lo = m + 1;\\n  }\\n  return hi + 1;\\n};", "var minimumScore = function(S, T) {\\n    let s = S.split(\\'\\'), t = T.split(\\'\\');\\n    let lo = 0, hi = T.length;\\n    while (lo <= hi) {\\n        let m = Math.floor((lo + hi) / 2);\\n        if (check(s, t, m)) hi = m - 1;\\n        else lo = m + 1;\\n    }\\n    return hi + 1;\\n};", "var minimumScore = function (SS, TT) {\\n  let s = SS.split(\"\"),\\n    t = TT.split(\"\");\\n  let lo = 0,\\n    hi = TT.length;\\n  while (lo <= hi) {\\n    let m = (lo + hi) >> 1;\\n    if (check(s, t, m)) hi = m - 1;\\n    else lo = m + 1;\\n  }\\n  return hi + 1;\\n};"]}
{"id": "2228", "ref_js": ["var handleQuery = function (nums1, nums2, queries) {\\n  let n = nums1.length;\\n  let it = new IntervalTree(nums1);\\n  let sum = 0;\\n  for (let i = 0; i < n; i++) sum += nums2[i];\\n  let q = queries.length;\\n  n--;\\n  let res = [];\\n\\n  for (let i = 0; i < q; i++) {\\n    if (queries[i][0] == 1) {\\n      it.flip(queries[i][1], queries[i][2], 0, 0, n);\\n    } else if (queries[i][0] == 2) sum += it.cnt1() * queries[i][1];\\n    else res.push(sum);\\n  }\\n\\n  return res;\\n};", "var handleQuery = function(nums1, nums2, queries) {\\n  const segmentTree = new SegmentTree(nums1, nums2);\\n\\n  return queries.reduce((answers, [type, a, b]) => {\\n    switch (type) {\\n      case 1:\\n        segmentTree.query1(a, b);\\n        return answers;\\n      case 2:\\n        segmentTree.query2(a);\\n        return answers;\\n      default:\\n        answers.push(segmentTree.query3());\\n        return answers;\\n    }\\n  }, []);\\n};", "var handleQuery = function (nums1, nums2, queries) {\\n  let ans = [];\\n  let nums1Ones = 0;\\n  for (let val of nums1) \\n    if (val === 1) nums1Ones++;\\n  let type3Result = nums2.reduce((a, g) => a + g);\\n\\n  for (let query of queries) {\\n    let type = query[0];\\n    switch (type) {\\n      case 1:\\n        let [_, l, r] = query;\\n        let oldOnes = 0;\\n        let bitSum = r - l + 1;\\n        for (let i = l; i <= r; i++) {\\n          if (nums1[i] === 1) oldOnes++;\\n          nums1[i] = Math.abs(nums1[i] - 1);\\n        }\\n\\n        "]}
{"id": "2229", "ref_js": ["var findTheString = function (lcp) {\\n  let n = lcp.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let bound = n - i;\\n    ", "var findTheString = function (lcp) {\\n  let n = lcp.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let bound = n - i;\\n    ", "var findTheString = function (lcp) {\\n  let n = lcp.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let bound = n - i;\\n    "]}
{"id": "2230", "ref_js": ["var minimumTime = function(grid) {\\n    visited = new Set();\\n    ", "var minimumTime = function(grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n        return -1;\\n    }  \\n    const dp = new Array(grid.length).fill().map(_ => new Array(grid[0].length).fill());\\n    const dir = [1, 0, -1, 0, 1];\\n    const pq = new MinPriorityQueue({\\n        compare: (a, b) => a[0]-b[0]\\n    })\\n    pq.enqueue([0, 0, 0]);\\n    while (pq.size() > 0) {\\n        ", "var minimumTime = function(grid) {\\n    if (grid[0][1] > 1 && grid[1][0] > 1) {\\n        return -1;\\n    }  \\n    const dp = new Array(grid.length).fill().map(_ => new Array(grid[0].length).fill());\\n    const dir = [1, 0, -1, 0, 1];\\n    const pq = new MinPriorityQueue({\\n        compare: (a, b) => a[0]-b[0]\\n    })\\n    pq.enqueue([0, 0, 0]);\\n    while (pq.size() > 0) {\\n        "]}
{"id": "2231", "ref_js": ["var rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};", "var rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};", "var rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};"]}
{"id": "2232", "ref_js": ["var findValidSplit = function(nums) {\\n  let n = nums.length, right = {};", "var findValidSplit = function (a) {\\n    let n = a.length;\\n    let tp = 1n; ", "var findValidSplit = function(nums) {\\n  let n = nums.length, right = {};"]}
{"id": "2233", "ref_js": ["var minimumTime = function (time, totalTrips) {\\n  let maxTime = Math.min.apply(null, time) * totalTrips;\\n  let minTime = 1;\\n\\n  while (minTime < maxTime) {\\n    const midTime = Math.floor((minTime + maxTime) / 2);\\n    let trips = 0;\\n    for (const tripTime of time) {\\n      trips += Math.floor(midTime / tripTime);\\n    }\\n\\n    trips < totalTrips ? (minTime = midTime + 1) : (maxTime = midTime);\\n  }\\n\\n  return minTime;\\n};", "var minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};", "var minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};"]}
{"id": "2234", "ref_js": ["var findMinimumTime = function(tasks) {\\n    const maxTimeSlot = tasks.map(el => el[1]+1)\\n    const timeSlots = new Array(Math.max(...maxTimeSlot)).fill(false)\\n    tasks.sort((a,b) => a[1] - b[1])\\n\\n    for(const task of tasks) {\\n        let [start, end, duration] = task\\n\\n        for(let i = start; i <= end; i++) {\\n            duration -= Number(timeSlots[i])\\n        }\\n\\n        let time = end\\n\\n        while(duration > 0) {\\n            if(!timeSlots[time]) {\\n                timeSlots[time] = true\\n                duration--\\n            }\\n            time--\\n        }\\n    }\\n    return timeSlots.reduce((a,b) => a + Number(b), 0)\\n};", "var findMinimumTime = function(tasks) {\\n    const maxTimeSlot = tasks.map(el => el[1]+1)\\n    const timeSlots = new Array(Math.max(...maxTimeSlot)).fill(false)\\n    tasks.sort((a,b) => a[1] - b[1])\\n\\n    for(const task of tasks) {\\n        let [start, end, duration] = task\\n\\n        for(let i = start; i <= end; i++) {\\n            duration -= Number(timeSlots[i])\\n        }\\n\\n        let time = end\\n\\n        while(duration > 0) {\\n            if(!timeSlots[time]) {\\n                timeSlots[time] = true\\n                duration--\\n            }\\n            time--\\n        }\\n    }\\n    return timeSlots.reduce((a,b) => a + Number(b), 0)\\n};", "var findMinimumTime = function(tasks) {\\n    const maxTimeSlot = tasks.map(el => el[1]+1)\\n    const timeSlots = new Array(Math.max(...maxTimeSlot)).fill(false)\\n    tasks.sort((a,b) => a[1] - b[1])\\n\\n    for(const task of tasks) {\\n        let [start, end, duration] = task\\n\\n        for(let i = start; i <= end; i++) {\\n            duration -= Number(timeSlots[i])\\n        }\\n\\n        let time = end\\n\\n        while(duration > 0) {\\n            if(!timeSlots[time]) {\\n                timeSlots[time] = true\\n                duration--\\n            }\\n            time--\\n        }\\n    }\\n    return timeSlots.reduce((a,b) => a + Number(b), 0)\\n};"]}
{"id": "2235", "ref_js": ["var collectTheCoins = function(coins, edges) {\\n    const adj = getAdj(edges)\\n    let totalEdges = edges.length * 2 ", "var collectTheCoins = function(coins, edges) {\\n    const adj = getAdj(edges)\\n    let totalEdges = edges.length * 2 ", "var collectTheCoins = function(coins, edges) {\\n    const adj = getAdj(edges)\\n    let totalEdges = edges.length * 2 "]}
{"id": "2236", "ref_js": ["var findShortestCycle = function(n, edges) {\\n  const oo = 1000000000;\\n  let result = oo;\\n\\n  \\n  const graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let i = 0; i < edges.length; i++) {\\n    graph[edges[i][0]].push(edges[i][1]);\\n    graph[edges[i][1]].push(edges[i][0]);\\n  } \\n\\n  const q = new CircularQueue(n);\\n  const visited = Array(n);\\n  \\n  function bfs(fr, to) {\\n    visited.fill(0);\\n    q.clear();\\n    q.enqueue(fr);\\n    visited[fr] = 1;\\n\\n    while (q.size) {\\n      const curr = q.dequeue();\\n      const newVisited = visited[curr] + 1;\\n\\n      for (let next of graph[curr]) {\\n        if (visited[next]) continue;\\n        if (next === to) {\\n          if (curr === fr) continue;\\n          return newVisited;\\n        }\\n        q.enqueue(next);\\n        visited[next] = newVisited;\\n      }\\n    }\\n\\n    return oo;\\n  }\\n\\n  edges.forEach(edge => {\\n    result = Math.min(result, bfs(...edge));\\n  })\\n\\n  return result === oo? -1 : result;\\n};", "var findShortestCycle = function (n, edges) {\\n  let ans = Infinity;\\n  const graph = new Array(n).fill().map((_) => []);\\n\\n  for (const [v1, v2] of edges) {\\n    graph[v1].push(v2);\\n    graph[v2].push(v1);\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    ans = Math.min(ans, bfs(graph, i, n));\\n  }\\n\\n  return ans === Infinity ? -1 : ans;\\n};", "var findShortestCycle = function(n, edges) {\\n  const oo = 1000000000;\\n  let result = oo;\\n\\n  \\n  const graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let i = 0; i < edges.length; i++) {\\n    graph[edges[i][0]].push(edges[i][1]);\\n    graph[edges[i][1]].push(edges[i][0]);\\n  } \\n\\n  const q = new CircularQueue(n);\\n  const visited = Array(n);\\n  \\n  function bfs(fr, to) {\\n    visited.fill(0);\\n    q.clear();\\n    q.enqueue(fr);\\n    visited[fr] = 1;\\n\\n    while (q.size) {\\n      const curr = q.dequeue();\\n      const newVisited = visited[curr] + 1;\\n\\n      for (let next of graph[curr]) {\\n        if (visited[next]) continue;\\n        if (next === to) {\\n          if (curr === fr) continue;\\n          return newVisited;\\n        }\\n        q.enqueue(next);\\n        visited[next] = newVisited;\\n      }\\n    }\\n\\n    return oo;\\n  }\\n\\n  edges.forEach(edge => {\\n    result = Math.min(result, bfs(...edge));\\n  })\\n\\n  return result === oo? -1 : result;\\n};"]}
{"id": "2237", "ref_js": ["var buyChoco = function(prices, money) {\\n    let firstMinCost = Infinity;\\n    let secondMinCost = Infinity;\\n\\n    for (let p of prices) {\\n        if (p < firstMinCost) {\\n            secondMinCost = firstMinCost;\\n            firstMinCost = p;\\n        } else {\\n            secondMinCost = Math.min(secondMinCost, p);\\n        }\\n    }\\n\\n    let leftover = money - (firstMinCost + secondMinCost);\\n\\n    return leftover >= 0 ? leftover : money;    \\n};", "var buyChoco = function(arr, key) {\\n    let ans = Infinity;\\n        let fin;\\n\\n        for (let i = 0; i < arr.length; ++i) {\\n            for (let j = 0; j < arr.length; ++j) {\\n                if (i !== j) {\\n                    const sum = arr[i] + arr[j];\\n                    ans = Math.min(ans, sum);\\n                }\\n            }\\n        }\\n\\n        fin = key - ans;\\n        if(fin>=0){\\n        return fin;\\n        }\\n        else{\\n            return key;\\n        }\\n};", "var buyChoco = function(arr, key) {\\n    let ans = Infinity;\\n        let fin;\\n\\n        for (let i = 0; i < arr.length; ++i) {\\n            for (let j = 0; j < arr.length; ++j) {\\n                if (i !== j) {\\n                    const sum = arr[i] + arr[j];\\n                    ans = Math.min(ans, sum);\\n                }\\n            }\\n        }\\n\\n        fin = key - ans;\\n        if(fin>=0){\\n        return fin;\\n        }\\n        else{\\n            return key;\\n        }\\n};"]}
{"id": "2238", "ref_js": ["var minimumVisitedCells = function(grid) {\\n  let m = grid.length, n = grid[0].length;\\n  let dp = Array(m).fill(0).map(() => Array(n).fill(Infinity)), colStacks = Array(n).fill(0).map(() => []); ", "var minimumVisitedCells = function(grid) {\\n  let m = grid.length, n = grid[0].length;\\n  let dp = Array(m).fill(0).map(() => Array(n).fill(Infinity)), colStacks = Array(n).fill(0).map(() => []); ", "var minimumVisitedCells = function(grid) {\\n  let m = grid.length, n = grid[0].length;\\n  let dp = Array(m).fill(0).map(() => Array(n).fill(Infinity)), colStacks = Array(n).fill(0).map(() => []); "]}
{"id": "2241", "ref_js": ["var minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) {\\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) {\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};", "var minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) { ", "var minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) { "]}
{"id": "2243", "ref_js": ["var countOperationsToEmptyArray = function(nums) {\\n    var map = {};", "var countOperationsToEmptyArray = function(nums) {\\n  let n = nums.length, segTree = new SegmentTree(Array(n).fill(1));\\n  nums = nums.map((num, index) => [num, index]).sort((a, b) => a[0] - b[0]);\\n  let prevIndex = -1, ans = 0;\\n  for (let [_num, index] of nums) {\\n    if (index >= prevIndex) {\\n      ans += segTree.sumRange(prevIndex + 1, index);\\n    } else {\\n      ans += segTree.sumRange(prevIndex + 1, n - 1) + segTree.sumRange(0, index);\\n    }\\n    segTree.update(index);\\n    prevIndex = index;\\n  }\\n  return ans;\\n};", "var countOperationsToEmptyArray = function(arr) {\\n    const map = new Map(arr.map((val, i) => [val, i]))\\n    arr.sort((a,b) => a-b)\\n\\n    let prevIndex = -1\\n    let count = 0\\n    let ans = 0\\n    let multiplier = 1\\n\\n    for (let i=0; i<arr.length; i++) {\\n        const val = arr[i]\\n        const index = map.get(val)\\n\\n        if (index > prevIndex) {\\n           count++\\n        } else {\\n            ans += count * multiplier\\n            multiplier++ \\n            count = 1\\n        }\\n        if (i === arr.length - 1) {\\n            ans += count * multiplier\\n        }\\n\\n        prevIndex = index \\n    }\\n\\n    return ans\\n};"]}
{"id": "2244", "ref_js": ["var smallestBeautifulString = function(s, k) {\\n    let ch = s.split(\\'\\');\\n    let i = ch.length - 1;\\n    while (i >= 0) {\\n        ch[i] = String.fromCharCode(ch[i].charCodeAt(0) + 1);\\n        if (ch[i].charCodeAt(0) - \\'a\\'.charCodeAt(0) === k) {\\n            i--;\\n        } else if ((i - 1 < 0 || ch[i - 1] !== ch[i]) && (i - 2 < 0 || ch[i - 2] !== ch[i])) {\\n            break;\\n        }\\n    }\\n    if (i < 0) {\\n        return \\'\\';\\n    }\\n    for (let j = i + 1; j < ch.length; j++) {\\n        let set = new Set([\\'a\\', \\'b\\', \\'c\\']);\\n        if (j - 2 >= 0 && set.has(ch[j - 2])) {\\n            set.delete(ch[j - 2]);\\n        }\\n        if (j - 1 >= 0 && set.has(ch[j - 1])) {\\n            set.delete(ch[j - 1]);\\n        }\\n        ch[j] = Array.from(set)[0];\\n    }\\n    return ch.join(\\'\\');\\n};", "var smallestBeautifulString = function(s, k) {\\n   \\n  let chars = s.split(\"\");\\n\\n  for (let i = chars.length - 1; i >= 0; i--) {\\n    chars[i] = String.fromCharCode(chars[i].charCodeAt(0) + 1);\\n    while (containsPalindrome(chars, i)) {\\n      chars[i] = String.fromCharCode(chars[i].charCodeAt(0) + 1);\\n    }\\n    if (chars[i] < String.fromCharCode(\"a\".charCodeAt(0) + k)) {\\n      ", "var smallestBeautifulString = function(s, k) {\\n    const isValid = (i) => {\\n        return (i < 1 || s[i] !== s[i - 1]) && (i < 2 || s[i] !== s[i - 2])\\n    }\\n    \\n    s = s.split(\\'\\')\\n    \\n    for(let i = s.length - 1; i >= 0; i--) {\\n        let next = s[i].charCodeAt(0) + 1\\n        s[i] = String.fromCharCode(next)\\n        \\n        while(!isValid(i)) {\\n            next++\\n            s[i] = String.fromCharCode(next)\\n        }\\n        \\n        if(next < 97 + k) {\\n            for(i = i+1; i < s.length; i++) {\\n                let j = 97\\n                \\n                for(s[i] = String.fromCharCode(j); !isValid(i); j++) {\\n                    s[i] = String.fromCharCode(j)\\n                }\\n            }\\n\\n            return s.join(\\'\\')\\n        }\\n    }\\n    \\n    return \\'\\'\\n};"]}
{"id": "2245", "ref_js": ["var waysToMakeFair = function (nums) {\\n    let odds = 0;\\n    let evens = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2) odds += nums[i];\\n        else evens += nums[i];\\n    }\\n\\n    let preOdds = 0;\\n    let preEvens = 0;\\n    let postOdds = odds;\\n    let postEvens = evens;\\n    let totInd = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i % 2) postOdds -= nums[i];\\n        else postEvens -= nums[i];\\n\\n        if (preEvens + postOdds === preOdds + postEvens) {\\n            totInd++;\\n        }\\n\\n        if (i % 2) preOdds += nums[i];\\n        else preEvens += nums[i];\\n    }\\n\\n    return totInd;\\n};", "var waysToMakeFair = function (a) {\\n  let sumEvenRight = 0, sumOddRight = 0;\\n  for (let i = 0; i < a.length; i++)\\n    if (i % 2 === 0) sumEvenRight += a[i];\\n    else sumOddRight += a[i];\\n  let sumEvenLeft = 0, sumOddLeft = 0, count = 0;\\n  for (let i = 0; i < a.length; i++)\\n    if (i % 2 === 0) {\\n      sumEvenRight -= a[i];\\n      if (sumEvenLeft + sumOddRight === sumOddLeft + sumEvenRight) count++;\\n      sumEvenLeft += a[i];\\n    } else {\\n      sumOddRight -= a[i];\\n      if (sumEvenLeft + sumOddRight === sumOddLeft + sumEvenRight) count++;\\n      sumOddLeft += a[i];\\n    }\\n  return count;\\n};", "var waysToMakeFair = function (nums) {\\n\\n    "]}
{"id": "2246", "ref_js": ["var modifiedGraphEdges = function(n, edges, source, destination, target) {\\n  const kMax = 2000000000;\\n  const graph = Array(n).fill().map(() => []);\\n\\n  for (const [u, v, w] of edges) {\\n    if (w === -1) {\\n      continue;\\n    }\\n    graph[u].push([v, w]);\\n    graph[v].push([u, w]);\\n  }\\n\\n  const distToDestination = dijkstra(graph, source, destination);\\n  if (distToDestination < target) {\\n    return [];\\n  }\\n  if (distToDestination === target) {\\n    ", "var modifiedGraphEdges = function (n, edges, source, destination, target) {\\n    let map = getMap(edges)\\n    let dijMap = getDijMap(edges, map, source, destination, n)\\n\\n    ", "var modifiedGraphEdges = function(n, edges, source, destination, target) {\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        "]}
{"id": "2247", "ref_js": ["var canTraverseAllPairs = function(nums) {\\n  if (nums.length === 1) return true;\\n  if (nums.includes(1)) return false;\\n  const mx = Math.max(...nums) + 1;\\n  const sieve = Array.from({ length: mx }, (_, i) => i);\\n\\n  for (let i = 4; i < mx; i += 2) {\\n    sieve[i] = 2;\\n  }\\n\\n  for (let i = 3; i < Math.ceil(Math.sqrt(mx)); i++) {\\n    if (sieve[i] !== i) continue;\\n    for (let j = i * i; j < mx; j += i) {\\n      if (sieve[j] === j) {\\n        sieve[j] = i;\\n      }\\n    }\\n  }\\n\\n  function* factorize(num) {\\n    while (num !== 1) {\\n      yield sieve[num];\\n      num = Math.floor(num / sieve[num]);\\n    }\\n  }\\n\\n  const g = new Map();\\n  const seen = new Set();\\n\\n  for (const num of new Set(nums)) {\\n    for (const p of factorize(num)) {\\n      if (!g.has(num)) g.set(num, new Set());\\n      if (!g.has(p)) g.set(p, new Set());\\n      g.get(num).add(p);\\n      g.get(p).add(num);\\n    }\\n  }\\n\\n  const dq = [nums[0]];\\n  seen.add(nums[0]);\\n\\n  while (dq.length) {\\n    const num = dq.shift();\\n    for (const nxt of g.get(num)) {\\n      if (seen.has(nxt)) continue;\\n      seen.add(nxt);\\n      dq.push(nxt);\\n    }\\n  }\\n\\n  return seen.size === g.size;\\n};", "var canTraverseAllPairs = function(nums) {\\n  let n = nums.length, map = new Map(), uf = new UnionFind(n);\\n  for (let i = 0; i < n; i++) {\\n    let primeFactors = getPrimeFactors(nums[i]);\\n    for (let factor of primeFactors) {\\n      if (map.has(factor)) uf.union(i, map.get(factor));\\n      else map.set(factor, i);\\n    }\\n  }\\n  return uf.size === 1;\\n};", "var canTraverseAllPairs = function (nums) {\\n  if (nums.length === 1) return true;\\n\\n  const dset = new DisjointSets();\\n  for (let num of nums) {\\n    if (num === 1) return false;\\n    dset.add(...eratosthenesSieve[num]);\\n    dset.union(...eratosthenesSieve[num]);\\n  };"]}
{"id": "2248", "ref_js": ["var maxIncreasingCells = function(mat) {\\n    let max = 0;\\n\\n    const sort = [];\\n\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[i].length;j++){\\n            sort.push([i,j,mat[i][j]]);\\n        }\\n    }\\n\\n    sort.sort((a,b)=>b[2]-a[2]);\\n\\n    const rowDp = {};", "var maxIncreasingCells = function(mat) {\\n    let max = 0;\\n\\n    const sort = [];\\n\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[i].length;j++){\\n            sort.push([i,j,mat[i][j]]);\\n        }\\n    }\\n\\n    sort.sort((a,b)=>b[2]-a[2]);\\n\\n    const rowDp = {};", "var maxIncreasingCells = function(mat) {\\n    let max = 0;\\n\\n    const sort = [];\\n\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[i].length;j++){\\n            sort.push([i,j,mat[i][j]]);\\n        }\\n    }\\n\\n    sort.sort((a,b)=>b[2]-a[2]);\\n\\n    const rowDp = {};"]}
{"id": "2249", "ref_js": ["var count = function(num1, num2, min_sum, max_sum) {\\n    const modulo = 10**9 + 7\\n\\n    ", "var count = function(num1, num2, min_sum, max_sum) {\\n  let memo = new Map(), MOD = 10 ** 9 + 7;\\n  return dp(0, 1, 1, 0);\\n  \\n  function dp(i, state1, state2, digitSum) {\\n    if (i === num2.length) return state1 > 0 && state2 < 2 && digitSum >= min_sum && digitSum <= max_sum ? 1 : 0;\\n    let key = `${i},${state1},${state2},${digitSum}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = (i > num1.length || (i === num1.length && state1 > 0)) && digitSum >= min_sum && digitSum <= max_sum ? 1 : 0;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newState1 = getState(i, state1, digit, num1);\\n      let newState2 = getState(i, state2, digit, num2);\\n      ans = (ans + dp(i + 1, newState1, newState2, digitSum + digit)) % MOD;\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n  \\n  function getState(i, state, digit, num) {\\n    if (i >= num.length) return 2;\\n    if (state === 0 || state === 2) return state;\\n    if (digit > Number(num[i])) return 2;\\n    if (digit === Number(num[i])) return 1;\\n    return 0;\\n  }\\n};", "var count = function(num1, num2, min_sum, max_sum) {\\n  let memo = new Map(), MOD = 10 ** 9 + 7;\\n  return dp(0, 1, 1, 0);\\n  \\n  function dp(i, state1, state2, digitSum) {\\n    if (i === num2.length) return state1 > 0 && state2 < 2 && digitSum >= min_sum && digitSum <= max_sum ? 1 : 0;\\n    let key = `${i},${state1},${state2},${digitSum}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = (i > num1.length || (i === num1.length && state1 > 0)) && digitSum >= min_sum && digitSum <= max_sum ? 1 : 0;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newState1 = getState(i, state1, digit, num1);\\n      let newState2 = getState(i, state2, digit, num2);\\n      ans = (ans + dp(i + 1, newState1, newState2, digitSum + digit)) % MOD;\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n  \\n  function getState(i, state, digit, num) {\\n    if (i >= num.length) return 2;\\n    if (state === 0 || state === 2) return state;\\n    if (digit > Number(num[i])) return 2;\\n    if (digit === Number(num[i])) return 1;\\n    return 0;\\n  }\\n};"]}
{"id": "2250", "ref_js": ["var goodSubsetofBinaryMatrix = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const zeroIndexes = new Set();\\n    for (let i = 0 ; i < m ; i++) {\\n        let isOnlyZeroes = true;\\n        for (const num of grid[i]) {\\n            if (num !== 0) {\\n                isOnlyZeroes = false;\\n            }\\n        }\\n        if (isOnlyZeroes) {\\n            zeroIndexes.add(i);\\n        }\\n    }\\n    for (let i = 0 ; i < m; i++) {\\n        if (zeroIndexes.has(i)) {\\n            continue;\\n        }\\n        for (let j = i+1; j < m; j++) {\\n            if (zeroIndexes.has(j)) {\\n                continue\\n            }\\n            let validPair = true;\\n            for (let k = 0; k < n; k++) {\\n                if (grid[i][k] & grid[j][k] !== 0) {\\n                    validPair = false\\n                }\\n            }\\n            if (validPair) {\\n                return [i, j]\\n            }\\n        }\\n    }\\n    return [...zeroIndexes].sort((a, b) => a - b);\\n};", "var goodSubsetofBinaryMatrix = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const zeroIndexes = new Set();\\n    for (let i = 0 ; i < m ; i++) {\\n        let isOnlyZeroes = true;\\n        for (const num of grid[i]) {\\n            if (num !== 0) {\\n                isOnlyZeroes = false;\\n            }\\n        }\\n        if (isOnlyZeroes) {\\n            zeroIndexes.add(i);\\n        }\\n    }\\n    for (let i = 0 ; i < m; i++) {\\n        if (zeroIndexes.has(i)) {\\n            continue;\\n        }\\n        for (let j = i+1; j < m; j++) {\\n            if (zeroIndexes.has(j)) {\\n                continue\\n            }\\n            let validPair = true;\\n            for (let k = 0; k < n; k++) {\\n                if (grid[i][k] & grid[j][k] !== 0) {\\n                    validPair = false\\n                }\\n            }\\n            if (validPair) {\\n                return [i, j]\\n            }\\n        }\\n    }\\n    return [...zeroIndexes].sort((a, b) => a - b);\\n};", "var goodSubsetofBinaryMatrix = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const zeroIndexes = new Set();\\n    for (let i = 0 ; i < m ; i++) {\\n        let isOnlyZeroes = true;\\n        for (const num of grid[i]) {\\n            if (num !== 0) {\\n                isOnlyZeroes = false;\\n            }\\n        }\\n        if (isOnlyZeroes) {\\n            zeroIndexes.add(i);\\n        }\\n    }\\n    for (let i = 0 ; i < m; i++) {\\n        if (zeroIndexes.has(i)) {\\n            continue;\\n        }\\n        for (let j = i+1; j < m; j++) {\\n            if (zeroIndexes.has(j)) {\\n                continue\\n            }\\n            let validPair = true;\\n            for (let k = 0; k < n; k++) {\\n                if (grid[i][k] & grid[j][k] !== 0) {\\n                    validPair = false\\n                }\\n            }\\n            if (validPair) {\\n                return [i, j]\\n            }\\n        }\\n    }\\n    return [...zeroIndexes].sort((a, b) => a - b);\\n};"]}
{"id": "2251", "ref_js": ["var maximumSumQueries = function(nums1, nums2, queries) {\\n    const result = []\\n    const maxs = []\\n    const memc = {}\\n    for(let i = 0; i < nums1.length; i++){\\n        let x = nums1[i], y = nums2[i]\\n        maxs.push({x, y})\\n    }\\n    maxs.sort((a, b) => (b.x + b.y) - (a.x + a.y))\\n    nums1.sort((a, b) => b-a)\\n    nums2.sort((a, b) => b-a)\\n\\n    const mx = nums1[0]\\n    const my = nums2[0]\\n\\n    for(let j = 0; j < queries.length; j++){\\n        const q = queries[j]\\n        const qx = q[0], qy = q[1]\\n        const ck = qx + \",\" + qy\\n\\n        if(qx > mx || qy > my){\\n            memc[ck] = -1\\n            result.push(-1)\\n            continue;\\n        }\\n\\n        if(memc[ck]){\\n            result.push(memc[ck])\\n            continue\\n        }\\n\\n        result.push(-1)\\n        \\n        for(let i = 0; i < maxs.length; i++){\\n            const cs = maxs[i]\\n            if(qx <= cs.x && qy <= cs.y){\\n                memc[ck] = cs.x + cs.y\\n                result[result.length-1] = cs.x + cs.y\\n                break;\\n            }\\n        }\\n    }\\n\\n\\n    return result\\n};", "var maximumSumQueries = function (nums1, nums2, queries) {\\n  let n = nums1.length;\\n  let indices = new Uint32Array(n);\\n  for (let i = 0; i < n; i++) indices[i] = i;\\n\\n  indices.sort((a, b) => nums1[a] - nums1[b]);\\n  st.clear();\\n  st.push(indices[0]);\\n\\n  for (let i = 1; i < n; i++) {\\n    while (st.size && nums2[indices[i]] >= nums2[st.getLast()]) st.pop();\\n    st.push(indices[i]);\\n  }\\n\\n  n = st.size - 1;\\n  let it = new IntervalTree(st, nums1, nums2);\\n  let res = Array(queries.length).fill();\\n  for (let i = 0; i < queries.length; i++)\\n    res[i] = it.query(queries[i][0], queries[i][1], 0, 0, n);\\n\\n  return res;\\n};", "var maximumSumQueries = function(nums1, nums2, queries) {\\n    let n = nums1.length;\\n    let m = queries.length;\\n    function binarySearch(arr, l, r, x) {\\n        while (l < r) {\\n            let mid = Math.floor(l + (r-l)/2);\\n             if (arr[mid][0] < x) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return arr[l][0] >= x ? l : -1;\\n    }\\n    let pairArray = [];\\n    for (let i=0; i < nums1.length; i++) {\\n        pairArray.push([nums1[i], nums2[i]]);\\n    }\\n    let set = new Set();\\n    for(let y of nums2) {\\n        set.add(y);\\n    }\\n    for (let q of queries) {\\n        set.add(q[1]);\\n    }\\n    let sortedSet = [...set].sort((a, b) => a-b);\\n    let tdx = 0;\\n    let cord = {};"]}
{"id": "2252", "ref_js": ["var paintWalls = function(cost, time) {\\n    ", "var paintWalls = function(cost, time) {\\n     const n = cost.length;\\n        const dp = Array(n + 1).fill(Number.MAX_SAFE_INTEGER);\\n        dp[0] = 0;\\n\\n        for (let i = 0; i < n; i++) {\\n            for (let j = n; j >= 1; j--) {\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n            }\\n        }\\n        return dp[n];\\n};", "var paintWalls = function(cost, time) {\\n     const n = cost.length;\\n        const dp = Array(n + 1).fill(Number.MAX_SAFE_INTEGER);\\n        dp[0] = 0;\\n\\n        for (let i = 0; i < n; i++) {\\n            for (let j = n; j >= 1; j--) {\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n            }\\n        }\\n        return dp[n];\\n};"]}
{"id": "2253", "ref_js": ["var survivedRobotsHealths = function(positions, healths, directions) {\\n  let n = positions.length, stack = [], robots = [];\\n  for (let i = 0; i < n; i++) {\\n    robots.push({position: positions[i], health: healths[i], direction: directions[i], originalIndex: i})\\n  }\\n  robots.sort((a, b) => a.position - b.position); \\n  for (let i = 0; i < n; i++) {\\n    if (robots[i].direction === \\'L\\') {\\n      ", "var survivedRobotsHealths = function(positions, healths, directions) {\\n    ", "var survivedRobotsHealths = function(positions, healths, directions) {\\n    let solution = []\\n    let robots = []\\n    let customSort = {} "]}
{"id": "2254", "ref_js": ["var sumImbalanceNumbers = function (nums) {\\n  let res = 0;\\n  let n = nums.length;\\n\\n  let num;\\n  let cur;\\n  for (let r = 1; r < n; r++) {\\n    counters.fill(0, 0, n+2);\\n    num = nums[r];\\n    counters[num] = 1;\\n    cur = 0;\\n\\n    for (let l = r-1; l >= 0; l--) {\\n      num = nums[l];\\n\\n      if (!counters[num]) {\\n        counters[num] = 1;\\n        cur += 1;\\n\\n        if (counters[num+1]) cur--;\\n        if (counters[num-1]) cur--;\\n      }\\n\\n      res += cur;\\n    }\\n  }\\n\\n  return res;\\n};", "var sumImbalanceNumbers = function (nums) {\\n  let res = 0;\\n  let n = nums.length;\\n\\n  let num;\\n  let cur;\\n  for (let r = 1; r < n; r++) {\\n    counters.fill(0, 0, n+2);\\n    num = nums[r];\\n    counters[num] = 1;\\n    cur = 0;\\n\\n    for (let l = r-1; l >= 0; l--) {\\n      num = nums[l];\\n\\n      if (!counters[num]) {\\n        counters[num] = 1;\\n        cur += 1;\\n\\n        if (counters[num+1]) cur--;\\n        if (counters[num-1]) cur--;\\n      }\\n\\n      res += cur;\\n    }\\n  }\\n\\n  return res;\\n};", "var sumImbalanceNumbers = function (nums) {\\n  let res = 0;\\n  let n = nums.length;\\n\\n  let num;\\n  let cur;\\n  for (let r = 1; r < n; r++) {\\n    counters.fill(0, 0, n+2);\\n    num = nums[r];\\n    counters[num] = 1;\\n    cur = 0;\\n\\n    for (let l = r-1; l >= 0; l--) {\\n      num = nums[l];\\n\\n      if (!counters[num]) {\\n        counters[num] = 1;\\n        cur += 1;\\n\\n        if (counters[num+1]) cur--;\\n        if (counters[num-1]) cur--;\\n      }\\n\\n      res += cur;\\n    }\\n  }\\n\\n  return res;\\n};"]}
{"id": "2255", "ref_js": ["var longestValidSubstring = function (word, forbidden) {\\n  let ans = 0;\\n  const n = word.length;\\n  const set = new Set(forbidden);\\n  let right = n - 1;\\n\\n  for (let left = n - 1; left >= 0; left--) {\\n    let curr = \\'\\';\\n    for (let k = left; k < Math.min(left + 10, right + 1); k++) {\\n      curr += word[k];\\n      if (set.has(curr)) {\\n        right = k - 1;\\n        break;\\n      }\\n    }\\n    ans = Math.max(ans, right - left + 1);\\n  }\\n\\n  return ans;\\n};", "var longestValidSubstring = function (word, forbidden) {\\n  let ans = 0;\\n  const n = word.length;\\n  const set = new Set(forbidden);\\n  let right = n - 1;\\n\\n  for (let left = n - 1; left >= 0; left--) {\\n    let curr = \\'\\';\\n    for (let k = left; k < Math.min(left + 10, right + 1); k++) {\\n      curr += word[k];\\n      if (set.has(curr)) {\\n        right = k - 1;\\n        break;\\n      }\\n    }\\n    ans = Math.max(ans, right - left + 1);\\n  }\\n\\n  return ans;\\n};", "var longestValidSubstring = function (word, forbidden) {\\n  let ans = 0;\\n  const n = word.length;\\n  const set = new Set(forbidden);\\n  let right = n - 1;\\n\\n  for (let left = n - 1; left >= 0; left--) {\\n    let curr = \\'\\';\\n    for (let k = left; k < Math.min(left + 10, right + 1); k++) {\\n      curr += word[k];\\n      if (set.has(curr)) {\\n        right = k - 1;\\n        break;\\n      }\\n    }\\n    ans = Math.max(ans, right - left + 1);\\n  }\\n\\n  return ans;\\n};"]}
{"id": "2256", "ref_js": ["var maxIncreasingGroups = function(usageLimits) {\\n    usageLimits.sort((a, b) => a - b);\\n    let count = 0;\\n    let sum_limit = 0;\\n    \\n    for (let limit of usageLimits) {\\n        sum_limit += limit;\\n        \\n        if (sum_limit >= (count+1)*(count+2)/2) {\\n            count++;\\n        }\\n    }\\n\\n    return count;    \\n};", "var maxIncreasingGroups = function(usageLimits) {\\n    usageLimits.sort((a, b) => a - b);\\n    let count = 0;\\n    let sum_limit = 0;\\n    \\n    for (let limit of usageLimits) {\\n        sum_limit += limit;\\n        \\n        if (sum_limit >= (count+1)*(count+2)/2) {\\n            count++;\\n        }\\n    }\\n\\n    return count;    \\n};", "var maxIncreasingGroups = function(usageLimits) {\\n    usageLimits.sort((a, b) => a - b);\\n    let count = 0;\\n    let sum_limit = 0;\\n    \\n    for (let limit of usageLimits) {\\n        sum_limit += limit;\\n        \\n        if (sum_limit >= (count+1)*(count+2)/2) {\\n            count++;\\n        }\\n    }\\n\\n    return count;    \\n};"]}
{"id": "2257", "ref_js": ["var countPalindromePaths = function(parent, s) {\\n    const n = parent.length;\\n    const dp = Array(n).fill(0);\\n    let res = 0;\\n    const count = new Map();\\n\\n    function bit(parent, s, i) {\\n        if (i > 0 && dp[i] === 0)\\n            dp[i] = bit(parent, s, parent[i]) ^ (1 << (s.charCodeAt(i) - 97));\\n        return dp[i];\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        const mask = bit(parent, s, i);\\n        const v = count.get(mask) || 0;\\n        for (let j = 0; j < 26; j++)\\n            res += count.get(mask ^ (1 << j)) || 0;\\n        res += v;\\n        count.set(mask, v + 1);\\n    }\\n    \\n    return res;\\n};", "var countPalindromePaths = function(parent, s) {\\n  let n = parent.length;\\n  let dp = Array(n).fill(undefined);\\n  dp[0] = 0;\\n\\n  function getDp(x) {\\n    if (dp[x] != undefined) return dp[x];\\n    dp[x] = getDp(parent[x]) ^ getMask(s[x]);\\n    return dp[x];\\n  }\\n\\n  for (let i = 1; i < n; i++) getDp(i);\\n  dp.sort((a,b) => a - b);\\n  let counter = {};", "var countPalindromePaths = function(parent, s) {\\n  let n = parent.length;\\n  let dp = Array(n).fill(undefined);\\n  dp[0] = 0;\\n\\n  function getDp(x) {\\n    if (dp[x] != undefined) return dp[x];\\n    dp[x] = getDp(parent[x]) ^ getMask(s[x]);\\n    return dp[x];\\n  }\\n\\n  for (let i = 1; i < n; i++) getDp(i);\\n  dp.sort((a,b) => a - b);\\n  let counter = {};"]}
{"id": "2258", "ref_js": ["var countSteppingNumbers = function (low, high) {\\n  const dp = [];\\n  for (let i = 0; i < high.length; i++) dp.push(Array(11).fill(0));\\n\\n  \\n  function checkStepping(low) {\\n    for (let i = 1; i < low.length; i++) if (Math.abs(low[i].charCodeAt() - low[i - 1].charCodeAt()) !== 1) return 0;\\n    return 1;\\n  }\\n\\n  \\n  function calc(high) {\\n    let digit = high[0].charCodeAt() - 48;\\n    dp[0][0] = 0;\\n    for (let d = 1; d < 10; d++) {\\n      if (d < digit) dp[0][d] = 1;\\n      else if (d === digit) {\\n        dp[0][10] = 1;\\n        dp[0][d] = 0;\\n      }\\n      else dp[0][d] = 0;\\n    }\\n\\n    for (let i = 1; i < high.length; i++) {\\n      digit = high[i].charCodeAt() - 48;\\n\\n      dp[i][0] = 0;\\n      dp[i][10] = 0;\\n      for (let d = 1; d < 10; d++) dp[i][d] = 1;\\n      for (let d = 0; d < 10; d++) {\\n        if (d > 0) dp[i][d] = (dp[i][d] + dp[i - 1][d - 1]) % MOD;\\n        if (d < 9) dp[i][d] = (dp[i][d] + dp[i - 1][d + 1]) % MOD;\\n      }\\n      if (dp[i - 1][10]) {\\n        const preDigit = high[i - 1].charCodeAt() - 48;\\n        if (preDigit > 0 && preDigit - 1 <= digit) {\\n          if (preDigit - 1 === digit) dp[i][10] = 1;\\n          else dp[i][preDigit - 1] = (dp[i][preDigit - 1] + 1) % MOD;\\n        }\\n        if (preDigit < Math.min(9, digit)) {\\n          if (preDigit + 1 === digit) dp[i][10] = 1;\\n          else dp[i][preDigit + 1] = (dp[i][preDigit + 1] + 1) % MOD;\\n        }\\n      }\\n    }\\n\\n    let result = 0;\\n    for (let d = 0; d < 11; d++) result = (result + dp[high.length - 1][d]) % MOD;\\n    return result;\\n  }\\n\\n  return (calc(high) - calc(low) + checkStepping(low) + MOD) % MOD;\\n};", "var countSteppingNumbers = function(low, high) {\\n  let n = high.length, memo = Array(n).fill(0).map(() => Array(10).fill(0).map(() => Array(3).fill(0).map(() => Array(3).fill(-1)))); ", "var countSteppingNumbers = function (low, high) {\\n  const dp = [];\\n  for (let i = 0; i < high.length; i++) dp.push(Array(11).fill(0));\\n\\n  \\n  function checkStepping(low) {\\n    for (let i = 1; i < low.length; i++) if (Math.abs(low[i].charCodeAt() - low[i - 1].charCodeAt()) !== 1) return 0;\\n    return 1;\\n  }\\n\\n  \\n  function calc(high) {\\n    let digit = high[0].charCodeAt() - 48;\\n    dp[0][0] = 0;\\n    for (let d = 1; d < 10; d++) {\\n      if (d < digit) dp[0][d] = 1;\\n      else if (d === digit) {\\n        dp[0][10] = 1;\\n        dp[0][d] = 0;\\n      }\\n      else dp[0][d] = 0;\\n    }\\n\\n    for (let i = 1; i < high.length; i++) {\\n      digit = high[i].charCodeAt() - 48;\\n\\n      dp[i][0] = 0;\\n      dp[i][10] = 0;\\n      for (let d = 1; d < 10; d++) dp[i][d] = 1;\\n      for (let d = 0; d < 10; d++) {\\n        if (d > 0) dp[i][d] = (dp[i][d] + dp[i - 1][d - 1]) % MOD;\\n        if (d < 9) dp[i][d] = (dp[i][d] + dp[i - 1][d + 1]) % MOD;\\n      }\\n      if (dp[i - 1][10]) {\\n        const preDigit = high[i - 1].charCodeAt() - 48;\\n        if (preDigit > 0 && preDigit - 1 <= digit) {\\n          if (preDigit - 1 === digit) dp[i][10] = 1;\\n          else dp[i][preDigit - 1] = (dp[i][preDigit - 1] + 1) % MOD;\\n        }\\n        if (preDigit < Math.min(9, digit)) {\\n          if (preDigit + 1 === digit) dp[i][10] = 1;\\n          else dp[i][preDigit + 1] = (dp[i][preDigit + 1] + 1) % MOD;\\n        }\\n      }\\n    }\\n\\n    let result = 0;\\n    for (let d = 0; d < 11; d++) result = (result + dp[high.length - 1][d]) % MOD;\\n    return result;\\n  }\\n\\n  return (calc(high) - calc(low) + checkStepping(low) + MOD) % MOD;\\n};"]}
{"id": "2259", "ref_js": ["var minimumTime = function(nums1, nums2, x) {\\n    \\n", "var minimumTime = function(nums1, nums2, x) {\\n    \\n", "var minimumTime = function(nums1, nums2, x) {\\n    \\n"]}
{"id": "2260", "ref_js": ["var maximumElementAfterDecrementingAndRearranging = function(arr) {\\n    arr.sort((a, b) => a - b);\\n    let maxVal = 1;\\n\\n    for (let i = 1; i < arr.length; i++) {\\n        if (arr[i] > maxVal) {\\n            maxVal += 1;\\n        }\\n    }\\n\\n    return maxVal;    \\n};", "var maximumElementAfterDecrementingAndRearranging = function(arr) {\\n    arr.sort(function(a,b) {return a-b});\\n    arr[0] = 1;\\n    let bckp = arr[0];\\n    for(let i=1; i<arr.length; i++) {\\n        if(Math.abs(arr[i]-bckp) > 1) arr[i] = bckp + 1;\\n        bckp = arr[i];\\n    }\\n    return Math.max.apply(null, arr);\\n};", "var maximumElementAfterDecrementingAndRearranging = function(arr) {\\n    arr.sort(function(a,b) {return a-b});\\n    arr[0] = 1;\\n    let bckp = arr[0];\\n    for(let i=1; i<arr.length; i++) {\\n        if(Math.abs(arr[i]-bckp) > 1) arr[i] = bckp + 1;\\n        bckp = arr[i];\\n    }\\n    return Math.max.apply(null, arr);\\n};"]}
{"id": "2261", "ref_js": ["var maximumScore = function(nums, k) {\\n    let totalScore = 1n;\\n    const numsProps = nums.map((num) => [num, primeScore[num], 1]);\\n\\n    getNumsDominance(numsProps);\\n    numsProps.sort((b, a) => a[0] - b[0])\\n\\n    for (let i = k, j = 0; i > 0; j++) {\\n        const dominance = Math.min(i, numsProps[j][2]);\\n        i -= dominance;\\n        totalScore =\\n            totalScore * getPower(numsProps[j][0], dominance) % mod;\\n    }\\n    return totalScore;\\n};", "var maximumScore = function(nums, k) {\\n    let totalScore = 1n;\\n    const numsProps = nums.map((num) => [num, primeScore[num], 1]);\\n\\n    getNumsDominance(numsProps);\\n    numsProps.sort((b, a) => a[0] - b[0])\\n\\n    for (let i = k, j = 0; i > 0; j++) {\\n        const dominance = Math.min(i, numsProps[j][2]);\\n        i -= dominance;\\n        totalScore =\\n            totalScore * getPower(numsProps[j][0], dominance) % mod;\\n    }\\n    return totalScore;\\n};", "var maximumScore = function(nums, k) {\\n    let totalScore = 1n;\\n    const numsProps = nums.map((num) => [num, primeScore[num], 1]);\\n\\n    getNumsDominance(numsProps);\\n    numsProps.sort((b, a) => a[0] - b[0])\\n\\n    for (let i = k, j = 0; i > 0; j++) {\\n        const dominance = Math.min(i, numsProps[j][2]);\\n        i -= dominance;\\n        totalScore =\\n            totalScore * getPower(numsProps[j][0], dominance) % mod;\\n    }\\n    return totalScore;\\n};"]}
