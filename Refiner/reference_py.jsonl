{"id": "1", "ref_py": ["def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                if (i != j and nums[i] + nums[j] == target):\\n                    return [i, j]\\n        return []", "def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): ", "def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): "]}
{"id": "2", "ref_py": ["def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False", "def isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```", "def isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```"]}
{"id": "3", "ref_py": ["def romanToInt(self, s: str) -> int:\\n        romanValues = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000\\n        }", "def romanToInt(self, s: str) -> int:\\n        romanValues = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000\\n        }", "def romanToInt(self, s: str) -> int:\\n        romanValues = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000\\n        }"]}
{"id": "4", "ref_py": ["def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"\\n        prefix = strs[0]\\n        for string in strs[1:]:\\n            while string.find(prefix) != 0:\\n                prefix = prefix[:-1]\\n                if not prefix:\\n                    return \"\"\\n        return prefix\\n```", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"  "]}
{"id": "5", "ref_py": ["def isValid(self, s):\\n        stack = [] ", "def isValid(self, s):\\n        stack = [] ", "def isValid(self, s):\\n        "]}
{"id": "6", "ref_py": ["def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:   \\n        dummy = temp = ListNode(0)\\n        while l1 != None and l2 != None: ", "def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:   \\n        dummy = temp = ListNode(0)\\n        while l1 != None and l2 != None: ", "def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:   \\n        dummy = temp = ListNode(0)\\n        while l1 != None and l2 != None: "]}
{"id": "7", "ref_py": ["def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tnums[:] = sorted(set(nums))\\n\\t\\treturn len(nums)\\n```", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  ", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  "]}
{"id": "8", "ref_py": ["def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[k] = nums[i]\\n                k += 1\\n        return k\\n```\\n```javascript []\\nfunction removeElement(nums, val) {\\n    let k = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] !== val) {\\n            nums[k] = nums[i];\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n```", "def removeElement(self, nums, val):\\n        ", "def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[k] = nums[i]\\n                k += 1\\n        return k\\n```\\n```javascript []\\nfunction removeElement(nums, val) {\\n    let k = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] !== val) {\\n            nums[k] = nums[i];\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n```"]}
{"id": "9", "ref_py": ["def strStr(self, haystack: str, needle: str) -> int:\\n        m = len(needle)\\n        n = len(haystack)", "def strStr(self, haystack: str, needle: str) -> int:\\n        lps = [0] * len(needle)", "def strStr(self, haystack, needle):\\n        "]}
{"id": "10", "ref_py": ["def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1", "def searchInsert(self, nums, target):\\n        \\n        if target > nums[len(nums) - 1]:\\n            return len(nums)", "def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1"]}
{"id": "11", "ref_py": ["defines a class `Solution` with a method `lengthOfLastWord` that calculates the length of the last word in a given input string `s`. Here\\'s a brief explanation of each part of the code:", "def lengthOfLastWord(self, s):\\n        count = 0  ", "defines a class `Solution` with a method `lengthOfLastWord` that calculates the length of the last word in a given input string `s`. Here\\'s a brief explanation of each part of the code:"]}
{"id": "12", "ref_py": ["def plusOne(self, digits: List[int]) -> List[int]:", "def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)", "def plusOne(self, digits: List[int]) -> List[int]:"]}
{"id": "13", "ref_py": ["def addBinary(self, a: str, b: str) -> str:\\n    s = []\\n    carry = 0\\n    i = len(a) - 1\\n    j = len(b) - 1", "def addBinary(self, a: str, b: str) -> str:\\n        res = \"\"\\n        i, j, carry = len(a) - 1, len(b) - 1, 0\\n        while i >= 0 or j >= 0:\\n            sum = carry;\\n            if i >= 0 : sum += ord(a[i]) - ord(\\'0\\') ", "def addBinary(self, a, b):\\n        "]}
{"id": "14", "ref_py": ["def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"\\n        prefix = strs[0]\\n        for string in strs[1:]:\\n            while string.find(prefix) != 0:\\n                prefix = prefix[:-1]\\n                if not prefix:\\n                    return \"\"\\n        return prefix\\n```", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"  "]}
{"id": "15", "ref_py": ["defined recursively as: the total number of ways to climb `n-1` stairs + the total number of ways to climb `n-2` stairs.  Below is the recursive code:", "def climbStairs(self, n):\\n        \\n         def climb(n):\\n             if n==1: ", "defined recursively as: the total number of ways to climb `n-1` stairs + the total number of ways to climb `n-2` stairs.  Below is the recursive code:"]}
{"id": "16", "ref_py": ["def deleteDuplicates(self, head):\\n        temp = head\\n        while (temp and temp.next):\\n            if (temp.next.val == temp.val):\\n                temp.next = temp.next.next\\n                continue\\n            temp = temp.next\\n        return head\\n        \\n```", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def __init__(self, val=0, next=None):\\n"]}
{"id": "17", "ref_py": ["def merge(self, nums1, m, nums2, n):\\n        ", "def merge(self, nums1, m, nums2, n):\\n        ", "def merge(self, nums1, m, nums2, n):\\n        "]}
{"id": "18", "ref_py": ["def inorderTraversal(self, root):\\n        def helper(root,result):\\n          if root != None:\\n            helper(root.left,result)\\n            result.append(root.val)\\n            helper(root.right,result)  \\n            \\n        result = []\\n        helper(root,result)\\n        return result\\n```\\n```JavaScript []\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    helper(root, result);\\n    return result;\\n};", "def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        answer = []\\n        self.printInorder(root, answer)\\n        return answer\\n    \\n    def printInorder(self, node, answer):\\n        if node is None:\\n            return", "def inorderTraversal(self, root):\\n        def helper(root,result):\\n          if root != None:\\n            helper(root.left,result)\\n            result.append(root.val)\\n            helper(root.right,result)  \\n            \\n        result = []\\n        helper(root,result)\\n        return result\\n```\\n```JavaScript []\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    helper(root, result);\\n    return result;\\n};"]}
{"id": "19", "ref_py": ["def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        ", "def isSameTree(self, p, q):\\n        ", "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        "]}
{"id": "20", "ref_py": ["define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.", "def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)", "def isSymmetric(self, root):\\n        "]}
{"id": "21", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def maxDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "22", "ref_py": ["def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\\n        total_nums = len(nums)\\n        if not total_nums:\\n            return None", "def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\nclass Solution:\\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\\n        n = len(nums)", "def sortedArrayToBST(self, nums):\\n        "]}
{"id": "23", "ref_py": ["def isBalanced(self, root):\\n        return (self.Height(root) >= 0)\\n    def Height(self, root):\\n        if root is None:  return 0\\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\\n        return max(leftheight, rightheight) + 1\\n```\\n            \\n", "def isBalanced(self, root):\\n            \\n        def check(root):\\n            if root is None:\\n                return 0\\n            left  = check(root.left)\\n            right = check(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return 1 + max(left, right)\\n            \\n        return check(root) != -1", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "24", "ref_py": ["def minDepth(self, root):\\n        ", "def minDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque()\\n        queue.append(root)\\n        depth = 1\\n        \\n        while queue:\\n            size = len(queue)\\n            \\n            for _ in range(size):\\n                removed = queue.popleft()\\n                \\n                if not removed:\\n                    continue\\n                \\n                if not removed.left and not removed.right:\\n                    return depth\\n                \\n                if removed.left:\\n                    queue.append(removed.left)\\n                \\n                if removed.right:\\n                    queue.append(removed.right)\\n            \\n            depth += 1\\n        \\n        return 0\\n```", "def minDepth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque()\\n        queue.append(root)\\n        depth = 1\\n        \\n        while queue:\\n            size = len(queue)\\n            \\n            for _ in range(size):\\n                removed = queue.popleft()\\n                \\n                if not removed:\\n                    continue\\n                \\n                if not removed.left and not removed.right:\\n                    return depth\\n                \\n                if removed.left:\\n                    queue.append(removed.left)\\n                \\n                if removed.right:\\n                    queue.append(removed.right)\\n            \\n            depth += 1\\n        \\n        return 0\\n```"]}
{"id": "25", "ref_py": ["def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```C", "def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)", "def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```C"]}
{"id": "26", "ref_py": ["def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        prevRows = self.generate(numRows - 1)\\n        newRow = [1] * numRows\\n        \\n        for i in range(1, numRows - 1):\\n            newRow[i] = prevRows[-1][i - 1] + prevRows[-1][i]\\n        \\n        prevRows.append(newRow)\\n        return prevRows", "def generate(self, numRows):\\n        if numRows <= 0:\\n            return []\\n        \\n        triangle = []\\n        \\n        for i in range(numRows):\\n            row = [1] * (i + 1)\\n            \\n            if i >= 2:\\n                for j in range(1, i):\\n                    row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\\n            \\n            triangle.append(row)\\n        \\n        return triangle", "def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        prevRows = self.generate(numRows - 1)\\n        newRow = [1] * numRows\\n        \\n        for i in range(1, numRows - 1):\\n            newRow[i] = prevRows[-1][i - 1] + prevRows[-1][i]\\n        \\n        prevRows.append(newRow)\\n        return prevRows"]}
{"id": "27", "ref_py": ["def ncr(self, n, r, dp):\\n        if r == 0 or r == n:\\n            return 1\\n        if r == 1 or r == n - 1:\\n            return n\\n        if dp[n][r] != -1:\\n            return dp[n][r]\\n        dp[n][r] = self.ncr(n - 1, r, dp) + self.ncr(n - 1, r - 1, dp)\\n        return dp[n][r]", "def getRow(self, rowIndex: int) -> List[int]:\\n        ", "def getRow(self, rowIndex: int) -> List[int]:\\n        "]}
{"id": "28", "ref_py": ["def maxProfit(self,prices):\\n        left = 0 ", "def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices[1:]:\\n            max_profit = max(max_profit, price - min_price)\\n            min_price = min(min_price, price)\\n            \\n        return max_profit\\n```", "def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices[1:]:\\n            max_profit = max(max_profit, price - min_price)\\n            min_price = min(min_price, price)\\n            \\n        return max_profit\\n```"]}
{"id": "29", "ref_py": ["def isPalindrome(self, s: str) -> bool:\\n        l = 0\\n        r = len(s) - 1\\n        while l < r:\\n            if not s[l].isalnum():\\n                l += 1\\n            elif not s[r].isalnum():\\n                r -= 1\\n            elif s[l].lower() == s[r].lower():\\n                l += 1\\n                r -= 1\\n            else:\\n                return False", "def isPalindrome(self, s: str) -> bool:\\n        l = 0\\n        r = len(s) - 1\\n        while l < r:\\n            if not s[l].isalnum():\\n                l += 1\\n            elif not s[r].isalnum():\\n                r -= 1\\n            elif s[l].lower() == s[r].lower():\\n                l += 1\\n                r -= 1\\n            else:\\n                return False", "def isPalindrome(self, s: str) -> bool:\\n        l = 0\\n        r = len(s) - 1\\n        while l < r:\\n            if not s[l].isalnum():\\n                l += 1\\n            elif not s[r].isalnum():\\n                r -= 1\\n            elif s[l].lower() == s[r].lower():\\n                l += 1\\n                r -= 1\\n            else:\\n                return False"]}
{"id": "30", "ref_py": ["def singleNumber(self, nums):\\n        ", "def singleNumber(self, nums):\\n        ", "def singleNumber(self, nums):\\n        "]}
{"id": "31", "ref_py": ["def hasCycle(self, head):\\n        \\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False", "def hasCycle(self, head):\\n        \\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False", "def hasCycle(self, head):\\n        \\n        rabbit = head\\n        tortoise = head\\n        while rabbit and rabbit.next:\\n            rabbit = rabbit.next.next\\n            tortoise = tortoise.next\\n            if rabbit == tortoise:\\n                return True\\n        return False"]}
{"id": "32", "ref_py": ["defines a helper function preorder that traverses the tree in preorder and adds the node values to a vector. The main function preorderTraversal initializes an empty vector, calls the helper function to perform the traversal, and returns the vector containing the node values in preorder.", "def __init__(self, val=0, left=None, right=None):\\n", "defines a helper function preorder that traverses the tree in preorder and adds the node values to a vector. The main function preorderTraversal initializes an empty vector, calls the helper function to perform the traversal, and returns the vector containing the node values in preorder."]}
{"id": "33", "ref_py": ["def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)"]}
{"id": "34", "ref_py": ["def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while (a != b):\\n            a = headB if not a else a.next\\n            b = headA if not b else b.next\\n        return a\\n```", "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next", "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next"]}
{"id": "35", "ref_py": ["define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.", "def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)", "def isSymmetric(self, root):\\n        "]}
{"id": "36", "ref_py": ["def majorityElement(self, nums):\\n        ", "def majorityElement(self, nums):\\n        ", "def majorityElement(self, nums):\\n        "]}
{"id": "37", "ref_py": ["def str2num(s):\\n    res = 0\\n    for digit in s:\\n        res = res * 10 + int(digit)\\n    return res\\n```", "def titleToNumber(self, columnTitle):\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\\n            \\n", "def titleToNumber(self, columnTitle):\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\\n            \\n"]}
{"id": "42", "ref_py": ["def reverseBits(self, n: int) -> int:\\n        ", "def reverseBits(self, n: int) -> int:\\n        ", "def reverseBits(self, n: int) -> int:\\n        "]}
{"id": "43", "ref_py": ["def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\\'1\\')\\n```\\n```Ruby []\\nclass Solution\\n  def hamming_weight(n)\\n    n.to_s(2).count(\\'1\\')\\n  end\\nend", "def hammingWeight(self, n):\\n    return n.bit_count()\\n```\\n```Go []\\nimport \"math/bits\"", "def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\\'1\\')\\n```\\n```Ruby []\\nclass Solution\\n  def hamming_weight(n)\\n    n.to_s(2).count(\\'1\\')\\n  end\\nend"]}
{"id": "48", "ref_py": ["def isHappy(self, n):\\n        hset = set()\\n        while n != 1:\\n            if n in hset: return False\\n            hset.add(n)\\n            n = sum([int(i) ** 2 for i in str(n)])\\n        else:\\n            return True\\n```\\n            \\n", "def isHappy(self, n: int) -> bool:\\n        used = []", "def isHappy(self, n):\\n        hset = set()\\n        while n != 1:\\n            if n in hset: return False\\n            hset.add(n)\\n            n = sum([int(i) ** 2 for i in str(n)])\\n        else:\\n            return True\\n```\\n            \\n"]}
{"id": "49", "ref_py": ["def removeElements(self, head, val):\\n        \\n        \\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        current_node = dummy_head\\n        while current_node.next != None:\\n            if current_node.next.val == val:\\n                current_node.next = current_node.next.next\\n            else:\\n                current_node = current_node.next\\n                \\n        return dummy_head.next\\n```", "def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n        curr = dummy\\n        while curr.next:\\n            if curr.next.val == val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n```", "def removeElements(self, head, val):\\n        while head is not None and head.val == val:\\n            head = head.next"]}
{"id": "50", "ref_py": ["def isIsomorphic(self, s, t):\\n        map1 = []\\n        map2 = []\\n        for idx in s:\\n            map1.append(s.index(idx))\\n        for idx in t:\\n            map2.append(t.index(idx))\\n        if map1 == map2:\\n            return True\\n        return False\\n```\\n        \\n", "def isIsomorphic(self, s: str, t: str) -> bool:\\n        return len(set(s))==len(set(zip(s,t)))==len(set(t))\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def isIsomorphic(self, s: str, t: str) -> bool:\\n        zipped_set = set(zip(s, t))\\n        return len(zipped_set) == len(set(s)) == len(set(t))\\n        \\n```\\nExplanation:\\nwhy using zip ?\\n=> zip function would pair the first item of first iterator (i.e `s` here) to the first item of second iterator (i.e `t` here). `set()` would remove duplicate items from the zipped tuple. It is like the first item of first iterator mapped to the first item of second iterator as it would in case of a hashtable or dictionary.\\nUnderstand using exmaples:\\n```\\n"]}
{"id": "51", "ref_py": ["def reverseList(self, head):\\n        ", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def reverseList(self, head):\\n        "]}
{"id": "52", "ref_py": ["def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\\n                    \\n", "def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\\n                    \\n", "def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\\n                    \\n"]}
{"id": "53", "ref_py": ["def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}", "def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}", "def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}"]}
{"id": "54", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right", "def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right", "def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right"]}
{"id": "56", "ref_py": ["def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root: ", "def invertTree(self, root):\\n        ", "def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root: "]}
{"id": "57", "ref_py": ["def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []", "def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []", "def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []"]}
{"id": "58", "ref_py": ["def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        "]}
{"id": "60", "ref_py": ["def isPalindrome(self, head: ListNode) -> bool:\\n        slow, fast, prev = head, head, None\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n        prev, slow, prev.next = slow, slow.next, None\\n        while slow:\\n            slow.next, prev, slow = prev, slow, slow.next\\n        fast, slow = head, prev\\n        while slow:\\n            if fast.val != slow.val: return False\\n            fast, slow = fast.next, slow.next\\n        return True\\n```", "def isPalindrome(self, head):\\n        rev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            rev, rev.next, slow = slow, rev, slow.next\\n        if fast:\\n            slow = slow.next\\n        while rev and rev.val == slow.val:\\n            slow = slow.next\\n            rev = rev.next\\n        return not rev", "def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        global front\\n        front = head"]}
{"id": "61", "ref_py": ["def isAnagram(self, s, t):\\n        if len(s) != len(t):\\n            return False", "def isAnagram(self, s: str, t: str) -> bool:\\n        mp = {}\\n        mp2 = {}\\n        for i in s:\\n            mp[i] = mp.get(i, 0) + 1\\n        for i in t:\\n            mp2[i] = mp2.get(i, 0) + 1\\n        return mp == mp2", "def isAnagram(self, s, t):\\n        \\n        if len(s) != len(t):\\n            return False\\n        \\n        freq = [0] * 26\\n        for i in range(len(s)):\\n            freq[ord(s[i]) - ord(\\'a\\')] += 1\\n            freq[ord(t[i]) - ord(\\'a\\')] -= 1\\n        \\n        for i in range(len(freq)):\\n            if freq[i] != 0:\\n                return False\\n        \\n        return True"]}
{"id": "62", "ref_py": ["def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def dfs(node, path, result):\\n            if not node:\\n                return\\n            path += str(node.val)\\n            if not node.left and not node.right:\\n                result.append(path)\\n            else:\\n                dfs(node.left, path + \\'->\\', result)\\n                dfs(node.right, path + \\'->\\', result)", "def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    ", "def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def dfs(node, path, result):\\n            if not node:\\n                return\\n            path += str(node.val)\\n            if not node.left and not node.right:\\n                result.append(path)\\n            else:\\n                dfs(node.left, path + \\'->\\', result)\\n                dfs(node.right, path + \\'->\\', result)"]}
{"id": "63", "ref_py": ["def addDigits(self, num: int) -> int:\\n        if num == 0 : return 0\\n        if num % 9 == 0 : return 9\\n        else : return (num % 9)\\n```\\n* **Time Complexity :-** BigO(1)", "def addDigits(self, num: int) -> int:\\n        if num == 0 : return 0\\n        if num % 9 == 0 : return 9\\n        else : return (num % 9)\\n```\\n* **Time Complexity :-** BigO(1)", "def addDigits(self, num: int) -> int:\\n        if num == 0 : return 0\\n        if num % 9 == 0 : return 9\\n        else : return (num % 9)\\n```\\n* **Time Complexity :-** BigO(1)"]}
{"id": "64", "ref_py": ["def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n % 2 == 0:\\n            n //= 2\\n        while n % 3 == 0:\\n            n //= 3\\n        while n % 5 == 0:\\n            n //= 5\\n        return n == 1", "def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n % 2 == 0:\\n            n //= 2\\n        while n % 3 == 0:\\n            n //= 3\\n        while n % 5 == 0:\\n            n //= 5\\n        return n == 1", "def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n % 2 == 0:\\n            n //= 2\\n        while n % 3 == 0:\\n            n //= 3\\n        while n % 5 == 0:\\n            n //= 5\\n        return n == 1"]}
{"id": "65", "ref_py": ["def missingNumber(self, nums: List[int]) -> int:\\n  n = len(nums)\\n  return ((n * (n+1)) // 2 ) - sum(nums) ", "def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums) + 1\\n        total = (n * (n-1)) // 2\\n        \\n        for num in nums:\\n            total -= num\\n        \\n        return total\\n```\\n```Javascript []\\nvar missingNumber = function(nums) {\\n     let n = nums.length + 1;\\n        let total = (n * (n-1)) / 2;\\n        \\n        for (let num of nums) {\\n            total -= num;\\n        }\\n        \\n        return total;\\n};\\n```", "def missingNumber(self, nums: List[int]) -> int:\\n        nums.sort()"]}
{"id": "66", "ref_py": ["define the search range. We keep dividing the range in half and checking the middle point **mid**. If the **mid version is bad**, then we set the **new right boundary to mid**, effectively narrowing the search range. If the **mid version is not bad**, then we set the **new left boundary to mid + 1**, again narrowing the search range. The loop continues until **left and right become equal**, which means we have found the **first bad version**.", "defined for you.\\n", "define the search range. We keep dividing the range in half and checking the middle point **mid**. If the **mid version is bad**, then we set the **new right boundary to mid**, effectively narrowing the search range. If the **mid version is not bad**, then we set the **new left boundary to mid + 1**, again narrowing the search range. The loop continues until **left and right become equal**, which means we have found the **first bad version**."]}
{"id": "67", "ref_py": ["def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```", "def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```", "def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```"]}
{"id": "68", "ref_py": ["def wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  ", "def wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  ", "def wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  "]}
{"id": "69", "ref_py": ["def canWinNim(self, n: int) -> bool:\\n        ", "def canWinNim(self, n: int) -> bool:\\n        ", "def canWinNim(self, n: int) -> bool:\\n        "]}
{"id": "71", "ref_py": ["def isPowerOfThree(self, n: int) -> bool:\\n        return (n > 0) and 1162261467 % n == 0\\n```", "def isPowerOfThree(self, n):\\n        \\n        if n== 0: \\n            return False\\n        if n==1:\\n            return True\\n        \\n        while(n%3 == 0):\\n            n /= 3\\n            \\n        return n==1\\n        \\n```", "def isPowerOfThree(self, n: int) -> bool:\\n        return (n > 0) and 1162261467 % n == 0\\n```"]}
{"id": "72", "ref_py": ["def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```python []\\nclass Solution:\\n    def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```C", "def countBits(self, num: int) -> List[int]:\\n    counter = [0]\\n    for i in range(1, num+1):\\n        counter.append(counter[i >> 1] + i % 2)\\n    return counter\\n```", "def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```python []\\nclass Solution:\\n    def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```C"]}
{"id": "73", "ref_py": ["def isPowerOfFour(self, n):\\n        ", "def isPowerOfFour(self, n):\\n        ", "def isPowerOfFour(self, n):\\n        "]}
{"id": "74", "ref_py": ["def isPalindrome(self, head: ListNode) -> bool:\\n        slow, fast, prev = head, head, None\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n        prev, slow, prev.next = slow, slow.next, None\\n        while slow:\\n            slow.next, prev, slow = prev, slow, slow.next\\n        fast, slow = head, prev\\n        while slow:\\n            if fast.val != slow.val: return False\\n            fast, slow = fast.next, slow.next\\n        return True\\n```", "def isPalindrome(self, head):\\n        rev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            rev, rev.next, slow = slow, rev, slow.next\\n        if fast:\\n            slow = slow.next\\n        while rev and rev.val == slow.val:\\n            slow = slow.next\\n            rev = rev.next\\n        return not rev", "def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        global front\\n        front = head"]}
{"id": "75", "ref_py": ["def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        "]}
{"id": "76", "ref_py": ["def intersection(self, nums1, nums2):\\n        \\n        intersectingArray = []\\n        nums1.sort()\\n        nums2.sort()\\n        count1 = count2 = 0\\n        while (count1 < len(nums1) and count2 < len(nums2)):\\n            if nums1[count1] > nums2[count2]:\\n                count2 += 1\\n            elif nums1[count1] < nums2[count2]:\\n                count1 += 1\\n            else:\\n                sizeArrayHigh=len(intersectingArray)\\n                sizeArrayLow=len(intersectingArray)-1\\n                if not (sizeArrayHigh and nums1[count1] == intersectingArray[sizeArrayLow]):\\n                    intersectingArray.append(nums1[count1])\\n                count1 += 1\\n                count2 += 1", "def intersection(self, nums1, nums2):\\n        \\n        intersectingArray = []\\n        nums1.sort()\\n        nums2.sort()\\n        count1 = count2 = 0\\n        while (count1 < len(nums1) and count2 < len(nums2)):\\n            if nums1[count1] > nums2[count2]:\\n                count2 += 1\\n            elif nums1[count1] < nums2[count2]:\\n                count1 += 1\\n            else:\\n                sizeArrayHigh=len(intersectingArray)\\n                sizeArrayLow=len(intersectingArray)-1\\n                if not (sizeArrayHigh and nums1[count1] == intersectingArray[sizeArrayLow]):\\n                    intersectingArray.append(nums1[count1])\\n                count1 += 1\\n                count2 += 1", "def intersection(self, nums1, nums2):\\n        \\n        intersectingArray = []\\n        nums1.sort()\\n        nums2.sort()\\n        count1 = count2 = 0\\n        while (count1 < len(nums1) and count2 < len(nums2)):\\n            if nums1[count1] > nums2[count2]:\\n                count2 += 1\\n            elif nums1[count1] < nums2[count2]:\\n                count1 += 1\\n            else:\\n                sizeArrayHigh=len(intersectingArray)\\n                sizeArrayLow=len(intersectingArray)-1\\n                if not (sizeArrayHigh and nums1[count1] == intersectingArray[sizeArrayLow]):\\n                    intersectingArray.append(nums1[count1])\\n                count1 += 1\\n                count2 += 1"]}
{"id": "77", "ref_py": ["def intersect(self, nums1, nums2):", "def intersect(self, nums1, nums2):\\n        a, b = map(collections.Counter, (nums1, nums2))\\n        return list((a & b).elements())", "def intersect(self, nums1, nums2):\\n        a, b = map(collections.Counter, (nums1, nums2))\\n        return list((a & b).elements())"]}
{"id": "78", "ref_py": ["def isPerfectSquare(self, num: int) -> bool:\\n        if num == 1:\\n            return True", "def isPerfectSquare(self, num: int) -> bool:\\n        if num == 1:\\n            return True", "def isPerfectSquare(self, num: int) -> bool:\\n        if num == 1:\\n            return True"]}
{"id": "79", "ref_py": ["defined for you.\\n", "defined for you.\\n", "defined for you.\\n"]}
{"id": "80", "ref_py": ["def canConstruct(self, ransomNote, magazine):\\n        ", "def canConstruct(self, ransomNote: str, magazine: str) -> bool:\\n        return all(ransomNote.count(c) <= magazine.count(c) for c in set(ransomNote))", "def canConstruct(self, ransomNote, magazine):\\n        "]}
{"id": "81", "ref_py": ["def firstUniqChar(self, s):\\n        \\n        \\n        dictBag={}\\n        for char in range (len(s)):\\n            if s[char] not in dictBag:\\n                dictBag[s[char]]=1\\n            else:\\n                dictBag[s[char]]=-1\\n        for char in range(len(s)):\\n            if dictBag[s[char]]==1:\\n                return char\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```"]}
{"id": "82", "ref_py": ["def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) ", "def findTheDifference(self, s: str, t: str) -> str:\\n        char_count = {}\\n        \\n        ", "def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) "]}
{"id": "83", "ref_py": ["def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(s) > len(t):return False\\n        if len(s) == 0:return True\\n        subsequence=0\\n        for i in range(0,len(t)):\\n            if subsequence <= len(s) -1:\\n                print(s[subsequence])\\n                if s[subsequence]==t[i]:", "def isSubsequence(self, s, t):\\n        \\n        i = 0\\n        j = 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i+=1\\n            j+=1\\n        return True if i == len(s) else False\\n        \\n```\\n```C++ []\\nClass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.size() and j < t.size()) {\\n            if(s[i] == t[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return (i == s.size())?true:false;\\n    }\\n};\\n```", "def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            i = t.find(c)\\n            if i == -1:    return False\\n            else:   t = t[i+1:]\\n        return True\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "84", "ref_py": ["def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        output = []\\n        ", "def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        output = []\\n        ", "def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        output = []\\n        "]}
{"id": "85", "ref_py": ["def sumOfLeftLeaves(self, root):\\n        \\n        \\n        self.sum=0\\n        \\n        def depthFirstSeach(root):\\n            if root is None:\\n                return 0\\n            \\n            leftRoot=root.left\\n            rightRot=root.right\\n            \\n            if root.left:    \\n                leftLeave_ofLeft=root.left.left\\n                rightLeave_ofLeft=root.left.right\\n                value_ofLeft=root.left.val\\n                if leftLeave_ofLeft == None and rightLeave_ofLeft == None:\\n                    self.sum+=value_ofLeft      \\n                    \\n            depthFirstSeach(leftRoot)\\n            depthFirstSeach(rightRot)\\n            \\n        depthFirstSeach(root)\\n        return self.sum\\n```", "def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0", "def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0"]}
{"id": "86", "ref_py": ["def toHex(self, num: int) -> str:\\n    ", "def toHex(self, num: int) -> str:\\n    ", "def toHex(self, num: int) -> str:\\n    "]}
{"id": "87", "ref_py": ["def longestPalindrome(self, s: str) -> int:\\n        res = 0\\n        for i in collections.Counter(s).values():\\n            res += i // 2 * 2\\n        return min(res+1, len(s))\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def longestPalindrome(self, s: str) -> int:\\n        res = 0\\n        for i in collections.Counter(s).values():\\n            res += i // 2 * 2\\n        return min(res+1, len(s))\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def longestPalindrome(self, s: str) -> int:\\n        res = 0\\n        for i in collections.Counter(s).values():\\n            res += i // 2 * 2\\n        return min(res+1, len(s))\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "88", "ref_py": ["def fizzBuzz(self, n: int) -> List[str]:\\n        arr = []\\n\\t\\t\\n        for x in range(1, n + 1):\\n            if x % 15 == 0:\\n                arr.append(\\'FizzBuzz\\')\\n            elif x % 3 == 0:\\n                arr.append(\\'Fizz\\')\\n            elif x % 5 == 0:\\n                arr.append(\\'Buzz\\')\\n            else:\\n                arr.append(str(x))\\n\\t\\t\\t\\n        return arr\\n```\\nHowever, this is slow for many reasons. First, the % operator is costly. It\\'s a lot slower than most people would expect it to be. Second, the \"average\" case where it\\'s just a normal integer that you add to the list, you have to go through 4 % operators. This is extremely unnecessary.", "def fizzBuzz(self, n: int) -> List[str]:\\n        arr = []\\n\\t\\t\\n        for x in range(1, n + 1):\\n            if x % 15 == 0:\\n                arr.append(\\'FizzBuzz\\')\\n            elif x % 3 == 0:\\n                arr.append(\\'Fizz\\')\\n            elif x % 5 == 0:\\n                arr.append(\\'Buzz\\')\\n            else:\\n                arr.append(str(x))\\n\\t\\t\\t\\n        return arr\\n```\\nHowever, this is slow for many reasons. First, the % operator is costly. It\\'s a lot slower than most people would expect it to be. Second, the \"average\" case where it\\'s just a normal integer that you add to the list, you have to go through 4 % operators. This is extremely unnecessary.", "def fizzBuzz(self, n: int) -> List[str]:\\n        arr = []\\n\\t\\t\\n        for x in range(1, n + 1):\\n            if x % 15 == 0:\\n                arr.append(\\'FizzBuzz\\')\\n            elif x % 3 == 0:\\n                arr.append(\\'Fizz\\')\\n            elif x % 5 == 0:\\n                arr.append(\\'Buzz\\')\\n            else:\\n                arr.append(str(x))\\n\\t\\t\\t\\n        return arr\\n```\\nHowever, this is slow for many reasons. First, the % operator is costly. It\\'s a lot slower than most people would expect it to be. Second, the \"average\" case where it\\'s just a normal integer that you add to the list, you have to go through 4 % operators. This is extremely unnecessary."]}
{"id": "89", "ref_py": ["def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```", "def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```", "def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```"]}
{"id": "90", "ref_py": ["def isSubsequence(self, s: str, t: str) -> bool:\\n        if len(s) > len(t):return False\\n        if len(s) == 0:return True\\n        subsequence=0\\n        for i in range(0,len(t)):\\n            if subsequence <= len(s) -1:\\n                print(s[subsequence])\\n                if s[subsequence]==t[i]:", "def isSubsequence(self, s, t):\\n        \\n        i = 0\\n        j = 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i+=1\\n            j+=1\\n        return True if i == len(s) else False\\n        \\n```\\n```C++ []\\nClass Solution {\\npublic:\\n    bool isSubsequence(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.size() and j < t.size()) {\\n            if(s[i] == t[j]){\\n                i++;\\n            }\\n            j++;\\n        }\\n        return (i == s.size())?true:false;\\n    }\\n};\\n```", "def isSubsequence(self, s: str, t: str) -> bool:\\n        for c in s:\\n            i = t.find(c)\\n            if i == -1:    return False\\n            else:   t = t[i+1:]\\n        return True\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "91", "ref_py": ["def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def dfs(node, path, result):\\n            if not node:\\n                return\\n            path += str(node.val)\\n            if not node.left and not node.right:\\n                result.append(path)\\n            else:\\n                dfs(node.left, path + \\'->\\', result)\\n                dfs(node.right, path + \\'->\\', result)", "def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    ", "def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def dfs(node, path, result):\\n            if not node:\\n                return\\n            path += str(node.val)\\n            if not node.left and not node.right:\\n                result.append(path)\\n            else:\\n                dfs(node.left, path + \\'->\\', result)\\n                dfs(node.right, path + \\'->\\', result)"]}
{"id": "92", "ref_py": ["def arrangeCoins(self, n: int) -> int:\\n        completeStairs = 0\\n        \\n        ", "def arrangeCoins(self, n: int) -> int:\\n        ", "def arrangeCoins(self, n: int) -> int:\\n        completeStairs = 0\\n        \\n        "]}
{"id": "93", "ref_py": ["def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        ", "def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        ", "def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        "]}
{"id": "94", "ref_py": ["def findContentChildren(self, g, s):\\n        g.sort() ", "def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        i, j = 0, 0\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                i += 1\\n            j += 1\\n        return i", "def findContentChildren(self, g, s):\\n        g.sort() "]}
{"id": "95", "ref_py": ["def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        s_fold = \"\".join( (s[1:], s[:-1]) )\\n        \\n        return s in s_fold\\n```", "defines a class `Solution` with a method `repeatedSubstringPattern` that checks if a given string `s` can be formed by repeating a substring within itself.", "def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        lps = [0] * n\\n        \\n        len = 0\\n        \\n        for i in range(1, n):\\n            while len > 0 and s[i] != s[len]:\\n                len = lps[len - 1]\\n            if s[i] == s[len]:\\n                len += 1\\n            lps[i] = len\\n        \\n        pattern_len = n - lps[n - 1]\\n        \\n        return pattern_len != n and n % pattern_len == 0"]}
{"id": "96", "ref_py": ["def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root: ", "def invertTree(self, root):\\n        ", "def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if not root: "]}
{"id": "97", "ref_py": ["def islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t  R,C = len(grid), len(grid[0])\\n      perimeter = 0\\n\\t  ", "def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ", "def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m,n,visited = len(grid), len(grid[0]), set()\\n        \\n        def dfs(i,j):\\n            if (i,j) in visited: return 0\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j] == 0: return 1\\n"]}
{"id": "98", "ref_py": ["def findComplement(self, num: int) -> int:\\n        ", "def findComplement(self, num: int) -> int:\\n        ", "def findComplement(self, num: int) -> int:\\n        "]}
{"id": "99", "ref_py": ["def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        \\n        ", "def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        ", "def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        "]}
{"id": "100", "ref_py": ["def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        l, zeros = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > 0:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        \\n        return r - l + 1\\n```\\n", "def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        l, zeros = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > 0:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        \\n        return r - l + 1\\n```\\n", "def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        l, zeros = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > 0:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        \\n        return r - l + 1\\n```\\n"]}
{"id": "101", "ref_py": ["def constructRectangle(self, area: int) -> List[int]:\\n        ", "def constructRectangle(self, area: int) -> List[int]:\\n        ", "def constructRectangle(self, area: int) -> List[int]:\\n        "]}
{"id": "102", "ref_py": ["def findPoisonedDuration(self, timeSeries, duration):\\n        \\n        t=0\\n        poisonedSeconds = duration * len(timeSeries)\\n        \\n        for time in range(1,len(timeSeries)):\\n            timeInterval=timeSeries[time]\\n            timeInterval_prev=timeSeries[time-1]\\n            poisonedSeconds -= max(t, duration - (timeInterval - timeInterval_prev))\\n            \\n        return poisonedSeconds\\n```", "defining a function findPoisonedDuration that takes in two arguments - a list timeSeries containing non-decreasing integers and an integer duration.", "defining a function findPoisonedDuration that takes in two arguments - a list timeSeries containing non-decreasing integers and an integer duration."]}
{"id": "103", "ref_py": ["def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n\\tif not nums2:\\n\\t\\treturn None", "def nextGreaterElement(self, nums1, nums2):\\n        ans = []\\n        for i in range(len(nums1)):\\n            max_num = -1\\n            for j in range(len(nums2)):\\n                index = j\\n                if nums1[i] == nums2[j]: ", "def nextGreaterElement(self, nums1, nums2):\\n        ans = []\\n        for i in range(len(nums1)):\\n            max_num = -1\\n            for j in range(len(nums2)):\\n                index = j\\n                if nums1[i] == nums2[j]: "]}
{"id": "104", "ref_py": ["def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False", "def isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```", "def isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```"]}
{"id": "105", "ref_py": ["def inorder(root):\\n                if not root:\\n                    return\\n                inorder(root.left)\\n                .... store/use value here : root.val ....\\n                inorder(root.right)", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self):\\n        self.mp = {}"]}
{"id": "106", "ref_py": ["def convertToBase7(self, num: int) -> str:\\n        ", "def convertToBase7(self, num: int) -> str:\\n        ", "def convertToBase7(self, num: int) -> str:\\n        "]}
{"id": "107", "ref_py": ["def findRelativeRanks(self, score: List[int]) -> List[str]:\\n        rank = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] + list(map(str, range(4, len(score) + 1)))\\n        place = sorted(score, reverse = True)\\n        d = dict(zip(place, rank))", "def findRelativeRanks(self, score: List[int]) -> List[str]:\\n        rank = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] + list(map(str, range(4, len(score) + 1)))\\n        place = sorted(score, reverse = True)\\n        d = dict(zip(place, rank))", "def findRelativeRanks(self, score: List[int]) -> List[str]:\\n        rank = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] + list(map(str, range(4, len(score) + 1)))\\n        place = sorted(score, reverse = True)\\n        d = dict(zip(place, rank))"]}
{"id": "108", "ref_py": ["def checkPerfectNumber(self, num: int) -> bool:\\n        ", "def checkPerfectNumber(self, num: int) -> bool:\\n        ", "def checkPerfectNumber(self, num: int) -> bool:\\n        "]}
{"id": "109", "ref_py": ["def fib(self, n):\\n        \\n        if n==0:\\n            return 0\\n        elif n==1:\\n            return 1\\n        else:\\n            return self.fib(n-1)+self.fib(n-2)\\n", "def fib(self, n):\\n        \\n        if n==0:\\n            return 0\\n        elif n==1:\\n            return 1\\n        else:\\n            return self.fib(n-1)+self.fib(n-2)\\n", "def fib(self, n):\\n        \\n        if n==0:\\n            return 0\\n        elif n==1:\\n            return 1\\n        else:\\n            return self.fib(n-1)+self.fib(n-2)\\n"]}
{"id": "111", "ref_py": ["def detectCapitalUse(self, word: str) -> bool:\\n        if len(word)<2: return True\\n        pattern = \\'[A-Z][A-Z]+|[a-z][a-z]+|[A-Z][a-z]*\\'\\n        m = re.match(pattern, word)\\n        if not m: return False\\n        return m.span()==(0, len(word))\\n```", "def detectCapitalUse(self, word: str) -> bool:\\n        ", "def detectCapitalUse(self, word: str) -> bool:\\n        if len(word)<2: return True\\n        pattern = \\'[A-Z][A-Z]+|[a-z][a-z]+|[A-Z][a-z]*\\'\\n        m = re.match(pattern, word)\\n        if not m: return False\\n        return m.span()==(0, len(word))\\n```"]}
{"id": "112", "ref_py": ["def findLUSlength(self, a: str, b: str) -> int:\\n        ", "def findLUSlength(self, a: str, b: str) -> int:\\n\\tdef isSub(x, y):\\n\\t\\ti = j = 0\\n\\t\\twhile(i<len(x) and j<len(y)):\\n\\t\\t\\tif(x[i] == y[j]):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tj += 1\\n\\t\\treturn i != len(x)\\n\\tt1, t2 = isSub(a, b), isSub(b, a)\\n\\tif(t1 and t2):\\n\\t\\treturn max(len(a), len(b))\\n\\tif(t1):\\n\\t\\treturn len(a)\\n\\tif(t2):\\n\\t\\treturn len(b)\\n", "def findLUSlength(self, a: str, b: str) -> int:\\n        "]}
{"id": "113", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "114", "ref_py": ["def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))"]}
{"id": "115", "ref_py": ["def depth(node: Optional[TreeNode]) -> int:\\n    \\n\\t", "def diameterOfBinaryTree(self, root):\\n        \\n        if root is None:\\n            return 0\\n        \\n        left_height=self.height(root.left)\\n        right_height=self.height(root.right)\\n        \\n        left_diameter=self.diameterOfBinaryTree(root.left)\\n        right_diameter=self.diameterOfBinaryTree(root.right)\\n        \\n        return max((left_height+right_height), max(left_diameter,right_diameter))\\n        \\n    \\n    def height(self,root):\\n        if root is None:\\n            return 0\\n        \\n        else:\\n            left_height=self.height(root.left)\\n            right_height=self.height(root.right)\\n        \\n            return 1 + max(left_height, right_height)\\n```", "def depth(node: Optional[TreeNode]) -> int:\\n    \\n\\t"]}
{"id": "116", "ref_py": ["def checkRecord(self, s):\\n        isLate = False\\n        absent = 0", "def checkRecord(self, s: str) -> bool:\\n        ", "def checkRecord(self, s: str) -> bool:\\n\\treturn False if \"LLL\" in s or s.count(\\'A\\') >= 2 else True\\n```"]}
{"id": "117", "ref_py": ["default whitespace delimiter. This creates a list of words from the input string.", "def reverseWords(self, s: str) -> str:\\n        n = len(s)\\n        i = 0\\n        j = 0\\n        while j < n:\\n            if s[j] == \\' \\':\\n                s = s[:i] + s[i:j][::-1] + s[j:]\\n                i = j + 1\\n            if j == n - 1:\\n                s = s[:i] + s[i:j+1][::-1]\\n            j += 1\\n        return s\\n```", "def reverseWords(self, s):\\n        \\n        words = s.split()\\n        \\n        reversed_words = [word[::-1] for word in words]\\n        \\n        reversed_s = \\' \\'.join(reversed_words)\\n        \\n        return reversed_s\\n```"]}
{"id": "118", "ref_py": ["def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth"]}
{"id": "119", "ref_py": ["def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n\\tif not nums2:\\n\\t\\treturn None", "def nextGreaterElement(self, nums1, nums2):\\n        ans = []\\n        for i in range(len(nums1)):\\n            max_num = -1\\n            for j in range(len(nums2)):\\n                index = j\\n                if nums1[i] == nums2[j]: ", "def nextGreaterElement(self, nums1, nums2):\\n        ans = []\\n        for i in range(len(nums1)):\\n            max_num = -1\\n            for j in range(len(nums2)):\\n                index = j\\n                if nums1[i] == nums2[j]: "]}
{"id": "120", "ref_py": ["def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.total_tilt = 0\\n        \\n        def calculate_tilt(node):\\n            if not node:\\n                return 0\\n            \\n            left_sum = calculate_tilt(node.left)\\n            right_sum = calculate_tilt(node.right)\\n            tilt = abs(left_sum - right_sum)\\n            \\n            self.total_tilt += tilt\\n            \\n            return left_sum + right_sum + node.val\\n        \\n        calculate_tilt(root)\\n        return self.total_tilt", "def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n", "def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n"]}
{"id": "121", "ref_py": ["def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flatten = []\\n        new_mat = []\\n        for row in mat:\\n            for num in row:\\n                flatten.append(num)\\n                \\n        if r * c != len(flatten):   ", "def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        ", "def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\\n        flatten = []\\n        new_mat = []\\n        for row in mat:\\n            for num in row:\\n                flatten.append(num)\\n                \\n        if r * c != len(flatten):   "]}
{"id": "122", "ref_py": ["def isSubtree(self, root, subRoot):\\n         \\n        if root is None and subRoot is None:\\n            return True\\n        if subRoot is None:\\n            return True\\n        if root is None and subRoot is not None:\\n            return False\\n        return self.isSame(root,subRoot) or self.isSubtree(root.left,subRoot) or self.isSubtree(root.right,subRoot)", "def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:\\n        if not s: \\n            return False\\n        if self.isSameTree(s, t): \\n            return True\\n        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)", "def isSubtree(self, root, subRoot):\\n         \\n        if root is None and subRoot is None:\\n            return True\\n        if subRoot is None:\\n            return True\\n        if root is None and subRoot is not None:\\n            return False\\n        return self.isSame(root,subRoot) or self.isSubtree(root.left,subRoot) or self.isSubtree(root.right,subRoot)"]}
{"id": "123", "ref_py": ["def distributeCandies(self, candyType: List[int]) -> int:\\n        seen = {}\\n        i = 0\\n        amount_allowed = 0\\n        while(i<len(candyType) and amount_allowed<len(candyType)//2):\\n            if seen.get(candyType[i],0)==0:\\n                amount_allowed+=1\\n                seen[candyType[i]] = 1\\n            i+=1\\n        return amount_allowed", "def distributeCandies(self, candyType: List[int]) -> int:\\n        ", "def distributeCandies(self, candyType: List[int]) -> int:\\n        seen = {}\\n        i = 0\\n        amount_allowed = 0\\n        while(i<len(candyType) and amount_allowed<len(candyType)//2):\\n            if seen.get(candyType[i],0)==0:\\n                amount_allowed+=1\\n                seen[candyType[i]] = 1\\n            i+=1\\n        return amount_allowed"]}
{"id": "127", "ref_py": ["def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"", "define a separate recursive helper. In order to accomplish this, we\\'ll need to create a new **default argument** for the function to hold our answer array (**ans**), which should default to an empty array.", "def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\""]}
{"id": "128", "ref_py": ["def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        res = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            res.append(node.val)\\n            \\n            for child in node.children:\\n                stack.append(child)\\n                \\n        return res[::-1]", "def iterative(self, root):\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        while len(stack):\\n            top = stack.pop()\\n            out.append(top.val)\\n            stack.extend(top.children or [])\\n        return out[::-1]\\n \\n            \\n```\\n\\t\\t\\t\\n\\t\\t\\t\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                for c in root.children:\\n                    rec(c)\\n                out.append(root.val)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n\\t\\t\\n", "def iterative(self, root):\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        while len(stack):\\n            top = stack.pop()\\n            out.append(top.val)\\n            stack.extend(top.children or [])\\n        return out[::-1]\\n \\n            \\n```\\n\\t\\t\\t\\n\\t\\t\\t\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                for c in root.children:\\n                    rec(c)\\n                out.append(root.val)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n\\t\\t\\n"]}
{"id": "129", "ref_py": ["def findLHS(self, nums: List[int]) -> int:\\n        freq = Counter(nums)\\n        max_length = 0\\n        \\n        for key in freq:\\n            if key + 1 in freq:\\n                max_length = max(max_length, freq[key] + freq[key+1])\\n                \\n        return max_length", "def findLHS(self, nums: List[int]) -> int:\\n        freq = Counter(nums)\\n        max_length = 0\\n        \\n        for key in freq:\\n            if key + 1 in freq:\\n                max_length = max(max_length, freq[key] + freq[key+1])\\n                \\n        return max_length", "def findLHS(self, nums: List[int]) -> int:\\n        freq = Counter(nums)\\n        max_length = 0\\n        \\n        for key in freq:\\n            if key + 1 in freq:\\n                max_length = max(max_length, freq[key] + freq[key+1])\\n                \\n        return max_length"]}
{"id": "132", "ref_py": ["def maxCount(self, m, n, ops):\\n        for i,j in ops:\\n            m,n = min(i,m), min(j,n)\\n        return m*n", "def maxCount(self, m, n, ops):\\n        for i,j in ops:\\n            m,n = min(i,m), min(j,n)\\n        return m*n", "def maxCount(self, m, n, ops):\\n        for i,j in ops:\\n            m,n = min(i,m), min(j,n)\\n        return m*n"]}
{"id": "133", "ref_py": ["def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```", "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = set(list1) & set(list2)  ", "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```"]}
{"id": "134", "ref_py": ["def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False", "def canPlaceFlowers(self, flowerbed, n):\\n        if n == 0: return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):  ", "def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False"]}
{"id": "135", "ref_py": ["def tree2str(self, root):\\n        if root is None:\\n            return \"\"", "def tree2str(self, t):\\n        res = []\\n        self.dfs(t, res)\\n        return \\'\\'.join(res)", "def tree2str(self, root):\\n        if root is None:\\n            return \"\""]}
{"id": "138", "ref_py": ["defined**, we can simply return the other node.\\n- **If the 2 nodes are not defined**, we can finish the recursion.", "defined**, we can simply return the other node.\\n- **If the 2 nodes are not defined**, we can finish the recursion.", "defined**, we can simply return the other node.\\n- **If the 2 nodes are not defined**, we can finish the recursion."]}
{"id": "142", "ref_py": ["def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False", "def canPlaceFlowers(self, flowerbed, n):\\n        if n == 0: return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):  ", "def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False"]}
{"id": "143", "ref_py": ["def averageOfLevels(self, root: TreeNode) -> List[float]:\\n        q, ans = [root], []\\n        while len(q):\\n            qlen, row = len(q), 0\\n            for i in range(qlen):\\n                curr = q.pop(0)\\n                row += curr.val\\n                if curr.left: q.append(curr.left)\\n                if curr.right: q.append(curr.right)\\n            ans.append(row/qlen)\\n        return ans\\n```", "def averageOfLevels(self, root: TreeNode) -> List[float]:\\n        q, ans = [root], []\\n        while len(q):\\n            qlen, row = len(q), 0\\n            for i in range(qlen):\\n                curr = q.pop(0)\\n                row += curr.val\\n                if curr.left: q.append(curr.left)\\n                if curr.right: q.append(curr.right)\\n            ans.append(row/qlen)\\n        return ans\\n```", "def averageOfLevels(self, root: TreeNode) -> List[float]:\\n        q, ans = [root], []\\n        while len(q):\\n            qlen, row = len(q), 0\\n            for i in range(qlen):\\n                curr = q.pop(0)\\n                row += curr.val\\n                if curr.left: q.append(curr.left)\\n                if curr.right: q.append(curr.right)\\n            ans.append(row/qlen)\\n        return ans\\n```"]}
{"id": "144", "ref_py": ["def findMaxAverage(self, nums, k):\\n        if len(nums) == 1:\\n            return float(nums[0])\\n        \\n        start = 0\\n        end = k\\n        average = 0.0\\n        \\n        ", "def findMaxAverage(self, nums, k):\\n        if len(nums) == 1:\\n            return float(nums[0])\\n        \\n        start = 0\\n        end = k\\n        average = 0.0\\n        \\n        ", "def findMaxAverage(self, nums, k):\\n        if len(nums) == 1:\\n            return float(nums[0])\\n        \\n        start = 0\\n        end = k\\n        average = 0.0\\n        \\n        "]}
{"id": "145", "ref_py": ["def isIsomorphic(self, s, t):\\n        map1 = []\\n        map2 = []\\n        for idx in s:\\n            map1.append(s.index(idx))\\n        for idx in t:\\n            map2.append(t.index(idx))\\n        if map1 == map2:\\n            return True\\n        return False\\n```\\n        \\n", "def isIsomorphic(self, s: str, t: str) -> bool:\\n        return len(set(s))==len(set(zip(s,t)))==len(set(t))\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def isIsomorphic(self, s: str, t: str) -> bool:\\n        zipped_set = set(zip(s, t))\\n        return len(zipped_set) == len(set(s)) == len(set(t))\\n        \\n```\\nExplanation:\\nwhy using zip ?\\n=> zip function would pair the first item of first iterator (i.e `s` here) to the first item of second iterator (i.e `t` here). `set()` would remove duplicate items from the zipped tuple. It is like the first item of first iterator mapped to the first item of second iterator as it would in case of a hashtable or dictionary.\\nUnderstand using exmaples:\\n```\\n"]}
{"id": "146", "ref_py": ["def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\\n        \\n        def existAns(a , b , k):\\n            if b==None:\\n                return False\\n            if a==b:\\n                return existAns(a,b.left,k) or existAns(a,b.right,k)\\n            if a.val + b.val == k:\\n                return True\\n            if a.val+b.val < k:\\n                return existAns(a,b.right,k)\\n            else:\\n                return existAns(a,b.left,k)\\n        \\n        def traverse(root,head, k):\\n            if (root==None):\\n                return False\\n            if existAns(root,head,k):\\n                return True\\n            return traverse(root.left,head, k) or traverse(root.right,head, k)\\n        \\n        return traverse(root,root,k)\\n```", "def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\\n        l = dict()\\n        \\n        def fun(node):\\n            if not node:\\n                return\\n            l[node.val] = l.get(node.val,0)+1\\n            fun(node.left)\\n            fun(node.right)\\n        \\n        fun(root)\\n        for key in l:\\n            if k-key in l:\\n                if key==k-key:\\n                    if l[key]>1:\\n                        return True\\n                else:\\n                    return True\\n```", "def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\\n        l = dict()\\n        \\n        def fun(node):\\n            if not node:\\n                return\\n            l[node.val] = l.get(node.val,0)+1\\n            fun(node.left)\\n            fun(node.right)\\n        \\n        fun(root)\\n        for key in l:\\n            if k-key in l:\\n                if key==k-key:\\n                    if l[key]>1:\\n                        return True\\n                else:\\n                    return True\\n```"]}
{"id": "147", "ref_py": ["def judgeCircle(self, moves):\\n        moves = list(moves)\\n        count_U = moves.count(\\'U\\')\\n        count_D = moves.count(\\'D\\')\\n        count_R = moves.count(\\'R\\')\\n        count_L = moves.count(\\'L\\')\\n        if count_D == count_U and count_R == count_L:\\n            return True\\n        return False\\n```", "def judgeCircle(self, moves):\\n        \\n        xPos = 0\\n        yPos = 0\\n        for i in range(0,len(moves)):\\n            if (moves[i]==\\'L\\'):\\n                xPos-=1\\n                continue\\n            if (moves[i]==\\'R\\'):\\n                xPos+=1\\n                continue\\n            if (moves[i]==\\'D\\'):\\n                yPos-=1\\n                continue\\n            if (moves[i]==\\'U\\'):\\n                yPos+=1\\n                continue\\n        if (xPos==0 and yPos==0):\\n            return True\\n        return False\\n```", "def judgeCircle(self, moves):\\n        \\n        xPos = 0\\n        yPos = 0\\n        for i in range(0,len(moves)):\\n            if (moves[i]==\\'L\\'):\\n                xPos-=1\\n                continue\\n            if (moves[i]==\\'R\\'):\\n                xPos+=1\\n                continue\\n            if (moves[i]==\\'D\\'):\\n                yPos-=1\\n                continue\\n            if (moves[i]==\\'U\\'):\\n                yPos+=1\\n                continue\\n        if (xPos==0 and yPos==0):\\n            return True\\n        return False\\n```"]}
{"id": "148", "ref_py": ["def imageSmoother(self, img):\\n        m, n = len(img), len(img[0])\\n        res = [[0] * n for _ in range(m)]", "def imageSmoother(self, img):\\n        m, n = len(img), len(img[0])\\n        res = [[0] * n for _ in range(m)]", "def imageSmoother(self, img):\\n        m, n = len(img), len(img[0])\\n        res = [[0] * n for _ in range(m)]"]}
{"id": "149", "ref_py": ["def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        ", "def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        ", "def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        "]}
{"id": "150", "ref_py": ["def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))", "def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))", "def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))"]}
{"id": "151", "ref_py": ["def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```", "def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```", "def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```"]}
{"id": "152", "ref_py": ["def calPoints(self, ops: List[str]) -> int:**\\n\\t\\n        stack = []\\n        curr = -1\\n        op = [\"C\",\"D\",\"+\"]\\n        for i in range (len(ops)):\\n            if ops[i] not in op:\\n                stack.append(int(ops[i]))\\n                curr += 1\\n            else:\\n                if ops[i] == \"C\":\\n                    stack.pop()\\n                    curr = curr-1\\n                elif ops[i] == \"D\":\\n                    stack.append(int(stack[curr])*2)\\n                    curr += 1\\n                else:\\n                    stack.append((int(stack[curr]) + int(stack[curr-1])))\\n                    curr += 1\\n        return sum(stack)\\n\\t\\t\\n\\t\\t*********************************2nd solution***********************\\n\\t\\t\\n", "def calPoints(self, ops: List[str]) -> int:**\\n\\t\\n        stack = []\\n        curr = -1\\n        op = [\"C\",\"D\",\"+\"]\\n        for i in range (len(ops)):\\n            if ops[i] not in op:\\n                stack.append(int(ops[i]))\\n                curr += 1\\n            else:\\n                if ops[i] == \"C\":\\n                    stack.pop()\\n                    curr = curr-1\\n                elif ops[i] == \"D\":\\n                    stack.append(int(stack[curr])*2)\\n                    curr += 1\\n                else:\\n                    stack.append((int(stack[curr]) + int(stack[curr-1])))\\n                    curr += 1\\n        return sum(stack)\\n\\t\\t\\n\\t\\t*********************************2nd solution***********************\\n\\t\\t\\n", "def calPoints(self, ops: List[str]) -> int:**\\n\\t\\n        stack = []\\n        curr = -1\\n        op = [\"C\",\"D\",\"+\"]\\n        for i in range (len(ops)):\\n            if ops[i] not in op:\\n                stack.append(int(ops[i]))\\n                curr += 1\\n            else:\\n                if ops[i] == \"C\":\\n                    stack.pop()\\n                    curr = curr-1\\n                elif ops[i] == \"D\":\\n                    stack.append(int(stack[curr])*2)\\n                    curr += 1\\n                else:\\n                    stack.append((int(stack[curr]) + int(stack[curr-1])))\\n                    curr += 1\\n        return sum(stack)\\n\\t\\t\\n\\t\\t*********************************2nd solution***********************\\n\\t\\t\\n"]}
{"id": "153", "ref_py": ["def reverseList(self, head):\\n        ", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def reverseList(self, head):\\n        "]}
{"id": "154", "ref_py": ["def countBinarySubstrings(self, s: str) -> int:\\n\\tans, prev, cur = 0, 0, 1\\n\\tfor i in range(1, len(s)):\\n\\t\\tif s[i] != s[i - 1]:\\n\\t\\t\\tans += min(prev, cur)\\n\\t\\t\\tprev = cur\\n\\t\\t\\tcur = 1\\n\\t\\telse:\\n\\t\\t\\tcur += 1\\n\\tans += min(prev, cur)\\n\\treturn ans\\n```\\n  \\n***Time Complexity :*** **`O(N)`**, where *`N`* is the length of given string.\\n***Space  Complexity :*** **`O(1)`**, since only constant space is being used.\\n  \\n---", "define a starting value for **curr** of **1**. Also, since the end of **s** is technically the end of a group, we should add another **min(curr, prev)** onto **ans** before we **return ans**, as it won\\'t be accounted for in the iteration through **s**.", "def countBinarySubstrings(self, s: str) -> int:\\n\\tans, prev, cur = 0, 0, 1\\n\\tfor i in range(1, len(s)):\\n\\t\\tif s[i] != s[i - 1]:\\n\\t\\t\\tans += min(prev, cur)\\n\\t\\t\\tprev = cur\\n\\t\\t\\tcur = 1\\n\\t\\telse:\\n\\t\\t\\tcur += 1\\n\\tans += min(prev, cur)\\n\\treturn ans\\n```\\n  \\n***Time Complexity :*** **`O(N)`**, where *`N`* is the length of given string.\\n***Space  Complexity :*** **`O(1)`**, since only constant space is being used.\\n  \\n---"]}
{"id": "155", "ref_py": ["def findShortestSubArray(self, nums: List[int]) -> int:\\n    \\tC = {}\\n    \\tfor i, n in enumerate(nums):\\n    \\t\\tif n in C: C[n].append(i)\\n    \\t\\telse: C[n] = [i]\\n    \\tM = max([len(i) for i in C.values()])\\n    \\treturn min([i[-1]-i[0] for i in C.values() if len(i) == M]) + 1\\n\\t\\t\\n", "def findShortestSubArray(self, nums: List[int]) -> int:\\n    \\tC = {}\\n    \\tfor i, n in enumerate(nums):\\n    \\t\\tif n in C: C[n].append(i)\\n    \\t\\telse: C[n] = [i]\\n    \\tM = max([len(i) for i in C.values()])\\n    \\treturn min([i[-1]-i[0] for i in C.values() if len(i) == M]) + 1\\n\\t\\t\\n", "def findShortestSubArray(self, nums: List[int]) -> int:\\n    \\tC = {}\\n    \\tfor i, n in enumerate(nums):\\n    \\t\\tif n in C: C[n].append(i)\\n    \\t\\telse: C[n] = [i]\\n    \\tM = max([len(i) for i in C.values()])\\n    \\treturn min([i[-1]-i[0] for i in C.values() if len(i) == M]) + 1\\n\\t\\t\\n"]}
{"id": "156", "ref_py": ["def searchBST(self, root, val):\\n        ", "def searchBST(self, root, val):\\n        ", "def searchBST(self, root, val):\\n        "]}
{"id": "158", "ref_py": ["def search(self, nums, target):\\n        \\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1", "def search(self, nums, target):\\n        \\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1", "def search(self, nums, target):\\n        \\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1"]}
{"id": "161", "ref_py": ["def toLowerCase(self, s):\\n        return \"\".join(chr(ord(c) + 32) if \"A\" <= c <= \"Z\" else c for c in s)\\n```\\n______________________________________________________________________\\n______________________________________________________________________\\n______________________________________________________________________", "def toLowerCase(self, s: str) -> str:\\n        ans = \"\"\\n        for c in s:\\n            n = ord(c)\\n            ans += chr(n+32) if n > 64 and n < 91 else c\\n        return ans\\n```", "def toLowerCase(self, s):\\n        return \"\".join(chr(ord(c) + 32) if \"A\" <= c <= \"Z\" else c for c in s)\\n```\\n______________________________________________________________________\\n______________________________________________________________________\\n______________________________________________________________________"]}
{"id": "162", "ref_py": ["def isOneBitCharacter(self, bits):\\n        \\n        i = 0\\n        last = 0\\n        while i < len(bits):\\n            if bits[i] == 0:\\n                last = 0 \\n                i += 1", "def isOneBitCharacter(self, bits):\\n        \\n        i = 0\\n        last = 0\\n        while i < len(bits):\\n            if bits[i] == 0:\\n                last = 0 \\n                i += 1", "def isOneBitCharacter(self, bits):\\n        \\n        i = 0\\n        last = 0\\n        while i < len(bits):\\n            if bits[i] == 0:\\n                last = 0 \\n                i += 1"]}
{"id": "163", "ref_py": ["def pivotIndex(self, nums):\\n        ", "def pivotIndex(self, nums: List[int]) -> int:\\n        total= sum(nums)\\n        temp = 0\\n        for i in range(len(nums)):\\n            if(nums[i] == total - 2*temp): \\n                return i\\n            temp += nums[i]\\n        return -1\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def pivotIndex(self, nums: List[int]) -> int:\\n        total= sum(nums)\\n        temp = 0\\n        for i in range(len(nums)):\\n            if(nums[i] == total - 2*temp): \\n                return i\\n            temp += nums[i]\\n        return -1\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "164", "ref_py": ["def selfDividingNumbers(self, left, right):\\n        \\n        l=[]\\n        for i in range(left,right+1):\\n            fl,a=0,i\\n            if \\'0\\' in str(i):\\n                fl=1\\n\\n            else:\\n                while a!=0:\\n                    if i%(a%10)!=0:\\n                        fl=1\\n                        break\\n                    a=a//10\\n            if fl==0:\\n                l.append(i)\\n        return l", "def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        ans = []\\n        for i in range(left,right+1):\\n            val = i\\n            res = True\\n            if \"0\" not in str(i):\\n                while val != 0:\\n                    val1 = val % 10\\n                    if i%val1!=0:\\n                        res = False\\n                    val = val // 10\\n                if res: ans.append(i)\\n        return ans\\n```", "def selfDividingNumbers(self, left, right):\\n        \\n        l=[]\\n        for i in range(left,right+1):\\n            fl,a=0,i\\n            if \\'0\\' in str(i):\\n                fl=1\\n\\n            else:\\n                while a!=0:\\n                    if i%(a%10)!=0:\\n                        fl=1\\n                        break\\n                    a=a//10\\n            if fl==0:\\n                l.append(i)\\n        return l"]}
{"id": "165", "ref_py": ["def fill(self, image, sr, sc, color, cur):\\n        ", "def fill(self, image, sr, sc, color, cur):\\n        ", "def fill(self, image, sr, sc, color, cur):\\n        "]}
{"id": "166", "ref_py": ["def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        ans=[]\\n        c=0\\n        n=len(letters)\\n        for i in range(0,n):\\n            if letters[i]>target:\\n                ans.append(letters[i])", "def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        ans=[]\\n        c=0\\n        n=len(letters)\\n        for i in range(0,n):\\n            if letters[i]>target:\\n                ans.append(letters[i])", "def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        ans=[]\\n        c=0\\n        n=len(letters)\\n        for i in range(0,n):\\n            if letters[i]>target:\\n                ans.append(letters[i])"]}
{"id": "167", "ref_py": ["def sumOfLeftLeaves(self, root):\\n        \\n        \\n        self.sum=0\\n        \\n        def depthFirstSeach(root):\\n            if root is None:\\n                return 0\\n            \\n            leftRoot=root.left\\n            rightRot=root.right\\n            \\n            if root.left:    \\n                leftLeave_ofLeft=root.left.left\\n                rightLeave_ofLeft=root.left.right\\n                value_ofLeft=root.left.val\\n                if leftLeave_ofLeft == None and rightLeave_ofLeft == None:\\n                    self.sum+=value_ofLeft      \\n                    \\n            depthFirstSeach(leftRoot)\\n            depthFirstSeach(rightRot)\\n            \\n        depthFirstSeach(root)\\n        return self.sum\\n```", "def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0", "def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return 0"]}
{"id": "168", "ref_py": ["def dominantIndex(self, nums: List[int]) -> int:\\n        maxx,index=nums[0],0\\n        for i,v in enumerate(nums):\\n            maxx=max(maxx,v)\\n            if maxx==v:\\n                index=i\\n        for i in range(len(nums)):\\n            if nums[i]!=maxx and maxx<2*nums[i]:\\n                return -1", "def dominantIndex(self, nums: List[int]) -> int:\\n\\tfirst_max = second_max = -1\\n\\tmax_ind = 0", "def dominantIndex(self, nums: List[int]) -> int:\\n        \\n        "]}
{"id": "169", "ref_py": ["def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:\\n  \\n        license_chars = [char.lower() for char in licensePlate if char.isalpha()]\\n        \\n        license_count = Counter(license_chars)\\n        \\n        words.sort(key=len)", "def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:\\n  \\n        license_chars = [char.lower() for char in licensePlate if char.isalpha()]\\n        \\n        license_count = Counter(license_chars)\\n        \\n        words.sort(key=len)", "def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:\\n  \\n        license_chars = [char.lower() for char in licensePlate if char.isalpha()]\\n        \\n        license_count = Counter(license_chars)\\n        \\n        words.sort(key=len)"]}
{"id": "170", "ref_py": ["def countPrimeSetBits(self, left: int, right: int) -> int:", "def countPrimeSetBits(self, left: int, right: int) -> int:", "def countPrimeSetBits(self, left: int, right: int) -> int:"]}
{"id": "171", "ref_py": ["def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n\\tif not nums2:\\n\\t\\treturn None", "def nextGreaterElement(self, nums1, nums2):\\n        ans = []\\n        for i in range(len(nums1)):\\n            max_num = -1\\n            for j in range(len(nums2)):\\n                index = j\\n                if nums1[i] == nums2[j]: ", "def nextGreaterElement(self, nums1, nums2):\\n        ans = []\\n        for i in range(len(nums1)):\\n            max_num = -1\\n            for j in range(len(nums2)):\\n                index = j\\n                if nums1[i] == nums2[j]: "]}
{"id": "172", "ref_py": ["def numJewelsInStones(jewels, stones):\\n    count = 0\\n    for i in stones:\\n        if i in jewels:\\n            count += 1\\n    return count", "def numJewelsInStones(self, jewels, stones):\\n       \\n        count_jewels =0\\n        for i in jewels:\\n            count_jewels += stones.count(i)", "def numJewelsInStones(self, jewels, stones):\\n        \\n        count=0\\n        for i in stones:\\n            if i in jewels:\\n                count=count+1\\n        return count\\n```"]}
{"id": "173", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def minDiffInBST(self, root):\\n        \\n        \\n        rootStack = []\\n        previous = None\\n        minimum = float(\\'inf\\')\\n        while rootStack or root:\\n            while root:\\n                rootStack.append(root)\\n                root = root.left\\n            root = rootStack.pop()\\n            minimum = min(root.val - previous.val, minimum) if previous else minimum\\n            previous = root\\n            root = root.right\\n        return minimum\\n```", "def minDiffInBST(self, root):\\n        \\n        \\n        rootStack = []\\n        previous = None\\n        minimum = float(\\'inf\\')\\n        while rootStack or root:\\n            while root:\\n                rootStack.append(root)\\n                root = root.left\\n            root = rootStack.pop()\\n            minimum = min(root.val - previous.val, minimum) if previous else minimum\\n            previous = root\\n            root = root.right\\n        return minimum\\n```"]}
{"id": "174", "ref_py": ["def rotateString(self, s: str, goal: str) -> bool:\\n        return len(s) == len(goal) and s in goal+goal \\n```", "def rotateString(self, s: str, goal: str) -> bool: \\n\\t\\n        if len(s)!=len(goal):\\n            return False\\n", "def rotateString(self, s: str, goal: str) -> bool:\\n        return len(s) == len(goal) and s in goal+goal \\n```"]}
{"id": "175", "ref_py": ["def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        ", "def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        ENG_to_MORSE = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\" }\\n        transform = lambda c: ENG_to_MORSE[c]   ", "def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t\\t\\treturn len(set(map(self.encode, words)))"]}
{"id": "176", "ref_py": ["default whitespace delimiter. This creates a list of words from the input string.", "def reverseWords(self, s: str) -> str:\\n        n = len(s)\\n        i = 0\\n        j = 0\\n        while j < n:\\n            if s[j] == \\' \\':\\n                s = s[:i] + s[i:j][::-1] + s[j:]\\n                i = j + 1\\n            if j == n - 1:\\n                s = s[:i] + s[i:j+1][::-1]\\n            j += 1\\n        return s\\n```", "def reverseWords(self, s):\\n        \\n        words = s.split()\\n        \\n        reversed_words = [word[::-1] for word in words]\\n        \\n        reversed_s = \\' \\'.join(reversed_words)\\n        \\n        return reversed_s\\n```"]}
{"id": "177", "ref_py": ["def distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n", "def distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n", "def distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n"]}
{"id": "178", "ref_py": ["def pivotIndex(self, nums):\\n        ", "def pivotIndex(self, nums: List[int]) -> int:\\n        total= sum(nums)\\n        temp = 0\\n        for i in range(len(nums)):\\n            if(nums[i] == total - 2*temp): \\n                return i\\n            temp += nums[i]\\n        return -1\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def pivotIndex(self, nums: List[int]) -> int:\\n        total= sum(nums)\\n        temp = 0\\n        for i in range(len(nums)):\\n            if(nums[i] == total - 2*temp): \\n                return i\\n            temp += nums[i]\\n        return -1\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "179", "ref_py": ["def shortestToChar(self, s, c):\\n         \\n        lengthOf_string = len(s)\\n        result = [lengthOf_string] * lengthOf_string\\n        lastItem_string = -lengthOf_string\\n        for i in list(range(lengthOf_string)) + list(range(lengthOf_string)[::-1]):\\n            if(s[i] == c):  lastItem_string = i\\n            result[i] = min(result[i], abs(i - lastItem_string))\\n        return result  \\n```", "def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```", "def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n"]}
{"id": "180", "ref_py": ["def toGoatLatin(self, sentence: str) -> str:\\n\\t\\t\\tlst = sentence.split(\" \")", "def toGoatLatin(self, sentence: str) -> str:\\n\\t\\t\\tlst = sentence.split(\" \")", "def toGoatLatin(self, sentence: str) -> str:\\n\\t\\t\\tlst = sentence.split(\" \")"]}
{"id": "181", "ref_py": ["def convertToBase7(self, num: int) -> str:\\n        ", "def convertToBase7(self, num: int) -> str:\\n        ", "def convertToBase7(self, num: int) -> str:\\n        "]}
{"id": "182", "ref_py": ["def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```", "def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```", "def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```"]}
{"id": "183", "ref_py": ["def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tnums[:] = sorted(set(nums))\\n\\t\\treturn len(nums)\\n```", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  ", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  "]}
{"id": "184", "ref_py": ["def countRealSymbol(s):\\n    counter = 0\\n    i = 0\\n    while i < len(s):\\n        if s[i] != \\'", "def backspaceCompare(self, s, t):\\n        ", "def backspaceCompare(self, s, t):\\n        "]}
{"id": "185", "ref_py": ["def buddyStrings(self, s, goal):\\n        ind = []", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        c1=Counter(s)\\n        c2=Counter(goal)\\n        if c1!=c2:\\n            return False", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False"]}
{"id": "186", "ref_py": ["def lemonadeChange(self, bills):\\n        fives, tens = 0, 0\\n        for bill in bills:\\n            if bill == 5:\\n                fives += 1\\n            elif bill == 10:\\n                if fives == 0:\\n                    return False\\n                fives -= 1\\n                tens += 1\\n            else:\\n                if tens > 0 and fives > 0:\\n                    tens -= 1\\n                    fives -= 1\\n                elif fives >= 3:\\n                    fives -= 3\\n                else:\\n                    return False\\n        return True", "def lemonadeChange(self, bills: List[int]) -> bool:\\n        fiveBills, tenBills = 0, 0", "def lemonadeChange(self, bills):\\n        fives, tens = 0, 0\\n        for bill in bills:\\n            if bill == 5:\\n                fives += 1\\n            elif bill == 10:\\n                if fives == 0:\\n                    return False\\n                fives -= 1\\n                tens += 1\\n            else:\\n                if tens > 0 and fives > 0:\\n                    tens -= 1\\n                    fives -= 1\\n                elif fives >= 3:\\n                    fives -= 3\\n                else:\\n                    return False\\n        return True"]}
{"id": "187", "ref_py": ["def transpose(self, matrix):\\n        n = len(matrix)\\n        m = len(matrix[0])", "def transpose(self, matrix):\\n        n = len(matrix)\\n        m = len(matrix[0])", "def transpose(self, matrix):\\n        n = len(matrix)\\n        m = len(matrix[0])"]}
{"id": "188", "ref_py": ["def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m", "def binaryGap(self, n):\\n        \\n        lPtr = -1\\n        idx = 0\\n        res = 0\\n        while(n > 0):\\n            if n % 2 == 1:\\n                if lPtr != -1:\\n                    res = max(idx - lPtr,res)\\n                    \\n                lPtr = idx\\n            idx += 1\\n            n = n >> 1\\n        return res", "def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m"]}
{"id": "189", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "190", "ref_py": ["def middleNode(self, head):\\n        ", "def middleNode(self, head):\\n        \\n        slow  = head\\n        fast = head", "def middleNode(self, head):\\n        "]}
{"id": "191", "ref_py": ["def projectionArea(self, arr):\\n        res = 0\\n        c = 0", "def projectionArea(self, arr):\\n        res = 0\\n        c = 0", "def projectionArea(self, arr):\\n        res = 0\\n        c = 0"]}
{"id": "192", "ref_py": ["def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\\n        allWordsList = s1.split(\\' \\') + s2.split(\\' \\')\\n        words = Counter(allWordsList)\\n        \\n        output = []\\n        \\n        for word in words:\\n            if words[word] == 1:\\n                output.append(word)\\n                \\n        return output\\n", "def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\\n        allWordsList = s1.split(\\' \\') + s2.split(\\' \\')\\n        words = Counter(allWordsList)\\n        \\n        output = []\\n        \\n        for word in words:\\n            if words[word] == 1:\\n                output.append(word)\\n                \\n        return output\\n", "def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\\n        allWordsList = s1.split(\\' \\') + s2.split(\\' \\')\\n        words = Counter(allWordsList)\\n        \\n        output = []\\n        \\n        for word in words:\\n            if words[word] == 1:\\n                output.append(word)\\n                \\n        return output\\n"]}
{"id": "193", "ref_py": ["def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "194", "ref_py": ["def surfaceArea(self, grid):\\n        n = len(grid)\\n        res = 0", "def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n\\t\\tNotes\\n\\t\\t============\\n\\t\\t\\n        Calculations\\n        ------------\\n        \\n        Top and Bottom Face:\\n        If a positive value exists on the current cell, increment counter (only need to know if it exists, one cell face == 1)\\n        \\n        Change in Altitude:\\n        For each cell, check difference between current position and surrounding\\n            - Goal is to check diff below current position and in front of current position\\n            - If at right edge, check below if possible\\n            - If at bottom edge, check right if possible\\n            - It not at right and bottom, check both right and bottom\\n        \\n            Search Pattern:\\n            (i,j)->\\n              |\\n              v", "def surfaceArea(self, grid):\\n        n = len(grid)\\n        res = 0"]}
{"id": "195", "ref_py": ["def isMonotonic(self, A: List[int]) -> bool:\\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1))", "def isMonotonic(self, nums):\\n        monotonic = True\\n        monotonic1 = True\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] > nums[i + 1]:\\n                monotonic = False\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i + 1]:\\n                monotonic1 = False\\n        \\n        if monotonic:\\n            return monotonic\\n        elif monotonic1:\\n            return monotonic1\\n        else:\\n            return False\\n```", "def isMonotonic(self, nums):\\n        monotonic = True\\n        monotonic1 = True\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] > nums[i + 1]:\\n                monotonic = False\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i + 1]:\\n                monotonic1 = False\\n        \\n        if monotonic:\\n            return monotonic\\n        elif monotonic1:\\n            return monotonic1\\n        else:\\n            return False\\n```"]}
{"id": "196", "ref_py": ["def increasingBST(self, root):\\n        \\n        if not root:\\n            return None\\n        stack = []\\n        temp = x = root\\n        i = 0\\n        while stack or temp:\\n            if temp:\\n                stack.append(temp)\\n                temp = temp.left\\n            else:\\n                node = stack.pop()\\n                if i==0:\\n                    root = x = node\\n                    i+=1\\n                else:\\n                    x.right = node\\n                    x = node\\n                    x.left = None\\n                temp = node.right\\n        return root\\t\\n", "def increasingBST(self, root):\\n        \\n        def sortBST(node):\\n            if not node:    return []\\n            \\n            ", "def increasingBST(self, root):\\n        \\n        if not root:\\n            return None\\n        stack = []\\n        temp = x = root\\n        i = 0\\n        while stack or temp:\\n            if temp:\\n                stack.append(temp)\\n                temp = temp.left\\n            else:\\n                node = stack.pop()\\n                if i==0:\\n                    root = x = node\\n                    i+=1\\n                else:\\n                    x.right = node\\n                    x = node\\n                    x.left = None\\n                temp = node.right\\n        return root\\t\\n"]}
{"id": "197", "ref_py": ["def sortArrayByParity(self, A: List[int]) -> List[int]:\\n    odd, even = [], []\\n    for v in A:\\n      if v % 2 == 0:\\n        even.append(v)\\n      else:\\n        odd.append(v)\\n    \\n    return even + odd\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParity(vector<int>& A) {\\n    vector<int> even, odd;\\n    \\n    for (const auto &n: A) {\\n      if (n % 2 == 1) {\\n        odd.push_back(n);\\n      } else {\\n        even.push_back(n);\\n      }\\n    }\\n    \\n    for (const auto &n: odd) {\\n      even.push_back(n);\\n    }\\n    \\n    return even;\\n  }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn sort_array_by_parity(nums: Vec<i32>) -> Vec<i32> {\\n    let (mut arr_odd, mut arr_even) = (Vec::new(), Vec::new())    ;\\n    for v in nums {\\n      if v % 2 == 1 {\\n        arr_odd.push(v);\\n      } else {\\n        arr_even.push(v);\\n      }\\n    }", "def sortArrayByParity(self, A: List[int]) -> List[int]:\\n    odd, even = [], []\\n    for v in A:\\n      if v % 2 == 0:\\n        even.append(v)\\n      else:\\n        odd.append(v)\\n    \\n    return even + odd\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParity(vector<int>& A) {\\n    vector<int> even, odd;\\n    \\n    for (const auto &n: A) {\\n      if (n % 2 == 1) {\\n        odd.push_back(n);\\n      } else {\\n        even.push_back(n);\\n      }\\n    }\\n    \\n    for (const auto &n: odd) {\\n      even.push_back(n);\\n    }\\n    \\n    return even;\\n  }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn sort_array_by_parity(nums: Vec<i32>) -> Vec<i32> {\\n    let (mut arr_odd, mut arr_even) = (Vec::new(), Vec::new())    ;\\n    for v in nums {\\n      if v % 2 == 1 {\\n        arr_odd.push(v);\\n      } else {\\n        arr_even.push(v);\\n      }\\n    }", "def sortArrayByParity(self, A: List[int]) -> List[int]:\\n    odd, even = [], []\\n    for v in A:\\n      if v % 2 == 0:\\n        even.append(v)\\n      else:\\n        odd.append(v)\\n    \\n    return even + odd\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParity(vector<int>& A) {\\n    vector<int> even, odd;\\n    \\n    for (const auto &n: A) {\\n      if (n % 2 == 1) {\\n        odd.push_back(n);\\n      } else {\\n        even.push_back(n);\\n      }\\n    }\\n    \\n    for (const auto &n: odd) {\\n      even.push_back(n);\\n    }\\n    \\n    return even;\\n  }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn sort_array_by_parity(nums: Vec<i32>) -> Vec<i32> {\\n    let (mut arr_odd, mut arr_even) = (Vec::new(), Vec::new())    ;\\n    for v in nums {\\n      if v % 2 == 1 {\\n        arr_odd.push(v);\\n      } else {\\n        arr_even.push(v);\\n      }\\n    }"]}
{"id": "198", "ref_py": ["def smallestRangeI(self, nums, k):\\n        min_val = min(nums)\\n        max_val = max(nums)", "def smallestRangeI(self, A: List[int], K: int) -> int:", "def smallestRangeI(self, nums, k):\\n        min_val = min(nums)\\n        max_val = max(nums)"]}
{"id": "199", "ref_py": ["def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        return reduce(gcd,Counter(deck).values()) != 1\\n\\t\\t\\n", "def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        return reduce(gcd,Counter(deck).values()) != 1\\n\\t\\t\\n", "def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        return reduce(gcd,Counter(deck).values()) != 1\\n\\t\\t\\n"]}
{"id": "200", "ref_py": ["def reverseOnlyLetters(self, s: str) -> str:**\\n\\t\\n        d = {}\\n        ind = 0\\n        for i in s:\\n            if i.isalpha() == False:\\n                d[ind] = i\\n            ind += 1\\n        temp = [i for i in s if i.isalpha()][::-1]\\n        for i in d:\\n            temp.insert(i,d[i])\\n        return \"\".join(temp)\\n\\t\\t\\n\\t\\t\\n\\t\\t****************************************2nd Solution*****************************************\\n\\t\\t\\n", "def reverseOnlyLetters(self, s: str) -> str:**\\n\\t\\n        d = {}\\n        ind = 0\\n        for i in s:\\n            if i.isalpha() == False:\\n                d[ind] = i\\n            ind += 1\\n        temp = [i for i in s if i.isalpha()][::-1]\\n        for i in d:\\n            temp.insert(i,d[i])\\n        return \"\".join(temp)\\n\\t\\t\\n\\t\\t\\n\\t\\t****************************************2nd Solution*****************************************\\n\\t\\t\\n", "def reverseOnlyLetters(self, s: str) -> str:**\\n\\t\\n        d = {}\\n        ind = 0\\n        for i in s:\\n            if i.isalpha() == False:\\n                d[ind] = i\\n            ind += 1\\n        temp = [i for i in s if i.isalpha()][::-1]\\n        for i in d:\\n            temp.insert(i,d[i])\\n        return \"\".join(temp)\\n\\t\\t\\n\\t\\t\\n\\t\\t****************************************2nd Solution*****************************************\\n\\t\\t\\n"]}
{"id": "201", "ref_py": ["def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth"]}
{"id": "202", "ref_py": ["def isLongPressedName(self, name, typed):\\n        \\n        j = 0\\n        i = 0\\n        n = len(name)\\n        t = len(typed)\\n        \\n        while j < t:\\n            if i < n and name[i] == typed[j]:\\n                i +=1\\n            elif j == 0 or typed[j] != typed[j-1]:\\n                return False\\n            j +=1\\n        return i == n\\n", "def isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\tfor (a, a_gr), (b, b_gr) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None)):\\n\\t\\t\\tif a != b or sum(1 for _ in a_gr) > sum(1 for _ in b_gr):\\n\\t\\t\\t\\treturn False\\n\\t\\treturn True", "def isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\tfor (a, a_gr), (b, b_gr) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None)):\\n\\t\\t\\tif a != b or sum(1 for _ in a_gr) > sum(1 for _ in b_gr):\\n\\t\\t\\t\\treturn False\\n\\t\\treturn True"]}
{"id": "203", "ref_py": ["def numUniqueEmails(self, emails: List[str]) -> int:\\n        \\n        res = set()\\n        for email in emails:\\n            local,domain = email.split(\\'@\\')\\n            tmp = \"\"\\n            for c in local:\\n                if c==\".\": continue\\n                elif c==\"+\": break\\n                else: tmp+=c\\n            res.add(tmp+\"@\"+domain)\\n        \\n        return len(res)", "def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                ", "def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                "]}
{"id": "205", "ref_py": ["def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```", "def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```", "def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```"]}
{"id": "206", "ref_py": ["def validMountainArray(self, arr: List[int]) -> bool:\\n        if len(arr) < 3: return False;\\n        l = 0;\\n        r = len(arr) - 1\\n        while l + 1 < len(arr) - 1 and arr[l] < arr[l + 1]: \\n            l += 1\\n        while r - 1 > 0 and arr[r] < arr[r - 1]: \\n            r -= 1\\n        return l == r\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N) as we are traversing the array only once.", "def validMountainArray(self, arr: List[int]) -> bool:\\n        if len(arr) < 3: return False;\\n        l = 0;\\n        r = len(arr) - 1\\n        while l + 1 < len(arr) - 1 and arr[l] < arr[l + 1]: \\n            l += 1\\n        while r - 1 > 0 and arr[r] < arr[r - 1]: \\n            r -= 1\\n        return l == r\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N) as we are traversing the array only once.", "def validMountainArray(self, arr: List[int]) -> bool:\\n        if len(arr) < 3: return False;\\n        l = 0;\\n        r = len(arr) - 1\\n        while l + 1 < len(arr) - 1 and arr[l] < arr[l + 1]: \\n            l += 1\\n        while r - 1 > 0 and arr[r] < arr[r - 1]: \\n            r -= 1\\n        return l == r\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N) as we are traversing the array only once."]}
{"id": "207", "ref_py": ["def isOneBitCharacter(self, bits):\\n        \\n        i = 0\\n        last = 0\\n        while i < len(bits):\\n            if bits[i] == 0:\\n                last = 0 \\n                i += 1", "def isOneBitCharacter(self, bits):\\n        \\n        i = 0\\n        last = 0\\n        while i < len(bits):\\n            if bits[i] == 0:\\n                last = 0 \\n                i += 1", "def isOneBitCharacter(self, bits):\\n        \\n        i = 0\\n        last = 0\\n        while i < len(bits):\\n            if bits[i] == 0:\\n                last = 0 \\n                i += 1"]}
{"id": "208", "ref_py": ["def minDeletionSize(self, strs):\\n        ", "def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n=len(strs),len(strs[0])\\n        c=0\\n        for i in range(n):\\n            for j in range(m-1):\\n                if ord(strs[j][i])>ord(strs[j+1][i]):\\n                    c+=1\\n                    break\\n        return c\\n```", "def minDeletionSize(self, strs):\\n        "]}
{"id": "209", "ref_py": ["def isAlienSorted(self, words, order):\\n        \\n        orderRange_inDictionary = {char:i for i,char in enumerate(order)}\\n        sizeWords=range(len(words)-1)", "def isAlienSorted(self, words, order):\\n        \\n        orderRange_inDictionary = {char:i for i,char in enumerate(order)}\\n        sizeWords=range(len(words)-1)", "def isAlienSorted(self, words, order):\\n        \\n        orderRange_inDictionary = {char:i for i,char in enumerate(order)}\\n        sizeWords=range(len(words)-1)"]}
{"id": "210", "ref_py": ["def transpose(self, matrix):\\n        n = len(matrix)\\n        m = len(matrix[0])", "def transpose(self, matrix):\\n        n = len(matrix)\\n        m = len(matrix[0])", "def transpose(self, matrix):\\n        n = len(matrix)\\n        m = len(matrix[0])"]}
{"id": "211", "ref_py": ["def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        ", "def isSameTree(self, p, q):\\n        ", "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        "]}
{"id": "212", "ref_py": ["def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "213", "ref_py": ["def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```", "def sortedSquares(self, nums):\\n        result = [0]*len(nums)\\n        i = 0\\n        j = len(nums)-1\\n        k = len(nums)-1\\n        while k>=0:\\n            if nums[i]*nums[i] <= nums[j]*nums[j]:\\n                result[k] = nums[j]*nums[j]\\n                k-=1\\n                j-=1\\n            else:\\n                result[k] = nums[i]*nums[i]\\n                i+=1\\n                k-=1\\n        return result        ", "def getAbsMin(lst):\\n    \\n    l, r = 0, len(lst) - 1\\n    while l <= r:\\n        mid = l + (r - l) // 2\\n        if lst[mid] == 0:L\\n            return mid\\n        elif lst[mid] < 0:\\n            l = mid + 1\\n        elif lst[mid] > 0:\\n            r = mid -1\\n    return l\\nprint(getAbsMin([-4,-1,2,3,10]))\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        minVal = -1\\n        ans = []\\n        j = getAbsMin(nums)\\n        i = j -1\\n        while i != -1 and j != len(nums):\\n            if nums[i]**2 < nums[j]**2:\\n                ans.append(nums[i]**2)\\n                i-=1\\n            else:\\n                ans.append(nums[j]**2)\\n                j+=1\\n        while i != -1:\\n            ans.append(nums[i]**2)\\n            i-=1\\n        while j != len(nums):\\n            ans.append(nums[j]**2)\\n            j+=1"]}
{"id": "214", "ref_py": ["def addToArrayForm(self, A, K):\\n        A[-1] += K\\n        for i in range(len(A) - 1, -1, -1):\\n            carry, A[i] = divmod(A[i], 10)\\n            if i: A[i-1] += carry\\n        if carry:\\n            A = list(map(int, str(carry))) + A\\n        return A", "def addToArrayForm(self, A, K):\\n        A[-1] += K\\n        for i in range(len(A) - 1, -1, -1):\\n            carry, A[i] = divmod(A[i], 10)\\n            if i: A[i-1] += carry\\n        if carry:\\n            A = list(map(int, str(carry))) + A\\n        return A", "def addToArrayForm(self, A, K):\\n        A[-1] += K\\n        for i in range(len(A) - 1, -1, -1):\\n            carry, A[i] = divmod(A[i], 10)\\n            if i: A[i-1] += carry\\n        if carry:\\n            A = list(map(int, str(carry))) + A\\n        return A"]}
{"id": "215", "ref_py": ["def isCousins(self, root: TreeNode, x: int, y: int) -> bool:\\n\\t\\t", "def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            size = len(q)\\n            x_found = False\\n            y_found = False\\n            for i in range(size):\\n                curr = q.popleft()\\n                \\n                if curr.val == x:\\n                    x_found = True\\n                if curr.val == y:\\n                    y_found = True\\n                if curr.left is not None and curr.right is not None:\\n                    if curr.left.val == x and curr.right.val == y:\\n                        return False\\n                    if curr.left.val == y and curr.right.val == x:\\n                        return False\\n                if curr.left is not None:\\n                    q.append(curr.left)\\n                if curr.right is not None:\\n                    q.append(curr.right)\\n            \\n            if x_found and y_found:\\n                return True\\n            if x_found or y_found:\\n                return False\\n        return False\\n```", "def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            size = len(q)\\n            x_found = False\\n            y_found = False\\n            for i in range(size):\\n                curr = q.popleft()\\n                \\n                if curr.val == x:\\n                    x_found = True\\n                if curr.val == y:\\n                    y_found = True\\n                if curr.left is not None and curr.right is not None:\\n                    if curr.left.val == x and curr.right.val == y:\\n                        return False\\n                    if curr.left.val == y and curr.right.val == x:\\n                        return False\\n                if curr.left is not None:\\n                    q.append(curr.left)\\n                if curr.right is not None:\\n                    q.append(curr.right)\\n            \\n            if x_found and y_found:\\n                return True\\n            if x_found or y_found:\\n                return False\\n        return False\\n```"]}
{"id": "216", "ref_py": ["def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        if n==1: return 1 ", "def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        if n==1: return 1 ", "def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        if n==1: return 1 "]}
{"id": "217", "ref_py": ["def isValid(self, s):\\n        stack = [] ", "def isValid(self, s):\\n        stack = [] ", "def isValid(self, s):\\n        "]}
{"id": "218", "ref_py": ["def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     "]}
{"id": "219", "ref_py": ["def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        ", "def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        ", "def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        "]}
{"id": "220", "ref_py": ["def bitwiseComplement(self, n: int) -> int:\\n       \\n        if n == 0:\\n            return 1", "def bitwiseComplement(self, n):\\n\\t\\treturn ((2 << int(math.log(max(n, 1), 2))) - 1) - n\\n        ", "def bitwiseComplement(self, n: int) -> int:\\n       \\n        if n == 0:\\n            return 1"]}
{"id": "221", "ref_py": ["def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total_sum = sum(arr)\\n        if total_sum % 3 != 0:\\n            return False", "def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total_sum = sum(arr)\\n        if total_sum % 3 != 0:\\n            return False", "def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total_sum = sum(arr)\\n        if total_sum % 3 != 0:\\n            return False"]}
{"id": "222", "ref_py": ["def prefixesDivBy5(self, nums: List[int]) -> List[bool]:\\n        res = []\\n        num = 0\\n        \\n        for n in nums:\\n            num = (num * 2 + n) % 5\\n            res.append(num == 0)\\n            \\n        return res\\n```", "def prefixesDivBy5(self, nums: List[int]) -> List[bool]:\\n        res = []\\n        num = 0\\n        \\n        for n in nums:\\n            num = (num * 2 + n) % 5\\n            res.append(num == 0)\\n            \\n        return res\\n```", "def prefixesDivBy5(self, nums: List[int]) -> List[bool]:\\n        res = []\\n        num = 0\\n        \\n        for n in nums:\\n            num = (num * 2 + n) % 5\\n            res.append(num == 0)\\n            \\n        return res\\n```"]}
{"id": "223", "ref_py": ["def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):", "def removeOuterParentheses(self, s: str) -> str:\\n        cnt=0\\n        ans=\\'\\'\\n        for ch in s:\\n            if ch ==\\'(\\':\\n                cnt+=1\\n                if cnt!=1:\\n                    ans+=\\'(\\'    \\n            else:\\n                if cnt!=1:\\n                    ans+=\\')\\'\\n                cnt-=1\\n        return ans\\n", "def removeOuterParentheses(self, s: str) -> str:\\n        cnt=0\\n        ans=\\'\\'\\n        for ch in s:\\n            if ch ==\\'(\\':\\n                cnt+=1\\n                if cnt!=1:\\n                    ans+=\\'(\\'    \\n            else:\\n                if cnt!=1:\\n                    ans+=\\')\\'\\n                cnt-=1\\n        return ans\\n"]}
{"id": "224", "ref_py": ["def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): ", "def __init__(self):\\n        self.ans = 0", "def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): "]}
{"id": "225", "ref_py": ["def divisorGame(self, N: int) -> bool:\\n        return N % 2 == 0\\n\\t\\t\\n", "def divisorGame(self, n: int) -> bool:\\n        return n % 2 == 0", "def divisorGame(self, N: int) -> bool:\\n        return N % 2 == 0\\n\\t\\t\\n"]}
{"id": "226", "ref_py": ["def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    return sorted([(i, j) for i in range(R) for j in range(C)], key=lambda p: abs(p[0] - r0) + abs(p[1] - c0))\\n```", "def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    return sorted([(i, j) for i in range(R) for j in range(C)], key=lambda p: abs(p[0] - r0) + abs(p[1] - c0))\\n```", "def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    return sorted([(i, j) for i in range(R) for j in range(C)], key=lambda p: abs(p[0] - r0) + abs(p[1] - c0))\\n```"]}
{"id": "227", "ref_py": ["def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     "]}
{"id": "228", "ref_py": ["def lastStoneWeight(self, stones: List[int]) -> int:\\n        ", "def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  ", "def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  "]}
{"id": "229", "ref_py": ["def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     "]}
{"id": "231", "ref_py": ["def heightChecker(self, heights: List[int]) -> int:\\n        sort_heights = sorted(heights)\\n        return sum([0 if heights[i] == sort_heights[i] else 1 for i in range(len(heights))])\\n```", "def heightChecker(self, heights: List[int]) -> int:\\n        sort_heights = sorted(heights)\\n        return sum([0 if heights[i] == sort_heights[i] else 1 for i in range(len(heights))])\\n```", "def heightChecker(self, heights: List[int]) -> int:\\n        sort_heights = sorted(heights)\\n        return sum([0 if heights[i] == sort_heights[i] else 1 for i in range(len(heights))])\\n```"]}
{"id": "233", "ref_py": ["def gcdOfStrings(self, str1: str, str2: str) -> str:", "def gcdOfStrings(self, str1, str2):\\n        if str1 + str2 != str2 + str1:\\n            return \"\"\\n        if len(str1) == len(str2):\\n            return str1\\n        if len(str1) > len(str2):\\n            return self.gcdOfStrings(str1[len(str2):], str2)\\n        return self.gcdOfStrings(str1, str2[len(str1):])", "def gcdOfStrings(self, str1: str, str2: str) -> str:\\n        if str1 + str2 != str2 + str1:\\n            return \"\"\\n        max_length = gcd(len(str1), len(str2))\\n        return str1[:max_length]\\n```"]}
{"id": "235", "ref_py": ["def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\\n        thirds = []\\n        words = text.split()\\n        for index,word in enumerate(words):\\n            if index < len(words)-2:\\n                if word == first and words[index+1] == second:\\n                    thirds.append(words[index+2])\\n        return thirds", "def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\\n        thirds = []\\n        words = text.split()\\n        for index,word in enumerate(words):\\n            if index < len(words)-2:\\n                if word == first and words[index+1] == second:\\n                    thirds.append(words[index+2])\\n        return thirds", "def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\\n        thirds = []\\n        words = text.split()\\n        for index,word in enumerate(words):\\n            if index < len(words)-2:\\n                if word == first and words[index+1] == second:\\n                    thirds.append(words[index+2])\\n        return thirds"]}
{"id": "237", "ref_py": ["def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) ", "def findTheDifference(self, s: str, t: str) -> str:\\n        char_count = {}\\n        \\n        ", "def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) "]}
{"id": "238", "ref_py": ["def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.", "def distributeCandies(self, candies, num_people):\\n        \\n        cur = 1\\n        ans = [0 for i in range(num_people)]\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cur <= candies:\\n                    candies -= cur\\n                    ans[i] += cur\\n                else:\\n                    ans[i] += candies\\n                    return ans\\n                cur += 1\\n        return ans", "def distributeCandies(self, candies, num_people):\\n        \\n        cur = 1\\n        ans = [0 for i in range(num_people)]\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cur <= candies:\\n                    candies -= cur\\n                    ans[i] += cur\\n                else:\\n                    ans[i] += candies\\n                    return ans\\n                cur += 1\\n        return ans"]}
{"id": "239", "ref_py": ["def defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```", "def defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```", "def defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```"]}
{"id": "241", "ref_py": ["def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\\n        sorted_lst = []", "def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\\n        sorted_lst = []", "def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\\n        sorted_lst = []"]}
{"id": "242", "ref_py": ["def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            ", "def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            ", "def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            "]}
{"id": "243", "ref_py": ["def tribonacci(self, n: int) -> int:\\n        t0, t1, t2 = 0, 1, 1\\n        if n==0: return t0\\n        if n==1: return t1\\n        for _ in range(n-2):\\n            t0, t1, t2 = t1, t2, t0+t1+t2\\n        return t2\\n```", "def tribo(self, k):\\n        if k == 0:\\n            return 0\\n        if self.nums[k] != 0:\\n            return self.nums[k]", "def tribo(self, k):\\n        if k == 0:\\n            return 0\\n        if self.nums[k] != 0:\\n            return self.nums[k]"]}
{"id": "246", "ref_py": ["def dayOfYear(self, date: str) -> int:\\n\\t\\t\\tmap={\\n\\t\\t\\t\\t0:0,\\n\\t\\t\\t\\t1:31,\\n\\t\\t\\t\\t2:28,\\n\\t\\t\\t\\t3:31,\\n\\t\\t\\t\\t4:30,\\n\\t\\t\\t\\t5:31,\\n\\t\\t\\t\\t6:30,\\n\\t\\t\\t\\t7:31,\\n\\t\\t\\t\\t8:31,\\n\\t\\t\\t\\t9:30,\\n\\t\\t\\t\\t10:31,\\n\\t\\t\\t\\t11:30,\\n\\t\\t\\t\\t12:31                \\n\\t\\t\\t}", "def dayOfYear(self, date: str) -> int:\\n\\t\\t\\tmap={\\n\\t\\t\\t\\t0:0,\\n\\t\\t\\t\\t1:31,\\n\\t\\t\\t\\t2:28,\\n\\t\\t\\t\\t3:31,\\n\\t\\t\\t\\t4:30,\\n\\t\\t\\t\\t5:31,\\n\\t\\t\\t\\t6:30,\\n\\t\\t\\t\\t7:31,\\n\\t\\t\\t\\t8:31,\\n\\t\\t\\t\\t9:30,\\n\\t\\t\\t\\t10:31,\\n\\t\\t\\t\\t11:30,\\n\\t\\t\\t\\t12:31                \\n\\t\\t\\t}", "def dayOfYear(self, date: str) -> int:\\n\\t\\t\\tmap={\\n\\t\\t\\t\\t0:0,\\n\\t\\t\\t\\t1:31,\\n\\t\\t\\t\\t2:28,\\n\\t\\t\\t\\t3:31,\\n\\t\\t\\t\\t4:30,\\n\\t\\t\\t\\t5:31,\\n\\t\\t\\t\\t6:30,\\n\\t\\t\\t\\t7:31,\\n\\t\\t\\t\\t8:31,\\n\\t\\t\\t\\t9:30,\\n\\t\\t\\t\\t10:31,\\n\\t\\t\\t\\t11:30,\\n\\t\\t\\t\\t12:31                \\n\\t\\t\\t}"]}
{"id": "247", "ref_py": ["def countCharacters(self, words, chars):\\n        counts = [0] * 26", "def countCharacters(self, words, chars):\\n        counts = [0] * 26", "def countCharacters(self, words, chars):\\n        counts = [0] * 26"]}
{"id": "249", "ref_py": ["def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.", "def distributeCandies(self, candies, num_people):\\n        \\n        cur = 1\\n        ans = [0 for i in range(num_people)]\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cur <= candies:\\n                    candies -= cur\\n                    ans[i] += cur\\n                else:\\n                    ans[i] += candies\\n                    return ans\\n                cur += 1\\n        return ans", "def distributeCandies(self, candies, num_people):\\n        \\n        cur = 1\\n        ans = [0 for i in range(num_people)]\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cur <= candies:\\n                    candies -= cur\\n                    ans[i] += cur\\n                else:\\n                    ans[i] += candies\\n                    return ans\\n                cur += 1\\n        return ans"]}
{"id": "251", "ref_py": ["def inorder(root):\\n                if not root:\\n                    return\\n                inorder(root.left)\\n                .... store/use value here : root.val ....\\n                inorder(root.right)", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self):\\n        self.mp = {}"]}
{"id": "252", "ref_py": ["def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\\n\\treturn date(year, month, day).strftime(\"%A\")\\n```", "def dayOfTheWeek(self, d: int, m: int, y: int) -> str:\\n    \\treturn date(y,m,d).strftime(\"%A\")\\n\\t\\t\\n", "def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\\n\\treturn date(year, month, day).strftime(\"%A\")\\n```"]}
{"id": "253", "ref_py": ["def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)"]}
{"id": "254", "ref_py": ["def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\\n\\tminDiff = math.inf\\n\\tdic = collections.defaultdict(list)\\n\\tarr.sort()                                         ", "def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\\n        ", "def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\\n\\tminDiff = math.inf\\n\\tdic = collections.defaultdict(list)\\n\\tarr.sort()                                         "]}
{"id": "255", "ref_py": ["def uniqueOccurrences(self, arr):\\n        hash = {}\\n        for num in arr:\\n            if num not in hash:\\n                hash[num] = 1\\n            else:\\n                hash[num] += 1\\n        seen_values = set()\\n        bool1 = True", "def-4f3b-947e-f1d3d5adfa82_1663996980.2229927.png)", "def uniqueOccurrences(self, arr):\\n        hash = {}\\n        for num in arr:\\n            if num not in hash:\\n                hash[num] = 1\\n            else:\\n                hash[num] += 1\\n        seen_values = set()\\n        bool1 = True"]}
{"id": "257", "ref_py": ["def minCostToMoveChips(self, position: List[int]) -> int:\\n        ", "def minCostToMoveChips(self, position: List[int]) -> int:\\n        ", "def minCostToMoveChips(self, position: List[int]) -> int:\\n        "]}
{"id": "258", "ref_py": ["defines a class named \"Solution\" with a member function named \"balancedStringSplit\". This function takes a string \"s\" as input and returns an integer.", "defines a class named \"Solution\" with a member function named \"balancedStringSplit\". This function takes a string \"s\" as input and returns an integer.", "defines a class named \"Solution\" with a member function named \"balancedStringSplit\". This function takes a string \"s\" as input and returns an integer."]}
{"id": "259", "ref_py": ["def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        n = len(coordinates)", "def checkStraightLine(self, coordinates):\\n        \\n        if len(coordinates)<3:\\n            return True\\n        \\n        (x0,y0),(x1,y1)=coordinates[:2]", "def checkStraightLine(self, coordinates):\\n        \\n        if len(coordinates)<3:\\n            return True\\n        \\n        (x0,y0),(x1,y1)=coordinates[:2]"]}
{"id": "261", "ref_py": ["def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        ", "def isSameTree(self, p, q):\\n        ", "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        "]}
{"id": "262", "ref_py": ["def shiftGrid(self, grid, k):\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        modulo = rows * cols\\n        k = k % modulo\\n        \\n        if k == 0:\\n            return grid", "def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  ", "def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  "]}
{"id": "263", "ref_py": ["define a helper function `toTime` that calculates the time to move from one point to another. The time is the maximum of the absolute differences in x and y coordinates.\\n2. We iterate through the points, starting from the second point (index 1), and accumulate the time using the `toTime` function.\\n3. The final accumulated time is the answer.", "def minTimeToVisitAllPoints(self, p: List[List[int]]) -> int:\\n        return sum(max(abs(x1-x2), abs(y1-y2)) for (x1, y1), (x2, y2) in zip(p, p[1:]))\\n```", "define a helper function toTime that calculates the time to move from one point to another. The time is the maximum of the absolute differences in x and y coordinates.\\n2. We iterate through the points, starting from the second point (index 1), and accumulate the time using the toTime function.\\n3. The final accumulated time is the answer."]}
{"id": "264", "ref_py": ["def tictactoe(self, moves: List[List[int]]) -> str:\\n        winner = None\\n        matrix = [[0 for _ in range(3)] for _ in range(3)]", "def tictactoe(self, moves: List[List[int]]) -> str:\\n        \\n        board = [[0]*3 for _ in range(3)]\\n        \\n        i = 0\\n        while i < len(moves):\\n            x = moves[i][0]\\n            y = moves[i][1]\\n            if i % 2 == 0:\\n                board[x][y] = 7\\n            else:\\n                board[x][y] = 5\\n            i+=1\\n            \\n        print(board)\\n            \\n            ", "def tictactoe(self, moves: List[List[int]]) -> str:\\n        winner = None\\n        matrix = [[0 for _ in range(3)] for _ in range(3)]"]}
{"id": "266", "ref_py": ["def subtractProductAndSum(self, n: int) -> int:\\n        s = 0\\n        mult = 1", "def subtractProductAndSum(n)t:\\n    return eval(\\'*\\'.join(str(n))) - eval(\\'+\\'.join(str(n)))\\n```", "def subtractProductAndSum(n)t:\\n    return eval(\\'*\\'.join(str(n))) - eval(\\'+\\'.join(str(n)))\\n```"]}
{"id": "267", "ref_py": ["def findSpecialInteger(self, arr):\\n        size = len(arr)\\n        qtr = size // 4\\n        cnt = 1\\n        p = arr[0]\\n        \\n        for i in range(1, size):\\n            if p == arr[i]:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            \\n            if cnt > qtr:\\n                return arr[i]\\n            \\n            p = arr[i]", "def findSpecialInteger(self, arr):\\n        size = len(arr)\\n        qtr = size // 4\\n        cnt = 1\\n        p = arr[0]\\n        \\n        for i in range(1, size):\\n            if p == arr[i]:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            \\n            if cnt > qtr:\\n                return arr[i]\\n            \\n            p = arr[i]", "def findSpecialInteger(self, arr):\\n        size = len(arr)\\n        qtr = size // 4\\n        cnt = 1\\n        p = arr[0]\\n        \\n        for i in range(1, size):\\n            if p == arr[i]:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            \\n            if cnt > qtr:\\n                return arr[i]\\n            \\n            p = arr[i]"]}
{"id": "268", "ref_py": ["def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next"]}
{"id": "269", "ref_py": ["def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        ", "def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        ", "def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        "]}
{"id": "270", "ref_py": ["def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```", "def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```", "def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```"]}
{"id": "271", "ref_py": ["def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            ", "def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            ", "def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            "]}
{"id": "272", "ref_py": ["def freqAlphabets(self, s: str) -> str:\\n\\tres = []\\n\\ti = 0", "def freqAlphabets(self, s: str) -> str:\\n        for i in range(26,0,-1): s = s.replace(str(i)+\\'", "def freqAlphabets(self, s: str) -> str:\\n        for i in range(26,0,-1): s = s.replace(str(i)+\\'"]}
{"id": "273", "ref_py": ["def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tnums[:] = sorted(set(nums))\\n\\t\\treturn len(nums)\\n```", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  ", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  "]}
{"id": "274", "ref_py": ["def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def check(num):\\n            while num>0:\\n                if num%10==0:\\n                    return False\\n                num//=10\\n            return True\\n        for i in range(1,n):\\n            t=n-i\\n            if check(t) and check(i):\\n                return [i,t]\\n```", "def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def check(num):\\n            while num>0:\\n                if num%10==0:\\n                    return False\\n                num//=10\\n            return True\\n        for i in range(1,n):\\n            t=n-i\\n            if check(t) and check(i):\\n                return [i,t]\\n```", "def getNoZeroIntegers(self, n: int) -> List[int]:\\n        def check(num):\\n            while num>0:\\n                if num%10==0:\\n                    return False\\n                num//=10\\n            return True\\n        for i in range(1,n):\\n            t=n-i\\n            if check(t) and check(i):\\n                return [i,t]\\n```"]}
{"id": "275", "ref_py": ["def maximum69Number (self, num: int) -> int:\\n        num=str(num)\\n        t=\\'\\'\\n        n,f=len(num),0\\n        for i in range(n):\\n            if num[i]==\\'6\\' and f==0:\\n                t+=\\'9\\'\\n                f=1\\n            else:\\n                t+=num[i]\\n        return int(t)\\n```", "def maximum69Number (self, num: int) -> int:\\n        num=str(num)\\n        t=\\'\\'\\n        n,f=len(num),0\\n        for i in range(n):\\n            if num[i]==\\'6\\' and f==0:\\n                t+=\\'9\\'\\n                f=1\\n            else:\\n                t+=num[i]\\n        return int(t)\\n```", "def maximum69Number (self, num: int) -> int:\\n        num=str(num)\\n        t=\\'\\'\\n        n,f=len(num),0\\n        for i in range(n):\\n            if num[i]==\\'6\\' and f==0:\\n                t+=\\'9\\'\\n                f=1\\n            else:\\n                t+=num[i]\\n        return int(t)\\n```"]}
{"id": "277", "ref_py": ["def canConstruct(self, ransomNote, magazine):\\n        ", "def canConstruct(self, ransomNote: str, magazine: str) -> bool:\\n        return all(ransomNote.count(c) <= magazine.count(c) for c in set(ransomNote))", "def canConstruct(self, ransomNote, magazine):\\n        "]}
{"id": "278", "ref_py": ["def removePalindromeSub(self, S: str) -> int:\\n        if not S: return 0\\n        return 1 if S == S[::-1] else 2\\n```", "def removePalindromeSub(self, s: str) -> int:\\n        return 1 if s == s[::-1] else 2\\n```", "def removePalindromeSub(self, S: str) -> int:\\n        if not S: return 0\\n        return 1 if S == S[::-1] else 2\\n```"]}
{"id": "279", "ref_py": ["def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\\n        ", "def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:\\n        return sorted(range(len(mat)), key=lambda x: sum(mat[x]))[:k]\\n        \\n```", "def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:\\n        return sorted(range(len(mat)), key=lambda x: sum(mat[x]))[:k]\\n        \\n```"]}
{"id": "280", "ref_py": ["def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```", "def numberOfSteps(self, num):\\n        counter = 0\\n        while num != 0:\\n            if num%2==0:\\n                num = num//2\\n                counter += 1\\n            else:\\n                num = num - 1\\n                counter += 1\\n        return counter", "def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```"]}
{"id": "281", "ref_py": ["def checkIfExist(self, arr):\\n        \\n        for i in range(len(arr)):\\n            if arr[i]*2 in (arr[:i]+arr[i+1:]):\\n                return True\\n        \\n        return False", "def checkIfExist(self, arr):\\n        for i in range(0,len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[i]*2==arr[j] or arr[i]==arr[j]*2:\\n                    return True;\\n        return False;\\n```\\n", "def checkIfExist(self, arr):\\n        \\n        for i in range(len(arr)):\\n            if arr[i]*2 in (arr[:i]+arr[i+1:]):\\n                return True\\n        \\n        return False"]}
{"id": "282", "ref_py": ["def countNegatives(self, grid):\\n        temp = 0\\n        for x in grid:\\n            for y in x:\\n                if y < 0:\\n                    temp += 1\\n        return temp", "def countNegatives(self, grid):\\n        i = 0\\n        j = len(grid[0]) - 1\\n        count = 0\\n        \\n        while i < len(grid) and j >= 0:\\n            if grid[i][j] < 0:\\n                count += (len(grid) - i)\\n                j -= 1\\n            elif grid[i][j] >= 0:\\n                i += 1\\n        \\n        return count", "def countNegatives(self, grid):\\n        i = 0\\n        j = len(grid[0]) - 1\\n        count = 0\\n        \\n        while i < len(grid) and j >= 0:\\n            if grid[i][j] < 0:\\n                count += (len(grid) - i)\\n                j -= 1\\n            elif grid[i][j] >= 0:\\n                i += 1\\n        \\n        return count"]}
{"id": "283", "ref_py": ["def sortByBits(self, arr: List[int]) -> List[int]:\\n        ", "def sortByBits(self, arr):\\n        dror1 = list(arr)\\n        dror1.sort(key=lambda x: (bin(x).count(\\'1\\'), x))\\n        return dror1", "def sortByBits(self, arr):\\n        dror1 = list(arr)\\n        dror1.sort(key=lambda x: (bin(x).count(\\'1\\'), x))\\n        return dror1"]}
{"id": "284", "ref_py": ["def _isLeap(self,year: int) -> bool:\\n\\t    return (year%4==0 and year%100!=0)or year%400==0\\n    \\n    def _dateToDays(self,year,month,day) -> int:\\n        days_since_1970 = 0\\n        \\n        for i in range(1970, year):\\n            if self._isLeap(i):\\n                days_since_1970 += 366\\n            else:\\n                days_since_1970 += 365\\n        \\n        for i in range(1, month):\\n            if i == 2 and self._isLeap(year):\\n                days_since_1970 += 1\\n                \\n            days_since_1970 += self.month_days[i]\\n        \\n        days_since_1970 += day\\n        \\n        return days_since_1970\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = map(lambda x: int(x), date1.split(\"-\"))\\n        year2, month2, day2 = map(lambda x: int(x), date2.split(\"-\"))\\n        \\n        return abs(self._dateToDays(year1, month1, day1) - self._dateToDays(year2, month2, day2))\\n", "def _isLeap(self,year: int) -> bool:\\n\\t    return (year%4==0 and year%100!=0)or year%400==0\\n    \\n    def _dateToDays(self,year,month,day) -> int:\\n        days_since_1970 = 0\\n        \\n        for i in range(1970, year):\\n            if self._isLeap(i):\\n                days_since_1970 += 366\\n            else:\\n                days_since_1970 += 365\\n        \\n        for i in range(1, month):\\n            if i == 2 and self._isLeap(year):\\n                days_since_1970 += 1\\n                \\n            days_since_1970 += self.month_days[i]\\n        \\n        days_since_1970 += day\\n        \\n        return days_since_1970\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = map(lambda x: int(x), date1.split(\"-\"))\\n        year2, month2, day2 = map(lambda x: int(x), date2.split(\"-\"))\\n        \\n        return abs(self._dateToDays(year1, month1, day1) - self._dateToDays(year2, month2, day2))\\n", "def _isLeap(self,year: int) -> bool:\\n\\t    return (year%4==0 and year%100!=0)or year%400==0\\n    \\n    def _dateToDays(self,year,month,day) -> int:\\n        days_since_1970 = 0\\n        \\n        for i in range(1970, year):\\n            if self._isLeap(i):\\n                days_since_1970 += 366\\n            else:\\n                days_since_1970 += 365\\n        \\n        for i in range(1, month):\\n            if i == 2 and self._isLeap(year):\\n                days_since_1970 += 1\\n                \\n            days_since_1970 += self.month_days[i]\\n        \\n        days_since_1970 += day\\n        \\n        return days_since_1970\\n    \\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\\n        \\n        year1, month1, day1 = map(lambda x: int(x), date1.split(\"-\"))\\n        year2, month2, day2 = map(lambda x: int(x), date2.split(\"-\"))\\n        \\n        return abs(self._dateToDays(year1, month1, day1) - self._dateToDays(year2, month2, day2))\\n"]}
{"id": "285", "ref_py": ["def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        test_list = sorted(nums)\\n        answer = []\\n        for i in nums:\\n            answer.append(test_list.index(i))\\n        return answer\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>ordered_version = nums;\\n        vector<int>answer;\\n        sort(ordered_version.begin(), ordered_version.end());\\n        \\n        for (auto it = nums.begin(); it != nums.end(); it++){\\n            for (int i = 0; i < ordered_version.size(); i++){\\n                if ( *it == ordered_version.at(i)){\\n                    answer.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```"]}
{"id": "286", "ref_py": ["def sort_hm(self, s1,hm, keys):\\n        for k in keys:\\n            if hm[k] >0:\\n                s1 += k\\n                hm[k] -=1\\n        return s1, hm\\n    \\n    def sortString(self, s: str) -> str:\\n        ", "def sortString(self, s: str) -> str:\\n        result = []\\n        chars = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        while s:\\n            for c in chars:\\n                if c in s:\\n                    result.append(c)\\n                    s = s.replace(c,\\'\\',1)\\n                else:\\n                    chars = chars.replace(c,\\'\\')\\n            chars = chars[::-1]\\n        return \\'\\'.join(result)\\n```", "def sortString(self, s: str) -> str:\\n        result = []\\n        chars = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        while s:\\n            for c in chars:\\n                if c in s:\\n                    result.append(c)\\n                    s = s.replace(c,\\'\\',1)\\n                else:\\n                    chars = chars.replace(c,\\'\\')\\n            chars = chars[::-1]\\n        return \\'\\'.join(result)\\n```"]}
{"id": "287", "ref_py": ["def generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```", "def generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```", "def generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```"]}
{"id": "290", "ref_py": ["def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:\\n        minrow = {min(r) for r in matrix}\\n        maxcol = {max(c) for c in zip(*matrix)} ", "def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:\\n        minrow = {min(r) for r in matrix}\\n        maxcol = {max(c) for c in zip(*matrix)} ", "def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:\\n        minrow = {min(r) for r in matrix}\\n        maxcol = {max(c) for c in zip(*matrix)} "]}
{"id": "291", "ref_py": ["def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        res, buckets = 0, dict() ", "def findTheDistanceValue(self, a: List[int], b : List[int], d: int) -> int:\\n        b.sort()\\n        counter = 0\\n        for i in a :\\n            m =  0 \\n            n = len(b)\\n            flag = 0\\n            while m < n :\\n                mid = (m + n) // 2 \\n                if i < b[mid] : n = mid\\n                if i > b[mid] : m = mid + 1\\n                if i == b[mid] : \\n                    flag = 1\\n                    break\\n            if flag == 1 : continue\\n            if m == n : \\n                if m == 0 and abs(i - b[m]) > d : counter += 1\\n                elif m == len(b) and abs(i - b[m-1]) > d : counter += 1\\n                elif abs(b[m-1] - i) > d and abs(b[m] - i) > d : counter += 1\\n        return counter\\n", "def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)"]}
{"id": "292", "ref_py": ["def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1", "def searchInsert(self, nums, target):\\n        \\n        if target > nums[len(nums) - 1]:\\n            return len(nums)", "def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1"]}
{"id": "293", "ref_py": ["defines a class `Solution` with a method `lengthOfLastWord` that calculates the length of the last word in a given input string `s`. Here\\'s a brief explanation of each part of the code:", "def lengthOfLastWord(self, s):\\n        count = 0  ", "defines a class `Solution` with a method `lengthOfLastWord` that calculates the length of the last word in a given input string `s`. Here\\'s a brief explanation of each part of the code:"]}
{"id": "294", "ref_py": ["def countLargestGroup(self, n: int) -> int:\\n\\t\\t", "def countLargestGroup(self, n):\\n        \\n        def g(n):\\n            temp  = 0\\n            while n :\\n                temp += n%10\\n                n /= 10\\n            return temp\\n        rez = {}\\n        for i in range(1,n +1):\\n            temp = g(i)\\n            if temp in rez:\\n                rez[temp].append(i)\\n            else:\\n                rez[temp] = [i]\\n        temp = {}\\n        for i in rez.values():\\n            t = len(i)\\n            temp[t]=temp.get(t,0) + 1\\n        return temp[max(temp)]", "def countLargestGroup(self, n):\\n        \\n        def g(n):\\n            temp  = 0\\n            while n :\\n                temp += n%10\\n                n /= 10\\n            return temp\\n        rez = {}\\n        for i in range(1,n +1):\\n            temp = g(i)\\n            if temp in rez:\\n                rez[temp].append(i)\\n            else:\\n                rez[temp] = [i]\\n        temp = {}\\n        for i in rez.values():\\n            t = len(i)\\n            temp[t]=temp.get(t,0) + 1\\n        return temp[max(temp)]"]}
{"id": "295", "ref_py": ["def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def dfs(node, path, result):\\n            if not node:\\n                return\\n            path += str(node.val)\\n            if not node.left and not node.right:\\n                result.append(path)\\n            else:\\n                dfs(node.left, path + \\'->\\', result)\\n                dfs(node.right, path + \\'->\\', result)", "def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    ", "def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def dfs(node, path, result):\\n            if not node:\\n                return\\n            path += str(node.val)\\n            if not node.left and not node.right:\\n                result.append(path)\\n            else:\\n                dfs(node.left, path + \\'->\\', result)\\n                dfs(node.right, path + \\'->\\', result)"]}
{"id": "297", "ref_py": ["def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```", "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = set(list1) & set(list2)  ", "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```"]}
{"id": "298", "ref_py": ["def minStartValue(self, nums: List[int]) -> int:\\n        prefix_sum = 0\\n        min_start_value = 1\\n        \\n        for num in nums:\\n            prefix_sum += num\\n            min_start_value = max(min_start_value, 1 - prefix_sum)\\n        \\n        return min_start_value\\n```", "def minStartValue(self, nums: List[int]) -> int:\\n        start_n = 1\\n        cal = 0\\n        while True:\\n            cal = start_n\\n            cnt = 0\\n            for i in range(len(nums)):\\n                if cal + nums[i] >= 1:\\n                    cal = cal + nums[i]\\n                    cnt += 1\\n                else:\\n                    start_n += 1\\n                    break\\n            if cnt == len(nums):\\n                break\\n        return start_n\\n```", "def minStartValue(self, nums: List[int]) -> int:\\n        return max( 1, 1 - min(accumulate(nums, operator.add)) )\\n```"]}
{"id": "299", "ref_py": ["def reformat(self, s: str) -> str:\\n        letters = [c for c in s if c.isalpha()]\\n        digits = [c for c in s if c.isdigit()]\\n        if abs(len(letters) - len(digits)) > 1: return \"\"\\n        \\n        rv = []\\n        flag = len(letters) > len(digits)\\n        while letters or digits:\\n            rv.append(letters.pop() if flag else digits.pop())\\n            flag = not flag\\n        return rv\\n```", "def reformat(self, s: str) -> str:\\n        letters = [c for c in s if c.isalpha()]\\n        digits = [c for c in s if c.isdigit()]\\n        if abs(len(letters) - len(digits)) > 1: return \"\"\\n        \\n        rv = []\\n        flag = len(letters) > len(digits)\\n        while letters or digits:\\n            rv.append(letters.pop() if flag else digits.pop())\\n            flag = not flag\\n        return rv\\n```", "def reformat(self, s: str) -> str:\\n        letters = [c for c in s if c.isalpha()]\\n        digits = [c for c in s if c.isdigit()]\\n        if abs(len(letters) - len(digits)) > 1: return \"\"\\n        \\n        rv = []\\n        flag = len(letters) > len(digits)\\n        while letters or digits:\\n            rv.append(letters.pop() if flag else digits.pop())\\n            flag = not flag\\n        return rv\\n```"]}
{"id": "300", "ref_py": ["def maxScore(self, s):\\n        length = len(s)\\n        ones = 0\\n        tmpScore = 1 if s[0] == \\'0\\' else 0\\n        score = tmpScore\\n        \\n        for i in range(1, length - 1):\\n            if s[i] == \\'0\\':\\n                tmpScore += 1\\n            else:\\n                ones += 1\\n                tmpScore -= 1", "def maxScore(self, s: str) -> int:\\n        one_count = s.count(\\'1\\')\\n        res = 0\\n        zero_count = 0\\n        for i in range(len(s) - 1):\\n            if s[i] == \\'1\\':\\n                one_count -= 1\\n            else:\\n                zero_count += 1\\n            res = max(res, zero_count + one_count)\\n        return res", "def max_score(str):\\n    result = 0\\n    for i in range(len(str) - 1):\\n        current_score = 0\\n        for j in range(i + 1):\\n            if str[j] == \\'0\\':\\n                current_score += 1\\n        for j in range(i + 1, len(str)):\\n            if str[j] == \\'1\\':\\n                current_score += 1\\n        result = max(result, current_score)\\n    return result"]}
{"id": "301", "ref_py": ["def kidsWithCandies(self, candies, extraCandies):\\n        max_candies = max(candies)\\n        \\n        result = []\\n        \\n        for candy in candies:\\n            if candy + extraCandies >= max_candies:\\n                result.append(True)\\n            else:\\n                result.append(False)\\n        \\n        return result\\n```\\n```java []\\nclass Solution {\\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\\n        int maxCandies = 0;\\n        for (int candy : candies) {\\n            maxCandies = Math.max(maxCandies, candy);\\n        }\\n        \\n        List<Boolean> result = new ArrayList<>();\\n        \\n        for (int candy : candies) {\\n            if (candy + extraCandies >= maxCandies) {\\n                result.add(true);\\n            } else {\\n                result.add(false);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```", "def kidsWithCandies(self, candies, extraCandies):\\n    mostCandies = max(candies)\\n    return map(\\n        lambda candyAmount: candyAmount + extraCandies >= mostCandies, \\n        candies\\n    )\\n```\\n```C++ []\\nvector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\\n    int mostCandies = *std::max_element(candies.begin(), candies.end());\\n    std::vector<bool> result(candies.size());\\n    std::transform(candies.begin(), candies.end(), result.begin(), \\n        [&] (const int & candyAmount) {\\n            return candyAmount + extraCandies >= mostCandies;\\n        }\\n    );\\n    return result;\\n}", "def kidsWithCandies(self, candies, extraCandies):\\n    mostCandies = max(candies)\\n    return map(\\n        lambda candyAmount: candyAmount + extraCandies >= mostCandies, \\n        candies\\n    )\\n```\\n```C++ []\\nvector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\\n    int mostCandies = *std::max_element(candies.begin(), candies.end());\\n    std::vector<bool> result(candies.size());\\n    std::transform(candies.begin(), candies.end(), result.begin(), \\n        [&] (const int & candyAmount) {\\n            return candyAmount + extraCandies >= mostCandies;\\n        }\\n    );\\n    return result;\\n}"]}
{"id": "302", "ref_py": ["def destCity(self, paths):\\n        cities = set()", "def destCity(self, paths):\\n        cities = set()", "def destCity(self, paths):\\n        cities = set()"]}
{"id": "303", "ref_py": ["def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []", "def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []", "def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []"]}
{"id": "304", "ref_py": ["def maxPower(self, s: str) -> int:\\n        res=1\\n        c=1\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                c=c+1\\n            else:\\n                res=max(res,c)\\n                c=1\\n        res=max(res,c)\\n        return res\\n        \\n", "def maxPower(self, s: str) -> int:\\n        res=1\\n        c=1\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                c=c+1\\n            else:\\n                res=max(res,c)\\n                c=1\\n        res=max(res,c)\\n        return res\\n        \\n", "def maxPower(self, s: str) -> int:\\n        res=1\\n        c=1\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                c=c+1\\n            else:\\n                res=max(res,c)\\n                c=1\\n        res=max(res,c)\\n        return res\\n        \\n"]}
{"id": "305", "ref_py": ["def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\\n\\treturn sum([i <= queryTime and queryTime <= j for i, j in zip(startTime, endTime)])\\n```", "def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\\n\\treturn sum([i <= queryTime and queryTime <= j for i, j in zip(startTime, endTime)])\\n```", "def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\\n\\treturn sum([i <= queryTime and queryTime <= j for i, j in zip(startTime, endTime)])\\n```"]}
{"id": "306", "ref_py": ["def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for i, word in enumerate(words):\\n            if word.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```", "def isPrefixOfWord(self, sentence, searchWord):\\n        \\n        sentence = sentence.split()\\n        res = 0\\n        for i in range(len(sentence)):\\n            if sentence[i][:len(searchWord)] == searchWord:\\n                res = i + 1\\n                break\\n        return -1 if res == 0 else res", "def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for i, word in enumerate(words):\\n            if word.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```"]}
{"id": "307", "ref_py": ["def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        "]}
{"id": "308", "ref_py": ["def maxProduct(self, nums):\\n        max1 = float(\\'-inf\\')\\n        max2 = float(\\'-inf\\')", "def maxProduct(self, nums):\\n        max1 = float(\\'-inf\\')\\n        max2 = float(\\'-inf\\')", "def maxProduct(self, nums):\\n        max1 = float(\\'-inf\\')\\n        max2 = float(\\'-inf\\')"]}
{"id": "309", "ref_py": ["def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        new_list = []\\n        for i in range(len(nums)//2):\\n            new_list.append(nums[i])\\n            new_list.append(nums[i+n])\\n        return new_list\\n```\\n", "def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        new_list = []\\n        for i in range(len(nums)//2):\\n            new_list.append(nums[i])\\n            new_list.append(nums[i+n])\\n        return new_list\\n```\\n", "def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        new_list = []\\n        for i in range(len(nums)//2):\\n            new_list.append(nums[i])\\n            new_list.append(nums[i+n])\\n        return new_list\\n```\\n"]}
{"id": "310", "ref_py": ["def finalPrices(self, prices: List[int]) -> List[int]:\\n        stack = [] ", "def finalPrices(self, prices: List[int]) -> List[int]:\\n        stack = [] ", "def finalPrices(self, prices: List[int]) -> List[int]:\\n        stack = [] "]}
{"id": "311", "ref_py": ["def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []", "def runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] ", "def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []"]}
{"id": "313", "ref_py": ["def xorOperation(self, n: int, start: int) -> int:\\n        \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        \\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```", "def xorOperation(self, n: int, start: int) -> int:\\n        \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        \\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```", "def xorOperation(self, n: int, start: int) -> int:\\n        \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        \\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```"]}
{"id": "314", "ref_py": ["def average(self, salary):\\n        s=0.0\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop()\\n        for i in salary:\\n            s=s+i\\n        var=s/len(salary)\\n        return var", "def average(self, salary):\\n        s=0.0\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop()\\n        for i in salary:\\n            s=s+i\\n        var=s/len(salary)\\n        return var", "def average(self, salary):\\n        s=0.0\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop()\\n        for i in salary:\\n            s=s+i\\n        var=s/len(salary)\\n        return var"]}
{"id": "315", "ref_py": ["def isPathCrossing(self, path):\\n        moves = {\\n            \"N\": (0, 1),\\n            \"S\": (0, -1),\\n            \"W\": (-1, 0),\\n            \"E\": (1, 0)\\n        }\\n        \\n        visited = {(0, 0)}\\n        x = 0\\n        y = 0", "def isPathCrossing(self, path: str) -> bool:\\n        x, y = 0, 0\\n        visited = {(0, 0)}", "def isPathCrossing(movementPath):\\n    visitedPoints = set()\\n    currentX, currentY = 0, 0\\n    visitedPoints.add((currentX, currentY))"]}
{"id": "316", "ref_py": ["default in AP and return TRUE.", "def canMakeArithmeticProgression(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        for x,y in zip(arr,arr[1:]):\\n            if y-x!=arr[1]-arr[0]:\\n                return False", "def canMakeArithmeticProgression(self, arr):\\n        arr.sort()  "]}
{"id": "317", "ref_py": ["def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()", "def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()", "def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()"]}
{"id": "318", "ref_py": ["def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashtable={}\\n        for i in nums:\\n            if i in hashtable:\\n                hashtable[i]=hashtable[i]+1\\n            else:\\n                hashtable[i]=1\\n        sum=0\\n        for i in hashtable:\\n            n=hashtable[i]\\n            if n>1:\\n                sum=sum+(n*(n-1))/2\\n        return int(sum)\\n        ", "defines a C++ class named Solution with a member function numIdenticalPairs. The purpose of this function is to count the number of identical pairs in a given vector of integers.", "def numIdenticalPairs(self, nums: List[int]) -> int:\\n        hashtable={}\\n        for i in nums:\\n            if i in hashtable:\\n                hashtable[i]=hashtable[i]+1\\n            else:\\n                hashtable[i]=1\\n        sum=0\\n        for i in hashtable:\\n            n=hashtable[i]\\n            if n>1:\\n                sum=sum+(n*(n-1))/2\\n        return int(sum)\\n        "]}
{"id": "320", "ref_py": ["def numWaterBottles(self, numBottles: int, numExchange: int) -> int:\\n        result = numBottles\\n        drunk, empty = divmod(numBottles, numExchange)\\n        while drunk:\\n            result += drunk\\n            drunk, empty = divmod(empty + drunk, numExchange)\\n        return result\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    pair<int, int> divmod(int dividend, int divisor) {\\n        int quotient = dividend / divisor;\\n        int remainder = dividend % divisor;\\n        return make_pair(quotient, remainder);\\n    }\\n    int numWaterBottles(int numBottles, int numExchange) {\\n        int result = numBottles;\\n        pair<int, int> div = divmod(numBottles, numExchange);\\n        int drunk = div.first;\\n        int empty = div.second;\\n        while(drunk) {\\n            result += drunk;\\n            div = divmod(drunk + empty, numExchange);\\n            drunk = div.first;\\n            empty = div.second;\\n        }\\n        return result;\\n    }\\n};\\n```\\n", "def numWaterBottles(self, numBottles: int, numExchange: int) -> int:\\n        result = numBottles\\n        drunk, empty = divmod(numBottles, numExchange)\\n        while drunk:\\n            result += drunk\\n            drunk, empty = divmod(empty + drunk, numExchange)\\n        return result\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    pair<int, int> divmod(int dividend, int divisor) {\\n        int quotient = dividend / divisor;\\n        int remainder = dividend % divisor;\\n        return make_pair(quotient, remainder);\\n    }\\n    int numWaterBottles(int numBottles, int numExchange) {\\n        int result = numBottles;\\n        pair<int, int> div = divmod(numBottles, numExchange);\\n        int drunk = div.first;\\n        int empty = div.second;\\n        while(drunk) {\\n            result += drunk;\\n            div = divmod(drunk + empty, numExchange);\\n            drunk = div.first;\\n            empty = div.second;\\n        }\\n        return result;\\n    }\\n};\\n```\\n", "def numWaterBottles(self, numBottles: int, numExchange: int) -> int:\\n        result = numBottles\\n        drunk, empty = divmod(numBottles, numExchange)\\n        while drunk:\\n            result += drunk\\n            drunk, empty = divmod(empty + drunk, numExchange)\\n        return result\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    pair<int, int> divmod(int dividend, int divisor) {\\n        int quotient = dividend / divisor;\\n        int remainder = dividend % divisor;\\n        return make_pair(quotient, remainder);\\n    }\\n    int numWaterBottles(int numBottles, int numExchange) {\\n        int result = numBottles;\\n        pair<int, int> div = divmod(numBottles, numExchange);\\n        int drunk = div.first;\\n        int empty = div.second;\\n        while(drunk) {\\n            result += drunk;\\n            div = divmod(drunk + empty, numExchange);\\n            drunk = div.first;\\n            empty = div.second;\\n        }\\n        return result;\\n    }\\n};\\n```\\n"]}
{"id": "321", "ref_py": ["def countOdds(self, low, high):\\n        \\n        totalNumbers = high - low\\n        result = totalNumbers // 2", "def countOdds(self, low, high):\\n        \\n        totalNumbers = high - low\\n        result = totalNumbers // 2", "def countOdds(self, low, high):\\n        \\n        totalNumbers = high - low\\n        result = totalNumbers // 2"]}
{"id": "323", "ref_py": ["def restoreString(self, s, indices):\\n        ", "defines a class Solution with a method restoreString that is used to restore the original string from a given string s and a list of indices indices. The indices list indicates the order in which characters of the original string should be rearranged.", "defines a class Solution with a method restoreString that is used to restore the original string from a given string s and a list of indices indices. The indices list indicates the order in which characters of the original string should be rearranged."]}
{"id": "324", "ref_py": ["def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        size = len(arr)\\n        \\n        good_count = 0\\n        \\n        for i in range(size-2):\\n            for j in range(i+1, size-1):\\n                for k in range(j+1, size):\\n                    \\n                    ok_a = abs(arr[i] - arr[j]) <= a\\n                    ok_b = abs(arr[j] - arr[k]) <= b\\n                    ok_c = abs(arr[i] - arr[k]) <= c\\n                    \\n                    if all((ok_a, ok_b, ok_c)):\\n                        good_count += 1\\n                        \\n                        \\n        return good_count", "def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        ", "def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        "]}
{"id": "325", "ref_py": ["def findKthPositive(self, arr, k):\\n        \\n        left, right = 0, len(arr) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if arr[mid] - mid - 1 < k:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return left + k", "def findKthPositive(self, arr, k):\\n        \\n        left, right = 0, len(arr) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if arr[mid] - mid - 1 < k:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return left + k", "def findKthPositive(self, arr, k):\\n        \\n        left, right = 0, len(arr) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if arr[mid] - mid - 1 < k:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return left + k"]}
{"id": "326", "ref_py": ["def makeGood(self, s: str) -> str:\\n        def removeadj(s):\\n            i,n=0,len(s)\\n            t=\\'\\'\\n            while i<n:\\n                if i+1!=n and (ord(s[i+1])+32 == ord(s[i]) or ord(s[i+1]) == ord(s[i])+32):\\n                    i+=2\\n                else:\\n                    t+=s[i]\\n                    i+=1\\n            return t\\n        n=len(s)\\n        s=removeadj(s)\\n        while n!=len(s): ", "def makeGood(self, s: str) -> str:\\n        def removeadj(s):\\n            i,n=0,len(s)\\n            t=\\'\\'\\n            while i<n:\\n                if i+1!=n and (ord(s[i+1])+32 == ord(s[i]) or ord(s[i+1]) == ord(s[i])+32):\\n                    i+=2\\n                else:\\n                    t+=s[i]\\n                    i+=1\\n            return t\\n        n=len(s)\\n        s=removeadj(s)\\n        while n!=len(s): ", "def makeGood(self, s: str) -> str:\\n        def removeadj(s):\\n            i,n=0,len(s)\\n            t=\\'\\'\\n            while i<n:\\n                if i+1!=n and (ord(s[i+1])+32 == ord(s[i]) or ord(s[i+1]) == ord(s[i])+32):\\n                    i+=2\\n                else:\\n                    t+=s[i]\\n                    i+=1\\n            return t\\n        n=len(s)\\n        s=removeadj(s)\\n        while n!=len(s): "]}
{"id": "327", "ref_py": ["def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        "]}
{"id": "328", "ref_py": ["def thousandSeparator(self, n):\\n        \\n        n = str(n)\\n        if len(n) <= 3:\\n            return str(n)\\n        result = \"\"      \\n        dot = \\'.\\'\\n        index = 0\\n        startPos = len(n) % 3 \\n        if startPos == 0:\\n            startPos += 3\\n        val = -1\\n        while index < len(n):\\n            result += n[index]\\n            if index == startPos - 1:\\n                result += dot\\n                val = 0\\n            if val != -1:\\n                val += 1\\n                if val > 3 and (val - 1) % 3 == 0 and index != len(n) - 1:\\n                    result += dot\\n                    val = 1  \\n            index += 1", "def thousandSeparator(self, n):\\n        \\n        n = str(n)\\n        if len(n) <= 3:\\n            return str(n)\\n        result = \"\"      \\n        dot = \\'.\\'\\n        index = 0\\n        startPos = len(n) % 3 \\n        if startPos == 0:\\n            startPos += 3\\n        val = -1\\n        while index < len(n):\\n            result += n[index]\\n            if index == startPos - 1:\\n                result += dot\\n                val = 0\\n            if val != -1:\\n                val += 1\\n                if val > 3 and (val - 1) % 3 == 0 and index != len(n) - 1:\\n                    result += dot\\n                    val = 1  \\n            index += 1", "def thousandSeparator(self, n):\\n        \\n        n = str(n)\\n        if len(n) <= 3:\\n            return str(n)\\n        result = \"\"      \\n        dot = \\'.\\'\\n        index = 0\\n        startPos = len(n) % 3 \\n        if startPos == 0:\\n            startPos += 3\\n        val = -1\\n        while index < len(n):\\n            result += n[index]\\n            if index == startPos - 1:\\n                result += dot\\n                val = 0\\n            if val != -1:\\n                val += 1\\n                if val > 3 and (val - 1) % 3 == 0 and index != len(n) - 1:\\n                    result += dot\\n                    val = 1  \\n            index += 1"]}
{"id": "329", "ref_py": ["def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        ", "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        ", "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        "]}
{"id": "330", "ref_py": ["def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\\n\\ti = 0\\n\\twhile i <= len(arr)-1:\\n\\t\\tp = arr[i:i+m]\\n\\t\\tif p * k == arr[i:i+m*k]:\\n\\t\\t\\treturn True", "def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\\n\\ti = 0\\n\\twhile i <= len(arr)-1:\\n\\t\\tp = arr[i:i+m]\\n\\t\\tif p * k == arr[i:i+m*k]:\\n\\t\\t\\treturn True", "def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\\n\\ti = 0\\n\\twhile i <= len(arr)-1:\\n\\t\\tp = arr[i:i+m]\\n\\t\\tif p * k == arr[i:i+m*k]:\\n\\t\\t\\treturn True"]}
{"id": "331", "ref_py": ["def diagonalSum(self, mat):\\n        \\n        s=0\\n        for i in range(0,len(mat)):\\n            a=mat[i][i]\\n            b=mat[i][len(mat)-i-1]\\n            s=s+a+b\\n        if len(mat)%2==0:\\n            return(s)\\n        else:\\n            mid=(1+len(mat))/2-1\\n            return(s-mat[mid][mid])", "def diagonalSum(self, mat: list[list[int]]) -> int:\\n        return (n := len(mat)) and sum(\\n            mat[i][i] + mat[i][n - 1 - i] for i in range(n)\\n        ) - mat[n // 2][n // 2] * (n % 2)", "def diagonalSum(self, mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        res = 0\\n\\t\\t"]}
{"id": "332", "ref_py": ["def modifyString(self, s: str) -> str:\\n\\ts = list(s)", "def modifyString(self, s: str) -> str:\\n\\ts = list(s)", "def modifyString(self, s: str) -> str:\\n\\ts = list(s)"]}
{"id": "334", "ref_py": ["def numSpecial(self, mat):\\n        specials = 0", "def numSpecial(self, mat: List[List[int]]) -> int:\\n        return sum(\\n            sum(mat[i][col] for i in range(len(mat))) == 1\\n            for col in [\\n                row.index(1)\\n                for row in mat\\n                if sum(row) == 1\\n            ]\\n        )", "def numSpecial(self, mat: List[List[int]]) -> int:\\n        return sum(\\n            sum(mat[i][col] for i in range(len(mat))) == 1\\n            for col in [\\n                row.index(1)\\n                for row in mat\\n                if sum(row) == 1\\n            ]\\n        )"]}
{"id": "336", "ref_py": ["def sumOddLengthSubarrays(self, arr: List[int]) -> int:\\n        ", "def sumOddLengthSubarrays(self, arr: List[int]) -> int:\\n        ", "def sumOddLengthSubarrays(self, arr: List[int]) -> int:\\n        "]}
{"id": "337", "ref_py": ["def reorderSpaces(self, text):\\n        \\n", "def reorderSpaces(self, text):\\n        word_list = text.split()\\n        words, spaces = len(word_list), text.count(\" \")\\n        \\n        if words > 1:\\n            q, r = spaces//(words-1), spaces%(words-1)\\n            return (\" \" * q).join(word_list) + \" \" * r\\n        else:\\n            return \"\".join(word_list) + \" \" * spaces\\n```", "def reorderSpaces(self, text):\\n        word_list = text.split()\\n        words, spaces = len(word_list), text.count(\" \")\\n        \\n        if words > 1:\\n            q, r = spaces//(words-1), spaces%(words-1)\\n            return (\" \" * q).join(word_list) + \" \" * r\\n        else:\\n            return \"\".join(word_list) + \" \" * spaces\\n```"]}
{"id": "338", "ref_py": ["def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)", "def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t", "def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)"]}
{"id": "340", "ref_py": ["def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     "]}
{"id": "341", "ref_py": ["def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) ", "def findTheDifference(self, s: str, t: str) -> str:\\n        char_count = {}\\n        \\n        ", "def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) "]}
{"id": "342", "ref_py": ["def quickSelect(arr, start, end, k):\\n            pivot = arr[end]\\n            left = start", "def quickSelect(arr, start, end, k):\\n            pivot = arr[end]\\n            left = start", "def quickSelect(arr, start, end, k):\\n            pivot = arr[end]\\n            left = start"]}
{"id": "343", "ref_py": ["def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ", "def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ", "def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        "]}
{"id": "344", "ref_py": ["def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        dics = collections.defaultdict(list)\\n        max_length = releaseTimes[0]\\n        \\n        dics[max_length].append(keysPressed[0])\\n        \\n        for i in range(1, len(releaseTimes)):\\n            length = releaseTimes[i] - releaseTimes[i - 1]\\n            \\n            if length >= max_length:\\n                dics[length].append(keysPressed[i])\\n                max_length = length\\n                \\n        \\n        dics[max_length].sort()\\n        \\n        return dics[max_length][len(dics[max_length]) - 1]\\n```", "def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\tkey = [keysPressed[0]]\\n\\tmax_dur = releaseTimes[0]", "def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_dur = releaseTimes[0]\\n        max_key = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            if releaseTimes[i] - releaseTimes[i-1] > max_dur:\\n                max_dur = releaseTimes[i] - releaseTimes[i-1]\\n                max_key = keysPressed[i]\\n            elif releaseTimes[i] - releaseTimes[i-1] == max_dur and max_key < keysPressed[i]:\\n                 max_key = keysPressed[i]\\n                    \\n        return max_key \\n```\\t\\t\\n"]}
{"id": "346", "ref_py": ["def frequencySort(self, nums):\\n        dic={}\\n        for i in set(nums):\\n            dic[nums.count(i)]=[]\\n        print(dic.keys(), dic.values())", "def frequencySort(self, nums):\\n        \\n        \\n        mostCommon = Counter(nums).most_common()\\n        mostCommon.sort(key = lambda x: x[0], reverse=True)\\n        mostCommon.sort(key = lambda x: x[1])\\n        \\n        frequencyResult = []\\n        for item in mostCommon:\\n            x, y = item\\n            frequencyResult.extend([x]*y)\\n            \\n        return frequencyResult\\n        \\n```", "default, Feb  3 2021, 07:38:02)\\n[Clang 12.0.0 (clang-1200.0.32.29)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums = [1,1,2,2,2,6,6,4,4,5,5,3]\\n```"]}
{"id": "347", "ref_py": ["def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\\n        hashmap = {}\\n        for i in range(len(pieces)):\\n            hashmap[pieces[i][0]] = pieces[i]\\n        print(hashmap)    \\n        i = 0    \\n        while i<len(arr):\\n            if arr[i] not in hashmap.keys():\\n                return False\\n            \\n            else:\\n                lis = hashmap[arr[i]]\\n                \\n                for j in range(len(lis)):\\n                    \\n                    if lis[j] != arr[i]:\\n                        return False\\n                    i += 1\\n       \\n        return True", "def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\\n        hashmap = {}\\n        for i in range(len(pieces)):\\n            hashmap[pieces[i][0]] = pieces[i]\\n        print(hashmap)    \\n        i = 0    \\n        while i<len(arr):\\n            if arr[i] not in hashmap.keys():\\n                return False\\n            \\n            else:\\n                lis = hashmap[arr[i]]\\n                \\n                for j in range(len(lis)):\\n                    \\n                    if lis[j] != arr[i]:\\n                        return False\\n                    i += 1\\n       \\n        return True", "def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\\n        hashmap = {}\\n        for i in range(len(pieces)):\\n            hashmap[pieces[i][0]] = pieces[i]\\n        print(hashmap)    \\n        i = 0    \\n        while i<len(arr):\\n            if arr[i] not in hashmap.keys():\\n                return False\\n            \\n            else:\\n                lis = hashmap[arr[i]]\\n                \\n                for j in range(len(lis)):\\n                    \\n                    if lis[j] != arr[i]:\\n                        return False\\n                    i += 1\\n       \\n        return True"]}
{"id": "348", "ref_py": ["def getMaximumGenerated(self, n: int) -> int:\\n\\tif not n:\\n\\t\\treturn n", "def getMaximumGenerated(self, n: int) -> int:\\n\\t\\t\\tif n==0: return 0\\n\\t\\t\\tarr = [0, 1]\\n\\t\\t\\tfor i in range(2, n+1):\\n\\t\\t\\t\\tif i%2==0:\\n\\t\\t\\t\\t\\tarr.append(arr[i//2])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tarr.append(arr[i//2] + arr[i//2 + 1])\\n\\t\\t\\treturn max(arr)\\n\\t\\t\\t\\nThe Basic Idea is that given our constraints and the Question itself, we can simply just generate the array by simulating what is needed. So, we start with our base array of `[0, 1]` and for any `N > 1` we generate the array as following:\\n* If our index is even: we divide the index by 2 and append that result to our base array.\\n* If our index is odd: we divide the index by 2 ( and considering only the integer of it, so 7//2 = 3 and not 3.5 ) and use that index and the next of that index.", "def getMaximumGenerated(self, n: int) -> int:\\n\\t\\t\\tif n==0: return 0\\n\\t\\t\\tarr = [0, 1]\\n\\t\\t\\tfor i in range(2, n+1):\\n\\t\\t\\t\\tif i%2==0:\\n\\t\\t\\t\\t\\tarr.append(arr[i//2])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tarr.append(arr[i//2] + arr[i//2 + 1])\\n\\t\\t\\treturn max(arr)\\n\\t\\t\\t\\nThe Basic Idea is that given our constraints and the Question itself, we can simply just generate the array by simulating what is needed. So, we start with our base array of `[0, 1]` and for any `N > 1` we generate the array as following:\\n* If our index is even: we divide the index by 2 and append that result to our base array.\\n* If our index is odd: we divide the index by 2 ( and considering only the integer of it, so 7//2 = 3 and not 3.5 ) and use that index and the next of that index."]}
{"id": "349", "ref_py": ["def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```", "def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```", "def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```"]}
{"id": "352", "ref_py": ["def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        return \\'\\'.join(word1) == \\'\\'.join(word2)\\n```\\nBut LeetCode is coding/algorithm platform, so I will take anoter away.", "def arrayStringsAreEqual(self, word1, word2):\\t\\n\\treturn \\'\\'.join(word1) == \\'\\'.join(word2)\\n```", "def arrayStringsAreEqual(self, word1, word2):\\t\\n\\treturn \\'\\'.join(word1) == \\'\\'.join(word2)\\n```"]}
{"id": "354", "ref_py": ["def maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0", "def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n\\t\\t\\n        while True:\\n\\t\\t\\n            if k*word not in sequence:\\n                return k-1\\n", "def maxRepeating(self, sequence: str, word: str) -> int:\\n        count=0\\n        while True:\\n            if word*(count+1) not in sequence:\\n                return count\\n            count+=1\\n```\\n\\tE.g.:\\n\\tSequence = \"ababa\"\\n\\tword = \"ab\"\\n\\t\\n\\t1. Initially set count to 0, saying that word might not be present in sequence.\\n\\t2. word * (count+1) = word * (0+1) = word * 1 = word = ab is present in sequence. Increment count by 1, count =1.\\n\\t3. Now, word * (count+1) = word * (1+1) = word * 2 = abab is also present in sequence. Increment count by 1, count=2.\\n"]}
{"id": "355", "ref_py": ["def destCity(self, paths):\\n        cities = set()", "def destCity(self, paths):\\n        cities = set()", "def destCity(self, paths):\\n        cities = set()"]}
{"id": "356", "ref_py": ["def interpret(command):\\n  \\n  return_string = \"\"\\n  i = 0\\n  while i < len(command):\\n    if command[i] == \"G\":\\n      return_string += \\'G\\'\\n      i += 1\\n    elif command[i:i + 2] == \\'()\\':\\n      return_string += \\'o\\'\\n      i += 2\\n    else:\\n      \\'\\'\\'when command[i:i+3] == \"Cal)\"\\n             or command[i] == \\'(\\'\\n             but command[i+1] != \\')\\'\\n          \\'\\'\\'\\n      return_string += \\'al\\'\\n      i += 4\\n  \\n  return return_string\\n```\\nUse for loop if you want:\\n```\\n", "def interpret(command):\\n  \\n  return_string = \"\"\\n  i = 0\\n  while i < len(command):\\n    if command[i] == \"G\":\\n      return_string += \\'G\\'\\n      i += 1\\n    elif command[i:i + 2] == \\'()\\':\\n      return_string += \\'o\\'\\n      i += 2\\n    else:\\n      \\'\\'\\'when command[i:i+3] == \"Cal)\"\\n             or command[i] == \\'(\\'\\n             but command[i+1] != \\')\\'\\n          \\'\\'\\'\\n      return_string += \\'al\\'\\n      i += 4\\n  \\n  return return_string\\n```\\nUse for loop if you want:\\n```\\n", "def interpret(command):\\n  \\n  return_string = \"\"\\n  i = 0\\n  while i < len(command):\\n    if command[i] == \"G\":\\n      return_string += \\'G\\'\\n      i += 1\\n    elif command[i:i + 2] == \\'()\\':\\n      return_string += \\'o\\'\\n      i += 2\\n    else:\\n      \\'\\'\\'when command[i:i+3] == \"Cal)\"\\n             or command[i] == \\'(\\'\\n             but command[i+1] != \\')\\'\\n          \\'\\'\\'\\n      return_string += \\'al\\'\\n      i += 4\\n  \\n  return return_string\\n```\\nUse for loop if you want:\\n```\\n"]}
{"id": "358", "ref_py": ["def searchBST(self, root, val):\\n        ", "def searchBST(self, root, val):\\n        ", "def searchBST(self, root, val):\\n        "]}
{"id": "359", "ref_py": ["def numberOfMatches(self, n):\\n        return n - 1\\n```", "def numberOfMatches(self, n):\\n        return n - 1\\n```", "def numberOfMatches(self, n):\\n        return n - 1\\n```"]}
{"id": "361", "ref_py": ["def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```", "def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```", "def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```"]}
{"id": "362", "ref_py": ["def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\\n        count = 0\\n        while len(students) > count:\\n            if students[0] == sandwiches[0]:\\n                sandwiches.pop(0)\\n                count = 0\\n            else:\\n                students.append(students[0])\\n                count+=1", "def countStu(stu,sand):\\n    while sand:\\n        if sand[0] in stu:\\n            stu.remove(sand[0])\\n            sand.pop(0)\\n        else:break\\n    return len(sand)\\n```", "def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\\n        count = 0\\n        while len(students) > count:\\n            if students[0] == sandwiches[0]:\\n                sandwiches.pop(0)\\n                count = 0\\n            else:\\n                students.append(students[0])\\n                count+=1"]}
{"id": "363", "ref_py": ["def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for i, word in enumerate(words):\\n            if word.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```", "def isPrefixOfWord(self, sentence, searchWord):\\n        \\n        sentence = sentence.split()\\n        res = 0\\n        for i in range(len(sentence)):\\n            if sentence[i][:len(searchWord)] == searchWord:\\n                res = i + 1\\n                break\\n        return -1 if res == 0 else res", "def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\\n        words = sentence.split()\\n        indicies = []\\n        for i, word in enumerate(words):\\n            if word.startswith(searchWord):\\n                return i + 1\\n        return -1\\n```"]}
{"id": "364", "ref_py": ["def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda a:-a[1])\\n\\tmax_units = 0\\n\\tfor box in boxTypes:\\n\\t\\tif truckSize < 0 : break\\n\\t\\tmax_units += min(truckSize, box[0]) * box[1]\\n\\t\\ttruckSize -= box[0]\\n\\treturn max_units\\n```", "def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        ", "def maximumUnits(self, B: List[List[int]], T: int) -> int:\\n        B.sort(key=lambda x: x[1], reverse=True)\\n        ans = 0\\n        for b,n in B:\\n            boxes = min(b, T)\\n            ans += boxes * n\\n            T -= boxes\\n            if T == 0: return ans\\n        return ans\\n```"]}
{"id": "365", "ref_py": ["def solve(self, week):\\n        result = 0\\n        for i in range(week):\\n            result += 28 + (i * 7)\\n        return result", "def totalMoney(self, n: int) -> int:\\n        total = 0\\n        \\n        for day in range(n):\\n            total += (day // 7 + 1) + (day % 7)\\n        \\n        return total\\n```\\n```javascript []\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalMoney = function(n) {\\n    let total = 0;", "def total_money(n):\\n  sum = 0\\n  current_value = 1\\n  for i in range(1, n + 1):\\n    sum += current_value"]}
{"id": "366", "ref_py": ["def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```", "def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```", "def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```"]}
{"id": "367", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "370", "ref_py": ["def largestAltitude(self, gain: List[int]) -> int:\\n        highest_point = 0\\n        prev_altitude = 0\\n        for i in gain:\\n            prev_altitude += i\\n            highest_point = max(highest_point, prev_altitude)", "def largestAltitude(self, gain):\\n        sol = 0\\n        curHeight = 0", "def largestAltitude(self, gain: List[int]) -> int:\\n        highest_point = 0\\n        prev_altitude = 0\\n        for i in gain:\\n            prev_altitude += i\\n            highest_point = max(highest_point, prev_altitude)"]}
{"id": "371", "ref_py": ["def str2num(s):\\n    res = 0\\n    for digit in s:\\n        res = res * 10 + int(digit)\\n    return res\\n```", "def titleToNumber(self, columnTitle):\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\\n            \\n", "def titleToNumber(self, columnTitle):\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\\n            \\n"]}
{"id": "373", "ref_py": ["def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        \\n        ", "def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        \\n        ", "def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        \\n        "]}
{"id": "374", "ref_py": ["def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []", "def runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] ", "def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []"]}
{"id": "375", "ref_py": ["def check(self, nums):\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            if i==0:\\n                return 1\\n            if nums[i]<nums[i-1]:\\n                break\\n        for j in range(i):\\n            if nums[j]>nums[j+1]:\\n                break\\n        if i-j==0 or i-j==1 and nums[-1] <= nums[0]:\\n            return 1\\n        else:\\n            return 0", "def check_rotation(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        elif nums[mid] < nums[right]:\\n            right = mid\\n        else:\\n            right -= 1\\n    return left == right and all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\\n```\\n", "def check_rotation(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        elif nums[mid] < nums[right]:\\n            right = mid\\n        else:\\n            right -= 1\\n    return left == right and all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\\n```\\n"]}
{"id": "377", "ref_py": ["def minOperations(self, s):\\n        c_0 = s[0]\\n        count1 = self.count(s, c_0)\\n        count2 = self.count(s, \\'0\\' if c_0 == \\'1\\' else \\'1\\') + 1\\n        return min(count1, count2)", "def minOperations(s: str) -> int:\\n    countForAlternate0 = 0\\n    countForAlternate1 = 0", "def minOperations(self, s: str) -> int:\\n        start0 = 0\\n        start1 = 0\\n        \\n        for i in range(len(s)):\\n            if i % 2 == 0:\\n                if s[i] == \"0\":\\n                    start1 += 1\\n                else:\\n                    start0 += 1\\n            else:\\n                if s[i] == \"1\":\\n                    start1 += 1\\n                else:\\n                    start0 += 1\\n        \\n        return min(start0, start1)"]}
{"id": "378", "ref_py": ["def longestNiceSubstring(self, s: str) -> str:\\n        \\n        if set(s) == set(s.swapcase()):\\n            return s\\n        \\n        orphan = set(s) - set(s.swapcase())\\n        \\n        return max(map(self.longestNiceSubstring, re.split(\"|\".join(orphan), s)), key=len)", "def longestNiceSubstring(self, s: str) -> str:\\n        \\n        if set(s) == set(s.swapcase()):\\n            return s\\n        \\n        orphan = set(s) - set(s.swapcase())\\n        \\n        return max(map(self.longestNiceSubstring, re.split(\"|\".join(orphan), s)), key=len)", "def longestNiceSubstring(self, s: str) -> str:\\n        \\n        if set(s) == set(s.swapcase()):\\n            return s\\n        \\n        orphan = set(s) - set(s.swapcase())\\n        \\n        return max(map(self.longestNiceSubstring, re.split(\"|\".join(orphan), s)), key=len)"]}
{"id": "379", "ref_py": ["def mergeAlternately(self, word1, word2):\\n        \\n        result = []\\n        i = 0\\n        while i < len(word1) or i < len(word2):\\n            if i < len(word1):\\n                result.append(word1[i])\\n            if i < len(word2):\\n                result.append(word2[i])\\n            i += 1\\n        return \\'\\'.join(result)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string mergeAlternately(string word1, string word2) {\\n        string result = \"\";\\n        int i = 0;\\n        while (i < word1.length() || i < word2.length()) {\\n            if (i < word1.length()) {\\n                result += word1[i];\\n            }\\n            if (i < word2.length()) {\\n                result += word2[i];\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```", "def mergeAlternately(self, word1, word2):\\n        \\n        result = []\\n        i = 0\\n        while i < len(word1) or i < len(word2):\\n            if i < len(word1):\\n                result.append(word1[i])\\n            if i < len(word2):\\n                result.append(word2[i])\\n            i += 1\\n        return \\'\\'.join(result)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string mergeAlternately(string word1, string word2) {\\n        string result = \"\";\\n        int i = 0;\\n        while (i < word1.length() || i < word2.length()) {\\n            if (i < word1.length()) {\\n                result += word1[i];\\n            }\\n            if (i < word2.length()) {\\n                result += word2[i];\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```", "def mergeAlternately(self, word1, word2):\\n        \\n        result = []\\n        i = 0\\n        while i < len(word1) or i < len(word2):\\n            if i < len(word1):\\n                result.append(word1[i])\\n            if i < len(word2):\\n                result.append(word2[i])\\n            i += 1\\n        return \\'\\'.join(result)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string mergeAlternately(string word1, string word2) {\\n        string result = \"\";\\n        int i = 0;\\n        while (i < word1.length() || i < word2.length()) {\\n            if (i < word1.length()) {\\n                result += word1[i];\\n            }\\n            if (i < word2.length()) {\\n                result += word2[i];\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```"]}
{"id": "380", "ref_py": ["def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []", "def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []", "def summaryRanges(self, nums: List[int]) -> List[str]:\\n    ans = []"]}
{"id": "381", "ref_py": ["def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        return reduce(gcd,Counter(deck).values()) != 1\\n\\t\\t\\n", "def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        return reduce(gcd,Counter(deck).values()) != 1\\n\\t\\t\\n", "def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        return reduce(gcd,Counter(deck).values()) != 1\\n\\t\\t\\n"]}
{"id": "382", "ref_py": ["def f(self, s: str) -> bool:\\n      for index,i in enumerate(s):\\n        if i == \\'0\\': break", "def checkOnesSegment(self, s):\\n        \\n        \\n        ", "def checkOnesSegment(self, s):\\n        \\n        \\n        "]}
{"id": "384", "ref_py": ["def reverseList(self, head):\\n        ", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def reverseList(self, head):\\n        "]}
{"id": "385", "ref_py": ["def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)"]}
{"id": "387", "ref_py": ["def diagonalSum(self, mat):\\n        \\n        s=0\\n        for i in range(0,len(mat)):\\n            a=mat[i][i]\\n            b=mat[i][len(mat)-i-1]\\n            s=s+a+b\\n        if len(mat)%2==0:\\n            return(s)\\n        else:\\n            mid=(1+len(mat))/2-1\\n            return(s-mat[mid][mid])", "def diagonalSum(self, mat: list[list[int]]) -> int:\\n        return (n := len(mat)) and sum(\\n            mat[i][i] + mat[i][n - 1 - i] for i in range(n)\\n        ) - mat[n // 2][n // 2] * (n % 2)", "def diagonalSum(self, mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        res = 0\\n\\t\\t"]}
{"id": "388", "ref_py": ["def firstUniqChar(self, s):\\n        \\n        \\n        dictBag={}\\n        for char in range (len(s)):\\n            if s[char] not in dictBag:\\n                dictBag[s[char]]=1\\n            else:\\n                dictBag[s[char]]=-1\\n        for char in range(len(s)):\\n            if dictBag[s[char]]==1:\\n                return char\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```"]}
{"id": "389", "ref_py": ["def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth"]}
{"id": "390", "ref_py": ["def countNegatives(self, grid):\\n        temp = 0\\n        for x in grid:\\n            for y in x:\\n                if y < 0:\\n                    temp += 1\\n        return temp", "def countNegatives(self, grid):\\n        i = 0\\n        j = len(grid[0]) - 1\\n        count = 0\\n        \\n        while i < len(grid) and j >= 0:\\n            if grid[i][j] < 0:\\n                count += (len(grid) - i)\\n                j -= 1\\n            elif grid[i][j] >= 0:\\n                i += 1\\n        \\n        return count", "def countNegatives(self, grid):\\n        i = 0\\n        j = len(grid[0]) - 1\\n        count = 0\\n        \\n        while i < len(grid) and j >= 0:\\n            if grid[i][j] < 0:\\n                count += (len(grid) - i)\\n                j -= 1\\n            elif grid[i][j] >= 0:\\n                i += 1\\n        \\n        return count"]}
{"id": "391", "ref_py": ["def truncateSentence(self, s: str, k: int) -> str:\\n        words = s.split(\" \")\\n        return \" \".join(words[0:k])\\n```\\nJust split the string with space into list and then append the number of words according to the number given.", "def truncateSentence(self, s: str, k: int) -> str:\\n        words = s.split(\" \")\\n        return \" \".join(words[0:k])\\n```\\nJust split the string with space into list and then append the number of words according to the number given.", "def truncateSentence(self, s: str, k: int) -> str:\\n        words = s.split(\" \")\\n        return \" \".join(words[0:k])\\n```\\nJust split the string with space into list and then append the number of words according to the number given."]}
{"id": "392", "ref_py": ["def arraySign(self, nums):\\n        \\n        \\n        equal=0\\n        negative=-1\\n        positive=1\\n        \\n        product=nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            product*=nums[i]\\n        if product==0: \\n            return equal\\n        elif product>0: \\n            return positive\\n        else: \\n            return negative\\n        \\n```", "def arraySign(self, nums: List[int]) -> int:\\n        sign = 1", "def arraySign(self, nums: List[int]) -> int:\\n        sign = 1"]}
{"id": "393", "ref_py": ["def minOperations(self, nums):\\n        count = current= 0\\n        for n in nums:\\n            if n <= current:\\n                current += 1\\n                count += current - n\\n            else:\\n                current = n\\n        return count\\n  ", "defines a class named \"Solution\" with a member function named \"minOperations\". This function takes a vector of integers \"nums\" as input and returns an integer.", "def minOperations(self, nums: List[int]) -> int:\\n\\tans = 0"]}
{"id": "394", "ref_py": ["def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(list(sentence)))==26", "def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(list(sentence)))==26", "def checkIfPangram(self, sentence: str) -> bool:\\n        return len(set(list(sentence)))==26"]}
{"id": "395", "ref_py": ["def sumBase(self, n: int, k: int) -> int:\\n        s=np.base_repr(n,k)\\n        ans=0\\n        for i in s:\\n            ans+=int(i)\\n        return ans\\n```", "def sumBase(self, n: int, k: int) -> int:\\n        s=np.base_repr(n,k)\\n        ans=0\\n        for i in s:\\n            ans+=int(i)\\n        return ans\\n```", "def sumBase(self, n: int, k: int) -> int:\\n        s=np.base_repr(n,k)\\n        ans=0\\n        for i in s:\\n            ans+=int(i)\\n        return ans\\n```"]}
{"id": "396", "ref_py": ["def rotateString(self, s: str, goal: str) -> bool:\\n        return len(s) == len(goal) and s in goal+goal \\n```", "def rotateString(self, s: str, goal: str) -> bool: \\n\\t\\n        if len(s)!=len(goal):\\n            return False\\n", "def rotateString(self, s: str, goal: str) -> bool:\\n        return len(s) == len(goal) and s in goal+goal \\n```"]}
{"id": "397", "ref_py": ["def getMinDistance(self, nums, target, start):\\n        \\n        \\n        left = right = start\\n        \\n        \\n        while left >= 0 or right < len(nums):\\n            minDistance_left=start - left\\n            minDistance_right=right - start\\n            \\n            if left >= 0 and nums[left] == target: \\n                return minDistance_left\\n            if right < len(nums) and nums[right] == target:  \\n                return minDistance_right\\n            left -= 1\\n            right += 1\\n        \\n```", "def getMinDistance(self, nums, target, start):\\n        \\n        \\n        left = right = start\\n        \\n        \\n        while left >= 0 or right < len(nums):\\n            minDistance_left=start - left\\n            minDistance_right=right - start\\n            \\n            if left >= 0 and nums[left] == target: \\n                return minDistance_left\\n            if right < len(nums) and nums[right] == target:  \\n                return minDistance_right\\n            left -= 1\\n            right += 1\\n        \\n```", "def getMinDistance(self, nums, target, start):\\n        \\n        \\n        left = right = start\\n        \\n        \\n        while left >= 0 or right < len(nums):\\n            minDistance_left=start - left\\n            minDistance_right=right - start\\n            \\n            if left >= 0 and nums[left] == target: \\n                return minDistance_left\\n            if right < len(nums) and nums[right] == target:  \\n                return minDistance_right\\n            left -= 1\\n            right += 1\\n        \\n```"]}
{"id": "398", "ref_py": ["def maximumPopulation(self, logs: List[List[int]]) -> int:\\n        ", "def maximumPopulation(self, logs: List[List[int]]) -> int:\\n        ", "def maximumPopulation(self, logs: List[List[int]]) -> int:\\n        "]}
{"id": "399", "ref_py": ["def sortSentence(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str", "def sortSentence(self, s: str) -> str:\\n        \\n        x = s.split()\\n        dic = {}\\n        for i in x :\\n            dic[i[-1]] = i[:-1]\\n        return \\' \\'.join([dic[j] for j in sorted(dic)])\\n```\\n```", "def sortSentence(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str"]}
{"id": "400", "ref_py": ["def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))"]}
{"id": "401", "ref_py": ["def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```", "def numberOfSteps(self, num):\\n        counter = 0\\n        while num != 0:\\n            if num%2==0:\\n                num = num//2\\n                counter += 1\\n            else:\\n                num = num - 1\\n                counter += 1\\n        return counter", "def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```"]}
{"id": "403", "ref_py": ["def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```", "def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```", "def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```"]}
{"id": "404", "ref_py": ["def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        return sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[firstWord[i]]*(10**(len(firstWord)-i-1)) for i in range(len(firstWord))]) + sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[secondWord[j]]*(10**(len(secondWord)-j-1)) for j in range(len(secondWord))]) == sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[targetWord[k]]*(10**(len(targetWord)-1-k)) for k in range(len(targetWord))])", "def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n\\tfirstNum, secondNum, targetNum = \"\", \"\", \"\"", "def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        s1=self.helper(firstWord)     \\n        s2=self.helper(secondWord)\\n        s3=self.helper(targetWord)\\n        return s1+s2==s3\\n    \\n    def helper(self, word):\\n        s=0\\n        for i in range(len(word)):\\n            s=s*10+ord(word[i])-97\\n        return s\\n```"]}
{"id": "405", "ref_py": ["def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\\n        \\n        for _ in range(4):\\n            ", "def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\\n        \\n        for _ in range(4):\\n            ", "def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\\n        \\n        for _ in range(4):\\n            "]}
{"id": "407", "ref_py": ["def isCovered(self, matrix: List[List[int]], l: int, r: int) -> bool:\\n        mat = []\\n        \\n        for start, end in matrix:\\n            mat.extend(list(range(start, end + 1)))\\n        \\n        for i in range(l, r + 1):\\n            if i not in mat:\\n                return False\\n        \\n        return True", "def isCovered(self, matrix: List[List[int]], l: int, r: int) -> bool:\\n        mat = []\\n        \\n        for start, end in matrix:\\n            mat.extend(list(range(start, end + 1)))\\n        \\n        for i in range(l, r + 1):\\n            if i not in mat:\\n                return False\\n        \\n        return True", "def isCovered(self, matrix: List[List[int]], l: int, r: int) -> bool:\\n        mat = []\\n        \\n        for start, end in matrix:\\n            mat.extend(list(range(start, end + 1)))\\n        \\n        for i in range(l, r + 1):\\n            if i not in mat:\\n                return False\\n        \\n        return True"]}
{"id": "408", "ref_py": ["def makeEqual(self, words: List[str]) -> bool:\\n        \\n        joint = \\'\\'.join(words)\\n        set1 = set(joint)\\n        \\n        for i in set1 :\\n            if joint.count(i) % len(words) != 0 : return False \\n        return True\\n```", "def makeEqual(self, words: List[str]) -> bool:\\n        def indx(x):\\n            return ord(x) - ord(\\'a\\')\\n        \\n        hashmap = [0]*26\\n        for word in words:\\n            for c in word:\\n                hashmap[indx(c)]+=1\\n        \\n        n = len(words)\\n        \\n        for i in range(26):\\n            if hashmap[i]%n != 0:\\n                return False\\n        return True\\n```\\nTime: O(n) for iterating through each word in words and O(n) for iterating through each character in a word = O(n^2)\\nSpace: Constant as we are using a hashmap of fixed size (26).", "def makeEqual(self, words: List[str]) -> bool:\\n        \\n        joint = \\'\\'.join(words)\\n        set1 = set(joint)\\n        \\n        for i in set1 :\\n            if joint.count(i) % len(words) != 0 : return False \\n        return True\\n```"]}
{"id": "409", "ref_py": ["def largestOddNumber(self, num: str) -> str:\\n        ln = len(num) - 1\\n        for i in range(ln, -1, -1):\\n            ch = num[i]\\n            if int(ch) % 2 != 0:\\n                return num[:i + 1]\\n        return \"\"\\n```\\n``` Java []\\npublic class Solution {\\n    public String largestOddNumber(String num) {\\n        String result = \"\";\\n        int ln = num.length() - 1;\\n        for (int i = ln; i >= 0; i--) {\\n            char ch = num.charAt(i);\\n            if (Character.getNumericValue(ch) % 2 != 0) {\\n                return num.substring(0, i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n``` Rust []\\npub fn largest_odd_number(num: &str) -> String {\\n    let ln = num.len();\\n    for (i, ch) in num.chars().rev().enumerate() {\\n        if ch.to_digit(10).unwrap() % 2 != 0 {\\n            return num[..ln - i].to_string();\\n        }\\n    }\\n    String::new()\\n}", "def largestOddNumber(self, num: str) -> str:\\n        return num.rstrip(\\'02468\\')\\n```", "def largestOddNumber(self, num: str) -> str:\\n        return num.rstrip(\\'02468\\')\\n```"]}
{"id": "410", "ref_py": ["def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) ", "def findTheDifference(self, s: str, t: str) -> str:\\n        char_count = {}\\n        \\n        ", "def findTheDifference(self, s: str, t: str) -> str:\\n        c = 0\\n        for cs in s: c ^= ord(cs) "]}
{"id": "411", "ref_py": ["def maxProductDifference(self, nums):\\r\\n        largest, secondLargest = 0, 0\\r\\n        smallest, secondSmallest = float(\\'inf\\'), float(\\'inf\\')\\r\\n\\r\\n        for n in nums:\\r\\n            if n < smallest:\\r\\n                secondSmallest = smallest\\r\\n                smallest = n\\r\\n            elif n < secondSmallest:\\r\\n                secondSmallest = n\\r\\n\\r\\n            if n > largest:\\r\\n                secondLargest = largest\\r\\n                largest = n\\r\\n            elif n > secondLargest:\\r\\n                secondLargest = n\\r\\n\\r\\n        return (largest * secondLargest) - (smallest * secondSmallest)\\r\\n```\\r\\n```JavaScript []\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxProductDifference = function(nums) {\\r\\n    let largest = 0, secondLargest = 0;\\r\\n    let smallest = Number.MAX_SAFE_INTEGER, secondSmallest = Number.MAX_SAFE_INTEGER;\\r\\n\\r\\n    for (const n of nums) {\\r\\n        if (n < smallest) {\\r\\n            secondSmallest = smallest;\\r\\n            smallest = n;\\r\\n        } else if (n < secondSmallest) {\\r\\n            secondSmallest = n;\\r\\n        }\\r\\n\\r\\n        if (n > largest) {\\r\\n            secondLargest = largest;\\r\\n            largest = n;\\r\\n        } else if (n > secondLargest) {\\r\\n            secondLargest = n;\\r\\n        }\\r\\n    }\\r\\n", "def maxProductDifference(self, nums):\\n        nums.sort()\\n        n = len(nums)\\n        return nums[n-1] * nums[n-2] - nums[0] * nums[1]\\n```", "def maxProductDifference(self, nums):\\n        nums.sort()\\n        n = len(nums)\\n        return nums[n-1] * nums[n-2] - nums[0] * nums[1]\\n```"]}
{"id": "412", "ref_py": ["def buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  ", "def buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  ", "def buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  "]}
{"id": "413", "ref_py": ["def countTriples(self, n: int) -> int:\\n\\tres = 0", "def countTriples(self, n: int) -> int:\\n\\tres = 0", "def countTriples(self, n: int) -> int:\\n\\tres = 0"]}
{"id": "414", "ref_py": ["def getConcatenation(self, nums):\\n        ", "def getConcatenation(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        n = len(nums)\\n        for i in range(2*n):\\n            ans.append(nums[i%n])\\n        return ans\\n```", "def getConcatenation(self, nums):\\n        "]}
{"id": "415", "ref_py": ["def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)", "def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)", "def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\\n        text = text.split()\\n        length = len(text)\\n        brokenLetters = set(brokenLetters)"]}
{"id": "416", "ref_py": ["def areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\t\\tif len(set(Counter(s).values())) == 1:\\n\\t\\t\\t\\treturn True\\n", "def areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\t\\tif len(set(Counter(s).values())) == 1:\\n\\t\\t\\t\\treturn True\\n", "def areOccurrencesEqual(self, s: str) -> bool:\\n\\t\\t\\tif len(set(Counter(s).values())) == 1:\\n\\t\\t\\t\\treturn True\\n"]}
{"id": "417", "ref_py": ["def getLucky(self, s: str, k: int) -> int:\\n        num=\\'\\'\\n        for i in range(len(s)):\\n            num+=str(ord(s[i])-ord(\\'a\\')+1)\\n        \\n        for i in range(k):\\n            count=0\\n            for j in range(len(num)):\\n                count+=int(num[j]) \\n            num=str(count)    \\n        return int(num)", "def getLucky(self, s: str, k: int) -> int:\\n        alphabet = {\"a\" : 1 , \"b\" : 2 , \"c\" : 3 , \"d\" : 4 , \"e\" : 5 , \"f\" : 6 , \"g\" : 7 \\\\\\n        , \"h\" : 8 , \"i\" : 9 , \"j\" : 10 , \"k\" : 11 , \"l\" : 12 , \"m\" : 13 , \"n\" : 14 , \"o\" : 15 \\\\\\n        , \"p\" : 16 , \"q\" : 17 , \"r\" : 18 , \"s\" : 19 , \"t\" : 20 , \"u\" : 21 , \"v\" : 22 , \"w\" : 23 \\\\\\n        , \"x\" : 24 , \"y\" : 25 , \"z\" : 26}\\n        answ = \"\"\\n        for i in s:\\n            answ += str(alphabet[i])\\n        while k != 0:\\n            answ = sum(int(x) for x in str(answ))\\n            k -= 1\\n        return answ", "def convert(self, s):\\n        converted = \"\"\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        for char in s:\\n            converted += str(alphabet.index(char) + 1)\\n        return converted\\n    def getSum(self, converted):\\n        result = 0\\n        for char in str(converted):\\n            result += int(char)\\n        return str(result)\\n    def getLucky(self, s: str, k: int) -> int:\\n        converted = self.convert(s)\\n        result = converted\\n        for i in range(k):\\n            result = self.getSum(result)\\n        return int(result)\\n```"]}
{"id": "418", "ref_py": ["def minOperations(self, s):\\n        c_0 = s[0]\\n        count1 = self.count(s, c_0)\\n        count2 = self.count(s, \\'0\\' if c_0 == \\'1\\' else \\'1\\') + 1\\n        return min(count1, count2)", "def minOperations(s: str) -> int:\\n    countForAlternate0 = 0\\n    countForAlternate1 = 0", "def minOperations(self, s: str) -> int:\\n        start0 = 0\\n        start1 = 0\\n        \\n        for i in range(len(s)):\\n            if i % 2 == 0:\\n                if s[i] == \"0\":\\n                    start1 += 1\\n                else:\\n                    start0 += 1\\n            else:\\n                if s[i] == \"1\":\\n                    start1 += 1\\n                else:\\n                    start0 += 1\\n        \\n        return min(start0, start1)"]}
{"id": "419", "ref_py": ["def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 1 and letter == stack[-1] == stack[-2]:\\n                stack.pop()\\n            stack.append(letter)\\n        return \\'\\'.join(stack)", "def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 1 and letter == stack[-1] == stack[-2]:\\n                stack.pop()\\n            stack.append(letter)\\n        return \\'\\'.join(stack)", "def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 1 and letter == stack[-1] == stack[-2]:\\n                stack.pop()\\n            stack.append(letter)\\n        return \\'\\'.join(stack)"]}
{"id": "420", "ref_py": ["def findSpecialInteger(self, arr):\\n        size = len(arr)\\n        qtr = size // 4\\n        cnt = 1\\n        p = arr[0]\\n        \\n        for i in range(1, size):\\n            if p == arr[i]:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            \\n            if cnt > qtr:\\n                return arr[i]\\n            \\n            p = arr[i]", "def findSpecialInteger(self, arr):\\n        size = len(arr)\\n        qtr = size // 4\\n        cnt = 1\\n        p = arr[0]\\n        \\n        for i in range(1, size):\\n            if p == arr[i]:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            \\n            if cnt > qtr:\\n                return arr[i]\\n            \\n            p = arr[i]", "def findSpecialInteger(self, arr):\\n        size = len(arr)\\n        qtr = size // 4\\n        cnt = 1\\n        p = arr[0]\\n        \\n        for i in range(1, size):\\n            if p == arr[i]:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            \\n            if cnt > qtr:\\n                return arr[i]\\n            \\n            p = arr[i]"]}
{"id": "422", "ref_py": ["def numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```", "def numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```", "def numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```"]}
{"id": "423", "ref_py": ["def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:\\n        neighbors = defaultdict(list)\\n        for n1, n2 in edges:\\n            neighbors[n1].append(n2)\\n            neighbors[n2].append(n1)\\n            \\n        def dfs(node, end, seen):\\n            if node == end:\\n                return True\\n            if node in seen:\\n                return False\\n            \\n            seen.add(node)\\n            for n in neighbors[node]:\\n                if dfs(n, end, seen):\\n                    return True\\n                \\n            return False\\n        \\n        seen = set()    \\n        return dfs(start, end, seen)\\n```\\nBFS            \\n```class Solution:\\n    def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:\\n        neighbors = defaultdict(list)\\n        for n1, n2 in edges:\\n            neighbors[n1].append(n2)\\n            neighbors[n2].append(n1)\\n            \\n        q = deque([start])\\n        seen = set([start])\\n        while q:\\n            node = q.popleft()            \\n            if node == end:\\n                return True            \\n            for n in neighbors[node]:\\n                if n not in seen:\\n                    seen.add(n)\\n                    q.append(n)\\n                \\n        return False\\n```", "def validPath(self, n, edges, start, end):\\n        \\n        visited = [False]*n\\n        d = {}\\n\\t\\t", "def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:\\n        neighbors = defaultdict(list)\\n        for n1, n2 in edges:\\n            neighbors[n1].append(n2)\\n            neighbors[n2].append(n1)\\n            \\n        def dfs(node, end, seen):\\n            if node == end:\\n                return True\\n            if node in seen:\\n                return False\\n            \\n            seen.add(node)\\n            for n in neighbors[node]:\\n                if dfs(n, end, seen):\\n                    return True\\n                \\n            return False\\n        \\n        seen = set()    \\n        return dfs(start, end, seen)\\n```\\nBFS            \\n```class Solution:\\n    def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:\\n        neighbors = defaultdict(list)\\n        for n1, n2 in edges:\\n            neighbors[n1].append(n2)\\n            neighbors[n2].append(n1)\\n            \\n        q = deque([start])\\n        seen = set([start])\\n        while q:\\n            node = q.popleft()            \\n            if node == end:\\n                return True            \\n            for n in neighbors[node]:\\n                if n not in seen:\\n                    seen.add(n)\\n                    q.append(n)\\n                \\n        return False\\n```"]}
{"id": "424", "ref_py": ["define `code` from ASCII-table and number of `moves`, that equals `1`\\n4. check `pointer < code` and in both cases add **the minimum amount** of steps to rotate the wheel\\n5. increment `ans` by `moves`\\n6. and replace `pointer` by `code`\\n7. return `ans`", "define `code` from ASCII-table and number of `moves`, that equals `1`\\n4. check `pointer < code` and in both cases add **the minimum amount** of steps to rotate the wheel\\n5. increment `ans` by `moves`\\n6. and replace `pointer` by `code`\\n7. return `ans`", "define `code` from ASCII-table and number of `moves`, that equals `1`\\n4. check `pointer < code` and in both cases add **the minimum amount** of steps to rotate the wheel\\n5. increment `ans` by `moves`\\n6. and replace `pointer` by `code`\\n7. return `ans`"]}
{"id": "426", "ref_py": ["def findGCD(self, nums):\\n        mini=min(nums)\\n        maxi=max(nums)\\n        for i in range(mini,0,-1):\\n            if maxi%i==0 and mini%i==0:\\n                return i\\n                \\n                  ", "def findGCD(self, nums):\\n        mini=min(nums)\\n        maxi=max(nums)\\n        for i in range(mini,0,-1):\\n            if maxi%i==0 and mini%i==0:\\n                return i\\n                \\n                  ", "def findGCD(self, nums):\\n        mini=min(nums)\\n        maxi=max(nums)\\n        for i in range(mini,0,-1):\\n            if maxi%i==0 and mini%i==0:\\n                return i\\n                \\n                  "]}
{"id": "427", "ref_py": ["def minimumDifference(self, nums: List[int], k: int) -> int:\\n\\tif len(nums) <= 1:\\n\\t\\treturn 0", "def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        m,n=100001,len(nums)\\n        i,j=0,k-1\\n        while j<n:\\n            m=min(m,nums[j]-nums[i])\\n            i+=1\\n            j+=1\\n        return m\\n```", "def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        m,n=100001,len(nums)\\n        i,j=0,k-1\\n        while j<n:\\n            m=min(m,nums[j]-nums[i])\\n            i+=1\\n            j+=1\\n        return m\\n```"]}
{"id": "428", "ref_py": ["def findMiddleIndex(self, nums: List[int]) -> int:               \\n\\tleftSum = 0\\n\\trightSum = sum(nums)", "def findMiddleIndex(self, nums: List[int]) -> int:               \\n\\tleftSum = 0\\n\\trightSum = sum(nums)", "def findMiddleIndex(self, nums: List[int]) -> int:               \\n\\tleftSum = 0\\n\\trightSum = sum(nums)"]}
{"id": "429", "ref_py": ["def countQuadruplets(self, nums: List[int]) -> int:\\n        res = 0\\n        l = len(nums)\\n        \\n        count = defaultdict(lambda: 0)\\n        count[nums[l-1] - nums[l-2]] = 1\\n        \\n        for b in range(l - 3, 0, -1):\\n            for a in range(b - 1, -1, -1):\\n                res += count[nums[a] + nums[b]]\\n            \\n            for x in range(l - 1, b, -1):\\n                count[nums[x] - nums[b]] += 1\\n        \\n        return res\\n```", "def countQuadruplets(self, nums: List[int]) -> int:\\n        res = 0\\n        l = len(nums)\\n        \\n        count = defaultdict(lambda: 0)\\n        count[nums[l-1] - nums[l-2]] = 1\\n        \\n        for b in range(l - 3, 0, -1):\\n            for a in range(b - 1, -1, -1):\\n                res += count[nums[a] + nums[b]]\\n            \\n            for x in range(l - 1, b, -1):\\n                count[nums[x] - nums[b]] += 1\\n        \\n        return res\\n```", "def countQuadruplets(self, nums: List[int]) -> int:\\n        res = 0\\n        l = len(nums)\\n        \\n        count = defaultdict(lambda: 0)\\n        count[nums[l-1] - nums[l-2]] = 1\\n        \\n        for b in range(l - 3, 0, -1):\\n            for a in range(b - 1, -1, -1):\\n                res += count[nums[a] + nums[b]]\\n            \\n            for x in range(l - 1, b, -1):\\n                count[nums[x] - nums[b]] += 1\\n        \\n        return res\\n```"]}
{"id": "430", "ref_py": ["def maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0", "def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n\\t\\t\\n        while True:\\n\\t\\t\\n            if k*word not in sequence:\\n                return k-1\\n", "def maxRepeating(self, sequence: str, word: str) -> int:\\n        count=0\\n        while True:\\n            if word*(count+1) not in sequence:\\n                return count\\n            count+=1\\n```\\n\\tE.g.:\\n\\tSequence = \"ababa\"\\n\\tword = \"ab\"\\n\\t\\n\\t1. Initially set count to 0, saying that word might not be present in sequence.\\n\\t2. word * (count+1) = word * (0+1) = word * 1 = word = ab is present in sequence. Increment count by 1, count =1.\\n\\t3. Now, word * (count+1) = word * (1+1) = word * 2 = abab is also present in sequence. Increment count by 1, count=2.\\n"]}
{"id": "431", "ref_py": ["def countKDifference(self, nums: List[int], k: int) -> int:\\n        seen = defaultdict(int)\\n        counter = 0\\n        for num in nums:\\n            tmp, tmp2 = num - k, num + k\\n            if tmp in seen:\\n                counter += seen[tmp]\\n            if tmp2 in seen:\\n                counter += seen[tmp2]\\n            \\n            seen[num] += 1\\n        \\n        return counter\\n```", "def countKDifference(self, nums: List[int], k: int) -> int:\\n        seen = defaultdict(int)\\n        counter = 0\\n        for num in nums:\\n            tmp, tmp2 = num - k, num + k\\n            if tmp in seen:\\n                counter += seen[tmp]\\n            if tmp2 in seen:\\n                counter += seen[tmp2]\\n            \\n            seen[num] += 1\\n        \\n        return counter\\n```", "def countKDifference(self, nums: List[int], k: int) -> int:\\n        seen = defaultdict(int)\\n        counter = 0\\n        for num in nums:\\n            tmp, tmp2 = num - k, num + k\\n            if tmp in seen:\\n                counter += seen[tmp]\\n            if tmp2 in seen:\\n                counter += seen[tmp2]\\n            \\n            seen[num] += 1\\n        \\n        return counter\\n```"]}
{"id": "432", "ref_py": ["def finalValueAfterOperations(self, operations: List[str]) -> int:\\n    \\n      \\n        A=operations.count(\"++X\")\\n        B=operations.count(\"X++\")\\n        C=operations.count(\"--X\") \\n        D=operations.count(\"X--\")\\n\\t\\t\\n        return A+B-C-D             ", "def finalValueAfterOperations(self, operations: List[str]) -> int:\\n    \\n      \\n        A=operations.count(\"++X\")\\n        B=operations.count(\"X++\")\\n        C=operations.count(\"--X\") \\n        D=operations.count(\"X--\")\\n\\t\\t\\n        return A+B-C-D             ", "def finalValueAfterOperations(self, operations: List[str]) -> int:\\n    \\n      \\n        A=operations.count(\"++X\")\\n        B=operations.count(\"X++\")\\n        C=operations.count(\"--X\") \\n        D=operations.count(\"X--\")\\n\\t\\t\\n        return A+B-C-D             "]}
{"id": "433", "ref_py": ["def maximumDifference(self, nums: List[int]) -> int:\\n\\tmaxDiff = -1", "def maximumDifference(self, nums: List[int]) -> int:\\n\\tmaxDiff = -1", "def maximumDifference(self, nums: List[int]) -> int:\\n\\tmaxDiff = -1"]}
{"id": "434", "ref_py": ["def construct2DArray(self, original, m, n):\\n        if len(original) != m * n:\\n            return []", "def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\\n        if len(original) != m*n: return []\\n        \\n        res = [[None for j in range(n)] for i in range(m)]\\n        k = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j] = original[k]\\n                k += 1\\n        \\n        return res", "def construct2DArray(self, original, m, n):\\n        if len(original) != m * n:\\n            return []"]}
{"id": "435", "ref_py": ["def isPalindrome(self, head: ListNode) -> bool:\\n        slow, fast, prev = head, head, None\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n        prev, slow, prev.next = slow, slow.next, None\\n        while slow:\\n            slow.next, prev, slow = prev, slow, slow.next\\n        fast, slow = head, prev\\n        while slow:\\n            if fast.val != slow.val: return False\\n            fast, slow = fast.next, slow.next\\n        return True\\n```", "def isPalindrome(self, head):\\n        rev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            rev, rev.next, slow = slow, rev, slow.next\\n        if fast:\\n            slow = slow.next\\n        while rev and rev.val == slow.val:\\n            slow = slow.next\\n            rev = rev.next\\n        return not rev", "def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        global front\\n        front = head"]}
{"id": "436", "ref_py": ["def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```", "def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```", "def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\\n\\treturn set(nums1) & set(nums2) | set(nums2) & set(nums3) | set(nums1) & set(nums3)\\n```"]}
{"id": "437", "ref_py": ["def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        total_moves = 0 ", "def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c,n=0,len(seats)\\n        for i in range(n): c+=abs(seats[i]-students[i])\\n        return c\\n```", "def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        total_moves = 0 "]}
{"id": "438", "ref_py": ["def areNumbersAscending(self, s: str) -> bool:\\n\\tprev = -1", "def __init__(self):\\n        self.res = []", "def areNumbersAscending(self, s: str) -> bool:\\n\\tprev = -1"]}
{"id": "439", "ref_py": ["def countValidWords(self, sentence: str) -> int:\\n        sentence_list = sentence.split()\\n        count = 0\\n        for i, word in enumerate(sentence_list):\\n            valid = True\\n            hyphen_count = 0  \\n            for j, letter in enumerate(word):\\n                if letter.isdigit():\\n                    valid = False \\n                    break\\n                if letter in (\"!\",\".\",\",\") and j != len(word)-1:\\n                    valid = False \\n                    break\\n                if (letter == \"-\" and (j == len(word)-1 or j == 0)) or (letter == \"-\" and (not word[j-1].isalpha() or not word[j+1].isalpha())):\\n                    valid = False \\n                    break\\n                if letter == \"-\":\\n                    hyphen_count +=1\\n                    if hyphen_count >1:\\n                        valid = False \\n                        break\\n            if valid:\\n                count +=1\\n        return count", "def countValidWords(self, sentence: str) -> int:\\n        \\n        ", "def countValidWords(self, sentence: str) -> int:\\n        \\n        "]}
{"id": "440", "ref_py": ["def kthDistinct(self, arr, k):\\n        \\n        item_list=[]\\n        items_set=set()\\n        for i in arr:\\n            if i in item_list:\\n                items_set.add(i)\\n            else :\\n                item_list.append(i)\\n        for i in items_set:\\n            print(i)\\n            item_list.remove(i)\\n        counter=1\\n        res=\"\"\\n        for key in item_list:\\n            if counter==k:\\n                res=key\\n            counter=counter+1\\n        return res", "def kthDistinct(self, arr: List[str], k: int) -> str:\\n\\tarr = [i for i in arr if arr.count(i) == 1]\\n\\treturn \"\" if k > len(arr) else arr[k - 1]\\n```", "def kthDistinct(self, arr, k):\\n        \\n        item_list=[]\\n        items_set=set()\\n        for i in arr:\\n            if i in item_list:\\n                items_set.add(i)\\n            else :\\n                item_list.append(i)\\n        for i in items_set:\\n            print(i)\\n            item_list.remove(i)\\n        counter=1\\n        res=\"\"\\n        for key in item_list:\\n            if counter==k:\\n                res=key\\n            counter=counter+1\\n        return res"]}
{"id": "441", "ref_py": ["def smallestEqual(self, nums: List[int]) -> int:\\n\\tfor idx, n in enumerate(nums):\\n\\t\\tif idx % 10 == n:\\n\\t\\t\\treturn idx\\n\\treturn -1 \\n```", "def smallestEqual(self, nums: List[int]) -> int:\\n\\tfor idx, n in enumerate(nums):\\n\\t\\tif idx % 10 == n:\\n\\t\\t\\treturn idx\\n\\treturn -1 \\n```", "def smallestEqual(self, nums: List[int]) -> int:\\n\\tfor idx, n in enumerate(nums):\\n\\t\\tif idx % 10 == n:\\n\\t\\t\\treturn idx\\n\\treturn -1 \\n```"]}
{"id": "442", "ref_py": ["def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        lastConsonant = -1\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        lastSeenVowels = {vowel: -1 for vowel in vowels}\\n        for idx, char in enumerate(word):\\n            if char not in vowels:\\n                lastConsonant = idx\\n            else:\\n                lastSeenVowels[char] = idx\\n                count += max(min(lastSeenVowels.values()) - lastConsonant, 0)\\n        return count", "def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        lastConsonant = -1\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        lastSeenVowels = {vowel: -1 for vowel in vowels}\\n        for idx, char in enumerate(word):\\n            if char not in vowels:\\n                lastConsonant = idx\\n            else:\\n                lastSeenVowels[char] = idx\\n                count += max(min(lastSeenVowels.values()) - lastConsonant, 0)\\n        return count", "def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        lastConsonant = -1\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        lastSeenVowels = {vowel: -1 for vowel in vowels}\\n        for idx, char in enumerate(word):\\n            if char not in vowels:\\n                lastConsonant = idx\\n            else:\\n                lastSeenVowels[char] = idx\\n                count += max(min(lastSeenVowels.values()) - lastConsonant, 0)\\n        return count"]}
{"id": "443", "ref_py": ["def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n\\t\\treturn all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\\n```", "def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\treturn all(v <= 3 for v in ((Counter(list(word1)) - Counter(list(word2))) + (Counter(list(word2)) - Counter(list(word1)))).values())\\n```", "def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n\\t\\treturn all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\\n```"]}
{"id": "444", "ref_py": ["def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: ", "def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: ", "def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: "]}
{"id": "445", "ref_py": ["def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t", "def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t", "def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t"]}
{"id": "447", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "448", "ref_py": ["def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```", "def sortedSquares(self, nums):\\n        result = [0]*len(nums)\\n        i = 0\\n        j = len(nums)-1\\n        k = len(nums)-1\\n        while k>=0:\\n            if nums[i]*nums[i] <= nums[j]*nums[j]:\\n                result[k] = nums[j]*nums[j]\\n                k-=1\\n                j-=1\\n            else:\\n                result[k] = nums[i]*nums[i]\\n                i+=1\\n                k-=1\\n        return result        ", "def getAbsMin(lst):\\n    \\n    l, r = 0, len(lst) - 1\\n    while l <= r:\\n        mid = l + (r - l) // 2\\n        if lst[mid] == 0:L\\n            return mid\\n        elif lst[mid] < 0:\\n            l = mid + 1\\n        elif lst[mid] > 0:\\n            r = mid -1\\n    return l\\nprint(getAbsMin([-4,-1,2,3,10]))\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        minVal = -1\\n        ans = []\\n        j = getAbsMin(nums)\\n        i = j -1\\n        while i != -1 and j != len(nums):\\n            if nums[i]**2 < nums[j]**2:\\n                ans.append(nums[i]**2)\\n                i-=1\\n            else:\\n                ans.append(nums[j]**2)\\n                j+=1\\n        while i != -1:\\n            ans.append(nums[i]**2)\\n            i-=1\\n        while j != len(nums):\\n            ans.append(nums[j]**2)\\n            j+=1"]}
{"id": "449", "ref_py": ["def tictactoe(self, moves: List[List[int]]) -> str:\\n        winner = None\\n        matrix = [[0 for _ in range(3)] for _ in range(3)]", "def tictactoe(self, moves: List[List[int]]) -> str:\\n        \\n        board = [[0]*3 for _ in range(3)]\\n        \\n        i = 0\\n        while i < len(moves):\\n            x = moves[i][0]\\n            y = moves[i][1]\\n            if i % 2 == 0:\\n                board[x][y] = 7\\n            else:\\n                board[x][y] = 5\\n            i+=1\\n            \\n        print(board)\\n            \\n            ", "def tictactoe(self, moves: List[List[int]]) -> str:\\n        winner = None\\n        matrix = [[0 for _ in range(3)] for _ in range(3)]"]}
{"id": "450", "ref_py": ["def maxSubsequence(self, nums, k):\\n        ret, max_k = [], sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_k:\\n                ret.append(num)\\n                max_k.remove(num)\\n                if len(max_k) == 0:\\n                    return ret\\n```\\n**An alternative python solution, maybe a little more pythonic!**\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        ", "def maxSubsequence(self, nums, k):\\n        ret, max_k = [], sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_k:\\n                ret.append(num)\\n                max_k.remove(num)\\n                if len(max_k) == 0:\\n                    return ret\\n```\\n**An alternative python solution, maybe a little more pythonic!**\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        ", "def maxSubsequence(self, nums, k):\\n        ret, max_k = [], sorted(nums, reverse=True)[:k]\\n        for num in nums:\\n            if num in max_k:\\n                ret.append(num)\\n                max_k.remove(num)\\n                if len(max_k) == 0:\\n                    return ret\\n```\\n**An alternative python solution, maybe a little more pythonic!**\\n```\\nclass Solution(object):\\n    def maxSubsequence(self, nums, k):\\n        "]}
{"id": "451", "ref_py": ["def countPoints(self, rings: str) -> int:\\n        out =0\\n        for i in range(0,10):\\n            if rings.count(\\'R\\'+str(i)) and rings.count(\\'G\\'+str(i)) and rings.count(\\'B\\'+str(i)):\\n                out +=1\\n        return out\\n\\t\\t\\n", "def countPoints(self, rings: str) -> int:\\n        out =0\\n        for i in range(0,10):\\n            if rings.count(\\'R\\'+str(i)) and rings.count(\\'G\\'+str(i)) and rings.count(\\'B\\'+str(i)):\\n                out +=1\\n        return out\\n\\t\\t\\n", "def countPoints(self, rings: str) -> int:\\n        out =0\\n        for i in range(0,10):\\n            if rings.count(\\'R\\'+str(i)) and rings.count(\\'G\\'+str(i)) and rings.count(\\'B\\'+str(i)):\\n                out +=1\\n        return out\\n\\t\\t\\n"]}
{"id": "452", "ref_py": ["def firstPalindrome(self, words: List[str]) -> str:\\n        for word in words:\\n            if word == word[::-1]\\n                return word\\n            \\n        return \"\"\\n```", "def firstPalindrome(self, words: List[str]) -> str:\\n        for word in words:\\n            if word == word[::-1]\\n                return word\\n            \\n        return \"\"\\n```", "def firstPalindrome(self, words: List[str]) -> str:\\n        for word in words:\\n            if word == word[::-1]\\n                return word\\n            \\n        return \"\"\\n```"]}
{"id": "453", "ref_py": ["def mostWordsFound(self, sentences: List[str]) -> int:\\n        answer = 0\\n        for sentence in sentences:\\n            answer = max(answer, len(sentence.split()))", "def mostWordsFound(self, sentences: List[str]) -> int:\\n\\treturn max(len(word.split()) for word in sentences)\\n```", "def mostWordsFound(self, sentences: List[str]) -> int:\\n        answer = 0\\n        for sentence in sentences:\\n            answer = max(answer, len(sentence.split()))"]}
{"id": "454", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def minDiffInBST(self, root):\\n        \\n        \\n        rootStack = []\\n        previous = None\\n        minimum = float(\\'inf\\')\\n        while rootStack or root:\\n            while root:\\n                rootStack.append(root)\\n                root = root.left\\n            root = rootStack.pop()\\n            minimum = min(root.val - previous.val, minimum) if previous else minimum\\n            previous = root\\n            root = root.right\\n        return minimum\\n```", "def minDiffInBST(self, root):\\n        \\n        \\n        rootStack = []\\n        previous = None\\n        minimum = float(\\'inf\\')\\n        while rootStack or root:\\n            while root:\\n                rootStack.append(root)\\n                root = root.left\\n            root = rootStack.pop()\\n            minimum = min(root.val - previous.val, minimum) if previous else minimum\\n            previous = root\\n            root = root.right\\n        return minimum\\n```"]}
{"id": "455", "ref_py": ["def checkString(self, s: str) -> bool:\\n        return (\\'\\'.join(sorted(list(s))))==s\\n```", "def checkString(self, s: str) -> bool:\\n\\tisA = True\\n\\tfor char in s:\\n\\t\\tif char == \\'a\\' and not isA:\\n\\t\\t\\treturn False\\n\\t\\tif char == \\'b\\':\\n\\t\\t\\tisA = False", "def checkString(self, s: str) -> bool:\\n\\tisA = True\\n\\tfor char in s:\\n\\t\\tif char == \\'a\\' and not isA:\\n\\t\\t\\treturn False\\n\\t\\tif char == \\'b\\':\\n\\t\\t\\tisA = False"]}
{"id": "456", "ref_py": ["def capitalizeTitle(self, title: str) -> str:\\n\\treturn \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])\\n```", "def capitalizeTitle(self, title: str) -> str:\\n\\treturn \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])\\n```", "def capitalizeTitle(self, title: str) -> str:\\n\\treturn \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])\\n```"]}
{"id": "457", "ref_py": ["def checkIfExist(self, arr):\\n        \\n        for i in range(len(arr)):\\n            if arr[i]*2 in (arr[:i]+arr[i+1:]):\\n                return True\\n        \\n        return False", "def checkIfExist(self, arr):\\n        for i in range(0,len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[i]*2==arr[j] or arr[i]==arr[j]*2:\\n                    return True;\\n        return False;\\n```\\n", "def checkIfExist(self, arr):\\n        \\n        for i in range(len(arr)):\\n            if arr[i]*2 in (arr[:i]+arr[i+1:]):\\n                return True\\n        \\n        return False"]}
{"id": "458", "ref_py": ["def divideString(self, s: str, k: int, fill: str) -> List[str]:\\n\\t\\t\\n\\t\\tans = []\\n        n = len(s)\\n        end = 0\\n        while end<len(s):\\n                        \\n            if end+k<=len(s): \\n                ans.append(s[end:end+k])\\n            else:\\n                res  = s[end:]   ", "def divideString(self, s: str, k: int, fill: str) -> List[str]:\\n\\t\\t\\n\\t\\tans = []\\n        n = len(s)\\n        end = 0\\n        while end<len(s):\\n                        \\n            if end+k<=len(s): \\n                ans.append(s[end:end+k])\\n            else:\\n                res  = s[end:]   ", "def divideString(self, s: str, k: int, fill: str) -> List[str]:\\n\\t\\t\\n\\t\\tans = []\\n        n = len(s)\\n        end = 0\\n        while end<len(s):\\n                        \\n            if end+k<=len(s): \\n                ans.append(s[end:end+k])\\n            else:\\n                res  = s[end:]   "]}
{"id": "459", "ref_py": ["def minimumCost(self, cost: List[int]) -> int:\\n        cost = sorted(cost,reverse=True)\\n        i =0 \\n        output = 0\\n        while i<len(cost):\\n            output += cost[i] if i == len(cost)-1 else cost[i] + cost[i+1]\\n            i +=3\\n        return output", "def minimumCost(self, cost: List[int]) -> int:\\n        cost = sorted(cost,reverse=True)\\n        i =0 \\n        output = 0\\n        while i<len(cost):\\n            output += cost[i] if i == len(cost)-1 else cost[i] + cost[i+1]\\n            i +=3\\n        return output", "def minimumCost(self, cost: List[int]) -> int:\\n        cost = sorted(cost,reverse=True)\\n        i =0 \\n        output = 0\\n        while i<len(cost):\\n            output += cost[i] if i == len(cost)-1 else cost[i] + cost[i+1]\\n            i +=3\\n        return output"]}
{"id": "460", "ref_py": ["def modifyString(self, s: str) -> str:\\n\\ts = list(s)", "def modifyString(self, s: str) -> str:\\n\\ts = list(s)", "def modifyString(self, s: str) -> str:\\n\\ts = list(s)"]}
{"id": "461", "ref_py": ["def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s=set(nums)\\n        while original in s: original*=2\\n        return original\\n```", "def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s=set(nums)\\n        while original in s: original*=2\\n        return original\\n```", "def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s=set(nums)\\n        while original in s: original*=2\\n        return original\\n```"]}
{"id": "462", "ref_py": ["def minimumSum(self, num: int) -> int:\\n        num = sorted(str(num),reverse=True)\\n        n = len(num)    \\n        res = 0\\n        even_iteration = False\\n        position = 0\\n        for i in range(n):\\n            res += int(num[i])*(10**position)\\n            if even_iteration:\\n                position += 1\\n                even_iteration = False\\n            else:\\n                even_iteration = True\\n        return res\\n```", "def minimumSum(self, num: int) -> int:\\n        num = sorted(str(num),reverse=True)\\n        n = len(num)    \\n        res = 0\\n        even_iteration = False\\n        position = 0\\n        for i in range(n):\\n            res += int(num[i])*(10**position)\\n            if even_iteration:\\n                position += 1\\n                even_iteration = False\\n            else:\\n                even_iteration = True\\n        return res\\n```", "def minimumSum(self, num: int) -> int:\\n        num = sorted(str(num),reverse=True)\\n        n = len(num)    \\n        res = 0\\n        even_iteration = False\\n        position = 0\\n        for i in range(n):\\n            res += int(num[i])*(10**position)\\n            if even_iteration:\\n                position += 1\\n                even_iteration = False\\n            else:\\n                even_iteration = True\\n        return res\\n```"]}
{"id": "463", "ref_py": ["def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```", "def sortedSquares(self, nums):\\n        result = [0]*len(nums)\\n        i = 0\\n        j = len(nums)-1\\n        k = len(nums)-1\\n        while k>=0:\\n            if nums[i]*nums[i] <= nums[j]*nums[j]:\\n                result[k] = nums[j]*nums[j]\\n                k-=1\\n                j-=1\\n            else:\\n                result[k] = nums[i]*nums[i]\\n                i+=1\\n                k-=1\\n        return result        ", "def getAbsMin(lst):\\n    \\n    l, r = 0, len(lst) - 1\\n    while l <= r:\\n        mid = l + (r - l) // 2\\n        if lst[mid] == 0:L\\n            return mid\\n        elif lst[mid] < 0:\\n            l = mid + 1\\n        elif lst[mid] > 0:\\n            r = mid -1\\n    return l\\nprint(getAbsMin([-4,-1,2,3,10]))\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        minVal = -1\\n        ans = []\\n        j = getAbsMin(nums)\\n        i = j -1\\n        while i != -1 and j != len(nums):\\n            if nums[i]**2 < nums[j]**2:\\n                ans.append(nums[i]**2)\\n                i-=1\\n            else:\\n                ans.append(nums[j]**2)\\n                j+=1\\n        while i != -1:\\n            ans.append(nums[i]**2)\\n            i-=1\\n        while j != len(nums):\\n            ans.append(nums[j]**2)\\n            j+=1"]}
{"id": "464", "ref_py": ["def countOperations(self, num1: int, num2: int) -> int:\\n\\toperations = 0", "def countOperations(self, num1: int, num2: int) -> int:\\n        steps = 0\\n        while num1 != 0 and num2 != 0:\\n            if num1 > num2:\\n                steps += num1 // num2\\n                num1 = num1 % num2\\n            else:\\n                steps += num2 // num1\\n                num2 = num2 % num1\\n        return steps\\n", "def countOperations(self, num1: int, num2: int) -> int:\\n\\toperations = 0"]}
{"id": "465", "ref_py": ["def buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  ", "def buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  ", "def buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  "]}
{"id": "466", "ref_py": ["def countEven(self, num: int) -> int:\\n        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2\\n```\\n\\t\\t\\n", "def countEven(self, num: int) -> int:\\n        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2\\n```\\n\\t\\t\\n", "def countEven(self, num: int) -> int:\\n        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2\\n```\\n\\t\\t\\n"]}
{"id": "467", "ref_py": ["def prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```", "def prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```", "def prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```"]}
{"id": "468", "ref_py": ["def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```", "def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```", "def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```"]}
{"id": "469", "ref_py": ["def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```\\n![Screenshot 2023-07-17 at 22.02.52.png](https://assets.leetcode.com/users/images/417eaef4-6451-4ffa-9cbe-d39867ab6f5c_1689620605.0786376.png)", "def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```\\n![Screenshot 2023-07-17 at 22.02.52.png](https://assets.leetcode.com/users/images/417eaef4-6451-4ffa-9cbe-d39867ab6f5c_1689620605.0786376.png)", "def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```\\n![Screenshot 2023-07-17 at 22.02.52.png](https://assets.leetcode.com/users/images/417eaef4-6451-4ffa-9cbe-d39867ab6f5c_1689620605.0786376.png)"]}
{"id": "470", "ref_py": ["def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```", "def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```", "def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```"]}
{"id": "471", "ref_py": ["def smallestRangeI(self, nums, k):\\n        min_val = min(nums)\\n        max_val = max(nums)", "def smallestRangeI(self, A: List[int], K: int) -> int:", "def smallestRangeI(self, nums, k):\\n        min_val = min(nums)\\n        max_val = max(nums)"]}
{"id": "472", "ref_py": ["def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            ", "def countHillValley(self, ns: List[int]) -> int:\\n    ", "def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            "]}
{"id": "473", "ref_py": ["def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```", "def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```", "def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```"]}
{"id": "474", "ref_py": ["def minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```", "def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```", "def minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```"]}
{"id": "475", "ref_py": ["def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)", "def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)", "def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)"]}
{"id": "476", "ref_py": ["def largestInteger(self, num: int) -> int:\\n        digitFreq = [0] * 10 ", "def largestInteger(self, num: int) -> int:\\n        digitFreq = [0] * 10 ", "def largestInteger(self, num: int) -> int:\\n        digitFreq = [0] * 10 "]}
{"id": "477", "ref_py": ["def sum(self, num1: int, num2: int) -> int:\\n        return num1+num2\\n```", "def sum(self, num1: int, num2: int) -> int:\\n        return num1+num2\\n```", "def sum(self, num1: int, num2: int) -> int:\\n        return num1+num2\\n```"]}
{"id": "478", "ref_py": ["def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```"]}
{"id": "479", "ref_py": ["def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]", "def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]", "def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]"]}
{"id": "480", "ref_py": ["def digitSum(self, s: str, k: int) -> str:\\n        while len(s) > k:\\n            new_s = \\'\\'\\n            for i in range(0,len(s), k):\\n                new_s += str(sum(int(d) for d in s[i:i+k]))\\n            s = new_s \\n        return s", "def digitSum(self, s: str, k: int) -> str:\\n\\t\\t\\t\\n\\t\\t\\twhile len(s) > k:\\n\\t\\t\\t\\ts = self.round(s, k)\\n\\t\\t\\treturn s\\n\\t\\n\\t\\tdef digitSum(self, s: str, k: int) -> str:\\n\\t\\t\\t\\n\\t\\t\\tif len(s) <= k:\\n\\t\\t\\t\\treturn s\\n\\t\\t\\treturn self.digitSum(self.round(s, k), k)", "def digitSum(self, s: str, k: int) -> str:\\n        while len(s) > k:\\n            new_s = \\'\\'\\n            for i in range(0,len(s), k):\\n                new_s += str(sum(int(d) for d in s[i:i+k]))\\n            s = new_s \\n        return s"]}
{"id": "481", "ref_py": ["def intersection(self, A: List[List[int]]) -> List[int]:\\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\\n\\t\\t\\n```", "def intersection(self, A: List[List[int]]) -> List[int]:\\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\\n\\t\\t\\n```", "def intersection(self, A: List[List[int]]) -> List[int]:\\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\\n\\t\\t\\n```"]}
{"id": "482", "ref_py": ["def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        return sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[firstWord[i]]*(10**(len(firstWord)-i-1)) for i in range(len(firstWord))]) + sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[secondWord[j]]*(10**(len(secondWord)-j-1)) for j in range(len(secondWord))]) == sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[targetWord[k]]*(10**(len(targetWord)-1-k)) for k in range(len(targetWord))])", "def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n\\tfirstNum, secondNum, targetNum = \"\", \"\", \"\"", "def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        s1=self.helper(firstWord)     \\n        s2=self.helper(secondWord)\\n        s3=self.helper(targetWord)\\n        return s1+s2==s3\\n    \\n    def helper(self, word):\\n        s=0\\n        for i in range(len(word)):\\n            s=s*10+ord(word[i])-97\\n        return s\\n```"]}
{"id": "483", "ref_py": ["def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        ", "def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        ", "def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        "]}
{"id": "484", "ref_py": ["def largestGoodInteger(self, num: str) -> str:\\n        maxi=\"\"\\n        for i in range(0,len(num)-2):  \\n            if len(set([num[i],num[i+1],num[i+2]]))==1:\\n                maxi=max(maxi,num[i])\\n        return maxi*3\\n\\t\\n```", "def largestGoodInteger(self, num: str) -> str:\\n        maxi=\"\"\\n        for i in range(0,len(num)-2):  \\n            if len(set([num[i],num[i+1],num[i+2]]))==1:\\n                maxi=max(maxi,num[i])\\n        return maxi*3\\n\\t\\n```", "def largestGoodInteger(self, num: str) -> str:\\n        maxi=\"\"\\n        for i in range(0,len(num)-2):  \\n            if len(set([num[i],num[i+1],num[i+2]]))==1:\\n                maxi=max(maxi,num[i])\\n        return maxi*3\\n\\t\\n```"]}
{"id": "485", "ref_py": ["def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```", "def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```", "def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```"]}
{"id": "486", "ref_py": ["def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```", "def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```", "def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```"]}
{"id": "487", "ref_py": ["def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()", "def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()", "def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()"]}
{"id": "488", "ref_py": ["def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```", "def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```", "def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```"]}
{"id": "489", "ref_py": ["def rearrangeCharacters(self, s: str, target: str) -> int:\\n        counter_s = Counter(s)        \\n        return min(counter_s[c] // count for c,count in Counter(target).items())\\n```", "def rearrangeCharacters(self, s: str, target: str) -> int:\\n        count1=Counter(s)\\n        ", "def rearrangeCharacters(self, s: str, target: str) -> int:\\n        counter_s = Counter(s)        \\n        return min(counter_s[c] // count for c,count in Counter(target).items())\\n```"]}
{"id": "490", "ref_py": ["def minMaxGame(self, nums: List[int]) -> int:                \\n        l=nums\\n        while len(l)>1:\\n            is_min=True     \\n            tmp=[]\\n            for i in range(0, len(l), 2):\\n                if is_min:\\n                    tmp.append(min(l[i:i+2]))\\n                else:\\n                    tmp.append(max(l[i:i+2]))\\n                is_min=not is_min            \\n            l=tmp            \\n        return l[0]                        \\n```", "def minMaxGame(self, nums: List[int]) -> int:                \\n        l=nums\\n        while len(l)>1:\\n            is_min=True     \\n            tmp=[]\\n            for i in range(0, len(l), 2):\\n                if is_min:\\n                    tmp.append(min(l[i:i+2]))\\n                else:\\n                    tmp.append(max(l[i:i+2]))\\n                is_min=not is_min            \\n            l=tmp            \\n        return l[0]                        \\n```", "def minMaxGame(self, nums: List[int]) -> int:                \\n        l=nums\\n        while len(l)>1:\\n            is_min=True     \\n            tmp=[]\\n            for i in range(0, len(l), 2):\\n                if is_min:\\n                    tmp.append(min(l[i:i+2]))\\n                else:\\n                    tmp.append(max(l[i:i+2]))\\n                is_min=not is_min            \\n            l=tmp            \\n        return l[0]                        \\n```"]}
{"id": "491", "ref_py": ["def strongPasswordCheckerII(self, password):\\n        return re.match(r\\'^(?!.*(.)\\\\1)(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@", "def strongPasswordCheckerII(self, password: str) -> bool:\\n        oneUpper, oneLower, oneDigit, oneSpl = False, False, False, False", "def strongPasswordCheckerII(self, password):\\n        return re.match(r\\'^(?!.*(.)\\\\1)(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@"]}
{"id": "492", "ref_py": ["def reverseList(self, head):\\n        ", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def reverseList(self, head):\\n        "]}
{"id": "493", "ref_py": ["def greatestLetter(self, s: str) -> str:\\n\\t\\t\\tletters = set(s)", "def greatestLetter(self, s: str) -> str:\\n        \\n        new = \"\"\\n        \\n        for i in s:\\n            if i.isupper() and i.lower() in s:\\n                if i>new:\\n                    new = i.upper()\\n                        \\n        return new\\n", "def greatestLetter(self, s: str) -> str:\\n        leng = len(s)\\n        if leng == 1:\\n            return \\'\\'\\n        greatest_char = []\\n        char_hash = {}\\n        \\n        for i in range(1, leng):\\n            if (ord(s[i]) < 91 and ord(s[i])+32 in char_hash):\\n                greatest_char.append(ord(s[i]))\\n            elif(ord(s[i]) > 96 and ord(s[i]) - 32 in char_hash):\\n                greatest_char.append(ord(s[i])-32)\\n            char_hash[ord(s[i])] = 1\\n            \\n        greatest_char.sort()\\n        return chr(greatest_char[-1]) if len(greatest_char) else \"\"\\n                        "]}
{"id": "494", "ref_py": ["def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        "]}
{"id": "495", "ref_py": ["def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or (i+j) ==n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0: \\n                    return False\\n        return True;\\n```", "def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or (i+j) ==n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0: \\n                    return False\\n        return True;\\n```", "def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or (i+j) ==n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0: \\n                    return False\\n        return True;\\n```"]}
{"id": "496", "ref_py": ["def decodeMessage(self, key: str, message: str) -> str:\\n        alpha = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        i=0\\n        d={}\\n        for j in key:\\n            if j!=\" \" and j not in d:\\n                d[j]=alpha[i]\\n                i+=1\\n            if len(d)==26:\\n                break\\n        res=\"\"\\n        d[\" \"]=\" \"\\n        for i in message:\\n            res+=d[i]\\n        return res\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\tstring decodeMessage(string key, string message) {\\n        vector <char> alpha {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n        int i=0;\\n        \\n\\t\\tmap<char,char> d;\\n        \\n        for(int j=0;j<26;j++){\\n            d[alpha[j]]=\\'0\\';\\n        }\\n        \\n\\t\\tfor(int j=0; j<key.size(); j++){\\n            \\n\\t\\t\\tif(key[j]!=\\' \\' && d[key[j]]==\\'0\\'){\\n\\t\\t\\t\\td[key[j]]=alpha[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            if (i==26) break;\\n\\t\\t}\\n        d[\\' \\'] = \\' \\';\\n        \\n        string res=\"\";\\n\\t\\tfor(int i=0; i<message.size(); i++){  \\n            res += d[message[i]];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```", "def decodeMessage(self, key: str, message: str) -> str:\\n        alpha = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        i=0\\n        d={}\\n        for j in key:\\n            if j!=\" \" and j not in d:\\n                d[j]=alpha[i]\\n                i+=1\\n            if len(d)==26:\\n                break\\n        res=\"\"\\n        d[\" \"]=\" \"\\n        for i in message:\\n            res+=d[i]\\n        return res\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\tstring decodeMessage(string key, string message) {\\n        vector <char> alpha {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n        int i=0;\\n        \\n\\t\\tmap<char,char> d;\\n        \\n        for(int j=0;j<26;j++){\\n            d[alpha[j]]=\\'0\\';\\n        }\\n        \\n\\t\\tfor(int j=0; j<key.size(); j++){\\n            \\n\\t\\t\\tif(key[j]!=\\' \\' && d[key[j]]==\\'0\\'){\\n\\t\\t\\t\\td[key[j]]=alpha[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            if (i==26) break;\\n\\t\\t}\\n        d[\\' \\'] = \\' \\';\\n        \\n        string res=\"\";\\n\\t\\tfor(int i=0; i<message.size(); i++){  \\n            res += d[message[i]];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```", "def decodeMessage(self, key: str, message: str) -> str:\\n        alpha = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        i=0\\n        d={}\\n        for j in key:\\n            if j!=\" \" and j not in d:\\n                d[j]=alpha[i]\\n                i+=1\\n            if len(d)==26:\\n                break\\n        res=\"\"\\n        d[\" \"]=\" \"\\n        for i in message:\\n            res+=d[i]\\n        return res\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\tstring decodeMessage(string key, string message) {\\n        vector <char> alpha {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n        int i=0;\\n        \\n\\t\\tmap<char,char> d;\\n        \\n        for(int j=0;j<26;j++){\\n            d[alpha[j]]=\\'0\\';\\n        }\\n        \\n\\t\\tfor(int j=0; j<key.size(); j++){\\n            \\n\\t\\t\\tif(key[j]!=\\' \\' && d[key[j]]==\\'0\\'){\\n\\t\\t\\t\\td[key[j]]=alpha[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            if (i==26) break;\\n\\t\\t}\\n        d[\\' \\'] = \\' \\';\\n        \\n        string res=\"\";\\n\\t\\tfor(int i=0; i<message.size(); i++){  \\n            res += d[message[i]];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```"]}
{"id": "497", "ref_py": ["def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\tif root is not None:\\n\\t\\t\\treturn self.MAPPING[root.val](\\n\\t\\t\\t\\tself.evaluateTree(root.left),\\n\\t\\t\\t\\tself.evaluateTree(root.right),\\n\\t\\t\\t)\\n```", "def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\tif root is not None:\\n\\t\\t\\treturn self.MAPPING[root.val](\\n\\t\\t\\t\\tself.evaluateTree(root.left),\\n\\t\\t\\t\\tself.evaluateTree(root.right),\\n\\t\\t\\t)\\n```", "def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\tif root is not None:\\n\\t\\t\\treturn self.MAPPING[root.val](\\n\\t\\t\\t\\tself.evaluateTree(root.left),\\n\\t\\t\\t\\tself.evaluateTree(root.right),\\n\\t\\t\\t)\\n```"]}
{"id": "498", "ref_py": ["def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t", "def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t", "def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t"]}
{"id": "499", "ref_py": ["def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        ", "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        ", "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        "]}
{"id": "500", "ref_py": ["def bestHand(self, ranks: List[int], suits: List[str]) -> str:\\n        if(len(set(suits))==1):\\n            return \"Flush\"\\n        \\n        mp={}\\n        \\n        for i in range(5):\\n            if(ranks[i] not in mp):\\n                mp[ranks[i]]=1\\n            else:\\n                mp[ranks[i]]+=1\\n        \\n        for val in mp:\\n            if(mp[val]>=3):\\n                return \"Three of a Kind\"\\n            elif(mp[val]==2):\\n                return \"Pair\"\\n        \\n        return \"High Card\"\\n\\t\\t\\n", "def bestHand(self, ranks: List[int], suits: List[str]) -> str:\\n        N = len(ranks)\\n        statistic = defaultdict(int)", "def bestHand(self, ranks: List[int], suits: List[str]) -> str:\\n\\tmax_rank_cnt = max(Counter(ranks).values())\\n\\tmax_suit_cnt = max(Counter(suits).values())"]}
{"id": "501", "ref_py": ["def tree2str(self, root):\\n        if root is None:\\n            return \"\"", "def tree2str(self, t):\\n        res = []\\n        self.dfs(t, res)\\n        return \\'\\'.join(res)", "def tree2str(self, root):\\n        if root is None:\\n            return \"\""]}
{"id": "503", "ref_py": ["def minimumOperations(self, nums: List[int]) -> int:\\n        c,n=0,len(nums)\\n        def smallestNonZero():\\n            x=101\\n            for i in nums:\\n                if i==0:\\n                    continue\\n                if i<x:\\n                    x=i\\n            return x\\n        while sum(nums)!=0:\\n            c+=1\\n            x=smallestNonZero()\\n            for i in range(n):\\n                if nums[i]==0:\\n                    continue\\n                nums[i]-=x\\n        return c\\n```", "defined, we need to implement it. The idea is to count the number of distinct integers in the array (different from \\'0\\'). ", "defined, we need to implement it. The idea is to count the number of distinct integers in the array (different from \\'0\\'). "]}
{"id": "504", "ref_py": ["def mergeSimilarItems(self, items1: list[list[int]], items2: list[list[int]]) -> list[list[int]]:\\n        m1 = {value: weight for value, weight in items1}\\n        ret = []\\n        \\n        for item in items2:\\n            value, weight = item\\n            \\n            if not m1.get(value):\\n                m1[value] = weight\\n            else:\\n                m1[value] += weight\\n        \\n        for value, weight in m1.items():\\n            ret.append([value, weight])\\n        \\n        ret.sort()", "def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:", "def mergeSimilarItems(self, items1: list[list[int]], items2: list[list[int]]) -> list[list[int]]:\\n        m1 = {value: weight for value, weight in items1}\\n        ret = []\\n        \\n        for item in items2:\\n            value, weight = item\\n            \\n            if not m1.get(value):\\n                m1[value] = weight\\n            else:\\n                m1[value] += weight\\n        \\n        for value, weight in m1.items():\\n            ret.append([value, weight])\\n        \\n        ret.sort()"]}
{"id": "505", "ref_py": ["def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        return sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[firstWord[i]]*(10**(len(firstWord)-i-1)) for i in range(len(firstWord))]) + sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[secondWord[j]]*(10**(len(secondWord)-j-1)) for j in range(len(secondWord))]) == sum([{\\'a\\':0, \\'b\\':1, \\'c\\':2, \\'d\\':3, \\'e\\':4, \\'f\\':5, \\'g\\':6, \\'h\\':7, \\'i\\':8, \\'j\\':9}[targetWord[k]]*(10**(len(targetWord)-1-k)) for k in range(len(targetWord))])", "def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n\\tfirstNum, secondNum, targetNum = \"\", \"\", \"\"", "def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        s1=self.helper(firstWord)     \\n        s2=self.helper(secondWord)\\n        s3=self.helper(targetWord)\\n        return s1+s2==s3\\n    \\n    def helper(self, word):\\n        s=0\\n        for i in range(len(word)):\\n            s=s*10+ord(word[i])-97\\n        return s\\n```"]}
{"id": "506", "ref_py": ["def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\\n        N = len(grid)-2\\n        res = [[0] * N for _ in range(N)]\\n        for i,j in product(range(N), range(N)):\\n            res[i][j] = max(grid[r][c] for r, c in product(range(i, i+3), range(j, j+3)))", "def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\\n        N = len(grid)-2\\n        res = [[0] * N for _ in range(N)]\\n        for i,j in product(range(N), range(N)):\\n            res[i][j] = max(grid[r][c] for r, c in product(range(i, i+3), range(j, j+3)))", "def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\\n        N = len(grid)-2\\n        res = [[0] * N for _ in range(N)]\\n        for i,j in product(range(N), range(N)):\\n            res[i][j] = max(grid[r][c] for r, c in product(range(i, i+3), range(j, j+3)))"]}
{"id": "507", "ref_py": ["def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```", "def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```", "def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```"]}
{"id": "508", "ref_py": ["def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```"]}
{"id": "509", "ref_py": ["def solve(s,target):\\n        l,h=0,len(s)-1\\n        ans=-1\\n        while l<=h:\\n            mid=(l+h)//2\\n            if s[mid]==target:\\n                return mid+1\\n            elif s[mid]>target:\\n                ans=mid\\n                h=mid-1\\n            else:\\n                l=mid+1\\n        return len(s) if ans==-1 else ans\\n        \\n    s=[]\\n    nums.sort()\\n\\t", "def solve(s,target):\\n        l,h=0,len(s)-1\\n        ans=-1\\n        while l<=h:\\n            mid=(l+h)//2\\n            if s[mid]==target:\\n                return mid+1\\n            elif s[mid]>target:\\n                ans=mid\\n                h=mid-1\\n            else:\\n                l=mid+1\\n        return len(s) if ans==-1 else ans\\n        \\n    s=[]\\n    nums.sort()\\n\\t", "def solve(s,target):\\n        l,h=0,len(s)-1\\n        ans=-1\\n        while l<=h:\\n            mid=(l+h)//2\\n            if s[mid]==target:\\n                return mid+1\\n            elif s[mid]>target:\\n                ans=mid\\n                h=mid-1\\n            else:\\n                l=mid+1\\n        return len(s) if ans==-1 else ans\\n        \\n    s=[]\\n    nums.sort()\\n\\t"]}
{"id": "510", "ref_py": ["def findSubarrays(self, nums: List[int]) -> bool:\\n        out = set()\\n        for i in range(1, len(nums)):\\n            if nums[i-1]+nums[i] in out:\\n                return True\\n            out.add(nums[i-1]+nums[i])\\n        return False\\n```", "def findSubarrays(self, nums: List[int]) -> bool:\\n    \\n", "def findSubarrays(self, nums: List[int]) -> bool:\\n        out = set()\\n        for i in range(1, len(nums)):\\n            if nums[i-1]+nums[i] in out:\\n                return True\\n            out.add(nums[i-1]+nums[i])\\n        return False\\n```"]}
{"id": "511", "ref_py": ["def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\\n        count = 0\\n        while len(students) > count:\\n            if students[0] == sandwiches[0]:\\n                sandwiches.pop(0)\\n                count = 0\\n            else:\\n                students.append(students[0])\\n                count+=1", "def countStu(stu,sand):\\n    while sand:\\n        if sand[0] in stu:\\n            stu.remove(sand[0])\\n            sand.pop(0)\\n        else:break\\n    return len(sand)\\n```", "def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\\n        count = 0\\n        while len(students) > count:\\n            if students[0] == sandwiches[0]:\\n                sandwiches.pop(0)\\n                count = 0\\n            else:\\n                students.append(students[0])\\n                count+=1"]}
{"id": "512", "ref_py": ["def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = {}\\n        for ele in nums:\\n            if ele%2 == 0:\\n                d[ele] = d.get(ele,0) + 1", "def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = {}\\n        for ele in nums:\\n            if ele%2 == 0:\\n                d[ele] = d.get(ele,0) + 1", "def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = {}\\n        for ele in nums:\\n            if ele%2 == 0:\\n                d[ele] = d.get(ele,0) + 1"]}
{"id": "513", "ref_py": ["def countDaysTogether(self, arrive_alice: str, leave_alice: str, arrive_bob: str, leave_bob: str) -> int:\\n\\t\\t\\tstart = max(self.to_date(arrive_alice), self.to_date(arrive_bob))\\n\\t\\t\\tend = min(self.to_date(leave_alice), self.to_date(leave_bob))\\n\\t\\t\\treturn max((end - start).days + 1, 0)", "def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        return max(0, 1 + min(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveAlice[:2]) - 1)]) + (int(leaveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveBob[:2]) - 1)]) + (int(leaveBob[3:]) - 1))) - max(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveAlice[:2]) - 1)]) + (int(arriveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveBob[:2]) - 1)])) + (int(arriveBob[3:]) - 1))) ", "def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        return max(0, 1 + min(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveAlice[:2]) - 1)]) + (int(leaveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveBob[:2]) - 1)]) + (int(leaveBob[3:]) - 1))) - max(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveAlice[:2]) - 1)]) + (int(arriveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveBob[:2]) - 1)])) + (int(arriveBob[3:]) - 1))) "]}
{"id": "514", "ref_py": ["def smallestEvenMultiple(self, n: int) -> int:\\n\\t\\t", "def smallestEvenMultiple(self, n: int) -> int:\\n\\t\\t", "def smallestEvenMultiple(self, n: int) -> int:\\n\\t\\t"]}
{"id": "515", "ref_py": ["def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.total_tilt = 0\\n        \\n        def calculate_tilt(node):\\n            if not node:\\n                return 0\\n            \\n            left_sum = calculate_tilt(node.left)\\n            right_sum = calculate_tilt(node.right)\\n            tilt = abs(left_sum - right_sum)\\n            \\n            self.total_tilt += tilt\\n            \\n            return left_sum + right_sum + node.val\\n        \\n        calculate_tilt(root)\\n        return self.total_tilt", "def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n", "def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n"]}
{"id": "516", "ref_py": ["def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if len(set(Counter(word[0:i] + word[i+1:]).values())) == 1:\\n                return True\\n        return False\\n```", "def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if len(set(Counter(word[0:i] + word[i+1:]).values())) == 1:\\n                return True\\n        return False\\n```", "def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if len(set(Counter(word[0:i] + word[i+1:]).values())) == 1:\\n                return True\\n        return False\\n```"]}
{"id": "517", "ref_py": ["def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```", "def numberOfSteps(self, num):\\n        counter = 0\\n        while num != 0:\\n            if num%2==0:\\n                num = num//2\\n                counter += 1\\n            else:\\n                num = num - 1\\n                counter += 1\\n        return counter", "def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```"]}
{"id": "518", "ref_py": ["def diagonalSum(self, mat):\\n        \\n        s=0\\n        for i in range(0,len(mat)):\\n            a=mat[i][i]\\n            b=mat[i][len(mat)-i-1]\\n            s=s+a+b\\n        if len(mat)%2==0:\\n            return(s)\\n        else:\\n            mid=(1+len(mat))/2-1\\n            return(s-mat[mid][mid])", "def diagonalSum(self, mat: list[list[int]]) -> int:\\n        return (n := len(mat)) and sum(\\n            mat[i][i] + mat[i][n - 1 - i] for i in range(n)\\n        ) - mat[n // 2][n // 2] * (n % 2)", "def diagonalSum(self, mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        res = 0\\n\\t\\t"]}
{"id": "519", "ref_py": ["def countTime(self, time: str) -> int:", "def countTime(self, time: str) -> int:\\n        pattern = time.replace(\\'?\\', \\'.\\')\\n        return sum(\\n            re.fullmatch(pattern, f\\'{hour:02}:{minute:02}\\') is not None\\n            for hour in range(24)\\n            for minute in range(60)\\n        )\\n```", "def countTime(self, time: str) -> int:\\n        pattern = time.replace(\\'?\\', \\'.\\')\\n        return sum(\\n            re.fullmatch(pattern, f\\'{hour:02}:{minute:02}\\') is not None\\n            for hour in range(24)\\n            for minute in range(60)\\n        )\\n```"]}
{"id": "520", "ref_py": ["def wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  ", "def wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  ", "def wordPattern(pattern: str, s: str) -> bool:\\n    words = s.split()  "]}
{"id": "521", "ref_py": ["def haveConflict(self, e1, e2):\\n        return e1[0] <= e2[1] and e2[0] <= e1[1]\\n```\\n<br>", "def haveConflict(self, e1, e2):\\n        return e1[0] <= e2[1] and e2[0] <= e1[1]\\n```\\n<br>", "def haveConflict(self, e1, e2):\\n        return e1[0] <= e2[1] and e2[0] <= e1[1]\\n```\\n<br>"]}
{"id": "522", "ref_py": ["def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```", "def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```", "def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```"]}
{"id": "523", "ref_py": ["def averageValue(self, nums: List[int]) -> int:\\n        ans=0       ", "def averageValue(self, nums: List[int]) -> int:\\n        s, c = 0, 0\\n        for n in nums:\\n            f = n%6==0\\n            s += f*n\\n            c += f*1\\n        return int(s/c) if c!=0 else 0\\n```", "def averageValue(self, nums: List[int]) -> int:\\n        s, c = 0, 0\\n        for n in nums:\\n            f = n%6==0\\n            s += f*n\\n            c += f*1\\n        return int(s/c) if c!=0 else 0\\n```"]}
{"id": "524", "ref_py": ["def applyOperations(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            if nums[i-1]==nums[i]:\\n                nums[i-1]*=2\\n                nums[i]=0\\n        c,a=0,[]\\n        for i in nums:\\n            if i==0:\\n                c+=1\\n                continue\\n            a.append(i)\\n        return a+[0]*c\\n```", "def applyOperations(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            if nums[i-1]==nums[i]:\\n                nums[i-1]*=2\\n                nums[i]=0\\n        c,a=0,[]\\n        for i in nums:\\n            if i==0:\\n                c+=1\\n                continue\\n            a.append(i)\\n        return a+[0]*c\\n```", "def applyOperations(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            if nums[i-1]==nums[i]:\\n                nums[i-1]*=2\\n                nums[i]=0\\n        c,a=0,[]\\n        for i in nums:\\n            if i==0:\\n                c+=1\\n                continue\\n            a.append(i)\\n        return a+[0]*c\\n```"]}
{"id": "525", "ref_py": ["def distinctAverages(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        j=n-1\\n        s=set()\\n        nums.sort()\\n        while i<=j:\\n            s.add((nums[i]+nums[j])/2)\\n            i+=1\\n            j-=1\\n        return len(s)\\n```", "def distinctAverages(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        j=n-1\\n        s=set()\\n        nums.sort()\\n        while i<=j:\\n            s.add((nums[i]+nums[j])/2)\\n            i+=1\\n            j-=1\\n        return len(s)\\n```", "def distinctAverages(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        j=n-1\\n        s=set()\\n        nums.sort()\\n        while i<=j:\\n            s.add((nums[i]+nums[j])/2)\\n            i+=1\\n            j-=1\\n        return len(s)\\n```"]}
{"id": "526", "ref_py": ["def convertTemperature(self, celsius: float) -> List[float]:\\n        return [celsius + 273.15, celsius * 1.80 + 32.00 ]\\n        ", "defined a class called `Solution` that contains a method named `convertTemperature`. In Python, classes are used to create objects with specific attributes and methods. In this case, you\\'ve created a class that can perform temperature conversions.", "def convertTemperature(self, celsius: float) -> List[float]:\\n        return [celsius + 273.15, celsius * 1.80 + 32.00 ]\\n        "]}
{"id": "527", "ref_py": ["def unequalTriplets(self, A: List[int]) -> int:\\n        trips = pairs = 0\\n        count = Counter()\\n        for i,a in enumerate(A):\\n            trips += pairs - count[a] * (i - count[a])\\n            pairs += i - count[a]\\n            count[a] += 1\\n        return trips\\n```", "def unequalTriplets(self, A: List[int]) -> int:\\n        trips = pairs = 0\\n        count = Counter()\\n        for i,a in enumerate(A):\\n            trips += pairs - count[a] * (i - count[a])\\n            pairs += i - count[a]\\n            count[a] += 1\\n        return trips\\n```", "def unequalTriplets(self, A: List[int]) -> int:\\n        trips = pairs = 0\\n        count = Counter()\\n        for i,a in enumerate(A):\\n            trips += pairs - count[a] * (i - count[a])\\n            pairs += i - count[a]\\n            count[a] += 1\\n        return trips\\n```"]}
{"id": "528", "ref_py": ["def largestAltitude(self, gain: List[int]) -> int:\\n        highest_point = 0\\n        prev_altitude = 0\\n        for i in gain:\\n            prev_altitude += i\\n            highest_point = max(highest_point, prev_altitude)", "def largestAltitude(self, gain):\\n        sol = 0\\n        curHeight = 0", "def largestAltitude(self, gain: List[int]) -> int:\\n        highest_point = 0\\n        prev_altitude = 0\\n        for i in gain:\\n            prev_altitude += i\\n            highest_point = max(highest_point, prev_altitude)"]}
{"id": "529", "ref_py": ["def pivotInteger(self, n):\\n        \\n        s=(n*(n+1))/2\\n        p=int(s**0.5)\\n        k=(p*(p+1))/2\\n        if s+p-k==k:\\n            return p\\n        else:\\n            return -1", "def pivotInteger(self, n):\\n        \\n        temp = (n * n + n) // 2\\n        sq = int(sqrt(temp))\\n        if sq * sq == temp:\\n            return sq\\n        return -1\\n        \\n```", "def pivotInteger(self, n):\\n        \\n        total = sum(range(n+1))\\n        prefix_sum = 0\\n        \\n        for i in range(n, -1, -1):\\n            prefix_sum += i\\n            if prefix_sum == total:\\n                return i"]}
{"id": "530", "ref_py": ["def isCircularSentence(self, sentence: str) -> bool:\\n        for i in range(len(sentence)):\\n            if sentence[i] == \" \":\\n                if sentence[i-1] != sentence[i+1]:\\n                    return False\\n        return sentence[0] == sentence[-1]\\n```", "def isCircularSentence(self, sentence: str) -> bool:\\n        for i in range(len(sentence)):\\n            if sentence[i] == \" \":\\n                if sentence[i-1] != sentence[i+1]:\\n                    return False\\n        return sentence[0] == sentence[-1]\\n```", "def isCircularSentence(self, sentence: str) -> bool:\\n        for i in range(len(sentence)):\\n            if sentence[i] == \" \":\\n                if sentence[i-1] != sentence[i+1]:\\n                    return False\\n        return sentence[0] == sentence[-1]\\n```"]}
{"id": "531", "ref_py": ["def maximumValue(self, strs):\\n        \\n        maxLen = -1\\n        for ele in strs:\\n            if ele.isdigit():\\n                maxLen = max(maxLen,int(ele))\\n            else:\\n                maxLen = max(maxLen,len(ele))\\n        return maxLen\\n        \\n```\\nAlternate Solution without any space\\n```\\nclass Solution(object):\\n    def maximumValue(self, strs):\\n        \\n        for i in range(len(strs)):\\n            if strs[i].isnumeric():\\n                strs[i] = int(strs[i])\\n            else:\\n                strs[i] = len(strs[i])\\n        return max(strs)\\n```", "def maximumValue(self, strs: List[str]) -> int:\\n        \\n        max_val, cur_val = -1, 0\\n        \\n        def hasDigits(word):\\n            return bool(re.search(r\\'\\\\d\\', word))\\n        \\n        def hasChars(word):\\n            return bool(re.search(r\\'[a-z]\\', word))\\n        \\n        for word in strs:\\n            if hasDigits(word) and hasChars(word):\\n                cur_val = len(word)\\n            elif hasDigits(word) and not hasChars(word):\\n                cur_val = int(word)\\n            else:\\n                cur_val = len(word)\\n                \\n            max_val = max(max_val, cur_val)\\n            \\n        return max_val\\n```", "def maximumValue(self, strs: List[str]) -> int:\\n        \\n        max_val, cur_val = -1, 0\\n        \\n        def hasDigits(word):\\n            return bool(re.search(r\\'\\\\d\\', word))\\n        \\n        def hasChars(word):\\n            return bool(re.search(r\\'[a-z]\\', word))\\n        \\n        for word in strs:\\n            if hasDigits(word) and hasChars(word):\\n                cur_val = len(word)\\n            elif hasDigits(word) and not hasChars(word):\\n                cur_val = int(word)\\n            else:\\n                cur_val = len(word)\\n                \\n            max_val = max(max_val, cur_val)\\n            \\n        return max_val\\n```"]}
{"id": "532", "ref_py": ["def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        i = 0\\n        output = 0\\n        current_max = 0\\n        while True:\\n            if len(grid[i]) == 0:\\n                break\\n            grid[i] = sorted(grid[i])\\n            current_max = max(current_max,grid[i][-1])\\n            grid[i].pop(-1)\\n            i+=1\\n            if i == len(grid):\\n                output += current_max\\n                current_max = 0\\n                i = 0\\n        return output\\n        ", "def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        i = 0\\n        output = 0\\n        current_max = 0\\n        while True:\\n            if len(grid[i]) == 0:\\n                break\\n            grid[i] = sorted(grid[i])\\n            current_max = max(current_max,grid[i][-1])\\n            grid[i].pop(-1)\\n            i+=1\\n            if i == len(grid):\\n                output += current_max\\n                current_max = 0\\n                i = 0\\n        return output\\n        ", "def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        i = 0\\n        output = 0\\n        current_max = 0\\n        while True:\\n            if len(grid[i]) == 0:\\n                break\\n            grid[i] = sorted(grid[i])\\n            current_max = max(current_max,grid[i][-1])\\n            grid[i].pop(-1)\\n            i+=1\\n            if i == len(grid):\\n                output += current_max\\n                current_max = 0\\n                i = 0\\n        return output\\n        "]}
{"id": "533", "ref_py": ["def similarPairs(self, words: List[str]) -> int:\\n        wordMap = {}", "def similarPairs(self, words: List[str]) -> int:\\n        wordMap = {}", "def similarPairs(self, words: List[str]) -> int:\\n        wordMap = {}"]}
{"id": "534", "ref_py": ["def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        "]}
{"id": "535", "ref_py": ["def closetTarget(self, words, target, startIndex):\\n        \\n        if target not in words:\\n            return -1\\n        else:\\n            res = []\\n            for index,value in enumerate(words):\\n                if value == target:\\n                    res.append(abs(index-startIndex))\\n                    res.append(abs(len(words)-abs(index-startIndex)))\\n            return min(res)", "def closetTarget(self, words, target, startIndex):\\n        \\n        if target not in words:\\n            return -1\\n        else:\\n            res = []\\n            for index,value in enumerate(words):\\n                if value == target:\\n                    res.append(abs(index-startIndex))\\n                    res.append(abs(len(words)-abs(index-startIndex)))\\n            return min(res)", "def closetTarget(self, words, target, startIndex):\\n        \\n        if target not in words:\\n            return -1\\n        else:\\n            res = []\\n            for index,value in enumerate(words):\\n                if value == target:\\n                    res.append(abs(index-startIndex))\\n                    res.append(abs(len(words)-abs(index-startIndex)))\\n            return min(res)"]}
{"id": "536", "ref_py": ["def countDigits(self, num: int) -> int:\\n        t,c=num,0\\n        while t>0:\\n            s=t%10\\n            if num%s==0:\\n                c+=1\\n            t//=10\\n        return c\\n```", "def countDigits(self, num: int) -> int:\\n        t,c=num,0\\n        while t>0:\\n            s=t%10\\n            if num%s==0:\\n                c+=1\\n            t//=10\\n        return c\\n```", "def countDigits(self, num: int) -> int:\\n        t,c=num,0\\n        while t>0:\\n            s=t%10\\n            if num%s==0:\\n                c+=1\\n            t//=10\\n        return c\\n```"]}
{"id": "537", "ref_py": ["def categorizeBox(self, length, wid, h, mass):", "def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\\n        volume = length * width * height\\n        category = []\\n        \\n        if length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9:\\n            category.append(\"Bulky\")", "def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\\n        volume = length * width * height\\n        category = []\\n        \\n        if length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9:\\n            category.append(\"Bulky\")"]}
{"id": "538", "ref_py": ["def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n> ", "def maximumCount(self, nums: List[int]) -> int:\\n        neg=0\\n        pos=0\\n        for i in nums:\\n            if i>0:\\n                pos+=1\\n            if i<0:\\n                neg+=1", "def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n> "]}
{"id": "539", "ref_py": ["def differenceOfSum(self, nums):\\n        \\n        element_sum = 0\\n        digit_sum = 0\\n        for i in nums:\\n            element_sum +=i\\n            while i>0:\\n                digit_sum +=(i % 10)\\n                i //=10\\n        return abs(element_sum - digit_sum)", "def differenceOfSum(self, nums):\\n        \\n        element_sum = 0\\n        digit_sum = 0\\n        for i in nums:\\n            element_sum +=i\\n            while i>0:\\n                digit_sum +=(i % 10)\\n                i //=10\\n        return abs(element_sum - digit_sum)", "def differenceOfSum(self, nums):\\n        \\n        element_sum = 0\\n        digit_sum = 0\\n        for i in nums:\\n            element_sum +=i\\n            while i>0:\\n                digit_sum +=(i % 10)\\n                i //=10\\n        return abs(element_sum - digit_sum)"]}
{"id": "540", "ref_py": ["def getCommon(self, nums1: List[int], nums2: List[int]) -> int:", "def getCommon(self, nums1: List[int], nums2: List[int]) -> int:", "def getCommon(self, nums1: List[int], nums2: List[int]) -> int:"]}
{"id": "541", "ref_py": ["def alternateDigitSum(self, n: int) -> int:\\n        nums = []\\n        while n > 0:\\n            nums.append(n%10)\\n            n = n//10", "def alternateDigitSum(self, n: int) -> int:\\n        sum = 0\\n        for i in range(len(str(n))):\\n            if i % 2 == 0:\\n                sum += int(str(n)[i])\\n            else:\\n                sum += -int(str(n)[i])\\n        return sum", "def alternateDigitSum(self, n: int) -> int:\\n        sum = 0\\n        for i in range(len(str(n))):\\n            if i % 2 == 0:\\n                sum += int(str(n)[i])\\n            else:\\n                sum += -int(str(n)[i])\\n        return sum"]}
{"id": "542", "ref_py": ["definitely will have length `n-1` within 1 billion days.", "definitely will have length `n-1` within 1 billion days.", "definitely will have length `n-1` within 1 billion days."]}
{"id": "543", "ref_py": ["def selfDividingNumbers(self, left, right):\\n        \\n        l=[]\\n        for i in range(left,right+1):\\n            fl,a=0,i\\n            if \\'0\\' in str(i):\\n                fl=1\\n\\n            else:\\n                while a!=0:\\n                    if i%(a%10)!=0:\\n                        fl=1\\n                        break\\n                    a=a//10\\n            if fl==0:\\n                l.append(i)\\n        return l", "def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        ans = []\\n        for i in range(left,right+1):\\n            val = i\\n            res = True\\n            if \"0\" not in str(i):\\n                while val != 0:\\n                    val1 = val % 10\\n                    if i%val1!=0:\\n                        res = False\\n                    val = val // 10\\n                if res: ans.append(i)\\n        return ans\\n```", "def selfDividingNumbers(self, left, right):\\n        \\n        l=[]\\n        for i in range(left,right+1):\\n            fl,a=0,i\\n            if \\'0\\' in str(i):\\n                fl=1\\n\\n            else:\\n                while a!=0:\\n                    if i%(a%10)!=0:\\n                        fl=1\\n                        break\\n                    a=a//10\\n            if fl==0:\\n                l.append(i)\\n        return l"]}
{"id": "544", "ref_py": ["def pickGifts(self, gifts: List[int], k: int) -> int:", "def pickGifts(self, gifts: List[int], k: int) -> int:", "def pickGifts(self, gifts: List[int], k: int) -> int:"]}
{"id": "545", "ref_py": ["def findTheArrayConcVal(self, nums):\\n        \\n        sm=0\\n        i=0\\n        j=len(nums)-1\\n        if len(nums)%2!=0:sm+=nums[(i+j)//2]\\n        while i<j:\\n            sm+=int(str(nums[i])+str(nums[j]))\\n            i+=1\\n            j-=1\\n        return sm", "def findTheArrayConcVal(self, nums):\\n        \\n        sm=0\\n        i=0\\n        j=len(nums)-1\\n        if len(nums)%2!=0:sm+=nums[(i+j)//2]\\n        while i<j:\\n            sm+=int(str(nums[i])+str(nums[j]))\\n            i+=1\\n            j-=1\\n        return sm", "def findTheArrayConcVal(self, nums):\\n        \\n        sm=0\\n        i=0\\n        j=len(nums)-1\\n        if len(nums)%2!=0:sm+=nums[(i+j)//2]\\n        while i<j:\\n            sm+=int(str(nums[i])+str(nums[j]))\\n            i+=1\\n            j-=1\\n        return sm"]}
{"id": "546", "ref_py": ["def minMaxDifference(self, num: int) -> int:\\n        lst = list(str(num))\\n        minN = lst[0]\\n        maxN = lst[0]\\n        num1 = list()\\n        num2 = list()\\n        \\n        for i in lst:\\n            if i != \\'9\\':\\n                minN = i\\n                break", "def minMaxDifference(self, num: int) -> int:\\n        lst = list(str(num))\\n        minN = lst[0]\\n        maxN = lst[0]\\n        num1 = list()\\n        num2 = list()\\n        \\n        for i in lst:\\n            if i != \\'9\\':\\n                minN = i\\n                break", "def minMaxDifference(self, num: int) -> int:\\n        lst = list(str(num))\\n        minN = lst[0]\\n        maxN = lst[0]\\n        num1 = list()\\n        num2 = list()\\n        \\n        for i in lst:\\n            if i != \\'9\\':\\n                minN = i\\n                break"]}
{"id": "547", "ref_py": ["def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3", "def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3", "def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3"]}
{"id": "548", "ref_py": ["def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```", "def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```", "def thirdMax(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c,n=1,len(nums)\\n        m=nums[0]\\n        for i in range(1,n):\\n            if nums[i]<m:\\n                c+=1\\n                m=nums[i]\\n            if c==3:\\n                return m\\n        return nums[0]\\n```"]}
{"id": "549", "ref_py": ["def splitNum(self, num: int) -> int:\\n        a = [int(x) for x in str(num)]\\n        pq = PriorityQueue()\\n        num1 = \"\"\\n        num2 = \"\"\\n        for i in a:\\n            pq.put(i)", "def splitNum(self, num: int) -> int:\\n        a = [int(x) for x in str(num)]\\n        pq = PriorityQueue()\\n        num1 = \"\"\\n        num2 = \"\"\\n        for i in a:\\n            pq.put(i)", "def splitNum(self, num: int) -> int:\\n        a = [int(x) for x in str(num)]\\n        pq = PriorityQueue()\\n        num1 = \"\"\\n        num2 = \"\"\\n        for i in a:\\n            pq.put(i)"]}
{"id": "550", "ref_py": ["def passThePillow(self, n, time):\\n        return (1-((time% ((n-1)<<1)) // (n-1)))* (((time% ((n-1)<<1)) % (n-1)) + 1) + ((time% ((n-1)<<1)) // (n-1))*(n- ((time% ((n-1)<<1)) % (n-1)))", "def passThePillow(self, n, time):\\n        return (1-((time% ((n-1)<<1)) // (n-1)))* (((time% ((n-1)<<1)) % (n-1)) + 1) + ((time% ((n-1)<<1)) // (n-1))*(n- ((time% ((n-1)<<1)) % (n-1)))", "def passThePillow(self, n, time):\\n        return (1-((time% ((n-1)<<1)) // (n-1)))* (((time% ((n-1)<<1)) % (n-1)) + 1) + ((time% ((n-1)<<1)) // (n-1))*(n- ((time% ((n-1)<<1)) % (n-1)))"]}
{"id": "551", "ref_py": ["def vowelStrings(self, words: List[str], left: int, right: int) -> int:\\n        vowels = \\'aeiouAEIOU\\'\\n        count = 0\\n        for i in range(left, right+1):\\n            if words[i][0] in vowels and words[i][-1] in vowels:\\n                count += 1\\n        return count", "def vowelStrings(self, words: List[str], left: int, right: int) -> int:\\n        vowels = \\'aeiouAEIOU\\'\\n        count = 0\\n        for i in range(left, right+1):\\n            if words[i][0] in vowels and words[i][-1] in vowels:\\n                count += 1\\n        return count", "def vowelStrings(self, words: List[str], left: int, right: int) -> int:\\n        vowels = \\'aeiouAEIOU\\'\\n        count = 0\\n        for i in range(left, right+1):\\n            if words[i][0] in vowels and words[i][-1] in vowels:\\n                count += 1\\n        return count"]}
{"id": "552", "ref_py": ["def distMoney(self, money: int, children: int) -> int:\\n        ans=(money-children)//7\\n        if children>money:\\n            return -1", "def distMoney(self, money: int, children: int) -> int:\\n        ans=(money-children)//7\\n        if children>money:\\n            return -1", "def distMoney(self, money: int, children: int) -> int:\\n        ans=(money-children)//7\\n        if children>money:\\n            return -1"]}
{"id": "553", "ref_py": ["def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        \\n        for idx, val in enumerate(bin(n)[2:][::-1]):\\n            if idx % 2 == 0 and val == \\'1\\':\\n                ans[0] += 1\\n            elif idx % 2 == 1 and val == \\'1\\':\\n                ans[1] += 1\\n                \\n        return ans\\n```\\nSame story, but now with bitwise operations. Inside the while loop, we add the least significant bit of **n** to the appropriate element in the list based on the value of **i**: if i == 0, we add the least significant bit to the first element of the list, otherwise, we add it to the second element of the list. Next, we **right shift** n by one bit, removes the least significant bit of n. Finally, we use **XOR** i with 1 to flips the value of i between 0 and 1.", "def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        \\n        for idx, val in enumerate(bin(n)[2:][::-1]):\\n            if idx % 2 == 0 and val == \\'1\\':\\n                ans[0] += 1\\n            elif idx % 2 == 1 and val == \\'1\\':\\n                ans[1] += 1\\n                \\n        return ans\\n```\\nSame story, but now with bitwise operations. Inside the while loop, we add the least significant bit of **n** to the appropriate element in the list based on the value of **i**: if i == 0, we add the least significant bit to the first element of the list, otherwise, we add it to the second element of the list. Next, we **right shift** n by one bit, removes the least significant bit of n. Finally, we use **XOR** i with 1 to flips the value of i between 0 and 1.", "def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        \\n        for idx, val in enumerate(bin(n)[2:][::-1]):\\n            if idx % 2 == 0 and val == \\'1\\':\\n                ans[0] += 1\\n            elif idx % 2 == 1 and val == \\'1\\':\\n                ans[1] += 1\\n                \\n        return ans\\n```\\nSame story, but now with bitwise operations. Inside the while loop, we add the least significant bit of **n** to the appropriate element in the list based on the value of **i**: if i == 0, we add the least significant bit to the first element of the list, otherwise, we add it to the second element of the list. Next, we **right shift** n by one bit, removes the least significant bit of n. Finally, we use **XOR** i with 1 to flips the value of i between 0 and 1."]}
{"id": "554", "ref_py": ["def firstUniqChar(self, s):\\n        \\n        \\n        dictBag={}\\n        for char in range (len(s)):\\n            if s[char] not in dictBag:\\n                dictBag[s[char]]=1\\n            else:\\n                dictBag[s[char]]=-1\\n        for char in range(len(s)):\\n            if dictBag[s[char]]==1:\\n                return char\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```"]}
{"id": "555", "ref_py": ["def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]", "def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]", "def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]"]}
{"id": "556", "ref_py": ["def findTheLongestBalancedSubstring(s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    i = 0", "def findTheLongestBalancedSubstring(s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    i = 0", "def findTheLongestBalancedSubstring(s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    i = 0"]}
{"id": "557", "ref_py": ["def diagonalPrime(self, nums: List[List[int]]) -> int:", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num: int) -> bool:\\n            if num == 2 or num == 3:\\n                return True\\n            if num <= 1 or num % 2 == 0 or num % 3 == 0:\\n                return False"]}
{"id": "565", "ref_py": ["def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        res = []\\n        for x in zip(*grid):\\n            mx = 1\\n            for y in x:\\n                mx = max(mx, cal(y))\\n            res.append(mx)\\n        return res\\n```", "def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        res = []\\n        for x in zip(*grid):\\n            mx = 1\\n            for y in x:\\n                mx = max(mx, cal(y))\\n            res.append(mx)\\n        return res\\n```", "def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\\n        def cal(x):\\n            res = 0\\n            if x == 0:\\n                res += 1\\n            if x < 0:\\n                res += 1\\n                x = -x\\n            while x > 0:\\n                x //= 10\\n                res += 1\\n            return res\\n        res = []\\n        for x in zip(*grid):\\n            mx = 1\\n            for y in x:\\n                mx = max(mx, cal(y))\\n            res.append(mx)\\n        return res\\n```"]}
{"id": "566", "ref_py": ["def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        answer = []\\n        answer.append(0)\\n        answer.append(0)\\n        cnt = 0\\n        for row in range(len(mat)):\\n            for column in mat[row]:\\n                if column == 1:\\n                    cnt += 1\\n            if answer[1] < cnt:\\n                answer[0] = row\\n                answer[1] = cnt\\n            cnt = 0", "def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output", "def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output"]}
{"id": "567", "ref_py": ["def maxDivScore(self, nums, divisors):\\n         \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]", "def maxDivScore(self, nums, divisors):\\n         \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]", "def maxDivScore(self, nums, divisors):\\n         \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]"]}
{"id": "569", "ref_py": ["def findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24", "def findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24", "def findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24"]}
{"id": "570", "ref_py": ["def sumOfMultiples(self, n: int) -> int:\\n        s = 0\\n        for i in range(1,n+1):\\n            s += i if i%3 == 0 or i%5==0 or i%7 == 0 else 0\\n            ", "def sumOfMultiples(self, n: int) -> int:\\n        s = 0\\n        for i in range(1,n+1):\\n            s += i if i%3 == 0 or i%5==0 or i%7 == 0 else 0\\n            ", "def sumOfMultiples(self, n: int) -> int:\\n        s = 0\\n        for i in range(1,n+1):\\n            s += i if i%3 == 0 or i%5==0 or i%7 == 0 else 0\\n            "]}
{"id": "571", "ref_py": ["define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`", "define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`", "define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`"]}
{"id": "572", "ref_py": ["def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res", "def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res", "def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res"]}
{"id": "576", "ref_py": ["def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i + 1])) - len(set(nums[i + 1:])))\\n        return res\\n```", "def distinctDifferenceArray(nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    answer = [0] * n\\n    prefix = [0] * n\\n    suffix = [0] * n\\n    prefixSet = set()\\n    suffixSet = set()\\n    for i in range(n):\\n        if nums[i] not in prefixSet:\\n            prefixSet.add(nums[i])\\n            prefix[i] = len(prefixSet)\\n        elif i > 0:\\n            prefix[i] = prefix[i-1]\\n    for i in range(n-1, -1, -1):\\n        if nums[i] not in suffixSet:\\n            suffixSet.add(nums[i])\\n            suffix[i] = len(suffixSet)\\n        elif i < n-1:\\n            suffix[i] = suffix[i+1]\\n    for i in range(n-1):\\n        answer[i] = prefix[i] - suffix[i+1]\\n    answer[n-1] = prefix[n-1]\\n    return answer\\n```", "def distinctDifferenceArray(nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    answer = [0] * n\\n    prefix = [0] * n\\n    suffix = [0] * n\\n    prefixSet = set()\\n    suffixSet = set()\\n    for i in range(n):\\n        if nums[i] not in prefixSet:\\n            prefixSet.add(nums[i])\\n            prefix[i] = len(prefixSet)\\n        elif i > 0:\\n            prefix[i] = prefix[i-1]\\n    for i in range(n-1, -1, -1):\\n        if nums[i] not in suffixSet:\\n            suffixSet.add(nums[i])\\n            suffix[i] = len(suffixSet)\\n        elif i < n-1:\\n            suffix[i] = suffix[i+1]\\n    for i in range(n-1):\\n        answer[i] = prefix[i] - suffix[i+1]\\n    answer[n-1] = prefix[n-1]\\n    return answer\\n```"]}
{"id": "578", "ref_py": ["def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count", "def countSeniors(details: List[str]) -> int:\\n    cnt = 0\\n    for tem in details:\\n        age = int(tem[11:13])\\n        if age > 60:\\n            cnt += 1\\n    return cnt\\n```\\n", "def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count"]}
{"id": "579", "ref_py": ["def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;", "def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;", "def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;"]}
{"id": "581", "ref_py": ["def countOperations(self, num1: int, num2: int) -> int:\\n\\toperations = 0", "def countOperations(self, num1: int, num2: int) -> int:\\n        steps = 0\\n        while num1 != 0 and num2 != 0:\\n            if num1 > num2:\\n                steps += num1 // num2\\n                num1 = num1 % num2\\n            else:\\n                steps += num2 // num1\\n                num2 = num2 % num1\\n        return steps\\n", "def countOperations(self, num1: int, num2: int) -> int:\\n\\toperations = 0"]}
{"id": "582", "ref_py": ["def make_smallest_palindrome(s):\\n  arr = list(s)\\n  left = 0\\n  right = len(arr) - 1\\n  ops = 0\\n  while left < right:\\n    if arr[left] != arr[right]:\\n      if arr[left] > arr[right]:\\n        arr[left] = arr[right]\\n      else:\\n        arr[right] = arr[left]\\n      ops += 1\\n    left += 1\\n    right -= 1", "def make_smallest_palindrome(s):\\n  arr = list(s)\\n  left = 0\\n  right = len(arr) - 1\\n  ops = 0\\n  while left < right:\\n    if arr[left] != arr[right]:\\n      if arr[left] > arr[right]:\\n        arr[left] = arr[right]\\n      else:\\n        arr[right] = arr[left]\\n      ops += 1\\n    left += 1\\n    right -= 1", "def make_smallest_palindrome(s):\\n  arr = list(s)\\n  left = 0\\n  right = len(arr) - 1\\n  ops = 0\\n  while left < right:\\n    if arr[left] != arr[right]:\\n      if arr[left] > arr[right]:\\n        arr[left] = arr[right]\\n      else:\\n        arr[right] = arr[left]\\n      ops += 1\\n    left += 1\\n    right -= 1"]}
{"id": "585", "ref_py": ["def buyChoco(self, arr, key):\\n        ans = float(\\'inf\\')", "def buyChoco(self, price, money):\\n        price.sort()\\n        total = price[0] + price[1]\\n        return money - total if money >= total else money", "def buyChoco(self, arr, key):\\n        ans = float(\\'inf\\')"]}
{"id": "586", "ref_py": ["def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```", "def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```", "def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```"]}
{"id": "588", "ref_py": ["def smallestEqual(self, nums: List[int]) -> int:\\n\\tfor idx, n in enumerate(nums):\\n\\t\\tif idx % 10 == n:\\n\\t\\t\\treturn idx\\n\\treturn -1 \\n```", "def smallestEqual(self, nums: List[int]) -> int:\\n\\tfor idx, n in enumerate(nums):\\n\\t\\tif idx % 10 == n:\\n\\t\\t\\treturn idx\\n\\treturn -1 \\n```", "def smallestEqual(self, nums: List[int]) -> int:\\n\\tfor idx, n in enumerate(nums):\\n\\t\\tif idx % 10 == n:\\n\\t\\t\\treturn idx\\n\\treturn -1 \\n```"]}
{"id": "589", "ref_py": ["def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        s_fold = \"\".join( (s[1:], s[:-1]) )\\n        \\n        return s in s_fold\\n```", "defines a class `Solution` with a method `repeatedSubstringPattern` that checks if a given string `s` can be formed by repeating a substring within itself.", "def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        lps = [0] * n\\n        \\n        len = 0\\n        \\n        for i in range(1, n):\\n            while len > 0 and s[i] != s[len]:\\n                len = lps[len - 1]\\n            if s[i] == s[len]:\\n                len += 1\\n            lps[i] = len\\n        \\n        pattern_len = n - lps[n - 1]\\n        \\n        return pattern_len != n and n % pattern_len == 0"]}
{"id": "595", "ref_py": ["def reorderSpaces(self, text):\\n        \\n", "def reorderSpaces(self, text):\\n        word_list = text.split()\\n        words, spaces = len(word_list), text.count(\" \")\\n        \\n        if words > 1:\\n            q, r = spaces//(words-1), spaces%(words-1)\\n            return (\" \" * q).join(word_list) + \" \" * r\\n        else:\\n            return \"\".join(word_list) + \" \" * spaces\\n```", "def reorderSpaces(self, text):\\n        word_list = text.split()\\n        words, spaces = len(word_list), text.count(\" \")\\n        \\n        if words > 1:\\n            q, r = spaces//(words-1), spaces%(words-1)\\n            return (\" \" * q).join(word_list) + \" \" * r\\n        else:\\n            return \"\".join(word_list) + \" \" * spaces\\n```"]}
{"id": "596", "ref_py": ["def findNonMinOrMax(self, A):\\n        return -1 if len(A) < 3 else sum(A[:3]) - min(A[:3]) - max(A[:3])\\n```\\n<br>", "def findNonMinOrMax(self, nums: List[int]) -> int:\\n        minVal, maxVal = min(nums), max(nums)\\n        for n in nums:\\n            if n != minVal and n != maxVal:\\n                return n\\n        return -1", "def findNonMinOrMax(self, A):\\n        return -1 if len(A) < 3 else sum(A[:3]) - min(A[:3]) - max(A[:3])\\n```\\n<br>"]}
{"id": "597", "ref_py": ["def distanceTraveled(self, mainTank, additionalTank):\\n        sum = 0\\n        x = 0\\n        y = 0\\n        while mainTank >= 5:\\n            x = mainTank // 5\\n            y = mainTank % 5\\n            if additionalTank >= x:\\n                mainTank = y + x\\n            elif additionalTank >= 0:\\n                mainTank = y + additionalTank\\n            else:\\n                mainTank = y\\n            additionalTank = additionalTank - x\\n            sum = sum + x * 5 * 10\\n        return sum + mainTank * 10", "def distanceTraveled(self, mainTank, additionalTank):\\n        sum = 0\\n        x = 0\\n        y = 0\\n        while mainTank >= 5:\\n            x = mainTank // 5\\n            y = mainTank % 5\\n            if additionalTank >= x:\\n                mainTank = y + x\\n            elif additionalTank >= 0:\\n                mainTank = y + additionalTank\\n            else:\\n                mainTank = y\\n            additionalTank = additionalTank - x\\n            sum = sum + x * 5 * 10\\n        return sum + mainTank * 10", "def distanceTraveled(self, mainTank, additionalTank):\\n        sum = 0\\n        x = 0\\n        y = 0\\n        while mainTank >= 5:\\n            x = mainTank // 5\\n            y = mainTank % 5\\n            if additionalTank >= x:\\n                mainTank = y + x\\n            elif additionalTank >= 0:\\n                mainTank = y + additionalTank\\n            else:\\n                mainTank = y\\n            additionalTank = additionalTank - x\\n            sum = sum + x * 5 * 10\\n        return sum + mainTank * 10"]}
{"id": "598", "ref_py": ["def maximumNumberOfStringPairs(self, words):\\n        pairs = 0\\n        reverse_dict = {}", "def maximumNumberOfStringPairs(self, words):\\n        pairs = 0\\n        reverse_dict = {}", "def maximumNumberOfStringPairs(self, words):\\n        pairs = 0\\n        reverse_dict = {}"]}
{"id": "599", "ref_py": ["def countBeautifulPairs(self, nums):\\n        \\n        counter = 0", "def countBeautifulPairs(self, nums):\\n        \\n        counter = 0", "def countBeautifulPairs(self, nums):\\n        \\n        counter = 0"]}
{"id": "600", "ref_py": ["def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans", "def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:", "def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans"]}
{"id": "601", "ref_py": ["def alternatingSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = dp = -1\\n        for i in range(1, n):\\n            if dp > 0 and A[i] == A[i - 2]:\\n                dp += 1\\n            else:\\n                dp = 2 if A[i] == A[i - 1] + 1 else -1\\n            res = max(res, dp)\\n        return res\\n```", "def alternatingSubarray(self, nums: List[int]) -> int:\\n        \\n        left = 0\\n        right = 1\\n        ans = -1\\n        \\n        while right < len(nums):\\n            while right < len(nums) and nums[right] != nums[right - 1] + 1:\\n                left = right\\n                right += 1\\n            if right == len(nums):\\n                break\\n            \\n            ans = max(ans, right - left + 1)\\n            \\n            while right + 1 < len(nums) and nums[right + 1] == nums[right - 1]:\\n                right += 1\\n            ans = max(ans, right - left + 1)\\n            left = right\\n            right += 1\\n        return ans\\n```", "def alternatingSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = dp = -1\\n        for i in range(1, n):\\n            if dp > 0 and A[i] == A[i - 2]:\\n                dp += 1\\n            else:\\n                dp = 2 if A[i] == A[i - 1] + 1 else -1\\n            res = max(res, dp)\\n        return res\\n```"]}
{"id": "602", "ref_py": ["def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t", "def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t", "def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t"]}
{"id": "603", "ref_py": ["def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n> ", "def maximumCount(self, nums: List[int]) -> int:\\n        neg=0\\n        pos=0\\n        for i in nums:\\n            if i>0:\\n                pos+=1\\n            if i<0:\\n                neg+=1", "def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n> "]}
{"id": "604", "ref_py": ["def isGood(self, nums):\\n        if len(nums)==1:\\n            return False\\n        nums.sort()\\n        n = len(nums)\\n        \\n        ", "def isGood(self, nums):\\n        if len(nums)==1:\\n            return False\\n        nums.sort()\\n        n = len(nums)\\n        \\n        ", "def isGood(self, nums):\\n        if len(nums)==1:\\n            return False\\n        nums.sort()\\n        n = len(nums)\\n        \\n        "]}
{"id": "605", "ref_py": ["def splitWordsBySeparator(self, words, separator):\\n        ", "def splitWordsBySeparator(self, words, separator):\\n        ", "def splitWordsBySeparator(self, words, separator):\\n        "]}
{"id": "606", "ref_py": ["def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ", "def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ", "def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        "]}
{"id": "607", "ref_py": ["def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:", "def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:", "def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:"]}
{"id": "608", "ref_py": ["def finalString(self, s):\\n        d = collections.deque()\\n        cnt = s.count(\\'i\\') % 2\\n        for c in s:\\n            if c == \\'i\\': cnt ^= 1\\n            else: d.appendleft(c) if cnt else d.append(c)\\n        \\n        return \"\".join(d)\\n```", "def finalString(self, s: str) -> str:", "def finalString(self, s: str) -> str:"]}
{"id": "609", "ref_py": ["def maxSum(self, nums: List[int]) -> int:", "def maxSum(self, nums: List[int]) -> int:", "def maxSum(self, nums: List[int]) -> int:"]}
{"id": "610", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = ListNode(0)\\n        curr = dummyHead\\n        carry = 0\\n        while l1 != None or l2 != None or carry != 0:\\n            l1Val = l1.val if l1 else 0\\n            l2Val = l2.val if l2 else 0\\n            columnSum = l1Val + l2Val + carry\\n            carry = columnSum // 10\\n            newNode = ListNode(columnSum % 10)\\n            curr.next = newNode\\n            curr = newNode\\n            l1 = l1.next if l1 else None\\n            l2 = l2.next if l2 else None\\n        return dummyHead.next", "def __init__(self, val=0, next=None):\\n"]}
{"id": "611", "ref_py": ["def lengthOfLongestSubstring(self, s: str) -> int:\\n        seen = {}\\n        l = 0\\n        output = 0\\n        for r in range(len(s)):\\n            \\n            if s[r] not in seen:\\n                output = max(output,r-l+1)\\n            \\n            else:\\n                if seen[s[r]] < l:\\n                    output = max(output,r-l+1)\\n                else:\\n                    l = seen[s[r]] + 1\\n            seen[s[r]] = r\\n        return output\\n```\\n* Time complexity :O(n). \\n\\tn is the length of the input string.\\n\\tIt will iterate n times to get the result.", "def lengthOfLongestSubstring(self, s: str) -> int:\\n        seen = {}\\n        l = 0\\n        output = 0\\n        for r in range(len(s)):\\n            \\n            if s[r] not in seen:\\n                output = max(output,r-l+1)\\n            \\n            else:\\n                if seen[s[r]] < l:\\n                    output = max(output,r-l+1)\\n                else:\\n                    l = seen[s[r]] + 1\\n            seen[s[r]] = r\\n        return output\\n```\\n* Time complexity :O(n). \\n\\tn is the length of the input string.\\n\\tIt will iterate n times to get the result.", "def lengthOfLongestSubstring(self, s: str) -> int:\\n        seen = {}\\n        l = 0\\n        output = 0\\n        for r in range(len(s)):\\n            \\n            if s[r] not in seen:\\n                output = max(output,r-l+1)\\n            \\n            else:\\n                if seen[s[r]] < l:\\n                    output = max(output,r-l+1)\\n                else:\\n                    l = seen[s[r]] + 1\\n            seen[s[r]] = r\\n        return output\\n```\\n* Time complexity :O(n). \\n\\tn is the length of the input string.\\n\\tIt will iterate n times to get the result."]}
{"id": "612", "ref_py": ["def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]\\n```\\n```c []\\nint maxVal(int a, int b) {\\n    return a > b ? a : b;\\n}", "def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]", "def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]"]}
{"id": "613", "ref_py": ["def convert(self, s, numRows):\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        rows = [[] for row in range(numRows)]\\n        index = 0\\n        step = -1\\n        for char in s:\\n            rows[index].append(char)\\n            if index == 0:\\n                step = 1\\n            elif index == numRows - 1:\\n                step = -1\\n            index += step", "def convert(self, s, numRows):\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        rows = [[] for row in range(numRows)]\\n        index = 0\\n        step = -1\\n        for char in s:\\n            rows[index].append(char)\\n            if index == 0:\\n                step = 1\\n            elif index == numRows - 1:\\n                step = -1\\n            index += step", "def convert(self, s, numRows):\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        rows = [[] for row in range(numRows)]\\n        index = 0\\n        step = -1\\n        for char in s:\\n            rows[index].append(char)\\n            if index == 0:\\n                step = 1\\n            elif index == numRows - 1:\\n                step = -1\\n            index += step"]}
{"id": "614", "ref_py": ["def reverse(self, x: int) -> int:\\n        MAX_INT = 2 ** 31 - 1 ", "def reverse(self, x):\\n        reverse = 0\\n        sign = -1 if x < 0 else 1\\n        x = abs(x)\\n        while x:\\n            digit = x % 10\\n            reverse = reverse * 10 + digit\\n            x /= 10\\n        result = sign * reverse\\n        if result > 2 ** 31 - 1 or result < -(2 ** 31):\\n            return 0\\n        return result", "def reverse(self, x: int) -> int:\\n        MAX_INT = 2 ** 31 - 1 "]}
{"id": "615", "ref_py": ["def myAtoi(self, str: str) -> int:\\n        value, state, pos, sign = 0, 0, 0, 1", "def myAtoi(self, s):", "def myAtoi(self, s: str) -> int:\\n        s=s.strip()\\n        sign=1\\n        l=\"\"\\n        res=\"\"\\n        num=False"]}
{"id": "616", "ref_py": ["def maxArea(self, height):\\n        left = 0            ", "defined as **length * width**. The width of any container will be the difference between the index of the two lines (**i** and **j**), and the height will be whichever of the two sides is the lowest (**min(H[i], H[j])**).", "defined as **length * width**. The width of any container will be the difference between the index of the two lines (**i** and **j**), and the height will be whichever of the two sides is the lowest (**min(H[i], H[j])**)."]}
{"id": "617", "ref_py": ["def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman", "def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman", "def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman"]}
{"id": "618", "ref_py": ["def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output", "def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output", "def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output"]}
{"id": "619", "ref_py": ["def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n\\t\\t\\t", "def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n\\t\\t\\t", "def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n\\t\\t\\t"]}
{"id": "620", "ref_py": ["def subsets(self, nums):\\n        \\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path + [nums[i]], res)     \\n```\\n**90. Subsets II:**  Runtime: 20 ms, faster than 96.23% \\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```", "def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        phone = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\\n        res = []\\n        \\n        def backtrack(combination, next_digits):\\n            if not next_digits:\\n                res.append(combination)\\n                return\\n            \\n            for letter in phone[next_digits[0]]:\\n                backtrack(combination + letter, next_digits[1:])\\n        \\n        backtrack(\"\", digits)\\n        return res", "def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) {\\n        ans.clear();\\n        if (digits.length() == 0) {\\n            return ans;\\n        }\\n        helper(\"\", 0, digits);\\n        return ans;\\n    }\\n    \\n    void helper(string comb, int index, string digits) {\\n        if (index == digits.length()) {\\n            ans.push_back(comb);\\n            return;\\n        }\\n            \\n        string letters = dial[digits[index] - \\'0\\'];\\n        for (int i = 0; i < letters.length(); i++) {\\n            helper(comb + letters[i], index + 1, digits);\\n        }\\n    }\\n};"]}
{"id": "621", "ref_py": ["def fourSum(self, nums, target):\\n        def helper(nums, target, start, res, temp, num_need):\\n            if num_need != 2:\\n                for i in range(start, len(nums) - num_need + 1):\\n                    if i > start and nums[i] == nums[i - 1]:\\n                        continue  ", "def fourSum(self, nums, target):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n    \\n    def findNsum(self, nums, target, N, result, results):\\n        if len(nums) < N or N < 2: return\\n    \\n        ", "def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                k = j + 1\\n                l = len(nums) - 1\\n                while k < l:\\n                    sum = nums[i] + nums[j] + nums[k] + nums[l]\\n                    if sum == target:\\n                        s.add((nums[i], nums[j], nums[k], nums[l]))\\n                        k += 1\\n                        l -= 1\\n                    elif sum < target:\\n                        k += 1\\n                    else:\\n                        l -= 1\\n        output = list(s)\\n        return output"]}
{"id": "622", "ref_py": ["def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```", "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```", "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```"]}
{"id": "623", "ref_py": ["def generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn ", "def generateParenthesis(self,n,currentString = \\'\\',close = 0):\\n        if n == 1 and close == 0:\\n            return [currentString+\"()\"]\\n        elif n == 0 and close == 1:\\n            return [currentString+\")\"]", "define a helper function, `generateParentheses`, that takes the following parameters:\\n   - `result`: a reference to the vector of strings where we store the generated combinations.\\n   - `current`: the current combination being generated.\\n   - `open`: the count of opening parentheses \"(\" included in the current combination.\\n   - `close`: the count of closing parentheses \")\" included in the current combination.\\n   - `n`: the total number of pairs of parentheses to be included."]}
{"id": "624", "ref_py": ["def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next", "def swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```\\n", "def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next"]}
{"id": "625", "ref_py": ["def divide(self, dividend, divisor):\\n        \\n        if abs(divisor) == 1:\\n            dividend = divisor * dividend\\n            if dividend > 2**31 - 1:\\n                return 2**31 - 1", "def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result", "def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result"]}
{"id": "626", "ref_py": ["def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            ", "def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            ", "def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            "]}
{"id": "627", "ref_py": ["def search(self, A: List[int], B: int) -> int:\\n        l = 0\\n        r = len(A) - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if A[m] == B:\\n                return m\\n            if A[m] >= A[0]:\\n                if B >= A[0] and B <= A[m]:\\n                    r = m - 1\\n                else:\\n                    l = m + 1\\n            else:\\n                if B >= A[m] and B <= A[-1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1", "def search(self, nums: list[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1", "def search(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        mid = (start + end) / 2\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                return mid\\n            if nums[start] <= nums[mid]:\\n                if nums[start] <= target and nums[mid] >= target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if nums[end] >= target and nums[mid] <= target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1"]}
{"id": "628", "ref_py": ["defines a Solution with three member functions: search_first, search_last, and searchRange. The searchRange function aims to find the first and last occurrence of a target value in a sorted array of integers.", "defines a Solution with three member functions: search_first, search_last, and searchRange. The searchRange function aims to find the first and last occurrence of a target value in a sorted array of integers.", "defines a Solution with three member functions: search_first, search_last, and searchRange. The searchRange function aims to find the first and last occurrence of a target value in a sorted array of integers."]}
{"id": "629", "ref_py": ["def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        m = [[False] * 9 for _ in range(9)]\\n        m2 = [[False] * 9 for _ in range(9)]\\n        m3 = [[False] * 9 for _ in range(9)]", "define column and row (by single index), but squares are defined using two indexes. We will use **//** (floor division) operator to know in which square we are right now.", "define column and row (by single index), but squares are defined using two indexes. We will use **//** (floor division) operator to know in which square we are right now."]}
{"id": "630", "ref_py": ["def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s", "def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s", "def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s"]}
{"id": "631", "ref_py": ["def combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    ", "def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        ds = []\\n        candidates.sort()\\n        self.solve(0, candidates, target, 0, ans, ds)\\n        return ans", "def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        ds = []\\n        candidates.sort()\\n        self.solve(0, candidates, target, 0, ans, ds)\\n        return ans"]}
{"id": "632", "ref_py": ["def combinationSum2(self, nums: List[int], target: int) -> List[List[int]]:\\n        \\n        def dfs(i, path, current_target):\\n            if(current_target == 0): ", "def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()", "def combinationSum2(self, nums: List[int], target: int) -> List[List[int]]:\\n        \\n        def dfs(i, path, current_target):\\n            if(current_target == 0): "]}
{"id": "633", "ref_py": ["def multiply(self, num1: str, num2: str) -> str:", "def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \\'0\\' or num2 == \\'0\\':\\n            return \\'0\\'\\n        \\n        def decode(num):\\n            ans = 0\\n            for i in num:\\n                ans = ans*10 +(ord(i) - ord(\\'0\\'))\\n            return ans", "def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \\'0\\' or num2 == \\'0\\':\\n            return \\'0\\'\\n        \\n        def decode(num):\\n            ans = 0\\n            for i in num:\\n                ans = ans*10 +(ord(i) - ord(\\'0\\'))\\n            return ans"]}
{"id": "634", "ref_py": ["definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).", "definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).", "definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**)."]}
{"id": "635", "ref_py": ["def permute(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.helper([], nums, result)\\n        return result\\n    \\n    def helper(self, curr, nums, result):\\n        if len(curr) == len(nums):\\n            result.append(curr.copy())\\n            return\\n        \\n        for num in nums:\\n            if num not in curr:\\n                curr.append(num)\\n                self.helper(curr, nums, result)\\n                curr.pop()", "def permute(self, nums):\\n\\t", "def permute(self, nums):\\n        def solve(nums, per, c):\\n            if c == len(nums):\\n                ans.append(list(per))\\n                return\\n            for i in range(len(nums)):\\n                if per[i] == 11:\\n                    per[i] = nums[c]\\n                    solve(nums, per, c + 1)\\n                    per[i] = 11"]}
{"id": "636", "ref_py": ["def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 ", "def permuteUnique(self, nums):\\n        \\n        l = permutations(nums)\\n        visited =[]\\n        for i in l:\\n            if i not in visited:\\n                visited.append(i)\\n        \\n        return visited\\n              \\n            \\n```\\n", "def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            "]}
{"id": "637", "ref_py": ["def rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```", "def rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```", "def rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```"]}
{"id": "638", "ref_py": ["defines a class `Solution` with a method `groupAnagrams`. This method takes a list of strings `strs` as input and is supposed to group the anagrams from the input list into lists of lists, where each inner list contains words that are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such as \"listen\" and \"silent.\"", "defines a class `Solution` with a method `groupAnagrams`. This method takes a list of strings `strs` as input and is supposed to group the anagrams from the input list into lists of lists, where each inner list contains words that are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such as \"listen\" and \"silent.\"", "defines a class `Solution` with a method `groupAnagrams`. This method takes a list of strings `strs` as input and is supposed to group the anagrams from the input list into lists of lists, where each inner list contains words that are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such as \"listen\" and \"silent.\""]}
{"id": "639", "ref_py": ["def myPow(self, x, n):\\n        return x**n\\n```\\n", "def solve(self, x, n):\\n        if n == 0:\\n            return 1  ", "def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            return 1.0 / self.pow(x, -n)\\n        return self.pow(x, n)\\n    \\n    def pow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1.0\\n        if n % 2 == 0:\\n            return self.pow(x * x, n // 2)\\n        else:\\n            return x * self.pow(x * x, (n - 1) // 2)"]}
{"id": "640", "ref_py": ["def maxSubArray(self, nums):\\n        ", "def maxSubArray(self, nums):\\n        ", "def maxSubArray(self, nums):\\n        "]}
{"id": "641", "ref_py": ["def spiralOrder(self, matrix):\\n        return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])", "def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n  m = len(matrix)\\n  n = len(matrix[0])\\n  answer = []\\n  direction = [[1,0],[0,-1],[-1,0],[0,1]]\\n  visited = []\\n  for i in range(m):\\n      visited.append([0]*n)\\n  def traverse(coord, index):\\n      if coord[0] >= m or coord[0] < 0 or coord[1] >= n or coord[0] < 0 or visited[coord[0]][coord[1]] == 1:\\n          return\\n      answer.append(matrix[coord[0]][coord[1]])\\n      visited[coord[0]][coord[1]] = 1\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      if coord2[0] >= m or coord2[0] < 0 or coord2[1] >= n or coord2[0] < 0 or visited[coord2[0]][coord2[1]] == 1:\\n          index = (index + 1) % 4\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      traverse(coord2, index)\\n  traverse([0,0],3)\\n  return answer\\n```\\n", "def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n  m = len(matrix)\\n  n = len(matrix[0])\\n  answer = []\\n  direction = [[1,0],[0,-1],[-1,0],[0,1]]\\n  visited = []\\n  for i in range(m):\\n      visited.append([0]*n)\\n  def traverse(coord, index):\\n      if coord[0] >= m or coord[0] < 0 or coord[1] >= n or coord[0] < 0 or visited[coord[0]][coord[1]] == 1:\\n          return\\n      answer.append(matrix[coord[0]][coord[1]])\\n      visited[coord[0]][coord[1]] = 1\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      if coord2[0] >= m or coord2[0] < 0 or coord2[1] >= n or coord2[0] < 0 or visited[coord2[0]][coord2[1]] == 1:\\n          index = (index + 1) % 4\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      traverse(coord2, index)\\n  traverse([0,0],3)\\n  return answer\\n```\\n"]}
{"id": "642", "ref_py": ["def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): ", "def canJump(self, nums):\\n        ", "def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True"]}
{"id": "643", "ref_py": ["def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t", "def merge(self, intervals):\\n        ans = []\\n        intervals.sort()", "def merge(self, intervals):\\n        ans = []\\n        intervals.sort()"]}
{"id": "644", "ref_py": ["def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right", "def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:", "def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right"]}
{"id": "645", "ref_py": ["def generateMatrix(self, n):\\n        ", "def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 ", "def generateMatrix(self, n):\\n        "]}
{"id": "646", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def __init__(self, x):\\n", "def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:   \\n        if head is None or k == 0: return head\\n        res = head\\n        elems = []\\n        i = 0\\n        while head is not None:\\n            if i > k:\\n                elems.pop(0)\\n            elems.append(head)\\n            head, i = head.next, i + 1\\n            \\n        k %= i\\n        if k == 0: return res\\n        head = elems[-1]\\n        pre_rotated = elems[-k-1]\\n        rotated = pre_rotated.next "]}
{"id": "647", "ref_py": ["def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1", "def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1", "def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1"]}
{"id": "648", "ref_py": ["def uniquePathsWithObstacles(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])", "def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        m=len(obstacleGrid)\\n        n=len(obstacleGrid[0])\\n        res=[]\\n        \\n        def backtrack(i,j):\\n            if (i<m and i>=0 and j<n and j>=0) and obstacleGrid[i][j]!=1:\\n                if (i,j)==(m-1,n-1):\\n                    ", "def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        m=len(obstacleGrid)\\n        n=len(obstacleGrid[0])\\n        res=[]\\n        \\n        def backtrack(i,j):\\n            if (i<m and i>=0 and j<n and j>=0) and obstacleGrid[i][j]!=1:\\n                if (i,j)==(m-1,n-1):\\n                    "]}
{"id": "649", "ref_py": ["def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        ", "def minPathSum(grid):\\n    m = len(grid)\\n    n = len(grid[0])\\n    \\n    ", "def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        "]}
{"id": "650", "ref_py": ["def simplifyPath(self, path):\\n         ", "def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)", "def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)"]}
{"id": "651", "ref_py": ["defined as the minimum number of operations required to transform one string into another.\\n<!-- Describe your first thoughts on how to solve this problem. -->", "def minDistance(self, word1, word2):\\n        \\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        ", "def minDistance(self, word1, word2):\\n        \\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        "]}
{"id": "652", "ref_py": ["def setZeroes(self, matrix: List[List[int]]) -> None:\\n        ", "def setZeroes(self, matrix: List[List[int]]) -> None:\\n        ", "def setZeroes(self, matrix: List[List[int]]) -> None:\\n        "]}
{"id": "653", "ref_py": ["def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows=len(matrix)\\n        cols=len(matrix[0])\\n        top=0\\n        bottom=rows-1\\n        requiredRow=-1\\n        while top<=bottom:\\n            midRow= (top+bottom)//2\\n            if matrix[midRow][0]<=target and matrix[midRow][cols-1]>=target:\\n                requiredRow=midRow\\n                break\\n            elif matrix[midRow][0]>target:\\n                bottom=midRow-1\\n            elif matrix[midRow][cols-1]<target:\\n                top=midRow+1\\n        if requiredRow==-1:\\n            return False\\n        \\n        left=0\\n        right=cols-1\\n        while left<=right:\\n            mid = (left+right)//2\\n            if matrix[requiredRow][mid]==target:\\n                return True\\n            elif matrix[requiredRow][mid]>target:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False", "def searchMatrix(self,matrix:List[List[int]],target:int)->bool:\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j]==target:\\n                    return True", "def searchMatrix(self,matrix:List[List[int]],target:int)->bool:\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j]==target:\\n                    return True"]}
{"id": "654", "ref_py": ["def sortColors(self, nums: List[int]) -> None:\\n        \\n        nums[:] = nums.count(0) * [0] + nums.count(1) * [1] + nums.count(2) * [2]", "def sortColors(self, nums: List[int]) -> None:\\n        \\n        nums[:] = nums.count(0) * [0] + nums.count(1) * [1] + nums.count(2) * [2]", "def sortColors(self, nums: List[int]) -> None:\\n        \\n        nums[:] = nums.count(0) * [0] + nums.count(1) * [1] + nums.count(2) * [2]"]}
{"id": "655", "ref_py": ["def combine(n, k):\\n    res = []\\n    \\n    def backtrack(combo, start):\\n        if len(combo) == k:\\n            res.append(combo[:])\\n            return\\n        \\n        ", "def combine(n, k):\\n    res = []\\n    \\n    def backtrack(combo, start):\\n        if len(combo) == k:\\n            res.append(combo[:])\\n            return\\n        \\n        ", "def combine(n, k):\\n    res = []\\n    \\n    def backtrack(combo, start):\\n        if len(combo) == k:\\n            res.append(combo[:])\\n            return\\n        \\n        "]}
{"id": "656", "ref_py": ["defines a class `Solution` with a method `subsets` that takes a list of integers `nums` as input and returns a list of all possible subsets of the input list. The subsets are generated using a recursive helper function `subb`.", "def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    ", "def combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    "]}
{"id": "657", "ref_py": ["def exist(self, board: List[List[str]], word: str) -> bool:\\n\\t", "def exist(self, board: List[List[str]], word: str) -> bool:", "def exist(self, board: List[List[str]], word: str) -> bool:"]}
{"id": "658", "ref_py": ["def removeDuplicates(self, nums):\\n        ", "def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t", "def removeDuplicates(self, nums):\\n        "]}
{"id": "659", "ref_py": ["def search(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        l = 0\\n        r = n - 1", "def search(self, nums: List[int], target: int) -> bool:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] == nums[i] and nums[mid] == nums[j]:\\n                i = i + 1\\n                j = j - 1\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return False", "def search(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        l = 0\\n        r = n - 1"]}
{"id": "660", "ref_py": ["def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        ", "def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        ", "def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        "]}
{"id": "661", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```", "def __init__(self, val=0, next=None):\\n"]}
{"id": "662", "ref_py": ["def countNegatives(self, grid):\\n        temp = 0\\n        for x in grid:\\n            for y in x:\\n                if y < 0:\\n                    temp += 1\\n        return temp", "def countNegatives(self, grid):\\n        i = 0\\n        j = len(grid[0]) - 1\\n        count = 0\\n        \\n        while i < len(grid) and j >= 0:\\n            if grid[i][j] < 0:\\n                count += (len(grid) - i)\\n                j -= 1\\n            elif grid[i][j] >= 0:\\n                i += 1\\n        \\n        return count", "def countNegatives(self, grid):\\n        i = 0\\n        j = len(grid[0]) - 1\\n        count = 0\\n        \\n        while i < len(grid) and j >= 0:\\n            if grid[i][j] < 0:\\n                count += (len(grid) - i)\\n                j -= 1\\n            elif grid[i][j] >= 0:\\n                i += 1\\n        \\n        return count"]}
{"id": "663", "ref_py": ["def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(start, path, res):\\n            res.append(path)\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path + [nums[i]], res)\\n        \\n        nums.sort()\\n        res = []\\n        dfs(0, [], res)\\n        return res", "def subsetsWithDup(self, S):\\n            res = [[]]\\n            S.sort()\\n            for i in range(len(S)):\\n                if i == 0 or S[i] != S[i - 1]:\\n                    l = len(res)\\n                for j in range(len(res) - l, len(res)):\\n                    res.append(res[j] + [S[i]])\\n            return res", "def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(start, path, res):\\n            res.append(path)\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path + [nums[i]], res)\\n        \\n        nums.sort()\\n        res = []\\n        dfs(0, [], res)\\n        return res"]}
{"id": "664", "ref_py": ["def numDecodings(self, s):\\n        def decode_helper(index):\\n            if index == len(s):\\n                return 1  ", "define a dynamic programming array where `dp[i]` represents the number of ways to decode the substring starting from position `i` to the end of the string.", "def isValid(code, len):\\n    if len == 1:\\n        return 1 <= code <= 26\\n    else:\\n        return 10 <= code <= 26"]}
{"id": "665", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        if left == right:\\n            return head", "def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        if left == right:\\n            return head"]}
{"id": "666", "ref_py": ["def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)", "def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res", "def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res"]}
{"id": "667", "ref_py": ["def generateTrees(self, n: int) -> List[TreeNode]:\\n        def helper(start, end):\\n            variations = []\\n            if start > end:\\n                variations.append(None)\\n                return variations\\n            if (start, end) in dp:\\n                return dp[(start, end)]\\n            for i in range(start, end + 1):\\n                leftSubTrees = helper(start, i - 1)\\n                rightSubTrees = helper(i + 1, end)\\n                for left in leftSubTrees:\\n                    for right in rightSubTrees:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        variations.append(root)\\n            dp[(start, end)] = variations\\n            return variations\\n        \\n        dp = {}\\n        return helper(1, n)", "def generateTrees(self, n):\\n        def node(val, left, right):\\n            node = TreeNode(val)\\n            node.left = left\\n            node.right = right\\n            return node\\n        def trees(first, last):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in trees(first, root-1)\\n                    for right in trees(root+1, last)] or [None]\\n        return trees(1, n)", "def generateTrees(self, n):\\n        def node(val, left, right):\\n            node = TreeNode(val)\\n            node.left = left\\n            node.right = right\\n            return node\\n        def trees(first, last):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in trees(first, root-1)\\n                    for right in trees(root+1, last)] or [None]\\n        return trees(1, n)"]}
{"id": "668", "ref_py": ["def numTrees(self, n: int) -> int:\\n        self.table = [-1] * (n+1)\\n        self.table[0] = 1\\n        return self.numTreesRec(n)\\n        \\n    def numTreesRec(self, n):\\n        if self.table[n] != -1:\\n            return self.table[n]\\n        total = 0\\n        for m in range(n):\\n            total += (self.numTreesRec(n-1-m) * self.numTreesRec(m))\\n        self.table[n] = total\\n        return total\\n```", "def numTrees(self, n):\\n        if n == 0 or n == 1:\\n            return 1\\n        ", "def numTrees(self, n: int) -> int:\\n\\t\\t\\treturn self._num_trees(1, n)"]}
{"id": "669", "ref_py": ["def solve(self, s1: str, s2: str, s3: str, ind1: int, ind2: int, dp: List[List[int]]) -> bool:\\n        if ind1 + ind2 == len(s3):\\n            return True\\n        if dp[ind1][ind2] != -1:\\n            return dp[ind1][ind2] == 1\\n        ans = False\\n        \\n        if ind1 < len(s1) and s1[ind1] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1 + 1, ind2, dp)\\n        \\n        if ind2 < len(s2) and s2[ind2] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1, ind2 + 1, dp)\\n        \\n        dp[ind1][ind2] = 1 if ans else 0\\n        return ans\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, s3, 0, 0, dp)", "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        len_s1, len_s2, len_s3 = len(s1), len(s2), len(s3)\\n        \\n        ", "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False"]}
{"id": "670", "ref_py": ["def __init__(self, x):\\n", "def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```", "def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**"]}
{"id": "671", "ref_py": ["def recoverTree(self, root):\\n\\t\\n        ", "def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))", "def recoverTree(self, root):\\n\\t\\n        "]}
{"id": "672", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if root is None:\\n            return []\\n        ans=[]\\n        q= deque([root])\\n        while q:\\n            currLevel=[]\\n            for _ in range(len(q)):\\n                node= q.popleft()\\n                currLevel.append(node.val)\\n                if node.left is not None:\\n                    q.append(node.left)\\n                \\n                if node.right is not None:\\n                    q.append(node.right)\\n            ans.append(currLevel)\\n        return ans\\n```", "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if root is None:\\n            return []\\n        ans=[]\\n        q= deque([root])\\n        while q:\\n            currLevel=[]\\n            for _ in range(len(q)):\\n                node= q.popleft()\\n                currLevel.append(node.val)\\n                if node.left is not None:\\n                    q.append(node.left)\\n                \\n                if node.right is not None:\\n                    q.append(node.right)\\n            ans.append(currLevel)\\n        return ans\\n```"]}
{"id": "673", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "674", "ref_py": ["def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None", "def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None", "def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None"]}
{"id": "675", "ref_py": ["def buildTree(self, inorder, postorder):\\n        \\n        ", "def buildTree(self, inorder, postorder):\\n        \\n        ", "def buildTree(self, inorder, postorder):\\n        \\n        "]}
{"id": "676", "ref_py": ["def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return\\n        ans = []\\n        hashT = defaultdict(list)\\n        temp = []\\n        def levelOrd(root, level):\\n            if root is None:\\n                return\\n          \\n            hashT[level].append(root.val)\\n        \\n            levelOrd(root.left, level+1)\\n            levelOrd(root.right, level+1)\\n        \\n        levelOrd(root, 0)\\n        ", "def levelOrderBottom1(self, root):\\n        res = []\\n        self.dfs(root, 0, res)\\n        return res\\n    \\n    def dfs(self, root, level, res):\\n        if root:\\n            if len(res) < level + 1:\\n                res.insert(0, [])\\n            res[-(level+1)].append(root.val)\\n            self.dfs(root.left, level+1, res)\\n            self.dfs(root.right, level+1, res)\\n            \\n    ", "def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return\\n        ans = []\\n        hashT = defaultdict(list)\\n        temp = []\\n        def levelOrd(root, level):\\n            if root is None:\\n                return\\n          \\n            hashT[level].append(root.val)\\n        \\n            levelOrd(root.left, level+1)\\n            levelOrd(root.right, level+1)\\n        \\n        levelOrd(root, 0)\\n        "]}
{"id": "677", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n"]}
{"id": "678", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def pathSum(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, [], res)\\n        return res\\n        \\n    def dfs(self, root, sum, ls, res):\\n        if root:\\n\\t\\t\\tif not root.left and not root.right and sum == root.val:\\n\\t\\t\\t\\tls.append(root.val)\\n", "def pathSum(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, [], res)\\n        return res\\n        \\n    def dfs(self, root, sum, ls, res):\\n        if root:\\n\\t\\t\\tif not root.left and not root.right and sum == root.val:\\n\\t\\t\\t\\tls.append(root.val)\\n"]}
{"id": "679", "ref_py": ["define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards.", "define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards.", "define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards."]}
{"id": "680", "ref_py": ["def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  ", "def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  ", "def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  "]}
{"id": "681", "ref_py": ["def connect(self, root: \\'Node\\') -> \\'Node\\':\\n    ", "def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        q = deque()\\n        q.append(root)\\n        dummy=Node(-999) ", "def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        q = deque()\\n        q.append(root)\\n        dummy=Node(-999) "]}
{"id": "682", "ref_py": ["def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i, j):\\n            if i == len(triangle):\\n                return 0", "def minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(1, len(triangle)):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level-1][min(i, level-1)], triangle[level-1][max(i-1,0)])\\n    return min(triangle[-1])\\n```", "def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i, j):\\n            if i == len(triangle):\\n                return 0"]}
{"id": "683", "ref_py": ["def maxProfit(self, prices: List[int]) -> int:", "def maxProfit(self, prices: List[int]) -> int:", "def maxProfit(self, prices: List[int]) -> int:"]}
{"id": "684", "ref_py": ["def longestConsecutive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        if n == 0:\\n            return 0", "def longestConsecutive(self, nums):\\n        \\n        ", "def longestConsecutive(self, nums: List[int]) -> int:\\n\\tnums.sort()\\n\\tlongest, cur_longest = 0, min(1, len(nums))\\n\\tfor i in range(1,len(nums)):\\n\\t\\tif nums[i] == nums[i - 1] : continue\\n\\t\\tif nums[i] == nums[i - 1] + 1: cur_longest += 1\\n\\t\\telse: longest, cur_longest = max(longest, cur_longest), 1\\n\\treturn max(longest, cur_longest)\\n```"]}
{"id": "685", "ref_py": ["def sumNumbers(self, root):\\n        \\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)", "def sumNumbers(self, root):\\n        \\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)", "def sumNumbers(self, root):\\n        \\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)"]}
{"id": "686", "ref_py": ["def solve(self, board: List[List[str]]) -> None:\\n        rows, cols= len(board), len(board[0])", "def solve(self, board: List[List[str]]) -> None:\\n        \\n        rows = len(board) \\n        cols = len(board[0])\\n        \\n        def dfs(i,j):\\n            if i < 0 or j < 0 or i >= rows or j >= cols or board[i][j] == \"X\" or board[i][j] ==\"g\":\\n                return \\n            \\n            board[i][j] = \"g\"\\n            \\n            dfs(i, j + 1)\\n            dfs(i, j - 1)\\n            dfs(i + 1, j)\\n            dfs(i - 1, j)\\n            \\n       ", "def solve(self, board: List[List[str]]) -> None:\\n        \\n        rows = len(board) \\n        cols = len(board[0])\\n        \\n        def dfs(i,j):\\n            if i < 0 or j < 0 or i >= rows or j >= cols or board[i][j] == \"X\" or board[i][j] ==\"g\":\\n                return \\n            \\n            board[i][j] = \"g\"\\n            \\n            dfs(i, j + 1)\\n            dfs(i, j - 1)\\n            dfs(i + 1, j)\\n            dfs(i - 1, j)\\n            \\n       "]}
{"id": "687", "ref_py": ["def checkPalindrome(self, str, startIndex, lastIndex):\\n        while startIndex <= lastIndex:\\n            if str[startIndex] != str[lastIndex]:\\n                return False\\n            startIndex += 1\\n            lastIndex -= 1\\n        return True", "def partition(self, s: str) -> List[List[str]]:\\n        res = [] ", "def partition(self, s: str) -> List[List[str]]:\\n        res = [] "]}
{"id": "688", "ref_py": ["def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return None\\n        \\n        cloned = {}\\n        stack = [node]\\n        cloned[node] = Node(node.val)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            \\n            for neighbor in curr.neighbors:\\n                if neighbor not in cloned:\\n                    cloned[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n                \\n                cloned[curr].neighbors.append(cloned[neighbor])\\n        \\n        return cloned[node]", "def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return None\\n        \\n        cloned = {}\\n        stack = [node]\\n        cloned[node] = Node(node.val)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            \\n            for neighbor in curr.neighbors:\\n                if neighbor not in cloned:\\n                    cloned[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n                \\n                cloned[curr].neighbors.append(cloned[neighbor])\\n        \\n        return cloned[node]", "def __init__(self, val = 0, neighbors = None):\\n        self.val = val\\n        self.neighbors = neighbors if neighbors is not None else []\\n\\n        :type node: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not node:\\n            return None\\n        \\n        cloned = {}\\n        stack = [node]\\n        cloned[node] = Node(node.val)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            \\n            for neighbor in curr.neighbors:\\n                if neighbor not in cloned:\\n                    cloned[neighbor] = Node(neighbor.val)\\n                    stack.append(neighbor)\\n                \\n                cloned[curr].neighbors.append(cloned[neighbor])\\n        \\n        return cloned[node]"]}
{"id": "689", "ref_py": ["def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\ttrip_tank, curr_tank, start, n = 0, 0, 0, len(gas)\\n\\tfor i in range(n):\\n\\t\\ttrip_tank += gas[i] - cost[i]\\n\\t\\tcurr_tank += gas[i] - cost[i]\\n\\t\\tif curr_tank < 0:\\n\\t\\t\\tstart = i + 1\\n\\t\\t\\tcurr_tank = 0 \\n\\treturn start if trip_tank >= 0 else -1\\n```\\n", "def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost):\\n            return -1\\n        a = len(gas)\\n        s = 0\\n        result = 0\\n        for i in range(a):\\n            s += gas[i] - cost[i]\\n            if s < 0:\\n                s = 0\\n                result =(i + 1) % a \\n        return result", "def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\ttrip_tank, curr_tank, start, n = 0, 0, 0, len(gas)\\n\\tfor i in range(n):\\n\\t\\ttrip_tank += gas[i] - cost[i]\\n\\t\\tcurr_tank += gas[i] - cost[i]\\n\\t\\tif curr_tank < 0:\\n\\t\\t\\tstart = i + 1\\n\\t\\t\\tcurr_tank = 0 \\n\\treturn start if trip_tank >= 0 else -1\\n```\\n"]}
{"id": "690", "ref_py": ["def singleNumber(self, nums: list[int]) -> int:\\n        def counts(a: tuple[int, int], num: int) -> tuple[int, int]:\\n            ones, twos = a\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n            return ones, twos\\n        \\n        return reduce(counts, nums, (0, 0))[0]", "def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0", "def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0"]}
{"id": "691", "ref_py": ["def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        current = head\\n        while current:\\n            new_node = Node(current.val)\\n            new_node.next = current.next\\n            current.next = new_node\\n            current = new_node.next\\n        \\n        current = head\\n        while current:\\n            if current.random:\\n                current.next.random = current.random.next\\n            current = current.next.next\\n        \\n        new_head = head.next\\n        current = head\\n        while current:\\n            temp = current.next\\n            current.next = temp.next\\n            current = current.next\\n            if temp.next:\\n                temp.next = temp.next.next\\n        \\n        return new_head", "def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        node_map = {}\\n        current = head\\n        \\n        ", "def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        current = head\\n        while current:\\n            new_node = Node(current.val)\\n            new_node.next = current.next\\n            current.next = new_node\\n            current = new_node.next\\n        \\n        current = head\\n        while current:\\n            if current.random:\\n                current.next.random = current.random.next\\n            current = current.next.next\\n        \\n        new_head = head.next\\n        current = head\\n        while current:\\n            temp = current.next\\n            current.next = temp.next\\n            current = current.next\\n            if temp.next:\\n                temp.next = temp.next.next\\n        \\n        return new_head"]}
{"id": "692", "ref_py": ["def __init__(self):\\n        self.dp = {}", "def __init__(self):\\n        self.dp = {}", "def __init__(self):\\n        self.dp = {}"]}
{"id": "693", "ref_py": ["def detectCycle(self, head: ListNode) -> ListNode:\\n    ", "definition of x, `head` will also reach the start of the cycle after moving `x` steps.\\n* so if `head` and `slow` start to move at the same time, they will meet at the start of the cycle, that is the answer.", "def detectCycle(self, head: ListNode) -> ListNode:\\n    "]}
{"id": "694", "ref_py": ["def reorderList(self, head: ListNode) -> None:\\n        \\n\\t\\t\\n\\t\\t", "def reorderList(self, head: Optional[ListNode]) -> None:\\n        ", "def reorderList(self, head: ListNode) -> None:\\n        \\n\\t\\t\\n\\t\\t"]}
{"id": "696", "ref_py": ["def insertionSortList(self, head: ListNode) -> ListNode:\\n        \\n        ", "def insertionSortList(self, head: ListNode) -> ListNode:\\n        ", "def insertionSortList(self, head: ListNode) -> ListNode:\\n        \\n        "]}
{"id": "697", "ref_py": ["def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n  dummy = ListNode(0)\\n  dummy.next = head", "def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        ", "def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n  dummy = ListNode(0)\\n  dummy.next = head"]}
{"id": "698", "ref_py": ["def evalRPN(self, tokens: List[str]) -> int:\\n        s=[]\\n        for i in tokens:\\n            if i not in {\"+\",\"-\",\"/\",\"*\"}:\\n                s.append(int(i))\\n            else:\\n                b,a=s.pop(),s.pop()\\n                if i==\"+\":s.append(a+b)\\n                elif i==\"-\":s.append(a-b)\\n                elif i==\"*\":s.append(a*b)\\n                else: s.append(trunc(a/b))\\n        return s[0]\\n        \\n```\\n**Runtime:**  151 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def evalRPN(self, tokens: List[str]) -> int:\\n        s=[]\\n        for i in tokens:\\n            if i not in {\"+\",\"-\",\"/\",\"*\"}:\\n                s.append(int(i))\\n            else:\\n                b,a=s.pop(),s.pop()\\n                if i==\"+\":s.append(a+b)\\n                elif i==\"-\":s.append(a-b)\\n                elif i==\"*\":s.append(a*b)\\n                else: s.append(trunc(a/b))\\n        return s[0]\\n        \\n```\\n**Runtime:**  151 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def evalRPN(self, tokens: List[str]) -> int:\\n        s=[]\\n        for i in tokens:\\n            if i not in {\"+\",\"-\",\"/\",\"*\"}:\\n                s.append(int(i))\\n            else:\\n                b,a=s.pop(),s.pop()\\n                if i==\"+\":s.append(a+b)\\n                elif i==\"-\":s.append(a-b)\\n                elif i==\"*\":s.append(a*b)\\n                else: s.append(trunc(a/b))\\n        return s[0]\\n        \\n```\\n**Runtime:**  151 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "699", "ref_py": ["def reverseWords(self, s):\\n        ", "def reverseWords(self, s: str) -> str:\\n        ", "def reverseWords(self, s: str) -> str:\\n        "]}
{"id": "700", "ref_py": ["def maxProduct(self, nums: List[int]) -> int:\\n        min_prod = max_prod = ans = nums[0]", "def maxProduct(self, nums):\\n        \\n        prev_max = nums[0] ", "def maxProduct(self, nums: List[int]) -> int:\\n        min_prod = max_prod = ans = nums[0]"]}
{"id": "701", "ref_py": ["def findMin(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        left=0\\n        right=n-1\\n        while left<=right:\\n            mid = (left+right)//2\\n            ", "def findMin(self, nums: List[int]) -> int:\\n        ", "def findMin(self, nums: List[int]) -> int:\\n        "]}
{"id": "703", "ref_py": ["def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            ", "def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            ", "def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            "]}
{"id": "704", "ref_py": ["def compareVersion(self, version1: str, version2: str) -> int:\\n    ", "def compareVersion(self, version1, version2):\\n        splits = (map(int, v.split('.')) for v in (version1, version2))\\n        return cmp(*zip(*itertools.izip_longest(*splits, fillvalue=0)))", "def compareVersion(self, version1: str, version2: str) -> int:\\n    "]}
{"id": "705", "ref_py": ["def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        ", "def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))", "def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        "]}
{"id": "706", "ref_py": ["def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\\n[Al_Dan](https://leetcode.com/Al_Dan/) pointed out that the solution can be made a bit more concise as the problem description states the following constraint:\\n>The tests are generated such that there is exactly one solution.", "def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\\n[Al_Dan](https://leetcode.com/Al_Dan/) pointed out that the solution can be made a bit more concise as the problem description states the following constraint:\\n>The tests are generated such that there is exactly one solution.", "def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\\n[Al_Dan](https://leetcode.com/Al_Dan/) pointed out that the solution can be made a bit more concise as the problem description states the following constraint:\\n>The tests are generated such that there is exactly one solution."]}
{"id": "707", "ref_py": ["def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c", "def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c", "def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c"]}
{"id": "712", "ref_py": ["def __lt__(x, y):\\n        ", "def __lt__(x, y):\\n        ", "def __lt__(x, y):\\n        "]}
{"id": "715", "ref_py": ["def findRepeatedDnaSequences(self, s):\\n        m = {}\\n        for i in range(len(s)):\\n            m[s[i : i + 10]] = 1 + m.get(s[i : i + 10], 0)\\n        return [key for key, value in m.items() if value > 1]     ", "def findRepeatedDnaSequences(self, s):\\n        m = {}\\n        for i in range(len(s)):\\n            m[s[i : i + 10]] = 1 + m.get(s[i : i + 10], 0)\\n        return [key for key, value in m.items() if value > 1]     ", "def findRepeatedDnaSequences(self, s):\\n        m = {}\\n        for i in range(len(s)):\\n            m[s[i : i + 10]] = 1 + m.get(s[i : i + 10], 0)\\n        return [key for key, value in m.items() if value > 1]     "]}
{"id": "716", "ref_py": ["def rotate(self, nums, k):\\n        if len(nums) == 0:\\n            return []\\n        if k == 0:\\n            return nums\\n        if len(nums)<k:\\n            nums[:] = Solution.rotate(self,nums,len(nums))\\n            nums[:] = Solution.rotate(self,nums,k-len(nums))\\n        nums.reverse()\\n        nums[:k] = reversed(nums[:k])\\n        nums[k:] = reversed(nums[k:])\\n        return nums\\n            \\n```\\n![image.png](https://assets.leetcode.com/users/images/a16354d4-6cdd-4d82-b759-a1fba4152e62_1701623756.8915458.png)", "defined as` the array part just before the last 3 values. What I mean is something like [1,2,3,4]\\n* `[P2] is defined as` the array part just after remaining values which we have to rotate [5,6,7]", "def rotate(self, nums, k):\\n        if len(nums) == 0:\\n            return []\\n        if k == 0:\\n            return nums\\n        if len(nums)<k:\\n            nums[:] = Solution.rotate(self,nums,len(nums))\\n            nums[:] = Solution.rotate(self,nums,k-len(nums))\\n        nums.reverse()\\n        nums[:k] = reversed(nums[:k])\\n        nums[k:] = reversed(nums[k:])\\n        return nums\\n            \\n```\\n![image.png](https://assets.leetcode.com/users/images/a16354d4-6cdd-4d82-b759-a1fba4152e62_1701623756.8915458.png)"]}
{"id": "719", "ref_py": ["def maxSubArray(self, nums):\\n        ", "def maxSubArray(self, nums):\\n        ", "def maxSubArray(self, nums):\\n        "]}
{"id": "720", "ref_py": ["def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn ", "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn ", "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn "]}
{"id": "721", "ref_py": ["def numIslands(self, grid):\\n        def sink(i, j):\\n            if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == '1':\\n                grid[i][j] = '0'\\n                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n                return 1\\n            return 0\\n        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))", "def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        if not grid:\\n            return 0   \\n        count = 0\\n        check = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] ==\\'1\\' and check[i][j]== False:\\n                    count += 1\\n                    self.search(grid,check,i,j)\\n        return count       \\n    def search(self,grid,check,i,j):\\n        qu = deque([(i,j)])\\n        while qu:\\n            i, j = qu.popleft()\\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==\\'1\\' and check[i][j]==False:\\n                check[i][j] = True\\n                qu.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)])\\n```\\n* Improve space complexity to O(1): we can improve the algorithm by replacing the check matrix by flip the visited \\'1\\' to \\'0\\'. We can flip the visited \\'1\\' to \\'0\\' since we are only adding the index of \\'1\\' into the queue. The connected \\'1\\' already flip into \\'0\\', so we don\\'t need to worry about duplicate calculation. \\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    ", "def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        if not grid:\\n            return 0   \\n        count = 0\\n        check = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] ==\\'1\\' and check[i][j]== False:\\n                    count += 1\\n                    self.search(grid,check,i,j)\\n        return count       \\n    def search(self,grid,check,i,j):\\n        qu = deque([(i,j)])\\n        while qu:\\n            i, j = qu.popleft()\\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==\\'1\\' and check[i][j]==False:\\n                check[i][j] = True\\n                qu.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)])\\n```\\n* Improve space complexity to O(1): we can improve the algorithm by replacing the check matrix by flip the visited \\'1\\' to \\'0\\'. We can flip the visited \\'1\\' to \\'0\\' since we are only adding the index of \\'1\\' into the queue. The connected \\'1\\' already flip into \\'0\\', so we don\\'t need to worry about duplicate calculation. \\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    "]}
{"id": "722", "ref_py": ["def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        \\n        ", "def rangeBitwiseAnd(self, m, n):\\n        i = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            i += 1\\n        return n << i", "def rangeBitwiseAnd(self, m, n):\\n        i = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            i += 1\\n        return n << i"]}
{"id": "723", "ref_py": ["def countPrimes(self, n: int) -> int:\\n        seen, ans = [0] * n, 0\\n        for num in range(2, n):\\n            if seen[num]: continue\\n            ans += 1\\n            seen[num*num:n:num] = [1] * ((n - 1) // num - num + 1)\\n        return ans\\n```", "def countPrimes(self, n: int) -> int:\\n        if n <= 2:\\n            return 0\\n        \\n        ", "def countPrimes(self, n: int) -> int:\\n        if n < 3: return 0     "]}
{"id": "724", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if root is None:\\n            return []\\n        ans=[]\\n        q= deque([root])\\n        while q:\\n            currLevel=[]\\n            for _ in range(len(q)):\\n                node= q.popleft()\\n                currLevel.append(node.val)\\n                if node.left is not None:\\n                    q.append(node.left)\\n                \\n                if node.right is not None:\\n                    q.append(node.right)\\n            ans.append(currLevel)\\n        return ans\\n```", "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if root is None:\\n            return []\\n        ans=[]\\n        q= deque([root])\\n        while q:\\n            currLevel=[]\\n            for _ in range(len(q)):\\n                node= q.popleft()\\n                currLevel.append(node.val)\\n                if node.left is not None:\\n                    q.append(node.left)\\n                \\n                if node.right is not None:\\n                    q.append(node.right)\\n            ans.append(currLevel)\\n        return ans\\n```"]}
{"id": "726", "ref_py": ["def minSubArrayLen(self, target, nums):\\n        \\n        start = 0\\n        end = 0\\n        min_length = float(\\'inf\\')\\n        n = len(nums)\\n        curr_sum = 0\\n        while end<n:\\n            curr_sum+= nums[end]", "def minSubArrayLen(self, target, nums):\\n        length = float(\\'inf\\')\\n        left = 0\\n        summ=0", "def minSubArrayLen(self, target, nums):\\n        length = float(\\'inf\\')\\n        left = 0\\n        summ=0"]}
{"id": "727", "ref_py": ["defaultdict, deque", "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        ", "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        def dfs(sv,visited):\\n            if visited[sv]==-1:"]}
{"id": "729", "ref_py": ["def rob(self, nums):\\n        \\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```", "def rob(self, nums):\\n        \\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```", "def rob(self, nums):\\n        \\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```"]}
{"id": "730", "ref_py": ["default ascending order.\\n    //step 2: largest elements will be towards the end of the array as the array is a sorted one.\\n    //step 3: the kth largest element is the last element minus the the given k value.\\n    //for ex: 3rd largest element in a sorted array will be (n-3)th element.\\n    //arr[1,2,3,4,5]; k=2\\n    //2nd largest element = 5-2 = 3rd element = 4.\\n    var newarr=nums.sort((a,b)=>(a-b));\\n    let n=newarr.length;\\n    return newarr[n-k];\\n};\\n```\\n", "def findKthLargest(self, nums: List[int], k: int) -> int:\\n        pivot=random.choice(nums)\\n        left=[x for x in nums if x>pivot]\\n        mid=[x for x in nums if x==pivot]\\n        right=[x for x in nums if x<pivot]\\n        n=len(left)\\n        m=len(mid)\\n        if k<=n:\\n            return self.findKthLargest(left,k)", "default ascending order.\\n    //step 2: largest elements will be towards the end of the array as the array is a sorted one.\\n    //step 3: the kth largest element is the last element minus the the given k value.\\n    //for ex: 3rd largest element in a sorted array will be (n-3)th element.\\n    //arr[1,2,3,4,5]; k=2\\n    //2nd largest element = 5-2 = 3rd element = 4.\\n    var newarr=nums.sort((a,b)=>(a-b));\\n    let n=newarr.length;\\n    return newarr[n-k];\\n};\\n```\\n"]}
{"id": "731", "ref_py": ["def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III.", "def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III.", "def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III."]}
{"id": "732", "ref_py": ["def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        dp = [[0]*(cols+1) for _ in range(rows+1)]\\n        max_side = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] == \\'1\\':\\n                    dp[r+1][c+1] = min(dp[r][c], dp[r+1][c], dp[r][c+1]) + 1 ", "define a 2D array dp where dp[i][j] represents the maximum size of a square that can be formed at position (i, j) such that all its elements are 1\\'s. We can fill this array using the following recurrence relation:", "define a 2D array dp where dp[i][j] represents the maximum size of a square that can be formed at position (i, j) such that all its elements are 1\\'s. We can fill this array using the following recurrence relation:"]}
{"id": "733", "ref_py": ["def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        ", "def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        a1=(ax2-ax1)*(ay2-ay1)\\n        a2=(bx2-bx1)*(by2-by1)\\n        x1=max(ax1,bx1)\\n        x2=min(ax2,bx2)\\n        y1=max(ay1,by1)\\n        y2=min(ay2,by2)\\n        if x2-x1<0 or y2-y1<0: ", "def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        a1=(ax2-ax1)*(ay2-ay1)\\n        a2=(bx2-bx1)*(by2-by1)\\n        x1=max(ax1,bx1)\\n        x2=min(ax2,bx2)\\n        y1=max(ay1,by1)\\n        y2=min(ay2,by2)\\n        if x2-x1<0 or y2-y1<0: "]}
{"id": "734", "ref_py": ["def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))"]}
{"id": "735", "ref_py": ["def majorityElement(self, nums: list[int]) -> list[int]:\\n        ", "def majorityElement(self, nums):\\n        return [num for num, count in Counter(nums).items() if count > len(nums) // 3]", "def majorityElement(self, nums: list[int]) -> list[int]:\\n        "]}
{"id": "736", "ref_py": ["def kthSmallest(self, root, k):\\n        values = []\\n        self.inorder(root, values)\\n        return values[k - 1]", "def kthSmallest(self, root, k):\\n        self.k = k\\n        self.res = None\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, node):\\n        if not node:\\n            return\\n        self.helper(node.left)\\n        self.k -= 1\\n        if self.k == 0:\\n            self.res = node.val\\n            return\\n        self.helper(node.right)", "def kthSmallest(self, root, k):\\n        self.k = k\\n        self.res = None\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, node):\\n        if not node:\\n            return\\n        self.helper(node.left)\\n        self.k -= 1\\n        if self.k == 0:\\n            self.res = node.val\\n            return\\n        self.helper(node.right)"]}
{"id": "737", "ref_py": ["def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        while True:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```", "def lowestCommonAncestor(self, root, p, q):\\n    while True:\\n        if root.val < min(p.val,q.val):\\n            root = root.right\\n        elif root.val > max(p.val,q.val):\\n            root = root.left\\n        else:\\n            return root\\n```", "def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\t\\tdef find_lca(root, p, q):\\n\\t\\t\\tif root in [p, q, None]:\\n\\t\\t\\t\\treturn root"]}
{"id": "738", "ref_py": ["def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        left, right = (self.lowestCommonAncestor(kid, p, q)\\n                       for kid in (root.left, root.right))\\n        return root if left and right else left or right", "def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n    if not root or root == p or root == q:\\n      return root", "def lowestCommonAncestor(self, root, p, q):\\n        stack = [root]\\n        parent = {root: None}\\n        while p not in parent or q not in parent:\\n            node = stack.pop()\\n            if node.left:\\n                parent[node.left] = node\\n                stack.append(node.left)\\n            if node.right:\\n                parent[node.right] = node\\n                stack.append(node.right)\\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        while q not in ancestors:\\n            q = parent[q]\\n        return q"]}
{"id": "739", "ref_py": ["def __init__(self, x):\\n", "def __init__(self, x):\\n", "def __init__(self, x):\\n"]}
{"id": "740", "ref_py": ["def productExceptSelf(self, nums):\\n        n = len(nums)\\n        prefix = 1\\n        postfix = 1\\n        output = [1] * n\\n        ", "def productExceptSelf(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    left_product = [1] * n ", "def productExceptSelf(self, nums):\\n        n = len(nums)\\n        prefix = 1\\n        postfix = 1\\n        output = [1] * n\\n        "]}
{"id": "741", "ref_py": ["def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        ROWS, COLS = len(matrix), len(matrix[0])", "def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        ROWS, COLS = len(matrix), len(matrix[0])", "def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        ROWS, COLS = len(matrix), len(matrix[0])"]}
{"id": "742", "ref_py": ["def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        ", "def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        ", "def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        "]}
{"id": "743", "ref_py": ["defaultdict) to store the count of each number in the array.\\n2. Iterate through the input array, and for each number, increment its count in the dictionary.\\n3. Iterate through the dictionary, and for each key-value pair, if the value is 1 (indicating the number appears only once), add the key to a result list.\\n4. Return the result list containing the two distinct numbers.", "defaultdict) to store the count of each number in the array.\\n2. Iterate through the input array, and for each number, increment its count in the dictionary.\\n3. Iterate through the dictionary, and for each key-value pair, if the value is 1 (indicating the number appears only once), add the key to a result list.\\n4. Return the result list containing the two distinct numbers.", "defaultdict) to store the count of each number in the array.\\n2. Iterate through the input array, and for each number, increment its count in the dictionary.\\n3. Iterate through the dictionary, and for each key-value pair, if the value is 1 (indicating the number appears only once), add the key to a result list.\\n4. Return the result list containing the two distinct numbers."]}
{"id": "744", "ref_py": ["def nthUglyNumber(self, n: int) -> int:\\n        ugly = [1]  ", "defunct acm.uva.es :-)", "defunct acm.uva.es :-)"]}
{"id": "745", "ref_py": ["def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) ", "def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) ", "def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) "]}
{"id": "746", "ref_py": ["def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] == n - mid:\\n                return n - mid\\n            elif citations[mid] < n - mid:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return n - left", "def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] == n - mid:\\n                return n - mid\\n            elif citations[mid] < n - mid:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return n - left", "def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] == n - mid:\\n                return n - mid\\n            elif citations[mid] < n - mid:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return n - left"]}
{"id": "747", "ref_py": ["def numSquares(self, n: int) -> int:", "def solve(n):", "def solve(n):"]}
{"id": "749", "ref_py": ["def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []", "def runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] ", "def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []"]}
{"id": "750", "ref_py": ["def gameOfLife(self, b: List[List[int]]) -> None:\\n        \\n        ", "def gameOfLifeInfinite(self, live):\\n        ctr = collections.Counter((I, J)\\n                                  for i, j in live\\n                                  for I in range(i-1, i+2)\\n                                  for J in range(j-1, j+2)\\n                                  if I != i or J != j)\\n        return {ij\\n                for ij in ctr\\n                if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}", "def gameOfLife(self, b: List[List[int]]) -> None:\\n        \\n        "]}
{"id": "751", "ref_py": ["def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```", "def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```", "def reformatNumber(self, number: str) -> str:\\n    return re.sub(\\'(...?(?=..))\\', r\\'\\\\1-\\', re.sub(\\'\\\\D\\', \\'\\', number))\\n```"]}
{"id": "752", "ref_py": ["def lengthOfLIS(self, nums):\\n        tails = [0] * len(nums)\\n        size = 0\\n        for x in nums:\\n            i, j = 0, size\\n            while i != j:\\n                m = (i + j) / 2\\n                if tails[m] < x:\\n                    i = m + 1\\n                else:\\n                    j = m\\n            tails[i] = x\\n            size = max(i + 1, size)\\n        return size", "def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        n = len(nums)\\n        dp = [1] * n", "def lengthOfLIS(self, nums):\\n        tails = [0] * len(nums)\\n        size = 0\\n        for x in nums:\\n            i, j = 0, size\\n            while i != j:\\n                m = (i + j) / 2\\n                if tails[m] < x:\\n                    i = m + 1\\n                else:\\n                    j = m\\n            tails[i] = x\\n            size = max(i + 1, size)\\n        return size"]}
{"id": "754", "ref_py": ["def isAdditiveNumber(self, num: str) -> bool:\\n        n = len(num)\\n        \\n        ", "def isAdditiveNumber(self, num: str) -> bool:\\n        n = len(num)\\n        \\n        ", "def isAdditiveNumber(self, num: str) -> bool:\\n        n = len(num)\\n        \\n        "]}
{"id": "756", "ref_py": ["definition we have:", "definition we have:", "definition we have:"]}
{"id": "757", "ref_py": ["def findMinHeightTrees(self, n, edges):\\n        if n == 1: return [0] \\n        adj = [set() for _ in xrange(n)]\\n        for i, j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)", "defaultdict", "def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n    "]}
{"id": "758", "ref_py": ["def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ", "def nthSuperUglyNumber(self, n, primes):\\n        uglies = [1]\\n        def gen(prime):\\n            for ugly in uglies:\\n                yield ugly * prime\\n        merged = heapq.merge(*map(gen, primes))\\n        while len(uglies) < n:\\n            ugly = next(merged)\\n            if ugly != uglies[-1]:\\n                uglies.append(ugly)\\n        return uglies[-1]", "def nthSuperUglyNumber(self, n, primes):\\n        uglies = [1]\\n        def gen(prime):\\n            for ugly in uglies:\\n                yield ugly * prime\\n        merged = heapq.merge(*map(gen, primes))\\n        while len(uglies) < n:\\n            ugly = next(merged)\\n            if ugly != uglies[-1]:\\n                uglies.append(ugly)\\n        return uglies[-1]"]}
{"id": "759", "ref_py": ["def removeDuplicateLetters(self, s: str) -> str:\\n        \\n\\t\\tlast_occ = {}\\n\\t\\tstack = []\\n\\t\\tvisited = set()", "def removeDuplicateLetters(self, s: str) -> str:\\n        \\n\\t\\tlast_occ = {}\\n\\t\\tstack = []\\n\\t\\tvisited = set()", "def removeDuplicateLetters(self, s: str) -> str:\\n        \\n\\t\\tlast_occ = {}\\n\\t\\tstack = []\\n\\t\\tvisited = set()"]}
{"id": "760", "ref_py": ["def maxProduct(self, words: List[str]) -> int:\\n\\tdef common(chars1, chars2):\\n\\t\\tfor c1, c2 in zip(chars1, chars2):\\n\\t\\t\\tif c1 and c2: return True\\n\\t\\treturn False\\n\\tchars, ans = [[False]*26 for i in range(len(words))], 0\\n\\tfor i, word in enumerate(words):\\n\\t\\tfor ch in word:\\n\\t\\t\\tchars[i][ord(ch) - ord(\\'a\\')] = True\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif not common(chars[i], chars[j]):\\n\\t\\t\\t\\tans = max(ans, len(words[i]) * len(words[j]))\\n\\treturn ans\\n```", "defining a nested function getMask(word: str) -> int that takes a string and returns an integer bit mask. The bit mask is computed by looping over each character in the string and setting the corresponding bit in the mask to 1. The bit position is determined by subtracting the ASCII value of the character \\'a\\' from the ASCII value of the current character.", "def maxProduct(self, words: List[str]) -> int:\\n        n=len(words)                        \\n        char_set = [set(words[i]) for i in range(n)] "]}
{"id": "761", "ref_py": ["def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n```\\n```Java []\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```", "def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n```\\n```Java []\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```", "def bulbSwitch(self, n: int) -> int:\\n        return int(n**0.5)\\n```\\n```Java []\\nclass Solution {\\n    public int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```"]}
{"id": "762", "ref_py": ["def coinChange(self, coins: List[int], amount: int) -> int:\\n        dp = [0] + ([float(\\'inf\\')] * amount)\\n        for i in range(1, amount + 1):\\n            for coin in coins:\\n                if coin <= i:\\n                    dp[i] = min(dp[i], dp[i - coin] + 1)", "def coinChange(self, coins, amount):\\n        \\n        def dp_solver(index, target, dp):\\n            if index == 0:\\n                if target % coins[0] == 0:\\n                    return  target / coins[0]", "def coinChange(self, coins: List[int], amount: int) -> int:        \\n        dp=[math.inf] * (amount+1)\\n        dp[0]=0\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                if i-coin>=0:\\n                    dp[i]=min(dp[i], dp[i-coin]+1)\\n        \\n        return -1 if dp[-1]==math.inf else dp[-1]\\n                \\n```"]}
{"id": "763", "ref_py": ["def wiggleSort(self, nums):\\n        ", "def wiggleSort(self, nums):\\n        ", "def wiggleSort(self, nums):\\n        "]}
{"id": "764", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def oddEvenList(self, head: ListNode) -> ListNode:\\n        ", "def oddEvenList(self, head: ListNode) -> ListNode:\\n        "]}
{"id": "765", "ref_py": ["def isValidSerialization(self, preorder: str) -> bool:\\n        ", "def isValidSerialization(self, preorder):\\n        need = 1\\n        for val in preorder.split(','):\\n            if not need:\\n                return False\\n            need -= ' ", "def isValidSerialization(self, preorder: str) -> bool:\\n        "]}
{"id": "766", "ref_py": ["def increasingTriplet(self, nums: list[int]) -> bool:\\n        \\n        first, second = inf, inf\\n        \\n        for third in nums:\\n            \\n            if second < third: return True\\n            if third <= first: first= third    \\n            else:  second = third \\n                \\n        return  False\\n```\\n[https://leetcode.com/submissions/detail/680380429/](http://)\\n", "def increasingTriplet(self, nums: list[int]) -> bool:\\n        \\n        first, second = inf, inf\\n        \\n        for third in nums:\\n            \\n            if second < third: return True\\n            if third <= first: first= third    \\n            else:  second = third \\n                \\n        return  False\\n```\\n[https://leetcode.com/submissions/detail/680380429/](http://)\\n", "def increasingTriplet(self, nums: list[int]) -> bool:\\n        \\n        first, second = inf, inf\\n        \\n        for third in nums:\\n            \\n            if second < third: return True\\n            if third <= first: first= third    \\n            else:  second = third \\n                \\n        return  False\\n```\\n[https://leetcode.com/submissions/detail/680380429/](http://)\\n"]}
{"id": "767", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "769", "ref_py": ["def integerBreak(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        dp[1] = 1\\n        for i in range(2, n + 1):\\n            dp[i] = -float(\\'inf\\')\\n            for j in range(1, i):\\n                dp[i] = max(dp[i], j * (i - j), j * dp[i - j])\\n        return dp[n]\\n```\\n```Java []\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; ++i) {\\n            for (int j = 1; j < i; ++j) {\\n                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n```C []\\nint integerBreak(int n) {\\n    if (n < 2) {\\n        return 0;\\n    }\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    for (int i = 2; i <= n; i++) {\\n        dp[i] = 0;\\n        for (int j = 1; j < i; j++) {\\n            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));\\n        }\\n    }\\n    return dp[n];\\n}\\n```\\n", "def integerBreak(self, n: int) -> int:\\n        ", "def integerBreak(self, n: int) -> int:\\n        "]}
{"id": "770", "ref_py": ["def topKFrequent(self, nums: List[int], k: int) -> List[int]:", "def topKFrequent(self, nums: List[int], k: int) -> List[int]:", "def topKFrequent(self, nums: List[int], k: int) -> List[int]:"]}
{"id": "772", "ref_py": ["def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        ", "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        ", "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\\n        \\n        "]}
{"id": "773", "ref_py": ["def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\\n        if jug1Capacity + jug2Capacity < targetCapacity:\\n            return False\\n        def greatestCommonDevisor(x, y):\\n           while(y):\\n               x, y = y, x % y\\n           return x\\n        \\n        gcd = greatestCommonDevisor(jug1Capacity, jug2Capacity)\\n        return True if targetCapacity % gcd == 0 else False", "def canMeasureWater(self, jug1: int, jug2: int, tar: int) -> bool:\\n\\tif(jug1 + jug2 < tar):\\n\\t\\treturn 0\\n", "def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\\n        if jug1Capacity + jug2Capacity < targetCapacity:\\n            return False\\n        def greatestCommonDevisor(x, y):\\n           while(y):\\n               x, y = y, x % y\\n           return x\\n        \\n        gcd = greatestCommonDevisor(jug1Capacity, jug2Capacity)\\n        return True if targetCapacity % gcd == 0 else False"]}
{"id": "774", "ref_py": ["def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))", "def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        tmp=[]\\n        ans=[]\\n        dp=[-1]*n\\n        def lds(i,prev,tmp,ans):\\n            if i>=n:\\n                if len(tmp)>len(ans):\\n                    ans.append(tmp[:])\\n                return \\n            if len(tmp)>dp[i] and nums[i]%prev==0:\\n                dp[i]=len(tmp)\\n                tmp.append(nums[i])\\n                lds(i+1,nums[i],tmp,ans)\\n                tmp.pop()\\n            lds(i+1,prev,tmp,ans)\\n        lds(0,1,tmp,ans)\\n        p=[]\\n        res=0\\n        for i in ans:\\n            if len(i)>res:\\n                res=len(i)\\n                p=i\\n        return p", "def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))"]}
{"id": "775", "ref_py": ["def getSum(self, a: int, b: int) -> int:\\n        \\n        ", "def getSum(self, a: int, b: int) -> int:\\n        \\n        ", "def getSum(self, a: int, b: int) -> int:\\n        \\n        "]}
{"id": "776", "ref_py": ["def superPow(self, a: int, b: List[int]) -> int:\\n        ", "def superPow(self, a: int, b: List[int]) -> int:\\n        ", "def superPow(self, a: int, b: List[int]) -> int:\\n        "]}
{"id": "777", "ref_py": ["def kSmallestPairs(self, nums1, nums2, k):\\n        return sorted(itertools.product(nums1, nums2), key=sum)[:k]", "def kSmallestPairs(self, nums1, nums2, k):\\n        return sorted(itertools.product(nums1, nums2), key=sum)[:k]", "def kSmallestPairs(self, nums1, nums2, k):\\n        return sorted(itertools.product(nums1, nums2), key=sum)[:k]"]}
{"id": "778", "ref_py": ["def getMoneyAmount(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        starting_index = 1 if n % 2 == 0 else 2\\n        selected_nums = [i for i in range(starting_index, n, 2)]\\n        selected_nums_length = len(selected_nums)\\n        dp = [[0] * selected_nums_length for _ in range(selected_nums_length)]", "def getMoneyAmount(self, n):\\n        need = [[0] * (n+1) for _ in range(n+1)]\\n        for lo in range(n, 0, -1):\\n            for hi in range(lo+1, n+1):\\n                need[lo][hi] = min(x + max(need[lo][x-1], need[x+1][hi])\\n                                   for x in range(lo, hi))\\n        return need[1][n]", "def getMoneyAmount(self, n):\\n        need = [[0] * (n+1) for _ in range(n+1)]\\n        for lo in range(n, 0, -1):\\n            for hi in range(lo+1, n+1):\\n                need[lo][hi] = min(x + max(need[lo][x-1], need[x+1][hi])\\n                                   for x in range(lo, hi))\\n        return need[1][n]"]}
{"id": "779", "ref_py": ["def wiggleMaxLength(self, nums: List[int]) -> int:\\n        f = 1\\n        d = 1\\n        for i in range(1, len(nums)):\\n            if nums[i]>nums[i-1]:\\n                f = d+1\\n            elif nums[i] < nums[i-1]:\\n                d = f+1\\n        res = max(f, d)\\n        return res\\n```", "def wiggleMaxLength(self, nums: List[int]) -> int:\\n        peak = valley = 0\\n        for i in range(1, len(nums)):\\n            ", "def wiggleMaxLength(self, nums: List[int]) -> int:\\n        peak = valley = 0\\n        for i in range(1, len(nums)):\\n            "]}
{"id": "780", "ref_py": ["def combinationSum4(self, nums, target):\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        \\n        return dp[target]\\n```\\nMethod -Memoization \\n`Time Complexity: O(n * target)`\\n`Space Complexity: O(target) `\\n`C++`\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums, int target,vector<int>& dp){\\n        int n=nums.size();\\n\\t\\t// Base case: If target is zero, we find the combination\\n        if(target==0) return 1; \\n        int ans=0; \\n\\t\\t\\n        if(dp[target]!=-1) return dp[target];   // To avoid redundant calculations.\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=target){ // Check if the current element can contribute to the target sum.\\n                ans+=help(nums, target-nums[i],dp); // Recursively explore subproblem with reduced target.\\n            }\\n        }\\n        dp[target]= ans; // Store the result in dp.\\n        return dp[target]; // Return the total no of valid combination.\\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1); //create Dp", "def combinationSum4(self, nums, target):\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        \\n        return dp[target]\\n```\\nMethod -Memoization \\n`Time Complexity: O(n * target)`\\n`Space Complexity: O(target) `\\n`C++`\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums, int target,vector<int>& dp){\\n        int n=nums.size();\\n\\t\\t// Base case: If target is zero, we find the combination\\n        if(target==0) return 1; \\n        int ans=0; \\n\\t\\t\\n        if(dp[target]!=-1) return dp[target];   // To avoid redundant calculations.\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=target){ // Check if the current element can contribute to the target sum.\\n                ans+=help(nums, target-nums[i],dp); // Recursively explore subproblem with reduced target.\\n            }\\n        }\\n        dp[target]= ans; // Store the result in dp.\\n        return dp[target]; // Return the total no of valid combination.\\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1); //create Dp", "def combinationSum4(self, nums, target):\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        \\n        return dp[target]\\n```\\nMethod -Memoization \\n`Time Complexity: O(n * target)`\\n`Space Complexity: O(target) `\\n`C++`\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums, int target,vector<int>& dp){\\n        int n=nums.size();\\n\\t\\t// Base case: If target is zero, we find the combination\\n        if(target==0) return 1; \\n        int ans=0; \\n\\t\\t\\n        if(dp[target]!=-1) return dp[target];   // To avoid redundant calculations.\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=target){ // Check if the current element can contribute to the target sum.\\n                ans+=help(nums, target-nums[i],dp); // Recursively explore subproblem with reduced target.\\n            }\\n        }\\n        dp[target]= ans; // Store the result in dp.\\n        return dp[target]; // Return the total no of valid combination.\\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1); //create Dp"]}
{"id": "781", "ref_py": ["def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        temp = []\\n        \\n        for row in matrix:\\n            temp.extend(row)\\n        temp.sort()\\n        return temp[k-1]\\n```", "def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        ", "def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        temp = []\\n        \\n        for row in matrix:\\n            temp.extend(row)\\n        temp.sort()\\n        return temp[k-1]\\n```"]}
{"id": "785", "ref_py": ["def deserialize(self, s: str) -> NestedInteger:\\n        \\n        def dfs(obj):\\n            if isinstance(obj, int):\\n                return NestedInteger(obj)", "def deserialize(self, s: str) -> NestedInteger:\\n    ", "def deserialize(self, s):\\n        def nestedInteger(x):\\n            if isinstance(x, int):\\n                return NestedInteger(x)\\n            lst = NestedInteger()\\n            for y in x:\\n                lst.add(nestedInteger(y))\\n            return lst\\n        return nestedInteger(eval(s))"]}
{"id": "786", "ref_py": ["def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        cur = 1\\n        for i in range(n):\\n            ", "def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []\\n        def helper(x):\\n            nonlocal ans\\n            for y in range(0, 10):\\n                new = (x*10)+y\\n                if new <= n and new > 0:\\n                    ans.append(new)\\n                    helper(new)\\n            \\n        helper(0)\\n        return ans\\n", "def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []"]}
{"id": "787", "ref_py": ["def lengthLongestPath(self, s: str) -> int:\\n        paths = s.split(\\'\\\\n\\')\\n        stack, ans = [0], 0 ", "def lengthLongestPath(self, input: str) -> int:\\n        input = input.split(\\'\\\\n\\')\\n        path, ans, total = [], 0, 0\\n        for line in input:\\n            tabs = line.count(\\'\\\\t\\')\\n            while len(path) > tabs: total -= path.pop()\\n            path.append(len(line) - tabs)\\n            total += path[-1]\\n            if \\'.\\' in line: ans = max(ans, total + len(path) - 1)\\n        return ans\\n```\\nThe basic idea is to create a stack containing the lengths of each of the path components along with a running total of the component lengths. Depth in the filepath is based on how many tab characters per line. ", "def lengthLongestPath(self, input: str) -> int:\\n        input = input.split(\\'\\\\n\\')\\n        path, ans, total = [], 0, 0\\n        for line in input:\\n            tabs = line.count(\\'\\\\t\\')\\n            while len(path) > tabs: total -= path.pop()\\n            path.append(len(line) - tabs)\\n            total += path[-1]\\n            if \\'.\\' in line: ans = max(ans, total + len(path) - 1)\\n        return ans\\n```\\nThe basic idea is to create a stack containing the lengths of each of the path components along with a running total of the component lengths. Depth in the filepath is based on how many tab characters per line. "]}
{"id": "788", "ref_py": ["def lastRemaining(self, n: int):\\n        if n%2: n = n-1  // 2k+1 will have the same answer as 2k\\n        if not n: return 1 // setting up the base case\\n        return n - 2*(self.lastRemaining(n//2)-1) // recursion step\\n", "def lastRemaining(self, n: int):\\n        if n%2: n = n-1  // 2k+1 will have the same answer as 2k\\n        if not n: return 1 // setting up the base case\\n        return n - 2*(self.lastRemaining(n//2)-1) // recursion step\\n", "def lastRemaining(self, n: int):\\n        if n%2: n = n-1  // 2k+1 will have the same answer as 2k\\n        if not n: return 1 // setting up the base case\\n        return n - 2*(self.lastRemaining(n//2)-1) // recursion step\\n"]}
{"id": "789", "ref_py": ["def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        i = 0\\n        \\n        while i < n:\\n            valid_encoding = False\\n            if self.one_byte_encoding(data[i]):\\n                i += 1\\n                valid_encoding = True\\n            \\n            for byte_len in range(2, 4 + 1):\\n                if self.byte_encoding(byte_len, data, i):\\n                    i += byte_len\\n                    valid_encoding = True\\n                    break\\n            \\n            if not valid_encoding:\\n                return False\\n        return True\\n    \\n    def one_byte_encoding(self, number: int):\\n\\t\\t", "def validUtf8(self, data: List[int]) -> bool:\\n        data_len = len(data)\\n        i = 0\\n        while i < data_len:\\n            num = data[i]\\n            num_binary = \\'{0:08b}\\'.format(num)\\n            \\n\\t\\t\\t", "def validUtf8(self, data: List[int]) -> bool:\\n        data_len = len(data)\\n        i = 0\\n        while i < data_len:\\n            num = data[i]\\n            num_binary = \\'{0:08b}\\'.format(num)\\n            \\n\\t\\t\\t"]}
{"id": "790", "ref_py": ["def decodeString(self, s: str) -> str:\\n        ", "def decodeString(self, s: str) -> str:\\n        ", "def decodeString(self, s: str) -> str:\\n        "]}
{"id": "791", "ref_py": ["def longestSubstring(self, s: str, k: int) -> int:\\n        ", "def longestSubstring(self, s: str, k: int) -> int:\\n        if k > len(s):\\n            return 0\\n                \\n        freq = {}\\n        for i, ch in enumerate(s):\\n            if ch not in freq:\\n                freq[ch] = 0\\n            freq[ch] += 1\\n        \\n        longSubstring = 0\\n        start = 0\\n        invalidSubstring = False\\n        for end in range(len(s)):\\n            if freq[s[end]] < k:\\n                longSubstring = max(longSubstring, self.longestSubstring(s[start:end], k))\\n                start = end+1\\n                invalidSubstring = True\\n        \\n        if not invalidSubstring:\\n            return len(s)\\n        else:\\n            return max(longSubstring, self.longestSubstring(s[start:], k))\\n```", "def longestSubstring(self, s: str, k: int) -> int:\\n        N = len(s)\\n        \\n        char_freq = Counter(s)\\n        \\n        max_len = 0\\n        for max_allowed_unique_chars in range(1, len(char_freq.keys()) + 1):\\n            char_freq = defaultdict(int)\\n            \\n            current_unique_chars = 0\\n            start = 0\\n            for end in range(N):\\n\\t\\t\\t\\t"]}
{"id": "792", "ref_py": ["def maxRotateFunction(self, nums: List[int]) -> int:\\n        F = 0\\n        S = 0\\n        for i in range(len(nums)):\\n            F = F + (nums[i] * i)\\n            S = S + nums[i]", "def maxRotateFunction(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        total_sum = sum(nums)  ", "def maxRotateFunction(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        total_sum = sum(nums)  "]}
{"id": "793", "ref_py": ["def integerReplacement(self, n: int) -> int:\\n        ", "def integerReplacement(self, n: int) -> int:\\n        ", "def integerReplacement(self, n: int) -> int:\\n        "]}
{"id": "795", "ref_py": ["defaultdict(dict) G` to build a weighted graph and `G[x][y]` will be the weight of edge `x->y` which is the value of `x / y`", "defaultdict.", "defaultdict."]}
{"id": "796", "ref_py": ["def findNthDigit(self, n: int) -> int:\\n        ", "def findNthDigit(self, n: int) -> int:\\n        if n <= 9:  ", "def findNthDigit(self, n: int) -> int:\\n\\ttemp = 0\\n\\ti = 1\\n\\twhile(temp + i*(10**i - 10**(i-1)) < n):\\n\\t\\ttemp += i*(10**i - 10**(i-1))\\n\\t\\ti += 1\\n\\td = i\\n\\tn -= temp\\n\\tnum = n//d\\n\\tdone = str(10**(d-1)-1 + num + int(n%d > 0))\\n\\tif(n % d):\\n\\t\\treturn done[n%d - 1]\\n"]}
{"id": "797", "ref_py": ["def removeKdigits(self, num: str, k: int) -> str:\\n        stack = []  ", "def removeKdigits(self, num, k):\\n        stack = []\\n        for c in num:\\n            while stack and k>0 and stack[-1] > c:\\n                stack.pop()\\n                k -= 1\\n            stack.append(c)\\n        while stack and k>0:\\n            stack.pop()\\n            k -= 1\\n        if not stack:\\n            return \"0\"\\n        return str(int(\"\".join(stack)))\\n```", "def removeKdigits(self, num: str, k: int) -> str:\\n        stack = []  "]}
{"id": "798", "ref_py": ["def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\\n        \\n        queue = [[-1,-1]]*len(people)\\n        people.sort()\\n        \\n        for i,j in people: \\n            \\n            greater_ele = 0\\n            place_pos = 0\\n                        \\n            while greater_ele<j:\\n                if queue[ place_pos ][0] >= i or queue[ place_pos ][0] == -1:\\n                    place_pos += 1\\n                    greater_ele += 1\\n                else:\\n                    place_pos += 1\\n            \\n            while queue[place_pos][0] != -1:\\n                place_pos+=1\\n            \\n            queue[ place_pos ] = [i,j]\\n        \\n        return queue\\n```\\n![image](https://assets.leetcode.com/users/images/d8dfb974-1ce0-4bb0-8e86-b700cf2ca113_1656465042.3333626.jpeg)", "def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\\n        people.sort(key=lambda person: (-person[0], person[1]))\\n        ans = []\\n        for person in people:\\n            ans.insert(person[1], person)\\n        return ans\\n```", "def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\\n        output=[] \\n        \\n        "]}
{"id": "799", "ref_py": ["def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        le=len(A)\\n        l=[0]*(le)\\n        for i in range(2,le):\\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\\n                l[i]=1+l[i-1]\\n        return sum(l)", "def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        le=len(A)\\n        l=[0]*(le)\\n        for i in range(2,le):\\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\\n                l[i]=1+l[i-1]\\n        return sum(l)", "def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        le=len(A)\\n        l=[0]*(le)\\n        for i in range(2,le):\\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\\n                l[i]=1+l[i-1]\\n        return sum(l)"]}
{"id": "800", "ref_py": ["def canPartition(a, index, target):\\n        ", "def canPartition(self, arr: List[int]) -> bool:\\n        def solve(ind,target):\\n            if target==0:\\n                return True\\n            if ind==0:\\n                return arr[ind]==target\\n            if dp[ind][target]!=-1:\\n                return dp[ind][target]\\n            not_pick=solve(ind-1,target)\\n            pick=False\\n            if target>=arr[ind]:\\n                pick=solve(ind-1,target-arr[ind])\\n            dp[ind][target]=pick or not_pick\\n            return dp[ind][target]\\n        s=sum(arr)\\n        if s%2!=0:\\n            return False\\n        s//=2\\n        n=len(arr)\\n        dp=[[-1 for j in range(s+1)] for i in range(n)]\\n        return solve(n-1,s)", "def canPartition(self, nums: List[int]) -> bool:\\n        "]}
{"id": "801", "ref_py": ["def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        flow = [[1]*n for _ in range(m)]", "def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        flow = [[1]*n for _ in range(m)]", "def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        flow = [[1]*n for _ in range(m)]"]}
{"id": "802", "ref_py": ["def countBattleships(self, board: List[List[str]]) -> int:\\n        count = 0\\n        \\n        for i, row in enumerate(board):\\n            for j, cell in enumerate(row):\\n                if cell == \"X\":\\n                    if (i == 0 or board[i - 1][j] == \".\") and\\\\\\n                       (j == 0 or board[i][j - 1] == \".\"):\\n                            count += 1\\n                            \\n        return count\\n```", "def countBattleships(self, board: List[List[str]]) -> int:\\n    count = 0\\n    ", "def countBattleships(self, board: List[List[str]]) -> int:\\n        count = 0\\n        \\n        for i, row in enumerate(board):\\n            for j, cell in enumerate(row):\\n                if cell == \"X\":\\n                    if (i == 0 or board[i - 1][j] == \".\") and\\\\\\n                       (j == 0 or board[i][j - 1] == \".\"):\\n                            count += 1\\n                            \\n        return count\\n```"]}
{"id": "803", "ref_py": ["def findMaximumXOR(self, nums: List[int]) -> int:\\n        \"\"\"\\n        let ni and nj be the numbers such that xor between them produces maximum\\n        value among other pairs. let m be the max value.", "def findMaximumXOR(self, nums: List[int]) -> int:\\n    maxNum = max(nums)\\n    if maxNum == 0:\\n      return 0\\n    maxBit = int(math.log2(maxNum))\\n    ans = 0\\n    mask = 0", "def findMaximumXOR(self, nums: List[int]) -> int:\\n        \"\"\"\\n        let ni and nj be the numbers such that xor between them produces maximum\\n        value among other pairs. let m be the max value."]}
{"id": "804", "ref_py": ["default value of 0 to update the counts of digits 0, 2, 4, 6, and 8 in digit_counts based on the counts of their corresponding characters \\'z\\', \\'w\\', \\'u\\', \\'x\\', and \\'g\\' in char_counts.\\n6. Calculate the count of digit 1 in digit_counts by subtracting the counts of digits 0, 2, and 4 from the count of character \\'o\\' in char_counts.\\n7. Calculate the count of digit 3 in digit_counts by subtracting the count of digit 8 from the count of character \\'h\\' in char_counts.\\n8. Calculate the count of digit 5 in digit_counts by subtracting the count of digit 4 from the count of character \\'f\\' in char_counts.\\n9. Calculate the count of digit 7 in digit_counts by subtracting the count of digit 6 from the count of character \\'s\\' in char_counts.\\n10. Calculate the count of digit 9 in digit_counts by subtracting the counts of digits 5, 6, and 8 from the count of character \\'i\\' in char_counts.\\n11. Use a list comprehension to create a string that concatenates the digits in digit_counts based on their counts. Return this string as the final output.", "def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```", "def originalDigits(self, s: str) -> str:"]}
{"id": "805", "ref_py": ["def characterReplacement(self, s: str, k: int) -> int:\\n        \\n        l = 0\\n        c_frequency = {}\\n        longest_str_len = 0\\n        for r in range(len(s)):\\n            \\n            if not s[r] in c_frequency:\\n                c_frequency[s[r]] = 0\\n            c_frequency[s[r]] += 1\\n            \\n            ", "def characterReplacement(self, s: str, k: int) -> int:\\n        res = 0\\n        l=0\\n        count = {}\\n        for r in range(len(s)):\\n            count[s[r]] = 1 + count.get(s[r],0)", "def characterReplacement(self, s: str, k: int) -> int:\\n        res = 0\\n        l=0\\n        count = {}\\n        for r in range(len(s)):\\n            count[s[r]] = 1 + count.get(s[r],0)"]}
{"id": "807", "ref_py": ["def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result", "def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result", "def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result"]}
{"id": "809", "ref_py": ["def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```", "def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```", "def moveZeroes(self, nums):\\n        n = len(nums)\\n        i = 0\\n        for j in range(n):\\n            if (nums[j] != 0):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n```"]}
{"id": "810", "ref_py": ["def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        @cache\\n        def dfs(idx):\\n            if idx==len(intervals):\\n                return 0", "def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda interval: interval[1])\\n        end = intervals[0][1]\\n        count = len(intervals) - 1\\n        for i in range(1, len(intervals)):\\n            if intervals[i][0] >= end:\\n                end = intervals[i][1]\\n                count -= 1\\n        return count", "def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])        \\n        ans = 0\\n        endTime = -60000\\n        for interval in intervals:\\n            if interval[0] < endTime:\\n                ans += 1\\n            else:\\n                endTime = interval[1]  \\n        return ans"]}
{"id": "811", "ref_py": ["def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        N = len(intervals)\\n        res = [-1] * N\\n        intervals = sorted([(s,e,i) for i,(s,e) in enumerate(intervals)])\\n        intervals.append((float(inf), float(inf), -1))\\n        for idx in range(N):\\n            s1,e1,i1 = intervals[idx]\\n            left = 0\\n            right = N\\n            while left < right:\\n                mid = (left + right) // 2\\n                s2,e2,i2 = intervals[mid]\\n                if s2 >= e1:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            res[i1] = intervals[left][2]\\n        return res\\n```\\nOR\\n```\\nclass Solution:\\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        N = len(intervals)\\n        intervals = sorted([(s,e,i) for i,(s,e) in enumerate(intervals)])\\n        intervals.append((float(inf), float(inf), -1)) ", "def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        ", "def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        "]}
{"id": "812", "ref_py": ["def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        self.count = 0\\n        self.prefix_sum = {0: 1}\\n        self.dfs(root, targetSum, 0)\\n        return self.count\\n        \\n    def dfs(self, node: TreeNode, targetSum: int, curr_sum: int) -> None:\\n        if not node:\\n            return\\n        \\n        curr_sum += node.val\\n        self.count += self.prefix_sum.get(curr_sum - targetSum, 0)\\n        self.prefix_sum[curr_sum] = self.prefix_sum.get(curr_sum, 0) + 1\\n        \\n        self.dfs(node.left, targetSum, curr_sum)\\n        self.dfs(node.right, targetSum, curr_sum)\\n        \\n        self.prefix_sum[curr_sum] -= 1", "def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:", "def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        self.count = 0\\n        self.prefix_sum = {0: 1}\\n        self.dfs(root, targetSum, 0)\\n        return self.count\\n        \\n    def dfs(self, node: TreeNode, targetSum: int, curr_sum: int) -> None:\\n        if not node:\\n            return\\n        \\n        curr_sum += node.val\\n        self.count += self.prefix_sum.get(curr_sum - targetSum, 0)\\n        self.prefix_sum[curr_sum] = self.prefix_sum.get(curr_sum, 0) + 1\\n        \\n        self.dfs(node.left, targetSum, curr_sum)\\n        self.dfs(node.right, targetSum, curr_sum)\\n        \\n        self.prefix_sum[curr_sum] -= 1"]}
{"id": "813", "ref_py": ["def findAnagrams(self, s: str, p: str) -> List[int]:\\n        res = []\\n        \\n        ", "def findAnagrams(self, s2: str, s1: str) -> list[int]:\\n        n1, n2 = len(s1), len(s2)\\n        c1, c2 = Counter(s1), Counter(islice(s2, n1))\\n        \\n        eq_count = sum(c1[ch] == c2[ch] for ch in c1)", "def findAnagrams(self, s2: str, s1: str) -> list[int]:\\n        n1, n2 = len(s1), len(s2)\\n        c1, c2 = Counter(s1), Counter(islice(s2, n1))\\n        \\n        eq_count = sum(c1[ch] == c2[ch] for ch in c1)"]}
{"id": "814", "ref_py": ["def findDuplicates(self, nums: List[int]) -> List[int]:\\n        output = []\\n        \\n        for num in nums:\\n            if nums[abs(num) - 1] < 0:\\n                output.append(abs(num))\\n            else:\\n                nums[abs(num) - 1] *= -1\\n        return output\\n```", "def findDuplicates(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        d={}\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                l.append(nums[i])\\n            d[nums[i]]=1\\n        return l\\n```", "def findDuplicates(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        d={}\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                l.append(nums[i])\\n            d[nums[i]]=1\\n        return l\\n```"]}
{"id": "815", "ref_py": ["def compress(self, chars: list[str]) -> int:\\n        iter_len = lambda xs: sum(1 for _ in xs)\\n        \\n        ch_counts = ((ch, iter_len(g)) for ch, g in groupby(chars))\\n        compressed = chain.from_iterable(ch + str(n) if n > 1 else ch for ch, n in ch_counts)", "def compress(self, chars):\\n        n = len(chars)\\n        if n == 1:\\n            return 1\\n        \\n        write_idx = 0\\n        curr_idx = 0\\n        while curr_idx < n:\\n            curr_char = chars[curr_idx]\\n            cnt = 0\\n            while curr_idx < n and chars[curr_idx] == curr_char:\\n                curr_idx += 1\\n                cnt += 1\\n            chars[write_idx] = curr_char\\n            write_idx += 1\\n            if cnt > 1:\\n                cnt_str = str(cnt)\\n                for i in range(len(cnt_str)):\\n                    chars[write_idx] = cnt_str[i]\\n                    write_idx += 1\\n        \\n        return write_idx", "def compress(self, chars: list[str]) -> int:\\n        iter_len = lambda xs: sum(1 for _ in xs)\\n        \\n        ch_counts = ((ch, iter_len(g)) for ch, g in groupby(chars))\\n        compressed = chain.from_iterable(ch + str(n) if n > 1 else ch for ch, n in ch_counts)"]}
{"id": "816", "ref_py": ["def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        def to_int(ll: ListNode) -> int:\\n            n = 0\\n            while ll: n = n * 10 + ll.val; ll = ll.next\\n            return n\\n        \\n        def to_LL(n: int) -> ListNode:\\n            ll = None\\n            while n: n, val = divmod(n, 10); ll = ListNode(val, ll)\\n            return ll or ListNode()\\n        \\n        return to_LL(to_int(l1) + to_int(l2))", "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        ", "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        "]}
{"id": "817", "ref_py": ["def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        def distance(p1, p2):\\n            x1, y1 = p1 \\n            x2, y2 = p2", "defaultdict called distances to keep track of the number of points that are a certain distance away from p1.\\n5. Iterate through each point, p2, in the points list.\\n6. If p1 is the same as p2, continue to the next iteration of the loop.\\n7. Calculate the squared distance between p1 and p2.\\n8. Increment the value in distances corresponding to the squared distance by 1.\\n9. Iterate through each value in distances.\\n10. For each value dist in distances, calculate the number of boomerangs that can be formed with p1 as the center point and dist as the distance.\\n11. Add the number of boomerangs calculated in step 10 to boomerangs.\\n12. Return the final value of boomerangs.", "def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        def distance(p1, p2):\\n            x1, y1 = p1 \\n            x2, y2 = p2"]}
{"id": "819", "ref_py": ["def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        \\n        ", "def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n\\tif not root:\\n\\t\\treturn None", "def getLeftMostNode(self, node):\\n        temp = node\\n        while temp.left is not None:\\n            temp = temp.left\\n        return temp\\n        \\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return root\\n        \\n        "]}
{"id": "820", "ref_py": ["def frequencySort(self, s: str) -> str:\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char,0) + 1", "def frequencySort(self, s: str) -> str:\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char,0) + 1", "def frequencySort(self, s: str) -> str:\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char,0) + 1"]}
{"id": "821", "ref_py": ["def findMinArrowShots(self, segments):\\n        segments.sort(key=lambda p: p[1])\\n        ans, arrow = 0, 0\\n        for [start, end] in segments:\\n            if ans == 0 or start > arrow:\\n                ans, arrow = ans + 1, end\\n        return ans\\n```", "def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n        points.sort(key=lambda p: p[1])\\n        arrows = 1", "def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n        points.sort(key=lambda p: p[1])\\n        arrows = 1"]}
{"id": "822", "ref_py": ["defined by incrementing any `n - 1` elements in `nums` by 1, where `n` is the number of elements in `nums`. This can be re-written to incrementing **all elements but one** in `nums` by 1.", "def minMoves(self, nums: List[int]) -> int:\\n        ", "def minMoves(self, nums: List[int]) -> int:\\n        "]}
{"id": "823", "ref_py": ["def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        ", "def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        ", "def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        "]}
{"id": "824", "ref_py": ["def find132pattern(self, nums: List[int]) -> bool:\\n        length = len(nums)", "def find132pattern(self, nums: List[int]) -> bool:\\n        stack=[]\\n        curMin=nums[0]\\n        for num in nums:\\n            while stack and num>=stack[-1][0]:\\n                stack.pop()", "def find132pattern(self, nums: List[int]) -> bool:\\n        length = len(nums)"]}
{"id": "825", "ref_py": ["def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return False", "def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return False", "def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return False"]}
{"id": "826", "ref_py": ["def minMoves2(self, nums):\\n        n = len (nums)\\n        mid = sorted (nums) [n // 2]\\n        res = sum (abs (i - mid) for i in nums)\\n        return res\\n```", "definition, so we can ignore the first and last value. Then we can continue this process and are left with the median value.", "def minMoves2(self, nums):\\n        n = len (nums)\\n        mid = sorted (nums) [n // 2]\\n        res = sum (abs (i - mid) for i in nums)\\n        return res\\n```"]}
{"id": "827", "ref_py": ["def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \\n        has_used = lambda flag, x: flag & (1<<x)\\n        is_odd = lambda x: x % 2 == 1\\n        \\n        ", "def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n    ", "def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n    "]}
{"id": "828", "ref_py": ["def findSubstringInWraproundString(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        count = {}\\n        curr_count = 0\\n        max_len = 1\\n        prev = s[0]\\n        \\n        for i in range(len(s)):\\n            if ord(s[i]) - ord(prev) == 1 or ord(prev) - ord(s[i]) == 25:\\n                max_len += 1\\n            else:\\n                max_len = 1\\n            \\n            if max_len >= curr_count:\\n                curr_count = max_len\\n            else:\\n                curr_count = 1\\n            \\n            count[s[i]] = max(count.get(s[i], 0), curr_count)\\n            \\n            prev = s[i]\\n        \\n        return sum(count.values())", "def findSubstringInWraproundString(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        count = {}\\n        curr_count = 0\\n        max_len = 1\\n        prev = s[0]\\n        \\n        for i in range(len(s)):\\n            if ord(s[i]) - ord(prev) == 1 or ord(prev) - ord(s[i]) == 25:\\n                max_len += 1\\n            else:\\n                max_len = 1\\n            \\n            if max_len >= curr_count:\\n                curr_count = max_len\\n            else:\\n                curr_count = 1\\n            \\n            count[s[i]] = max(count.get(s[i], 0), curr_count)\\n            \\n            prev = s[i]\\n        \\n        return sum(count.values())", "def findSubstringInWraproundString(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        count = {}\\n        curr_count = 0\\n        max_len = 1\\n        prev = s[0]\\n        \\n        for i in range(len(s)):\\n            if ord(s[i]) - ord(prev) == 1 or ord(prev) - ord(s[i]) == 25:\\n                max_len += 1\\n            else:\\n                max_len = 1\\n            \\n            if max_len >= curr_count:\\n                curr_count = max_len\\n            else:\\n                curr_count = 1\\n            \\n            count[s[i]] = max(count.get(s[i], 0), curr_count)\\n            \\n            prev = s[i]\\n        \\n        return sum(count.values())"]}
{"id": "829", "ref_py": ["def validIPAddress(self, IP: str) -> str:\\n        if \".\" in IP:\\n            segments = IP.split(\".\")\\n            if len(segments) != 4:\\n                return \"Neither\"\\n            for segment in segments:\\n                if not segment.isdigit() or not 0 <= int(segment) <= 255 or (segment[0] == \"0\" and len(segment) > 1):\\n                    return \"Neither\"\\n            return \"IPv4\"\\n        elif \":\" in IP:\\n            segments = IP.split(\":\")\\n            if len(segments) != 8:\\n                return \"Neither\"\\n            for segment in segments:\\n                if not segment or len(segment) > 4 or not all(c in string.hexdigits for c in segment):\\n                    return \"Neither\"\\n            return \"IPv6\"\\n        return \"Neither\"", "def validIPAddress(self, queryIP: str) -> str:\\n        new_string = queryIP.replace(\":\" , \".\")\\n        formatted_string = new_string.split(\".\")\\n        res = \"Neither\"\\n        if len(formatted_string) == 4 or len(formatted_string) == 8:\\n            if len(formatted_string) == 4:\\n                for item in formatted_string:\\n                    for character in item:\\n                        if not character.isdigit():\\n                            return \"Neither\"\\n                    if len(item) == 0 or len(item) > 3 or int(item) >255 or (len(item)!=1 and item[0] == \"0\"):\\n                        return \"Neither\"\\n                res = \"IPv4\"", "def validIPAddress(self, queryIP: str) -> str:\\n        new_string = queryIP.replace(\":\" , \".\")\\n        formatted_string = new_string.split(\".\")\\n        res = \"Neither\"\\n        if len(formatted_string) == 4 or len(formatted_string) == 8:\\n            if len(formatted_string) == 4:\\n                for item in formatted_string:\\n                    for character in item:\\n                        if not character.isdigit():\\n                            return \"Neither\"\\n                    if len(item) == 0 or len(item) > 3 or int(item) >255 or (len(item)!=1 and item[0] == \"0\"):\\n                        return \"Neither\"\\n                res = \"IPv4\""]}
{"id": "830", "ref_py": ["definitely until a suitable random number is generated.\\n3. Within the loop, use the rand7() function twice to generate a random number num in the range [1, 49].\\n4. Check if num is within the range [1, 40]. If not, continue to the next iteration of the while loop.\\n5. If num is within the range [1, 40], exit the while loop and return a value between 1 and 10.\\n6. To obtain the random integer within the range [1, 10], use the modulus operator to find the remainder of dividing num by 10 and add 1 to the result.", "def rand10(self):", "defined for you.\\n"]}
{"id": "831", "ref_py": ["def makesquare(self, matchsticks: List[int]) -> bool:\\n        \\n        s = sum(matchsticks)\\n        n = len(matchsticks)\\n        if s % 4 != 0 :   ", "def makesquare(self, matchsticks: List[int]) -> bool:\\n\\t\\t\\t\\ttotal = sum(matchsticks)\\n\\t\\t\\t\\tif total % 4:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttarget = total >> 2\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tfor n in matchsticks:\\n\\t\\t\\t\\t\\tif n > target:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telif n < target:\\n\\t\\t\\t\\t\\t\\tnums.append(n)", "def makesquare(self, matchsticks: List[int]) -> bool:\\n        value = sum(matchsticks)\\n        if value < 4:\\n            return False\\n        if value % 4 != 0:\\n            return False\\n        edge = value // 4\\n        matchsticks.sort(reverse=True)\\n        @cache\\n        def findedges(l1, l2, l3, l4, i):\\n            nonlocal edge\\n            if l1 == l2 == l3 == l4 == edge:\\n                return True\\n            if i > len(matchsticks) - 1:\\n                return False\\n            if l1 > edge or l2 > edge or l3 > edge or l4 > edge:\\n                return False\\n            return findedges(l1 + matchsticks[i], l2, l3, l4, i + 1) or findedges(l1, l2 + matchsticks[i] , l3, l4, i + 1) or findedges(l1, l2, l3 + matchsticks[i], l4, i + 1) or findedges(l1, l2, l3, l4 + matchsticks[i] , i + 1)\\n        return findedges(0, 0, 0, 0, 0)\\n                \\n```"]}
{"id": "832", "ref_py": ["def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        counter=[[s.count(\"0\"), s.count(\"1\")] for s in strs]\\n        \\n        @cache\\n        def dp(i,j,idx):\\n            if i<0 or j<0:\\n                return -math.inf\\n            \\n            if idx==len(strs):\\n                return 0\\n            \\n            return max(dp(i,j,idx+1), 1 + dp(i-counter[idx][0], j-counter[idx][1], idx+1))\\n        return dp(m,n,0)\\n```", "def findMaxForm(self, S: List[str], M: int, N: int) -> int:\\n        dp = [[0 for _ in range(N+1)] for _ in range(M+1)]\\n        for str in S:\\n            zeros = str.count(\"0\")\\n            ones = len(str) - zeros\\n            for i in range(M, zeros - 1, -1):\\n                for j in range(N, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\\n        return dp[M][N]\\n```", "defined by the number of 0s and 1s allowed in the subset. dp[i][j] represents the maximum number of strings that can be selected using i 0s and j 1s."]}
{"id": "833", "ref_py": ["def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        ", "def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n\\tdef isValid(rad):\\n\\t\\th = 0\\n\\t\\ti = 0\\n\\t\\twhile(i < len(houses)):\\n\\t\\t\\tif(abs(houses[i] - heaters[h]) <= rad):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\tif(h == len(heaters)):\\n\\t\\t\\t\\treturn 0\\n\\t\\treturn 1\\n\\thouses.sort()\\n\\theaters.sort()\\n\\ti, j = 0, 1000000000\\n\\tans = 0\\n\\twhile(i <= j):\\n\\t\\tmid = i+(j-i)//2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n", "def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n\\tdef isValid(rad):\\n\\t\\th = 0\\n\\t\\ti = 0\\n\\t\\twhile(i < len(houses)):\\n\\t\\t\\tif(abs(houses[i] - heaters[h]) <= rad):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\tif(h == len(heaters)):\\n\\t\\t\\t\\treturn 0\\n\\t\\treturn 1\\n\\thouses.sort()\\n\\theaters.sort()\\n\\ti, j = 0, 1000000000\\n\\tans = 0\\n\\twhile(i <= j):\\n\\t\\tmid = i+(j-i)//2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n"]}
{"id": "834", "ref_py": ["def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result", "def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result", "def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result"]}
{"id": "836", "ref_py": ["def magicalString(self, n):\\n        s = [1, 2, 2]\\n        for i in range(2, int(0.667*n)+2):\\n            s += [i % 2 + 1] * s[i]\\n        return s[:n].count(1)\\n```", "def magicalString(self, n):\\n        s = [1, 2, 2]\\n        for i in range(2, int(0.667*n)+2):\\n            s += [i % 2 + 1] * s[i]\\n        return s[:n].count(1)\\n```", "def magicalString(self, n):\\n        s = [1, 2, 2]\\n        for i in range(2, int(0.667*n)+2):\\n            s += [i % 2 + 1] * s[i]\\n        return s[:n].count(1)\\n```"]}
{"id": "837", "ref_py": ["define MAX_SIZE 23", "default.\\n2. Create a 2D array **`dp`**, where **`dp[i][j]`** represents the maximum score that the first player can get from the subarray **`nums[i:j]`**.\\n3. Iterate over different subarray lengths **`g`** starting from 0 to the length of the array (**`n`**). For each subarray length, iterate over all possible starting indices **`i`** and calculate the corresponding ending index **`j`** based on the subarray length.\\n4. If the subarray length (**`g`**) is 0, set **`dp[i][j]`** to the value of the element at index **`i`** in **`nums`**.\\n5. If the subarray length (**`g`**) is 1, set **`dp[i][j]`** to the maximum value between the elements at indices **`i`** and **`j`** in **`nums`**.\\n6. For subarray lengths greater than 1, calculate **`dp[i][j]`** using the following formula:\\n    \\n    ```\\n    dp[i][j] = max(nums[i] + min(dp[i+2][j], dp[i+1][j-1]), nums[j] + min(dp[i+1][j-1], dp[i][j-2]))\\n    \\n    ```\\n    \\n    This formula represents the optimal strategy for the first player: they can either choose the element at index **`i`** and leave the second player with the subarray **`nums[i+1:j]`**, or choose the element at index **`j`** and leave the second player with the subarray **`nums[i:j-1]`**.\\n    \\n7. After filling the **`dp`** array, calculate the sum of all elements in the original array **`nums`**, and store it in the variable **`sum`**.\\n8. The remaining sum after the first player\\'s optimal choices will be **`sum - dp[0][n-1]`**.\\n9. Finally, check if the remaining sum is greater than the maximum score **`dp[0][n-1]`**. If it is, return **`false`** as the first player cannot win the game with optimal play. Otherwise, return **`true`**\\n", "def PredictTheWinner(self, nums: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i <= j) and max(\\n                nums[i] - score(i + 1, j),\\n                nums[j] - score(i, j - 1),\\n            )\\n        \\n        return len(nums) % 2 == 0 or score(0, len(nums) - 1) >= 0"]}
{"id": "838", "ref_py": ["def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        ans = {}\\n        \\n        def rec(idx, arr):\\n            if len(arr) > 1: ans[tuple(arr)]= 1\\n                \\n            for i in range(idx, N):\\n                if nums[i] >= arr[-1]:\\n                    rec(i+1, arr+[nums[i]])\\n        \\n        for i in range(N): \\n            rec(i+1, [nums[i]])\\n            \\n        return ans.keys()\\n```\\n", "def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n    ans = []\\n    \\n    def dfs(start: int, path: List[int]) -> None:\\n      if len(path) > 1:\\n        ans.append(path[:])\\n      \\n      used = set()\\n      for i in range(start, len(nums)):\\n        if nums[i] in used:\\n          continue\\n        if not path or nums[i] >= path[-1]:\\n          used.add(nums[i])\\n          dfs(i + 1, path + [nums[i]])\\n    \\n    dfs(0, [])\\n    return ans", "def findSubsequences(self, nums: List[int]) -> List[List[int]]:\\n        N = len(nums)\\n        ans = {}\\n        \\n        def rec(idx, arr):\\n            if len(arr) > 1: ans[tuple(arr)]= 1\\n                \\n            for i in range(idx, N):\\n                if nums[i] >= arr[-1]:\\n                    rec(i+1, arr+[nums[i]])\\n        \\n        for i in range(N): \\n            rec(i+1, [nums[i]])\\n            \\n        return ans.keys()\\n```\\n"]}
{"id": "839", "ref_py": ["def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        if (sum(nums)+target)%2!=0 or sum(nums)+target<0:\\n            return 0\\n        target=(sum(nums)+target)//2\\n        prev=[0 for _ in range(target + 1)]\\n        curr=[0 for _ in range(target + 1)]\\n        \\n        prev[0] = 1\\n        ", "def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n    ", "def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        if (sum(nums)+target)%2!=0 or sum(nums)+target<0:\\n            return 0\\n        target=(sum(nums)+target)//2\\n        prev=[0 for _ in range(target + 1)]\\n        curr=[0 for _ in range(target + 1)]\\n        \\n        prev[0] = 1\\n        "]}
{"id": "841", "ref_py": ["def findDiagonalOrder(self, matrix):\\n        \\n        d={}\\n\\t\\t", "def findDiagonalOrder(self, matrix):\\n        \\n        d={}\\n\\t\\t", "def findDiagonalOrder(self, matrix):\\n        \\n        d={}\\n\\t\\t"]}
{"id": "842", "ref_py": ["def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        st = []\\n        ans = [-1] * n\\n        for i in xrange(n * 2 - 1, -1, -1):\\n            while st and st[-1] <= nums[i % n]:\\n                st.pop()\\n            if i < n:\\n                ans[i] = st[-1] if st else -1\\n            st.append(nums[i % n])\\n        return ans", "def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, L = [], len(nums)\\n        res = [-1] * L", "def nextGreaterElements(self, nums: List[int]) -> List[int]:\\n        stack, res = [], [-1] * len(nums) "]}
{"id": "843", "ref_py": ["def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:\\n        ", "def findFrequentTreeSum(self, root: TreeNode) -> List[int]:\\n        if not root: return []\\n        \\n        D = collections.defaultdict(int)\\n        ", "def findFrequentTreeSum(self, root: TreeNode) -> List[int]:\\n        if not root: return []\\n        \\n        D = collections.defaultdict(int)\\n        "]}
{"id": "844", "ref_py": ["def findBottomLeftValue(self, root: TreeNode) -> int:\\n        ", "def findBottomLeftValue(self, root: TreeNode) -> int:\\n        ", "def findBottomLeftValue(self, root: TreeNode) -> int:\\n        "]}
{"id": "845", "ref_py": ["def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        queue = deque([root])\\n        res = []", "def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        queue = deque([root])\\n        res = []", "def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        queue = deque([root])\\n        res = []"]}
{"id": "846", "ref_py": ["def longestPalindromeSubseq(self, s):\\n        n = len(s)\\n        dp = [[0]*n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            dp[i][i] = 1\\n            for j in range(i+1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = 2 + dp[i+1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n                    \\n        return dp[0][n-1]\\n```\\n```ruby []\\nclass Solution {\\npublic:\\n    int longestPalindromeSubseq(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            dp[i][i] = 1;\\n            for (int j = i+1; j < n; j++) {\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = 2 + dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n```", "def longestPalindromeSubseq(self, s):\\n        n = len(s)\\n        dp = [[0]*n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            dp[i][i] = 1\\n            for j in range(i+1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = 2 + dp[i+1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n                    \\n        return dp[0][n-1]\\n```\\n```ruby []\\nclass Solution {\\npublic:\\n    int longestPalindromeSubseq(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            dp[i][i] = 1;\\n            for (int j = i+1; j < n; j++) {\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = 2 + dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n```", "def longestPalindromeSubseq(self, s):\\n        n = len(s)\\n        dp = [[0]*n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            dp[i][i] = 1\\n            for j in range(i+1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = 2 + dp[i+1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n                    \\n        return dp[0][n-1]\\n```\\n```ruby []\\nclass Solution {\\npublic:\\n    int longestPalindromeSubseq(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            dp[i][i] = 1;\\n            for (int j = i+1; j < n; j++) {\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = 2 + dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n```"]}
{"id": "847", "ref_py": ["def change(self, value: int, arr: List[int]) -> int:\\n    \\n\\t\\n        prev=[0 for i in range(value+1)] \\n        curr=[0 for i in range(value+1)] \\n        for i in range(value+1):\\n            if i%arr[0]==0:\\n                prev[i]=1 \\n            else:\\n                prev[i]=0\\n        for i in range(1,len(arr)):\\n            for j in range(value+1):\\n                nottake=prev[j]\\n                take=0\\n                if j>=arr[i]:\\n                    take=curr[j-arr[i]]\\n                curr[j]=take+nottake \\n            prev=curr[:]\\n        return prev[value] \\n```", "def change(self, value: int, arr: List[int]) -> int:\\n    \\n\\t\\n        prev=[0 for i in range(value+1)] \\n        curr=[0 for i in range(value+1)] \\n        for i in range(value+1):\\n            if i%arr[0]==0:\\n                prev[i]=1 \\n            else:\\n                prev[i]=0\\n        for i in range(1,len(arr)):\\n            for j in range(value+1):\\n                nottake=prev[j]\\n                take=0\\n                if j>=arr[i]:\\n                    take=curr[j-arr[i]]\\n                curr[j]=take+nottake \\n            prev=curr[:]\\n        return prev[value] \\n```", "def change(self, value: int, arr: List[int]) -> int:\\n    \\n\\t\\n        prev=[0 for i in range(value+1)] \\n        curr=[0 for i in range(value+1)] \\n        for i in range(value+1):\\n            if i%arr[0]==0:\\n                prev[i]=1 \\n            else:\\n                prev[i]=0\\n        for i in range(1,len(arr)):\\n            for j in range(value+1):\\n                nottake=prev[j]\\n                take=0\\n                if j>=arr[i]:\\n                    take=curr[j-arr[i]]\\n                curr[j]=take+nottake \\n            prev=curr[:]\\n        return prev[value] \\n```"]}
{"id": "849", "ref_py": ["define a helper function isSubsequence(a: str, b: str) -> bool that returns True if string a is a subsequence of string b, and False otherwise. We do this by iterating through each character in b, and for each character that matches the current character in a, we move to the next character in a. If we\\'ve successfully matched all characters in a, then it is a subsequence of b.", "def findLUSlength(self, strs: List[str]) -> int:\\n\\tdef isSub(x, y):\\n\\t\\ti = j = 0\\n\\t\\twhile(i<len(x) and j<len(y)):\\n\\t\\t\\tif(x[i] == y[j]):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\treturn i == len(x)\\n\\tstrs.sort(key = len, reverse = True)\\n\\tn = len(strs)\\n\\tfor i in range(n):\\n\\t\\tp = 1\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(i != j and isSub(strs[i], strs[j])):\\n\\t\\t\\t\\tp = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tif(p):\\n\\t\\t\\treturn len(strs[i])\\n", "def findLUSlength(self, strs: List[str]) -> int:\\n\\tdef isSub(x, y):\\n\\t\\ti = j = 0\\n\\t\\twhile(i<len(x) and j<len(y)):\\n\\t\\t\\tif(x[i] == y[j]):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\treturn i == len(x)\\n\\tstrs.sort(key = len, reverse = True)\\n\\tn = len(strs)\\n\\tfor i in range(n):\\n\\t\\tp = 1\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(i != j and isSub(strs[i], strs[j])):\\n\\t\\t\\t\\tp = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tif(p):\\n\\t\\t\\treturn len(strs[i])\\n"]}
{"id": "850", "ref_py": ["def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        d , s = {0:-1} , 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                s = (s + n) % k\\n            else:\\n                s += n\\n            if s not in d:\\n                d[s] = i\\n            else:\\n                if i - d[s] >= 2:\\n                    return True\\n        return False\\n```", "def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        d , s = {0:-1} , 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                s = (s + n) % k\\n            else:\\n                s += n\\n            if s not in d:\\n                d[s] = i\\n            else:\\n                if i - d[s] >= 2:\\n                    return True\\n        return False\\n```", "def checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n        d , s = {0:-1} , 0\\n        for i, n in enumerate(nums):\\n            if k != 0:\\n                s = (s + n) % k\\n            else:\\n                s += n\\n            if s not in d:\\n                d[s] = i\\n            else:\\n                if i - d[s] >= 2:\\n                    return True\\n        return False\\n```"]}
{"id": "851", "ref_py": ["def findLongestWord(self, s: str, d: List[str]) -> str:\\n        ", "def findLongestWord(self, s: str, d: List[str]) -> str:\\n        ", "def findLongestWord(self, s: str, d: List[str]) -> str:\\n        "]}
{"id": "852", "ref_py": ["def findMaxLength(self, nums: List[int]) -> int:\\n        max_length =0\\n        hash={}\\n        count=0\\n        for i in range(len(nums)):\\n            current=nums[i]\\n            if current==0:\\n                count-=1 ", "def findMaxLength(self, nums):\\n      nums = list(accumulate([x * 2 - 1 for x in nums]))\\n      ind = defaultdict(list)\\n      ind[0] = [-1,-1]\\n      for i in range(len(nums)):\\n        if not ind[nums[i]]:\\n          ind[nums[i]] = [i,i]\\n        else:\\n          ind[nums[i]][1] = i\\n      \\n      max_len = 0\\n      for i in ind:\\n        max_len = max(max_len,ind[i][1]-ind[i][0])\\n      return max_len\\n```\\n", "def findMaxLength(self, nums):\\n      nums = list(accumulate([x * 2 - 1 for x in nums]))\\n      ind = defaultdict(list)\\n      ind[0] = [-1,-1]\\n      for i in range(len(nums)):\\n        if not ind[nums[i]]:\\n          ind[nums[i]] = [i,i]\\n        else:\\n          ind[nums[i]][1] = i\\n      \\n      max_len = 0\\n      for i in ind:\\n        max_len = max(max_len,ind[i][1]-ind[i][0])\\n      return max_len\\n```\\n"]}
{"id": "853", "ref_py": ["def countArrangement(self, n: int) -> int:\\n        ", "def countArrangement(self, n: int) -> int:\\n        \\n        nums = [i for i in range(1, n + 1)]\\n        i = 1\\n\\t\\tres = [0]\\n\\t\\t \\n        self.dfs(nums, res, 1, n)\\n        return res[0]\\n    \\n    def dfs(self, nums, res, i, n):\\n        \\n        if i == n + 1: \\n            res[0] += 1\\n            return", "def countArrangement(self, n: int) -> int:\\n        \\n        nums = [i for i in range(1, n + 1)]\\n        i = 1\\n\\t\\tres = [0]\\n\\t\\t \\n        self.dfs(nums, res, 1, n)\\n        return res[0]\\n    \\n    def dfs(self, nums, res, i, n):\\n        \\n        if i == n + 1: \\n            res[0] += 1\\n            return"]}
{"id": "855", "ref_py": ["def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\\n        ", "def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\\n        m, n = len(board), len(board[0])\\n        x, y = click", "def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\\n        m, n = len(board), len(board[0])\\n        x, y = click"]}
{"id": "856", "ref_py": ["def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        ", "def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        ", "def diffWaysToCompute(self, inputStr: str) -> List[int]:\\n        \\n        "]}
{"id": "858", "ref_py": ["def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        ", "def complexNumberMultiply(self, n1, n2):\\n        \\n        a1,b1=n1.split(\\'+\\')\\n        a1=int(a1)\\n        b1=int(b1[:-1])\\n        a2,b2=n2.split(\\'+\\')\\n        a2=int(a2)\\n        b2=int(b2[:-1])\\n        return str(a1*a2-b1*b2)+\\'+\\'+str(a1*b2+a2*b1)+\\'i\\'\\n```", "def complexNumberMultiply(self, n1, n2):\\n        \\n        a1,b1=n1.split(\\'+\\')\\n        a1=int(a1)\\n        b1=int(b1[:-1])\\n        a2,b2=n2.split(\\'+\\')\\n        a2=int(a2)\\n        b2=int(b2[:-1])\\n        return str(a1*a2-b1*b2)+\\'+\\'+str(a1*b2+a2*b1)+\\'i\\'\\n```"]}
{"id": "859", "ref_py": ["def convertBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tsum = 0\\n\\t\\t\\t\\n\\t\\t\\tdef sol(root: TreeNode) -> TreeNode:\\n\\t\\t\\t\\tnonlocal sum\\n\\t\\t\\t\\tif root:\\n\\t\\t\\t\\t\\tsol(root.right)\\n\\t\\t\\t\\t\\troot.val += sum\\n\\t\\t\\t\\t\\tsum = root.val\\n\\t\\t\\t\\t\\tsol(root.left)\\n\\t\\t\\t\\treturn root\\n\\t\\t\\t\\n", "def convertBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tsum = 0\\n\\t\\t\\t\\n\\t\\t\\tdef sol(root: TreeNode) -> TreeNode:\\n\\t\\t\\t\\tnonlocal sum\\n\\t\\t\\t\\tif root:\\n\\t\\t\\t\\t\\tsol(root.right)\\n\\t\\t\\t\\t\\troot.val += sum\\n\\t\\t\\t\\t\\tsum = root.val\\n\\t\\t\\t\\t\\tsol(root.left)\\n\\t\\t\\t\\treturn root\\n\\t\\t\\t\\n", "def convertBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tsum = 0\\n\\t\\t\\t\\n\\t\\t\\tdef sol(root: TreeNode) -> TreeNode:\\n\\t\\t\\t\\tnonlocal sum\\n\\t\\t\\t\\tif root:\\n\\t\\t\\t\\t\\tsol(root.right)\\n\\t\\t\\t\\t\\troot.val += sum\\n\\t\\t\\t\\t\\tsum = root.val\\n\\t\\t\\t\\t\\tsol(root.left)\\n\\t\\t\\t\\treturn root\\n\\t\\t\\t\\n"]}
{"id": "860", "ref_py": ["def findMinDifference(self, time: List[str]) -> int:\\n        for i in range(len(time)):\\n            time[i]=time[i].split(\\':\\')\\n            time[i]=[int(time[i][0]),int(time[i][1])]", "def findMinDifference(self, time: List[str]) -> int:\\n        for i in range(len(time)):\\n            time[i]=time[i].split(\\':\\')\\n            time[i]=[int(time[i][0]),int(time[i][1])]", "def findMinDifference(self, time: List[str]) -> int:\\n        for i in range(len(time)):\\n            time[i]=time[i].split(\\':\\')\\n            time[i]=[int(time[i][0]),int(time[i][1])]"]}
{"id": "861", "ref_py": ["def singleNonDuplicate(self, arr: List[int]) -> int:\\n        i = 0\\n        j = len(arr) - 1\\n        while i < j:\\n            m = (i+j) // 2\\n            if m < j and arr[m] == arr[m+1]:\\n                m = m + 1\\n            if arr[m] != arr[m-1] and arr[m] != arr[m+1]:\\n                return arr[m]\\n            elif abs(m-i) % 2 == 0:\\n                j = m - 1\\n            else:\\n                i = m + 1 \\n        return arr[i]", "def singleNonDuplicate(self, arr: List[int]) -> int:\\n        i = 0\\n        j = len(arr) - 1\\n        while i < j:\\n            m = (i+j) // 2\\n            if m < j and arr[m] == arr[m+1]:\\n                m = m + 1\\n            if arr[m] != arr[m-1] and arr[m] != arr[m+1]:\\n                return arr[m]\\n            elif abs(m-i) % 2 == 0:\\n                j = m - 1\\n            else:\\n                i = m + 1 \\n        return arr[i]", "def singleNonDuplicate(self, arr: List[int]) -> int:\\n        i = 0\\n        j = len(arr) - 1\\n        while i < j:\\n            m = (i+j) // 2\\n            if m < j and arr[m] == arr[m+1]:\\n                m = m + 1\\n            if arr[m] != arr[m-1] and arr[m] != arr[m+1]:\\n                return arr[m]\\n            elif abs(m-i) % 2 == 0:\\n                j = m - 1\\n            else:\\n                i = m + 1 \\n        return arr[i]"]}
{"id": "862", "ref_py": ["def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:\\n        m, n = len(mat), len(mat[0])\\n        dists = [[inf] * n for _ in range(m)]", "def updateMatrix(self, mat):\\n        n = len(mat)\\n        m = len(mat[0])", "def updateMatrix(self, A: List[List[int]]) -> List[List[int]]:\\n        n = len(A)\\n        m = len(A[0])\\n        \\n        if A[0][0] != 0:\\n            A[0][0] = m + n\\n        \\n        "]}
{"id": "863", "ref_py": ["def findCircleNum(self, is_connected: list[list[int]]) -> int:\\n        def visit_from(x: int, seen: set[int]) -> bool:\\n            return seen.add(x) or all(visit_from(y, seen) for y, c in enumerate(is_connected[x]) if y not in seen and c)", "def findCircleNum(self, isConnected: List[List[int]]) -> int:\\n        N = len(isConnected)\\n        adjList = defaultdict(list)\\n        for row in range(N):\\n            for col in range(row + 1, N):\\n                if isConnected[row][col] == 1:\\n                    adjList[row + 1].append(col + 1)\\n                    adjList[col + 1].append(row + 1)\\n        \\n        def dfs(city):\\n            if city in visited:\\n                return False", "def __init__(self, n):\\n        self.u = list(range(n))\\n        \\n    def union(self, a, b):\\n        ra, rb = self.find(a), self.find(b)\\n        if ra != rb: self.u[ra] = rb\\n    \\n    def find(self, a):\\n        while self.u[a] != a: a = self.u[a]\\n        return a\\n    \\nclass Solution(object):\\n    def findCircleNum(self, M):\\n        \\n        \\n        if not M: return 0\\n        s = len(M)\\n        \\n        uf = UnionFind(s)\\n        for r in range(s):\\n            for c in range(r,s):\\n                if M[r][c] == 1: uf.union(r,c)\\n                    \\n        return len(set([uf.find(i) for i in range(s)]))\\n```"]}
{"id": "865", "ref_py": ["def optimalDivision(self, nums: List[int]) -> str:\\n        if len(nums) == 1:\\n            return str(nums[0])\\n        elif len(nums) == 2:\\n            return str(nums[0]) + \\'/\\' + str(nums[1])\\n        else:\\n            nums_str = list(map(str, nums))\\n            return str(nums[0]) + \\'/(\\' + \\'/\\'.join(nums_str[1:]) + \\')\\'", "def optimalDivision(self, nums: List[int]) -> str:\\n        if len(nums) == 1:\\n            return str(nums[0])\\n        \\n        if len(nums) == 2:\\n            return str(nums[0]) + \\'/\\' + str(nums[1])", "def optimalDivision(self, nums: List[int]) -> str:\\n        if len(nums) == 1:\\n            return str(nums[0])\\n        elif len(nums) == 2:\\n            return str(nums[0]) + \\'/\\' + str(nums[1])\\n        else:\\n            nums_str = list(map(str, nums))\\n            return str(nums[0]) + \\'/(\\' + \\'/\\'.join(nums_str[1:]) + \\')\\'"]}
{"id": "866", "ref_py": ["def leastBricks(self, wall: List[List[int]]) -> int:\\n\\tedges, maxEdges = defaultdict(int), 0\\n\\tfor row in wall:\\n\\t\\tfor idx in accumulate(row[:-1]):\\n\\t\\t\\tedges[idx] += 1\\n\\t\\t\\tmaxEdges = max(maxEdges, edges[idx])\\n\\treturn len(wall) - maxEdges\\n```", "def leastBricks(self, wall: List[List[int]]) -> int:\\n\\tedges, maxEdges = defaultdict(int), 0\\n\\tfor row in wall:\\n\\t\\tfor idx in accumulate(row[:-1]):\\n\\t\\t\\tedges[idx] += 1\\n\\t\\t\\tmaxEdges = max(maxEdges, edges[idx])\\n\\treturn len(wall) - maxEdges\\n```", "defined as **[1,2,2,1]**, then the inside edges occur at **[1,1+2,1+2+2]**, or **[1,3,5]**."]}
{"id": "867", "ref_py": ["def nextGreaterElement(self, n: int) -> int:\\n        digits = list(map(int, str(n)))\\n        stack, L = [], len(digits)\\n        for i in reversed(range(L)):\\n            ", "def nextGreaterElement(self, n: int) -> int:\\n        nums = list(str(n))\\n        i = len(nums) - 1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:\\n            return -1\\n        j = len(nums) - 1\\n        while j > i-1 and nums[j] <= nums[i-1]:\\n            j -= 1\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        nums[i:] = nums[i:][::-1]\\n        res = int(\\'\\'.join(nums))\\n        return res if res < 2**31 else -1", "def nextGreaterElement(self, n: int) -> int:\\n        nums = list(str(n))\\n        i = len(nums) - 1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:\\n            return -1\\n        j = len(nums) - 1\\n        while j > i-1 and nums[j] <= nums[i-1]:\\n            j -= 1\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        nums[i:] = nums[i:][::-1]\\n        res = int(\\'\\'.join(nums))\\n        return res if res < 2**31 else -1"]}
{"id": "869", "ref_py": ["def subarraySum(self, nums: List[int], k: int) -> int:", "def subarraySum(self, nums: List[int], k: int) -> int:", "def subarraySum(self, nums: List[int], k: int) -> int:"]}
{"id": "870", "ref_py": ["def arrayNesting(self, nums: List[int]) -> int:\\n        visited = [False] * len(nums)  ", "def arrayNesting(self, nums):\\n        vis = set()", "def arrayNesting(self, nums: List[int]) -> int:\\n        visited = [False] * len(nums)  "]}
{"id": "871", "ref_py": ["def checkInclusion(self, s1: str, s2: str) -> bool:\\n        l1, l2 = len(s1), len(s2)\\n        if l1>l2: return False ", "def checkInclusion(self, s1: str, s2: str) -> bool:\\n        l1, l2 = len(s1), len(s2)\\n        if l1>l2: return False ", "def checkInclusion(self, s1: str, s2: str) -> bool:\\n        l1, l2 = len(s1), len(s2)\\n        if l1>l2: return False "]}
{"id": "873", "ref_py": ["def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:", "def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:\\n        mod = 10**9 + 7\\n        self.directions = [[0,-1],[0,1],[1,0],[-1,0]]\\n        \\n        @lru_cache(maxsize = None)\\n        def dfs(r,c,moves):\\n            default = 0\\n            for dr,dc in self.directions:\\n                nr,nc = r + dr, c + dc\\n                if nr < 0 or nc < 0 or nr >= m or nc >= n:\\n                    if moves > 0:\\n                        default = (default + 1) % mod\\n                    continue\\n                if moves > 1:\\n                    default = (default + dfs(nr,nc,moves-1)) % mod\\n            return default\\n        return dfs(startRow,startColumn,maxMove) % mod\\n```", "def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:"]}
{"id": "874", "ref_py": ["def findUnsortedSubarray(self, N: List[int]) -> int:\\n        lenN, left, right = len(N) - 1, -1, -1\\n        maxN, minN = N[0], N[lenN]\\n        for i in range(1, len(N)):\\n            a, b = N[i], N[lenN-i]\\n            if a < maxN: right = i\\n            else: maxN = a\\n            if b > minN: left = i\\n            else: minN = b\\n        return max(0, left + right - lenN + 1)\\n```", "def findUnsortedSubarray(self, N: List[int]) -> int:\\n        lenN, left, right = len(N) - 1, -1, -1\\n        maxN, minN = N[0], N[lenN]\\n        for i in range(1, len(N)):\\n            a, b = N[i], N[lenN-i]\\n            if a < maxN: right = i\\n            else: maxN = a\\n            if b > minN: left = i\\n            else: minN = b\\n        return max(0, left + right - lenN + 1)\\n```", "def findUnsortedSubarray(self, N: List[int]) -> int:\\n        lenN, left, right = len(N) - 1, -1, -1\\n        maxN, minN = N[0], N[lenN]\\n        for i in range(1, len(N)):\\n            a, b = N[i], N[lenN-i]\\n            if a < maxN: right = i\\n            else: maxN = a\\n            if b > minN: left = i\\n            else: minN = b\\n        return max(0, left + right - lenN + 1)\\n```"]}
{"id": "875", "ref_py": ["def minDistance(self, word1: str, word2: str) -> int:\\n        l1 = len(word1)\\n        l2 = len(word2)", "def minDistance(self, word1: str, word2: str) -> int:\\n        m,n=len(word1),len(word2)\\n        dp=[[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        k=dp[m][n] ", "def minDistance(self, word1: str, word2: str) -> int:\\n        m,n=len(word1),len(word2)\\n        dp=[[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        k=dp[m][n] "]}
{"id": "877", "ref_py": ["def fractionAddition(self, expression: str) -> str:\\n\\t\\t\\tresult_fraction = Fraction(0)", "def fractionAddition(self, expression: str) -> str:\\n        ", "def fractionAddition(self, expression: str) -> str:\\n\\t\\t\\tresult_fraction = Fraction(0)"]}
{"id": "878", "ref_py": ["def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\\n        distSet = set()\\n        distArr = []\\n        \\n        def findDist(ptOne, ptTwo):\\n            dx, dy = ptOne[0] - ptTwo[0], ptOne[1] - ptTwo[1]\\n            dist = dx ** 2 + dy ** 2\\n            distSet.add(dist)\\n            distArr.append(dist)\\n        \\n\\t\\t", "def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\\n        distSet = set()\\n        distArr = []\\n        \\n        def findDist(ptOne, ptTwo):\\n            dx, dy = ptOne[0] - ptTwo[0], ptOne[1] - ptTwo[1]\\n            dist = dx ** 2 + dy ** 2\\n            distSet.add(dist)\\n            distArr.append(dist)\\n        \\n\\t\\t", "def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\\n        distSet = set()\\n        distArr = []\\n        \\n        def findDist(ptOne, ptTwo):\\n            dx, dy = ptOne[0] - ptTwo[0], ptOne[1] - ptTwo[1]\\n            dist = dx ** 2 + dy ** 2\\n            distSet.add(dist)\\n            distArr.append(dist)\\n        \\n\\t\\t"]}
{"id": "881", "ref_py": ["defaultdict object named \"content_dict\" that will store the file contents as keys and the file paths as values.\\n2. Iterate over each path in the \"paths\" list.\\n3. Split the path string into separate parts based on spaces, so that the first part is the directory and the remaining parts are individual files.\\n4. For each file in the path, split the file string into separate parts based on the opening parenthesis. The first part is the file name, and the second part (without the closing parenthesis) is the file content.\\n5. Append the directory path and file name together as a string, and add it to the list of file paths stored under the corresponding file content key in the \"content_dict\" dictionary.\\n6. After iterating over all paths, create a new list of lists by iterating over each unique file content key in the \"content_dict\" dictionary.\\n7. If the list of file paths stored under the current file content key has a length greater than 1 (meaning there are at least two files with the same content), add it to the new list of lists.\\n8. Return the new list of lists of file paths.", "defaultdict object named \"content_dict\" that will store the file contents as keys and the file paths as values.\\n2. Iterate over each path in the \"paths\" list.\\n3. Split the path string into separate parts based on spaces, so that the first part is the directory and the remaining parts are individual files.\\n4. For each file in the path, split the file string into separate parts based on the opening parenthesis. The first part is the file name, and the second part (without the closing parenthesis) is the file content.\\n5. Append the directory path and file name together as a string, and add it to the list of file paths stored under the corresponding file content key in the \"content_dict\" dictionary.\\n6. After iterating over all paths, create a new list of lists by iterating over each unique file content key in the \"content_dict\" dictionary.\\n7. If the list of file paths stored under the current file content key has a length greater than 1 (meaning there are at least two files with the same content), add it to the new list of lists.\\n8. Return the new list of lists of file paths.", "defaultdict object named \"content_dict\" that will store the file contents as keys and the file paths as values.\\n2. Iterate over each path in the \"paths\" list.\\n3. Split the path string into separate parts based on spaces, so that the first part is the directory and the remaining parts are individual files.\\n4. For each file in the path, split the file string into separate parts based on the opening parenthesis. The first part is the file name, and the second part (without the closing parenthesis) is the file content.\\n5. Append the directory path and file name together as a string, and add it to the list of file paths stored under the corresponding file content key in the \"content_dict\" dictionary.\\n6. After iterating over all paths, create a new list of lists by iterating over each unique file content key in the \"content_dict\" dictionary.\\n7. If the list of file paths stored under the current file content key has a length greater than 1 (meaning there are at least two files with the same content), add it to the new list of lists.\\n8. Return the new list of lists of file paths."]}
{"id": "882", "ref_py": ["def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        nums.sort()\\n        \\n        for i1 in range(len(nums)):\\n            for i2 in range(i1 + 1, len(nums)):\\n                for i3 in range(i2 + 1, len(nums)):\\n                    \\n                    condition1 = nums[i1] +  nums[i2] >  nums[i3]\\n                    condition2 = nums[i1] +  nums[i3] >  nums[i2]\\n                    condition3 = nums[i2] +  nums[i3] >  nums[i1]\\n                    \\n                    if condition1 and condition2 and condition3:  count += 1\\n                        \\n        return count\\n\\t\\t\\n", "def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        nums.sort()\\n        \\n        for i1 in range(len(nums)):\\n            for i2 in range(i1 + 1, len(nums)):\\n                for i3 in range(i2 + 1, len(nums)):\\n                    \\n                    condition1 = nums[i1] +  nums[i2] >  nums[i3]\\n                    condition2 = nums[i1] +  nums[i3] >  nums[i2]\\n                    condition3 = nums[i2] +  nums[i3] >  nums[i1]\\n                    \\n                    if condition1 and condition2 and condition3:  count += 1\\n                        \\n        return count\\n\\t\\t\\n", "def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        nums.sort()\\n        \\n        for i1 in range(len(nums)):\\n            for i2 in range(i1 + 1, len(nums)):\\n                for i3 in range(i2 + 1, len(nums)):\\n                    \\n                    condition1 = nums[i1] +  nums[i2] >  nums[i3]\\n                    condition2 = nums[i1] +  nums[i3] >  nums[i2]\\n                    condition3 = nums[i2] +  nums[i3] >  nums[i1]\\n                    \\n                    if condition1 and condition2 and condition3:  count += 1\\n                        \\n        return count\\n\\t\\t\\n"]}
{"id": "883", "ref_py": ["def leastInterval(self, tasks, n):\\n        ", "def leastInterval(self, tasks: List[str], n: int) -> int:\\n        ", "def leastInterval(self, tasks: List[str], n: int) -> int:\\n        \\'\\'\\'\\n          STRATEGY\\n          Greedy; schedule the n most common in round-robin fashion.\\n          The \"n most common\" adjusts as \"time\" progresses.\\n          If there are fewer than n distinct tasks in todo, pad to n with idle states."]}
{"id": "885", "ref_py": ["def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:\\n        ", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "887", "ref_py": ["def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(c**0.5)  ", "def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(c**0.5)  ", "def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(c**0.5)  "]}
{"id": "888", "ref_py": ["def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 ", "def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 ", "def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 "]}
{"id": "889", "ref_py": ["def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\t\\t\\tn = len(price)\\n\\t\\t\\tcount = [0]*(n+1)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\textra = [0]*(n+1)\\n\\t\\t\\t\\textra[-1] = price[i]  \\n\\t\\t\\t\\textra[i] = 1 \\n\\t\\t\\t\\tspecial.append(extra) ", "def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        memo = {}\\n        \\n        def dp(needs):\\n            if needs in memo:\\n                return memo[needs]\\n            \\n            cost = sum(price[i] * needs[i] for i in range(len(needs)))\\n            \\n            for offer in special:\\n                remain = [needs[i] - offer[i] for i in range(len(needs))]\\n                \\n                if all(x >= 0 for x in remain):\\n                    cost = min(cost, offer[-1] + dp(tuple(remain)))\\n            \\n            memo[needs] = cost\\n            return cost\\n        \\n        return dp(tuple(needs))", "def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\t\\t\\tn = len(price)\\n\\t\\t\\tcount = [0]*(n+1)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\textra = [0]*(n+1)\\n\\t\\t\\t\\textra[-1] = price[i]  \\n\\t\\t\\t\\textra[i] = 1 \\n\\t\\t\\t\\tspecial.append(extra) "]}
{"id": "890", "ref_py": ["def solveEquation(self, eqn: str) -> str:\\n        if eqn == \"x=x\": return \"Infinite solutions\"", "def solveEquation(self, equation):\\n        \\n        ", "def solveEquation(self, equation):\\n        \\n        "]}
{"id": "892", "ref_py": ["def findLongestChain(self, pairs: List[List[int]]) -> int:\\n    ans = 0\\n    prevEnd = -math.inf", "def findLongestChain(self, pairs: List[List[int]]) -> int:\\n        pairs.sort(key=lambda x: x[1])\\n        \\n        prev = 0\\n        res = 1\\n        \\n        for i in range(1, len(pairs)):\\n            if pairs[prev][1] < pairs[i][0]:\\n                prev = i\\n                res += 1\\n        \\n        return res", "def findLongestChain(self, pairs: List[List[int]]) -> int:\\n        pairs.sort(key=lambda x: x[1])\\n        \\n        prev = 0\\n        res = 1\\n        \\n        for i in range(1, len(pairs)):\\n            if pairs[prev][1] < pairs[i][0]:\\n                prev = i\\n                res += 1\\n        \\n        return res"]}
{"id": "893", "ref_py": ["defined as **N * (N + 1) / 2**) to account for all the smaller palindromes of which it\\'s made.", "def expandAndCountPallindromes(self, i, j, s):\\n        \\'\\'\\'Counts the number of pallindrome substrings from a given center i,j        \\n        1. when i=j, it\\'s an odd-lengthed pallindrome string. \\n            eg: for string \"aba\", i=j=1.\\n        2. when i+1=j, it\\'s an even-lengthed pallindrome string. \\n            eg: for string \"abba\", i=1, j=2.\\n        \\n        Parameters:\\n            i,j - centers from which the code will expand to find number of pallindrome substrings.\\n            s - the string in which the code needs to find the pallindrome substrings. \\n        \\n        Returns:\\n            cnt - The number of pallindrome substrings from the given center i,j       \\n        \\'\\'\\'\\n        \\n        length=len(s)\\n        cnt=0\\n        \\n        while 0<=i and j<length and s[i]==s[j]:\\n            i-=1\\n            j+=1\\n            cnt+=1\\n        \\n        return cnt\\n        \\n    def countSubstrings(self, s: str) -> int:\\n        \\n        return sum(self.expandAndCountPallindromes(i,i,s) + self.expandAndCountPallindromes(i,i+1,s) for i in range(len(s)))\\n        \\n```", "defined as **N * (N + 1) / 2**) to account for all the smaller palindromes of which it\\'s made."]}
{"id": "894", "ref_py": ["def replaceWords(self, dic, sentence):\\n        s=sentence.split()\\n        ", "def __init__(self, dictionary) -> None:\\n        self.root = {}\\n        for word in dictionary:\\n            self.insert(word)\\n        \\n    def insert(self, word) -> None:\\n        node = self.root\\n        for char in word:\\n            if char not in node:\\n                node[char] = {}\\n            node = node[char]", "def __init__(self, dictionary) -> None:\\n        self.root = {}\\n        for word in dictionary:\\n            self.insert(word)\\n        \\n    def insert(self, word) -> None:\\n        node = self.root\\n        for char in word:\\n            if char not in node:\\n                node[char] = {}\\n            node = node[char]"]}
{"id": "895", "ref_py": ["def predictPartyVictory(self, senate):\\n        \\n        senate=list(senate)\\n        n=len(senate)\\n        D,R = deque(), deque()\\n        for i in range(n):\\n            if senate[i]==\"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)", "def predictPartyVictory(self, senate):\\n        \\n        senate=list(senate)\\n        n=len(senate)\\n        D,R = deque(), deque()\\n        for i in range(n):\\n            if senate[i]==\"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)", "def predictPartyVictory(self, senate):\\n        \\n        senate=list(senate)\\n        n=len(senate)\\n        D,R = deque(), deque()\\n        for i in range(n):\\n            if senate[i]==\"R\":\\n                R.append(i)\\n            else:\\n                D.append(i)"]}
{"id": "896", "ref_py": ["def minSteps(self, n: int) -> int:\\n        cache = {}\\n        def helper(screen, clipboard):\\n            if (screen, clipboard) in cache: return cache[(screen, clipboard)]\\n            if screen == n: return 0\\n            if screen > n: return float(\"Inf\")\\n            \\n            copy_paste = helper(screen+screen, screen) + 2\\n            paste = float(\"Inf\")\\n            if clipboard:\\n                paste = helper(screen + clipboard, clipboard) + 1", "def minSteps(self, n: int) -> int:\\n        \\n        dp = [float(\\'inf\\')] * (n+1)\\t\\n\\t\\t", "def minSteps(self, n: int) -> int:\\n        \\n        dp = [float(\\'inf\\')] * (n+1)\\t\\n\\t\\t"]}
{"id": "897", "ref_py": ["def serialization(node, path):\\n\\tif node is None: return \\'", "def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\\n    ans = []\\n    count = collections.Counter()", "def serialization(node, path):\\n\\tif node is None: return \\'"]}
{"id": "898", "ref_py": ["def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:\\n    ", "def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\\n        A = nums + [inf]\\n        stack = [TreeNode(A[0])]\\n        for a in A[1:]:\\n            n = TreeNode(a)\\n            if stack and stack[-1].val < a:\\n                p = stack.pop()\\n                while stack and stack[-1].val < a:\\n                    stack[-1].right = p\\n                    p = stack.pop()\\n                n.left = p\\n            stack.append(n)\\n        return stack[0].left\\n    \\n```", "def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\\n        A = nums + [inf]\\n        stack = [TreeNode(A[0])]\\n        for a in A[1:]:\\n            n = TreeNode(a)\\n            if stack and stack[-1].val < a:\\n                p = stack.pop()\\n                while stack and stack[-1].val < a:\\n                    stack[-1].right = p\\n                    p = stack.pop()\\n                n.left = p\\n            stack.append(n)\\n        return stack[0].left\\n    \\n```"]}
{"id": "899", "ref_py": ["defined as the length of the longest path from the root to a leaf node.", "def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:\\n        tree_height = self.getTreeHeight(root) - 1\\n        rows = tree_height + 1\\n        cols = int(math.pow(2, tree_height + 1) - 1)\\n        matrix = [[\"\" for _ in range(cols)] for _ in range(rows)]\\n        \\n        count = 0\\n        def fillMatrix(node, r, c):\\n            nonlocal count, tree_height\\n            \\n            if node is None: return\\n            \\n            matrix[r][c] = str(node.val)\\n            \\n            fillMatrix(node.left, r+1,  c - int(math.pow(2, tree_height - r - 1)))\\n            fillMatrix(node.right, r+1,  c + int(math.pow(2, tree_height - r - 1)))\\n        \\n        r, c = 0, (len(matrix[0]) - 1) // 2\\n        fillMatrix(root, r, c)\\n        return matrix\\n        \\n    \\n    def getTreeHeight(self, node):\\n        if node is None: return 0\\n        \\n        left = self.getTreeHeight(node.left)\\n        right = self.getTreeHeight(node.right)\\n        \\n        return max(left, right) + 1\\n", "def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:\\n        def height(root):\\n            if not root:\\n                return 0\\n            return 1 + max(height(root.left), height(root.right))\\n"]}
{"id": "900", "ref_py": ["def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n> ", "def maximumCount(self, nums: List[int]) -> int:\\n        neg=0\\n        pos=0\\n        for i in nums:\\n            if i>0:\\n                pos+=1\\n            if i<0:\\n                neg+=1", "def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n> "]}
{"id": "901", "ref_py": ["def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)", "def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)", "def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)"]}
{"id": "902", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "903", "ref_py": ["def checkPossibility(self, N: List[int]) -> bool:\\n        err = 0\\n        for i in range(1, len(N)):\\n            if N[i] < N[i-1]:\\n                if err or (i > 1 and i < len(N) - 1 and N[i-2] > N[i] and N[i+1] < N[i-1]):\\n                    return False\\n                err = 1\\n        return True\\n```", "def checkPossibility(self, nums: List[int]) -> bool:\\n        cnt_violations=0        \\n        for i in range(1, len(nums)):                       \\n            if nums[i]<nums[i-1]:\\n                if cnt_violations==1:\\n                    return False\\n                cnt_violations+=1\\n                if i>=2 and nums[i-2]>nums[i]:\\n                    nums[i]=nums[i-1]                       \\n        return True\\n```", "def checkPossibility(self, N: List[int]) -> bool:\\n        err = 0\\n        for i in range(1, len(N)):\\n            if N[i] < N[i-1]:\\n                if err or (i > 1 and i < len(N) - 1 and N[i-2] > N[i] and N[i+1] < N[i-1]):\\n                    return False\\n                err = 1\\n        return True\\n```"]}
{"id": "904", "ref_py": ["def constructArray(self, n: int, k: int) -> List[int]:\\n    ans = list(range(1, n - k + 1))\\n    for i in range(k):\\n        diff = i // 2 + 1\\n        if i % 2 == 0:\\n            ans.append(n - diff + 1)\\n        else:\\n            ans.append(n - k + diff)", "def constructArray(self, n: int, k: int) -> List[int]:\\n        ans, a, z = [0] * n, 1, k + 1\\n        for i in range(k+1):\\n            if i % 2:\\n                ans[i] = z\\n                z -= 1\\n            else:\\n                ans[i] = a\\n                a += 1\\n        for i in range(k+1,n):\\n            ans[i] = i + 1\\n        return ans\\n```", "def constructArray(self, n: int, k: int) -> List[int]:\\n    ans = list(range(1, n - k + 1))\\n    for i in range(k):\\n        diff = i // 2 + 1\\n        if i % 2 == 0:\\n            ans.append(n - diff + 1)\\n        else:\\n            ans.append(n - k + diff)"]}
{"id": "905", "ref_py": ["def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:\\n\\t\\t\\tif not root: return root\\n\\t\\t\\tif root.val < low: return self.trimBST(root.right, low, high)\\n\\t\\t\\tif root.val > high: return self.trimBST(root.left, low, high)\\n\\t\\t\\troot.left = self.trimBST(root.left, low, high)\\n\\t\\t\\troot.right = self.trimBST(root.right, low, high)\\n", "def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:\\n        while root and (root.val < low or root.val > high):\\n            if root.val < low:\\n                root = root.right\\n            else:\\n                root = root.left\\n        \\n        if not root:\\n            return None\\n        \\n        node = root\\n        while node:\\n            while node.left and node.left.val < low:\\n                node.left = node.left.right\\n            \\n            node = node.left\\n            \\n        node = root\\n        while node:\\n            while node.right and node.right.val > high:\\n                node.right = node.right.left\\n            \\n            node = node.right\\n        \\n        return root", "def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\\n\\t\\t\\t\\tif(root == None) : \\n\\t\\t\\t\\t\\treturn None;    \\n\\t\\t\\t\\troot.left =  self.trimBST(root.left,low,high);\\n\\t\\t\\t\\troot.right = self.trimBST(root.right,low,high);    \\n\\t\\t\\t\\tif( low <= root.val and root.val <= high ) :\\n\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\tif root.left != None :\\n\\t\\t\\t\\t\\treturn root.left;\\n\\t\\t\\t\\telse:\\n"]}
{"id": "906", "ref_py": ["def depth(node: Optional[TreeNode]) -> int:\\n    \\n\\t", "def diameterOfBinaryTree(self, root):\\n        \\n        if root is None:\\n            return 0\\n        \\n        left_height=self.height(root.left)\\n        right_height=self.height(root.right)\\n        \\n        left_diameter=self.diameterOfBinaryTree(root.left)\\n        right_diameter=self.diameterOfBinaryTree(root.right)\\n        \\n        return max((left_height+right_height), max(left_diameter,right_diameter))\\n        \\n    \\n    def height(self,root):\\n        if root is None:\\n            return 0\\n        \\n        else:\\n            left_height=self.height(root.left)\\n            right_height=self.height(root.right)\\n        \\n            return 1 + max(left_height, right_height)\\n```", "def depth(node: Optional[TreeNode]) -> int:\\n    \\n\\t"]}
{"id": "907", "ref_py": ["def flipLights(self, n: int, m: int) -> int:\\n        ", "def flipLights(self, n, m):\\n        \\n        if(m==0): return 1;\\n        if(n==1): return 2;\\n        if(n==2 and m==1): return 3;\\n        if(n==2): return 4;\\n        if(m==1): return 4;\\n        if(m==2): return 7;\\n        if(m>=3): return 8;\\n        return 8;", "def flipLights(self, n, m):\\n        \\n        if(m==0): return 1;\\n        if(n==1): return 2;\\n        if(n==2 and m==1): return 3;\\n        if(n==2): return 4;\\n        if(m==1): return 4;\\n        if(m==2): return 7;\\n        if(m>=3): return 8;\\n        return 8;"]}
{"id": "908", "ref_py": ["def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf ", "def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf ", "def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf "]}
{"id": "911", "ref_py": ["def checkValidString(self, s: str) -> bool:\\n        \\n        ", "def checkValidString(self, s: str) -> bool:\\n        ", "def checkValidString(self, s: str) -> bool:\\n        \\n        "]}
{"id": "912", "ref_py": ["def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\\n        dsu = DSU()\\n        for u, v in edges:\\n            if dsu.is_connected(u, v): return [u, v]\\n            dsu.union(u, v)\\n    \\nclass DSU:\\n    T = Hashable", "define two functions: **union** and **find**. The **find** function will **recursively** trace a node\\'s lineage back to its ultimate parent and update its value in the parent array (**par**), providing a shortcut for the next link.", "defaultdict(list) \\n        \\n        ans = []\\n\\t\\t"]}
{"id": "913", "ref_py": ["def repeatedStringMatch(self, a: str, b: str) -> int:\\n        counter = 1\\n        tmp = a\\n        while (len(a)<len(b)):\\n            a+=tmp\\n            counter+=1\\n        if b in a:\\n            return counter\\n        if b in a+tmp:\\n            return counter+1\\n        return -1", "def repeatedStringMatch(self, a: str, b: str) -> int:\\n        n, m = divmod(len(b), len(a))\\n        if m:\\n            n += 1\\n        if b in a * n:\\n            return n\\n        elif b in a * (n+1):\\n            return n+1\\n        else:\\n            return -1", "def repeatedStringMatch(self, a: str, b: str) -> int:\\n        if b in a:\\n            return 1\\n        c,n=1,len(b)\\n        t=a\\n        while b!=t and len(t)<=n:\\n            c+=1\\n            t=a*c\\n        if b in t:\\n            return c\\n        if b in a*(c+1):\\n            return c+1\\n        return -1\\n```"]}
{"id": "914", "ref_py": ["define a variable max_len and initialize it to 0.\\nDefine a nested function helper that takes node and parent_val as parameters.\\nIf the node is None, return 0.\\nRecursively call the helper function on the left and right child nodes, passing the current node\\'s value as the parent_val.\\nDefine left_len and right_len as the return values of the recursive calls.\\nIf the node\\'s value equals the value of its left child node, increment left_len by 1, else set left_len to 0.\\nIf the node\\'s value equals the value of its right child node, increment right_len by 1, else set right_len to 0.\\nSet max_len to the maximum value between max_len and left_len + right_len.\\nReturn 1 + the maximum value between left_len and right_len if the node\\'s value equals the parent_val, else return 0.\\nCall the helper function on the root node with parent_val set to None.\\nReturn max_len.", "define a variable max_len and initialize it to 0.\\nDefine a nested function helper that takes node and parent_val as parameters.\\nIf the node is None, return 0.\\nRecursively call the helper function on the left and right child nodes, passing the current node\\'s value as the parent_val.\\nDefine left_len and right_len as the return values of the recursive calls.\\nIf the node\\'s value equals the value of its left child node, increment left_len by 1, else set left_len to 0.\\nIf the node\\'s value equals the value of its right child node, increment right_len by 1, else set right_len to 0.\\nSet max_len to the maximum value between max_len and left_len + right_len.\\nReturn 1 + the maximum value between left_len and right_len if the node\\'s value equals the parent_val, else return 0.\\nCall the helper function on the root node with parent_val set to None.\\nReturn max_len.", "define a variable max_len and initialize it to 0.\\nDefine a nested function helper that takes node and parent_val as parameters.\\nIf the node is None, return 0.\\nRecursively call the helper function on the left and right child nodes, passing the current node\\'s value as the parent_val.\\nDefine left_len and right_len as the return values of the recursive calls.\\nIf the node\\'s value equals the value of its left child node, increment left_len by 1, else set left_len to 0.\\nIf the node\\'s value equals the value of its right child node, increment right_len by 1, else set right_len to 0.\\nSet max_len to the maximum value between max_len and left_len + right_len.\\nReturn 1 + the maximum value between left_len and right_len if the node\\'s value equals the parent_val, else return 0.\\nCall the helper function on the root node with parent_val set to None.\\nReturn max_len."]}
{"id": "915", "ref_py": ["def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        @lru_cache(None)\\n        def dp(cur_r,cur_c,k):\\n            if k==0:\\n                return 1", "defining `on_board`, `moves`, `next_positions` are copy pasted in all solutions.", "def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        if k == 0:\\n            return 1"]}
{"id": "917", "ref_py": ["def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        heap = []\\n        for key, val in dico.items():\\n            heapq.heappush(heap, (val, key))\\n            if len(heap)>k: heapq.heappop(heap)\\n        \\n        res = []\\n        while heap:\\n            res.append([heapq.heappop(heap)[1]])\\n        return res[::-1]\\n```", "def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        heap = []\\n        for key, val in dico.items():\\n            heapq.heappush(heap, (val, key))\\n            if len(heap)>k: heapq.heappop(heap)\\n        \\n        res = []\\n        while heap:\\n            res.append([heapq.heappop(heap)[1]])\\n        return res[::-1]\\n```", "def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        heap = []\\n        for key, val in dico.items():\\n            heapq.heappush(heap, (val, key))\\n            if len(heap)>k: heapq.heappop(heap)\\n        \\n        res = []\\n        while heap:\\n            res.append([heapq.heappop(heap)[1]])\\n        return res[::-1]\\n```"]}
{"id": "918", "ref_py": ["def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\\n        ans, n, m = 0, len(grid), len(grid[0])\\n        def trav(i: int, j: int) -> int:\\n            if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] == 0: return 0\\n            grid[i][j] = 0\\n            return 1 + trav(i-1, j) + trav(i, j-1) + trav(i+1, j) + trav(i, j+1)\\n        for i, j in product(range(n), range(m)):\\n            if grid[i][j]: ans = max(ans, trav(i, j))\\n        return ans\\n```", "def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\\n        max_area = 0\\n        rows = len(grid)\\n        cols = len(grid[0])", "def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\\n        max_area = 0\\n        rows = len(grid)\\n        cols = len(grid[0])"]}
{"id": "919", "ref_py": ["def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\\n\\ttotal = sum(nums)", "def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\\n\\ttotal = sum(nums)", "def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\\n\\ttotal = sum(nums)"]}
{"id": "920", "ref_py": ["def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None: return TreeNode(val) \\n        if root.val > val:  root.left = self.insertIntoBST(root.left, val)\\n        else: root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)", "def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right, val)\\n        else:\\n            root.left = self.insertIntoBST(root.left, val)\\n        \\n        return root\\n```\\n```javascript []\\nvar insertIntoBST = function(root, val) {\\n    if (!root) return new TreeNode(val=val);", "def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right, val)\\n        else:\\n            root.left = self.insertIntoBST(root.left, val)\\n        \\n        return root\\n```\\n```javascript []\\nvar insertIntoBST = function(root, val) {\\n    if (!root) return new TreeNode(val=val);"]}
{"id": "922", "ref_py": ["def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n = len(s1)\\n        m = len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]", "def minimumDeleteSum(s1: str, s2: str) -> int:\\n    m, n = len(s1), len(s2)\\n    dp = [0] * (n + 1)", "def minimumDeleteSum(self, s1: str, s2: str) -> int:\\n        n = len(s1)\\n        m = len(s2)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]"]}
{"id": "923", "ref_py": ["def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\\n        if k==0:\\n            return 0\\n        p,n=1,len(nums)\\n        i=c=0\\n        for j in range(n):\\n            p*=nums[j]\\n            while p>=k and i<=j:\\n                p/=nums[i]\\n                i+=1\\n            c+=j-i+1\\n        return c\\n```", "def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\\n        if k==0:\\n            return 0\\n        p,n=1,len(nums)\\n        i=c=0\\n        for j in range(n):\\n            p*=nums[j]\\n            while p>=k and i<=j:\\n                p/=nums[i]\\n                i+=1\\n            c+=j-i+1\\n        return c\\n```", "def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\\n        if k==0:\\n            return 0\\n        p,n=1,len(nums)\\n        i=c=0\\n        for j in range(n):\\n            p*=nums[j]\\n            while p>=k and i<=j:\\n                p/=nums[i]\\n                i+=1\\n            c+=j-i+1\\n        return c\\n```"]}
{"id": "924", "ref_py": ["def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def solve(ind,buy):\\n            if ind==n:\\n                return 0\\n            profit=0\\n            if buy==0: ", "def maxProfit(self, prices, fee):\\n        free = 0\\n        hold = -prices[0]\\n        for i in prices:\\n            tmp = hold\\n            hold = max(hold, free - i)\\n            free = max(free, tmp + i - fee)\\n        return free\\n```", "def maxProfit(self, prices: List[int], fee: int) -> int:\\n        N = len(prices)\\n        \\n        had_stock = -prices[0]\\n        didnt_have_stock = 0\\n        \\n        for price in prices:\\n\\t\\t\\t"]}
{"id": "925", "ref_py": ["def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans", "def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:", "def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans"]}
{"id": "926", "ref_py": ["def shiftGrid(self, grid, k):\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        modulo = rows * cols\\n        k = k % modulo\\n        \\n        if k == 0:\\n            return grid", "def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  ", "def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  "]}
{"id": "927", "ref_py": ["def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            ", "def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def findParent(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=findParent(parent[u])\\n                return parent[u]\\n                \\n        def unionBySize(u,v):\\n            pu,pv=findParent(u),findParent(v)\\n            if pu==pv:\\n                return \\n            elif size[pu]<size[pv]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n            \\n        n=len(accounts)\\n        parent=[i for i in range(n)]\\n        size=[1]*n\\n        d={}\\n        for i in range(n):\\n            for j in range(1,len(accounts[i])):\\n                s=accounts[i][j]\\n                if s not in d:\\n                    d[s]=i\\n                else:\\n                    unionBySize(i,d[s])\\n        temp=defaultdict(list)\\n        for k,v in d.items():\\n            pv=findParent(v)\\n            temp[pv].append(k)\\n        res=[]\\n        for i in temp:\\n            temp2=sorted(temp[i])\\n            ans=[accounts[i][0]]\\n            ans.extend(temp2)\\n            res.append(ans)\\n        return res\\n```", "def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def findParent(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=findParent(parent[u])\\n                return parent[u]\\n                \\n        def unionBySize(u,v):\\n            pu,pv=findParent(u),findParent(v)\\n            if pu==pv:\\n                return \\n            elif size[pu]<size[pv]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n            \\n        n=len(accounts)\\n        parent=[i for i in range(n)]\\n        size=[1]*n\\n        d={}\\n        for i in range(n):\\n            for j in range(1,len(accounts[i])):\\n                s=accounts[i][j]\\n                if s not in d:\\n                    d[s]=i\\n                else:\\n                    unionBySize(i,d[s])\\n        temp=defaultdict(list)\\n        for k,v in d.items():\\n            pv=findParent(v)\\n            temp[pv].append(k)\\n        res=[]\\n        for i in temp:\\n            temp2=sorted(temp[i])\\n            ans=[accounts[i][0]]\\n            ans.extend(temp2)\\n            res.append(ans)\\n        return res\\n```"]}
{"id": "928", "ref_py": ["def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```", "def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```", "def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```"]}
{"id": "929", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n"]}
{"id": "932", "ref_py": ["def asteroidCollision(self, asteroids: List[int]) -> List[int]:\\n        j = 0\\n        n = len(asteroids)", "def samesign(self, x, y):\\n        if x < 0 and y < 0:\\n            return True\\n        elif x > 0 and y > 0:\\n            return True\\n        return False", "def samesign(self, x, y):\\n        if x < 0 and y < 0:\\n            return True\\n        elif x > 0 and y > 0:\\n            return True\\n        return False"]}
{"id": "933", "ref_py": ["def monotoneIncreasingDigits(self, n: int) -> int:\\n\\t\\t", "def monotoneIncreasingDigits(self, n: int) -> int:\\n        digits = list(str(n))\\n        n = len(digits)\\n        idx_to_modify = n  ", "def monotoneIncreasingDigits(self, n):\\n        "]}
{"id": "934", "ref_py": ["def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))"]}
{"id": "935", "ref_py": ["defaultdict", "def deleteAndEarn(self, nums: List[int]) -> int:\\n", "def deleteAndEarn(self, nums: List[int]) -> int:\\n        if  not nums:\\n            return 0"]}
{"id": "936", "ref_py": ["def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:        \\n        adj_list = defaultdict(list)\\n        \\n        for x,y,w in times:\\n            adj_list[x].append((w, y))\\n        \\n        visited=set()\\n        heap = [(0, k)]\\n        while heap:\\n            travel_time, node = heapq.heappop(heap)\\n            visited.add(node)\\n            \\n            if len(visited)==n:\\n                return travel_time\\n            \\n            for time, adjacent_node in adj_list[node]:\\n                if adjacent_node not in visited:\\n                    heapq.heappush(heap, (travel_time+time, adjacent_node))\\n                \\n        return -1\\n```", "defaultdict", "defaultdict"]}
{"id": "937", "ref_py": ["def neighbors(node):\\n    for i in range(4):\\n        x = int(node[i])\\n        for d in (-1, 1):  \\n            y = (x + d) % 10\\n            yield node[:i] + str(y) + node[i+1:]\\n```\\nThe neighbors function generates the immediate neighbors of the current combination of the lock. For each position in the 4-digit combination, it tries moving the digit up or down (hence the for d in (-1, 1) loop). If it moves from \\'9\\' it goes to \\'0\\' and vice versa, which is handled by the modulo operation.", "def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \"0000\": return 0\\n        queue, target = deque([0]), int(target)\\n        seen, turns = [0] * 10000, 1\\n        for d in deadends: seen[int(d)] = 1\\n        if seen[0]: return -1\\n        while len(queue):\\n            qlen = len(queue)\\n            for i in range(qlen):\\n                curr, j = queue.popleft(), 1\\n                while j < 10000:\\n                    mask = curr % (j * 10) // j\\n                    masked = curr - (mask * j)\\n                    for k in range(1,10,8):\\n                        nxt = masked + (mask + k) % 10 * j\\n                        if seen[nxt]: continue\\n                        if nxt == target: return turns\\n                        seen[nxt] = 1\\n                        queue.append(nxt)\\n                    j *= 10\\n            turns += 1\\n        return -1\\n```", "def openLock(self, deadends: List[str], target: str) -> int:\\n        if target == \"0000\": return 0\\n        queue, target = deque([0]), int(target)\\n        seen, turns = [0] * 10000, 1\\n        for d in deadends: seen[int(d)] = 1\\n        if seen[0]: return -1\\n        while len(queue):\\n            qlen = len(queue)\\n            for i in range(qlen):\\n                curr, j = queue.popleft(), 1\\n                while j < 10000:\\n                    mask = curr % (j * 10) // j\\n                    masked = curr - (mask * j)\\n                    for k in range(1,10,8):\\n                        nxt = masked + (mask + k) % 10 * j\\n                        if seen[nxt]: continue\\n                        if nxt == target: return turns\\n                        seen[nxt] = 1\\n                        queue.append(nxt)\\n                    j *= 10\\n            turns += 1\\n        return -1\\n```"]}
{"id": "938", "ref_py": ["def reachNumber(self, target: int) -> int:\\n        target = abs(target)\\n        n = ceil(sqrt(2*target)-1) ", "def reachNumber(self, target: int) -> int:\\n        target = abs(target)\\n        n = ceil(sqrt(2*target)-1) ", "def reachNumber(self, target: int) -> int:\\n        target = abs(target)\\n        n = ceil(sqrt(2*target)-1) "]}
{"id": "939", "ref_py": ["default(triplet[:2], []).append(triplet[2])\\n```\\nFor each triplet in the allowed list, we take its first two characters (which represent the bottom blocks) and map them to the third character (which represents the top block).\\nThe setdefault method ensures that if the key doesn\\'t already exist in the dictionary, it\\'s set to an empty list.", "def pyramidTransition(self, bottom, allowed):\\n        \\n        dic = defaultdict(list)\\n        for i in allowed:\\n            dic[(i[0], i[1])].append(i[2])\\n        \\n        res = []\\n        \\n        def dfs(arr, nxt):\\n            ", "default(triplet[:2], []).append(triplet[2])\\n```\\nFor each triplet in the allowed list, we take its first two characters (which represent the bottom blocks) and map them to the third character (which represents the top block).\\nThe setdefault method ensures that if the key doesn\\'t already exist in the dictionary, it\\'s set to an empty list."]}
{"id": "940", "ref_py": ["def constructArray(self, n: int, k: int) -> List[int]:\\n    ans = list(range(1, n - k + 1))\\n    for i in range(k):\\n        diff = i // 2 + 1\\n        if i % 2 == 0:\\n            ans.append(n - diff + 1)\\n        else:\\n            ans.append(n - k + diff)", "def constructArray(self, n: int, k: int) -> List[int]:\\n        ans, a, z = [0] * n, 1, k + 1\\n        for i in range(k+1):\\n            if i % 2:\\n                ans[i] = z\\n                z -= 1\\n            else:\\n                ans[i] = a\\n                a += 1\\n        for i in range(k+1,n):\\n            ans[i] = i + 1\\n        return ans\\n```", "def constructArray(self, n: int, k: int) -> List[int]:\\n    ans = list(range(1, n - k + 1))\\n    for i in range(k):\\n        diff = i // 2 + 1\\n        if i % 2 == 0:\\n            ans.append(n - diff + 1)\\n        else:\\n            ans.append(n - k + diff)"]}
{"id": "941", "ref_py": ["def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        grid = [[n] * n for _ in range(n)]\\n        \\n        for x, y in mines:\\n            grid[x][y] = 0", "def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        m=len(mines)\\n        if m==n*n: return 0\\n        seen=set()\\n        for i,j in mines:\\n            seen.add((i,j))\\n        ans=1\\n        ", "def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\\n        \\n        row = defaultdict(list)\\n        col = defaultdict(list)\\n        mines.sort()\\n        idx = 0\\n        for i in range(n):\\n            for j in range(n):\\n                \\n                if idx < len(mines) and [i,j] == mines[idx]:\\n                    if len(row[i]) == 0:\\n                        row[i].append(0)\\n                        row[i].append(0)\\n                    else:\\n                        row[i].append(row[i][-1] + 0)\\n                    if len(col[j]) == 0:\\n                        col[j].append(0)\\n                        col[j].append(0)\\n                    else:    \\n                        col[j].append(col[j][-1] + 0)\\n                \\n                    idx +=1\\n                else:\\n                    if len(row[i]) == 0:\\n                        row[i].append(0)\\n                        row[i].append(1)\\n                    else:\\n                        row[i].append(row[i][-1] + 1)\\n                    if len(col[j]) == 0:\\n                        col[j].append(0)\\n                        col[j].append(1)\\n                    else:    \\n                        col[j].append(col[j][-1] + 1)\\n        \\n        \\n        def isGood(target):\\n            \\n            for i in range(target-1, n-target+1):\\n                for j in range(target-1, n-target+1):\\n                    \\n                    "]}
{"id": "942", "ref_py": ["def reorganizeString(self, s):\\n        \\n        ", "def reorganizeString(self, s: str) -> str:\\n        dic = {}\\n        for i in s:\\n            dic[i] = dic.get(i,0)+1     \\n        max_key = None\\n        max_value = None", "def reorganizeString(self, s):\\n        \\n        "]}
{"id": "943", "ref_py": ["define a variable max_len and initialize it to 0.\\nDefine a nested function helper that takes node and parent_val as parameters.\\nIf the node is None, return 0.\\nRecursively call the helper function on the left and right child nodes, passing the current node\\'s value as the parent_val.\\nDefine left_len and right_len as the return values of the recursive calls.\\nIf the node\\'s value equals the value of its left child node, increment left_len by 1, else set left_len to 0.\\nIf the node\\'s value equals the value of its right child node, increment right_len by 1, else set right_len to 0.\\nSet max_len to the maximum value between max_len and left_len + right_len.\\nReturn 1 + the maximum value between left_len and right_len if the node\\'s value equals the parent_val, else return 0.\\nCall the helper function on the root node with parent_val set to None.\\nReturn max_len.", "define a variable max_len and initialize it to 0.\\nDefine a nested function helper that takes node and parent_val as parameters.\\nIf the node is None, return 0.\\nRecursively call the helper function on the left and right child nodes, passing the current node\\'s value as the parent_val.\\nDefine left_len and right_len as the return values of the recursive calls.\\nIf the node\\'s value equals the value of its left child node, increment left_len by 1, else set left_len to 0.\\nIf the node\\'s value equals the value of its right child node, increment right_len by 1, else set right_len to 0.\\nSet max_len to the maximum value between max_len and left_len + right_len.\\nReturn 1 + the maximum value between left_len and right_len if the node\\'s value equals the parent_val, else return 0.\\nCall the helper function on the root node with parent_val set to None.\\nReturn max_len.", "define a variable max_len and initialize it to 0.\\nDefine a nested function helper that takes node and parent_val as parameters.\\nIf the node is None, return 0.\\nRecursively call the helper function on the left and right child nodes, passing the current node\\'s value as the parent_val.\\nDefine left_len and right_len as the return values of the recursive calls.\\nIf the node\\'s value equals the value of its left child node, increment left_len by 1, else set left_len to 0.\\nIf the node\\'s value equals the value of its right child node, increment right_len by 1, else set right_len to 0.\\nSet max_len to the maximum value between max_len and left_len + right_len.\\nReturn 1 + the maximum value between left_len and right_len if the node\\'s value equals the parent_val, else return 0.\\nCall the helper function on the root node with parent_val set to None.\\nReturn max_len."]}
{"id": "944", "ref_py": ["definition, a global inversion*. Any number that represents part of a global inversion, however, could represent more than one global inversion.", "def isIdealPermutation(self, A: List[int]) -> bool:", "def isIdealPermutation(self, arr: List[int]) -> bool:\\n        n=len(arr)\\n        l=0\\n        for i in range(n-1):\\n            if arr[i]>arr[i+1]:\\n                l+=1\\n                if l>1:\\n                    return False\\n        g=self.mergeSort(arr,0,n-1)\\n        return g==l\\n    \\n    def merge(self,arr,l,m,r):\\n        left=l\\n        right=m+1\\n        temp=[]\\n        c=0\\n        while left<=m and right<=r:\\n            if arr[left]<=arr[right]:\\n                temp.append(arr[left])\\n                left+=1\\n            else:\\n                temp.append(arr[right])\\n                c+=m-left+1\\n                right+=1\\n        while left<=m:\\n            temp.append(arr[left])\\n            left+=1\\n        while right<=r:\\n            temp.append(arr[right])\\n            right+=1\\n        for i in range(l,r+1):\\n            arr[i]=temp[i-l]\\n        return c\\n            \\n    def mergeSort(self,arr,l,r):\\n        c=0\\n        if l>=r:\\n            return c\\n        m=(l+r)>>1\\n        c+=self.mergeSort(arr,l,m)\\n        c+=self.mergeSort(arr,m+1,r)\\n        c+=self.merge(arr,l,m,r)\\n        return c\\n```"]}
{"id": "945", "ref_py": ["def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        \\n        ", "def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        \\n        ", "def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        \\n        "]}
{"id": "946", "ref_py": ["def kthGrammar(self, n: int, k: int) -> int:\\n        if n == 1:\\n            return 0\\n        if k % 2 == 0:\\n            return 1 if self.kthGrammar(n-1, k//2) == 0 else 0\\n        else:\\n            return 0 if self.kthGrammar(n-1, (k+1)//2) == 0 else 1\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int kthGrammar(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }", "def kthGrammar(self, n: int, k: int) -> int:\\n        if n == 1:\\n            return 0\\n        x = 2 ** (n - 2)\\n        if k > x:\\n            return 1 ^ self.kthGrammar(n - 1, k - x)\\n        return self.kthGrammar(n - 1, k)", "def kthGrammar(self, n, k):\\n        "]}
{"id": "947", "ref_py": ["def numRabbits(self, answers: List[int]) -> int:\\n        count = Counter(answers)\\n        res = 0\\n        \\n        for k, v in count.items():\\n            groups = v \\n            res += groups * (k + 1)\\n            \\n        return res", "def numRabbits(self, answers: List[int]) -> int:\\n        count = Counter(answers)\\n        res = 0\\n        \\n        for k, v in count.items():\\n            groups = v \\n            res += groups * (k + 1)\\n            \\n        return res", "def numRabbits(self, answers: List[int]) -> int:\\n        count = Counter(answers)\\n        res = 0\\n        \\n        for k, v in count.items():\\n            groups = v \\n            res += groups * (k + 1)\\n            \\n        return res"]}
{"id": "948", "ref_py": ["def letterCasePermutation(self, s: str) -> List[str]:\\n        all_strings = []\\n        \\n        mapping = re.sub(\"[a-zA-Z]\", \"*\", s)    ", "def letterCasePermutation(self, s: str) -> List[str]:\\n        all_strings = []\\n        \\n        mapping = re.sub(\"[a-zA-Z]\", \"*\", s)    ", "def letterCasePermutation(self, s: str) -> List[str]:\\n        all_strings = []\\n        \\n        mapping = re.sub(\"[a-zA-Z]\", \"*\", s)    "]}
{"id": "949", "ref_py": ["def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n=len(graph)\\n        col=[-1]*n\\n        for i in range(n):\\n            if col[i]!=-1:\\n                continue", "def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        visited = [-1]*len(graph)\\n        d = {x:graph[x] for x in range(n)}\\n        for i in range(n):\\n            if visited[i] < 0:\\n                q = deque([[i,0]])\\n                visited[i] = 0\\n                while q:\\n                    curr, time = q.popleft()\\n                    for vtx in d[curr]:\\n                        if visited[vtx] == -1:\\n                            q.append([vtx, time+1])\\n                            visited[vtx] = time+1\\n                        elif (time+1-visited[vtx])%2 == 1:\\n                            return False\\n        return True", "def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        visited = [-1]*len(graph)\\n        d = {x:graph[x] for x in range(n)}\\n        for i in range(n):\\n            if visited[i] < 0:\\n                q = deque([[i,0]])\\n                visited[i] = 0\\n                while q:\\n                    curr, time = q.popleft()\\n                    for vtx in d[curr]:\\n                        if visited[vtx] == -1:\\n                            q.append([vtx, time+1])\\n                            visited[vtx] = time+1\\n                        elif (time+1-visited[vtx])%2 == 1:\\n                            return False\\n        return True"]}
{"id": "950", "ref_py": ["def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\tif len(arr) > 2:\\n\\t\\t\\tres = []  ", "def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\tif len(arr) > 2:\\n\\t\\t\\tres = []  ", "def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\tif len(arr) > 2:\\n\\t\\t\\tres = []  "]}
{"id": "951", "ref_py": ["def dp(self, cur, price, step):\\n        if cur == self.dst: return price\\n        if step == 0: return inf\\n        \\n        if self.memo[cur][step]: return self.memo[cur][step]\\n        \\n        res = inf\\n        for item in self.graph[cur]:\\n            neighbor, cost = item[0], item[1]\\n            res = min(res, self.dp(neighbor, price+cost, step-1))\\n            \\n        self.memo[cur][step] = res\\n        return res\\n    \\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        self.dst = dst\\n        self.graph = {key: [] for key in range(n)}\\n        for flight in flights:\\n            self.graph[flight[0]].append((flight[1], flight[2]))\\n        \\n        self.memo = [[None for _ in range(k+2)] for _ in range(n)]\\n        \\n        res = self.dp(src, 0, k+1)\\n        res = res if res != inf else -1\\n        return res\\n```", "def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        adj = [[] for _ in range(n)]\\n        for flight in flights:\\n            adj[flight[0]].append((flight[1], flight[2]))\\n        \\n        q = [(src, 0)]\\n        minCost = [float(\\'inf\\') for _ in range(n)]\\n        stops = 0\\n        \\n        while q and stops <= k:\\n            size = len(q)\\n            for i in range(size):\\n                currNode, cost = q.pop(0)\\n                for neighbour, price in adj[currNode]:\\n                    if price + cost >= minCost[neighbour]:\\n                        continue\\n                    minCost[neighbour] = price + cost\\n                    q.append((neighbour, minCost[neighbour]))\\n            stops += 1\\n        \\n        return -1 if minCost[dst] == float(\\'inf\\') else minCost[dst]", "def findCheapestPrice(self, n, flights, src, dst, k):\\n        dp = [[sys.maxsize for _ in range(n)] for _ in range(k+2)]\\n        for i in range(k+2):\\n            dp[i][src] = 0\\n        for i in range(1, k+2):\\n            for f in flights:\\n                if dp[i-1][f[0]] != sys.maxsize:\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i-1][f[0]] + f[2])\\n        return dp[k+1][dst] if dp[k+1][dst] != sys.maxsize else -1\\n        \\n```"]}
{"id": "952", "ref_py": ["def rotatedDigits(self, n: int) -> int:", "def rotatedDigits(self, n: int) -> int:", "def rotatedDigits(self, n: int) -> int:"]}
{"id": "953", "ref_py": ["def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:\\n        player_distance = abs(target[0]) + abs(target[1])", "def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:\\n        player_distance = abs(target[0]) + abs(target[1])", "def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:\\n        player_distance = abs(target[0]) + abs(target[1])"]}
{"id": "954", "ref_py": ["def numTilings(self, n):\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp, dpa = [1, 2] + [0] * n, [1] * n\\n        for i in range(2, n):\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007\\n        return dp[n - 1]\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for (int i = 3; i < n; i ++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 2]; dp[0] = 1; dp[1] = 2;\\n        long[] dpa = new long[n + 2]; dpa[1] = 1;\\n        for (int i = 2; i < n; i ++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\\n**C/C++**\\n```\\nint numTilings(int n) {\\n    unsigned int dp[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n    for (int i = 3; i < n; i ++) {\\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\\n```\\nint numTilings(int n){\\n    if (n == 1) return 1;\\n    unsigned int dp[n]; dp[0] = 1; dp[1] = 2;\\n    unsigned int dpa[n]; dpa[1] = 1;\\n    for (int i = 2; i < n; i ++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n        dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```", "def numTilings(self, n: int) -> int:\\n        full_0, full_1, incomp_1 = 1, 2, 2\\n        for i in range(2, n):\\n            full_0, full_1, incomp_1 = full_1, full_0 + full_1 + incomp_1, 2 * full_0 + incomp_1\\n        return full_1 % (10 ** 9 + 7) if n >= 2 else 1\\n```", "def numTilings(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        if n < 2: return dp[n]\\n            \\n        dp[2] = 2\\n        mod = 10**9 + 7\\n        \\n        for i in range(3, n + 1):\\n            dp[i] = (2*dp[i - 1] + dp[i - 3]) % mod\\n            \\n        return dp[n]\\n        \\n        \\n        \\n"]}
{"id": "955", "ref_py": ["def customSortString(self, order: str, s: str) -> str:\\n        s_count = Counter(s)\\n        \\n        result = \\'\\'.join([char * s_count[char] for char in order])\\n        \\n        for char, freq in s_count.items():\\n            if char not in order:\\n                result += char * freq\\n        \\n        return result", "def customSortString(self, S, T):\\n            \\n        from collections import Counter\\n\\t\\t\\n        result = \"\"\\n        order_count = Counter(T)\\n        \\n        for key in S:\\n            if key in order_count:\\n                result = result + key * order_count[key]\\n                order_count[key] = 0\\n        \\n        for key in order_count:\\n            if order_count[key] > 0:\\n                result = result + key*order_count[key]\\n        \\n        return result\\n        \\n        \\n```", "def customSortString(self, S, T):\\n            \\n        from collections import Counter\\n\\t\\t\\n        result = \"\"\\n        order_count = Counter(T)\\n        \\n        for key in S:\\n            if key in order_count:\\n                result = result + key * order_count[key]\\n                order_count[key] = 0\\n        \\n        for key in order_count:\\n            if order_count[key] > 0:\\n                result = result + key*order_count[key]\\n        \\n        return result\\n        \\n        \\n```"]}
{"id": "956", "ref_py": ["def numMatchingSubseq(self, s: str, words: List[str]) -> int:\\n        def issubseq(s,t):\\n            stack = []\\n            for i in t:\\n                stack.append(i)\\n            \\n            n = len(s)\\n            for i in range(n-1,-1,-1):\\n                if not stack:\\n                    return True\\n                if stack[-1] == s[i]:\\n                    stack.pop()\\n            return stack == []\\n        \\n        \\n        hashmap = {}\\n        \\n        count = 0\\n        for word in words:\\n            if word not in hashmap:\\n                if issubseq(s,word):\\n                    count += 1\\n                    hashmap[word] = True\\n                else:\\n                    hashmap[word] = False\\n            else:\\n                if hashmap[word]:\\n                    count += 1\\n        return count\\n```", "def numMatchingSubseq(self, s: str, words: List[str]) -> int:\\n        def issubseq(s,t):\\n            stack = []\\n            for i in t:\\n                stack.append(i)\\n            \\n            n = len(s)\\n            for i in range(n-1,-1,-1):\\n                if not stack:\\n                    return True\\n                if stack[-1] == s[i]:\\n                    stack.pop()\\n            return stack == []\\n        \\n        \\n        hashmap = {}\\n        \\n        count = 0\\n        for word in words:\\n            if word not in hashmap:\\n                if issubseq(s,word):\\n                    count += 1\\n                    hashmap[word] = True\\n                else:\\n                    hashmap[word] = False\\n            else:\\n                if hashmap[word]:\\n                    count += 1\\n        return count\\n```", "def numMatchingSubseq(self, s: str, words: List[str]) -> int:\\n        def issubseq(s,t):\\n            stack = []\\n            for i in t:\\n                stack.append(i)\\n            \\n            n = len(s)\\n            for i in range(n-1,-1,-1):\\n                if not stack:\\n                    return True\\n                if stack[-1] == s[i]:\\n                    stack.pop()\\n            return stack == []\\n        \\n        \\n        hashmap = {}\\n        \\n        count = 0\\n        for word in words:\\n            if word not in hashmap:\\n                if issubseq(s,word):\\n                    count += 1\\n                    hashmap[word] = True\\n                else:\\n                    hashmap[word] = False\\n            else:\\n                if hashmap[word]:\\n                    count += 1\\n        return count\\n```"]}
{"id": "957", "ref_py": ["def validTicTacToe(self, board: List[str]) -> bool:\\n        ", "def validTicTacToe(self, board: List[str]) -> bool:\\n        ", "def validTicTacToe(self, board: List[str]) -> bool:\\n        "]}
{"id": "958", "ref_py": ["def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\\n        ans, low, mid = 0, 0, 0\\n        for num in nums:\\n            if num > right: mid = 0\\n            else:\\n                mid += 1\\n                ans += mid\\n            if num >= left: low = 0\\n            else:\\n                low += 1\\n                ans -= low\\n        return ans\\n```", "def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\\n        ans, low, mid = 0, 0, 0\\n        for num in nums:\\n            if num > right: mid = 0\\n            else:\\n                mid += 1\\n                ans += mid\\n            if num >= left: low = 0\\n            else:\\n                low += 1\\n                ans -= low\\n        return ans\\n```", "def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\\n        ans, low, mid = 0, 0, 0\\n        for num in nums:\\n            if num > right: mid = 0\\n            else:\\n                mid += 1\\n                ans += mid\\n            if num >= left: low = 0\\n            else:\\n                low += 1\\n                ans -= low\\n        return ans\\n```"]}
{"id": "959", "ref_py": ["defined sturcture, the general-case DAG is unpredictable. This difference though will have no impact on the DFS algorithm and will only materlize in the time complexity of the algorithm. **More on that later.**", "defined sturcture, the general-case DAG is unpredictable. This difference though will have no impact on the DFS algorithm and will only materlize in the time complexity of the algorithm. **More on that later.**", "defined sturcture, the general-case DAG is unpredictable. This difference though will have no impact on the DFS algorithm and will only materlize in the time complexity of the algorithm. **More on that later.**"]}
{"id": "960", "ref_py": ["def champagneTower(self, poured, query_row, query_glass):\\n        mat = [[0.0] * 101 for _ in range(101)]\\n        mat[0][0] = poured\\n        \\n        for i in range(100):\\n            for j in range(i + 1):\\n                if mat[i][j] > 1:\\n                    overflow = (mat[i][j] - 1) / 2.0\\n                    mat[i + 1][j] += overflow\\n                    mat[i + 1][j + 1] += overflow\\n                    mat[i][j] = 1.0\\n        \\n        return mat[query_row][query_glass]\\n```", "def iteration(self, values: List[float]) -> List[float]:\\n    next_values = [0] * (len(values) + 1)\\n    for p, v in enumerate(values):\\n      if v > 1:\\n        v_ = (v - 1) / 2\\n        next_values[p] += v_\\n        next_values[p + 1] += v_\\n    \\n    return next_values\\n        ", "def iteration(self, values: List[float]) -> List[float]:\\n    next_values = [0] * (len(values) + 1)\\n    for p, v in enumerate(values):\\n      if v > 1:\\n        v_ = (v - 1) / 2\\n        next_values[p] += v_\\n        next_values[p + 1] += v_\\n    \\n    return next_values\\n        "]}
{"id": "961", "ref_py": ["def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\\n        n = len(graph)\\n        visited = [False] * n\\n        unsafe = [0] * n", "def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\\n        n=len(graph)\\n        safe={}\\n        ans=[]\\n        def dfs(i):\\n            if i in safe:\\n                return safe[i]", "def eventualSafeNodes(self, graph: list[list[int]]) -> list[int]:\\n        DiGraph = list[list[int]]"]}
{"id": "962", "ref_py": ["def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```python []\\nclass Solution:\\n    def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```C", "def countBits(self, num: int) -> List[int]:\\n    counter = [0]\\n    for i in range(1, num+1):\\n        counter.append(counter[i >> 1] + i % 2)\\n    return counter\\n```", "def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```python []\\nclass Solution:\\n    def countBits(self, n: int) -> List[int]:\\n        sum=0\\n        list1 = []\\n        for i in range(n+1):\\n            sum=bin(i).count(\"1\")\\n            list1.append(sum)\\n        return list1\\n```\\n```C"]}
{"id": "963", "ref_py": ["def __init__(self):\\n        self.mp = {}", "def soupServings(self, n: int) -> float:\\n        m = ceil(n / 25)\\n        return self.empty_prob(m, m) if m < 200 else 1.0\\n    \\n    @cache\\n    def empty_prob(self, a: int, b: int) -> float:\\n        match a <= 0, b <= 0:\\n            case True , True : return 0.5\\n            case True , False: return 1.0\\n            case False, True : return 0.0\\n            case False, False: return sum(\\n                self.empty_prob(a - da, b - db)\\n                for da, db in ((4, 0), (3, 1), (2, 2), (1, 3)) \\n            ) / 4", "def soupServings(self, n: int) -> float:\\n        if n>4275:\\n            return 1\\n        n/=25    \\n        @cache\\n        def dfs(a,b):\\n            if a<=0 and b>0:\\n                return 1"]}
{"id": "964", "ref_py": ["define helper functions.", "def expressiveWords(self, S: str, words: List[str]) -> int:\\n        def process(st):\\n            if not st:\\n                return [], []\\n            chars, counts = [st[0]], [1]\\n            \\n            for i in range(1, len(st)):\\n                if st[i] == chars[-1]:\\n                    counts[-1] += 1\\n                else:\\n                    chars.append(st[i])\\n                    counts.append(1)\\n            return chars, counts\\n                ", "def expressiveWords(self, S: str, words: List[str]) -> int:\\n        def process(st):\\n            if not st:\\n                return [], []\\n            chars, counts = [st[0]], [1]\\n            \\n            for i in range(1, len(st)):\\n                if st[i] == chars[-1]:\\n                    counts[-1] += 1\\n                else:\\n                    chars.append(st[i])\\n                    counts.append(1)\\n            return chars, counts\\n                "]}
{"id": "965", "ref_py": ["def setZeroes(self, matrix: List[List[int]]) -> None:\\n        ", "def setZeroes(self, matrix: List[List[int]]) -> None:\\n        ", "def setZeroes(self, matrix: List[List[int]]) -> None:\\n        "]}
{"id": "966", "ref_py": ["def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        n=len(nums)\\n        dp=[[[-1 for _ in range(k+1)] for _ in range(n+1)] for _ in range(n+1)]\\n        \\n        def recur(i,j,par):\\n            ", "def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\tn = len(nums)\\n\\tpre = [0]\\n\\tfor i in nums:\\n\\t\\tpre.append(pre[-1] + i)\\n\\tdef solve(i, k):\\n\\t\\tif(k == 1): return sum(nums[i:])/(n-i)", "def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\tn = len(nums)\\n\\tpre = [0]\\n\\tfor i in nums:\\n\\t\\tpre.append(pre[-1] + i)\\n\\tdef solve(i, k):\\n\\t\\tif(k == 1): return sum(nums[i:])/(n-i)"]}
{"id": "967", "ref_py": ["def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif root:\\n\\t\\troot.left = self.pruneTree(root.left)\\n\\t\\troot.right = self.pruneTree(root.right)\\n\\t\\tif not root.left and not root.right and root.val == 0:\\n\\t\\t\\treturn None\\n\\treturn root\\n```", "def explore_node(self, node):\\n        if node is None:\\n            return None\\n        \\n        node.left = self.explore_node(node.left)\\n        node.right = self.explore_node(node.right)\\n        \\n        if node.left is None and node.right is None and node.val != 1:\\n            node = None\\n        \\n        return node\\n        \\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root = self.explore_node(root)\\n        \\n        return root\\n```", "def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif root:\\n\\t\\troot.left = self.pruneTree(root.left)\\n\\t\\troot.right = self.pruneTree(root.right)\\n\\t\\tif not root.left and not root.right and root.val == 0:\\n\\t\\t\\treturn None\\n\\treturn root\\n```"]}
{"id": "968", "ref_py": ["define a helper function (**parse**) which will take a string (**str**) and only pass on valid options for another helper (**process**) to handle.", "definitely doesn\\'t deserve so many downvotes. The edge cases may seem bad initially, but in code it\\'s only a couple `if elif` conditionals to make this pass.", "definitely doesn\\'t deserve so many downvotes. The edge cases may seem bad initially, but in code it\\'s only a couple `if elif` conditionals to make this pass."]}
{"id": "969", "ref_py": ["def minDeletionSize(self, strs):\\n        ", "def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n=len(strs),len(strs[0])\\n        c=0\\n        for i in range(n):\\n            for j in range(m-1):\\n                if ord(strs[j][i])>ord(strs[j+1][i]):\\n                    c+=1\\n                    break\\n        return c\\n```", "def minDeletionSize(self, strs):\\n        "]}
{"id": "970", "ref_py": ["define branches of prefix (or in this case suffix) data. In this way, entries that share the same prefix will be grouped together and easy to identify.", "def minimumLengthEncoding(self, words: List[str]) -> int:\\n        words.sort(key=len, reverse=True)\\n        res = []\\n        for suffix in words:\\n            if not any(word.endswith(suffix) for word in res):  ", "def minimumLengthEncoding(self, words: List[str]) -> int:\\n        words.sort(key=len, reverse=True)\\n        res = []\\n        for suffix in words:\\n            if not any(word.endswith(suffix) for word in res):  "]}
{"id": "971", "ref_py": ["def flipgame(self, f, b):\\n        same = {x for x, y in zip(f, b) if x == y}\\n        return min([i for i in f + b if i not in same] or [0])\\n```", "def flipgame(self, f, b):\\n        same = {x for x, y in zip(f, b) if x == y}\\n        return min([i for i in f + b if i not in same] or [0])\\n```", "def flipgame(self, f, b):\\n        same = {x for x, y in zip(f, b) if x == y}\\n        return min([i for i in f + b if i not in same] or [0])\\n```"]}
{"id": "972", "ref_py": ["def numFactoredBinaryTrees(self, arr):\\n        mod = int(1e9 + 7)\\n        arr.sort()\\n        ans = 0\\n        map = {}", "def numFactoredBinaryTrees(self, arr):\\n        mod = int(1e9 + 7)\\n        arr.sort()\\n        ans = 0\\n        map = {}", "def numFactoredBinaryTrees(self, arr):\\n        mod = int(1e9 + 7)\\n        arr.sort()\\n        ans = 0\\n        map = {}"]}
{"id": "973", "ref_py": ["def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    ", "def numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        ", "def numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        "]}
{"id": "974", "ref_py": ["def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) ", "def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        ", "def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        "]}
{"id": "975", "ref_py": ["define a helper function isSubsequence(a: str, b: str) -> bool that returns True if string a is a subsequence of string b, and False otherwise. We do this by iterating through each character in b, and for each character that matches the current character in a, we move to the next character in a. If we\\'ve successfully matched all characters in a, then it is a subsequence of b.", "def findLUSlength(self, strs: List[str]) -> int:\\n\\tdef isSub(x, y):\\n\\t\\ti = j = 0\\n\\t\\twhile(i<len(x) and j<len(y)):\\n\\t\\t\\tif(x[i] == y[j]):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\treturn i == len(x)\\n\\tstrs.sort(key = len, reverse = True)\\n\\tn = len(strs)\\n\\tfor i in range(n):\\n\\t\\tp = 1\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(i != j and isSub(strs[i], strs[j])):\\n\\t\\t\\t\\tp = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tif(p):\\n\\t\\t\\treturn len(strs[i])\\n", "def findLUSlength(self, strs: List[str]) -> int:\\n\\tdef isSub(x, y):\\n\\t\\ti = j = 0\\n\\t\\twhile(i<len(x) and j<len(y)):\\n\\t\\t\\tif(x[i] == y[j]):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\treturn i == len(x)\\n\\tstrs.sort(key = len, reverse = True)\\n\\tn = len(strs)\\n\\tfor i in range(n):\\n\\t\\tp = 1\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(i != j and isSub(strs[i], strs[j])):\\n\\t\\t\\t\\tp = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tif(p):\\n\\t\\t\\treturn len(strs[i])\\n"]}
{"id": "976", "ref_py": ["def checker(strinPtr, source):\\n            for char in source:\\n                if s[strinPtr] != char:\\n                    return False\\n                strinPtr += 1\\n            return True\\n```\\nAs we iterate over the original string, if the current visiting index is in the map we have, call the helper function to check if it matches. If it matches, build the result string with the string in the targets, otherwise, build with value that we are checking. The string pointer jumps as much as length of the source, so we are not revisiting any character we already checked from helper function.\\n```\\n        res = \"\"\\n        strPtr = 0\\n        while strPtr < len(s):\\n            if strPtr in idxMap:\\n                if checker(strPtr, sources[idxMap[strPtr]]):\\n                    res += targets[idxMap[strPtr]]\\n                    strPtr += len(sources[idxMap[strPtr]])\\n                    continue\\n            res += s[strPtr]\\n            strPtr += 1\\n```", "def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:\\n\\tlookup = {i: (src, tgt) for i, src, tgt in zip(indexes, sources, targets)}\\n\\ti, result = 0, \"\"\\n\\twhile i < len(S):\\n\\t\\tif i in lookup and S[i:].startswith(lookup[i][0]):\\n\\t\\t\\tresult += lookup[i][1]\\n\\t\\t\\ti += len(lookup[i][0])\\n\\t\\telse:\\n\\t\\t\\tresult += S[i]\\n\\t\\t\\ti += 1\\n\\treturn result\\n```", "def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:    \\n        result=list(s)\\n        for begin,src,tgt in zip(indices,sources,targets):\\n            if s.startswith(src,begin):\\n                result[begin]=tgt\\n                for idx in range(begin+1,begin+len(src)):\\n                    result[idx]=\\'\\'\\n        return \\'\\'.join(result)\\n```"]}
{"id": "977", "ref_py": ["def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\\n        \\n        def get_row_mask(row: List[int]) -> int:        \\n            \\n            mask = 0\\n            for shift, value in enumerate(reversed(row)):\\n                if value:\\n                    mask |= 1 << shift\\n            \\n            return mask\\n        \\n        img1_row_masks = [get_row_mask(row) for row in img1]\\n        img2_row_masks = [get_row_mask(row) for row in img2]\\n        n = len(img1)\\n        largest_overlap = 0\\n        \\n        for shift in range(n): \\n            for start_row in range(n):\\n                \\n                total_overlap_1 = 0\\n                total_overlap_2 = 0\\n                total_overlap_3 = 0\\n                total_overlap_4 = 0\\n                \\n                for idx in range(start_row, n): \\n                    \\n                    total_overlap_1 += (\\n                        img1_row_masks[idx - start_row] >> shift & img2_row_masks[idx]\\n                    ).bit_count()\\n                    \\n                    total_overlap_2 += (\\n                        img1_row_masks[idx] >> shift & img2_row_masks[idx - start_row]\\n                    ).bit_count()\\n                    \\n                    total_overlap_3 += (\\n                        img1_row_masks[idx - start_row] & img2_row_masks[idx] >> shift\\n                    ).bit_count()\\n                    \\n                    total_overlap_4 += (\\n                        img1_row_masks[idx] & img2_row_masks[idx - start_row] >> shift\\n                    ).bit_count()\\n                    \\n                    \\n                largest_overlap = max(\\n                    largest_overlap, \\n                    total_overlap_1,\\n                    total_overlap_2,\\n                    total_overlap_3,\\n                    total_overlap_4,\\n                )                    ", "def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\\n        \\n        def get_row_mask(row: List[int]) -> int:        \\n            \\n            mask = 0\\n            for shift, value in enumerate(reversed(row)):\\n                if value:\\n                    mask |= 1 << shift\\n            \\n            return mask\\n        \\n        img1_row_masks = [get_row_mask(row) for row in img1]\\n        img2_row_masks = [get_row_mask(row) for row in img2]\\n        n = len(img1)\\n        largest_overlap = 0\\n        \\n        for shift in range(n): \\n            for start_row in range(n):\\n                \\n                total_overlap_1 = 0\\n                total_overlap_2 = 0\\n                total_overlap_3 = 0\\n                total_overlap_4 = 0\\n                \\n                for idx in range(start_row, n): \\n                    \\n                    total_overlap_1 += (\\n                        img1_row_masks[idx - start_row] >> shift & img2_row_masks[idx]\\n                    ).bit_count()\\n                    \\n                    total_overlap_2 += (\\n                        img1_row_masks[idx] >> shift & img2_row_masks[idx - start_row]\\n                    ).bit_count()\\n                    \\n                    total_overlap_3 += (\\n                        img1_row_masks[idx - start_row] & img2_row_masks[idx] >> shift\\n                    ).bit_count()\\n                    \\n                    total_overlap_4 += (\\n                        img1_row_masks[idx] & img2_row_masks[idx - start_row] >> shift\\n                    ).bit_count()\\n                    \\n                    \\n                largest_overlap = max(\\n                    largest_overlap, \\n                    total_overlap_1,\\n                    total_overlap_2,\\n                    total_overlap_3,\\n                    total_overlap_4,\\n                )                    ", "def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\\n        \\n        def get_row_mask(row: List[int]) -> int:        \\n            \\n            mask = 0\\n            for shift, value in enumerate(reversed(row)):\\n                if value:\\n                    mask |= 1 << shift\\n            \\n            return mask\\n        \\n        img1_row_masks = [get_row_mask(row) for row in img1]\\n        img2_row_masks = [get_row_mask(row) for row in img2]\\n        n = len(img1)\\n        largest_overlap = 0\\n        \\n        for shift in range(n): \\n            for start_row in range(n):\\n                \\n                total_overlap_1 = 0\\n                total_overlap_2 = 0\\n                total_overlap_3 = 0\\n                total_overlap_4 = 0\\n                \\n                for idx in range(start_row, n): \\n                    \\n                    total_overlap_1 += (\\n                        img1_row_masks[idx - start_row] >> shift & img2_row_masks[idx]\\n                    ).bit_count()\\n                    \\n                    total_overlap_2 += (\\n                        img1_row_masks[idx] >> shift & img2_row_masks[idx - start_row]\\n                    ).bit_count()\\n                    \\n                    total_overlap_3 += (\\n                        img1_row_masks[idx - start_row] & img2_row_masks[idx] >> shift\\n                    ).bit_count()\\n                    \\n                    total_overlap_4 += (\\n                        img1_row_masks[idx] & img2_row_masks[idx - start_row] >> shift\\n                    ).bit_count()\\n                    \\n                    \\n                largest_overlap = max(\\n                    largest_overlap, \\n                    total_overlap_1,\\n                    total_overlap_2,\\n                    total_overlap_3,\\n                    total_overlap_4,\\n                )                    "]}
{"id": "978", "ref_py": ["def new21Game(self, n: int, k: int, maxPts: int) -> float:\\n        if k==0 or n>=k+maxPts:\\n            return 1", "def new21Game(self, n: int, k: int, maxPts: int) -> float:\\n        if k==0 or n>=k+maxPts:\\n            return 1", "def new21Game(self, n: int, k: int, maxPts: int) -> float:\\n        if k==0 or n>=k+maxPts:\\n            return 1"]}
{"id": "979", "ref_py": ["def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       ", "def pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))", "def pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))"]}
{"id": "980", "ref_py": ["def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        n,m=len(grid),len(grid[0])\\n        magic_square=[\\n            [4,3,8],\\n            [9,5,1],\\n            [2,7,6]\\n        ]\\n        def grid_Rotation(grid,k):\\n            a=grid\\n            for _ in range(k):\\n                a=list(zip(*a[::-1]))\\n            return a\\n        def number_Of_Rotations(k):\\n            if k==4: return 0\\n            if k==2: return 1\\n            if k==6: return 2\\n            if k==8: return 3\\n            return -1\\n        def is_Identical(grid1,grid2):\\n            for i in range(3):\\n                for j in range(3):\\n                    if grid1[i][j]!=grid2[i][j]:\\n                        return False\\n            return True\\n        def is_transpose(grid1,grid2):\\n            for i in range(3):\\n                for j in range(3):\\n                    if grid1[i][j]!=grid2[j][i]:\\n                        return False\\n            return True\\n        def is_Magic_Square(i,j):\\n            if grid[i][j]!=5:\\n                return False\\n            if i<1 or i>n-2 or j<1 or j>m-2:\\n                return False\\n            k=number_Of_Rotations(grid[i-1][j-1])\\n            if k==-1:\\n                return False\\n            rotated=grid_Rotation(magic_square,k)\\n            return (is_Identical(rotated,[grid[i+x][j-1:j+2] for x in [-1,0,1]])) or (is_transpose(rotated,[grid[i+x][j-1:j+2] for x in [-1,0,1]]))", "def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        n,m=len(grid),len(grid[0])\\n        magic_square=[\\n            [4,3,8],\\n            [9,5,1],\\n            [2,7,6]\\n        ]\\n        def grid_Rotation(grid,k):\\n            a=grid\\n            for _ in range(k):\\n                a=list(zip(*a[::-1]))\\n            return a\\n        def number_Of_Rotations(k):\\n            if k==4: return 0\\n            if k==2: return 1\\n            if k==6: return 2\\n            if k==8: return 3\\n            return -1\\n        def is_Identical(grid1,grid2):\\n            for i in range(3):\\n                for j in range(3):\\n                    if grid1[i][j]!=grid2[i][j]:\\n                        return False\\n            return True\\n        def is_transpose(grid1,grid2):\\n            for i in range(3):\\n                for j in range(3):\\n                    if grid1[i][j]!=grid2[j][i]:\\n                        return False\\n            return True\\n        def is_Magic_Square(i,j):\\n            if grid[i][j]!=5:\\n                return False\\n            if i<1 or i>n-2 or j<1 or j>m-2:\\n                return False\\n            k=number_Of_Rotations(grid[i-1][j-1])\\n            if k==-1:\\n                return False\\n            rotated=grid_Rotation(magic_square,k)\\n            return (is_Identical(rotated,[grid[i+x][j-1:j+2] for x in [-1,0,1]])) or (is_transpose(rotated,[grid[i+x][j-1:j+2] for x in [-1,0,1]]))", "def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        n,m=len(grid),len(grid[0])\\n        magic_square=[\\n            [4,3,8],\\n            [9,5,1],\\n            [2,7,6]\\n        ]\\n        def grid_Rotation(grid,k):\\n            a=grid\\n            for _ in range(k):\\n                a=list(zip(*a[::-1]))\\n            return a\\n        def number_Of_Rotations(k):\\n            if k==4: return 0\\n            if k==2: return 1\\n            if k==6: return 2\\n            if k==8: return 3\\n            return -1\\n        def is_Identical(grid1,grid2):\\n            for i in range(3):\\n                for j in range(3):\\n                    if grid1[i][j]!=grid2[i][j]:\\n                        return False\\n            return True\\n        def is_transpose(grid1,grid2):\\n            for i in range(3):\\n                for j in range(3):\\n                    if grid1[i][j]!=grid2[j][i]:\\n                        return False\\n            return True\\n        def is_Magic_Square(i,j):\\n            if grid[i][j]!=5:\\n                return False\\n            if i<1 or i>n-2 or j<1 or j>m-2:\\n                return False\\n            k=number_Of_Rotations(grid[i-1][j-1])\\n            if k==-1:\\n                return False\\n            rotated=grid_Rotation(magic_square,k)\\n            return (is_Identical(rotated,[grid[i+x][j-1:j+2] for x in [-1,0,1]])) or (is_transpose(rotated,[grid[i+x][j-1:j+2] for x in [-1,0,1]]))"]}
{"id": "981", "ref_py": ["def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output", "def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output", "def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output"]}
{"id": "982", "ref_py": ["def splitIntoFibonacci(self, s: str) -> list[int]:\\n        n = len(s)\\n        A = [*map(int, s)]", "def splitIntoFibonacci(self, s: str) -> list[int]:\\n        n = len(s)\\n        A = [*map(int, s)]", "def splitIntoFibonacci(self, s: str) -> list[int]:\\n        n = len(s)\\n        A = [*map(int, s)]"]}
{"id": "983", "ref_py": ["def longestMountain(self, arr: List[int]) -> int:\\n        \\n        @cache\\n        def get_left(i):\\n            if i - 1 >= 0 and arr[i - 1] < arr[i]:\\n                return get_left(i - 1) + 1\\n            return 0", "def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```", "def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```"]}
{"id": "984", "ref_py": ["def isNStraightHand(self, hand, groupSize):\\n       count_map = {}\\n        for card in hand:\\n            count_map[card] = count_map.get(card, 0) + 1\\n        \\n        hand.sort()\\n        \\n        for i in range(len(hand)):\\n            if count_map[hand[i]] == 0:\\n                continue\\n            \\n            for j in range(groupSize):\\n                curr_card = hand[i] + j\\n                \\n                if count_map.get(curr_card, 0) == 0:\\n                    return False\\n                \\n                count_map[curr_card] -= 1\\n        \\n        return True\\n```\\n", "def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\\n\\t\\t", "def isNStraightHand(self, hand, groupSize):\\n       count_map = {}\\n        for card in hand:\\n            count_map[card] = count_map.get(card, 0) + 1\\n        \\n        hand.sort()\\n        \\n        for i in range(len(hand)):\\n            if count_map[hand[i]] == 0:\\n                continue\\n            \\n            for j in range(groupSize):\\n                curr_card = hand[i] + j\\n                \\n                if count_map.get(curr_card, 0) == 0:\\n                    return False\\n                \\n                count_map[curr_card] -= 1\\n        \\n        return True\\n```\\n"]}
{"id": "985", "ref_py": ["def shiftingLetters(self, s: str, shifts: List[int]) -> str:\\n        ans, shift = \\'\\', 0\\n        for i in range(len(shifts) -1, -1, -1):\\n            ans += chr((ord(s[i]) - ord(\\'a\\') + shift+shifts[i]) % 26 + ord(\\'a\\'))\\n            shift += shifts[i]\\n        \\n        return ans[::-1]\\n```", "def shiftingLetters(self, s: str, shifts: List[int]) -> str:\\n        ans, shift = \\'\\', 0\\n        for i in range(len(shifts) -1, -1, -1):\\n            ans += chr((ord(s[i]) - ord(\\'a\\') + shift+shifts[i]) % 26 + ord(\\'a\\'))\\n            shift += shifts[i]\\n        \\n        return ans[::-1]\\n```", "def shiftingLetters(self, s: str, shifts: List[int]) -> str:\\n        ans, shift = \\'\\', 0\\n        for i in range(len(shifts) -1, -1, -1):\\n            ans += chr((ord(s[i]) - ord(\\'a\\') + shift+shifts[i]) % 26 + ord(\\'a\\'))\\n            shift += shifts[i]\\n        \\n        return ans[::-1]\\n```"]}
{"id": "986", "ref_py": ["def maxDistToClosest(self, seats):\\n        pre_zeros, suf_zeros, max_zeros, zeros = -1, -1, -1, 0\\n        for seat in seats:\\n            if seat == 0: zeros += 1\\n            else:\\n                if pre_zeros == -1: \\n                    pre_zeros = zeros\\n                else:\\n                    max_zeros = max(max_zeros, zeros)\\n                zeros = 0\\n        suf_zeros = zeros\\n        return max(pre_zeros, suf_zeros, (max_zeros + 1) // 2)\\n```", "def maxDistToClosest(self, seats: List[int]) -> int:\\n        n = len(seats)\\n        empty, result, idx1, idx2 = 0, 0, -1, -1\\n        \\n        for i in range(n):\\n            if seats[i] == 1:\\n                empty = 0\\n                if idx1 == -1: idx1 = i\\n                idx2 = i\\n            else:\\n                empty += 1\\n                result = max(result, (empty+1)//2)\\n        result = max(result, idx1, n-1-idx2)\\n        return result\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)", "def maxDistToClosest(self, seats):\\n        pre_zeros, suf_zeros, max_zeros, zeros = -1, -1, -1, 0\\n        for seat in seats:\\n            if seat == 0: zeros += 1\\n            else:\\n                if pre_zeros == -1: \\n                    pre_zeros = zeros\\n                else:\\n                    max_zeros = max(max_zeros, zeros)\\n                zeros = 0\\n        suf_zeros = zeros\\n        return max(pre_zeros, suf_zeros, (max_zeros + 1) // 2)\\n```"]}
{"id": "987", "ref_py": ["def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            ", "def loudAndRich(richer, quiet):\\n\\tg, loud = collections.defaultdict(set), [-1]*len(quiet)\\n\\tfor u, v in richer: g[v].add(u)\\n\\tdef dfs(node):\\n\\t\\tif loud[node] < 0: loud[node] = min([dfs(nei) for nei in g[node]]+[node], key=lambda x:quiet[x])\\n\\t\\treturn loud[node]\\n", "def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            "]}
{"id": "988", "ref_py": ["def peakIndexInMountainArray(self, arr: List[int]) -> int:\\n        i = 0\\n        j = len(arr) - 1\\n        n = len(arr)\\n        while i <= j:\\n            mid = (i + j) // 2\\n            if (mid == 0 or arr[mid - 1] < arr[mid]) and (mid == n - 1 or arr[mid + 1] < arr[mid]):\\n                return mid\\n            elif mid > 0 and arr[mid - 1] > arr[mid]:\\n                j = mid - 1\\n            else:\\n                i = mid + 1\\n        return -1", "def peakIndexInMountainArray(self, arr):\\n        \\n        ", "def peakIndexInMountainArray(self, arr: List[int]) -> int:\\n        i = 0\\n        j = len(arr) - 1\\n        n = len(arr)\\n        while i <= j:\\n            mid = (i + j) // 2\\n            if (mid == 0 or arr[mid - 1] < arr[mid]) and (mid == n - 1 or arr[mid + 1] < arr[mid]):\\n                return mid\\n            elif mid > 0 and arr[mid - 1] > arr[mid]:\\n                j = mid - 1\\n            else:\\n                i = mid + 1\\n        return -1"]}
{"id": "989", "ref_py": ["def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t", "def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t", "def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t"]}
{"id": "991", "ref_py": ["def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```", "def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```", "def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```"]}
{"id": "992", "ref_py": ["def mirrorReflection(self, p: int, q: int) -> int:", "def lcm(self, x, y):\\n        return x * y // self.gcd(x, y)", "def lcm(self, x, y):\\n        return x * y // self.gcd(x, y)"]}
{"id": "993", "ref_py": ["def matrixScore(self, grid: List[List[int]]) -> int:\\n        return sum(map(lambda pair : (pair[0] if pair[0] > (len(grid) / 2) else  (len(grid) - pair[0])) << (len(grid[0]) - pair[1] - 1),zip([sum([1 if i == 0 else v if grid[r][0] else -1*v+1 for r in range(len(grid)) for v in list([grid[r][i]])]) for i in range(len(grid[0]))],range(len(grid[0])))))\\n", "def matrixScore(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])", "def matrixScore(self, grid: List[List[int]]) -> int:\\n        return sum(map(lambda pair : (pair[0] if pair[0] > (len(grid) / 2) else  (len(grid) - pair[0])) << (len(grid[0]) - pair[1] - 1),zip([sum([1 if i == 0 else v if grid[r][0] else -1*v+1 for r in range(len(grid)) for v in list([grid[r][i]])]) for i in range(len(grid[0]))],range(len(grid[0])))))\\n"]}
{"id": "994", "ref_py": ["def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        parent = {}  ", "def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        parents = {}", "def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        parent = {}  "]}
{"id": "995", "ref_py": ["def __init__(self, x):\\n", "def subtreeWithAllDeepest(self, root):\\n        queue = [root]\\n        deepestRow = [root]\\n        while len(queue) > 0:\\n            temp = []\\n            for ele in queue:\\n                top = ele\\n                if top.left:\\n                    temp.append(top.left)\\n                if top.right:\\n                    temp.append(top.right)\\n            if temp: deepestRow = temp\\n            queue = temp\\n        if len(deepestRow) == 1: return deepestRow[0]\\n        else:\\n            return lowestCommonAncestor(root, deepestRow[0], deepestRow[-1])", "def subtreeWithAllDeepest(self, root):\\n        queue = [root]\\n        deepestRow = [root]\\n        while len(queue) > 0:\\n            temp = []\\n            for ele in queue:\\n                top = ele\\n                if top.left:\\n                    temp.append(top.left)\\n                if top.right:\\n                    temp.append(top.right)\\n            if temp: deepestRow = temp\\n            queue = temp\\n        if len(deepestRow) == 1: return deepestRow[0]\\n        else:\\n            return lowestCommonAncestor(root, deepestRow[0], deepestRow[-1])"]}
{"id": "996", "ref_py": ["def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True", "def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n", "def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)"]}
{"id": "997", "ref_py": ["def reorderedPowerOf2(self, n):\\n        \\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False", "def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```", "def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```"]}
{"id": "998", "ref_py": ["def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```", "def advantageCount(self, nums1, nums2):\\n        ", "def advantageCount(self, nums1, nums2):\\n        "]}
{"id": "999", "ref_py": ["def generateMatrix(self, n):\\n        ", "def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 ", "def generateMatrix(self, n):\\n        "]}
{"id": "1000", "ref_py": ["def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\\n        obs = set(tuple(o) for o in obstacles)\\n        x = y = a = out = 0\\n        move = {0:(0,1), 90:(1,0), 180:(0,-1), 270:(-1,0)}\\n        for c in commands:\\n            if c == -1:\\n                a += 90\\n            elif c == -2:\\n                a -= 90\\n            else:\\n                direction = a % 360\\n                dx, dy = move[direction]\\n                for _ in range(c):\\n                    if (x + dx, y + dy) in obs:\\n                        break\\n                    x += dx\\n                    y += dy\\n                out = max(out, x**2 + y**2)\\n        return out\\n```", "def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\\n        obs = set(tuple(o) for o in obstacles)\\n        x = y = a = out = 0\\n        move = {0:(0,1), 90:(1,0), 180:(0,-1), 270:(-1,0)}\\n        for c in commands:\\n            if c == -1:\\n                a += 90\\n            elif c == -2:\\n                a -= 90\\n            else:\\n                direction = a % 360\\n                dx, dy = move[direction]\\n                for _ in range(c):\\n                    if (x + dx, y + dy) in obs:\\n                        break\\n                    x += dx\\n                    y += dy\\n                out = max(out, x**2 + y**2)\\n        return out\\n```", "def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\\n        obs = set(tuple(o) for o in obstacles)\\n        x = y = a = out = 0\\n        move = {0:(0,1), 90:(1,0), 180:(0,-1), 270:(-1,0)}\\n        for c in commands:\\n            if c == -1:\\n                a += 90\\n            elif c == -2:\\n                a -= 90\\n            else:\\n                direction = a % 360\\n                dx, dy = move[direction]\\n                for _ in range(c):\\n                    if (x + dx, y + dy) in obs:\\n                        break\\n                    x += dx\\n                    y += dy\\n                out = max(out, x**2 + y**2)\\n        return out\\n```"]}
{"id": "1001", "ref_py": ["def minEatingSpeed(self, piles, h):\\n        left = 1\\n        right = max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if self.canEatAll(piles, mid, h):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n    \\n    def canEatAll(self, piles, speed, h):\\n        time = 0\\n        for pile in piles:\\n            time += (pile - 1) / speed + 1\\n            if time > h:\\n                return False\\n        return True", "def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        \\n        def isSufficientSpeed(cnt):\\n            return sum(ceil(i/cnt) for i in piles) <= h", "def minEatingSpeed(self, piles, h):\\n        low, high = 1, 10 ** 9\\n        while low <= high:\\n            k = (low + high) // 2\\n            if sum(math.ceil(1.0 * pile / k) for pile in piles) > h: low = k + 1\\n            else: high = k - 1\\n        return low\\n```"]}
{"id": "1002", "ref_py": ["def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)", "def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)", "def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)"]}
{"id": "1003", "ref_py": ["def decodeAtIndex(self, inputString: str, k: int) -> str:\\n        decoded_length = 0  ", "def decodeAtIndex(self, s, k):\\n        size = 0\\n        \\n        ", "def decodeAtIndex(self, inputString: str, k: int) -> str:\\n        decoded_length = 0  "]}
{"id": "1004", "ref_py": ["definitely exceed the boats rated capacity if it did with 1 in the first place. \\n3. Thus if the `people[hi]` cannot be seated with `people[lo]` in one boat then that means that people[hi] cannot form a pair with any of the remaining people, and we will thus stop looking for a partner for that person and give him a boat for him/her self.", "def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        start = 0\\n        end = len(people) - 1\\n        res = 0", "def numRescueBoats(self, people: List[int], limit: int) -> int:\\n        people.sort()\\n        left, right, boats = 0, len(people) - 1, 0\\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n            right -= 1\\n            boats += 1\\n        return boats"]}
{"id": "1005", "ref_py": ["default in AP and return TRUE.", "def canMakeArithmeticProgression(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        for x,y in zip(arr,arr[1:]):\\n            if y-x!=arr[1]-arr[0]:\\n                return False", "def canMakeArithmeticProgression(self, arr):\\n        arr.sort()  "]}
{"id": "1006", "ref_py": ["def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        \\n        ", "defaultdict\\n\\tclass DSU:\\n\\t\\tdef __init__(self,n):\\n\\t\\t\\tself.parent=[i for i in range(n+1)]\\n\\t\\tdef findPar(self,u):\\n\\t\\t\\tif self.parent[u]!=u:\\n\\t\\t\\t\\tself.parent[u]=self.findPar(self.parent[u])\\n\\t\\t\\treturn self.parent[u]\\n\\t\\tdef union(self,u,v):\\n\\t\\t\\tpu = self.findPar(u)\\n\\t\\t\\tpv = self.findPar(v)\\n\\t\\t\\tself.parent[pu] = pv", "defaultdict\\n\\tclass DSU:\\n\\t\\tdef __init__(self,n):\\n\\t\\t\\tself.parent=[i for i in range(n+1)]\\n\\t\\tdef findPar(self,u):\\n\\t\\t\\tif self.parent[u]!=u:\\n\\t\\t\\t\\tself.parent[u]=self.findPar(self.parent[u])\\n\\t\\t\\treturn self.parent[u]\\n\\t\\tdef union(self,u,v):\\n\\t\\t\\tpu = self.findPar(u)\\n\\t\\t\\tpv = self.findPar(v)\\n\\t\\t\\tself.parent[pu] = pv"]}
{"id": "1007", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:", "def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder) == 0: return None\\n        root = TreeNode(preorder[0])\\n        stack, i = [root], 0\\n        for n in preorder[1:]:\\n            if stack[-1].val != postorder[i]:\\n                stack[-1].left = left = TreeNode(n)\\n                stack.append(left)\\n            else:\\n                while stack and stack[-1].val == postorder[i]:\\n                    cur = stack.pop()\\n                    i += 1\\n                stack[-1].right = right = TreeNode(n)\\n                stack.append(right)\\n        return root\\n```"]}
{"id": "1008", "ref_py": ["define a function that calculates the the numeric pattern \\nand compare with each word in words**", "define a function that calculates the the numeric pattern \\nand compare with each word in words**", "define a function that calculates the the numeric pattern \\nand compare with each word in words**"]}
{"id": "1009", "ref_py": ["def distributeCandies(self, candyType: List[int]) -> int:\\n        seen = {}\\n        i = 0\\n        amount_allowed = 0\\n        while(i<len(candyType) and amount_allowed<len(candyType)//2):\\n            if seen.get(candyType[i],0)==0:\\n                amount_allowed+=1\\n                seen[candyType[i]] = 1\\n            i+=1\\n        return amount_allowed", "def distributeCandies(self, candyType: List[int]) -> int:\\n        ", "def distributeCandies(self, candyType: List[int]) -> int:\\n        seen = {}\\n        i = 0\\n        amount_allowed = 0\\n        while(i<len(candyType) and amount_allowed<len(candyType)//2):\\n            if seen.get(candyType[i],0)==0:\\n                amount_allowed+=1\\n                seen[candyType[i]] = 1\\n            i+=1\\n        return amount_allowed"]}
{"id": "1010", "ref_py": ["def clone(self, tree: TreeNode) -> TreeNode:\\n    if not tree:\\n      return None\\n    new_tree = TreeNode(0)\\n    new_tree.left = self.clone(tree.left)\\n    new_tree.right = self.clone(tree.right)\\n    return new_tree\\n  \\n  def allPossibleFBT(self, N: int) -> List[TreeNode]:\\n    if N % 2 == 0:\\n      return []\\n    elif N == 1:\\n      return [TreeNode(0)]\\n    ret = []\\n    for i in range(2, N + 1, 2):\\n      left_branch = self.allPossibleFBT(i - 1)\\n      right_branch = self.allPossibleFBT(N - i)\\n      for left_count, left in enumerate(left_branch, 1):\\n        for right_count, right in enumerate(right_branch, 1):\\n          tree = TreeNode(0)\\n          \\n          ", "defined as a recursive helper function to generate all possible full binary trees with `n` nodes.", "default for number of nodes = 1 and number of nodes = 3.\\nSo, for number of nodes = 5 we have to increment left side from 1 to 3 and decrement right side from 3 to 1 with gap of 2."]}
{"id": "1011", "ref_py": ["def subarrayBitwiseORs(self, arr: List[int]) -> int:", "def subarrayBitwiseORs(self, arr):\\n        \\n        ans = set()\\n        prev = set()\\n        val = -1\\n        for i in arr:\\n            val = i\\n            prev = set([j|i for j in list(prev) if i!=j])\\n            prev.add(i)\\n            ans.update(prev)\\n        return len(ans)", "def subarrayBitwiseORs(self, arr):\\n        \\n        result = set()  \\n        cur_set = set()  \\n        prev_set = set()  "]}
{"id": "1014", "ref_py": ["def totalFruit(self, fruits: List[int]) -> int:\\n        type1, type2, count1, count2, ans = None, None, 0, 0, 0\\n        prev, prefix_count1, prefix_count2 = None, 0, 0\\n        n = len(fruits)\\n        for i in range(n):\\n            ", "def totalFruit(self, fruits: List[int]) -> int:\\n        counter = Counter()\\n        l, r = 0, 0\\n        ans = 0\\n        for r in range(len(fruits)):\\n            counter[fruits[r]] += 1\\n            while len(counter) == 3:\\n                counter[fruits[l]] -= 1\\n                if counter[fruits[l]] == 0:\\n                    ", "def totalFruit(self, fruits: List[int]) -> int:\\n        counter = Counter()\\n        l, r = 0, 0\\n        ans = 0\\n        for r in range(len(fruits)):\\n            counter[fruits[r]] += 1\\n            while len(counter) == 3:\\n                counter[fruits[l]] -= 1\\n                if counter[fruits[l]] == 0:\\n                    "]}
{"id": "1015", "ref_py": ["def sumSubarrayMins(self, arr):\\n        \\n        arr = [0] + arr\\n        stack = [0] ", "def sumSubarrayMins(self, arr: List[int]) -> int:\\n        \\n        M = 10**9+7\\n        sums = 0\\n        arr.append(0) ", "def sumSubarrayMins(self, arr: List[int]) -> int:\\n        \\n        M = 10**9+7\\n        sums = 0\\n        arr.append(0) "]}
{"id": "1016", "ref_py": ["def snakesAndLadders(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        moves = 0\\n        q = collections.deque([1])\\n        visited = [[False for _ in range(n)] for _ in range(n)]\\n        visited[n-1][0] = True\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                currBoardVal = q.popleft()\\n                if currBoardVal == n*n:\\n                    return moves\\n                for diceVal in range(1, 7):\\n                    if currBoardVal + diceVal > n*n:\\n                        break\\n                    pos = self.findCoordinates(currBoardVal + diceVal, n)\\n                    row, col = pos\\n                    if not visited[row][col]:\\n                        visited[row][col] = True\\n                        if board[row][col] == -1:\\n                            q.append(currBoardVal + diceVal)\\n                        else:\\n                            q.append(board[row][col])\\n            moves += 1\\n        return -1\\n    \\n    def findCoordinates(self, curr: int, n: int) -> Tuple[int, int]:\\n        row = n - (curr - 1) // n - 1\\n        col = (curr - 1) % n\\n        if row % 2 == n % 2:\\n            return (row, n - 1 - col)\\n        else:\\n            return (row, col)", "def pair<int,int> Pi;\\nclass Solution {\\npublic:\\n    int snakesAndLadders(vector<vector<int>>& board) {\\n        int rows=board.size(), cols = board[0].size(), target=rows*cols, r, c, p;\\n        vector<int> visited(rows*cols + 1); // cells on board start from 1\\n        // queue contains <priority, square> sorted ascending by priority\\n        // prio = ", "def pair<int,int> Pi;\\nclass Solution {\\npublic:\\n    int snakesAndLadders(vector<vector<int>>& board) {\\n        int rows=board.size(), cols = board[0].size(), target=rows*cols, r, c, p;\\n        vector<int> visited(rows*cols + 1); // cells on board start from 1\\n        // queue contains <priority, square> sorted ascending by priority\\n        // prio = "]}
{"id": "1017", "ref_py": ["definition must be less than _jump_ distance apart. Thus we actually only care about the maximum number inside each range compared to the minimum number in the next (non empty) range. Each of these pairs is the only place that can have a jump larger than _jump_.", "def smallestRangeII(self, a: List[int], k: int) -> int:\\n        a.sort()\\n        ans = a[-1] - a[0]\\n        for x, y in zip(a, a[1:]):\\n            ans = min(ans, max(a[-1]-k, x+k) - min(a[0]+k, y-k))\\n        return ans\\n```", "def smallestRangeII(self, a: List[int], k: int) -> int:\\n        a.sort()\\n        ans = a[-1] - a[0]\\n        for x, y in zip(a, a[1:]):\\n            ans = min(ans, max(a[-1]-k, x+k) - min(a[0]+k, y-k))\\n        return ans\\n```"]}
{"id": "1019", "ref_py": ["def sortArray(self, arr):\\n        n = len(arr)", "def quicksort(self, nums):\\n    if len(nums) <= 1:\\n        return nums", "def quicksort(self, nums):\\n    if len(nums) <= 1:\\n        return nums"]}
{"id": "1020", "ref_py": ["def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        ", "def partitionDisjoint(self, nums: List[int]) -> int:\\n        left, right = 1, 0\\n        cur_low = next_low = nums[0]\\n        for val in nums[1:]:\\n            if val >= cur_low:\\n                right += 1\\n                next_low = max(next_low, val)\\n            else:\\n                left += right + 1\\n                right = 0\\n                cur_low = next_low\\n        return left\\n```", "def partitionDisjoint(self, nums: List[int]) -> int:\\n        left, right = 1, 0\\n        cur_low = next_low = nums[0]\\n        for val in nums[1:]:\\n            if val >= cur_low:\\n                right += 1\\n                next_low = max(next_low, val)\\n            else:\\n                left += right + 1\\n                right = 0\\n                cur_low = next_low\\n        return left\\n```"]}
{"id": "1021", "ref_py": ["def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\\n        ", "def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\\n        ", "def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\\n        "]}
{"id": "1022", "ref_py": ["def reverseList(self, head):\\n        ", "def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next", "def reverseList(self, head):\\n        "]}
{"id": "1024", "ref_py": ["def minAddToMakeValid(self, s: str) -> int:\\n        stack = []", "def minAddToMakeValid(self, s: str) -> int:\\n        stack = []", "def minAddToMakeValid(self, s: str) -> int:\\n        stack = []"]}
{"id": "1025", "ref_py": ["def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\t", "def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        mp, res = {}, 0\\n        for i in range(len(arr)-1):\\n            for j in range(i+1, len(arr)):\\n                diff = target - (arr[i] + arr[j])\\n                res += mp[diff] if diff in mp else 0\\n            \\n            mp[arr[i]] = mp.get(arr[i], 0) + 1\\n            \\n        return res % int(1e9 + 7)\\n```", "def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        mp, res = {}, 0\\n        for i in range(len(arr)-1):\\n            for j in range(i+1, len(arr)):\\n                diff = target - (arr[i] + arr[j])\\n                res += mp[diff] if diff in mp else 0\\n            \\n            mp[arr[i]] = mp.get(arr[i], 0) + 1\\n            \\n        return res % int(1e9 + 7)\\n```"]}
{"id": "1026", "ref_py": ["def minFlipsMonoIncr(self, s: str) -> int:", "def minFlipsMonoIncr(self, s: str) -> int:", "def minFlipsMonoIncr(self, s: str) -> int:"]}
{"id": "1027", "ref_py": ["def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\\n        //atmost(sum=goal) - atmost(sum=goal-1)\\n        return self.countSubarrays(nums,goal)-self.countSubarrays(nums,goal-1)", "def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\\n        //atmost(sum=goal) - atmost(sum=goal-1)\\n        return self.countSubarrays(nums,goal)-self.countSubarrays(nums,goal-1)", "def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\\n        //atmost(sum=goal) - atmost(sum=goal-1)\\n        return self.countSubarrays(nums,goal)-self.countSubarrays(nums,goal-1)"]}
{"id": "1028", "ref_py": ["def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        maxi = float(\\'inf\\')\\n        prev_row = [maxi] + matrix[0][:] + [maxi]", "def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        maxi = float(\\'inf\\')\\n        prev_row = [maxi] + matrix[0][:] + [maxi]", "def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        maxi = float(\\'inf\\')\\n        prev_row = [maxi] + matrix[0][:] + [maxi]"]}
{"id": "1029", "ref_py": ["def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```", "def beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)", "def beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)"]}
{"id": "1030", "ref_py": ["def shortestBridge(self, A: List[List[int]]) -> int:\\n        \\n        ", "def shortestBridge(self, grid: List[List[int]]) -> int:\\n        N = len(grid)", "def shortestBridge(self, grid: List[List[int]]) -> int:\\n        N = len(grid)"]}
{"id": "1031", "ref_py": ["def __init__(self):\\n        self.cache = [[0] * 10 for _ in range(5001)]", "def knightDialer(self, n: int) -> int:\\n        MOD = 10**9 + 7\\n        moves = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\\n        dp = dict()\\n        \\n        ", "def knightDialer(self, n: int) -> int:\\n        MOD = 10**9 + 7\\n        moves = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\\n        dp = dict()\\n        \\n        "]}
{"id": "1032", "ref_py": ["def reorderLogFiles(self, logs: List[str]) -> List[str]:\\n        def customSort(log):\\n            idx = log.index(\\' \\') + 1\\n            if log[idx].isalpha():\\n                return (0, log[idx:], log[:idx])\\n            return (1,)", "def reorderLogFiles(self, logs: List[str]) -> List[str]:\\n        def sorting_algorithm(log):\\n\\t\\t\\t", "def reorderLogFiles(self, logs: List[str]) -> List[str]:\\n        def sorting_algorithm(log):\\n\\t\\t\\t"]}
{"id": "1033", "ref_py": ["defaultdict\\nclass Solution:\\n    def minAreaRect(self, points: List[List[int]]) -> int:\\n        hashmap = defaultdict(set)\\n        for x, y in points:\\n            hashmap[x].add(y)\\n            \\n        min_area = math.inf\\n             \\n        i = 0\\n        for x1, y1 in points:\\n            i += 1\\n            for x2, y2 in points[i:]:\\n                if x1 != x2 and y1 != y2:\\n                    if y2 in hashmap[x1] and y1 in hashmap[x2]:\\n                        min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\\n                        if min_area == 1:\\n                            return 1\\n                \\n        return min_area if min_area != math.inf else 0\\n```", "def minAreaRect(self, points: List[List[int]]) -> int:\\n    points.sort()\\n    points_set = set([tuple(point) for point in points])\\n    smallest = float(\\'inf\\')\\n    for i, (x1, y1) in enumerate(points):\\n        for j, (x2, y2) in enumerate(points[i:], i):\\n            if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\\n                area = (x2 - x1) * (y2 - y1)\\n                smallest = min(smallest, area)\\n    return smallest if smallest != float(\\'inf\\') else 0\\n```", "def minAreaRect(self, points: List[List[int]]) -> int:\\n    points.sort()\\n    points_set = set([tuple(point) for point in points])\\n    smallest = float(\\'inf\\')\\n    for i, (x1, y1) in enumerate(points):\\n        for j, (x2, y2) in enumerate(points[i:], i):\\n            if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\\n                area = (x2 - x1) * (y2 - y1)\\n                smallest = min(smallest, area)\\n    return smallest if smallest != float(\\'inf\\') else 0\\n```"]}
{"id": "1034", "ref_py": ["def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        if (sum(nums)+target)%2!=0 or sum(nums)+target<0:\\n            return 0\\n        target=(sum(nums)+target)//2\\n        prev=[0 for _ in range(target + 1)]\\n        curr=[0 for _ in range(target + 1)]\\n        \\n        prev[0] = 1\\n        ", "def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n    ", "def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        if (sum(nums)+target)%2!=0 or sum(nums)+target<0:\\n            return 0\\n        target=(sum(nums)+target)//2\\n        prev=[0 for _ in range(target + 1)]\\n        curr=[0 for _ in range(target + 1)]\\n        \\n        prev[0] = 1\\n        "]}
{"id": "1035", "ref_py": ["def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        stack=[]\\n        i=0\\n        for num in pushed:\\n            stack.append(num) ", "def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        stack=[]\\n        i=0\\n        for num in pushed:\\n            stack.append(num) ", "def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n        stack=[]\\n        i=0\\n        for num in pushed:\\n            stack.append(num) "]}
{"id": "1036", "ref_py": ["def removeStones(self, stones: List[List[int]]) -> int:\\n\\t", "def removeStones(self, stones: List[List[int]]) -> int:\\n        def find(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=find(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=find(u),find(v)\\n            if pu==pv:\\n                return \\n            if size[pv]>size[pu]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n        \\n        n=len(stones)\\n        mr=mc=0\\n        for i,j in stones:\\n            mr=max(mr,i)\\n            mc=max(mc,j)\\n        parent=[i for i in range(mr+mc+2)]\\n        size=[1 for i in range(mr+mc+2)]\\n        d={} ", "def removeStones(self, stones: List[List[int]]) -> int:\\n\\t"]}
{"id": "1037", "ref_py": ["def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\\n        tokens.sort()\\n\\t\\t", "def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\\n        tokens.sort()\\n\\t\\t", "def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\\n        tokens.sort()\\n\\t\\t"]}
{"id": "1038", "ref_py": ["def largestTimeFromDigits(self, arr: List[int]) -> str:", "def largestTimeFromDigits(self, arr: List[int]) -> str:", "def largestTimeFromDigits(self, arr: List[int]) -> str:"]}
{"id": "1039", "ref_py": ["def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        d=deque(sorted(deck))\\n        res = deque()\\n        l = len(d)\\n        while l != len(res):\\n            t = d.pop()\\n            if len(res)>0:\\n                r = res.pop()\\n                res.appendleft(r)\\n            res.appendleft(t)\\n        return res\\n```", "def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        d=deque(sorted(deck))\\n        res = deque()\\n        l = len(d)\\n        while l != len(res):\\n            t = d.pop()\\n            if len(res)>0:\\n                r = res.pop()\\n                res.appendleft(r)\\n            res.appendleft(t)\\n        return res\\n```", "def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        d=deque(sorted(deck))\\n        res = deque()\\n        l = len(d)\\n        while l != len(res):\\n            t = d.pop()\\n            if len(res)>0:\\n                r = res.pop()\\n                res.appendleft(r)\\n            res.appendleft(t)\\n        return res\\n```"]}
{"id": "1040", "ref_py": ["def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\\n\\tlru_cache(None)\\n\\tdef dfs(n1, n2):\\n\\t\\tif not(n1 or n2):\\n\\t\\t\\treturn True\\n\\t\\tif not(n1 and n2) or n1.val != n2.val:\\n\\t\\t\\treturn False\\n\\t\\tif((n1.left and n2.left) or (n1.right and n2.right)):\\n\\t\\t\\treturn (dfs(n1.left, n2.left) and dfs(n1.right, n2.right)) or (dfs(n1.right, n2.left) and dfs(n1.left, n2.right))        \\n\\t\\telse:\\n\\t\\t\\treturn dfs(n1.right, n2.left) and dfs(n1.left, n2.right)\\n", "def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\\n\\tlru_cache(None)\\n\\tdef dfs(n1, n2):\\n\\t\\tif not(n1 or n2):\\n\\t\\t\\treturn True\\n\\t\\tif not(n1 and n2) or n1.val != n2.val:\\n\\t\\t\\treturn False\\n\\t\\tif((n1.left and n2.left) or (n1.right and n2.right)):\\n\\t\\t\\treturn (dfs(n1.left, n2.left) and dfs(n1.right, n2.right)) or (dfs(n1.right, n2.left) and dfs(n1.left, n2.right))        \\n\\t\\telse:\\n\\t\\t\\treturn dfs(n1.right, n2.left) and dfs(n1.left, n2.right)\\n", "def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\\n\\tlru_cache(None)\\n\\tdef dfs(n1, n2):\\n\\t\\tif not(n1 or n2):\\n\\t\\t\\treturn True\\n\\t\\tif not(n1 and n2) or n1.val != n2.val:\\n\\t\\t\\treturn False\\n\\t\\tif((n1.left and n2.left) or (n1.right and n2.right)):\\n\\t\\t\\treturn (dfs(n1.left, n2.left) and dfs(n1.right, n2.right)) or (dfs(n1.right, n2.left) and dfs(n1.left, n2.right))        \\n\\t\\telse:\\n\\t\\t\\treturn dfs(n1.right, n2.left) and dfs(n1.left, n2.right)\\n"]}
{"id": "1041", "ref_py": ["def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True", "def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n", "def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)"]}
{"id": "1042", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1043", "ref_py": ["def nextday(cells):\\n            next_day_cells = [0] *len(cells)\\n            for i in range(1,len(cells)-1):\\n                if cells[i-1] == cells[i+1]: \\n                        next_day_cells[i] = 1\\n                else:\\n                        next_day_cells[i] = 0\\n            return tuple(next_day_cells)\\n   \\n```\\n*  From the results, we know that the length of the pattern will be 14. i.e. the length of pattern == 14.\\n```\\nSeen =\\n{(0, 1, 1, 0, 0, 0, 0, 0): 1,\\n(0, 0, 0, 0, 1, 1, 1, 0): 2,\\n(0, 1, 1, 0, 0, 1, 0, 0): 3,\\n(0, 0, 0, 0, 0, 1, 0, 0): 4,\\n(0, 1, 1, 1, 0, 1, 0, 0): 5, \\n(0, 0, 1, 0, 1, 1, 0, 0): 6, \\n(0, 0, 1, 1, 0, 0, 0, 0): 7,\\n(0, 0, 0, 0, 0, 1, 1, 0): 8, \\n(0, 1, 1, 1, 0, 0, 0, 0): 9, \\n(0, 0, 1, 0, 0, 1, 1, 0): 10, \\n(0, 0, 1, 0, 0, 0, 0, 0): 11, \\n(0, 0, 1, 0, 1, 1, 1, 0): 12,\\n(0, 0, 1, 1, 0, 1, 0, 0): 13, \\n(0, 0, 0, 0, 1, 1, 0, 0): 14}\\n```", "def nextday(cells):\\n            next_day_cells = [0] *len(cells)\\n            for i in range(1,len(cells)-1):\\n                if cells[i-1] == cells[i+1]: \\n                        next_day_cells[i] = 1\\n                else:\\n                        next_day_cells[i] = 0\\n            return tuple(next_day_cells)\\n   \\n```\\n*  From the results, we know that the length of the pattern will be 14. i.e. the length of pattern == 14.\\n```\\nSeen =\\n{(0, 1, 1, 0, 0, 0, 0, 0): 1,\\n(0, 0, 0, 0, 1, 1, 1, 0): 2,\\n(0, 1, 1, 0, 0, 1, 0, 0): 3,\\n(0, 0, 0, 0, 0, 1, 0, 0): 4,\\n(0, 1, 1, 1, 0, 1, 0, 0): 5, \\n(0, 0, 1, 0, 1, 1, 0, 0): 6, \\n(0, 0, 1, 1, 0, 0, 0, 0): 7,\\n(0, 0, 0, 0, 0, 1, 1, 0): 8, \\n(0, 1, 1, 1, 0, 0, 0, 0): 9, \\n(0, 0, 1, 0, 0, 1, 1, 0): 10, \\n(0, 0, 1, 0, 0, 0, 0, 0): 11, \\n(0, 0, 1, 0, 1, 1, 1, 0): 12,\\n(0, 0, 1, 1, 0, 1, 0, 0): 13, \\n(0, 0, 0, 0, 1, 1, 0, 0): 14}\\n```", "def nextday(cells):\\n            next_day_cells = [0] *len(cells)\\n            for i in range(1,len(cells)-1):\\n                if cells[i-1] == cells[i+1]: \\n                        next_day_cells[i] = 1\\n                else:\\n                        next_day_cells[i] = 0\\n            return tuple(next_day_cells)\\n   \\n```\\n*  From the results, we know that the length of the pattern will be 14. i.e. the length of pattern == 14.\\n```\\nSeen =\\n{(0, 1, 1, 0, 0, 0, 0, 0): 1,\\n(0, 0, 0, 0, 1, 1, 1, 0): 2,\\n(0, 1, 1, 0, 0, 1, 0, 0): 3,\\n(0, 0, 0, 0, 0, 1, 0, 0): 4,\\n(0, 1, 1, 1, 0, 1, 0, 0): 5, \\n(0, 0, 1, 0, 1, 1, 0, 0): 6, \\n(0, 0, 1, 1, 0, 0, 0, 0): 7,\\n(0, 0, 0, 0, 0, 1, 1, 0): 8, \\n(0, 1, 1, 1, 0, 0, 0, 0): 9, \\n(0, 0, 1, 0, 0, 1, 1, 0): 10, \\n(0, 0, 1, 0, 0, 0, 0, 0): 11, \\n(0, 0, 1, 0, 1, 1, 1, 0): 12,\\n(0, 0, 1, 1, 0, 1, 0, 0): 13, \\n(0, 0, 0, 0, 1, 1, 0, 0): 14}\\n```"]}
{"id": "1044", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def isCompleteTree(self, root_: TreeNode | None) -> bool:\\n        def preorder(root: TreeNode | None, complete: bool=False) -> Iterator[TreeNode | None]:\\n            queue = deque((root,))\\n            while queue:\\n                node = queue.popleft()\\n                if complete or node: yield node\\n                queue.extend((node.left, node.right) if node else tuple())", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1045", "ref_py": ["def regionsBySlashes(self, grid):\\n        \\n        roots = {}\\n        ", "def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, a, b):\\n        self.parent[self.find(b)] = self.find(a)", "def regionsBySlashes(self, grid):\\n        \\n        roots = {}\\n        "]}
{"id": "1046", "ref_py": ["def maxWidthRamp(self, nums: List[int]) -> int:\\n        arr = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans = 0\\n        min_id = len(nums)\\n        for i in arr:\\n            ans = max(ans, i - min_id)\\n            min_id = min(min_id, i)\\n        return ans\\n```", "def maxWidthRamp(self, nums: List[int]) -> int:\\n        arr = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans = 0\\n        min_id = len(nums)\\n        for i in arr:\\n            ans = max(ans, i - min_id)\\n            min_id = min(min_id, i)\\n        return ans\\n```", "def maxWidthRamp(self, nums: List[int]) -> int:\\n        arr = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans = 0\\n        min_id = len(nums)\\n        for i in arr:\\n            ans = max(ans, i - min_id)\\n            min_id = min(min_id, i)\\n        return ans\\n```"]}
{"id": "1047", "ref_py": ["def dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5", "defaultdict", "def dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5"]}
{"id": "1048", "ref_py": ["def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```", "def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        words = set(wordlist)\\n        cap = {}\\n        devowel = {}\\n        \\n        def devowel_word(word):\\n            return \\'\\'.join(\\'", "def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```"]}
{"id": "1049", "ref_py": ["def lexicalOrder(self, n: int) -> List[int]:\\n        res = []\\n        cur = 1\\n        for i in range(n):\\n            ", "def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []\\n        def helper(x):\\n            nonlocal ans\\n            for y in range(0, 10):\\n                new = (x*10)+y\\n                if new <= n and new > 0:\\n                    ans.append(new)\\n                    helper(new)\\n            \\n        helper(0)\\n        return ans\\n", "def lexicalOrder(self, n: int) -> List[int]:\\n        ans = []"]}
{"id": "1050", "ref_py": ["def pancakeSort(self, arr: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(arr)-1, -1, -1):\\n            flip = 1 + arr.index(i+1)\\n            if flip != i+1:\\n                arr[:flip] = arr[:flip][::-1]\\n                arr[:i+1] = arr[:i+1][::-1]\\n                res.append(flip)\\n                res.append(i+1)\\n        return res\\n", "def pancakeSort(self, arr: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(arr)-1, -1, -1):\\n            flip = 1 + arr.index(i+1)\\n            if flip != i+1:\\n                arr[:flip] = arr[:flip][::-1]\\n                arr[:i+1] = arr[:i+1][::-1]\\n                res.append(flip)\\n                res.append(i+1)\\n        return res\\n", "def pancakeSort(self, arr: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(arr)-1, -1, -1):\\n            flip = 1 + arr.index(i+1)\\n            if flip != i+1:\\n                arr[:flip] = arr[:flip][::-1]\\n                arr[:i+1] = arr[:i+1][::-1]\\n                res.append(flip)\\n                res.append(i+1)\\n        return res\\n"]}
{"id": "1051", "ref_py": ["def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound <= 1: return []\\n        \\n        res = set()\\n        L = int(log(bound, x)) + 1 if x > 1 else 1\\n        M = int(log(bound, y)) + 1 if y > 1 else 1", "def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        ans, xi = set(), 1\\n        while xi < bound:\\n            yj = 1\\n            while xi + yj <= bound:\\n                ans.add(xi + yj)\\n                if y == 1: break\\n                yj *= y\\n            if x == 1: break\\n            xi *= x\\n        return list(ans)\\n```", "def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound <= 1: return []\\n        \\n        res = set()\\n        L = int(log(bound, x)) + 1 if x > 1 else 1\\n        M = int(log(bound, y)) + 1 if y > 1 else 1"]}
{"id": "1052", "ref_py": ["def flipMatchVoyage(self, root: TreeNode, V: List[int]) -> List[int]:\\n        ans = [0]\\n        def dfs(node, V, ans):\\n            if not node or ans[0] == -1: return\\n            if node.val != V[ans[0]]: ans[0] = -1\\n            else:\\n                ans[0] += 1\\n                if node.left and node.left.val != V[ans[0]]:\\n                    ans.append(node.val)\\n                    dfs(node.right, V, ans)\\n                    dfs(node.left, V, ans)\\n                else:\\n                    dfs(node.left, V, ans)\\n                    dfs(node.right, V, ans)\\n        dfs(root, V, ans)\\n        return ans[:1] if ans[0] == -1 else ans[1:]\\n```", "def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\\n        ans = []\\n        cur = 0\\n        def dfs(root):\\n            nonlocal cur\\n            if root is None or cur == len(voyage): return True\\n            if root.val != voyage[cur]: return False\\n\\t\\t\\t", "def flipMatchVoyage(self, root: TreeNode, V: List[int]) -> List[int]:\\n        ans = [0]\\n        def dfs(node, V, ans):\\n            if not node or ans[0] == -1: return\\n            if node.val != V[ans[0]]: ans[0] = -1\\n            else:\\n                ans[0] += 1\\n                if node.left and node.left.val != V[ans[0]]:\\n                    ans.append(node.val)\\n                    dfs(node.right, V, ans)\\n                    dfs(node.left, V, ans)\\n                else:\\n                    dfs(node.left, V, ans)\\n                    dfs(node.right, V, ans)\\n        dfs(root, V, ans)\\n        return ans[:1] if ans[0] == -1 else ans[1:]\\n```"]}
{"id": "1053", "ref_py": ["def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        heap = []\\n        \\n        for (x, y) in points:\\n            dist = -(x*x + y*y)\\n            if len(heap) == K:\\n                heapq.heappushpop(heap, (dist, x, y))\\n            else:\\n                heapq.heappush(heap, (dist, x, y))\\n        \\n        return [(x,y) for (dist,x, y) in heap]\\n```", "def kClosest(self, points, k):\\n        return nsmallest(K, points, lambda (x, y): x * x + y * y)\\n```", "def kClosest(self, points, k):\\n        return nsmallest(K, points, lambda (x, y): x * x + y * y)\\n```"]}
{"id": "1054", "ref_py": ["def subarraysDivByK(self, nums: list[int], k: int) -> int:\\n        prefix_sum_remainders = accumulate(nums, lambda a, x: (a + x % k) % k, initial=0)\\n        remainder_counts = Counter(prefix_sum_remainders).values()\\n        return sum(map(lambda n: n * (n - 1) // 2, remainder_counts))", "def subarraysDivByK(self, nums: list[int], k: int) -> int:\\n        prefix_sum_remainders = accumulate(nums, lambda a, x: (a + x % k) % k, initial=0)\\n        remainder_counts = Counter(prefix_sum_remainders).values()\\n        return sum(map(lambda n: n * (n - 1) // 2, remainder_counts))", "def subarraysDivByK(self, nums: list[int], k: int) -> int:\\n        prefix_sum_remainders = accumulate(nums, lambda a, x: (a + x % k) % k, initial=0)\\n        remainder_counts = Counter(prefix_sum_remainders).values()\\n        return sum(map(lambda n: n * (n - 1) // 2, remainder_counts))"]}
{"id": "1055", "ref_py": ["def maxTurbulenceSize(self, A):\\n    best = clen = 0", "def isTurbulent(self, arr, j):\\n        ", "def isTurbulent(self, arr, j):\\n        "]}
{"id": "1056", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1058", "ref_py": ["def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last_day = days[-1]\\n        travel_days = set(days) ", "def mincostTickets(self, days, costs):\\n        \\n        n = len(days)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + costs[0] ", "def mincostTickets(self, days, costs):\\n        \\n        n = len(days)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + costs[0] "]}
{"id": "1059", "ref_py": ["def strWithout3a3b(self, a, b):\\n        \\n        n=a+b\\n        count_A=0\\n        count_b=0\\n        res=\"\"\\n        for i in range(n):\\n            if (a>b and count_A<2) or count_b>1:\\n                res+=\"a\"\\n                count_A+=1\\n                a=a-1\\n                count_b=0\\n            else:\\n                res+=\"b\"\\n                b-=1\\n                count_A=0\\n                count_b+=1\\n        return res", "def strWithout3a3b(self, a: int, b: int) -> str:", "def strWithout3a3b(self, a, b):\\n        \\n        n=a+b\\n        count_A=0\\n        count_b=0\\n        res=\"\"\\n        for i in range(n):\\n            if (a>b and count_A<2) or count_b>1:\\n                res+=\"a\"\\n                count_A+=1\\n                a=a-1\\n                count_b=0\\n            else:\\n                res+=\"b\"\\n                b-=1\\n                count_A=0\\n                count_b+=1\\n        return res"]}
{"id": "1060", "ref_py": ["def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        ", "def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        even_sum = sum(v for v in nums if v % 2 == 0)\\n        res: list[int] = []", "def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        "]}
{"id": "1061", "ref_py": ["def intervalIntersection(self, firstList, secondList):\\n        \\n        l = 0\\n        r = 0\\n        intersec = []\\n        while l < len(firstList) and r < len(secondList):\\n            f = firstList[l]\\n            s = secondList[r]\\n            inter_s = -1\\n            inter_e = -1\\n            \\n            if (f[0] >= s[0] and f[0] <= s[1]):\\n                inter_s = f[0]\\n            elif (s[0] >= f[0] and s[0] <= f[1]):\\n                inter_s = s[0]\\n            else:\\n                if s[1] < f[1]:\\n                    r += 1\\n                else:\\n                    l += 1\\n            \\n            if inter_s != -1:\\n                if (f[1] > s[1]):\\n                    inter_e = s[1]\\n                    r += 1\\n                else:\\n                    inter_e = f[1]\\n                    l += 1\\n                    \\n            if inter_s != -1 and inter_e != -1:\\n                intersec.append([inter_s, inter_e])\\n                \\n        return intersec\\n```", "def intervalIntersection(self, firstList, secondList):\\n        \\n        l = 0\\n        r = 0\\n        intersec = []\\n        while l < len(firstList) and r < len(secondList):\\n            f = firstList[l]\\n            s = secondList[r]\\n            inter_s = -1\\n            inter_e = -1\\n            \\n            if (f[0] >= s[0] and f[0] <= s[1]):\\n                inter_s = f[0]\\n            elif (s[0] >= f[0] and s[0] <= f[1]):\\n                inter_s = s[0]\\n            else:\\n                if s[1] < f[1]:\\n                    r += 1\\n                else:\\n                    l += 1\\n            \\n            if inter_s != -1:\\n                if (f[1] > s[1]):\\n                    inter_e = s[1]\\n                    r += 1\\n                else:\\n                    inter_e = f[1]\\n                    l += 1\\n                    \\n            if inter_s != -1 and inter_e != -1:\\n                intersec.append([inter_s, inter_e])\\n                \\n        return intersec\\n```", "def intervalIntersection(self, firstList, secondList):\\n        \\n        l = 0\\n        r = 0\\n        intersec = []\\n        while l < len(firstList) and r < len(secondList):\\n            f = firstList[l]\\n            s = secondList[r]\\n            inter_s = -1\\n            inter_e = -1\\n            \\n            if (f[0] >= s[0] and f[0] <= s[1]):\\n                inter_s = f[0]\\n            elif (s[0] >= f[0] and s[0] <= f[1]):\\n                inter_s = s[0]\\n            else:\\n                if s[1] < f[1]:\\n                    r += 1\\n                else:\\n                    l += 1\\n            \\n            if inter_s != -1:\\n                if (f[1] > s[1]):\\n                    inter_e = s[1]\\n                    r += 1\\n                else:\\n                    inter_e = f[1]\\n                    l += 1\\n                    \\n            if inter_s != -1 and inter_e != -1:\\n                intersec.append([inter_s, inter_e])\\n                \\n        return intersec\\n```"]}
{"id": "1062", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1063", "ref_py": ["defaultdict", "defaultdict\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        count=0\\n        def def_val():\\n            return []\\n        dic=defaultdict(def_val)\\n        notequals = []\\n        for i in range(len(equations)):\\n            a=equations[i][0]\\n            b=equations[i][-1]\\n            relation = equations[i][1:3]\\n            if(relation==\"!=\"):\\n                notequals.append([a, b])\\n                continue\\n            if(a==b):\\n                continue\\n            else:\\n                if(a not in dic):\\n                    dic[a]=[b]\\n                    if(b in dic):\\n                        dic[b].append(a)\\n                    else:\\n                        dic[b]=[a]\\n                if(a in dic):\\n                    flag=False\\n                    for j in dic[a]:\\n                        if(j[0]==b):\\n                            flag=True\\n                    if(not flag):\\n                        dic[a].append(b)\\n                    if(b in dic):\\n                        flag=False\\n                        for j in dic[b]:\\n                            if(j[0]==a):\\n                                flag=True\\n                        if(not flag):\\n                            dic[b].append(a)\\n                    else:\\n                        dic[b]=[a]\\n        ", "defaultdict\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        count=0\\n        def def_val():\\n            return []\\n        dic=defaultdict(def_val)\\n        notequals = []\\n        for i in range(len(equations)):\\n            a=equations[i][0]\\n            b=equations[i][-1]\\n            relation = equations[i][1:3]\\n            if(relation==\"!=\"):\\n                notequals.append([a, b])\\n                continue\\n            if(a==b):\\n                continue\\n            else:\\n                if(a not in dic):\\n                    dic[a]=[b]\\n                    if(b in dic):\\n                        dic[b].append(a)\\n                    else:\\n                        dic[b]=[a]\\n                if(a in dic):\\n                    flag=False\\n                    for j in dic[a]:\\n                        if(j[0]==b):\\n                            flag=True\\n                    if(not flag):\\n                        dic[a].append(b)\\n                    if(b in dic):\\n                        flag=False\\n                        for j in dic[b]:\\n                            if(j[0]==a):\\n                                flag=True\\n                        if(not flag):\\n                            dic[b].append(a)\\n                    else:\\n                        dic[b]=[a]\\n        "]}
{"id": "1064", "ref_py": ["def brokenCalc(self, x: int, y: int) -> int:\\n    steps = 0\\n    while y > x:\\n      steps += 1 + y % 2 ", "def brokenCalc(self, startValue, target):\\n        result = 0;\\n        while (startValue < target) :\\n            result+=1;\\n            if target % 2 == 0: target = target/2;\\n            else: target+=1;\\n        return result+startValue-target;\\n```", "def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```"]}
{"id": "1065", "ref_py": ["def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        ", "def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        ", "def orangesRotting(self, grid: List[List[int]]) -> int:\\n        \\n        "]}
{"id": "1066", "ref_py": ["def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1067", "ref_py": ["def isValid(self, s: str) -> bool:\\n        incomplete = True\\n        \\n        while incomplete:\\n            if \\'abc\\' in s:\\n                s= s.replace(\\'abc\\',\\'\\')\\n            else:\\n                incomplete = False\\n        \\n        return s == \\'\\'\\n```", "def isValid(self, s: str) -> bool:\\n\\t\\t\\n\\t\\t\\t", "def isValid(self, s: str) -> bool:\\n        incomplete = True\\n        \\n        while incomplete:\\n            if \\'abc\\' in s:\\n                s= s.replace(\\'abc\\',\\'\\')\\n            else:\\n                incomplete = False\\n        \\n        return s == \\'\\'\\n```"]}
{"id": "1068", "ref_py": ["def longestOnes(self, nums: List[int], k: int) -> int:\\n        zeros, l = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > k:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        return r - l + 1", "def longestOnes(self, nums: List[int], k: int) -> int:\\n\\tn, ans, l = len(nums), 0, 0\\n\\tfor r in range(n):\\n\\t\\tif nums[r] == 0:                       ", "def longestOnes(self, nums: List[int], k: int) -> int:\\n        zeros, l = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > k:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        return r - l + 1"]}
{"id": "1069", "ref_py": ["def clumsy(self, n: int) -> int:\\n        ", "def clumsy(self, n: int) -> int:\\r\\n        stack = [\"(\"]\\r\\n        postfix = []\\r\\n\\r\\n        digit = n\\r\\n\\r\\n        priorities = {\"*\": 3, \"/\": 3, \"+\": 2, \"-\": 2, \"(\": 1, \")\": 0}\\r\\n\\r\\n        while digit:\\r\\n            for sign in \"*/+-\":\\r\\n                if digit:\\r\\n                    postfix.append(digit)\\r\\n\\r\\n                    while priorities[stack[-1]] >= priorities[sign]:\\r\\n                        postfix.append(stack.pop())\\r\\n                    stack.append(sign)\\r\\n                    digit -= 1\\r\\n                else:\\r\\n                    stack.pop()\\r\\n                    sign = \")\"\\r\\n                    while stack and priorities[stack[-1]] >= priorities[sign]:\\r\\n                        if stack[-1] == \"(\":\\r\\n                            stack.pop()\\r\\n                        else:\\r\\n                            postfix.append(stack.pop())\\r\\n                    break\\r\\n\\r\\n        eval_stack = []\\r\\n\\r\\n        ", "def clumsy(self, n: int) -> int:\\n        "]}
{"id": "1070", "ref_py": ["defaultdict(int)\\ncount_b = defaultdict(int)\\nN = len(A)\\nsame = 0", "def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:", "defaultdict(int)\\ncount_b = defaultdict(int)\\nN = len(A)\\nsame = 0"]}
{"id": "1071", "ref_py": ["def diagonalPrime(self, nums: List[List[int]]) -> int:", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num: int) -> bool:\\n            if num == 2 or num == 3:\\n                return True\\n            if num <= 1 or num % 2 == 0 or num % 3 == 0:\\n                return False"]}
{"id": "1072", "ref_py": ["def numPairsDivisibleBy60(self, time):\\n        ans, cnt = 0, [0] * 60\\n        for t in time: cnt[t % 60] += 1\\n        for i in range(1, 30): ans += cnt[i] * cnt[60 - i]\\n        return ans + cnt[0] * (cnt[0] - 1) // 2 + cnt[30] * (cnt[30] - 1) // 2\\n```", "def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ", "def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        "]}
{"id": "1073", "ref_py": ["def shipWithinDays(self, weights, days):\\r\\n        \\r\\n        lower = max(weights)\\r\\n        upper = sum(weights)\\r\\n        def canship(capacity):\\r\\n            num_days = 1\\r\\n            curr = 0\\r\\n            for w in weights:\\r\\n                curr += w\\r\\n                if curr > capacity:\\r\\n                    num_days += 1\\r\\n                    curr = w\\r\\n            return num_days <= days\\r\\n", "def shipWithinDays(self, weights: List[int], days: int) -> int:\\r\\n        left = max(weights)\\r\\n        right = sum(weights)\\r\\n        while left < right:\\r\\n            mid = (left + right) // 2\\r\\n            need, cur = 1, 0\\r\\n            for w in weights:\\r\\n                if cur + w > mid:\\r\\n                    need += 1\\r\\n                    cur = 0\\r\\n                cur += w\\r\\n            if need > days:\\r\\n                left = mid + 1\\r\\n            else:\\r\\n                right = mid\\r\\n        return left\\r\\n\\r\\n```\\r\\n", "def shipWithinDays(self, weights: List[int], days: int) -> int:\\r\\n        left = max(weights)\\r\\n        right = sum(weights)\\r\\n        while left < right:\\r\\n            mid = (left + right) // 2\\r\\n            need, cur = 1, 0\\r\\n            for w in weights:\\r\\n                if cur + w > mid:\\r\\n                    need += 1\\r\\n                    cur = 0\\r\\n                cur += w\\r\\n            if need > days:\\r\\n                left = mid + 1\\r\\n            else:\\r\\n                right = mid\\r\\n        return left\\r\\n\\r\\n```\\r\\n"]}
{"id": "1074", "ref_py": ["def maxScoreSightseeingPair(self, values: List[int]) -> int:      \\n      dp = [0]*(len(values))\\n      dp[0] = values[0]\\n      maxVal = 0\\n      \\n      for i in range(1, len(values)):\\n        dp[i] = max(dp[i-1], values[i-1]+i-1)\\n        maxVal = max(maxVal, dp[i]+values[i]-i)\\n      \\n      return maxVal\\n```", "def maxScoreSightseeingPair(self, values: List[int]) -> int:      \\n      dp = [0]*(len(values))\\n      dp[0] = values[0]\\n      maxVal = 0\\n      \\n      for i in range(1, len(values)):\\n        dp[i] = max(dp[i-1], values[i-1]+i-1)\\n        maxVal = max(maxVal, dp[i]+values[i]-i)\\n      \\n      return maxVal\\n```", "def maxScoreSightseeingPair(self, values: List[int]) -> int:      \\n      dp = [0]*(len(values))\\n      dp[0] = values[0]\\n      maxVal = 0\\n      \\n      for i in range(1, len(values)):\\n        dp[i] = max(dp[i-1], values[i-1]+i-1)\\n        maxVal = max(maxVal, dp[i]+values[i]-i)\\n      \\n      return maxVal\\n```"]}
{"id": "1075", "ref_py": ["define the remainder as the state\\n\\t* The stop condition is that the remainder is 0, so 0 is the stop state.\\n\\t* `k = 7` can stop after 6 transfers, so we `return 6`", "def smallestRepunitDivByK(self, k: int) -> int:\\n        if not k % 2 or not k % 5: return -1\\n        n = length = 1\\n        while True:\\n            if not n % k: return length\\n            length += 1\\n            n = 10*n + 1\\n```", "def smallestRepunitDivByK(self, k: int) -> int:\\n        if not k % 2 or not k % 5: return -1\\n        n = length = 1\\n        while True:\\n            if not n % k: return length\\n            length += 1\\n            n = 10*n + 1\\n```"]}
{"id": "1076", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def minDiffInBST(self, root):\\n        \\n        \\n        rootStack = []\\n        previous = None\\n        minimum = float(\\'inf\\')\\n        while rootStack or root:\\n            while root:\\n                rootStack.append(root)\\n                root = root.left\\n            root = rootStack.pop()\\n            minimum = min(root.val - previous.val, minimum) if previous else minimum\\n            previous = root\\n            root = root.right\\n        return minimum\\n```", "def minDiffInBST(self, root):\\n        \\n        \\n        rootStack = []\\n        previous = None\\n        minimum = float(\\'inf\\')\\n        while rootStack or root:\\n            while root:\\n                rootStack.append(root)\\n                root = root.left\\n            root = rootStack.pop()\\n            minimum = min(root.val - previous.val, minimum) if previous else minimum\\n            previous = root\\n            root = root.right\\n        return minimum\\n```"]}
{"id": "1077", "ref_py": ["def baseNeg2(self, n):\\n        if n == 0:\\n            return \"0\"\\n        res = []\\n        while n:\\n    ", "def baseNeg2(self, n):\\n        if n == 0:\\n            return \"0\"\\n        res = []\\n        while n:\\n    ", "def baseNeg2(self, n):\\n        if n == 0:\\n            return \"0\"\\n        res = []\\n        while n:\\n    "]}
{"id": "1078", "ref_py": ["def freqAlphabets(self, s: str) -> str:\\n\\tres = []\\n\\ti = 0", "def freqAlphabets(self, s: str) -> str:\\n        for i in range(26,0,-1): s = s.replace(str(i)+\\'", "def freqAlphabets(self, s: str) -> str:\\n        for i in range(26,0,-1): s = s.replace(str(i)+\\'"]}
{"id": "1079", "ref_py": ["def numEnclaves(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])", "def numEnclaves(self, A: List[List[int]]) -> int:\\n        m = len(A)\\n        n = len(A[0])", "def numEnclaves(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])"]}
{"id": "1080", "ref_py": ["def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\\n        def match(s):\\n            t,j,m,n=0,0,len(pattern),len(s)\\n            for i in range(n):\\n                if j==m:\\n                    t=i\\n                    break\\n                if pattern[j]==s[i]:\\n                    j+=1\\n                else:\\n                    if s[i].isupper():\\n                        return False\\n            if t!=0:\\n                for i in range(t+1,n):\\n                    if s[i].isupper():\\n                        return False\\n            return j==m\\n        a=[]\\n        for i in queries:\\n            a.append(match(i))\\n        return a\\n```", "def camelMatch(self, queries, pattern):\\n    ", "def camelMatch(self, queries, pattern):\\n    "]}
{"id": "1081", "ref_py": ["def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        max_jumps = [0]*101\\n        for l,r in clips:\\n            max_jumps[l] = max(max_jumps[l], r)\\n            \\n        ", "def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort()\\n        cur_farthest = 0\\n        farthest = 0\\n        ans = 0\\n        \\n        for x, y in clips:\\n            if x > cur_farthest: \\n                if x > farthest: return -1\\n                cur_farthest = farthest\\n                ans += 1\\n            farthest = max(farthest, y)\\n            if farthest >= time:\\n                return ans + 1\\n        return -1\\n```\\n", "def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort()\\n        cur_farthest = 0\\n        farthest = 0\\n        ans = 0\\n        \\n        for x, y in clips:\\n            if x > cur_farthest: \\n                if x > farthest: return -1\\n                cur_farthest = farthest\\n                ans += 1\\n            farthest = max(farthest, y)\\n            if farthest >= time:\\n                return ans + 1\\n        return -1\\n```\\n"]}
{"id": "1082", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def maxAncestorDiff(self, root):\\n        def getDiffMinMax(root):\\n            if not root.left and not root.right:  ", "def maxAncestorDiff(self, root: TreeNode) -> int:\\n        _, _, diff = self.max_diff(root)\\n        return diff"]}
{"id": "1083", "ref_py": ["def longestArithSeqLength(self, nums):", "def longestArithSeqLength(self, nums):", "def longestArithSeqLength(self, nums):"]}
{"id": "1084", "ref_py": ["def twoCitySchedCost(self, costs: List[List[int]]) -> int:\\n        ", "def twoCitySchedCost(self, costs: List[List[int]]) -> int:\\n        ", "def twoCitySchedCost(self, costs: List[List[int]]) -> int:\\n        "]}
{"id": "1085", "ref_py": ["define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`", "define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`", "define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`"]}
{"id": "1086", "ref_py": ["def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth", "def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth"]}
{"id": "1087", "ref_py": ["def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n", "def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n", "def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n"]}
{"id": "1088", "ref_py": ["def maxUncrossedLines(self, a: List[int], b: List[int]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return 0", "define the notation **DP[ y ][ x ]**.", "define the notation **DP[ y ][ x ]**."]}
{"id": "1089", "ref_py": ["def helper( self, node: TreeNode):", "def bstToGst(self, root: TreeNode) -> TreeNode:\\n        def change(value,root):\\n            if root is None:\\n                return value\\n            root.val=root.val+change(value,root.right)\\n            left=change(root.val,root.left)\\n            if root.left:\\n                return left\\n            return root.val\\n        change(0,root)\\n        return root\\n```", "def helper( self, node: TreeNode):"]}
{"id": "1090", "ref_py": ["def minScoreTriangulation(self, values: List[int]) -> int:\\n        def solve(i, j):\\n            if i+1 == j:\\n                return 0\\n            m = float(\\'inf\\')\\n            for k in range(i+1, j):\\n                m = min(m, values[i] * (values[j]*values[k]) + solve(i, k) + solve(k, j))\\n            return m\\n        return solve(0, len(values)-1)\\n    \\n", "def minScoreTriangulation(self, values):\\n        n = len(values)\\n        \\n        t = [[0 for c in range(n)] for r in range(n)]\\n        \\n        for s in range(2, n):\\n            for i in range(n-s):\\n                j = i + s\\n                t[i][j] = sys.maxint\\n                for l in range(i+1, j):\\n                    score = values[i]*values[j]*values[l] + t[i][l] + t[l][j]\\n                    if score < t[i][j]:\\n                        t[i][j] = score\\n                        \\n        return t[0][n-1]", "def minScoreTriangulation(self, values: List[int]) -> int:\\n        def solve(i, j):\\n            if i+1 == j:\\n                return 0\\n            m = float(\\'inf\\')\\n            for k in range(i+1, j):\\n                m = min(m, values[i] * (values[j]*values[k]) + solve(i, k) + solve(k, j))\\n            return m\\n        return solve(0, len(values)-1)\\n    \\n"]}
{"id": "1091", "ref_py": ["def numMovesStonesII(self, stones: List[int]) -> List[int]:\\n        \\n        stones.sort()\\n        n, lo = len(stones), inf", "def numMovesStonesII(self, stones: List[int]) -> List[int]:\\n        \\n        stones.sort()\\n        n, lo = len(stones), inf", "def numMovesStonesII(self, stones: List[int]) -> List[int]:\\n        \\n        stones.sort()\\n        n, lo = len(stones), inf"]}
{"id": "1092", "ref_py": ["def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```", "def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```", "def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```"]}
{"id": "1093", "ref_py": ["def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1", "def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1", "def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1"]}
{"id": "1094", "ref_py": ["def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            return maxAns\\n        n=len(arr)\\n        return solve(0)", "def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            ", "def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            "]}
{"id": "1096", "ref_py": ["def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key=len): dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```", "def longestStrChain(self, words):\\n        \\n        ", "def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key=len): dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```"]}
{"id": "1097", "ref_py": ["def og_knapsack(values, weights, i, T):\\n    \\'\\'\\' i = n,1; O(2^n) time, O(1) space \\'\\'\\'\\n    if i == -1 or T == 0:\\n        return 0\\n    if weights[i] > T:\\n        return og_knapsack(values, weights, i-1, T)\\n    else:\\n        with_i = values[i] + og_knapsack(values, weights, i-1, T-weights[i])\\n        without_i = og_knapsack(values, weights, i-1, T)\\n        return max(with_i, without_i)\\n```", "def lastStoneWeightII(self, stones: List[int]) -> int:\\n\\t\\n        return self.recursive(stones, 0, 0, 0)", "def og_knapsack(values, weights, i, T):\\n    \\'\\'\\' i = n,1; O(2^n) time, O(1) space \\'\\'\\'\\n    if i == -1 or T == 0:\\n        return 0\\n    if weights[i] > T:\\n        return og_knapsack(values, weights, i-1, T)\\n    else:\\n        with_i = values[i] + og_knapsack(values, weights, i-1, T-weights[i])\\n        without_i = og_knapsack(values, weights, i-1, T)\\n        return max(with_i, without_i)\\n```"]}
{"id": "1098", "ref_py": ["def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        satisfied=0\\n        n=len(grumpy)\\n        satisfied=sum([customers[i]*(1-grumpy[i]) for i in range(n)])\\n        max_satisfied=satisfied\\n        for i in range(n):\\n            if grumpy[i]==1: satisfied+=customers[i]    \\n            if i>=minutes:\\n                if grumpy[i-minutes]==1: satisfied-=customers[i-minutes]\\n            max_satisfied=max(satisfied,max_satisfied)\\n        return max_satisfied\\n", "def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        satisfied=0\\n        n=len(grumpy)\\n        satisfied=sum([customers[i]*(1-grumpy[i]) for i in range(n)])\\n        max_satisfied=satisfied\\n        for i in range(n):\\n            if grumpy[i]==1: satisfied+=customers[i]    \\n            if i>=minutes:\\n                if grumpy[i-minutes]==1: satisfied-=customers[i-minutes]\\n            max_satisfied=max(satisfied,max_satisfied)\\n        return max_satisfied\\n", "def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        satisfied=0\\n        n=len(grumpy)\\n        satisfied=sum([customers[i]*(1-grumpy[i]) for i in range(n)])\\n        max_satisfied=satisfied\\n        for i in range(n):\\n            if grumpy[i]==1: satisfied+=customers[i]    \\n            if i>=minutes:\\n                if grumpy[i-minutes]==1: satisfied-=customers[i-minutes]\\n            max_satisfied=max(satisfied,max_satisfied)\\n        return max_satisfied\\n"]}
{"id": "1099", "ref_py": ["def prevPermOpt1(self, A):\\n        i = len(A) - 2\\n        while i >= 0 and A[i] <= A[i+1]:\\n            i -= 1\\n        if i >= 0:\\n\\t\\t\\tmax_ = i + 1\\n\\t\\t\\t", "def prevPermOpt1(self, A):\\n        i = len(A) - 2\\n        while i >= 0 and A[i] <= A[i+1]:\\n            i -= 1\\n        if i >= 0:\\n\\t\\t\\tmax_ = i + 1\\n\\t\\t\\t", "def prevPermOpt1(self, A):\\n        i = len(A) - 2\\n        while i >= 0 and A[i] <= A[i+1]:\\n            i -= 1\\n        if i >= 0:\\n\\t\\t\\tmax_ = i + 1\\n\\t\\t\\t"]}
{"id": "1100", "ref_py": ["def rearrangeBarcodes(barcodes):", "def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\\n\\t\\t", "def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\\n\\t\\t"]}
{"id": "1101", "ref_py": ["def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.size = [1 for _ in range(n+1)]", "default value is -1.", "default value is -1."]}
{"id": "1103", "ref_py": ["def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\\n        counter = Counter()\\n        max_val = 2 ** len(matrix[0]) - 1\\n        for row in matrix:\\n            v = self.calculate_binary(row)\\n            counter[v] += 1\\n            counter[max_val - v] += 1\\n            ", "def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\\n        counter = Counter()\\n        max_val = 2 ** len(matrix[0]) - 1\\n        for row in matrix:\\n            v = self.calculate_binary(row)\\n            counter[v] += 1\\n            counter[max_val - v] += 1\\n            ", "def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\\n        counter = Counter()\\n        max_val = 2 ** len(matrix[0]) - 1\\n        for row in matrix:\\n            v = self.calculate_binary(row)\\n            counter[v] += 1\\n            counter[max_val - v] += 1\\n            "]}
{"id": "1104", "ref_py": ["def addNegabinary(self, arr1, arr2):\\n        \\n        def to_integer(arr):\\n            n = len(arr)\\n            converted = 0\\n            for i in range(n):\\n                converted += (-2)**(n-1-i) if arr[i] != 0 else 0\\n            return converted\\n        \\n        def to_negabinary(n):\\n            if n == 0:\\n                return \\'0\\'\\n            \\n            result = \\'\\'\\n            while n != 0:\\n                remainder = n % -2\\n                n //= -2\\n                if remainder < 0:\\n                    remainder += 2\\n                    n += 1\\n                result = str(remainder) + result\\n                \\n            return result", "def addNegabinary(self, arr1, arr2):\\n        \\n        def to_integer(arr):\\n            n = len(arr)\\n            converted = 0\\n            for i in range(n):\\n                converted += (-2)**(n-1-i) if arr[i] != 0 else 0\\n            return converted\\n        \\n        def to_negabinary(n):\\n            if n == 0:\\n                return \\'0\\'\\n            \\n            result = \\'\\'\\n            while n != 0:\\n                remainder = n % -2\\n                n //= -2\\n                if remainder < 0:\\n                    remainder += 2\\n                    n += 1\\n                result = str(remainder) + result\\n                \\n            return result", "def addNegabinary(self, arr1, arr2):\\n        \\n        def to_integer(arr):\\n            n = len(arr)\\n            converted = 0\\n            for i in range(n):\\n                converted += (-2)**(n-1-i) if arr[i] != 0 else 0\\n            return converted\\n        \\n        def to_negabinary(n):\\n            if n == 0:\\n                return \\'0\\'\\n            \\n            result = \\'\\'\\n            while n != 0:\\n                remainder = n % -2\\n                n //= -2\\n                if remainder < 0:\\n                    remainder += 2\\n                    n += 1\\n                result = str(remainder) + result\\n                \\n            return result"]}
{"id": "1105", "ref_py": ["def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]", "def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]", "def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]"]}
{"id": "1106", "ref_py": ["def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:", "def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:", "def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:"]}
{"id": "1107", "ref_py": ["def smallestSubsequence(self, s: str) -> str:\\n        stack, seen = [], set()\\n        last = {c:idx for idx,c in enumerate(s)}\\n        for idx, char in enumerate(s):\\n            if char in seen:\\n                continue\\n            while stack and stack[-1] > char and idx < last[stack[-1]]:\\n                c = stack.pop()\\n                seen.remove(c)\\n            stack.append(char)\\n            seen.add(char)\\n        return \"\".join(stack)", "def smallestSubsequence(self, s: str) -> str:\\n        stack, seen = [], set()\\n        last = {c:idx for idx,c in enumerate(s)}\\n        for idx, char in enumerate(s):\\n            if char in seen:\\n                continue\\n            while stack and stack[-1] > char and idx < last[stack[-1]]:\\n                c = stack.pop()\\n                seen.remove(c)\\n            stack.append(char)\\n            seen.add(char)\\n        return \"\".join(stack)", "def smallestSubsequence(self, s: str) -> str:\\n        stack, seen = [], set()\\n        last = {c:idx for idx,c in enumerate(s)}\\n        for idx, char in enumerate(s):\\n            if char in seen:\\n                continue\\n            while stack and stack[-1] > char and idx < last[stack[-1]]:\\n                c = stack.pop()\\n                seen.remove(c)\\n            stack.append(char)\\n            seen.add(char)\\n        return \"\".join(stack)"]}
{"id": "1108", "ref_py": ["def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\\n        labelsUsed = {}\\n        for label in set(labels):\\n            labelsUsed[label] = 0\\n        items = [(values[i], labels[i]) for i in range(len(values))]\\n        items.sort(reverse=True)\\n        score = 0\\n        for item in items:\\n            if numWanted == 0:\\n                return score\\n            if labelsUsed[item[1]] < useLimit:\\n                labelsUsed[item[1]] += 1\\n                score += item[0]\\n                numWanted -= 1\\n        return score\\n```", "def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\\n        labelsUsed = {}\\n        for label in set(labels):\\n            labelsUsed[label] = 0\\n        items = [(values[i], labels[i]) for i in range(len(values))]\\n        items.sort(reverse=True)\\n        score = 0\\n        for item in items:\\n            if numWanted == 0:\\n                return score\\n            if labelsUsed[item[1]] < useLimit:\\n                labelsUsed[item[1]] += 1\\n                score += item[0]\\n                numWanted -= 1\\n        return score\\n```", "def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\\n        labelsUsed = {}\\n        for label in set(labels):\\n            labelsUsed[label] = 0\\n        items = [(values[i], labels[i]) for i in range(len(values))]\\n        items.sort(reverse=True)\\n        score = 0\\n        for item in items:\\n            if numWanted == 0:\\n                return score\\n            if labelsUsed[item[1]] < useLimit:\\n                labelsUsed[item[1]] += 1\\n                score += item[0]\\n                numWanted -= 1\\n        return score\\n```"]}
{"id": "1109", "ref_py": ["def shortestPathBinaryMatrix(self, grid: list[list[int]]) -> int:\\n        n = len(grid)\\n        start, end = (0, 0), (n - 1, n - 1)", "def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:", "def shortestPathBinaryMatrix(self, grid):\\n        shortest_path = a_star_graph_search(\\n            start              = (0, 0), \\n            goal_function      = get_goal_function(grid),\\n            successor_function = get_successor_function(grid),\\n            heuristic          = get_heuristic(grid)\\n        )\\n        if shortest_path is None or grid[0][0] == 1:\\n            return -1\\n        else:\\n            return len(shortest_path)\\n```"]}
{"id": "1110", "ref_py": ["def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        test_list = sorted(nums)\\n        answer = []\\n        for i in nums:\\n            answer.append(test_list.index(i))\\n        return answer\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>ordered_version = nums;\\n        vector<int>answer;\\n        sort(ordered_version.begin(), ordered_version.end());\\n        \\n        for (auto it = nums.begin(); it != nums.end(); it++){\\n            for (int i = 0; i < ordered_version.size(); i++){\\n                if ( *it == ordered_version.at(i)){\\n                    answer.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```"]}
{"id": "1111", "ref_py": ["def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\\n        ", "default `return True`\\n\\t\\n* for example `trips = [[2,1,5],[3,3,7]], capacity = 4`\\n![image](https://assets.leetcode.com/users/images/0f15c22e-4752-4bc3-92af-3970b748d79b_1641457674.3701046.png)\\n\\t* the number of the **net increase** passengers for each stop\\n\\t\\t* `increase[0] = 0`\\n\\t\\t* `increase[1] = 2`\\n\\t\\t* `increase[2] = 0`\\n\\t\\t* `increase[3] = 3`\\n\\t\\t* `increase[4] = 0`\\n\\t\\t* `increase[5] = -2`\\n\\t\\t* `increase[6] = 0`\\n\\t\\t* `increase[7] = -3`\\n\\t\\t* `increase[8] = 0`\\n\\t\\t* `...`\\n\\t\\t* `increase[1000] = 0`\\n\\t* from start to end, for each stop we calculate the number of passengers in the car.\\n\\t\\t* stop 0: `in_car = 0`\\n\\t\\t* stop 1: `in_car = 2`\\n\\t\\t* stop 2: `in_car = 2`\\n\\t\\t* stop 3: `in_car = 5  ", "def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\\n        "]}
{"id": "1112", "ref_py": ["def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n\\t\\treturn all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\\n```", "def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\treturn all(v <= 3 for v in ((Counter(list(word1)) - Counter(list(word2))) + (Counter(list(word2)) - Counter(list(word1)))).values())\\n```", "def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n\\t\\treturn all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\\n```"]}
{"id": "1113", "ref_py": ["def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:        ", "def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:        ", "def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:        "]}
{"id": "1114", "ref_py": ["def corpFlightBookings(self, bookings, n: int):\\n        ans = [0]*(n+1)\\n        for i,j,k in bookings:\\n            ans[i-1] += k\\n            ans[j]   -= k\\n        ans.pop()\\n        prev = ans[0]\\n        for i in range(1,n):\\n            prev = ans[i] = prev + ans[i]\\n        return ans\\n```", "def corpFlightBookings(self, bookings, n: int):\\n        ans = [0]*(n+1)\\n        for i,j,k in bookings:\\n            ans[i-1] += k\\n            ans[j]   -= k\\n        ans.pop()\\n        prev = ans[0]\\n        for i in range(1,n):\\n            prev = ans[i] = prev + ans[i]\\n        return ans\\n```", "def corpFlightBookings(self, bookings, n: int):\\n        ans = [0]*(n+1)\\n        for i,j,k in bookings:\\n            ans[i-1] += k\\n            ans[j]   -= k\\n        ans.pop()\\n        prev = ans[0]\\n        for i in range(1,n):\\n            prev = ans[i] = prev + ans[i]\\n        return ans\\n```"]}
{"id": "1115", "ref_py": ["def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:\\n        ", "def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\\n        ans = []\\n        to_delete = set(to_delete)\\n        \\n        def helper(node):\\n            if not node:\\n                return None\\n            node.left = helper(node.left)\\n            node.right = helper(node.right)\\n\\t\\t\\t\\n\\t\\t\\t", "def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\\n        ans = []\\n        to_delete = set(to_delete)\\n        \\n        def helper(node):\\n            if not node:\\n                return None\\n            node.left = helper(node.left)\\n            node.right = helper(node.right)\\n\\t\\t\\t\\n\\t\\t\\t"]}
{"id": "1116", "ref_py": ["def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans=[]\\n        prev=1\\n        for i in seq:\\n            if i==\\'(\\':\\n                if prev==0:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n            else:\\n                ans.append(prev)\\n            if prev==0:\\n                prev=1\\n            else:\\n                prev=0\\n        return ans\\n```", "def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        m,c,n=0,0,len(seq)\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                m=max(c,m) ", "def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        m,c,n=0,0,len(seq)\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                m=max(c,m) "]}
{"id": "1120", "ref_py": ["def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def getLeaves(root):\\n            q=deque([root])\\n            while q:\\n                leaves=[]    \\n                for i in range(len(q)):\\n                    node=q.popleft()\\n                    leaves.append(node)\\n                    \\n                    if node.left:\\n                        q.append(node.left)\\n                    if node.right:\\n                        q.append(node.right)\\n            return leaves\\n        \\n        leaves=getLeaves(root)\\n        leaves=set(leaves)\\n        \\n        def getLCA(root):\\n            if not root:return\\n            if root in leaves:\\n                return root\\n            left=getLCA(root.left)\\n            right=getLCA(root.right)\\n            return root if left and right else left or right\\n        \\n        return getLCA(root)\\n                \\n```", "def ht(self, node):\\n        if not node:\\n            return 0\\n        return max(self.ht(node.left), self.ht(node.right)) + 1\\n    \\n    def dfs(self, node):\\n        if not node:\\n            return None\\n        left, right = self.ht(node.left), self.ht(node.right)\\n        if left == right:\\n            return node\\n        if left > right:\\n            return self.dfs(node.left)\\n        if left < right:\\n            return self.dfs(node.right)", "def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def getLeaves(root):\\n            q=deque([root])\\n            while q:\\n                leaves=[]    \\n                for i in range(len(q)):\\n                    node=q.popleft()\\n                    leaves.append(node)\\n                    \\n                    if node.left:\\n                        q.append(node.left)\\n                    if node.right:\\n                        q.append(node.right)\\n            return leaves\\n        \\n        leaves=getLeaves(root)\\n        leaves=set(leaves)\\n        \\n        def getLCA(root):\\n            if not root:return\\n            if root in leaves:\\n                return root\\n            left=getLCA(root.left)\\n            right=getLCA(root.right)\\n            return root if left and right else left or right\\n        \\n        return getLCA(root)\\n                \\n```"]}
{"id": "1121", "ref_py": ["def longestWPI(self, hours: List[int]) -> int:\\n        ", "def longestWPI(self, hours: List[int]) -> int:\\n        ", "def longestWPI(self, hours: List[int]) -> int:\\n        "]}
{"id": "1122", "ref_py": ["def shortestAlternatingPaths(self, n: int, red_edges: list[list[int]], blue_edges: list[list[int]]) -> list[int]:\\n        RED, BLUE = -1, +1\\n        flip = lambda color: -color ", "def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\\n        \\n        graph = {i:[] for i in range(n)}\\n        for x,y in redEdges:\\n            graph[x].append([y,\"R\"])\\n            \\n        \\n        for x,y in blueEdges:\\n            \\n            graph[x].append([y,\"B\"])\\n           \\n        \\n        \\n        def bfs(node):\\n            queue = collections.deque([[0,-1,0]])\\n            visited = set()\\n            visited.add((0,-1))\\n            while len(queue)>0:\\n                \\n                curr_node,prev_color,curr_dist = queue.popleft()\\n                if curr_node == node:\\n                    return curr_dist\\n                for children,color in graph[curr_node]:\\n                    if prev_color == -1:\\n                        if (children,color) not in visited:\\n                            queue.append([children,color,curr_dist+1])\\n                            visited.add((children,color))\\n                    elif prev_color == \"R\":\\n                        if color == \"B\":\\n                            if (children,color) not in visited:\\n                                queue.append([children,color,curr_dist+1])\\n                                visited.add((children,color))\\n                    elif prev_color == \"B\":\\n                        if color == \"R\":\\n                            if (children,color) not in visited:\\n                                queue.append([children,color,curr_dist+1])\\n                                visited.add((children,color))\\n            \\n            return -1\\n            \\n            \\n        ans = [0]\\n        for i in range(1,n):\\n            dist = bfs(i)\\n            ans.append(dist)\\n        \\n        return ans", "def shortestAlternatingPaths(self, n: int, red_edges: list[list[int]], blue_edges: list[list[int]]) -> list[int]:\\n        RED, BLUE = -1, +1\\n        flip = lambda color: -color "]}
{"id": "1123", "ref_py": ["def mctFromLeafValues(self, arr: List[int]) -> int:\\n        i = j = None\\n        res = 0", "def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        arr = [float(\\'inf\\')] + arr + [float(\\'inf\\')]\\n        n, res = len(arr), 0\\n        \\n        while n>3:\\n            mi = min(arr)\\n            ind = arr.index(mi)\\n            \\n            if arr[ind-1]<arr[ind+1]:\\n                res+=arr[ind-1]*arr[ind]\\n            else:\\n                res+=arr[ind+1]*arr[ind]\\n            \\n            arr.remove(mi)\\n            n = len(arr)\\n        \\n        return res", "def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = {}\\n        def findMax(start,end):\\n            if (start,end) in d: return d[(start,end)]\\n            maxx = start\\n            for i in range(start+1,end+1):\\n                if arr[maxx] < arr[i] : maxx = i\\n            d[(start,end)] = arr[maxx]\\n            return arr[maxx]\\n        \\n        dp = [[float(\\'inf\\') for i in range(n)] for j in range(n)]\\n        for gap in range(n):\\n            for row in range(n - gap):\\n                col = row + gap\\n                if gap == 0:\\n                    dp[row][col] = 0\\n                elif gap == 1:\\n                    dp[row][col] = arr[row] * arr[col]\\n                else:\\n                    for k in range(row,col):\\n                        val = dp[row][k] + findMax(row,k) * findMax(k+1,col) + dp[k+1][col]\\n                        if val < dp[row][col]: dp[row][col] = val\\n                "]}
{"id": "1124", "ref_py": ["def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n\\t", "def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n\\t", "def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n\\t"]}
{"id": "1125", "ref_py": ["def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        test_list = sorted(nums)\\n        answer = []\\n        for i in nums:\\n            answer.append(test_list.index(i))\\n        return answer\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>ordered_version = nums;\\n        vector<int>answer;\\n        sort(ordered_version.begin(), ordered_version.end());\\n        \\n        for (auto it = nums.begin(); it != nums.end(); it++){\\n            for (int i = 0; i < ordered_version.size(); i++){\\n                if ( *it == ordered_version.at(i)){\\n                    answer.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```"]}
{"id": "1126", "ref_py": ["def find132pattern(self, nums: List[int]) -> bool:\\n        length = len(nums)", "def find132pattern(self, nums: List[int]) -> bool:\\n        stack=[]\\n        curMin=nums[0]\\n        for num in nums:\\n            while stack and num>=stack[-1][0]:\\n                stack.pop()", "def find132pattern(self, nums: List[int]) -> bool:\\n        length = len(nums)"]}
{"id": "1127", "ref_py": ["defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check.", "defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check.", "defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check."]}
{"id": "1128", "ref_py": ["def longestCommonSubsequence(self, text1: str, text2: str):\\n        l1 = len(text1)\\n        l2 = len(text2)", "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def memo_solve(ptr1, ptr2):\\n            if ptr1 == len(text1) or ptr2 == len(text2):\\n                return 0\\n            \\n            ", "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def memo_solve(ptr1, ptr2):\\n            if ptr1 == len(text1) or ptr2 == len(text2):\\n                return 0\\n            \\n            "]}
{"id": "1129", "ref_py": ["def movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tif(n == 1):\\n\\t\\treturn 0\\n\\tt1 = t2 = 0\\n\\tfor i in range(n):\\n\\t\\t", "def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        cur_0 = 0\\n        for i in range(0, n, 2):\\n            nei = min(nums[i-1] if i - 1 >= 0 else 1001, nums[i+1] if i + 1 < n else 1001)\\n            cur_0 += max(nums[i] - nei + 1, 0)\\n        cur_1 = 0\\n        for i in range(1, n, 2):\\n            nei = min(nums[i-1] if i - 1 >= 0 else 1001, nums[i+1] if i + 1 < n else 1001)\\n            cur_1 += max(nums[i] - nei + 1, 0);\\n        return min(cur_0, cur_1)\\n```", "def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        cur_0 = 0\\n        for i in range(0, n, 2):\\n            nei = min(nums[i-1] if i - 1 >= 0 else 1001, nums[i+1] if i + 1 < n else 1001)\\n            cur_0 += max(nums[i] - nei + 1, 0)\\n        cur_1 = 0\\n        for i in range(1, n, 2):\\n            nei = min(nums[i-1] if i - 1 >= 0 else 1001, nums[i+1] if i + 1 < n else 1001)\\n            cur_1 += max(nums[i] - nei + 1, 0);\\n        return min(cur_0, cur_1)\\n```"]}
{"id": "1130", "ref_py": ["def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\\n        first = None\\n        def count(node):\\n            nonlocal first\\n            total = 0\\n            if node: \\n                if node.val == x: first = node\\n                total += count(node.left) + count(node.right) + 1\\n            return total\\n        \\n        s = count(root) ", "def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\\n        first = None\\n        def count(node):\\n            nonlocal first\\n            total = 0\\n            if node: \\n                if node.val == x: first = node\\n                total += count(node.left) + count(node.right) + 1\\n            return total\\n        \\n        s = count(root) ", "def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\\n        first = None\\n        def count(node):\\n            nonlocal first\\n            total = 0\\n            if node: \\n                if node.val == x: first = node\\n                total += count(node.left) + count(node.right) + 1\\n            return total\\n        \\n        s = count(root) "]}
{"id": "1132", "ref_py": ["def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        if n==1:\\n            return int(0<target<=k)\\n        \\n        ans=0\\n        for i in range(1,k+1):\\n            ans+=self.numRollsToTarget(n-1,k,target-i)\\n        return ans%(10**9+7)\\n```", "def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        if n==1:\\n            return int(0<target<=k)\\n        \\n        ans=0\\n        for i in range(1,k+1):\\n            ans+=self.numRollsToTarget(n-1,k,target-i)\\n        return ans%(10**9+7)\\n```", "def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        if n==1:\\n            return int(0<target<=k)\\n        \\n        ans=0\\n        for i in range(1,k+1):\\n            ans+=self.numRollsToTarget(n-1,k,target-i)\\n        return ans%(10**9+7)\\n```"]}
{"id": "1133", "ref_py": ["def maxRepOpt1(S):\\n    \\n    ", "def maxRepOpt1(self, text: str) -> int:\\n        total = [0] * 26\\n        win = [0] * 26\\n        distinct = 0\\n        left = 0\\n        ans = 0\\n        for x in text: total[ord(x) - ord(\\'a\\')] += 1\\n        \\n        for i, x in enumerate(text):\\n            \\n            if win[ord(x) - ord(\\'a\\')] == 0: distinct += 1\\n            win[ord(x) - ord(\\'a\\')] += 1\\n            total[ord(x) - ord(\\'a\\')] -= 1\\n            \\n            while distinct > 2 or distinct == 2 and min(y for y in win if y) > 1:\\n                win[ord(text[left]) - ord(\\'a\\')] -= 1\\n                if win[ord(text[left]) - ord(\\'a\\')] == 0: distinct -= 1\\n                total[ord(text[left]) - ord(\\'a\\')] += 1\\n                left += 1\\n            ans = max(ans, i - left + 1 - (distinct == 2) + (total[max(range(26), key=lambda x: win[x])] > 0))", "def maxRepOpt1(self, text: str) -> int:\\n        total = [0] * 26\\n        win = [0] * 26\\n        distinct = 0\\n        left = 0\\n        ans = 0\\n        for x in text: total[ord(x) - ord(\\'a\\')] += 1\\n        \\n        for i, x in enumerate(text):\\n            \\n            if win[ord(x) - ord(\\'a\\')] == 0: distinct += 1\\n            win[ord(x) - ord(\\'a\\')] += 1\\n            total[ord(x) - ord(\\'a\\')] -= 1\\n            \\n            while distinct > 2 or distinct == 2 and min(y for y in win if y) > 1:\\n                win[ord(text[left]) - ord(\\'a\\')] -= 1\\n                if win[ord(text[left]) - ord(\\'a\\')] == 0: distinct -= 1\\n                total[ord(text[left]) - ord(\\'a\\')] += 1\\n                left += 1\\n            ans = max(ans, i - left + 1 - (distinct == 2) + (total[max(range(26), key=lambda x: win[x])] > 0))"]}
{"id": "1135", "ref_py": ["def maxLevelSum(self, root):\\n        lis = [root] ", "def maxLevelSum(self, root: Optional[TreeNode]) -> List[float]:\\n        level_sum = defaultdict(int)", "def maxLevelSum(self, root: Optional[TreeNode]) -> List[float]:\\n        level_sum = defaultdict(int)"]}
{"id": "1136", "ref_py": ["def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\\n        dsu = DSU()\\n        for u, v in edges:\\n            if dsu.is_connected(u, v): return [u, v]\\n            dsu.union(u, v)\\n    \\nclass DSU:\\n    T = Hashable", "define two functions: **union** and **find**. The **find** function will **recursively** trace a node\\'s lineage back to its ultimate parent and update its value in the parent array (**par**), providing a shortcut for the next link.", "defaultdict(list) \\n        \\n        ans = []\\n\\t\\t"]}
{"id": "1138", "ref_py": ["defaultdict", "defaultdict", "defaultdict"]}
{"id": "1139", "ref_py": ["def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\\n\\t\\t\\tdef f(s):\\n\\t\\t\\t\\tt = sorted(list(s))[0]\\n\\t\\t\\t\\treturn s.count(t)\\n\\t\\t\\tquery = [f(x) for x in queries]\\n\\t\\t\\tword = [f(x) for x in words]\\n\\t\\t\\tm = []\\n\\t\\t\\tfor x in query:\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tfor y in word:\\n\\t\\t\\t\\t\\tif y>x:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tm.append(count)\\n", "def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\\n\\t\\t\\tdef f(s):\\n\\t\\t\\t\\tt = sorted(list(s))[0]\\n\\t\\t\\t\\treturn s.count(t)\\n\\t\\t\\tquery = [f(x) for x in queries]\\n\\t\\t\\tword = [f(x) for x in words]\\n\\t\\t\\tm = []\\n\\t\\t\\tfor x in query:\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tfor y in word:\\n\\t\\t\\t\\t\\tif y>x:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tm.append(count)\\n", "def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\\n\\t\\t\\tdef f(s):\\n\\t\\t\\t\\tt = sorted(list(s))[0]\\n\\t\\t\\t\\treturn s.count(t)\\n\\t\\t\\tquery = [f(x) for x in queries]\\n\\t\\t\\tword = [f(x) for x in words]\\n\\t\\t\\tm = []\\n\\t\\t\\tfor x in query:\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tfor y in word:\\n\\t\\t\\t\\t\\tif y>x:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tm.append(count)\\n"]}
{"id": "1140", "ref_py": ["def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:", "def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:", "def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:"]}
{"id": "1142", "ref_py": ["def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:", "def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:", "def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:"]}
{"id": "1143", "ref_py": ["def largestOddNumber(self, num: str) -> str:\\n        ln = len(num) - 1\\n        for i in range(ln, -1, -1):\\n            ch = num[i]\\n            if int(ch) % 2 != 0:\\n                return num[:i + 1]\\n        return \"\"\\n```\\n``` Java []\\npublic class Solution {\\n    public String largestOddNumber(String num) {\\n        String result = \"\";\\n        int ln = num.length() - 1;\\n        for (int i = ln; i >= 0; i--) {\\n            char ch = num.charAt(i);\\n            if (Character.getNumericValue(ch) % 2 != 0) {\\n                return num.substring(0, i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n``` Rust []\\npub fn largest_odd_number(num: &str) -> String {\\n    let ln = num.len();\\n    for (i, ch) in num.chars().rev().enumerate() {\\n        if ch.to_digit(10).unwrap() % 2 != 0 {\\n            return num[..ln - i].to_string();\\n        }\\n    }\\n    String::new()\\n}", "def largestOddNumber(self, num: str) -> str:\\n        return num.rstrip(\\'02468\\')\\n```", "def largestOddNumber(self, num: str) -> str:\\n        return num.rstrip(\\'02468\\')\\n```"]}
{"id": "1144", "ref_py": ["def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.total_tilt = 0\\n        \\n        def calculate_tilt(node):\\n            if not node:\\n                return 0\\n            \\n            left_sum = calculate_tilt(node.left)\\n            right_sum = calculate_tilt(node.right)\\n            tilt = abs(left_sum - right_sum)\\n            \\n            self.total_tilt += tilt\\n            \\n            return left_sum + right_sum + node.val\\n        \\n        calculate_tilt(root)\\n        return self.total_tilt", "def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n", "def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n"]}
{"id": "1145", "ref_py": ["define all(var)                      var.begin(), var.end()\\nint mod_add(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\\nconst int mod = 1e9 + 7;\\n", "def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tmod = int(1e9+7)", "define all(var)                      var.begin(), var.end()\\nint mod_add(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\\nconst int mod = 1e9 + 7;\\n"]}
{"id": "1148", "ref_py": ["def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        times = [1,1,1]\\n        smallest = inf\\n        while n != 0:\\n            smallest = min ( times[0]*a,times[1]*b,times[2]*c)\\n            if times[0]*a == smallest: times[0] += 1\\n            if times[1]*b == smallest: times[1] += 1\\n            if times[2]*c == smallest: times[2] += 1\\n            n -= 1\\n        return smallest\\n```", "def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:", "def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        times = [1,1,1]\\n        smallest = inf\\n        while n != 0:\\n            smallest = min ( times[0]*a,times[1]*b,times[2]*c)\\n            if times[0]*a == smallest: times[0] += 1\\n            if times[1]*b == smallest: times[1] += 1\\n            if times[2]*c == smallest: times[2] += 1\\n            n -= 1\\n        return smallest\\n```"]}
{"id": "1149", "ref_py": ["def __init__(self, N):\\n        self.parent = [i for i in range(N)]\\n        self.size = [1 for _ in range(N)]\\n        self.components = N\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, a, b):\\n        ua = self.find(a)\\n        ub = self.find(b)\\n        if ua == ub:\\n            return False\\n        \\n        if self.size[ua] < self.size[ub]:\\n            ua, ub = ub, ua\\n        self.parent[ub] = ua\\n        self.size[ua] += self.size[ub]\\n        self.size[ub] = self.size[ua]\\n        self.components -= 1        \\n        return True", "defined swaps between two indexes as per `pairs` (0-indexed).", "def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        subsets = list(range(len(s)))\\n        \\n        def find(x):\\n            nonlocal subsets\\n            if x != subsets[x]:\\n                subsets[x] = find(subsets[x])\\n            return subsets[x]\\n        \\n        def union(x,y):\\n            nonlocal subsets\\n            s1 = find(x)\\n            s2 = find(y)\\n            subsets[s2] = s1\\n            \\n        for pair in pairs:\\n            union(pair[0],pair[1])\\n            \\n        components = defaultdict(list)\\n        alphabets = defaultdict(list)\\n        for i,v in enumerate(subsets):\\n\\t\\t\\tparent = find(v)\\n\\t\\t\\tcomponents[parent].append(i)\\n\\t\\t\\talphabets[parent].append(s[i])\\n        \\n"]}
{"id": "1151", "ref_py": ["def equalSubstring(self, s, t, maxCost):\\n        \\n        ", "def equalSubstring(self, s, t, maxCost):\\n        \\n        ", "def equalSubstring(self, s, t, maxCost):\\n        \\n        "]}
{"id": "1152", "ref_py": ["def removeDuplicates(self, s: str, k: int) -> str:        \\n        stck = [[\\'$\\', 0]]     ", "def removeDuplicates(self, s: str, k: int) -> str:\\n        a=[]\\n        for i in s:\\n            if a and a[-1][0]==i:\\n                a[-1][1]+=1\\n                if a[-1][1]==k: a.pop()\\n            else: a.append([i,1])\\n        return \\'\\'.join(key*value for key, value in a)        \\n```", "def removeDuplicates(self, s: str, k: int) -> str:        \\n        stck = [[\\'$\\', 0]]     "]}
{"id": "1153", "ref_py": ["def longestSubsequence(self, nums: List[int], difference: int) -> int:\\n        dp = defaultdict(int)", "def longestSubsequence(self, arr, difference):", "def longestSubsequence(self, nums: List[int], difference: int) -> int:\\n        dp = defaultdict(int)"]}
{"id": "1154", "ref_py": ["def canConstruct(self, ransomNote, magazine):\\n        ", "def canConstruct(self, ransomNote: str, magazine: str) -> bool:\\n        return all(ransomNote.count(c) <= magazine.count(c) for c in set(ransomNote))", "def canConstruct(self, ransomNote, magazine):\\n        "]}
{"id": "1155", "ref_py": ["def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\\n        q = {(x,y) for x,y in queens}\\n        ans = []", "def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\\n        q = {(x,y) for x,y in queens}\\n        ans = []", "def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\\n        q = {(x,y) for x,y in queens}\\n        ans = []"]}
{"id": "1157", "ref_py": ["def nthPersonGetsNthSeat(self, n: int) -> float:\\n        return 0.5 if n!=1 else 1\\n```", "definition*\\nLet\\'s define a function, dp(i), that returns the probability of the *i*th person sitting on the *i*th seat when we are dealing with a problem that has *i* number of people. ", "def nthPersonGetsNthSeat(self, n: int) -> float:\\n        return 0.5 if n!=1 else 1\\n```"]}
{"id": "1158", "ref_py": ["def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False", "def removeSubfolders(self, folder: List[str]) -> List[str]:\\n        folder.sort()        \\n        store = set()\\n        \\n        for path in folder:\\n            dirs = path.split(\"/\")\\n            \\n            add = True\\n            d = \"\"\\n            for char in dirs:\\n                if not char:\\n                    continue\\n                d += \"/\" + char\\n                if d in store:\\n                    add = False\\n                    break\\n            \\n            if add:\\n                store.add(path)           \\n                    \\n        return list(store)", "def removeSubfolders(self, folder: List[str]) -> List[str]:\\n        folder.sort()        \\n        store = set()\\n        \\n        for path in folder:\\n            dirs = path.split(\"/\")\\n            \\n            add = True\\n            d = \"\"\\n            for char in dirs:\\n                if not char:\\n                    continue\\n                d += \"/\" + char\\n                if d in store:\\n                    add = False\\n                    break\\n            \\n            if add:\\n                store.add(path)           \\n                    \\n        return list(store)"]}
{"id": "1159", "ref_py": ["def balancedString(self, s: str) -> int:\\n        length = len(s)\\n        charCount = {}\\n        left = 0\\n        ans = length\\n        targetCount = length // 4", "def balancedString(self, s: str) -> int:\\n        length = len(s)\\n        charCount = {}\\n        left = 0\\n        ans = length\\n        targetCount = length // 4", "def balancedString(self, s: str) -> int:\\n        length = len(s)\\n        charCount = {}\\n        left = 0\\n        ans = length\\n        targetCount = length // 4"]}
{"id": "1160", "ref_py": ["def findSolution(self, customfunction: \\'CustomFunction\\', z: int) -> List[List[int]]:\\n        res = []\\n        \\n        for x in range(1, 1001):\\n            for y in range(1, 1001):\\n                if customfunction.f(x, y) == z:\\n                    res.append([x, y])\\n                    \\n        return res\\n```", "def findSolution(self, customfunction: \\'CustomFunction\\', z: int) -> List[List[int]]:\\n\\tx, y = 1, z\\n\\tpairs = []\\n\\t\\n\\twhile x<=z and y>0:\\n\\t\\tcf = customfunction.f(x,y)\\n\\t\\tif cf==z:\\n\\t\\t\\tpairs.append([x,y])\\n\\t\\t\\tx, y = x+1, y-1\\n\\t\\telif cf > z:\\n\\t\\t\\ty -= 1\\n\\t\\telse:\\n\\t\\t\\tx += 1\\n\\treturn pairs\\n```", "def findSolution(self, customfunction: \\'CustomFunction\\', z: int) -> List[List[int]]:\\n        res=[]\\n        x,y=1,1000\\n        while x<1000 and y>0:\\n            if customfunction.f(x,y)==z:\\n                res.append([x,y])\\n                x+=1\\n                y-=1\\n            elif customfunction.f(x,y)>z:\\n                y-=1\\n            else:\\n                x+=1\\n        return res\\n```\\n**Runtime:**  143 ms\\t\\n**Memory Usage:**  13.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "1161", "ref_py": ["def __init__(self):\\n        self.cache = [[0] * 10 for _ in range(5001)]", "def knightDialer(self, n: int) -> int:\\n        MOD = 10**9 + 7\\n        moves = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\\n        dp = dict()\\n        \\n        ", "def knightDialer(self, n: int) -> int:\\n        MOD = 10**9 + 7\\n        moves = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\\n        dp = dict()\\n        \\n        "]}
{"id": "1162", "ref_py": ["def maxLength(self, arr: List[str]) -> int:\\n        \\n\\t\\t\\tdef helper(index,visited):\\n\\t\\t\\t\\tif index >= len(arr):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tpossible = True     \\n\\t\\t\\t\\ttemp = set()      ", "def maxLength(self, arr: List[str]) -> int:\\n        \\n\\t\\t\\tdef helper(index,visited):\\n\\t\\t\\t\\tif index >= len(arr):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tpossible = True     \\n\\t\\t\\t\\ttemp = set()      ", "def maxLength(self, arr: List[str]) -> int:\\n        \\n\\t\\t\\tdef helper(index,visited):\\n\\t\\t\\t\\tif index >= len(arr):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tpossible = True     \\n\\t\\t\\t\\ttemp = set()      "]}
{"id": "1163", "ref_py": ["def minimumSwap(self, s1: str, s2: str) -> int:\\n        x_y, y_x = 0, 0\\n        for c1, c2 in zip(s1, s2):\\n            if c1 != c2:\\n                if c1 == \\'x\\':\\n                    x_y += 1\\n                else:\\n                    y_x += 1\\n                    \\n        if (x_y + y_x) % 2 == 1:\\n            return -1\\n        ", "def minimumSwap(self, s1: str, s2: str) -> int:\\n\\txy = yx = 0\\n\\tfor i in range(len(s1)):\\n\\t\\tif(s1[i] == \"x\" and s2[i] == \"y\"):\\n\\t\\t\\txy += 1\\n\\t\\tif(s2[i] == \"x\" and s1[i] == \"y\"):\\n\\t\\t\\tyx += 1\\n\\tif(xy%2 ^ yx%2):\\n\\t\\treturn -1\\n\\tans = xy//2 + yx//2 + (xy%2) * 2\\n", "def minimumSwap(self, s1: str, s2: str) -> int:\\n\\txy = yx = 0\\n\\tfor i in range(len(s1)):\\n\\t\\tif(s1[i] == \"x\" and s2[i] == \"y\"):\\n\\t\\t\\txy += 1\\n\\t\\tif(s2[i] == \"x\" and s1[i] == \"y\"):\\n\\t\\t\\tyx += 1\\n\\tif(xy%2 ^ yx%2):\\n\\t\\treturn -1\\n\\tans = xy//2 + yx//2 + (xy%2) * 2\\n"]}
{"id": "1164", "ref_py": ["def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0", "def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0", "def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0"]}
{"id": "1165", "ref_py": ["def minRemoveToMakeValid(self, s) :\\n        stack=[]\\n        split_str=list(s)\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                ", "def minRemoveToMakeValid(self, s: str) -> str:\\n    s = list(s)\\n    stack = []\\n    for i, char in enumerate(s):\\n        if char == \\'(\\':\\n            stack.append(i)\\n        elif char == \\')\\':\\n            if stack:\\n                stack.pop()\\n            else:\\n                s[i] = \\'\\'\\n    while stack:\\n        s[stack.pop()] = \\'\\'\\n    return \\'\\'.join(s)\\n```", "def minRemoveToMakeValid(self, s: str) -> str:\\n    s = list(s)\\n    stack = []\\n    for i, char in enumerate(s):\\n        if char == \\'(\\':\\n            stack.append(i)\\n        elif char == \\')\\':\\n            if stack:\\n                stack.pop()\\n            else:\\n                s[i] = \\'\\'\\n    while stack:\\n        s[stack.pop()] = \\'\\'\\n    return \\'\\'.join(s)\\n```"]}
{"id": "1166", "ref_py": ["def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\\n\\t\\t\\tbm = [[0 for _ in range(len(colsum))] for i in range(2)]\\n\\t\\t\\tfor i in range(len(colsum)):\\n\\t\\t\\t\\tif colsum[i]==2:\\n\\t\\t\\t\\t\\tcolsum[i]=0\\n\\t\\t\\t\\t\\tupper-=1\\n\\t\\t\\t\\t\\tlower-=1\\n\\t\\t\\t\\t\\tbm[0][i]=1\\n\\t\\t\\t\\t\\tbm[1][i]=1", "def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\\n\\t\\t\\tbm = [[0 for _ in range(len(colsum))] for i in range(2)]\\n\\t\\t\\tfor i in range(len(colsum)):\\n\\t\\t\\t\\tif colsum[i]==2:\\n\\t\\t\\t\\t\\tcolsum[i]=0\\n\\t\\t\\t\\t\\tupper-=1\\n\\t\\t\\t\\t\\tlower-=1\\n\\t\\t\\t\\t\\tbm[0][i]=1\\n\\t\\t\\t\\t\\tbm[1][i]=1", "def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\\n\\t\\t\\tbm = [[0 for _ in range(len(colsum))] for i in range(2)]\\n\\t\\t\\tfor i in range(len(colsum)):\\n\\t\\t\\t\\tif colsum[i]==2:\\n\\t\\t\\t\\t\\tcolsum[i]=0\\n\\t\\t\\t\\t\\tupper-=1\\n\\t\\t\\t\\t\\tlower-=1\\n\\t\\t\\t\\t\\tbm[0][i]=1\\n\\t\\t\\t\\t\\tbm[1][i]=1"]}
{"id": "1167", "ref_py": ["def closedIsland(self, grid: List[List[int]]) -> int:\\n        vis=defaultdict(lambda:False)\\n        n=len(grid)\\n        m=len(grid[0])\\n        \\'\\'\\'\\n        \\'\\'\\'\\n        def dfs(x,y):\\n            vis[(x,y)]=True\\n            isedge=True\\n            for i,j in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):\\n                if 0<=i<n and 0<=j<m:\\n                    if not vis[(i,j)] and (not grid[i][j]):\\n                        isedge=(dfs(i,j) and isedge)\\n                else:\\n                    isedge=(False and isedge)\\n            return isedge\\n        res=0\\n        for i in range(n):\\n            for j in range(m):\\n                if not vis[(i,j)] and (not grid[i][j]):\\n                    if dfs(i,j):\\n                        res+=1\\n                    ", "def closedIsland(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])", "def closedIsland(self, grid):\\n        \\n        n,m=len(grid),len(grid[0])\\n        def dfs(i,j):\\n            if ( i<0 or i>=n or j <0\\n             or j >=m or grid[i][j]!=0 ):\\n             return \\n            "]}
{"id": "1169", "ref_py": ["def maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [[0 for i in range(len(nums)+1)] for j in range(3)]", "def maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [[0 for i in range(len(nums)+1)] for j in range(3)]", "def maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [[0 for i in range(len(nums)+1)] for j in range(3)]"]}
{"id": "1170", "ref_py": ["def countServers(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        ", "def countServers(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        ", "def countServers(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        "]}
{"id": "1171", "ref_py": ["def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\\n        products.sort()\\n        n=len(products)\\n        indices=[i for i in range(n)]\\n        res=[]\\n        for idx, c in enumerate(searchWord):\\n            indices = [i for i in indices if len(products[i])>idx and products[i][idx] == c]                                                                \\n            res.append(products[i] for i in indices[:3])        \\n        return res        \\n```", "def suggestedProducts(self, P: List[str], S: str) -> List[List[str]]:\\n        P.sort()\\n        ans, left, right = [], 0, len(P) - 1\\n        for i in range(len(S)):\\n            c, res = S[i], []\\n            while left <= right and (len(P[left]) == i or P[left][i] < c): left += 1\\n            while left <= right and (len(P[right]) == i or P[right][i] > c): right -= 1\\n            for j in range(3):\\n                if left + j > right: break\\n                else: res.append(P[left+j])\\n            ans.append(res)\\n        return ans\\n```", "def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\\n        products.sort()\\n        n=len(products)\\n        indices=[i for i in range(n)]\\n        res=[]\\n        for idx, c in enumerate(searchWord):\\n            indices = [i for i in indices if len(products[i])>idx and products[i][idx] == c]                                                                \\n            res.append(products[i] for i in indices[:3])        \\n        return res        \\n```"]}
{"id": "1172", "ref_py": ["def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```", "def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \\n        t = tomatoSlices\\n        c = cheeseSlices", "def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```"]}
{"id": "1173", "ref_py": ["def countSquares(self, matrix: List[List[int]]) -> int:\\n        row=len(matrix)\\n        col=len(matrix[0])\\n        dp=[[0]*col for i in range(row)]\\n        for i in range(row):\\n            for j in range(col):\\n                if (i==0 or j==0) and matrix[i][j]==1:\\n                    dp[i][j]=1\\n        for i in range(1,row):\\n            for j in range(1,col):\\n                if matrix[i][j]==1:\\n                    dp[i][j]=1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])\\n        ans=0\\n        for rows in dp:\\n            ans+=sum(rows)\\n        return ans\\n```    \\n", "def countSquares(self, matrix: List[List[int]]) -> int:\\n        \\n        ", "def countSquares(self, matrix: List[List[int]]) -> int:\\n        row=len(matrix)\\n        col=len(matrix[0])\\n        dp=[[0]*col for i in range(row)]\\n        for i in range(row):\\n            for j in range(col):\\n                if (i==0 or j==0) and matrix[i][j]==1:\\n                    dp[i][j]=1\\n        for i in range(1,row):\\n            for j in range(1,col):\\n                if matrix[i][j]==1:\\n                    dp[i][j]=1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])\\n        ans=0\\n        for rows in dp:\\n            ans+=sum(rows)\\n        return ans\\n```    \\n"]}
{"id": "1174", "ref_py": ["def groupThePeople(self, group_sizes: list[int]) -> list[list[int]]:\\n        groups = defaultdict(lambda: [[]])\\n        for i, s in enumerate(group_sizes):\\n            if len(groups[s][-1]) == s: groups[s].append([])\\n            groups[s][-1].append(i)\\n        \\n        return list(chain.from_iterable(groups.values()))", "def groupThePeople(self, groupSizes):\\n        group_map = {}\\n        for i, size in enumerate(groupSizes):\\n            if size in group_map:\\n                group_map[size].append(i)\\n            else:\\n                group_map[size] = [i]\\n        \\n        result = []\\n        for size, group in group_map.items():\\n            for i in range(0, len(group), size):\\n                result.append(group[i:i+size])\\n        \\n        return result", "defaultdict called group_mapping to map group sizes to lists of people.\\n- We iterate through the groupSizes list, adding each person to the corresponding group size.\\n- When a group is complete (i.e., its size equals the specified group size), we add it to the result and remove it from the mapping.\\n- The result contains the groups of people, and we return it as the answer.\\n"]}
{"id": "1175", "ref_py": ["def maxEl(self, nums):\\n        maxi = float(\\'-inf\\')\\n        for num in nums:\\n            maxi = max(maxi, num)\\n        return maxi\\n    \\n    def sumByD(self, nums, div):\\n        _sum = 0\\n        for num in nums:\\n            _sum += -(-num // div)  ", "def smallestDivisor(self, nums: List[int], threshold: int) -> int:\\n\\tdef isValid(num):\\n\\t\\ttemp = 0\\n\\t\\tfor i in nums:\\n\\t\\t\\ttemp += ceil(i/num)\\n\\t\\treturn temp <= threshold\\n\\ti, j = 1, max(nums) + 1   \\n\\twhile(i <= j):\\n\\t\\tmid = i + (j-i)//2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n", "def calculate_sum(self,nums, mid):     \\n        total = 0\\n        for num in nums:\\n            total += -(-num // mid)\\n        return total"]}
{"id": "1177", "ref_py": ["def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:", "def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:", "def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:"]}
{"id": "1178", "ref_py": ["defination :- **if and only if each digit in the number is one more than the previous digit.** \\n```\\nNow, let\\'s understand this problem by taking an example :- low = 1000, high = 12000 \\nwhere low is the minimum of sequential digits we have and high is up to what you can have. \\nSince our lower limit is 1000 the sequence has to be of 4 digit. \\nSo, we can choose it from the range 1,2,3,4,5,6,7,8,9 \\nSo, what possible sequential digits we could have is lying in our range from 1000 to 12000 is :- [1234,2345,3456,4567,5678,6789]\\n```\\n![image](https://assets.leetcode.com/users/images/00307d32-ef0f-4192-8cea-1ca0713eb0cf_1642914439.3001685.png)", "defination :- **if and only if each digit in the number is one more than the previous digit.** \\n```\\nNow, let\\'s understand this problem by taking an example :- low = 1000, high = 12000 \\nwhere low is the minimum of sequential digits we have and high is up to what you can have. \\nSince our lower limit is 1000 the sequence has to be of 4 digit. \\nSo, we can choose it from the range 1,2,3,4,5,6,7,8,9 \\nSo, what possible sequential digits we could have is lying in our range from 1000 to 12000 is :- [1234,2345,3456,4567,5678,6789]\\n```\\n![image](https://assets.leetcode.com/users/images/00307d32-ef0f-4192-8cea-1ca0713eb0cf_1642914439.3001685.png)", "defination :- **if and only if each digit in the number is one more than the previous digit.** \\n```\\nNow, let\\'s understand this problem by taking an example :- low = 1000, high = 12000 \\nwhere low is the minimum of sequential digits we have and high is up to what you can have. \\nSince our lower limit is 1000 the sequence has to be of 4 digit. \\nSo, we can choose it from the range 1,2,3,4,5,6,7,8,9 \\nSo, what possible sequential digits we could have is lying in our range from 1000 to 12000 is :- [1234,2345,3456,4567,5678,6789]\\n```\\n![image](https://assets.leetcode.com/users/images/00307d32-ef0f-4192-8cea-1ca0713eb0cf_1642914439.3001685.png)"]}
{"id": "1179", "ref_py": ["def maxSideLength(self, mat, threshold):\\n        \\n        if not mat:\\n            return 0\\n        max_square = 0\\n        dp = [[0] * (len(mat[0]) + 1) for _ in range(len(mat) + 1)]\\n        for i in range(1, len(mat) + 1):\\n            for j in range(1, len(mat[0]) + 1):\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1]\\n                l = 1\\n                r = min(i, j)\\n                while l <= r:\\n                    k = (l + r) / 2\\n                    cur_sum = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k]\\n                    if cur_sum <= threshold:\\n                        max_square = max(max_square, k)\\n                        l = k + 1\\n                    else:\\n                        r = k - 1\\n        return max_square", "def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\\n        n, m = len(mat), len(mat[0])\\n        prefix = [[0] * (m + 1) for _ in range(n+1)]\\n        ans = 0\\n        def check(i, j, length):\\n            return (prefix[i+1][j+1] - prefix[i+1-length][j+1] - prefix[i+1][j+1-length] + prefix[i+1-length][j+1-length]) <= threshold\\n        \\n        for i, row in enumerate(mat):\\n            for j, x in enumerate(row):\\n                prefix[i+1][j+1] = x + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                left = ans + 1\\n                right = min(i+1, j+1)\\n                while left <= right:\\n                    mid = (left + right) // 2\\n                    if check(i, j, mid): left = mid + 1\\n                    else: right = mid - 1\\n                if right > ans: ans = right\\n            \\n        return ans\\n```", "def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\\n        n, m = len(mat), len(mat[0])\\n        prefix = [[0] * (m + 1) for _ in range(n+1)]\\n        ans = 0\\n        def check(i, j, length):\\n            return (prefix[i+1][j+1] - prefix[i+1-length][j+1] - prefix[i+1][j+1-length] + prefix[i+1-length][j+1-length]) <= threshold\\n        \\n        for i, row in enumerate(mat):\\n            for j, x in enumerate(row):\\n                prefix[i+1][j+1] = x + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                left = ans + 1\\n                right = min(i+1, j+1)\\n                while left <= right:\\n                    mid = (left + right) // 2\\n                    if check(i, j, mid): left = mid + 1\\n                    else: right = mid - 1\\n                if right > ans: ans = right\\n            \\n        return ans\\n```"]}
{"id": "1180", "ref_py": ["def isPossibleDivide(self, nums, k):\\n        \\n        num_map = {}\\n        for num in nums:\\n            num_map[num] = num_map.get(num, 0) + 1\\n        while num_map:\\n            first = min(num_map)\\n            for i in range(first, first+k):\\n                if i not in num_map:\\n                    return False\\n                num_map[i] -= 1\\n                if num_map[i] == 0:\\n                    del num_map[i]\\n        return True", "def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        \\n        nums.sort()\\n        \\n        sequences = 0\\n        for i in range(N):\\n            if nums[i] != 0:\\n                sequence = nums[i]\\n                nums[i] = 0\\n                found = 1\\n                for j in range(i + 1, N):\\n                    if sequence + 1 == nums[j]:\\n                        nums[j] = 0\\n                        sequence += 1\\n                        found += 1\\n                        if found == k:\\n                            found = 0\\n                            sequences += 1\\n                            break\\n        \\n        return N % k == 0 and sequences == N // k\\n```", "def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        \\n        nums.sort()\\n        \\n        sequences = 0\\n        for i in range(N):\\n            if nums[i] != 0:\\n                sequence = nums[i]\\n                nums[i] = 0\\n                found = 1\\n                for j in range(i + 1, N):\\n                    if sequence + 1 == nums[j]:\\n                        nums[j] = 0\\n                        sequence += 1\\n                        found += 1\\n                        if found == k:\\n                            found = 0\\n                            sequences += 1\\n                            break\\n        \\n        return N % k == 0 and sequences == N // k\\n```"]}
{"id": "1181", "ref_py": ["def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        \\n        n = len(s)\\n        substring_frequency = {}\\n        max_freq = 0\\n        i = 0", "def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        \\n        n = len(s)\\n        substring_frequency = {}\\n        max_freq = 0\\n        i = 0", "def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        \\n        n = len(s)\\n        substring_frequency = {}\\n        max_freq = 0\\n        i = 0"]}
{"id": "1182", "ref_py": ["def findBestValue(self, arr, target):\\n        \\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value", "def findBestValue(self, arr, target):\\n        \\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value", "def findBestValue(self, arr, target):\\n        \\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value"]}
{"id": "1183", "ref_py": ["def deepestLeavesSum(self, root: TreeNode) -> int:\\n        q, ans, qlen, curr = [root], 0, 0, 0\\n        while len(q):\\n            qlen, ans = len(q), 0\\n            for _ in range(qlen):\\n                curr = q.pop(0)\\n                ans += curr.val\\n                if curr.left: q.append(curr.left)\\n                if curr.right: q.append(curr.right)\\n        return ans\\n```", "def deepestLeavesSum(self, root: TreeNode) -> int:\\n        q, ans, qlen, curr = [root], 0, 0, 0\\n        while len(q):\\n            qlen, ans = len(q), 0\\n            for _ in range(qlen):\\n                curr = q.pop(0)\\n                ans += curr.val\\n                if curr.left: q.append(curr.left)\\n                if curr.right: q.append(curr.right)\\n        return ans\\n```", "def deepestLeavesSum(self, root: TreeNode) -> int:\\n        q, ans, qlen, curr = [root], 0, 0, 0\\n        while len(q):\\n            qlen, ans = len(q), 0\\n            for _ in range(qlen):\\n                curr = q.pop(0)\\n                ans += curr.val\\n                if curr.left: q.append(curr.left)\\n                if curr.right: q.append(curr.right)\\n        return ans\\n```"]}
{"id": "1184", "ref_py": ["def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\\n        def gen(node):\\n            if node:\\n                yield from gen(node.left)\\n                yield node.val\\n                yield from gen(node.right)\\n        return list(heapq.merge(gen(root1), gen(root2)))\\n```\\nThat last test case alone needs ~2.6s to finish and almost all of the time was consumed by the generators. The Python 2 equivalent is just as slow. In comparison, the following solution blazes through that last test case in ~80 ms:\\n```\\nimport heapq", "def inorder(self, root, currlist):\\n        if not root:\\n            return\\n        self.inorder(root.left, currlist)\\n        currlist.append(root.val)\\n        self.inorder(root.right, currlist)", "def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\\n        def gen(node):\\n            if node:\\n                yield from gen(node.left)\\n                yield node.val\\n                yield from gen(node.right)\\n        return list(heapq.merge(gen(root1), gen(root2)))\\n```\\nThat last test case alone needs ~2.6s to finish and almost all of the time was consumed by the generators. The Python 2 equivalent is just as slow. In comparison, the following solution blazes through that last test case in ~80 ms:\\n```\\nimport heapq"]}
{"id": "1185", "ref_py": ["def canReach(self, arr: List[int], start: int) -> bool:\\n        ", "def canReach(self, arr: List[int], start: int) -> bool:\\n        ", "def canReach(self, arr: List[int], start: int) -> bool:\\n        "]}
{"id": "1186", "ref_py": ["def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None", "def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None", "def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None"]}
{"id": "1187", "ref_py": ["def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], root: int, level: int) -> List[str]:\\n        seen, qu, count, L = {root}, [root], Counter(), 1\\n        while qu:\\n            new_qu = []\\n            for node in qu:\\n                for to in friends[node]:\\n                    if to not in seen and L <= level:                         \\n                        new_qu.append(to)\\n                        seen.add(to)\\n                        if L == level: count += Counter(watchedVideos[to])\\n            L += 1\\n            qu = new_qu", "def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        ", "def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        "]}
{"id": "1188", "ref_py": ["def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        ", "def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        ", "def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        "]}
{"id": "1189", "ref_py": ["def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```", "def numberOfSteps(self, num):\\n        counter = 0\\n        while num != 0:\\n            if num%2==0:\\n                num = num//2\\n                counter += 1\\n            else:\\n                num = num - 1\\n                counter += 1\\n        return counter", "def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```"]}
{"id": "1190", "ref_py": ["def minFlips(self, a: int, b: int, c: int) -> int:\\n        flips = 0\\n        for i in range(31):\\n            ", "def minFlips(self, a, b, c):\\n        ans = 0\\n        while a or b or c:\\n            x1 = a & 1\\n            x2 = b & 1\\n            x3 = c & 1\\n            if (x1 | x2) != x3:\\n                if x1 & x2:\\n                    ans += 2\\n                else:\\n                    ans += 1\\n            a = a >> 1\\n            b = b >> 1\\n            c = c >> 1\\n        return ans", "def minFlips(self, a: int, b: int, c: int) -> int:\\n        return ((a | b) ^ c).bit_count() + (a & b & ~c).bit_count()"]}
{"id": "1191", "ref_py": ["def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        parent=list(range(n))\\n        self.count=n\\n        self.redundant=0\\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x]=find(parent[x])", "def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections) < n - 1: return -1\\n        \\n        graph = [set() for i in range(n)]\\n        for u, v in connections:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited = [0] * n", "def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        if len(connections)+1<n:\\n            return -1\\n        def findParent(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=findParent(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=findParent(u),findParent(v)\\n            if pu==pv:\\n                return \\n            elif rank[pu]>rank[pv]:\\n                parent[pv]=pu\\n            elif rank[pu]<rank[pv]:\\n                parent[pu]=pv\\n            else:\\n                parent[pv]=pu\\n                rank[pu]+=1\\n        parent=[i for i in range(n)]\\n        rank=[0]*n\\n        for u,v in connections:\\n            union(u,v)\\n        c=0\\n        for i in range(n):\\n            if parent[i]==i:\\n                c+=1\\n        return c-1\\n```"]}
{"id": "1193", "ref_py": ["def printVertically(self, s: str) -> Iterable[str]:\\n        return map(str.rstrip, map(\\'\\'.join, zip_longest(*s.split(), fillvalue=\\' \\')))", "def printVertically(self, s: str) -> Iterable[str]:\\n        return map(str.rstrip, map(\\'\\'.join, zip_longest(*s.split(), fillvalue=\\' \\')))", "def printVertically(self, s: str) -> Iterable[str]:\\n        return map(str.rstrip, map(\\'\\'.join, zip_longest(*s.split(), fillvalue=\\' \\')))"]}
{"id": "1194", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:\\n        if root:\\n            root.left = self.removeLeafNodes(root.left, target)\\n            root.right = self.removeLeafNodes(root.right, target) \\n            if root.val == target and not root.left and not root.right:\\n                root = None\\n        return root \\n```"]}
{"id": "1195", "ref_py": ["def breakPalindrome(self, palindrome: str) -> str:\\n\\tn = len(palindrome) ", "def breakPalindrome(self, palindrome: str) -> str:\\n\\tn = len(palindrome) ", "def breakPalindrome(self, palindrome: str) -> str:\\n\\tn = len(palindrome) "]}
{"id": "1196", "ref_py": ["defaultdict", "def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n\\trow, col = len(mat), len(mat[0])\\n\\ttotal_num = row * col", "def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n\\trow, col = len(mat), len(mat[0])\\n\\ttotal_num = row * col"]}
{"id": "1197", "ref_py": ["def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\\n        heap = []\\n        for id, rating, vegan, price, dist in restaurants:\\n\\t\\t\\t", "def filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance):", "def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\\n        heap = []\\n        for id, rating, vegan, price, dist in restaurants:\\n\\t\\t\\t"]}
{"id": "1198", "ref_py": ["def bfs(self, node: int, adj, maximum: int) -> int:\\n\\t\\t\\theap = []\\n\\t\\t\\theappush(heap,(0,node,-1))\\n\\t\\t\\ts = set()", "def findTheCity(self, N, edges, distThre):\\n        \\n        G = defaultdict(list)\\n        for u, v, w in edges:\\n            G[u].append([v, w])\\n            G[v].append([u, w])", "def bfs(self, node: int, adj, maximum: int) -> int:\\n\\t\\t\\theap = []\\n\\t\\t\\theappush(heap,(0,node,-1))\\n\\t\\t\\ts = set()"]}
{"id": "1199", "ref_py": ["def minSetSize(self, arr: List[int]) -> int:\\n        total_count = 0\\n        \\n        for index, count in enumerate(sorted(collections.Counter(arr).values(), reverse=True)):\\n            total_count += count\\n            \\n            if total_count >= len(arr) // 2:\\n                return index + 1\\n        \\n        return 0\\n```\\n**JAVA**(copied)-https://leetcode.com/problems/reduce-array-size-to-the-half/discuss/496714/Java-O(N)-solution\\n```\\npublic int minSetSize(int[] arr) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tArrayList<Integer>[] list = new ArrayList[arr.length + 1];\\n\\t\\n\\tfor (int num : arr) {\\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\t}", "def minSetSize(self, arr: List[int]) -> int:\\n        total_len = len(arr)\\n        target_len = total_len // 2\\n        counter = 0\\n        arr_chr_count = Counter(arr).most_common()\\n        for x in arr_chr_count:\\n            total_len -= x[1]\\n            counter += 1\\n            print(counter)\\n            if total_len <= target_len:\\n                break", "define max(X, Y) ((X) > (Y) ? (X) : (Y)) "]}
{"id": "1200", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1202", "ref_py": ["def numOfSubarrays(self, arr, k, threshold):\\n        ", "def numOfSubarrays(self, arr, k, threshold):\\n        ", "def numOfSubarrays(self, arr, k, threshold):\\n        "]}
{"id": "1203", "ref_py": ["def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\\n        ", "def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\\n        m, n = len(board), len(board[0])\\n        x, y = click", "def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\\n        m, n = len(board), len(board[0])\\n        x, y = click"]}
{"id": "1204", "ref_py": ["def minSteps(self, s: str, t: str) -> int:\\n        ans = 0\\n        hashh = [0] * 26", "def minSteps(self, s: str, t: str) -> int:\\n        ans = 0\\n        hashh = [0] * 26", "def minSteps(self, s: str, t: str) -> int:\\n        ans = 0\\n        hashh = [0] * 26"]}
{"id": "1207", "ref_py": ["def maxEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        total_days = max(end for start, end in events)\\n        day = 0\\n        event_id = 0\\n        num_events_attended = 0\\n        min_heap = []\\n        \\n        for day in range(1, total_days+1):\\n            ", "def maxEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        total_days = max(end for start, end in events)\\n        day = 0\\n        event_id = 0\\n        num_events_attended = 0\\n        min_heap = []\\n        \\n        for day in range(1, total_days+1):\\n            ", "def maxEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        total_days = max(end for start, end in events)\\n        day = 0\\n        event_id = 0\\n        num_events_attended = 0\\n        min_heap = []\\n        \\n        for day in range(1, total_days+1):\\n            "]}
{"id": "1209", "ref_py": ["def numberOfSubstrings(s):\\n    map = {}\\n    count = 0\\n    start = end = 0\\n    n = len(s)\\n    while end < n:\\n        map[s[end]] = map.get(s[end], 0) + 1\\n        while map.get(\\'a\\', 0) > 0 and map.get(\\'b\\', 0) > 0 and map.get(\\'c\\', 0) > 0:\\n            count += n - end\\n            map[s[start]] -= 1\\n            start += 1\\n        end += 1\\n    return count", "def numberOfSubstrings(s):\\n    map = {}\\n    count = 0\\n    start = end = 0\\n    n = len(s)\\n    while end < n:\\n        map[s[end]] = map.get(s[end], 0) + 1\\n        while map.get(\\'a\\', 0) > 0 and map.get(\\'b\\', 0) > 0 and map.get(\\'c\\', 0) > 0:\\n            count += n - end\\n            map[s[start]] -= 1\\n            start += 1\\n        end += 1\\n    return count", "def numberOfSubstrings(s):\\n    map = {}\\n    count = 0\\n    start = end = 0\\n    n = len(s)\\n    while end < n:\\n        map[s[end]] = map.get(s[end], 0) + 1\\n        while map.get(\\'a\\', 0) > 0 and map.get(\\'b\\', 0) > 0 and map.get(\\'c\\', 0) > 0:\\n            count += n - end\\n            map[s[start]] -= 1\\n            start += 1\\n        end += 1\\n    return count"]}
{"id": "1210", "ref_py": ["def isBinaryTreeValid(self, root: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        visited = [False] * len(leftChild)  ", "defaultdict\\nclass Solution:\\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        graph = defaultdict(list)\\n        temp = {}\\n        for i in range(n):\\n            temp[i] = 1", "def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n        parent={}\\n        for p,child in enumerate(zip(leftChild,rightChild)):\\n            for c in child:\\n                if c==-1:\\n                    continue \\n                if c in parent:\\n                    return False \\n                if p in parent and parent[p]==c:\\n                    return False \\n                parent[c]=p\\n        root=set(range(n))-set(parent.keys())\\n        if  len(root)!=1:\\n            return False \\n        def count(root):\\n            if root ==-1:\\n                return 0\\n            return  1+count(leftChild[root])+count(rightChild[root])\\n        return count(root.pop())==n"]}
{"id": "1211", "ref_py": ["def closestDivisors(self, num: int) -> List[int]:\\n\\t\\t", "def closestDivisors(self, num: int) -> List[int]:\\n\\t\\t", "def closestDivisors(self, num: int) -> List[int]:\\n\\t\\t"]}
{"id": "1212", "ref_py": ["def rearrangeBarcodes(barcodes):", "def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\\n\\t\\t", "def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\\n\\t\\t"]}
{"id": "1213", "ref_py": ["def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)", "def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if Solution.flag2==False:\\n            Solution.temp1=head\\n            Solution.flag2=True\\n        if head==None and Solution.flag==True:\\n            return True\\n        elif root==None:\\n            return False\\n        if head.val==root.val:\\n            head=head.next\\n            Solution.flag=True\\n        else:\\n            head=Solution.temp1\\n            Solution.flag=False\\n        return self.isSubPath(head,root.left) or self.isSubPath(head,root.right)\\n```", "def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)"]}
{"id": "1214", "ref_py": ["def findTheLongestSubstring(self, s: str) -> int:\\n        map = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16}\\n        first_time = { 0 : -1 } ", "def findTheLongestSubstring(self, s: str) -> int:\\n        masks = [-2] * (1 << len(VOWELS))\\n        masks[0] = -1\\n        cur = 0\\n        ans = 0\\n        for i, x in enumerate(s):\\n            if x in VOWELS: \\n                cur ^= 1 << VOWELS[x]\\n            if masks[cur] != -2:\\n                ans = max(ans, i - masks[cur])\\n            if masks[cur] == -2:\\n                masks[cur] = i\\n        return ans\\n```", "def findTheLongestSubstring(self, s: str) -> int:\\n        masks = [-2] * (1 << len(VOWELS))\\n        masks[0] = -1\\n        cur = 0\\n        ans = 0\\n        for i, x in enumerate(s):\\n            if x in VOWELS: \\n                cur ^= 1 << VOWELS[x]\\n            if masks[cur] != -2:\\n                ans = max(ans, i - masks[cur])\\n            if masks[cur] == -2:\\n                masks[cur] = i\\n        return ans\\n```"]}
{"id": "1215", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        def zz(node, current_direction, previous_direction, current):\\n            if not node:\\n                return current\\n            elif current_direction == \"start\" and previous_direction == \"start\":\\n                current = 0\\n            elif current_direction != previous_direction:\\n                current += 1\\n            else:\\n                current = 1\\n            return max(zz(node.left, \"left\", current_direction, current), \\\\\\n                zz(node.right, \"right\", current_direction, current))", "def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        def zz(node, current_direction, previous_direction, current):\\n            if not node:\\n                return current\\n            elif current_direction == \"start\" and previous_direction == \"start\":\\n                current = 0\\n            elif current_direction != previous_direction:\\n                current += 1\\n            else:\\n                current = 1\\n            return max(zz(node.left, \"left\", current_direction, current), \\\\\\n                zz(node.right, \"right\", current_direction, current))"]}
{"id": "1216", "ref_py": ["def numTimesAllBlue(self, flips):", "def numTimesAllBlue(self, flips):", "def numTimesAllBlue(self, flips):"]}
{"id": "1217", "ref_py": ["def numOfMinutes(self, n: int, head_id: int, manager: list[int], inform_time: list[int]) -> int:\\n        Weight = int | float\\n        WeightedTree = tuple[Weight, Iterable[\\'WeightedTree\\']]", "def numOfMinutes(self, n: int, head: int, parents: List[int], time: List[int]) -> int:\\n    graph = [[] for _ in range(n)]\\n    for i, p in enumerate(parents):\\n      if p != -1:\\n        graph[p].append(i)\\n    \\n    frontier, res = [(head, time[head])], time[head]\\n    while frontier:\\n      new_frontier = []\\n      for p, t in frontier:\\n        for p_nxt in graph[p]:\\n          res = max(res, t + time[p_nxt])\\n          new_frontier.append((p_nxt, t + time[p_nxt]))\\n    \\n      frontier = new_frontier\\n    \\n    return res\\n```\\n```Go []\\nvar max int ", "def numOfMinutes(self, n: int, head_id: int, manager: list[int], inform_time: list[int]) -> int:\\n        Weight = int | float\\n        WeightedTree = tuple[Weight, Iterable[\\'WeightedTree\\']]"]}
{"id": "1219", "ref_py": ["def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root):\\n            if root is None: return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root)\\n        \\n        def bst(l,r):\\n            if l>r: return None\\n            mid = (l+r)//2\\n            return TreeNode(nums[mid], bst(l,mid-1), bst(mid+1,r))\\n            \\n        return bst(0, len(nums)-1)\\n```", "def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root):\\n            if root is None: return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root)\\n        \\n        def bst(l,r):\\n            if l>r: return None\\n            mid = (l+r)//2\\n            return TreeNode(nums[mid], bst(l,mid-1), bst(mid+1,r))\\n            \\n        return bst(0, len(nums)-1)\\n```", "def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root):\\n            if root is None: return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root)\\n        \\n        def bst(l,r):\\n            if l>r: return None\\n            mid = (l+r)//2\\n            return TreeNode(nums[mid], bst(l,mid-1), bst(mid+1,r))\\n            \\n        return bst(0, len(nums)-1)\\n```"]}
{"id": "1220", "ref_py": ["def maxNumberOfFamilies(self, n, reservedSeats):\\n\\t\\t\\t\\n\\t\\t\\td = collections.defaultdict(list)", "def maxNumberOfFamilies(self, n, reservedSeats):\\n        \\n        d = defaultdict(set)\\n        for row,seat in reservedSeats:\\n            d[row].add(seat)\\n        \\n        def row(i):\\n            a1 = not set((2,3,4,5)).intersection(d[i])\\n            a2 = not set((6,7,8,9)).intersection(d[i])\\n            if  a1 and a2:\\n                return 2\\n            if  a1 or a2:\\n                return 1\\n            return 1 if not set((4,5,6,7)).intersection(d[i]) else 0\\n        \\n        return sum((row(i) for i in d.keys())) + (n-len(d)) * 2", "def maxNumberOfFamilies(self, n, reservedSeats):\\n        \\n        d = defaultdict(set)\\n        for row,seat in reservedSeats:\\n            d[row].add(seat)\\n        \\n        def row(i):\\n            a1 = not set((2,3,4,5)).intersection(d[i])\\n            a2 = not set((6,7,8,9)).intersection(d[i])\\n            if  a1 and a2:\\n                return 2\\n            if  a1 or a2:\\n                return 1\\n            return 1 if not set((4,5,6,7)).intersection(d[i]) else 0\\n        \\n        return sum((row(i) for i in d.keys())) + (n-len(d)) * 2"]}
{"id": "1221", "ref_py": ["def getKth(self, lo: int, hi: int, k: int) -> int:\\n        return sorted(range(lo, hi + 1), key=self.power)[k - 1]", "def getKth(self, lo: int, hi: int, k: int) -> int:\\n        return sorted(range(lo, hi + 1), key=self.power)[k - 1]", "def getKth(self, lo: int, hi: int, k: int) -> int:\\n        return sorted(range(lo, hi + 1), key=self.power)[k - 1]"]}
{"id": "1222", "ref_py": ["def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)", "def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)", "def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)"]}
{"id": "1223", "ref_py": ["def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True", "def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True", "def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True"]}
{"id": "1225", "ref_py": ["def count_low_high(self,sl,x):\\n        lo =           sl.bisect_left(x)\\n        hi = len(sl) - lo\\n        return lo, hi\\n    \\n    def numTeams(self, A):\\n        result = 0\\n        left   = SortedList()\\n        right  = SortedList(A)\\n        for x in A:\\n            right.remove(x)\\n            lo_L, hi_L  =  self.count_low_high(left ,x)\\n            lo_R, hi_R  =  self.count_low_high(right,x)\\n            result     +=  lo_L*hi_R + hi_L*lo_R\\n            left .add(x)\\n        return result\\n```", "def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n    \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s", "def numTeams(self, rating: List[int]) -> int:\\n        res = 0\\n        for i in range(1, len(rating) - 1):\\n            less, greater = [0, 0], [0, 0]\\n            for j in range(i):\\n                if rating[j] < rating[i]:\\n                    less[0] += 1\\n                else:\\n                    greater[0] += 1\\n            \\n            for k in range(i+1, len(rating)):\\n                if rating[i] < rating[k]:\\n                    less[1] += 1\\n                else:\\n                    greater[1] += 1\\n            res += less[0] * less[1] + greater[0] * greater[1]\\n        return res\\n```"]}
{"id": "1227", "ref_py": ["def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False", "def canPlaceFlowers(self, flowerbed, n):\\n        if n == 0: return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):  ", "def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False"]}
{"id": "1228", "ref_py": ["def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def find(a1, a2, aCenter):\\n            if a1 <= aCenter and aCenter <= a2:\\n                return 0 \\n            elif a1 > aCenter:\\n                return  a1 - aCenter\\n            else:\\n                return aCenter - a2", "def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        ", "def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def find(a1, a2, aCenter):\\n            if a1 <= aCenter and aCenter <= a2:\\n                return 0 \\n            elif a1 > aCenter:\\n                return  a1 - aCenter\\n            else:\\n                return aCenter - a2"]}
{"id": "1229", "ref_py": ["def numSteps(self, s):\\n        \\n        l = len(s) - 1\\n        carry = 0\\n        count = 0\\n        while (l > 0):\\n            ", "def numSteps(self, s: str) -> int:\\n        \\n        def dfs(n):\\n            if n == 1:\\n                return 0\\n            \\n            if n % 2 == 0:\\n                return dfs(n // 2) + 1\\n            return dfs(n + 1) + 1", "def numSteps(self, s):\\n        "]}
{"id": "1230", "ref_py": ["def longestDiverseString(self, a: int, b: int, c: int) -> str:\\n        result = [] ", "def longestDiverseString(self, a: int, b: int, c: int) -> str:\\n        ", "def longestDiverseString(self, a: int, b: int, c: int) -> str:\\n        "]}
{"id": "1231", "ref_py": ["def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```", "def sortedSquares(self, nums):\\n        result = [0]*len(nums)\\n        i = 0\\n        j = len(nums)-1\\n        k = len(nums)-1\\n        while k>=0:\\n            if nums[i]*nums[i] <= nums[j]*nums[j]:\\n                result[k] = nums[j]*nums[j]\\n                k-=1\\n                j-=1\\n            else:\\n                result[k] = nums[i]*nums[i]\\n                i+=1\\n                k-=1\\n        return result        ", "def getAbsMin(lst):\\n    \\n    l, r = 0, len(lst) - 1\\n    while l <= r:\\n        mid = l + (r - l) // 2\\n        if lst[mid] == 0:L\\n            return mid\\n        elif lst[mid] < 0:\\n            l = mid + 1\\n        elif lst[mid] > 0:\\n            r = mid -1\\n    return l\\nprint(getAbsMin([-4,-1,2,3,10]))\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        minVal = -1\\n        ans = []\\n        j = getAbsMin(nums)\\n        i = j -1\\n        while i != -1 and j != len(nums):\\n            if nums[i]**2 < nums[j]**2:\\n                ans.append(nums[i]**2)\\n                i-=1\\n            else:\\n                ans.append(nums[j]**2)\\n                j+=1\\n        while i != -1:\\n            ans.append(nums[i]**2)\\n            i-=1\\n        while j != len(nums):\\n            ans.append(nums[j]**2)\\n            j+=1"]}
{"id": "1232", "ref_py": ["def entityParser(self, text: str) -> str:\\n        \\n        html_symbol = [ \\'&quot;\\', \\'&apos;\\', \\'&gt;\\', \\'&lt;\\', \\'&frasl;\\', \\'&amp;\\']\\n        formal_symbol = [ \\'\"\\', \"\\'\", \\'>\\', \\'<\\', \\'/\\', \\'&\\']\\n                \\n        for html_sym, formal_sym in zip(html_symbol, formal_symbol):\\n            text = text.replace( html_sym , formal_sym )\\n        \\n        return text\\n        \\n```", "def entityParser(self, text: str) -> str:\\n        \\n        html_symbol = [ \\'&quot;\\', \\'&apos;\\', \\'&gt;\\', \\'&lt;\\', \\'&frasl;\\', \\'&amp;\\']\\n        formal_symbol = [ \\'\"\\', \"\\'\", \\'>\\', \\'<\\', \\'/\\', \\'&\\']\\n                \\n        for html_sym, formal_sym in zip(html_symbol, formal_symbol):\\n            text = text.replace( html_sym , formal_sym )\\n        \\n        return text\\n        \\n```", "def entityParser(self, text: str) -> str:\\n        \\n        html_symbol = [ \\'&quot;\\', \\'&apos;\\', \\'&gt;\\', \\'&lt;\\', \\'&frasl;\\', \\'&amp;\\']\\n        formal_symbol = [ \\'\"\\', \"\\'\", \\'>\\', \\'<\\', \\'/\\', \\'&\\']\\n                \\n        for html_sym, formal_sym in zip(html_symbol, formal_symbol):\\n            text = text.replace( html_sym , formal_sym )\\n        \\n        return text\\n        \\n```"]}
{"id": "1233", "ref_py": ["def searchBST(self, root, val):\\n        ", "def searchBST(self, root, val):\\n        ", "def searchBST(self, root, val):\\n        "]}
{"id": "1234", "ref_py": ["def getHappyString(self, n, k):\\n        ", "def getHappyString(self, n, k):\\n        ", "def getHappyString(self, n, k):\\n        "]}
{"id": "1235", "ref_py": ["default value.\\r\\nNow, we traverse the input array(orders). We locate the correct element in our output array using our dictionaries, which provide values from the keys using the food item and table number specified in the input array.\\r\\nThe selected element in the output array will be a string. It is first typecasted into an integer, incremented, and the again typecasted into a string.\\r\\nAfter traversing the input array, our output array will be built and can be returned. \\r\\n\\r\\n", "default value.\\r\\nNow, we traverse the input array(orders). We locate the correct element in our output array using our dictionaries, which provide values from the keys using the food item and table number specified in the input array.\\r\\nThe selected element in the output array will be a string. It is first typecasted into an integer, incremented, and the again typecasted into a string.\\r\\nAfter traversing the input array, our output array will be built and can be returned. \\r\\n\\r\\n", "default value.\\r\\nNow, we traverse the input array(orders). We locate the correct element in our output array using our dictionaries, which provide values from the keys using the food item and table number specified in the input array.\\r\\nThe selected element in the output array will be a string. It is first typecasted into an integer, incremented, and the again typecasted into a string.\\r\\nAfter traversing the input array, our output array will be built and can be returned. \\r\\n\\r\\n"]}
{"id": "1236", "ref_py": ["def minNumberOfFrogs(self, croakOfFrogs: str) -> int:", "def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\\n        \\n        next_letter = {\\n            \\'c\\' : \\'r\\',\\n            \\'r\\' : \\'o\\',\\n            \\'o\\' : \\'a\\', \\n            \\'a\\' : \\'k\\',\\n            \\'k\\' : \\'f\\'\\n        }\\n        \\n        count = {\\n            \\'c\\' : 0,\\n            \\'r\\' : 0,\\n            \\'o\\' : 0,\\n            \\'a\\' : 0,\\n            \\'k\\' : 0,\\n            \\'f\\' : 0\\n        }\\n        \\n        for letter in croakOfFrogs:\\n            if letter != \\'c\\' and count[letter] < 1:\\n                return -1\\n            if letter == \\'c\\' and count[\\'f\\'] > 0:\\n                count[\\'f\\'] -= 1", "def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\\n        c = r = o = a = k = max_frog_croak = present_frog_croak = 0\\n        "]}
{"id": "1237", "ref_py": ["def maxScore(self, C: List[int], K: int) -> int:\\n        best = total = sum(C[:K])\\n        for i in range (K-1, -1, -1):\\n            total += C[i + len(C) - K] - C[i]\\n            best = max(best, total)\\n        return best\\n```", "def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        n = len(cardPoints)\\n        total = sum(cardPoints)\\n        \\n        remaining_length = n - k\\n        subarray_sum = sum(cardPoints[:remaining_length])\\n        \\n        min_sum = subarray_sum\\n        for i in range(remaining_length, n):\\n            ", "def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if len(cardPoints) <= k:\\n            return sum(cardPoints)"]}
{"id": "1238", "ref_py": ["def findDiagonalOrder(self, nums):\\n        diagonals = [deque() for _ in range(len(nums) + max(len(row) for row in nums) - 1)]\\n        for row_id, row in enumerate(nums):\\n            for col_id in range(len(row)):\\n                diagonals[row_id + col_id].appendleft(row[col_id])\\n        return list(chain(*diagonals))\\n```\\n```python3 []\\nclass Solution:\\n    def findDiagonalOrder(self, A: List[List[int]]) -> List[int]:\\n        d = defaultdict(list)\\n        for i in range(len(A)):\\n            for j in range(len(A[i])):\\n                d[i+j].append(A[i][j])\\n        return [v for k in d.keys() for v in reversed(d[k])]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& nums) {\\n        int m=nums.size(),n=0;\\n        \\n        //find max value and store in n;\\n        \\n        for(int i=0;i<m;i++){\\n            if(n<nums[i].size())\\n                n=nums[i].size();\\n        }\\n        vector<vector<int>>temp(m+n);\\n        vector<int>ans;\\n        \\n        // convert mat into adjacency list and keep value in temp\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                temp[i+j].push_back(nums[i][j]);\\n            }\\n        }\\n        \\n        // here we reverse matrix\\n        \\n        for(int i=0;i<m+n;i++){\\n            reverse(temp[i].begin(),temp[i].end());\\n        }\\n        \\n        // all value  of temp in ans vector\\n        \\n         for(int i=0;i<m+n;i++){\\n            for(int j=0;j<temp[i].size();j++){\\n                ans.push_back(temp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Javascript []\\nvar findDiagonalOrder = function(nums) {\\n    const result = [];", "def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:\\n        m = len(nums)\\n        n = max(len(x) for x in nums)\\n        bucket = [[] for _ in range(m+n-1)]\\n        for i in range(m-1, -1, -1):\\n            for j, x in enumerate(nums[i]):\\n                bucket[i+j].append(x)\\n        ans = []\\n        for x in bucket: ans += x\\n        return ans\\n```", "def findDiagonalOrder(self, nums):\\n        m = len(nums)\\n        maxSum, size, index = 0, 0, 0\\n        map = [[] for _ in range(100001)]\\n        \\n        for i in range(m):\\n            size += len(nums[i])\\n            for j in range(len(nums[i])):\\n                _sum = i + j\\n                map[_sum].append(nums[i][j])\\n                maxSum = max(maxSum, _sum)\\n        \\n        res = [0] * size\\n        for i in range(maxSum + 1):\\n            cur = map[i]\\n            for j in range(len(cur) - 1, -1, -1):\\n                res[index] = cur[j]\\n                index += 1\\n        \\n        return res\\n        \\n```\\n``` C++ []\\n"]}
{"id": "1239", "ref_py": ["def maximize(self, num):\\n        maximum = int(\"\".join([\"9\" for _ in range(len(str(num)))]))\\n        distance = \"\".join([\\'0\\' for _ in range(len(str(num))-len(str(maximum - num)))]) + str(maximum - num)\\n        for i, s in enumerate(distance):\\n            if s != \"0\":\\n                return str(num)[i], \"9\"\\n        return \"9\", \"9\"\\n    def minimize(self, num):\\n        minimum = int(\"1\" + \"\".join([\"0\" for _ in range(len(str(num)) - 1)]))\\n        distance = \"\".join([\\'0\\' for _ in range(len(str(num))-len(str(num - minimum)))]) + str(num - minimum)\\n        for i, s in enumerate(distance):\\n            if s != \"0\" and not (i != 0 and str(num)[i]==str(num)[0]):\\n                return str(num)[i], \"1\" if i==0 else \"0\"\\n        return \"0\", \"0\"\\n    \\n    def maxDiff(self, num):\\n        \\n        a = int(str(num).replace(*self.maximize(num)))\\n        b = int(str(num).replace(*self.minimize(num)))\\n        return a - b", "def maximize(self, num):\\n        maximum = int(\"\".join([\"9\" for _ in range(len(str(num)))]))\\n        distance = \"\".join([\\'0\\' for _ in range(len(str(num))-len(str(maximum - num)))]) + str(maximum - num)\\n        for i, s in enumerate(distance):\\n            if s != \"0\":\\n                return str(num)[i], \"9\"\\n        return \"9\", \"9\"\\n    def minimize(self, num):\\n        minimum = int(\"1\" + \"\".join([\"0\" for _ in range(len(str(num)) - 1)]))\\n        distance = \"\".join([\\'0\\' for _ in range(len(str(num))-len(str(num - minimum)))]) + str(num - minimum)\\n        for i, s in enumerate(distance):\\n            if s != \"0\" and not (i != 0 and str(num)[i]==str(num)[0]):\\n                return str(num)[i], \"1\" if i==0 else \"0\"\\n        return \"0\", \"0\"\\n    \\n    def maxDiff(self, num):\\n        \\n        a = int(str(num).replace(*self.maximize(num)))\\n        b = int(str(num).replace(*self.minimize(num)))\\n        return a - b", "def maximize(self, num):\\n        maximum = int(\"\".join([\"9\" for _ in range(len(str(num)))]))\\n        distance = \"\".join([\\'0\\' for _ in range(len(str(num))-len(str(maximum - num)))]) + str(maximum - num)\\n        for i, s in enumerate(distance):\\n            if s != \"0\":\\n                return str(num)[i], \"9\"\\n        return \"9\", \"9\"\\n    def minimize(self, num):\\n        minimum = int(\"1\" + \"\".join([\"0\" for _ in range(len(str(num)) - 1)]))\\n        distance = \"\".join([\\'0\\' for _ in range(len(str(num))-len(str(num - minimum)))]) + str(num - minimum)\\n        for i, s in enumerate(distance):\\n            if s != \"0\" and not (i != 0 and str(num)[i]==str(num)[0]):\\n                return str(num)[i], \"1\" if i==0 else \"0\"\\n        return \"0\", \"0\"\\n    \\n    def maxDiff(self, num):\\n        \\n        a = int(str(num).replace(*self.maximize(num)))\\n        b = int(str(num).replace(*self.minimize(num)))\\n        return a - b"]}
{"id": "1240", "ref_py": ["def checkIfCanBreak(self, s1, s2):\\n        \\n        \\n        s1 = sorted(s1)\\n        s2 = sorted(s2)\\n        i=0\\n        while i<len(s1):\\n            if s1[i] > s2[i]:\\n                flg = 1\\n                break\\n            elif s2[i]>s1[i]:\\n                flg = 2\\n                break\\n            i+=1\\n        \\n        sr = s1 if flg == 1 else s2\\n        srr = s2 if flg == 1 else s1\\n        \\n        fl = 0\\n        for i in range(len(s1)):\\n            if sr[i] < srr[i]:\\n                fl = 1\\n                break\\n        \\n        if fl == 0: \\n            return True\\n        else:\\n            return False", "def checkIfCanBreak(self, s1: str, s2: str) -> bool:", "def checkIfCanBreak(self, s1: str, s2: str) -> bool:"]}
{"id": "1241", "ref_py": ["def diagonalSum(self, mat):\\n        \\n        s=0\\n        for i in range(0,len(mat)):\\n            a=mat[i][i]\\n            b=mat[i][len(mat)-i-1]\\n            s=s+a+b\\n        if len(mat)%2==0:\\n            return(s)\\n        else:\\n            mid=(1+len(mat))/2-1\\n            return(s-mat[mid][mid])", "def diagonalSum(self, mat: list[list[int]]) -> int:\\n        return (n := len(mat)) and sum(\\n            mat[i][i] + mat[i][n - 1 - i] for i in range(n)\\n        ) - mat[n // 2][n // 2] * (n % 2)", "def diagonalSum(self, mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        res = 0\\n\\t\\t"]}
{"id": "1242", "ref_py": ["def buildArray(self, target: List[int], n: int) -> List[str]:\\n        return [\\n            x\\n            for i in range(1, target[-1] + 1)\\n            for x in [\"Push\"] + [\"Pop\"] * (i not in set(target))\\n        ]", "def buildArray(self, target: List[int], n: int) -> List[str]:\\n        return [\\n            x\\n            for i in range(1, target[-1] + 1)\\n            for x in [\"Push\"] + [\"Pop\"] * (i not in set(target))\\n        ]", "def buildArray(self, target: List[int], n: int) -> List[str]:\\n        return [\\n            x\\n            for i in range(1, target[-1] + 1)\\n            for x in [\"Push\"] + [\"Pop\"] * (i not in set(target))\\n        ]"]}
{"id": "1243", "ref_py": ["def countTriplets(self, arr: List[int]) -> int:\\n        count = 0", "def countTriplets(self, arr: List[int]) -> int:\\n        count = 0", "def countTriplets(self, arr: List[int]) -> int:\\n        count = 0"]}
{"id": "1244", "ref_py": ["def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def kahnsalgo():\\n            N = len(hasApple)\\n            E = len(edges)\\n            indegrees = [0] * N", "def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\\n        T = TypeVar(\\'T\\')\\n        Tree = Mapping[T, Collection[T]]", "def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def kahnsalgo():\\n            N = len(hasApple)\\n            E = len(edges)\\n            indegrees = [0] * N"]}
{"id": "1245", "ref_py": ["def pancakeSort(self, arr: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(arr)-1, -1, -1):\\n            flip = 1 + arr.index(i+1)\\n            if flip != i+1:\\n                arr[:flip] = arr[:flip][::-1]\\n                arr[:i+1] = arr[:i+1][::-1]\\n                res.append(flip)\\n                res.append(i+1)\\n        return res\\n", "def pancakeSort(self, arr: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(arr)-1, -1, -1):\\n            flip = 1 + arr.index(i+1)\\n            if flip != i+1:\\n                arr[:flip] = arr[:flip][::-1]\\n                arr[:i+1] = arr[:i+1][::-1]\\n                res.append(flip)\\n                res.append(i+1)\\n        return res\\n", "def pancakeSort(self, arr: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(arr)-1, -1, -1):\\n            flip = 1 + arr.index(i+1)\\n            if flip != i+1:\\n                arr[:flip] = arr[:flip][::-1]\\n                arr[:i+1] = arr[:i+1][::-1]\\n                res.append(flip)\\n                res.append(i+1)\\n        return res\\n"]}
{"id": "1246", "ref_py": ["def dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5", "defaultdict", "def dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5"]}
{"id": "1247", "ref_py": ["def arrangeWords(self, text: str) -> str:\\n        a = []\\n        for x in text.split(\" \"):\\n            a.append(x.lower())\\n        return \" \".join(sorted(a, key=len)).capitalize()\\n```", "def arrangeWords(self, text: str) -> str:\\n        a = []\\n        for x in text.split(\" \"):\\n            a.append(x.lower())\\n        return \" \".join(sorted(a, key=len)).capitalize()\\n```", "def arrangeWords(self, text: str) -> str:\\n        a = []\\n        for x in text.split(\" \"):\\n            a.append(x.lower())\\n        return \" \".join(sorted(a, key=len)).capitalize()\\n```"]}
{"id": "1248", "ref_py": ["def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        size = len(arr)\\n        \\n        good_count = 0\\n        \\n        for i in range(size-2):\\n            for j in range(i+1, size-1):\\n                for k in range(j+1, size):\\n                    \\n                    ok_a = abs(arr[i] - arr[j]) <= a\\n                    ok_b = abs(arr[j] - arr[k]) <= b\\n                    ok_c = abs(arr[i] - arr[k]) <= c\\n                    \\n                    if all((ok_a, ok_b, ok_c)):\\n                        good_count += 1\\n                        \\n                        \\n        return good_count", "def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        ", "def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\\n        \\n        "]}
{"id": "1249", "ref_py": ["def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        ", "def isPowerOfTwo(self, n):\\n        "]}
{"id": "1250", "ref_py": ["def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```", "def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```", "def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```"]}
{"id": "1251", "ref_py": ["def hasAllCodes(self, s: str, k: int) -> bool:                \\n        return len({s[i:i+k] for i in range(len(s)-k+1)}) == 2 ** k            \\n```", "def hasAllCodes(self, s: str, k: int) -> bool:\\n        codes = set()\\n        for i in range(len(s) - k + 1):\\n            codes.add(s[i:i+k])\\n        return len(codes) == 2 ** k\\n```", "def hasAllCodes(self, s: str, k: int) -> bool:                \\n        return len({s[i:i+k] for i in range(len(s)-k+1)}) == 2 ** k            \\n```"]}
{"id": "1252", "ref_py": ["def checkIfPrerequisite(self, numCourses, prerequisites, queries):\\n        adj={i:[] for i in range(numCourses)}", "def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n    \\n        def floydWarshall(reachable):\\n            for k in range(n):\\n                for i in range(n):\\n                    for j in range(n):\\n                        reachable[i][j] = reachable[i][j] or (reachable[i][k] and reachable[k][j])\\n            \\n            return reachable\\n            \\n        \\n        adjMatrix =  [[ 0 for i in range(n)] for j in range(n)]\\n        for i in prerequisites:\\n            adjMatrix[i[0]][i[1]] = 1\\n        \\n        ", "def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n    \\n        def floydWarshall(reachable):\\n            for k in range(n):\\n                for i in range(n):\\n                    for j in range(n):\\n                        reachable[i][j] = reachable[i][j] or (reachable[i][k] and reachable[k][j])\\n            \\n            return reachable\\n            \\n        \\n        adjMatrix =  [[ 0 for i in range(n)] for j in range(n)]\\n        for i in prerequisites:\\n            adjMatrix[i[0]][i[1]] = 1\\n        \\n        "]}
{"id": "1253", "ref_py": ["def calcMaxDist(self, cuts, end):\\n        cuts.append(0)\\n        cuts.append(end)\\n        cuts.sort()\\n        return max(cuts[i] - cuts[i - 1] for i in range(1, len(cuts)))\\n        \\n    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        maxWidth = self.calcMaxDist(horizontalCuts, h)\\n        maxHeight = self.calcMaxDist(verticalCuts, w)\\n        return (maxWidth * maxHeight) % MOD\\n```", "def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\\n\\t\\t", "def maxArea(self, h: int, w: int, hc: List[int], vc: List[int]) -> int:\\n        hc.sort()\\n        vc.sort()\\n        maxh, maxv = max(hc[0], h - hc[-1]), max(vc[0], w - vc[-1])\\n        for i in range(len(hc)):\\n            maxh = max(maxh, hc[i] - hc[i-1])\\n        for i in range(len(vc)):\\n            maxv = max(maxv, vc[i] - vc[i-1])\\n        return (maxh * maxv) % 1000000007\\n```"]}
{"id": "1254", "ref_py": ["def minReorder(self, n: int, connections: list[list[int]]) -> int:\\n        T = Hashable\\n        Direction = bool\\n        Graph = Mapping[T, Iterable[tuple[T, Direction]]]", "def dfs(self, al, visited, from_node):\\n        change = 0\\n        visited[from_node] = True\\n        for to_node in al[from_node]:\\n            if not visited[abs(to_node)]:\\n                change += self.dfs(al, visited, abs(to_node)) + (1 if to_node > 0 else 0)\\n        return change", "def dfs(self, gr, visited, from_node):\\n        change = 0\\n        visited[from_node] = True\\n        for to_node in gr[from_node]:\\n            if not visited[abs(to_node)]:\\n                change += self.dfs(gr, visited, abs(to_node)) + (1 if to_node > 0 else 0)\\n        return change"]}
{"id": "1255", "ref_py": ["def diagonalPrime(self, nums: List[List[int]]) -> int:", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num: int) -> bool:\\n            if num == 2 or num == 3:\\n                return True\\n            if num <= 1 or num % 2 == 0 or num % 3 == 0:\\n                return False"]}
{"id": "1258", "ref_py": ["defaultdict, deque", "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        ", "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        def dfs(sv,visited):\\n            if visited[sv]==-1:"]}
{"id": "1259", "ref_py": ["defines a class named \"Solution\" with a member function named \"balancedStringSplit\". This function takes a string \"s\" as input and returns an integer.", "defines a class named \"Solution\" with a member function named \"balancedStringSplit\". This function takes a string \"s\" as input and returns an integer.", "defines a class named \"Solution\" with a member function named \"balancedStringSplit\". This function takes a string \"s\" as input and returns an integer."]}
{"id": "1260", "ref_py": ["def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1", "def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        n = len(bloomDay)\\n        val = m * k\\n        if val > n:\\n            return -1\\n        \\n        low = float(\\'inf\\')\\n        high = float(\\'-inf\\')\\n        for day in bloomDay:\\n            low = min(day, low)\\n            high = max(day, high)\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if self.possible(bloomDay, mid, m, k):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n    \\n    def possible(self, bloomDay, day, m, k):\\n        cnt = 0\\n        num = 0\\n        for bd in bloomDay:\\n            if bd <= day:\\n                cnt += 1\\n            else:\\n                num += cnt // k\\n                cnt = 0\\n        num += cnt // k\\n        return num >= m", "def minDays(self, A: List[int], m: int, k: int) -> int:\\n        def isFeasible(x):\\n            aj_flw = count_flw =0\\n            \\n            for i in A:\\n                if x>=i:\\n                    aj_flw += 1\\n                else:\\n                    aj_flw = 0\\n                if aj_flw == k:\\n                    count_flw += 1 \\n                    aj_flw = 0\\n            return count_flw >=m\\n                    \\n        if len(A)<m*k: return -1 \\n        l,r = 1,max(A) \\n        \\n        while l<=r:\\n            mid = l+(r-l)//2 \\n            if isFeasible(mid):\\n                r = mid - 1 \\n            else:\\n                l = mid + 1\\n                 \\n        return l\\n                \\n```"]}
{"id": "1261", "ref_py": ["defined as the minimum number of operations required to transform one string into another.\\n<!-- Describe your first thoughts on how to solve this problem. -->", "def minDistance(self, word1, word2):\\n        \\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        ", "def minDistance(self, word1, word2):\\n        \\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        "]}
{"id": "1262", "ref_py": ["def avoidFlood(self, A: List[int]) -> List[int]:\\n        nxt = list(range(len(A) + 1))\\n        pre = {}\\n        res = [1] * len(A)", "def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        ret = [-1] * len(rains)\\n        to_empty = [] ", "def avoidFlood(self, rains: List[int]) -> List[int]:\\n    \\n        "]}
{"id": "1263", "ref_py": ["def kthFactor(self, n, k):\\n        \\n        for i in range(1, n+1):\\n            if n % i == 0:\\n                k -= 1\\n                if k == 0:  ", "def kthFactor(self, n, k):\\n        \\n        for i in range(1, n+1):\\n            if n % i == 0:\\n                k -= 1\\n                if k == 0:  ", "def kthFactor(self, n, k):\\n        \\n        for i in range(1, n+1):\\n            if n % i == 0:\\n                k -= 1\\n                if k == 0:  "]}
{"id": "1264", "ref_py": ["def longestSubarray(self, nums: list[int]) -> int:\\n        streaks_of_1s = accumulate(nums, lambda a, x: (a + 1) * (x != 0), initial=0)\\n        streaks_at_0 = compress(streaks_of_1s, map(not_, chain(nums, (0,))))\\n        return max(starmap(add, pairwise(streaks_at_0)), default=len(nums) - 1)", "def longestSubarray(self, nums):\\n        count = nums.count(0)\\n        listt=[]", "def longestSubarray(self, nums):\\n        count = nums.count(0)\\n        listt=[]"]}
{"id": "1265", "ref_py": ["def canArrange(self, arr: List[int], k: int) -> bool:\\n        return sum(arr)%k==0\\n```\\nSorry but that\\'s my thought process behind the solution which fortunately got accepted during the contest. I just got lucky like hundreds of others.\\nBut ,If you study the corner cases,you can find something like this \\n```\\n[2,2,2,2,2,2]\\nk =6\\n```\\nsum = 12  and 12%6=0, but there is no pair whose sum is divisible by 6.", "def canArrange(self, arr: List[int], k: int) -> bool:\\n        return sum(arr)%k==0\\n```\\nSorry but that\\'s my thought process behind the solution which fortunately got accepted during the contest. I just got lucky like hundreds of others.\\nBut ,If you study the corner cases,you can find something like this \\n```\\n[2,2,2,2,2,2]\\nk =6\\n```\\nsum = 12  and 12%6=0, but there is no pair whose sum is divisible by 6.", "def canArrange(self, arr: List[int], k: int) -> bool:\\n        return sum(arr)%k==0\\n```\\nSorry but that\\'s my thought process behind the solution which fortunately got accepted during the contest. I just got lucky like hundreds of others.\\nBut ,If you study the corner cases,you can find something like this \\n```\\n[2,2,2,2,2,2]\\nk =6\\n```\\nsum = 12  and 12%6=0, but there is no pair whose sum is divisible by 6."]}
{"id": "1266", "ref_py": ["def numSubseq(self, nums: list[int], target: int) -> int:\\n        s_nums = sorted(nums)\\n        return sum(\\n            pow(2, bisect.bisect(s_nums, y, i) - 1 - i, 1_000_000_007)\\n            for i, x in enumerate(s_nums)\\n            if (y := target - x) >= x\\n        ) % 1_000_000_007", "def numSubseq(self, nums: list[int], target: int) -> int:\\n        s_nums = sorted(nums)\\n        return sum(\\n            pow(2, bisect.bisect(s_nums, y, i) - 1 - i, 1_000_000_007)\\n            for i, x in enumerate(s_nums)\\n            if (y := target - x) >= x\\n        ) % 1_000_000_007", "def numSubseq(self, nums: list[int], target: int) -> int:\\n        s_nums = sorted(nums)\\n        return sum(\\n            pow(2, bisect.bisect(s_nums, y, i) - 1 - i, 1_000_000_007)\\n            for i, x in enumerate(s_nums)\\n            if (y := target - x) >= x\\n        ) % 1_000_000_007"]}
{"id": "1267", "ref_py": ["def getLastMoment(self, n, left, right):\\n        leftMax = float(\\'-inf\\')\\n        rightMin = float(\\'inf\\')\\n        \\n        for pos in left:\\n            leftMax = max(leftMax, pos)\\n        \\n        for pos in right:\\n            rightMin = min(rightMin, pos)\\n        \\n        return max(leftMax, n - rightMin)\\n        \\n```\\n", "def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ", "def getLastMoment(self, n, left, right):\\n        leftMax = float(\\'-inf\\')\\n        rightMin = float(\\'inf\\')\\n        \\n        for pos in left:\\n            leftMax = max(leftMax, pos)\\n        \\n        for pos in right:\\n            rightMin = min(rightMin, pos)\\n        \\n        return max(leftMax, n - rightMin)\\n        \\n```\\n"]}
{"id": "1268", "ref_py": ["def numSubmat(self, mat: List[List[int]]) -> int:\\n        col=len(mat[0])\\n        h,res=[0]*col,0", "def numSubmat(self, mat: List[List[int]]) -> int:\\n        col=len(mat[0])\\n        h,res=[0]*col,0", "def numSubmat(self, mat: List[List[int]]) -> int:\\n        col=len(mat[0])\\n        h,res=[0]*col,0"]}
{"id": "1269", "ref_py": ["define a helper function (**parse**) which will take a string (**str**) and only pass on valid options for another helper (**process**) to handle.", "definitely doesn\\'t deserve so many downvotes. The edge cases may seem bad initially, but in code it\\'s only a couple `if elif` conditionals to make this pass.", "definitely doesn\\'t deserve so many downvotes. The edge cases may seem bad initially, but in code it\\'s only a couple `if elif` conditionals to make this pass."]}
{"id": "1270", "ref_py": ["def minDifference(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\t\\tans = math.inf\\n\\t\\t\\t\\t\\tif n<=4:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\tnums.sort()\\n\\t\\t\\t\\t\\tfor i in range(4):\\n\\t\\t\\t\\t\\t\\tfor j in range(1,4-i+1):\\n\\t\\t\\t\\t\\t\\t\\tans = min(ans,abs(nums[i]-nums[n-j]))\\n\\t\\t\\t\\t\\treturn ans", "def minDifference(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\t\\tans = math.inf\\n\\t\\t\\t\\t\\tif n<=4:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\tnums.sort()\\n\\t\\t\\t\\t\\tfor i in range(4):\\n\\t\\t\\t\\t\\t\\tfor j in range(1,4-i+1):\\n\\t\\t\\t\\t\\t\\t\\tans = min(ans,abs(nums[i]-nums[n-j]))\\n\\t\\t\\t\\t\\treturn ans", "def minDifference(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\t\\tans = math.inf\\n\\t\\t\\t\\t\\tif n<=4:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\tnums.sort()\\n\\t\\t\\t\\t\\tfor i in range(4):\\n\\t\\t\\t\\t\\t\\tfor j in range(1,4-i+1):\\n\\t\\t\\t\\t\\t\\t\\tans = min(ans,abs(nums[i]-nums[n-j]))\\n\\t\\t\\t\\t\\treturn ans"]}
{"id": "1271", "ref_py": ["def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        parent = {}  ", "def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        parents = {}", "def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        parent = {}  "]}
{"id": "1272", "ref_py": ["def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            prob = succProb[i]\\n            graph[u].append((v, prob))\\n            graph[v].append((u, prob))", "def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            prob = succProb[i]\\n            graph[u].append((v, prob))\\n            graph[v].append((u, prob))", "def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            u, v = edges[i]\\n            prob = succProb[i]\\n            graph[u].append((v, prob))\\n            graph[v].append((u, prob))"]}
{"id": "1273", "ref_py": ["def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj = [[] for _ in range(n)]", "def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj = [[] for _ in range(n)]", "def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj = [[] for _ in range(n)]"]}
{"id": "1274", "ref_py": ["def numOfSubarrays(self, arr: List[int]) -> int:\\n        ans = 0 \\n        even = 1 ", "def numOfSubarrays(self, arr: List[int]) -> int:\\n        ans = 0 \\n        even = 1 ", "def numOfSubarrays(self, arr: List[int]) -> int:\\n        ans = 0 \\n        even = 1 "]}
{"id": "1275", "ref_py": ["def numSplits(self, s):\\n        \\n        st=set()\\n        ls=[0]*len(s)\\n        for i in range(len(s)):\\n            st.add(s[i])\\n            ls[i]=len(st)\\n        ls2=[0]*len(s)\\n        st.clear()\\n        for i in range(len(s)-1,-1,-1):\\n            st.add(s[i])\\n            ls2[i]=len(st)\\n        way=0\\n        for  i in range(len(ls)-1):\\n            if ls[i]==ls2[i+1]:\\n                way+=1\\n        return way", "def numSplits(self, s: str) -> int:\\n\\t\\t", "def numSplits(self, s):\\n        \\n        st=set()\\n        ls=[0]*len(s)\\n        for i in range(len(s)):\\n            st.add(s[i])\\n            ls[i]=len(st)\\n        ls2=[0]*len(s)\\n        st.clear()\\n        for i in range(len(s)-1,-1,-1):\\n            st.add(s[i])\\n            ls2[i]=len(st)\\n        way=0\\n        for  i in range(len(ls)-1):\\n            if ls[i]==ls2[i+1]:\\n                way+=1\\n        return way"]}
{"id": "1276", "ref_py": ["def inorder(root):\\n                if not root:\\n                    return\\n                inorder(root.left)\\n                .... store/use value here : root.val ....\\n                inorder(root.right)", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self):\\n        self.mp = {}"]}
{"id": "1277", "ref_py": ["def countPairs(self, root: TreeNode, distance: int) -> list:\\n        self.res = 0  \\n        \\n        def dfs(node) -> list:\\n            if not node: return []\\n            if not node.left and not node.right: return [1]", "def d(code1,code2):\\n            l1,l2 = len(code1),len(code2)\\n            if l1<l2:\\n                code1,code2=code2,code1\\n                l1,l2 = l2,l1\\n            a = l1-l2\\n            i = 0\\n            while code1[i]==code2[i]:\\n                i+=1\\n            return (l1-i)*2-a\\n```", "def countPairs(self, root: TreeNode, distance: int) -> list:\\n        self.res = 0  \\n        \\n        def dfs(node) -> list:\\n            if not node: return []\\n            if not node.left and not node.right: return [1]"]}
{"id": "1278", "ref_py": ["def getWinner(self, arr, k):\\n        winner = arr[0]\\n        wins = 0\\n        \\n        for i in range(1, len(arr)):\\n            if winner > arr[i]:\\n                wins += 1\\n            else:\\n                wins = 1\\n                winner = arr[i]\\n            \\n            if wins == k:\\n                break\\n        \\n        return winner\\n```", "defeat all other elements to **win** `k` games and the **only** element can do this is the **largest** element in the array.", "defeat all other elements to **win** `k` games and the **only** element can do this is the **largest** element in the array."]}
{"id": "1279", "ref_py": ["def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None", "def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None", "def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None"]}
{"id": "1280", "ref_py": ["def canConvertString(self, s: str, t: str, k: int) -> bool:", "def canConvertString(self, s: str, t: str, k: int) -> bool:", "def canConvertString(self, s: str, t: str, k: int) -> bool:"]}
{"id": "1281", "ref_py": ["def minInsertions(self, s: str) -> int:\\n        \\n        ", "def minInsertions(self, s):\\n        \\n        stack = []\\n        ans = 0\\n        i = 0\\n        left = 0\\n        right = 0\\n        while i < len(s):\\n            if s[i]==\"(\":\\n                left += 1\\n                i += 1\\n            else:\\n                print(i)\\n                ", "def minInsertions(self, s: str) -> int:\\n        \\n        "]}
{"id": "1282", "ref_py": ["def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     ", "def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     "]}
{"id": "1283", "ref_py": ["def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set()\\n        current_sum = 0\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            current_sum += nums[i]\\n            ", "def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set()\\n        current_sum = 0\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            current_sum += nums[i]\\n            ", "def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set()\\n        current_sum = 0\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            current_sum += nums[i]\\n            "]}
{"id": "1284", "ref_py": ["definition of a triangular number, which is in this case doubled because the numbers are **2** apart, rather than **1**. The standard formula for a triangular number is **n * (n + 1) / 2**. Since our triangular number is only half the length of array, not counting the middle, that equates to **2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2**, which simplifies to **(n^2 - 1) / 4**.", "def minOperations(self, n: int) -> int:\\n        s=t=0\\n        for i in range(1,n+1):\\n            if i%2!=0:\\n                s+=t\\n                t+=1\\n            else: \\n                s+=t\\n        return s\\n            \\n", "definition of a triangular number, which is in this case doubled because the numbers are **2** apart, rather than **1**. The standard formula for a triangular number is **n * (n + 1) / 2**. Since our triangular number is only half the length of array, not counting the middle, that equates to **2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2**, which simplifies to **(n^2 - 1) / 4**."]}
{"id": "1285", "ref_py": ["def maxDistance(self, position: List[int], m: int) -> int:\\n\\tposition.sort()\\n\\tn = len(position)\\n\\tdef isValid(force):\\n\\t\\tstart = position[0]\\n\\t\\tcount = 1\\n\\t\\twhile(count < m):\\n\\t\\t\\tstart += force\\n\\t\\t\\ti = bisect_left(position, start)\\n\\t\\t\\tif(i == n):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tstart = position[i]\\n\\t\\t\\tcount += 1\\n\\t\\treturn True\\n\\ti = 1\\n\\tj = position[n-1] - position[0]\\n\\twhile(i <= j):\\n\\t\\tmid = i + (j-i)//2\\n\\t\\tx = isValid(mid)\\n\\t\\tif(x):\\n\\t\\t\\ti = mid+1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\tj = mid-1\\n", "def maxDistance(self, position, m):\\n        position.sort()\\n        n = len(position)", "def isPossible(arr,dis,k):\\n    n=len(arr)\\n    force=1 \\n    last=arr[0]\\n    for i in range(n):\\n        if (arr[i]-last)>=dis:\\n            force+=1\\n            last=arr[i]\\n        if force>=k:\\n            return True"]}
{"id": "1286", "ref_py": ["def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\\n        set1, set2 = set(), set()\\n        for x, y in edges:\\n            set1.add(x)\\n            set2.add(y)\\n        return set1.difference(set2)\\n```\\n**Explanation**:", "def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\\n        nonRoots = [False] * n\\n        for edge in edges:\\n            nonRoots[edge[1]] = True\\n        return [i for i, isNonRoot in enumerate(nonRoots) if not isNonRoot]\\n```", "def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\\n        nonRoots = [False] * n\\n        for edge in edges:\\n            nonRoots[edge[1]] = True\\n        return [i for i, isNonRoot in enumerate(nonRoots) if not isNonRoot]\\n```"]}
{"id": "1287", "ref_py": ["def findBottomLeftValue(self, root: TreeNode) -> int:\\n        ", "def findBottomLeftValue(self, root: TreeNode) -> int:\\n        ", "def findBottomLeftValue(self, root: TreeNode) -> int:\\n        "]}
{"id": "1288", "ref_py": ["def containsCycle(self, grid: List[List[str]]) -> bool:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\t@lru_cache(None)\\n\\tdef isCycle(i, j, par_i, par_j):\\n\\t\\tif (i, j) in vis:\\n\\t\\t\\treturn True\\n\\t\\tvis.add((i, j))\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == grid[i][j] and (i+x, j+y) != (par_i, par_j)):\\n\\t\\t\\t\\tif(isCycle(i+x, j+y, i, j)):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\tvis = set()\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif((i, j) not in vis and isCycle(i, j, -1, -1)):\\n\\t\\t\\t\\treturn 1\\n", "def containsCycle(self, A: List[List[str]]) -> bool:\\n        R, C = len(A), len(A[0])\\n        visited = set()\\n        \\n        def neighbors(r, c):\\n            return [(i, j) for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)] if 0 <= i < R and 0 <= j < C and A[i][j] == A[r][c]]\\n        \\n        def dfs(r, c, x, prev, seen):\\n            if (r, c) in seen:\\n                return True\\n            seen.add((r, c))\\n            visited.add((r, c))", "def containsCycle(self, grid):\\n        \\n        \\n        m,n=len(grid),len(grid[0])\\n        "]}
{"id": "1289", "ref_py": ["def maxCoins(self, piles):\\n        piles.sort()\\n        ans = 0\\n        n = len(piles)", "def maxCoins(self, piles):\\n        piles.sort()\\n        ans = 0\\n        n = len(piles)", "def maxCoins(self, piles):\\n        piles.sort()\\n        ans = 0\\n        n = len(piles)"]}
{"id": "1290", "ref_py": ["def findLatestStep(self, arr: List[int], m: int) -> int:\\n        \\n        if m==len(arr): return m\\n        \\n        border=[0]*(len(arr)+2)\\n        ans=-1\\n        \\n        for i in range(len(arr)):\\n            left=right=arr[i]\\n            if border[right+1]>0: right=border[right+1]\\n            if border[left-1]>0: left=border[left-1]\\n            border[left], border[right] = right, left\\n            if (right-arr[i]==m) or (arr[i]-left ==m): ans=i\\n        \\n        return ans\\n", "def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.size = [0] * size\\n        self.cnt_size = [0] * size\\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.cnt_size[self.size[pp]] -= 1\\n        self.cnt_size[self.size[pq]] -= 1\\n        self.parent[pq] = pp\\n        self.size[pp] += self.size[pq]\\n        self.cnt_size[self.size[pp]] += 1", "def findLatestStep(arr, m):\\n    \\n    def dfs(start, end, step, target):\\n            \\n        if end - start + 1 < target:\\n            return -1\\n        \\n        elif end - start + 1 == target:\\n            return step\\n        \\n        x, res = arr[step - 1], -1"]}
{"id": "1291", "ref_py": ["define:\\n`dp[i][0] : max length of subarray ending with index i With positive product`\\n`dp[i][1] : max length of subarray ending with index i With negative product`", "define:\\n`dp[i][0] : max length of subarray ending with index i With positive product`\\n`dp[i][1] : max length of subarray ending with index i With negative product`", "define:\\n`dp[i][0] : max length of subarray ending with index i With positive product`\\n`dp[i][1] : max length of subarray ending with index i With negative product`"]}
{"id": "1292", "ref_py": ["def numWays(self, s: str) -> int:\\n        ones = 0", "def numWays(self, s):\\n\\tmod = 10**9+7\\n\\tcnt = s.count(\\'1\\')\\n\\tif cnt == 0: return (len(s)-1)*(len(s)-2)//2 % mod\\n\\tif cnt % 3 != 0: return 0\\n\\tones = []\\n\\tfor i,x in enumerate(s):\\n\\t\\tif x == \\'1\\': ones.append(i)\\n", "def numWays(self, s: str) -> int:\\n        ones = 0"]}
{"id": "1293", "ref_py": ["def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\\n        size = len(arr)\\n        right = size - 1\\n        while right and arr[right] >= arr[right - 1]:\\n            right -= 1\\n        if right == 0: return 0\\n        ans = right\\n        left = 0\\n        while left == 0 or arr[left] >= arr[left-1]:\\n            while right < size and arr[right] < arr[left]:\\n                right += 1\\n            ans = min(ans, right - left - 1)\\n            left += 1\\n        return ans\\n```", "def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\\n        size = len(arr)\\n        right = size - 1\\n        while right and arr[right] >= arr[right - 1]:\\n            right -= 1\\n        if right == 0: return 0\\n        ans = right\\n        left = 0\\n        while left == 0 or arr[left] >= arr[left-1]:\\n            while right < size and arr[right] < arr[left]:\\n                right += 1\\n            ans = min(ans, right - left - 1)\\n            left += 1\\n        return ans\\n```", "def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\\n        size = len(arr)\\n        right = size - 1\\n        while right and arr[right] >= arr[right - 1]:\\n            right -= 1\\n        if right == 0: return 0\\n        ans = right\\n        left = 0\\n        while left == 0 or arr[left] >= arr[left-1]:\\n            while right < size and arr[right] < arr[left]:\\n                right += 1\\n            ans = min(ans, right - left - 1)\\n            left += 1\\n        return ans\\n```"]}
{"id": "1294", "ref_py": ["def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)", "def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if Solution.flag2==False:\\n            Solution.temp1=head\\n            Solution.flag2=True\\n        if head==None and Solution.flag==True:\\n            return True\\n        elif root==None:\\n            return False\\n        if head.val==root.val:\\n            head=head.next\\n            Solution.flag=True\\n        else:\\n            head=Solution.temp1\\n            Solution.flag=False\\n        return self.isSubPath(head,root.left) or self.isSubPath(head,root.right)\\n```", "def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)"]}
{"id": "1295", "ref_py": ["def minCost(self, colors: str, neededTime: List[int]) -> int:\\n        ans = 0\\n        i = 0\\n        j = 1\\n        n = len(colors)\\n        while i < n and j < n:\\n            if colors[i] == colors[j]:\\n                if neededTime[i] > neededTime[j]:\\n                    ans += neededTime[j]\\n                    j += 1\\n                else:\\n                    ans += neededTime[i]\\n                    i = j\\n                    j += 1\\n                \\n            else:\\n                i = j\\n                j += 1", "def minCost(self, colors: str, neededTime: List[int]) -> int:\\n        \\n        time = 0\\n        if len(colors) == 1:\\n            return time\\n        \\n        \\n        for i in range(len(colors)-1):\\n            curColor = colors[i]\\n            nextColor = colors[i+1]\\n\\t\\t\\t\\n            if curColor == nextColor:\\n                if neededTime[i] < neededTime[i+1]:\\n                    time += neededTime[i]\\n                else:\\n                    time += neededTime[i+1]\\n                    neededTime[i+1], neededTime[i] = neededTime[i], neededTime[i+1]\\n                \\n        \\n        return time", "def minCost(self, colors: str, neededTime: List[int]) -> int:\\n        \\n        time = 0\\n        if len(colors) == 1:\\n            return time\\n        \\n        \\n        for i in range(len(colors)-1):\\n            curColor = colors[i]\\n            nextColor = colors[i+1]\\n\\t\\t\\t\\n            if curColor == nextColor:\\n                if neededTime[i] < neededTime[i+1]:\\n                    time += neededTime[i]\\n                else:\\n                    time += neededTime[i+1]\\n                    neededTime[i+1], neededTime[i] = neededTime[i], neededTime[i+1]\\n                \\n        \\n        return time"]}
{"id": "1296", "ref_py": ["def minSteps(self, s: str, t: str) -> int:\\n        ans = 0\\n        hashh = [0] * 26", "def minSteps(self, s: str, t: str) -> int:\\n        ans = 0\\n        hashh = [0] * 26", "def minSteps(self, s: str, t: str) -> int:\\n        ans = 0\\n        hashh = [0] * 26"]}
{"id": "1297", "ref_py": ["def minCostConnectPoints(self, points: List[List[int]]) -> int:\\n        n=len(points)\\n        def find(parent,x):\\n            if parent[x]==x:\\n                return x\\n            parent[x]=find(parent,parent[x])\\n            return parent[x]", "def find_set(point,parents):\\n    ", "def minCostConnectPoints(self, points: List[List[int]]) -> int:\\n        d, res = {(x, y): float(\\'inf\\') if i else 0 for i, (x, y) in enumerate(points)}, 0\\n        while d:\\n            x, y = min(d, key=d.get)  "]}
{"id": "1298", "ref_py": ["def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1", "def searchInsert(self, nums, target):\\n        \\n        if target > nums[len(nums) - 1]:\\n            return len(nums)", "def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1"]}
{"id": "1299", "ref_py": ["def minSubarray(self, nums: List[int], p: int) -> int:\\n        sumMod = sum(nums) % p\\n        if sumMod == 0: return 0\\n        prefixsum = 0\\n        remainder2idx = {0:-1}\\n        minLen = len(nums)\\n        for idx, n in enumerate(nums):\\n            prefixsum += n\\n            prefixsum %= p ", "def minSubarray(self, nums: List[int], p: int) -> int:\\n        dp = defaultdict(int)\\n        dp[0] = -1\\n        target = sum(nums) % p\\n        curSum = 0\\n        result = len(nums)\\n        \\n        if sum(nums) % p == 0: return 0\\n        \\n        for i in range(len(nums)):\\n            curSum += nums[i]\\n            \\n            curMod = curSum % p\\n            \\n            temp = (curSum - target) % p\\n            \\n            if temp in dp:\\n                if i - dp[temp] < result:\\n                    result = i - dp[temp]\\n            \\n            dp[curMod] = i\\n        \\n        return result if result < len(nums) else -1", "def minSubarray(self, nums: List[int], p: int) -> int:\\n        sumMod = sum(nums) % p\\n        if sumMod == 0: return 0\\n        prefixsum = 0\\n        remainder2idx = {0:-1}\\n        minLen = len(nums)\\n        for idx, n in enumerate(nums):\\n            prefixsum += n\\n            prefixsum %= p "]}
{"id": "1300", "ref_py": ["def maxUniqueSplit(self, s: str) -> int:", "def maxUniqueSplit(self, s: str) -> int:", "def maxUniqueSplit(self, s: str) -> int:"]}
{"id": "1301", "ref_py": ["def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        ", "def isSameTree(self, p, q):\\n        ", "def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        "]}
{"id": "1302", "ref_py": ["def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        CAPACITY = 4\\n        NO_PROFIT = -1\\n        \\n        numCustomersWaiting = 0\\n        totalCustomers = 0", "def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers:\\n            return 0\\n        waiting = 0\\n        profit = 0\\n        \\n        max_profit = -1\\n        index = 0\\n        \\n        op = 0 ", "def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        CAPACITY = 4\\n        NO_PROFIT = -1\\n        \\n        numCustomersWaiting = 0\\n        totalCustomers = 0"]}
{"id": "1304", "ref_py": ["def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\\n        \\n        def is_within_1hr(t1, t2):\\n            h1, m1 = t1.split(\":\")\\n            h2, m2 = t2.split(\":\")\\n            if int(h1) + 1 < int(h2): return False\\n            if h1 == h2: return True\\n            return m1 >= m2\\n        \\n        records = collections.defaultdict(list)\\n        for name, time in zip(keyName, keyTime):\\n            records[name].append(time)\\n        \\n        rv = []\\n        for person, record in records.items():\\n            record.sort()\\n", "def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\\n        key_time = {}\\n        for index, name in enumerate(keyName):\\n            key_time[name] = key_time.get(name, [])\\n            key_time[name].append(int(keyTime[index].replace(\":\", \"\")))\\n        ans = []\\n        for name, time_list in key_time.items():\\n            time_list.sort()\\n            n = len(time_list)\\n            for i in range(n-2):\\n                if time_list[i+2] - time_list[i] <= 100:\\n                    ans.append(name)\\n                    break\\n        return sorted(ans)\\n   ```\\n        \\n            \\n        \\n        \\n        \\n        \\n", "def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\\n        \\n        def is_within_1hr(t1, t2):\\n            h1, m1 = t1.split(\":\")\\n            h2, m2 = t2.split(\":\")\\n            if int(h1) + 1 < int(h2): return False\\n            if h1 == h2: return True\\n            return m1 >= m2\\n        \\n        records = collections.defaultdict(list)\\n        for name, time in zip(keyName, keyTime):\\n            records[name].append(time)\\n        \\n        rv = []\\n        for person, record in records.items():\\n            record.sort()\\n"]}
{"id": "1305", "ref_py": ["def diagonalPrime(self, nums: List[List[int]]) -> int:", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True", "def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num: int) -> bool:\\n            if num == 2 or num == 3:\\n                return True\\n            if num <= 1 or num % 2 == 0 or num % 3 == 0:\\n                return False"]}
{"id": "1306", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1307", "ref_py": ["def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\\n        adj = [set() for _ in range(n)]\\n        indegree = [0] * n\\n        \\n        for edge in roads:\\n            v, w = edge\\n            indegree[v] += 1\\n            indegree[w] += 1\\n            adj[v].add(w)\\n            adj[w].add(v)\\n        \\n        maxdegree = max(indegree)\\n        \\n        maxindex = [i for i in range(n) if indegree[i] == maxdegree]\\n        \\n        samemaxdegree = len(maxindex)\\n        \\n        if samemaxdegree > 1:\\n            for i in range(1, samemaxdegree):\\n                for j in range(i):\\n                    if maxindex[i] not in adj[maxindex[j]]:\\n                        print(maxindex[i], maxindex[j])\\n                        return 2 * maxdegree\\n                    \\n            return 2 * maxdegree - 1\\n        \\n        mxid = maxindex[0]\\n        max_rank = 0\\n        \\n        for j in range(n):\\n            if j == mxid:\\n                continue\\n            rank = maxdegree + indegree[j] - (1 if j in adj[mxid] else 0)\\n            max_rank = max(max_rank, rank)\\n            print(mxid)\\n        \\n        return max_rank", "def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\\n        adj = [set() for _ in range(n)]\\n        indegree = [0] * n\\n        \\n        for edge in roads:\\n            v, w = edge\\n            indegree[v] += 1\\n            indegree[w] += 1\\n            adj[v].add(w)\\n            adj[w].add(v)\\n        \\n        maxdegree = max(indegree)\\n        \\n        maxindex = [i for i in range(n) if indegree[i] == maxdegree]\\n        \\n        samemaxdegree = len(maxindex)\\n        \\n        if samemaxdegree > 1:\\n            for i in range(1, samemaxdegree):\\n                for j in range(i):\\n                    if maxindex[i] not in adj[maxindex[j]]:\\n                        print(maxindex[i], maxindex[j])\\n                        return 2 * maxdegree\\n                    \\n            return 2 * maxdegree - 1\\n        \\n        mxid = maxindex[0]\\n        max_rank = 0\\n        \\n        for j in range(n):\\n            if j == mxid:\\n                continue\\n            rank = maxdegree + indegree[j] - (1 if j in adj[mxid] else 0)\\n            max_rank = max(max_rank, rank)\\n            print(mxid)\\n        \\n        return max_rank", "def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\\n        adj = [set() for _ in range(n)]\\n        indegree = [0] * n\\n        \\n        for edge in roads:\\n            v, w = edge\\n            indegree[v] += 1\\n            indegree[w] += 1\\n            adj[v].add(w)\\n            adj[w].add(v)\\n        \\n        maxdegree = max(indegree)\\n        \\n        maxindex = [i for i in range(n) if indegree[i] == maxdegree]\\n        \\n        samemaxdegree = len(maxindex)\\n        \\n        if samemaxdegree > 1:\\n            for i in range(1, samemaxdegree):\\n                for j in range(i):\\n                    if maxindex[i] not in adj[maxindex[j]]:\\n                        print(maxindex[i], maxindex[j])\\n                        return 2 * maxdegree\\n                    \\n            return 2 * maxdegree - 1\\n        \\n        mxid = maxindex[0]\\n        max_rank = 0\\n        \\n        for j in range(n):\\n            if j == mxid:\\n                continue\\n            rank = maxdegree + indegree[j] - (1 if j in adj[mxid] else 0)\\n            max_rank = max(max_rank, rank)\\n            print(mxid)\\n        \\n        return max_rank"]}
{"id": "1308", "ref_py": ["def checkPalindromeFormation(self, a: str, b: str) -> bool:\\n        def pal(x):\\n            return x == x[::-1]\\n        if pal(a) or pal(b): return True\\n        ", "def checkPalindromeFormation(self, a: str, b: str) -> bool:\\n        def pal(x):\\n            return x == x[::-1]\\n        if pal(a) or pal(b): return True\\n        ", "def checkPalindromeFormation(self, a: str, b: str) -> bool:\\n        def pal(x):\\n            return x == x[::-1]\\n        if pal(a) or pal(b): return True\\n        "]}
{"id": "1309", "ref_py": ["def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:", "def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:\\n        ", "def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:\\n        "]}
{"id": "1310", "ref_py": ["def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        dics = collections.defaultdict(list)\\n        max_length = releaseTimes[0]\\n        \\n        dics[max_length].append(keysPressed[0])\\n        \\n        for i in range(1, len(releaseTimes)):\\n            length = releaseTimes[i] - releaseTimes[i - 1]\\n            \\n            if length >= max_length:\\n                dics[length].append(keysPressed[i])\\n                max_length = length\\n                \\n        \\n        dics[max_length].sort()\\n        \\n        return dics[max_length][len(dics[max_length]) - 1]\\n```", "def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\tkey = [keysPressed[0]]\\n\\tmax_dur = releaseTimes[0]", "def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_dur = releaseTimes[0]\\n        max_key = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            if releaseTimes[i] - releaseTimes[i-1] > max_dur:\\n                max_dur = releaseTimes[i] - releaseTimes[i-1]\\n                max_key = keysPressed[i]\\n            elif releaseTimes[i] - releaseTimes[i-1] == max_dur and max_key < keysPressed[i]:\\n                 max_key = keysPressed[i]\\n                    \\n        return max_key \\n```\\t\\t\\n"]}
{"id": "1311", "ref_py": ["def findLexSmallestString(self, s, a, b):\\n        ", "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tque = deque([s])\\n\\t\\t\\tans = s\\n\\t\\t\\tvisited = set([s])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\ts = que.popleft()\\n\\t\\t\\t\\tans = min(ans, s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsumm = \"\"\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\t\\tsumm += str((int(s[i])+a)%10)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm += s[i]  \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif summ not in visited:\\n\\t\\t\\t\\t\\tque.append(summ)\\n\\t\\t\\t\\t\\tvisited.add(summ)\\n\\t\\t\\t\\tif s[-b:]+s[:-b] not in visited:\\n\\t\\t\\t\\t\\tque.append(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\tvisited.add(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans \\n", "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tque = deque([s])\\n\\t\\t\\tans = s\\n\\t\\t\\tvisited = set([s])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\ts = que.popleft()\\n\\t\\t\\t\\tans = min(ans, s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsumm = \"\"\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\t\\tsumm += str((int(s[i])+a)%10)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm += s[i]  \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif summ not in visited:\\n\\t\\t\\t\\t\\tque.append(summ)\\n\\t\\t\\t\\t\\tvisited.add(summ)\\n\\t\\t\\t\\tif s[-b:]+s[:-b] not in visited:\\n\\t\\t\\t\\t\\tque.append(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\tvisited.add(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans \\n"]}
{"id": "1312", "ref_py": ["def __init__(self, n):\\n        self.n = n\\n        self.sums = [0] * (n + 1)", "def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\\n        n = len(scores)\\n        dp = [0] * n\\n        ans = 0\\n        players = [(ages[i], scores[i]) for i in range(n)]\\n        players.sort(key = lambda x: x[0])\\n        for i in range(n):\\n            dp[i] = players[i][1]\\n            for j in range(i):\\n                if players[j][1] <= players[i][1]:\\n                    dp[i] = max(dp[i], dp[j] + players[i][1])\\n            ans = max(ans, dp[i])\\n        return ans", "def __init__(self, n):\\n        self.n = n\\n        self.sums = [0] * (n + 1)"]}
{"id": "1313", "ref_py": ["def checkArithmeticSubarrays(self, nums, l, r):\\n        ans = []", "def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:\\n        result = []", "def checkArithmeticSubarrays(self, nums, l, r):\\n        ans = []"]}
{"id": "1314", "ref_py": ["defined as **maximum absolute difference in heights between two consecutive cells of the path.**\\n- **Thus, we could use Dijikstra\\'s algorithm** which is used to find the shortest path in a weighted graph with a slight modification of **criteria for the shortest path,** which costs **O(E log V)**, where E is number of edges **E = 4*M*N,** V is number of veritices **V = M*N**", "defined as **maximum absolute difference in heights between two consecutive cells of the path.**\\n- **Thus, we could use Dijikstra\\'s algorithm** which is used to find the shortest path in a weighted graph with a slight modification of **criteria for the shortest path,** which costs **O(E log V)**, where E is number of edges **E = 4*M*N,** V is number of veritices **V = M*N**", "defined as **maximum absolute difference in heights between two consecutive cells of the path.**\\n- **Thus, we could use Dijikstra\\'s algorithm** which is used to find the shortest path in a weighted graph with a slight modification of **criteria for the shortest path,** which costs **O(E log V)**, where E is number of edges **E = 4*M*N,** V is number of veritices **V = M*N**"]}
{"id": "1315", "ref_py": ["def maxWidthOfVerticalArea(self, points):\\n        \\n        points.sort(key=lambda p: p[0])  ", "def maxWidthOfVerticalArea(self, points):\\n        s = set()\\n        res = 0\\n        for i in points:\\n            s.add(i[0])\\n        sorted_set = sorted(s)\\n        for i in range(1, len(sorted_set)):\\n            res = max(res, sorted_set[i] - sorted_set[i-1])\\n        return res", "def maxWidthOfVerticalArea(self, points):\\n        s = set()\\n        res = 0\\n        for i in points:\\n            s.add(i[0])\\n        sorted_set = sorted(s)\\n        for i in range(1, len(sorted_set)):\\n            res = max(res, sorted_set[i] - sorted_set[i-1])\\n        return res"]}
{"id": "1316", "ref_py": ["def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result", "def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result", "def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result"]}
{"id": "1317", "ref_py": ["def countVowelStrings(self, n):\\n        a, e, i, o, u = 1, 1, 1, 1, 1", "def countVowelStrings(self, n: int) -> int:        \\n        dp = [[0] * 6 for _ in range(n+1)]\\n        for i in range(1, 6):\\n            dp[1][i] = i\\n        \\n        for i in range(2, n+1):\\n            dp[i][1]=1\\n            for j in range(2, 6):\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\\n        \\n        return dp[n][5]\\n```\\n**Time = O(n)**\\n**Space = O(n)**", "def countVowelStrings(self, n: int) -> int:        \\n        dp = [[0] * 6 for _ in range(n+1)]\\n        for i in range(1, 6):\\n            dp[1][i] = i\\n        \\n        for i in range(2, n+1):\\n            dp[i][1]=1\\n            for j in range(2, 6):\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\\n        \\n        return dp[n][5]\\n```\\n**Time = O(n)**\\n**Space = O(n)**"]}
{"id": "1318", "ref_py": ["def furthestBuilding(self, H: List[int], bricks: int, ladders: int) -> int:\\n    jumps_pq = []\\n    for i in range(len(H) - 1):\\n        jump_height = H[i + 1] - H[i]\\n        if jump_height <= 0: continue\\n        heappush(jumps_pq, jump_height)\\n        if len(jumps_pq) > ladders:\\n            bricks -= heappop(jumps_pq)\\n        if(bricks < 0) : return i\\n    return len(H) - 1\\n```", "defaults to a max order, so we can just invert the sign on the **diff** values before insertion to effectively turn it into a min priority queue instead.", "def furthestBuilding(self, h: List[int], bricks: int, ladders: int) -> int:\\n        heap=[]\\n        heapify(heap)\\n        for i in range(len(h)-1):\\n            d=h[i+1]-h[i]\\n            if d>0:\\n                heappush(heap,d)\\n                if len(heap)>ladders:\\n                    bricks-=heappop(heap)\\n                    if bricks<0:\\n                        return i\\n        return len(h)-1\\n\\t\\t\\n   ```    \\n  \\n           \\n\\t\\t   \\n\\t\\t   \\n\\t\\t   \\n"]}
{"id": "1319", "ref_py": ["def minDeletions(self, s: str) -> int:\\n        freq = [0] * 26 ", "def minDeletions(self, s: str) -> int:\\n        freq = [0] * 26\\n        for char in s:\\n            freq[ord(char) - ord(\\'a\\')] += 1\\n        \\n        hs = set()\\n        count = 0\\n        for i in freq:\\n            while i > 0 and i in hs:\\n                count += 1\\n                i -= 1\\n            hs.add(i)\\n        \\n        return count", "def minDeletions(self, s: str) -> int:\\n        freq = [0] * 26\\n        for char in s:\\n            freq[ord(char) - ord(\\'a\\')] += 1\\n        \\n        hs = set()\\n        count = 0\\n        for i in freq:\\n            while i > 0 and i in hs:\\n                count += 1\\n                i -= 1\\n            hs.add(i)\\n        \\n        return count"]}
{"id": "1320", "ref_py": ["def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n        profit = 0\\n        width = 1\\n        for i in range(len(inventory)-1):\\n            if inventory[i] > inventory[i+1]:\\n                if width * (inventory[i] - inventory[i+1]) < orders:\\n                    profit += width * self.sumRange(inventory[i+1]+1, inventory[i])\\n                    orders -= width * (inventory[i] - inventory[i+1])\\n                else:\\n                    whole, remaining = divmod(orders, width)\\n                    profit += width * self.sumRange(inventory[i]-whole+1, inventory[i])\\n                    profit += remaining * (inventory[i]-whole)\\n                    break\\n            width += 1\\n        return profit % (10**9 + 7)\\n                    \\n        \\ndef sumRange(self, lo, hi):\\n\\t", "def maxProfit(self, inventory: List[int], orders: int) -> int:\\n\\tinventory.sort()\\n\\ti, j = 1, inventory[-1]\\n\\tans = -1\\n\\tdef isValid(v):\\n\\t\\tt = orders\\n\\t\\tm = bisect_left(inventory, v)\\n\\t\\tfor i in range(m, len(inventory)):\\n\\t\\t\\tt -= inventory[i] - v\\n\\t\\t\\tif(t <= 0):\\n\\t\\t\\t\\treturn 1\\n\\t\\tif(t <= len(inventory)-m):\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\twhile(i <= j):\\n\\t\\tmid = i + (j-i) // 2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tans = mid\\n\\t\\t\\ti = mid+1\\n\\t\\telse:\\n\\t\\t\\tj = mid-1\\n\\tif(ans == -1):\\n\\t\\treturn -1\\n\\tans, v = 0, ans\\n\\tfor i in range(len(inventory)):\\n\\t\\tif(inventory[i] > v):\\n\\t\\t\\tans = (ans + ((inventory[i]+1)*inventory[i])//2 - ((v+1)*v)//2) % 1000000007\\n\\t\\t\\torders -= inventory[i] - v\\n\\tif(orders):\\n\\t\\tans = (ans + v * orders) % 1000000007\\n", "def maxProfit(self, inventory: List[int], orders: int) -> int:\\n        inventory.sort(reverse=True) \\n        inventory += [0]\\n        res = 0\\n        k = 1\\n        \\n        for i in range(len(inventory)-1): \\n            if inventory[i] > inventory[i+1]: \\n                if k*(inventory[i]-inventory[i+1]) < orders:\\n                    diff = inventory[i]-inventory[i+1]\\n                    res += k*(inventory[i]+inventory[i+1]+1)*(diff)//2\\n                    orders -= k*diff\\n                else: \\n                    q, r = divmod(orders, k)\\n                    res += k*(inventory[i]+(inventory[i]-q+1))*q//2\\n                    res += r*(inventory[i]-q)\\n                    return res%(10**9+7)\\n            k += 1\\n```"]}
{"id": "1321", "ref_py": ["def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```", "def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```", "def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```"]}
{"id": "1322", "ref_py": ["def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1", "def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1", "def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1"]}
{"id": "1323", "ref_py": ["def closeStrings(self, word1: str, word2: str) -> bool:         ", "def closeStrings(self, word1: str, word2: str) -> bool:         ", "def closeStrings(self, word1: str, word2: str) -> bool:         "]}
{"id": "1324", "ref_py": ["def minOperations(self, nums, targetSum) -> int:\\n        totalSum = sum(nums)\\n        target = totalSum - targetSum  ", "def minOperations(self, nums, x):\\n        \\n        total_sum = sum(nums)\\n        max_length = -1\\n        curr_sum = 0\\n        count_left = 0", "def minOperations(self, nums, targetSum) -> int:\\n        totalSum = sum(nums)\\n        target = totalSum - targetSum  "]}
{"id": "1325", "ref_py": ["def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output", "def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output", "def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output"]}
{"id": "1326", "ref_py": ["def waysToMakeFair(self, nums: List[int]) -> int:", "def waysToMakeFair(self, nums: List[int]) -> int:\\n\\t\\t\\tif len(nums) == 1:\\n\\t\\t\\t\\treturn 1", "def waysToMakeFair(self, nums: List[int]) -> int:"]}
{"id": "1327", "ref_py": ["def minFlipsMonoIncr(self, s: str) -> int:", "def minFlipsMonoIncr(self, s: str) -> int:", "def minFlipsMonoIncr(self, s: str) -> int:"]}
{"id": "1329", "ref_py": ["def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            return maxAns\\n        n=len(arr)\\n        return solve(0)", "def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            ", "def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            "]}
{"id": "1330", "ref_py": ["def minMoves(self, nums, limit):\\n        \\n        punishFromDown = [0] * (2 * limit + 2)\\n        punishFromUp = [0] * (2 * limit + 2)\\n        \\n        for i in xrange(len(nums) / 2):\\n            n1, n2 = nums[i], nums[len(nums) - i - 1]\\n            punishFromDown[n1 + n2 + 1] += 1\\n            punishFromDown[max(n1, n2) + limit + 1] += 1\\n            punishFromUp[n1 + n2 - 1] += 1\\n            punishFromUp[min(n1, n2)] += 1\\n        \\n        for l in xrange(1,  2 * limit + 1):\\n            punishFromDown[l] = punishFromDown[l - 1] + punishFromDown[l]\\n            punishFromUp[2 * limit - l] = punishFromUp[2 * limit - l] + punishFromUp[2 * limit - l + 1]\\n        \\n        best = len(nums)\\n        for l in xrange(1,  2 * limit + 1):\\n            best = min(punishFromDown[l] + punishFromUp[l], best)\\n        return best\\n```", "def solution(nums, limit):\\n\\tn = len(nums)\\n\\tmoves = [0] * (limit*2+1)\\n\\tfor i in range(n//2):\\n\\t\\ta, b = nums[i], nums[-i-1]\\n\\t\\tpairs.append(a+b)\\n\\t\\tfor j in range(2, limit*2+1):\\n\\t\\t\\tif j <= min(a,b):\\n\\t\\t\\t\\tmoves[j] += 2\\n\\t\\t\\telif j <= max(a,b) + limit:\\n\\t\\t\\t\\tmoves[j] += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmoves[j] += 2\\n\\t\\t\\tif j == pairs[-1]:\\n\\t\\t\\t\\tmoves[j] -= 1", "def minMoves(self, nums, limit):\\n        \\n        punishFromDown = [0] * (2 * limit + 2)\\n        punishFromUp = [0] * (2 * limit + 2)\\n        \\n        for i in xrange(len(nums) / 2):\\n            n1, n2 = nums[i], nums[len(nums) - i - 1]\\n            punishFromDown[n1 + n2 + 1] += 1\\n            punishFromDown[max(n1, n2) + limit + 1] += 1\\n            punishFromUp[n1 + n2 - 1] += 1\\n            punishFromUp[min(n1, n2)] += 1\\n        \\n        for l in xrange(1,  2 * limit + 1):\\n            punishFromDown[l] = punishFromDown[l - 1] + punishFromDown[l]\\n            punishFromUp[2 * limit - l] = punishFromUp[2 * limit - l] + punishFromUp[2 * limit - l + 1]\\n        \\n        best = len(nums)\\n        for l in xrange(1,  2 * limit + 1):\\n            best = min(punishFromDown[l] + punishFromUp[l], best)\\n        return best\\n```"]}
{"id": "1331", "ref_py": ["def maxOperations(self, nums: List[int], k: int) -> int:\\n        res, d = 0, Counter(nums)\\n        for val1, cnt in d.items():\\n            val2 = k - val1\\n            ", "def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        left = 0\\n        right = len(nums) - 1\\n        ans = 0\\n        while left < right:\\n            cur = nums[left] + nums[right]\\n            if cur == k:\\n                ans += 1\\n                left += 1\\n                right -= 1\\n            elif cur < k:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return ans\\n```", "def maxOperations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        left = 0\\n        right = len(nums) - 1\\n        ans = 0\\n        while left < right:\\n            cur = nums[left] + nums[right]\\n            if cur == k:\\n                ans += 1\\n                left += 1\\n                right -= 1\\n            elif cur < k:\\n                left += 1\\n            else:\\n                right -= 1\\n        \\n        return ans\\n```"]}
{"id": "1332", "ref_py": ["def concatenatedBinary(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        ", "def concatenatedBinary(self, n: int) -> int:", "def concatenatedBinary(self, n: int) -> int:\\n\\t    mod = 10**9 + 7\\n        digitsToLeftShift = 1                                "]}
{"id": "1333", "ref_py": ["def getSumAbsoluteDifferences(self, nums):\\n        total_sum = sum(nums)\\n        left, right = 0, total_sum\\n        result = []", "def getSumAbsoluteDifferences(self, nums):\\n        total_sum = sum(nums)\\n        left, right = 0, total_sum\\n        result = []", "def getSumAbsoluteDifferences(self, nums):\\n        total_sum = sum(nums)\\n        left, right = 0, total_sum\\n        result = []"]}
{"id": "1334", "ref_py": ["def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:", "def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:", "def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:"]}
{"id": "1335", "ref_py": ["def buddyStrings(self, s, goal):\\n        ind = []", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        c1=Counter(s)\\n        c2=Counter(goal)\\n        if c1!=c2:\\n            return False", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False"]}
{"id": "1336", "ref_py": ["def stoneGameVII(self, S: List[int]) -> int:\\n        N, dp = len(S), [0] * len(S)\\n        for i in range(N - 2, -1, -1):\\n            total = S[i]\\n            for j in range(i + 1, N):\\n                total += S[j]\\n                dp[j] = max(total - S[i] - dp[j], total - S[j] - dp[j-1])\\n        return dp[-1]\\n```", "def stoneGameVII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        \\n        prefix = [0]\\n        for i in stones:\\n            prefix.append(prefix[-1]+i)\\n        \\n        def solve(left, right):\\n            if left == right:\\n                return 0\\n            \\n            leftScore = prefix[right+1] - prefix[left+1] - solve(left+1,right)\\n            rightScore = prefix[right] - prefix[left] - solve(left,right-1)\\n            return max(leftScore,rightScore)\\n        \\n        return solve(0,n-1)\\n```", "def stoneGameVII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        \\n        prefix = [0]\\n        for i in stones:\\n            prefix.append(prefix[-1]+i)\\n        \\n        def solve(left, right):\\n            if left == right:\\n                return 0\\n            \\n            leftScore = prefix[right+1] - prefix[left+1] - solve(left+1,right)\\n            rightScore = prefix[right] - prefix[left] - solve(left,right-1)\\n            return max(leftScore,rightScore)\\n        \\n        return solve(0,n-1)\\n```"]}
{"id": "1337", "ref_py": ["def maximumUniqueSubarray(self, nums: List[int]) -> int:\\n        max_sum = 0\\n        seen = set()\\n        for l in range(len(nums)):\\n            seen.clear()\\n            curr_sum = 0\\n            r = l\\n            while r < len(nums):\\n                if nums[r] in seen:\\n                    break\\n                curr_sum += nums[r]\\n                seen.add(nums[r])\\n                r += 1\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```", "def maximumUniqueSubarray(self, nums: List[int]) -> int:\\n\\tsub_arr, l, cur_sum, ans  = set(), 0, 0, 0\\n\\tfor r in range(len(nums)):\\n\\t\\twhile nums[r] in sub_arr:     ", "def maximumUniqueSubarray(self, nums: List[int]) -> int:\\n\\tsub_arr, l, cur_sum, ans  = set(), 0, 0, 0\\n\\tfor r in range(len(nums)):\\n\\t\\twhile nums[r] in sub_arr:     "]}
{"id": "1338", "ref_py": ["def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        D = [-float(\\'inf\\')] * (n)\\n        \\n\\t\\t", "def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque([n-1])\\n        for i in range(n-2, -1, -1):\\n            if deq[0] - i > k: deq.popleft()\\n            nums[i] += nums[deq[0]]\\n            while len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n            deq.append(i)\\n        return nums[0]\\n```", "def maxResult(self, nums: List[int], k: int) -> int:\\n        dp = deque([(nums[0], 0)])\\n        for i in range(1, len(nums)):\\n            while dp and dp[0][1] + k < i:\\n                dp.popleft()\\n            cost = nums[i] + dp[0][0]\\n            while dp and cost >= dp[-1][0]:\\n                dp.pop()\\n            dp.append((cost, i))\\n        return dp[-1][0]\\n```"]}
{"id": "1339", "ref_py": ["def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        finish_time = -maxsize\\n        total_wait_time = 0", "def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        finish_time = -maxsize\\n        total_wait_time = 0", "def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        finish_time = -maxsize\\n        total_wait_time = 0"]}
{"id": "1340", "ref_py": ["def numSquares(self, n: int) -> int:", "def solve(n):", "def solve(n):"]}
{"id": "1341", "ref_py": ["def eatenApples(self, A: List[int], D: List[int]) -> int:\\n        ans, i, N = 0, 0, len(A)\\n        h = []\\n        while i < N or h:\\n            ", "defined `popFromHeap` that will pop from the heap based on the limit and return the `day`, `num` and new `heap` after poping element. ", "defined `popFromHeap` that will pop from the heap based on the limit and return the `day`, `num` and new `heap` after poping element. "]}
{"id": "1342", "ref_py": ["def countBinarySubstrings(self, s: str) -> int:\\n\\tans, prev, cur = 0, 0, 1\\n\\tfor i in range(1, len(s)):\\n\\t\\tif s[i] != s[i - 1]:\\n\\t\\t\\tans += min(prev, cur)\\n\\t\\t\\tprev = cur\\n\\t\\t\\tcur = 1\\n\\t\\telse:\\n\\t\\t\\tcur += 1\\n\\tans += min(prev, cur)\\n\\treturn ans\\n```\\n  \\n***Time Complexity :*** **`O(N)`**, where *`N`* is the length of given string.\\n***Space  Complexity :*** **`O(1)`**, since only constant space is being used.\\n  \\n---", "define a starting value for **curr** of **1**. Also, since the end of **s** is technically the end of a group, we should add another **min(curr, prev)** onto **ans** before we **return ans**, as it won\\'t be accounted for in the iteration through **s**.", "def countBinarySubstrings(self, s: str) -> int:\\n\\tans, prev, cur = 0, 0, 1\\n\\tfor i in range(1, len(s)):\\n\\t\\tif s[i] != s[i - 1]:\\n\\t\\t\\tans += min(prev, cur)\\n\\t\\t\\tprev = cur\\n\\t\\t\\tcur = 1\\n\\t\\telse:\\n\\t\\t\\tcur += 1\\n\\tans += min(prev, cur)\\n\\treturn ans\\n```\\n  \\n***Time Complexity :*** **`O(N)`**, where *`N`* is the length of given string.\\n***Space  Complexity :*** **`O(1)`**, since only constant space is being used.\\n  \\n---"]}
{"id": "1343", "ref_py": ["def countPairs(self, deliciousness: List[int]) -> int:\\n        pows = [2 ** i for i in range(0,22)] ", "def countPairs(self, deliciousness: List[int]) -> int:\\n        pows = [2 ** i for i in range(0,22)] ", "def countPairs(self, deliciousness: List[int]) -> int:\\n        pows = [2 ** i for i in range(0,22)] "]}
{"id": "1344", "ref_py": ["def waysToSplit(self, nums):\\n        \\n        res = 0\\n        totalSum = sum(nums)        \\n        firstRangeSum = nums[0]\\n        \\n        smallestIndxForEndOfSecond = 1\\n        smallestSecondRangeSum = nums[1]\\n        while True:\\n            if smallestSecondRangeSum >= firstRangeSum:\\n                break\\n            smallestIndxForEndOfSecond += 1\\n            if smallestIndxForEndOfSecond == len(nums) - 1:\\n                return 0\\n            smallestSecondRangeSum += nums[smallestIndxForEndOfSecond]\\n        \\n        biggestIndxForEndOfSecond = len(nums) - 2\\n        biggestSecondRangeSum = totalSum - nums[0] - nums[-1]\\n        while True:\\n            if totalSum - firstRangeSum - biggestSecondRangeSum >= biggestSecondRangeSum:\\n                break\\n            biggestSecondRangeSum -= nums[biggestIndxForEndOfSecond]                \\n            biggestIndxForEndOfSecond -= 1\\n            if biggestIndxForEndOfSecond == 0:\\n                return 0\\n        \\n        \\n        res += ((biggestIndxForEndOfSecond - smallestIndxForEndOfSecond) + 1)\\n        \\n        for firstRangeEnd in xrange(1, len(nums) - 2):\\n            firstRangeSum += nums[firstRangeEnd]\\n            smallestSecondRangeSum -= nums[firstRangeEnd]\\n            while True:\\n                if smallestSecondRangeSum >= firstRangeSum:\\n                    if smallestIndxForEndOfSecond == firstRangeEnd:\\n                        smallestIndxForEndOfSecond += 1\\n                    break\\n                smallestIndxForEndOfSecond += 1                    \\n                if smallestIndxForEndOfSecond == len(nums) - 1:\\n                    return res % (10 ** 9 + 7)\\n                smallestSecondRangeSum += nums[smallestIndxForEndOfSecond] \\n            ", "def waysToSplit(self, nums: List[int]) -> int:\\n        \\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        for i in range(1,n):\\n            nums[i]+=nums[i-1]\\n        \\n        res,j,k = 0,0,0\\n        for i in range(n-2):\\n            if j<=i:\\n                j = i+1\\n            while j<n-1 and nums[i]>nums[j]-nums[i]:\\n                j+=1\\n            \\n\\t\\t\\tif k<j:\\n                k = j\\n            while k<n-1 and nums[k]-nums[i]<=nums[n-1]-nums[k]:\\n                k += 1\\n            res = (res + k - j)%MOD\\n        \\n        return res", "def waysToSplit(self, nums: List[int]) -> int:\\n        \\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        for i in range(1,n):\\n            nums[i]+=nums[i-1]\\n        \\n        res,j,k = 0,0,0\\n        for i in range(n-2):\\n            if j<=i:\\n                j = i+1\\n            while j<n-1 and nums[i]>nums[j]-nums[i]:\\n                j+=1\\n            \\n\\t\\t\\tif k<j:\\n                k = j\\n            while k<n-1 and nums[k]-nums[i]<=nums[n-1]-nums[k]:\\n                k += 1\\n            res = (res + k - j)%MOD\\n        \\n        return res"]}
{"id": "1345", "ref_py": ["def findBestValue(self, arr, target):\\n        \\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value", "def findBestValue(self, arr, target):\\n        \\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value", "def findBestValue(self, arr, target):\\n        \\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value"]}
{"id": "1346", "ref_py": ["def constructDistancedSequence(n):\\n\\tm = 2*n-1\\n\\tA, V = [0] * m, [False] * (n+1)\\n\\tdef dfs(i):\\n\\t\\tif i == m:\\n\\t\\t\\treturn all(A)\\n\\t\\tif A[i]:\\n\\t\\t\\treturn dfs(i+1)\\n\\t\\tfor x in range(n, 0, -1):\\n\\t\\t    j = i if x == 1 else i+x    ", "def dfs(self, arr, p):\\n    if p == len(arr):\\n      return arr", "def constructDistancedSequence(n):\\n\\tm = 2*n-1\\n\\tA, V = [0] * m, [False] * (n+1)\\n\\tdef dfs(i):\\n\\t\\tif i == m:\\n\\t\\t\\treturn all(A)\\n\\t\\tif A[i]:\\n\\t\\t\\treturn dfs(i+1)\\n\\t\\tfor x in range(n, 0, -1):\\n\\t\\t    j = i if x == 1 else i+x    "]}
{"id": "1347", "ref_py": ["def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\\n        sentinal_head = i = j = ListNode(next=head)\\n        \\n        for _ in range(k - 1): j = j.next\\n        k_begin = j\\n        \\n        j = j.next\\n        while j and j.next: i, j = i.next, j.next\\n        k_end = i", "def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n\\tfirst = last = head\\n\\tfor i in range(1, k):\\n\\t\\tfirst = first.next\\n\\t\\t\\n\\tnull_checker = first \\n\\twhile null_checker.next:\\n\\t\\tlast = last.next\\n\\t\\tnull_checker = null_checker.next\\n\\tfirst.val, last.val = last.val, first.val\\n\\treturn head\\n```", "def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n\\tfirst = last = head\\n\\tfor i in range(1, k):\\n\\t\\tfirst = first.next\\n\\t\\t\\n\\tnull_checker = first \\n\\twhile null_checker.next:\\n\\t\\tlast = last.next\\n\\t\\tnull_checker = null_checker.next\\n\\tfirst.val, last.val = last.val, first.val\\n\\treturn head\\n```"]}
{"id": "1348", "ref_py": ["defaultdicts, source_count and target_count, are used to count the occurrences of each element in the respective groups.", "defaultdicts, source_count and target_count, are used to count the occurrences of each element in the respective groups.", "defaultdicts, source_count and target_count, are used to count the occurrences of each element in the respective groups."]}
{"id": "1349", "ref_py": ["def tupleSameProduct(self, nums: List[int]) -> int:\\n        n = len(nums)", "def tupleSameProduct(self, nums: List[int]) -> int:\\n        product_count = collections.defaultdict(int)\\n        n = len(nums)\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                product = nums[i] * nums[j]\\n                product_count[product] += 1\\n        res = 0\\n        for k, v in product_count.items():\\n            if v > 1:\\n                res += (v*(v-1)//2) * (2**3)\\n        return res\\n", "def tupleSameProduct(self, nums: List[int]) -> int:\\n        product_count = collections.defaultdict(int)\\n        n = len(nums)\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                product = nums[i] * nums[j]\\n                product_count[product] += 1\\n        res = 0\\n        for k, v in product_count.items():\\n            if v > 1:\\n                res += (v*(v-1)//2) * (2**3)\\n        return res\\n"]}
{"id": "1350", "ref_py": ["def largestSubmatrix(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                if matrix[i][j] == 1:\\n                    matrix[i][j] += matrix[i - 1][j]\\n        \\n        ans = 0\\n        \\n        for row in matrix:\\n            row.sort(reverse=True)\\n            for j in range(n):\\n                ans = max(ans, row[j] * (j + 1))\\n        \\n        return ans\\n```\\n```javascript []\\nvar largestSubmatrix = function(matrix) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;", "def largestSubmatrix(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                if matrix[i][j] == 1:\\n                    matrix[i][j] += matrix[i - 1][j]\\n        \\n        ans = 0\\n        \\n        for row in matrix:\\n            row.sort(reverse=True)\\n            for j in range(n):\\n                ans = max(ans, row[j] * (j + 1))\\n        \\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/f7634fc6-f30f-4df2-acff-08c3feaca390_1700994016.0912874.jpeg)", "def largestSubmatrix(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                if matrix[i][j] == 1:\\n                    matrix[i][j] += matrix[i - 1][j]\\n        \\n        ans = 0\\n        \\n        for row in matrix:\\n            row.sort(reverse=True)\\n            for j in range(n):\\n                ans = max(ans, row[j] * (j + 1))\\n        \\n        return ans\\n```\\n```javascript []\\nvar largestSubmatrix = function(matrix) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;"]}
{"id": "1351", "ref_py": ["def cantCommunicate(self, user1: int, user2: int, languages: List[Set[int]]) -> bool:\\n        \\'\\'\\'\\n        returns True iff user1 and user2 do not know any languages in common\\n        \\'\\'\\'\\n        return len(languages[user1].intersection(languages[user2])) == 0\\n    \\n    def needToTeach(self, language: int, languages: List[Set[int]], missingConnections: Set[int]) -> int:\\n        \\'\\'\\'\\n        returns number of users that have missing connections and do not know `language`\\n        \\'\\'\\'\\n        return len([user for user in missingConnections if language not in languages[user]])\\n    \\n    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:\\n\\t\\t", "def minimumTeachings(self, n, languages, friendships):\\n        \\n        people_need_lessons = set()        \\n        for friends in friendships:\\n            f1, f2 = friends[0], friends[1]\\n            if len(set(languages[f1 - 1]).intersection(set(languages[f2 - 1]))) == 0:\\n                people_need_lessons.add(f1)\\n                people_need_lessons.add(f2)", "def cantCommunicate(self, user1: int, user2: int, languages: List[Set[int]]) -> bool:\\n        \\'\\'\\'\\n        returns True iff user1 and user2 do not know any languages in common\\n        \\'\\'\\'\\n        return len(languages[user1].intersection(languages[user2])) == 0\\n    \\n    def needToTeach(self, language: int, languages: List[Set[int]], missingConnections: Set[int]) -> int:\\n        \\'\\'\\'\\n        returns number of users that have missing connections and do not know `language`\\n        \\'\\'\\'\\n        return len([user for user in missingConnections if language not in languages[user]])\\n    \\n    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:\\n\\t\\t"]}
{"id": "1352", "ref_py": ["def decode(self, encoded: List[int]) -> List[int]:  ", "def decode(self, encoded: List[int]) -> List[int]:  ", "def decode(self, encoded: List[int]) -> List[int]:  "]}
{"id": "1353", "ref_py": ["def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```", "def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```", "def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```"]}
{"id": "1354", "ref_py": ["def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:", "def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:", "def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:"]}
{"id": "1355", "ref_py": ["def restoreArray(self, adjacentPairs):\\n        ans = []\\n        gr = {}", "def restoreArray(self, adjacentPairs):\\n        ans = []\\n        gr = {}", "def restoreArray(self, adjacentPairs):\\n        ans = []\\n        gr = {}"]}
{"id": "1356", "ref_py": ["def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\\n        A = list(accumulate(candiesCount))\\n        res = []\\n        for type, day, cap in queries:\\n            if type == 0:\\n                res.append(A[0] > day)\\n            else:\\n                to_be_eaten = A[type-1] + 1\\n                res.append(to_be_eaten <= ((day + 1) * cap) and A[type] > day)\\n        return res\\n```", "def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for x in candiesCount: \\n            prefix.append(prefix[-1] + x)\\n        ans = []\\n        for t, d, dc in queries:\\n            pre1, pre2 = prefix[t], prefix[t+1]\\n            ans.append((d + 1) * dc > pre1 and pre2 > d and pre2 > pre1)\\n        return ans\\n```", "def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\\n        A = list(accumulate(candiesCount))\\n        res = []\\n        for type, day, cap in queries:\\n            if type == 0:\\n                res.append(A[0] > day)\\n            else:\\n                to_be_eaten = A[type-1] + 1\\n                res.append(to_be_eaten <= ((day + 1) * cap) and A[type] > day)\\n        return res\\n```"]}
{"id": "1357", "ref_py": ["def maxAbsoluteSum(self, A):", "def maxAbsoluteSum(self, A):", "def maxAbsoluteSum(self, A):"]}
{"id": "1358", "ref_py": ["def minimumLength(self, s: str) -> int:\\n\\tif len(s) <= 1:\\n\\t\\treturn len(s)", "def minimumLength(self, s: str) -> int:\\n        i,j=0,len(s)-1\\n        while i<j and s[i]==s[j]:\\n            t=s[i]\\n            while i<len(s) and s[i]==t:\\n                i+=1\\n            while j>=0 and s[j]==t:\\n                j-=1\\n        if j<i:\\n            return 0\\n        return j-i+1\\n```", "def minimumLength(self, s: str) -> int:\\n\\tif len(s) <= 1:\\n\\t\\treturn len(s)"]}
{"id": "1359", "ref_py": ["def maximumScore(self, a, b, c):\\n        maximum = max(a, b, c)\\n        minimum = min(a, b, c)\\n        middle = a + b + c - maximum - minimum", "def maximumScore(self, a, b, c):\\n        return min((a + b + c) / 2, a + b + c - max(a, b, c))", "def maximumScore(self, a, b, c):\\n        return min((a + b + c) / 2, a + b + c - max(a, b, c))"]}
{"id": "1360", "ref_py": ["def largestMerge(self, word1: str, word2: str) -> str:  \\n                                                        ", "def largestMerge(self, word1: str, word2: str) -> str:\\n        for1,for2=0,0\\n        answer=[]\\n        while for1<len(word1) and for2<len(word2):\\n            ele1,ele2=word1[for1],word2[for2]\\n            if ele1>ele2:\\n                answer.append(ele1)\\n                for1+=1\\n            elif ele1<ele2:\\n                answer.append(ele2)\\n                for2+=1\\n            else:\\n                temp1=word1[for1:]\\n                temp2=word2[for2:]\\n                if temp1>temp2:\\n                    answer.append(ele1)\\n                    for1+=1\\n                else:\\n                    answer.append(ele2)\\n                    for2+=1\\n        while for1<len(word1):\\n            answer.append(word1[for1])\\n            for1+=1\\n        while for2<len(word2):\\n            answer.append(word2[for2])\\n            for2+=1\\n        return \"\".join(answer)", "def largestMerge(self, word1: str, word2: str) -> str:  \\n                                                        "]}
{"id": "1361", "ref_py": ["def countHomogenous(self, s):\\n        res = 0\\n        start = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != s[start]:\\n                appear = i - start\\n                while appear > 0:\\n                    res += appear\\n                    appear -= 1\\n                start = i\\n        \\n        appear = len(s) - start\\n        while appear > 0:\\n            res += appear\\n            appear -= 1\\n        \\n        return int(res % (10**9 + 7))\\n```\\n", "def countHomogenous(self, s: str) -> int:\\n        return sum(\\n            x * (x + 1) >> 1\\n            for _, grp in groupby(s)\\n            for x in [len(list(grp))]\\n        ) % (10**9 + 7)", "def countHomogenous(self, s: str) -> int:\\n        return sum((l:=sum(1 for _ in grp))*(l + 1)//2 for _, grp in groupby(s))%(10**9 + 7)\\n```"]}
{"id": "1362", "ref_py": ["def isGood(self, nums):\\n        if len(nums)==1:\\n            return False\\n        nums.sort()\\n        n = len(nums)\\n        \\n        ", "def isGood(self, nums):\\n        if len(nums)==1:\\n            return False\\n        nums.sort()\\n        n = len(nums)\\n        \\n        ", "def isGood(self, nums):\\n        if len(nums)==1:\\n            return False\\n        nums.sort()\\n        n = len(nums)\\n        \\n        "]}
{"id": "1363", "ref_py": ["def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        ", "def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        ", "def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        "]}
{"id": "1364", "ref_py": ["def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        m,n = len(isWater),len(isWater[0])\\n        q = collections.deque()\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]==1:\\n                    dp[i][j] = 0\\n                    q.append([i,j,0])\\n        \\n        while q:\\n            x,y,c = q.popleft()\\n            for i,j in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                if 0<=x+i<m and 0<=y+j<n and dp[x+i][y+j]==float(\\'inf\\'):\\n                    dp[x+i][y+j] = c+1\\n                    q.append([x+i,y+j,c+1])\\n            \\n        return dp", "def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        ans = [[0] * n for _ in range(m)]\\n        q = deque([(i, j) for i, row in enumerate(isWater) for j, x in enumerate(row) if x == 1])\\n        \\n        while q:\\n            x, y = q.popleft()\\n            for i in range(4):\\n                nx, ny = x + dirs[i], y + dirs[i+1]\\n                if 0 <= nx < m and 0 <= ny < n and isWater[nx][ny] == 0 and ans[nx][ny] == 0:\\n                    ans[nx][ny] = ans[x][y] + 1\\n                    q.append((nx, ny))\\n        return ans\\n```", "def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        ans = [[0] * n for _ in range(m)]\\n        q = deque([(i, j) for i, row in enumerate(isWater) for j, x in enumerate(row) if x == 1])\\n        \\n        while q:\\n            x, y = q.popleft()\\n            for i in range(4):\\n                nx, ny = x + dirs[i], y + dirs[i+1]\\n                if 0 <= nx < m and 0 <= ny < n and isWater[nx][ny] == 0 and ans[nx][ny] == 0:\\n                    ans[nx][ny] = ans[x][y] + 1\\n                    q.append((nx, ny))\\n        return ans\\n```"]}
{"id": "1365", "ref_py": ["def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount ", "def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount ", "def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount "]}
{"id": "1366", "ref_py": ["def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        best_error = float(\"inf\")  ", "def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        best_error = float(\"inf\")  ", "def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        best_error = float(\"inf\")  "]}
{"id": "1367", "ref_py": ["def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n\\t\\t", "def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n\\t\\t", "def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n\\t\\t"]}
{"id": "1368", "ref_py": ["def countKDifference(self, nums: List[int], k: int) -> int:\\n        seen = defaultdict(int)\\n        counter = 0\\n        for num in nums:\\n            tmp, tmp2 = num - k, num + k\\n            if tmp in seen:\\n                counter += seen[tmp]\\n            if tmp2 in seen:\\n                counter += seen[tmp2]\\n            \\n            seen[num] += 1\\n        \\n        return counter\\n```", "def countKDifference(self, nums: List[int], k: int) -> int:\\n        seen = defaultdict(int)\\n        counter = 0\\n        for num in nums:\\n            tmp, tmp2 = num - k, num + k\\n            if tmp in seen:\\n                counter += seen[tmp]\\n            if tmp2 in seen:\\n                counter += seen[tmp2]\\n            \\n            seen[num] += 1\\n        \\n        return counter\\n```", "def countKDifference(self, nums: List[int], k: int) -> int:\\n        seen = defaultdict(int)\\n        counter = 0\\n        for num in nums:\\n            tmp, tmp2 = num - k, num + k\\n            if tmp in seen:\\n                counter += seen[tmp]\\n            if tmp2 in seen:\\n                counter += seen[tmp2]\\n            \\n            seen[num] += 1\\n        \\n        return counter\\n```"]}
{"id": "1369", "ref_py": ["def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)", "def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)", "def isPossible(self, nums: List[int]) -> bool:\\n\\tsubsequence = defaultdict(int)\\n\\tnum_count = Counter(nums)"]}
{"id": "1370", "ref_py": ["def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t", "def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t", "def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t"]}
{"id": "1371", "ref_py": ["def wiggleMaxLength(self, nums: List[int]) -> int:\\n        f = 1\\n        d = 1\\n        for i in range(1, len(nums)):\\n            if nums[i]>nums[i-1]:\\n                f = d+1\\n            elif nums[i] < nums[i-1]:\\n                d = f+1\\n        res = max(f, d)\\n        return res\\n```", "def wiggleMaxLength(self, nums: List[int]) -> int:\\n        peak = valley = 0\\n        for i in range(1, len(nums)):\\n            ", "def wiggleMaxLength(self, nums: List[int]) -> int:\\n        peak = valley = 0\\n        for i in range(1, len(nums)):\\n            "]}
{"id": "1372", "ref_py": ["defined as,", "defined as,", "defined as,"]}
{"id": "1374", "ref_py": ["def minFlipsMonoIncr(self, s: str) -> int:", "def minFlipsMonoIncr(self, s: str) -> int:", "def minFlipsMonoIncr(self, s: str) -> int:"]}
{"id": "1375", "ref_py": ["def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        ", "def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        ", "def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        "]}
{"id": "1376", "ref_py": ["def solve(self, sum, k):\\n        ans = 0\\n        minVal = min(sum, k)\\n        ans = (minVal * (2 * sum - minVal + 1)) // 2\\n        if k > sum:\\n            ans += k - sum\\n        return ans", "def maxValue(self, n: int, index: int, maxSum: int) -> int:\\n        low, high = 1, maxSum\\n        while low <= high:  \\n            mid = (low + high) // 2\\n            if self.helper(mid, index, maxSum, n):\\n                ans = mid \\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n    \\n    def helper(self, val, idx, maxSum, n):\\n        ", "def solve(self, sum, k):\\n        ans = 0\\n        minVal = min(sum, k)\\n        ans = (minVal * (2 * sum - minVal + 1)) // 2\\n        if k > sum:\\n            ans += k - sum\\n        return ans"]}
{"id": "1377", "ref_py": ["def reinitializePermutation(self, n: int) -> int:\\n\\tif n == 2:\\n\\t\\treturn 1\\n\\tmod = n - 1\\n\\tcurr_power = 2\\n\\tcnt = 1\\n\\t", "def reinitializePermutation(self, n: int) -> int:\\n\\tif n == 2:\\n\\t\\treturn 1\\n\\tmod = n - 1\\n\\tcurr_power = 2\\n\\tcnt = 1\\n\\t", "def reinitializePermutation(self, n: int) -> int:\\n\\tif n == 2:\\n\\t\\treturn 1\\n\\tmod = n - 1\\n\\tcurr_power = 2\\n\\tcnt = 1\\n\\t"]}
{"id": "1378", "ref_py": ["def evaluate(self, s: str, knowledge: list[list[str]]) -> str:\\n\\t    ", "def evaluate(self, s: str, knowledge: list[list[str]]) -> str:\\n\\t    ", "def evaluate(self, s: str, knowledge: list[list[str]]) -> str:\\n\\t    "]}
{"id": "1379", "ref_py": ["def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        ", "def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        even_sum = sum(v for v in nums if v % 2 == 0)\\n        res: list[int] = []", "def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        "]}
{"id": "1380", "ref_py": ["defined as a pair of elements whose difference is equal to the difference between the reverse of the two elements. The intuition is to iterate through the array, calculate the temporary number (the difference between the element and its reverse), and maintain a count of occurrences for each temporary number.", "def countNicePairs(self, nums: List[int]) -> int:\\n        nums = [n - int(str(n)[::-1]) for n in nums]\\n        res = 0\\n        for n in Counter(nums).values():\\n            res += n*(n-1)//2 \\n        return res % (10**9 + 7)\\n```\\n```python3 []\\nclass Solution:\\n    def countNicePairs(self, nums: List[int]) -> int:\\n        nums = [n - int(str(n)[::-1]) for n in nums]\\n        return sum(n*(n-1)//2 for v in Counter(nums).values()) % (10**9 + 7)\\n```\\n```python3 []\\nclass Solution:\\n    def countNicePairs(self, nums: List[int]) -> int:\\n        return sum(v*(v-1)//2 for v in Counter(n - int(str(n)[::-1]) for n in nums).values()) % (10**9 + 7)\\n```\\nLike a classic 2 Sum problem, but slower than code above.\\nNew value `k` is making pairs with all the same values k before `d[k]`. Step by step.\\n```python3 []\\nclass Solution:\\n    def countNicePairs(self, nums: List[int]) -> int:\\n        res, d = 0, defaultdict(int)\\n        for i, n in enumerate(nums):\\n            k = n - int(str(n)[::-1])\\n            res += d[k]\\n            d[k] += 1\\n        return res % (10**9 + 7)\\n```\\n![Screenshot 2023-11-21 at 03.33.57.png](https://assets.leetcode.com/users/images/2d47769d-1f89-47b6-9503-8fc446531396_1700527683.4734156.png)", "def countNicePairs(self, nums: List[int]) -> int:\\n        return sum(comb(cnt, 2) for cnt in Counter(num - int(str(num)[::-1]) for num in nums).values())%(10**9 + 7)\\n```"]}
{"id": "1381", "ref_py": ["def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\\n        logs.sort()", "def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\\n        ans = [0] * k\\n        d = {}\\n        for log in logs:\\n            id, min = log\\n            if id not in d:\\n                d[id] = set()\\n            d[id].add(min)", "def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\\n        ans = [0] * k\\n        d = {}\\n        for log in logs:\\n            id, min = log\\n            if id not in d:\\n                d[id] = set()\\n            d[id].add(min)"]}
{"id": "1382", "ref_py": ["def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:        \\n        s1 = sorted(nums1) ", "def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:        \\n        s1 = sorted(nums1) ", "def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:        \\n        s1 = sorted(nums1) "]}
{"id": "1383", "ref_py": ["def findTheWinner(self, n: int, k: int) -> int:\\n        k = k-1\\n        index = 0\\n        li = [i for i in range(1,n+1)]\\n        def cal(k,index):\\n            if len(li) == 1:\\n                return li[0]\\n            index = (index + k)% len(li)\\n            del li[index]\\n            return cal(k,index)\\n        return cal(k,index)", "def findTheWinner(self, n: int, k: int) -> int:\\n        players = [playerNum+1 for playerNum in range(n)] ", "def findTheWinner(self, n: int, k: int) -> int:\\n        players = [playerNum+1 for playerNum in range(n)] "]}
{"id": "1384", "ref_py": ["def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result", "def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result", "def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result"]}
{"id": "1385", "ref_py": ["def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III.", "def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III.", "def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III."]}
{"id": "1386", "ref_py": ["def removeKdigits(self, num: str, k: int) -> str:\\n        stack = []  ", "def removeKdigits(self, num, k):\\n        stack = []\\n        for c in num:\\n            while stack and k>0 and stack[-1] > c:\\n                stack.pop()\\n                k -= 1\\n            stack.append(c)\\n        while stack and k>0:\\n            stack.pop()\\n            k -= 1\\n        if not stack:\\n            return \"0\"\\n        return str(int(\"\".join(stack)))\\n```", "def removeKdigits(self, num: str, k: int) -> str:\\n        stack = []  "]}
{"id": "1387", "ref_py": ["def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i] ", "def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        result=0\\n        costs.sort()\\n        for x,y in enumerate(costs):\\n            if coins<y:\\n                break\\n            result = result + 1\\n            coins = coins - y\\n        return result\\n```", "def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        sum, count = 0, 0\\n        for i in range(len(costs)):\\n            sum = sum + costs[i]\\n            if sum > coins:\\n                return count\\n            else:\\n                count += 1\\n        return count\\n```\\n"]}
{"id": "1388", "ref_py": ["def modifyString(self, s: str) -> str:\\n\\ts = list(s)", "def modifyString(self, s: str) -> str:\\n\\ts = list(s)", "def modifyString(self, s: str) -> str:\\n\\ts = list(s)"]}
{"id": "1389", "ref_py": ["define the subarray. The `right` pointer is advanced to include elements in the current subarray, while the `left` pointer is adjusted to maintain a valid subarray.", "define the subarray. The `right` pointer is advanced to include elements in the current subarray, while the `left` pointer is adjusted to maintain a valid subarray.", "define the subarray. The `right` pointer is advanced to include elements in the current subarray, while the `left` pointer is adjusted to maintain a valid subarray."]}
{"id": "1390", "ref_py": ["def longestBeautifulSubstring(self, word):\\n        \\n        max_length = 0\\n        current = 1\\n        i = 0\\n        while i < len(word):\\n            j = i + 1\\n            while j < len(word) and word[j] >= word[j-1]:\\n                current += 1\\n                j += 1\\n            if len(set(word[i:j])) == 5:\\n                max_length = max(max_length, current)\\n            current = 1\\n            i = j\\n        return max_length", "def longestBeautifulSubstring(self, word):\\n        ", "def longestBeautifulSubstring(self, word: str) -> int:\\n        beautiful_letters = \"aeiou\"\\n        N = len(word)\\n        max_len = 0\\n        i = 0\\n        while i < N:\\n            if word[i] == beautiful_letters[0]:\\n                start = i\\n                for c in beautiful_letters:\\n                    last_word_char = \\'\\'\\n                    if i < N and word[i] == c:\\n                        last_word_char = word[i]\\n                        while i < N and word[i] == c:\\n                            i += 1\\n                    else:\\n                        break\\n                if last_word_char == beautiful_letters[-1]:\\n                    max_len = max(max_len, i - start)\\n            else:\\n                i += 1\\n        \\n        return max_len\\n```"]}
{"id": "1392", "ref_py": ["def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\\n  counts = [0] * len(arr)\\n  for n in arr:\\n    if n < len(arr):\\n      counts[n] += 1\\n    else:\\n      ", "defined that the first element always remains one and array is sorted in ascending manner.\\nAlso the next element cannot be greater than ```1``` more than its previous element.\\nAlso to minimise the number of ```decreasing``` operations we need to keep the element as ```MAX``` as possible.\\n - If element is equal to its predessor -> ```a[i] == a[i-1]```, then no decrement is required.\\n - Else we perform decreament operations, such that ```a[i] == a[i-1] + 1```", "def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\\n  counts = [0] * len(arr)\\n  for n in arr:\\n    if n < len(arr):\\n      counts[n] += 1\\n    else:\\n      "]}
{"id": "1393", "ref_py": ["def splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t", "def splitString(self, s: str) -> bool:", "def splitString(self, s):"]}
{"id": "1394", "ref_py": ["def getMinSwaps(self, orig: str, k: int) -> int:\\n        def nextPermutation(nums):\\n            i = len(nums) - 2", "def getMinSwaps(self, num: str, k: int) -> int:\\n        def next_permutation(nums):\\n            small = len(nums) - 2\\n            while small >= 0 and nums[small] >= nums[small+1]: small -= 1 ", "def getMinSwaps(self, orig: str, k: int) -> int:\\n        def nextPermutation(nums):\\n            i = len(nums) - 2"]}
{"id": "1395", "ref_py": ["def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\\n        i=0\\n        j=0\\n        k=0\\n        while j<len(nums2):\\n            while i<len(nums1) and nums1[i]>nums2[j]:\\n                i+=1\\n            if (i<len(nums1)):\\n                k=max(k,j-i)\\n            j+=1\\n            if i==len(nums1):\\n                break\\n        return k\\n```", "def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j,n,m,res=0,0,len(nums1),len(nums2),0\\n        while i<n and j<m:\\n            if nums1[i]>nums2[j]:\\n                i+=1\\n            else:\\n                res=max(res,j-i)\\n                j+=1\\n        return res\\n```\\n**Runtime:**  1627 ms\\t\\n**Memory Usage:**  31.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\\n        i=0\\n        j=0\\n        k=0\\n        while j<len(nums2):\\n            while i<len(nums1) and nums1[i]>nums2[j]:\\n                i+=1\\n            if (i<len(nums1)):\\n                k=max(k,j-i)\\n            j+=1\\n            if i==len(nums1):\\n                break\\n        return k\\n```"]}
{"id": "1396", "ref_py": ["def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\t\\t\\tn = len(price)\\n\\t\\t\\tcount = [0]*(n+1)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\textra = [0]*(n+1)\\n\\t\\t\\t\\textra[-1] = price[i]  \\n\\t\\t\\t\\textra[i] = 1 \\n\\t\\t\\t\\tspecial.append(extra) ", "def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        memo = {}\\n        \\n        def dp(needs):\\n            if needs in memo:\\n                return memo[needs]\\n            \\n            cost = sum(price[i] * needs[i] for i in range(len(needs)))\\n            \\n            for offer in special:\\n                remain = [needs[i] - offer[i] for i in range(len(needs))]\\n                \\n                if all(x >= 0 for x in remain):\\n                    cost = min(cost, offer[-1] + dp(tuple(remain)))\\n            \\n            memo[needs] = cost\\n            return cost\\n        \\n        return dp(tuple(needs))", "def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\t\\t\\tn = len(price)\\n\\t\\t\\tcount = [0]*(n+1)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\textra = [0]*(n+1)\\n\\t\\t\\t\\textra[-1] = price[i]  \\n\\t\\t\\t\\textra[i] = 1 \\n\\t\\t\\t\\tspecial.append(extra) "]}
{"id": "1397", "ref_py": ["def solve_quadratic(i,x):\\n    return floor( (-i + sqrt(i**2+4*x))/2 )\\n```\\n \\nThe full solution is then:", "def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while max(memory1, memory2) >= i:\\n            if memory1 >= memory2:\\n                memory1 -= i\\n            else:\\n                memory2 -= i\\n            i += 1\\n        return [i, memory1, memory2]\\n```", "def solve_quadratic(i,x):\\n    return floor( (-i + sqrt(i**2+4*x))/2 )\\n```\\n \\nThe full solution is then:"]}
{"id": "1398", "ref_py": ["def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif root:\\n\\t\\troot.left = self.pruneTree(root.left)\\n\\t\\troot.right = self.pruneTree(root.right)\\n\\t\\tif not root.left and not root.right and root.val == 0:\\n\\t\\t\\treturn None\\n\\treturn root\\n```", "def explore_node(self, node):\\n        if node is None:\\n            return None\\n        \\n        node.left = self.explore_node(node.left)\\n        node.right = self.explore_node(node.right)\\n        \\n        if node.left is None and node.right is None and node.val != 1:\\n            node = None\\n        \\n        return node\\n        \\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root = self.explore_node(root)\\n        \\n        return root\\n```", "def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\tif root:\\n\\t\\troot.left = self.pruneTree(root.left)\\n\\t\\troot.right = self.pruneTree(root.right)\\n\\t\\tif not root.left and not root.right and root.val == 0:\\n\\t\\t\\treturn None\\n\\treturn root\\n```"]}
{"id": "1399", "ref_py": ["def minSwaps(self, s: str) -> int:\\n        count = Counter(s)", "def minSwaps(self, s: str) -> int:\\n        nOnes0, nZeros0 = 0, 0\\n        nOnes1, nZeros1 = 0, 0", "def minSwaps(self, s: str) -> int:\\n        count = Counter(s)"]}
{"id": "1401", "ref_py": ["def isPossible(self, dist: List[int], speed: int, hour: float) -> bool:\\n        ans = 0\\n        for i in range(len(dist)):\\n            d = dist[i] * 1.0 / speed\\n            if i != len(dist) - 1:\\n                ans = ans + math.ceil(d)\\n            else:\\n                ans += d\\n            if ans > hour:\\n                return False\\n        return ans <= hour", "def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour < len(dist) - 1:\\n            return -1", "def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\\n        n = len(dist)\\n        if hour <= n - 1: return -1"]}
{"id": "1402", "ref_py": ["def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        ", "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n\\t\\t", "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        "]}
{"id": "1403", "ref_py": ["def minPairSum(self, nums):\\n        nums.sort()\\n        sum = []\\n        for num in range(0,len(nums)):\\n            sum.append(nums[num] + nums[len(nums)-num-1])\\n        sum.sort(reverse = True)\\n        return sum[0]", "def minPairSum(self, nums):\\n        nums.sort()\\n        \\n        min_max_sum = 0\\n        for i in range(len(nums) // 2):\\n            min_max_sum = max(min_max_sum, nums[i] + nums[len(nums) - 1 - i])\\n            \\n        return min_max_sum\\n```", "def minPairSum(self, nums):\\n        nums.sort()\\n        \\n        min_max_sum = 0\\n        for i in range(len(nums) // 2):\\n            min_max_sum = max(min_max_sum, nums[i] + nums[len(nums) - 1 - i])\\n            \\n        return min_max_sum\\n```"]}
{"id": "1404", "ref_py": ["def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calc(l,r,u,d):\\n            sc=0\\n            c1=c2=(l+r)//2\\n            expand=True\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sc+=grid[row][c1]\\n                else:\\n                    sc+=grid[row][c1]+grid[row][c2]\\n                \\n                if c1==l:\\n                    expand=False\\n                \\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sc\\n            \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        heap=[]\\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<=n-1 and d<=m-1:\\n                    sc=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if len(heap)<3:\\n                        if sc not in heap:\\n                            heapq.heappush(heap,sc)\\n                    else:\\n                        if sc not in heap and sc>heap[0]:\\n                            heapq.heappop(heap)\\n                            heapq.heappush(heap,sc)\\n        \\n        heap.sort(reverse=True)\\n        return heap", "def getBiggestThree(self, A: List[List[int]]) -> List[int]:\\n        N, M = len(A), len(A[0])\\n        h = []\\n        LH = 3\\n        def add(x):\\n            if x not in h:\\n                if len(h) >= LH:\\n                    x = max(x, heappop(h))\\n                heappush(h,x)\\n        \\n        def check(i,j):\\n            r = 0\\n            add(A[i][j])\\n            r += 1\\n            while i - r >= 0 and i + r < N and j - r >= 0 and j +r < M:\\n                s = 0\\n                ", "def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calc(l,r,u,d):\\n            sc=0\\n            c1=c2=(l+r)//2\\n            expand=True\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sc+=grid[row][c1]\\n                else:\\n                    sc+=grid[row][c1]+grid[row][c2]\\n                \\n                if c1==l:\\n                    expand=False\\n                \\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sc\\n            \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        heap=[]\\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<=n-1 and d<=m-1:\\n                    sc=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if len(heap)<3:\\n                        if sc not in heap:\\n                            heapq.heappush(heap,sc)\\n                    else:\\n                        if sc not in heap and sc>heap[0]:\\n                            heapq.heappop(heap)\\n                            heapq.heappush(heap,sc)\\n        \\n        heap.sort(reverse=True)\\n        return heap"]}
{"id": "1405", "ref_py": ["def maxValue(self, n: str, x: int) -> str:\\n        x = str(x)", "def maxValue(self, n: str, x: int) -> str:\\n        x = str(x)", "def maxValue(self, n: str, x: int) -> str:\\n        x = str(x)"]}
{"id": "1406", "ref_py": ["def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        ", "def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        ", "def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        "]}
{"id": "1407", "ref_py": ["def twoEggDrop(self, n: int) -> int:\\n        ", "def twoEggDrop(self, n: int) -> int:\\n        dp = [[0,0] for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = i\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                if dp[i][1] == 0:\\n                    dp[i][1] = max(dp[j-1][0], dp[i-j][1]) + 1\\n                else:\\n                    dp[i][1] = min(dp[i][1], max(dp[j-1][0], dp[i-j][1]) + 1)\\n        return dp[n][1]\\n```\\nac, tc is ```O(n^2)```, sc is ```O(N)```\\n```\\nclass Solution:\\n    def twoEggDrop(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                if dp[i] == 0:\\n                    dp[i] = max(j-1, dp[i-j]) + 1\\n                else:\\n                    dp[i] = min(dp[i], max(j-1, dp[i-j]) + 1)\\n        return dp[n]   \\n```\\n", "def twoEggDrop(self, n: int) -> int:\\n        "]}
{"id": "1408", "ref_py": ["def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True", "def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n", "def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)"]}
{"id": "1409", "ref_py": ["def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"\\n        prefix = strs[0]\\n        for string in strs[1:]:\\n            while string.find(prefix) != 0:\\n                prefix = prefix[:-1]\\n                if not prefix:\\n                    return \"\"\\n        return prefix\\n```", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"  "]}
{"id": "1410", "ref_py": ["def chalkReplacer(self, chalk: List[int], k: int) -> int:\\n        i = 0\\n        n = len(chalk)\\n        \\n        while chalk[i] <= k:\\n            k -= chalk[i]\\n            i += 1\\n            if i == n: i = 0\\n                \\n        return i\\n\\t\\t\\n\\t\\t\\n", "def chalkReplacer(self, chalk: List[int], k: int) -> int:\\n        i = 0\\n        n = len(chalk)\\n        \\n        while chalk[i] <= k:\\n            k -= chalk[i]\\n            i += 1\\n            if i == n: i = 0\\n                \\n        return i\\n\\t\\t\\n\\t\\t\\n", "def chalkReplacer(self, chalk: List[int], k: int) -> int:\\n        i = 0\\n        n = len(chalk)\\n        \\n        while chalk[i] <= k:\\n            k -= chalk[i]\\n            i += 1\\n            if i == n: i = 0\\n                \\n        return i\\n\\t\\t\\n\\t\\t\\n"]}
{"id": "1411", "ref_py": ["def isMagicSquare(i, j, length):\\n            ", "def isMagicSquare(i, j, length):\\n            ", "def isMagicSquare(i, j, length):\\n            "]}
{"id": "1412", "ref_py": ["def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\\n        l, r = 0, len(removable)", "def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\\n        left, right = 0, len(removable)\\n        \\n        def can_remove(k):\\n            remove_indexes = set(removable[:k])\\n            si, pi = 0, 0\\n            while si<len(s) and pi<len(p):\\n                if si in remove_indexes:\\n                    si += 1\\n                    continue\\n                if s[si] == p[pi]:\\n                    si += 1\\n                    pi += 1\\n                else:\\n                    si += 1\\n            return pi == len(p)\\n        \\n        while left < right:\\n            mid = ((right-left+1)//2) + left\\n            if can_remove(mid):\\n                left = mid\\n            else:\\n                right = mid-1\\n        \\n        return left\\n```\\n", "def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\\n        \\n        def check(m):\\n            i = j = 0\\n            remove = set(removable[:m+1])\\n            while i < len(s) and j < len(p):\\n                if i in remove:\\n                    i += 1\\n                    continue\\n                if s[i] == p[j]:\\n                    i += 1\\n                    j += 1\\n                else:\\n                    i += 1\\n            \\n            return j == len(p)\\n            \\n                \\n        "]}
{"id": "1413", "ref_py": ["def longestMountain(self, arr: List[int]) -> int:\\n        \\n        @cache\\n        def get_left(i):\\n            if i - 1 >= 0 and arr[i - 1] < arr[i]:\\n                return get_left(i - 1) + 1\\n            return 0", "def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```", "def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```"]}
{"id": "1414", "ref_py": ["definately \\n            // greater than top and bottom. so we need to check only left and right i.e. our problem is reduced to find peak in 1d", "def maxEl(self, mat, n, m, col):\\n        maxi = -1\\n        ind = -1\\n        for i in range(n):\\n            if mat[i][col] > maxi:\\n                maxi = mat[i][col]\\n                ind = i\\n        return ind", "def maxEl(self, mat, n, m, col):\\n        maxi = -1\\n        ind = -1\\n        for i in range(n):\\n            if mat[i][col] > maxi:\\n                maxi = mat[i][col]\\n                ind = i\\n        return ind"]}
{"id": "1415", "ref_py": ["def numberOfRounds(self, startTime: str, finishTime: str) -> int:", "def numberOfRounds(self, startTime: str, finishTime: str) -> int:", "def numberOfRounds(self, startTime: str, finishTime: str) -> int:"]}
{"id": "1416", "ref_py": ["def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        m=len(grid1)\\n        n=len(grid1[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\\n                return\\n            \\n            grid2[i][j]=0\\n            dfs(i+1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n            dfs(i-1,j)\\n            \\n        ", "def countSubIslands(self, B: List[List[int]], A: List[List[int]]) -> int:\\n\\t\\t\\tn, m = len(A), len(A[0])", "def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n\\t\\t\\tm, n = len(grid1), len(grid1[0])"]}
{"id": "1417", "ref_py": ["def largestAltitude(self, gain: List[int]) -> int:\\n        highest_point = 0\\n        prev_altitude = 0\\n        for i in gain:\\n            prev_altitude += i\\n            highest_point = max(highest_point, prev_altitude)", "def largestAltitude(self, gain):\\n        sol = 0\\n        curHeight = 0", "def largestAltitude(self, gain: List[int]) -> int:\\n        highest_point = 0\\n        prev_altitude = 0\\n        for i in gain:\\n            prev_altitude += i\\n            highest_point = max(highest_point, prev_altitude)"]}
{"id": "1419", "ref_py": ["def removeOccurrences(self, s, part):\\n        while part in s:\\n            s = s.replace(part, \\'\\', 1)\\n        return s\\n```\\n```javascript []\\nvar removeOccurrences = function(s, part) {\\n    let idx = s.indexOf(part);\\n    while (idx !== -1) {\\n        s = s.substring(0, idx) + s.substring(idx + part.length);\\n        idx = s.indexOf(part);\\n    }\\n    return s;\\n};\\n```", "def removeOccurrences(self, s, part):\\n        while part in s:\\n            s = s.replace(part, \\'\\', 1)\\n        return s\\n```\\n```javascript []\\nvar removeOccurrences = function(s, part) {\\n    let idx = s.indexOf(part);\\n    while (idx !== -1) {\\n        s = s.substring(0, idx) + s.substring(idx + part.length);\\n        idx = s.indexOf(part);\\n    }\\n    return s;\\n};\\n```", "def removeOccurrences(self, s, part):\\n        while part in s:\\n            s = s.replace(part, \\'\\', 1)\\n        return s\\n```\\n```javascript []\\nvar removeOccurrences = function(s, part) {\\n    let idx = s.indexOf(part);\\n    while (idx !== -1) {\\n        s = s.substring(0, idx) + s.substring(idx + part.length);\\n        idx = s.indexOf(part);\\n    }\\n    return s;\\n};\\n```"]}
{"id": "1420", "ref_py": ["define `dp[0][0]` as `nums[0]` as the index is both `0`. We also need to pre-define `dp[0][1]` as `0` since we have to start by adding given the question, thus we put 0.", "def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        ", "def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        "]}
{"id": "1421", "ref_py": ["def rotateGrid(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        top = 0\\n        bottom = len(mat)-1\\n        left = 0\\n        right = len(mat[0])-1\\n        res = []\\n\\t\\t\\n        ", "def rotateGrid(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        top = 0\\n        bottom = len(mat)-1\\n        left = 0\\n        right = len(mat[0])-1\\n        res = []\\n\\t\\t\\n        ", "def rotateGrid(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        top = 0\\n        bottom = len(mat)-1\\n        left = 0\\n        right = len(mat[0])-1\\n        res = []\\n\\t\\t\\n        "]}
{"id": "1422", "ref_py": ["def numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```", "def numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```", "def numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```"]}
{"id": "1423", "ref_py": ["def eliminateMaximum(self, dist, speed):\\n        n = len(dist)\\n        time = [float(d) / s for d, s in zip(dist, speed)]\\n        time.sort()\\n        \\n        curr = 0\\n        for i in range(n):\\n            if time[i] <= i:\\n                break\\n            curr += 1\\n        \\n        return curr", "def eliminateMaximum(self, dist, speed):\\n        n = len(dist)\\n        time = [float(d) / s for d, s in zip(dist, speed)]\\n        time.sort()\\n        \\n        curr = 0\\n        for i in range(n):\\n            if time[i] <= i:\\n                break\\n            curr += 1\\n        \\n        return curr", "def eliminateMaximum(self, dist, speed):\\n        n = len(dist)\\n        time = [float(d) / s for d, s in zip(dist, speed)]\\n        time.sort()\\n        \\n        curr = 0\\n        for i in range(n):\\n            if time[i] <= i:\\n                break\\n            curr += 1\\n        \\n        return curr"]}
{"id": "1424", "ref_py": ["def countGoodNumbers(self, n: int) -> int:\\n        ans = 1\\n        rem = n % 2\\n        n -= rem\\n        ans = pow(20, n//2, 10**9 + 7)\\n        if rem == 1:\\n            ans *= 5\\n        return ans % (10**9 + 7)\\n```\\n**Note:** It can be solved in constant time, by using math.pow funtion.", "def countGoodNumbers(self, n: int) -> int:\\n        mod = 1000000007\\n        odd = n//2\\n        even = n//2 + n%2\\n        return (self.binaryExp(5, even)%mod *self.binaryExp(4, odd)%mod)%mod\\n    \\n    def binaryExp(self, x, n):\\n        mod = 1000000007\\n        if n==0:\\n            return 1\\n        if n < 0:\\n            return 1/self.binaryExp(x, -n)\\n        \\n        if n%2==0:\\n            return self.binaryExp((x*x)%mod, n//2)\\n        else:\\n            return x * self.binaryExp((x*x)%mod, (n-1)//2)\\n        ", "def countGoodNumbers(self, n: int) -> int:\\n        ans = 1\\n        rem = n % 2\\n        n -= rem\\n        ans = pow(20, n//2, 10**9 + 7)\\n        if rem == 1:\\n            ans *= 5\\n        return ans % (10**9 + 7)\\n```\\n**Note:** It can be solved in constant time, by using math.pow funtion."]}
{"id": "1425", "ref_py": ["def nearestExit(self, maze, entrance):", "def nearestExit(self, maze: List[List[str]], entr: List[int]) -> int:\\n        rows, cols = len(maze), len(maze[0])\\n        deq = deque()\\n        deq.append([entr[0], entr[1], -1])\\n        \\n        while deq:\\n            r, c, dist = deq.popleft()\\n            if not (0 <= r < rows and 0 <= c < cols):\\n                if dist > 0:\\n                    return dist\\n                continue\\n            if maze[r][c] == \\'+\\':\\n                continue\\n            \\n            maze[r][c] = \\'+\\'\\n            for _r, _c in ((0, 1), (0, -1), (1, 0), (-1, 0)):\\n                deq.append([r + _r, c + _c, dist + 1])\\n        \\n        return -1\\n```", "def nearestExit(self, maze: List[List[str]], entr: List[int]) -> int:\\n        rows, cols = len(maze), len(maze[0])\\n        deq = deque()\\n        deq.append([entr[0], entr[1], -1])\\n        \\n        while deq:\\n            r, c, dist = deq.popleft()\\n            if not (0 <= r < rows and 0 <= c < cols):\\n                if dist > 0:\\n                    return dist\\n                continue\\n            if maze[r][c] == \\'+\\':\\n                continue\\n            \\n            maze[r][c] = \\'+\\'\\n            for _r, _c in ((0, 1), (0, -1), (1, 0), (-1, 0)):\\n                deq.append([r + _r, c + _c, dist + 1])\\n        \\n        return -1\\n```"]}
{"id": "1426", "ref_py": ["def sumGame(self, num: str) -> bool:\\n  n = len(num)\\n  ", "def sumGame(self, num: str) -> bool:\\n  n = len(num)\\n  ", "def sumGame(self, num: str) -> bool:\\n  n = len(num)\\n  "]}
{"id": "1427", "ref_py": ["def countPalindromicSubsequence(self, s):\\n        c = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        a, t = 0, 0", "def countPalindromicSubsequence(self, s):\\n        res = 0", "def countPalindromicSubsequence(self, s):\\n        c = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        a, t = 0, 0"]}
{"id": "1429", "ref_py": ["def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)", "def postorder(self, node, post):\\n        if node is None:\\n            return\\n        \\n        self.postorder(node.left, post)\\n        self.postorder(node.right, post)\\n        post.append(node.val)"]}
{"id": "1430", "ref_py": ["def maxPoints(self, points: List[List[int]]) -> int:\\n        rows, cols = len(points), len(points[0])", "def maxPoints(self, points: List[List[int]]) -> int:\\n        rows, cols = len(points), len(points[0])", "def maxPoints(self, points: List[List[int]]) -> int:\\n        rows, cols = len(points), len(points[0])"]}
{"id": "1431", "ref_py": ["def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]", "def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]", "def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]"]}
{"id": "1432", "ref_py": ["def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:\\n        \\n        dic = defaultdict(int)\\n        for s,e,c in segments:\\n            dic[s]+=c\\n            dic[e]-=c\\n        \\n        st=None\\n        color=0\\n        res = []\\n        for p in sorted(dic):\\n            if st is not None and color!=0:\\n                res.append([st,p,color])\\n            color+=dic[p]\\n            st = p\\n        \\n        return res", "def splitPainting(self, segments):\\n        \\n        mixed = [[] for _ in range(10**5)]\\n        for a, b, c in segments:\\n            mixed[a-1].append(c)\\n            mixed[b-1].append(-c)\\n        cur, beg, output = 0, 0, []\\n        for i in range(10**5):\\n            if mixed[i]:\\n                output.append([beg, i+1, cur])\\n                beg = i+1\\n                cur += sum(mixed[i])\\n        return [tmp for tmp in output if tmp[2] != 0 ]", "def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:\\n        line = defaultdict(int)\\n        \\n        for start, end, color in segments:\\n            line[start] += color\\n            line[end] -= color\\n            \\n        painting = []\\n        prev_color, prev_point = 0, 0\\n        \\n        for point in sorted(line.keys()):\\n            if prev_color:\\n                painting.append([prev_point, point, prev_color])\\n            prev_point = point\\n            prev_color += line[point]\\n        \\n        return painting\\n```"]}
{"id": "1433", "ref_py": ["def maximumNumber(self, num: str, change: List[int]) -> str:\\n\\t\\t\\tlis = [int(i) for i in num]\\n\\t\\t\\tflag=True\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\tif lis[i]==change[int(lis[i])]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif lis[i]<change[int(lis[i])]:\\n\\t\\t\\t\\t\\tlis[i]=change[int(lis[i])]\\n\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif not flag:\\n\\t\\t\\t\\t\\t\\treturn \"\".join(map(str,lis))\\n", "def maximumNumber(self, num: str, change: List[int]) -> str:\\n        flag=0\\n        ls=list(num)\\n        for i in range(len(ls)):\\n            k=int(ls[i])\\n            if change[k]>k:\\n                ls[i]=str(change[k])\\n                flag=1\\n            elif flag==1 and change[k]<k:\\n                break\\n        \\n        return \"\".join(ls)", "def maximumNumber(self, num: str, change: List[int]) -> str:\\n\\t\\t\\tlis = [int(i) for i in num]\\n\\t\\t\\tflag=True\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\tif lis[i]==change[int(lis[i])]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telif lis[i]<change[int(lis[i])]:\\n\\t\\t\\t\\t\\tlis[i]=change[int(lis[i])]\\n\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif not flag:\\n\\t\\t\\t\\t\\t\\treturn \"\".join(map(str,lis))\\n"]}
{"id": "1434", "ref_py": ["defaultdict", "def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans = 0\\n        for perm in itertools.permutations(range(len(students))):\\n            cur = 0\\n            for i in range(len(students)):\\n                for j in range(len(students[0])):\\n                    cur += 1 if students[i][j] == mentors[perm[i]][j] else 0\\n            ans = max(ans, cur)\\n        return ans\\n```", "def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        backtrack = []\\n        ans = 0\\n        scores = [[0] * len(students) for _ in range(len(students))]\\n        for i, vec_i in enumerate(students):\\n            for j, vec_j in enumerate(mentors):\\n                scores[i][j] = sum(x == y for x, y in zip(vec_i, vec_j))\\n        def dfs(used_st):\\n            if len(backtrack) == len(students):\\n                nonlocal ans\\n                ans = max(ans, sum(scores[backtrack[i]][i] for i in range(len(students))))\\n                return\\n            \\n            for i in range(len(students)):\\n                if used_st >> i & 1: continue\\n                backtrack.append(i)\\n                dfs(used_st | (1 << i))\\n                backtrack.pop()\\n        dfs(0)\\n        return ans\\n```"]}
{"id": "1435", "ref_py": ["def numberOfWeeks(self, l: List[int]) -> int:\\n        l.sort(reverse=True)\\n        s=sum(l)-l[0]\\n        if s<l[0]:\\n            return min(s,l[0])*2 + 1\\n        return s+l[0]\\n```", "def numberOfWeeks(self, l: List[int]) -> int:\\n        l.sort(reverse=True)\\n        s=sum(l)-l[0]\\n        if s<l[0]:\\n            return min(s,l[0])*2 + 1\\n        return s+l[0]\\n```", "def numberOfWeeks(self, l: List[int]) -> int:\\n        l.sort(reverse=True)\\n        s=sum(l)-l[0]\\n        if s<l[0]:\\n            return min(s,l[0])*2 + 1\\n        return s+l[0]\\n```"]}
{"id": "1436", "ref_py": ["defines the square plot of land centered at `(0,0)` with perimeter `8*m`\\n`n` = number of apples on all trees at level `m` (on the perimeter)\\n`N` = number of apples contained within the square plot of land at level `m`", "def minimumPerimeter(self, nap: int) -> int:\\n        \\n        \\n", "def minimumPerimeter(self, neededApples: int) -> int:\\n        i, summ, curr = 0, 0, 0\\n        while True:\\n            curr = 3*i+(2*i-1)*2*i - i*(i+1)\\n            summ += 4*curr\\n            if summ >= neededApples:\\n                return i*4*2\\n            i+=1"]}
{"id": "1437", "ref_py": ["def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\\n        \\n        inverted_color = \\'B\\' if color == \\'W\\' else \\'W\\'\\n        for dr,dc in (1,0),(0,1),(-1,0),(0,-1),(-1,-1),(-1,1),(1,-1),(1,1):\\n            nr = rMove + dr ", "def checkMove(self, board, rMove, cMove, color):\\n        ", "def checkMove(self, board, rMove, cMove, color):\\n        \\n        "]}
{"id": "1438", "ref_py": ["def minSpaceWastedKResizing(self, A: List[int], K: int) -> int:\\n        def waste(i, j, h):\\n            sumI = sums[i-1] if i > 0 else 0\\n            return (j-i+1)*h - sums[j] + sumI\\n        \\n        def dp(i, k):\\n            if i <= k:\\n                return 0\\n            if k < 0:\\n                return MAX\\n            if (i, k) in memoize:\\n                return memoize[(i, k)]\\n            \\n            _max = A[i]\\n            r = MAX\\n            for j in range(i-1, -2, -1):\\n                r = min(r, dp(j, k-1) + waste(j+1, i,  _max))\\n                _max = max(_max, A[j])", "def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\\n\\t\\t\\t\\n\\t\\t\\tMAX = 200e6\\n\\t\\t\\t\\n\\t\\t\\t", "def minSpaceWastedKResizing(self, A: List[int], K: int) -> int:\\n        def waste(i, j, h):\\n            sumI = sums[i-1] if i > 0 else 0\\n            return (j-i+1)*h - sums[j] + sumI\\n        \\n        def dp(i, k):\\n            if i <= k:\\n                return 0\\n            if k < 0:\\n                return MAX\\n            if (i, k) in memoize:\\n                return memoize[(i, k)]\\n            \\n            _max = A[i]\\n            r = MAX\\n            for j in range(i-1, -2, -1):\\n                r = min(r, dp(j, k-1) + waste(j+1, i,  _max))\\n                _max = max(_max, A[j])"]}
{"id": "1439", "ref_py": ["def evalRPN(self, tokens: List[str]) -> int:\\n        s=[]\\n        for i in tokens:\\n            if i not in {\"+\",\"-\",\"/\",\"*\"}:\\n                s.append(int(i))\\n            else:\\n                b,a=s.pop(),s.pop()\\n                if i==\"+\":s.append(a+b)\\n                elif i==\"-\":s.append(a-b)\\n                elif i==\"*\":s.append(a*b)\\n                else: s.append(trunc(a/b))\\n        return s[0]\\n        \\n```\\n**Runtime:**  151 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def evalRPN(self, tokens: List[str]) -> int:\\n        s=[]\\n        for i in tokens:\\n            if i not in {\"+\",\"-\",\"/\",\"*\"}:\\n                s.append(int(i))\\n            else:\\n                b,a=s.pop(),s.pop()\\n                if i==\"+\":s.append(a+b)\\n                elif i==\"-\":s.append(a-b)\\n                elif i==\"*\":s.append(a*b)\\n                else: s.append(trunc(a/b))\\n        return s[0]\\n        \\n```\\n**Runtime:**  151 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def evalRPN(self, tokens: List[str]) -> int:\\n        s=[]\\n        for i in tokens:\\n            if i not in {\"+\",\"-\",\"/\",\"*\"}:\\n                s.append(int(i))\\n            else:\\n                b,a=s.pop(),s.pop()\\n                if i==\"+\":s.append(a+b)\\n                elif i==\"-\":s.append(a-b)\\n                elif i==\"*\":s.append(a*b)\\n                else: s.append(trunc(a/b))\\n        return s[0]\\n        \\n```\\n**Runtime:**  151 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "1440", "ref_py": ["def minSwaps(self, s: str) -> int:\\n        count = 0\\n        for i in s:\\n            if i == \"[\":\\n                count += 1  ", "def minSwaps(self, s):\\n        \\n        open = 0\\n        ans = 0\\n        for c in s:\\n            if c == \\']\\':\\n                if open:  \\n                    open-=1\\n                else:\\n                    ans+=1\\n                    open+=1\\n            else:\\n                 open+=1\\n        return ans\\n```", "def minSwaps(self, s: str) -> int:\\n        count = 0\\n        for i in s:\\n            if i == \"[\":\\n                count += 1  "]}
{"id": "1441", "ref_py": ["def compress(self, chars: list[str]) -> int:\\n        iter_len = lambda xs: sum(1 for _ in xs)\\n        \\n        ch_counts = ((ch, iter_len(g)) for ch, g in groupby(chars))\\n        compressed = chain.from_iterable(ch + str(n) if n > 1 else ch for ch, n in ch_counts)", "def compress(self, chars):\\n        n = len(chars)\\n        if n == 1:\\n            return 1\\n        \\n        write_idx = 0\\n        curr_idx = 0\\n        while curr_idx < n:\\n            curr_char = chars[curr_idx]\\n            cnt = 0\\n            while curr_idx < n and chars[curr_idx] == curr_char:\\n                curr_idx += 1\\n                cnt += 1\\n            chars[write_idx] = curr_char\\n            write_idx += 1\\n            if cnt > 1:\\n                cnt_str = str(cnt)\\n                for i in range(len(cnt_str)):\\n                    chars[write_idx] = cnt_str[i]\\n                    write_idx += 1\\n        \\n        return write_idx", "def compress(self, chars: list[str]) -> int:\\n        iter_len = lambda xs: sum(1 for _ in xs)\\n        \\n        ch_counts = ((ch, iter_len(g)) for ch, g in groupby(chars))\\n        compressed = chain.from_iterable(ch + str(n) if n > 1 else ch for ch, n in ch_counts)"]}
{"id": "1442", "ref_py": ["def minNonZeroProduct(self, p: int) -> int:\\n        mod = 10**9+7\\n        return (pow(2**p-2,2**(p-1)-1,mod)*(2**p-1))%mod\\n```", "def minNonZeroProduct(self, p):\\n        \\n        maximum=(2**p)-1\\n        mid=maximum//2\\n        mod=(10**9)+7\\n        res=pow(maximum-1,mid,mod)*maximum %mod\\n        return res", "def minNonZeroProduct(self, p):\\n        \\n        maximum=(2**p)-1\\n        mid=maximum//2\\n        mod=(10**9)+7\\n        res=pow(maximum-1,mid,mod)*maximum %mod\\n        return res"]}
{"id": "1443", "ref_py": ["def isPalindrome(self, head: ListNode) -> bool:\\n        slow, fast, prev = head, head, None\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n        prev, slow, prev.next = slow, slow.next, None\\n        while slow:\\n            slow.next, prev, slow = prev, slow, slow.next\\n        fast, slow = head, prev\\n        while slow:\\n            if fast.val != slow.val: return False\\n            fast, slow = fast.next, slow.next\\n        return True\\n```", "def isPalindrome(self, head):\\n        rev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            rev, rev.next, slow = slow, rev, slow.next\\n        if fast:\\n            slow = slow.next\\n        while rev and rev.val == slow.val:\\n            slow = slow.next\\n            rev = rev.next\\n        return not rev", "def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        global front\\n        front = head"]}
{"id": "1444", "ref_py": ["def countPaths(self, n: int, roads: List[List[int]]) -> int:", "def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for i in range(n)]\\n        for u,v,t in roads:\\n            adj[u].append((v,t))\\n            adj[v].append((u,t))\\n        dist=[float(\\'inf\\')]*n\\n        ways=[0]*n\\n        ways[0]=1\\n        dist[0]=0\\n        pq=[]\\n        heapify(pq)\\n        heappush(pq,(0,0))\\n        mod=10**9+7\\n        while pq:\\n            time,node=heappop(pq)\\n            for v,t in adj[node]:\\n                if dist[v]>t+time:\\n                    dist[v]=t+time\\n                    heappush(pq,(dist[v],v))\\n                    ways[v]=ways[node]\\n                elif dist[v]==t+time:\\n                    ways[v]=(ways[v]+ways[node])%mod\\n        return ways[n-1]%mod\\n```", "def countPaths(self, n: int, roads: List[List[int]]) -> int:"]}
{"id": "1445", "ref_py": ["def findDifferentBinaryString(self, nums):\\n        result = \"\"", "def findDifferentBinaryString(self, nums: List[str]) -> str:\\n        size = len(nums)  ", "def findDifferentBinaryString(self, nums):\\n        result = \"\""]}
{"id": "1446", "ref_py": ["def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\tm = len(mat)\\n\\tfor i in range(m):\\n\\t\\tmat[i].sort()\\n\\tq = set([0])\\n\\tfor i in range(m):\\n\\t\\ttemp = set()\\n\\t\\tfor num1 in q:\\n\\t\\t\\tfor num2 in mat[i]:\\n\\t\\t\\t\\ttemp.add(num1+num2)\\n\\t\\t\\t\\tif(num1+num2 > target):\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tq = temp\\n\\tq = sorted(list(q))\\n\\ti = bisect_right(q, target)\\n\\tif(i == len(q)):\\n\\t\\treturn target - q[-1]\\n\\tif(i == 0):\\n\\t\\treturn q[0] - target\\n", "def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\tm = len(mat)\\n\\tfor i in range(m):\\n\\t\\tmat[i].sort()\\n\\tq = set([0])\\n\\tfor i in range(m):\\n\\t\\ttemp = set()\\n\\t\\tfor num1 in q:\\n\\t\\t\\tfor num2 in mat[i]:\\n\\t\\t\\t\\ttemp.add(num1+num2)\\n\\t\\t\\t\\tif(num1+num2 > target):\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tq = temp\\n\\tq = sorted(list(q))\\n\\ti = bisect_right(q, target)\\n\\tif(i == len(q)):\\n\\t\\treturn target - q[-1]\\n\\tif(i == 0):\\n\\t\\treturn q[0] - target\\n", "def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\tm = len(mat)\\n\\tfor i in range(m):\\n\\t\\tmat[i].sort()\\n\\tq = set([0])\\n\\tfor i in range(m):\\n\\t\\ttemp = set()\\n\\t\\tfor num1 in q:\\n\\t\\t\\tfor num2 in mat[i]:\\n\\t\\t\\t\\ttemp.add(num1+num2)\\n\\t\\t\\t\\tif(num1+num2 > target):\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tq = temp\\n\\tq = sorted(list(q))\\n\\ti = bisect_right(q, target)\\n\\tif(i == len(q)):\\n\\t\\treturn target - q[-1]\\n\\tif(i == 0):\\n\\t\\treturn q[0] - target\\n"]}
{"id": "1447", "ref_py": ["def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        return sorted(nums, key= lambda i : int(i))[-k]\\n```", "def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        nums = sorted(map(int, nums), reverse=True)\\n        return str(nums[k-1])\\n```", "def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        return sorted(nums, key= lambda i : int(i))[-k]\\n```"]}
{"id": "1448", "ref_py": ["def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        if not tasks:\\n            return 0\\n        n = len(tasks)\\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                result = float(\\'inf\\')\\n                flag = True\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and s >= tasks[i]:\\n                        result = min(result, dp(mask | 2**i, s-tasks[i]))\\n                        flag = False\\n                if flag:\\n                    return 1 + dp(mask, sessionTime)\\n                return result\\n        return dp(0, sessionTime) + 1\\n```", "def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        if not tasks:\\n            return 0\\n        n = len(tasks)\\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                result = float(\\'inf\\')\\n                flag = True\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and s >= tasks[i]:\\n                        result = min(result, dp(mask | 2**i, s-tasks[i]))\\n                        flag = False\\n                if flag:\\n                    return 1 + dp(mask, sessionTime)\\n                return result\\n        return dp(0, sessionTime) + 1\\n```", "def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        if not tasks:\\n            return 0\\n        n = len(tasks)\\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                result = float(\\'inf\\')\\n                flag = True\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and s >= tasks[i]:\\n                        result = min(result, dp(mask | 2**i, s-tasks[i]))\\n                        flag = False\\n                if flag:\\n                    return 1 + dp(mask, sessionTime)\\n                return result\\n        return dp(0, sessionTime) + 1\\n```"]}
{"id": "1449", "ref_py": ["def findFarmland(self, land: List[List[int]]) -> List[List[int]]:", "def findFarmland(self, land: List[List[int]]) -> List[List[int]]:\\n        m, n = len(land), len(land[0])\\n        groups = []\\n        for i in range(m):\\n            for j in range(n):\\n                if land[i][j] == 1 and (i == 0 or land[i-1][j] == 0) and (j == 0 or land[i][j-1] == 0):\\n                    ", "def findFarmland(self, land: List[List[int]]) -> List[List[int]]:"]}
{"id": "1451", "ref_py": ["defense\\n    // 2. count weak characters (those defenses less than the current maximum defense)\\n    // 3. update the maximum defense\\n    int numberOfWeakCharacters(vector<vector<int>>& p) {\\n        // the final answer to be returned\\n        int weakCharacters = 0;\\n        // record maximum defense. since 1 <= defense_i <= 10 ^ 5\\n        // we can set the init value to x where x < 1\\n        int maxDefense = 0;\\n        // use a hash map to map the attack and defense with greater<int> as a key_compare\\n        map<int, vector<int>, greater<int>> m;\\n        for(auto x : p) m[x[0]].push_back(x[1]);\\n        // for each attack\\n        for(auto x : m) {\\n            // we count the number of weak characters \\n            // and add it to `weakCharacters`\\n            weakCharacters += count_if(x.second.begin(), x.second.end(), [&](int curDefense){ return curDefense < maxDefense;});\\n            // then update `maxDefense` which is the maximum value in current defenses\\n            maxDefense = max(maxDefense, *max_element(x.second.begin(), x.second.end()));\\n        }\\n        return weakCharacters;\\n    }\\n};\\n```", "def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\\n        \\n        properties.sort(key=lambda x: (-x[0],x[1]))\\n        \\n        ans = 0\\n        curr_max = 0\\n        \\n        for _, d in properties:\\n            if d < curr_max:\\n                ans += 1\\n            else:\\n                curr_max = d\\n        return ans\\n```", "defense\\n    // 2. count weak characters (those defenses less than the current maximum defense)\\n    // 3. update the maximum defense\\n    int numberOfWeakCharacters(vector<vector<int>>& p) {\\n        // the final answer to be returned\\n        int weakCharacters = 0;\\n        // record maximum defense. since 1 <= defense_i <= 10 ^ 5\\n        // we can set the init value to x where x < 1\\n        int maxDefense = 0;\\n        // use a hash map to map the attack and defense with greater<int> as a key_compare\\n        map<int, vector<int>, greater<int>> m;\\n        for(auto x : p) m[x[0]].push_back(x[1]);\\n        // for each attack\\n        for(auto x : m) {\\n            // we count the number of weak characters \\n            // and add it to `weakCharacters`\\n            weakCharacters += count_if(x.second.begin(), x.second.end(), [&](int curDefense){ return curDefense < maxDefense;});\\n            // then update `maxDefense` which is the maximum value in current defenses\\n            maxDefense = max(maxDefense, *max_element(x.second.begin(), x.second.end()));\\n        }\\n        return weakCharacters;\\n    }\\n};\\n```"]}
{"id": "1452", "ref_py": ["def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        N = len(intervals)\\n        res = [-1] * N\\n        intervals = sorted([(s,e,i) for i,(s,e) in enumerate(intervals)])\\n        intervals.append((float(inf), float(inf), -1))\\n        for idx in range(N):\\n            s1,e1,i1 = intervals[idx]\\n            left = 0\\n            right = N\\n            while left < right:\\n                mid = (left + right) // 2\\n                s2,e2,i2 = intervals[mid]\\n                if s2 >= e1:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            res[i1] = intervals[left][2]\\n        return res\\n```\\nOR\\n```\\nclass Solution:\\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        N = len(intervals)\\n        intervals = sorted([(s,e,i) for i,(s,e) in enumerate(intervals)])\\n        intervals.append((float(inf), float(inf), -1)) ", "def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        ", "def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\\n        "]}
{"id": "1453", "ref_py": ["def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\\n        ratios = defaultdict(int)\\n        for x, y in rectangles:\\n            ratios[x/y] += 1\\n        res = 0\\n        for val in ratios.values():\\n            res += (val*(val-1)//2)\\n        return res\\n```", "def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\\n        ratios = defaultdict(int)\\n        for x, y in rectangles:\\n            ratios[x/y] += 1\\n        res = 0\\n        for val in ratios.values():\\n            res += (val*(val-1)//2)\\n        return res\\n```", "def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\\n        ratios = defaultdict(int)\\n        for x, y in rectangles:\\n            ratios[x/y] += 1\\n        res = 0\\n        for val in ratios.values():\\n            res += (val*(val-1)//2)\\n        return res\\n```"]}
{"id": "1454", "ref_py": ["def maxProduct(self, s: str) -> int:\\n        n, pali = len(s), {} ", "def maxProduct(self, s: str) -> int:\\n        ", "def maxProduct(self, s: str) -> int:\\n        self.res = 0\\n        def isPalindrome(word):\\n            l, r = 0, len(word)-1\\n            while l < r:\\n                if word[l] != word[r]:\\n                    return False\\n                l += 1; r -= 1\\n            return True\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, word1, word2):\\n            if i >= len(s):\\n                if isPalindrome(word1) and isPalindrome(word2):\\n                    self.res = max(self.res, len(word1) * len(word2))\\n                return\\n            \\n\\t\\t\\tdfs(i + 1, word1, word2)             "]}
{"id": "1455", "ref_py": ["def findOriginalArray(self, changed: List[int]) -> List[int]:\\n        if len(changed) % 2 == 1:\\n            return []\\n        data = Counter(changed)\\n        result = []\\n        for k in sorted(data):\\n            if data[k] < 0:\\n                return []\\n            elif k == 0:\\n                x, y = divmod(data[k], 2)\\n                if y == 1:\\n                    return []\\n                result += [0] * x\\n            elif data[k] > 0:\\n                value = k * 2\\n                if data[value] == 0:\\n                    return []\\n                min_value = min(value, data[k])\\n                result += [k] * min_value\\n                data[k] -= min_value\\n                data[value] -= min_value\\n        return result\\n```", "def findOriginalArray(self, changed):\\n        ", "def findOriginalArray(self, changed):\\n        "]}
{"id": "1456", "ref_py": ["def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:", "def maxTaxiEarnings(self, n, A):\\n        A.sort()\\n        dp = [0] * (n+1)\\n        for i in range(n-1,-1,-1):\\n            dp[i] = dp[i+1]\\n            while A and i == A[-1][0]:\\n                s,e,t = A.pop()\\n                dp[i] = max(dp[i],dp[e] + e + t - s)\\n        return dp[0]\\n```", "def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:"]}
{"id": "1457", "ref_py": ["def sumOfBeauties(self, nums) :\\n        N=len(nums)\\n        \\n        ", "def sumOfBeauties(self, nums) :\\n        N=len(nums)\\n        \\n        ", "def sumOfBeauties(self, nums) :\\n        N=len(nums)\\n        \\n        "]}
{"id": "1459", "ref_py": ["def gridGame(self, g: List[List[int]]) -> int:\\n        top, bottom, res = sum(g[0]), 0, math.inf\\n        for g0, g1 in zip(g[0], g[1]):\\n            top -= g0\\n            res = min(res, max(top, bottom))\\n            bottom += g1\\n        return res\\n```", "def gridGame(self, grid: List[List[int]]) -> int:\\n        \\n        ", "def gridGame(self, g: List[List[int]]) -> int:\\n        top, bottom, res = sum(g[0]), 0, math.inf\\n        for g0, g1 in zip(g[0], g[1]):\\n            top -= g0\\n            res = min(res, max(top, bottom))\\n            bottom += g1\\n        return res\\n```"]}
{"id": "1460", "ref_py": ["def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\\n        M,N = len(board),len(board[0])\\n        L = len(word)\\n        def canPlace(r,c,dirX,dirY,i):\\n            ", "def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        W = len(word)\\n        \\n        def valid(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        \\n        def place(x, y, word, direction):\\n            dx, dy = direction\\n            for c in word:\\n                if not valid(x, y) or board[x][y] == \\'", "def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\\n        M,N = len(board),len(board[0])\\n        L = len(word)\\n        def canPlace(r,c,dirX,dirY,i):\\n            "]}
{"id": "1461", "ref_py": ["def findComplement(self, num: int) -> int:\\n        ", "def findComplement(self, num: int) -> int:\\n        ", "def findComplement(self, num: int) -> int:\\n        "]}
{"id": "1462", "ref_py": ["def findLongestWord(self, s: str, d: List[str]) -> str:\\n        ", "def findLongestWord(self, s: str, d: List[str]) -> str:\\n        ", "def findLongestWord(self, s: str, d: List[str]) -> str:\\n        "]}
{"id": "1463", "ref_py": ["def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = (len(rolls) + n) * mean\\n        remain = total - sum(rolls)\\n        if remain > n * 6 or remain < n:\\n            return []\\n        res = [1] * n\\n        remain -= n\\n", "def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = (len(rolls) + n) * mean\\n        remain = total - sum(rolls)\\n        if remain > n * 6 or remain < n:\\n            return []\\n        res = [1] * n\\n        remain -= n\\n", "def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = (len(rolls) + n) * mean\\n        remain = total - sum(rolls)\\n        if remain > n * 6 or remain < n:\\n            return []\\n        res = [1] * n\\n        remain -= n\\n"]}
{"id": "1464", "ref_py": ["defines a class `Solution` with a method `lengthOfLastWord` that calculates the length of the last word in a given input string `s`. Here\\'s a brief explanation of each part of the code:", "def lengthOfLastWord(self, s):\\n        count = 0  ", "defines a class `Solution` with a method `lengthOfLastWord` that calculates the length of the last word in a given input string `s`. Here\\'s a brief explanation of each part of the code:"]}
{"id": "1465", "ref_py": ["def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n\\t\\t\\n\\t\\t", "def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums = sorted([n for row in grid for n in row])\\n        target = nums[len(nums) // 2]", "def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n\\t\\t\\n\\t\\t"]}
{"id": "1467", "ref_py": ["def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```", "def numberOfSteps(self, num):\\n        counter = 0\\n        while num != 0:\\n            if num%2==0:\\n                num = num//2\\n                counter += 1\\n            else:\\n                num = num - 1\\n                counter += 1\\n        return counter", "def numberOfSteps(self, num: int) -> int:\\n        if num == 0:\\n            return 0\\n        return 1 + self.numberOfSteps(num - 1 if num & 1 else num >> 1)\\n```"]}
{"id": "1468", "ref_py": ["def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n            \\n        dis = {}\\n        queue = deque([(0, 0)])\\n        visited = set([0])\\n        while queue:\\n            cur, length = queue.popleft()\\n            dis[cur] = length * 2\\n            for nxt in graph[cur]:\\n                if nxt not in visited:\\n                    queue.append((nxt, length + 1))\\n                    visited.add(nxt)\\n        \\n        ans = -float(\"inf\")\\n        for i in range(1, len(patience)):\\n            if patience[i] < dis[i]:\\n                rem = dis[i] % patience[i]\\n                lastCall = dis[i] - (rem) if rem > 0 else dis[i] - patience[i]\\n                ans = max(ans, lastCall + dis[i]) \\n            else:\\n                ans = max(ans, dis[i])\\n        return ans + 1", "def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n            \\n        dis = {}\\n        queue = deque([(0, 0)])\\n        visited = set([0])\\n        while queue:\\n            cur, length = queue.popleft()\\n            dis[cur] = length * 2\\n            for nxt in graph[cur]:\\n                if nxt not in visited:\\n                    queue.append((nxt, length + 1))\\n                    visited.add(nxt)\\n        \\n        ans = -float(\"inf\")\\n        for i in range(1, len(patience)):\\n            if patience[i] < dis[i]:\\n                rem = dis[i] % patience[i]\\n                lastCall = dis[i] - (rem) if rem > 0 else dis[i] - patience[i]\\n                ans = max(ans, lastCall + dis[i]) \\n            else:\\n                ans = max(ans, dis[i])\\n        return ans + 1", "def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n            \\n        dis = {}\\n        queue = deque([(0, 0)])\\n        visited = set([0])\\n        while queue:\\n            cur, length = queue.popleft()\\n            dis[cur] = length * 2\\n            for nxt in graph[cur]:\\n                if nxt not in visited:\\n                    queue.append((nxt, length + 1))\\n                    visited.add(nxt)\\n        \\n        ans = -float(\"inf\")\\n        for i in range(1, len(patience)):\\n            if patience[i] < dis[i]:\\n                rem = dis[i] % patience[i]\\n                lastCall = dis[i] - (rem) if rem > 0 else dis[i] - patience[i]\\n                ans = max(ans, lastCall + dis[i]) \\n            else:\\n                ans = max(ans, dis[i])\\n        return ans + 1"]}
{"id": "1470", "ref_py": ["def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    return sorted([(i, j) for i in range(R) for j in range(C)], key=lambda p: abs(p[0] - r0) + abs(p[1] - c0))\\n```", "def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    return sorted([(i, j) for i in range(R) for j in range(C)], key=lambda p: abs(p[0] - r0) + abs(p[1] - c0))\\n```", "def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    return sorted([(i, j) for i in range(R) for j in range(C)], key=lambda p: abs(p[0] - r0) + abs(p[1] - c0))\\n```"]}
{"id": "1471", "ref_py": ["def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "1472", "ref_py": ["def __init__(self, n):\\n        self.n = n\\n        self.left = None\\n        self.right = None", "def __init__(self, n):\\n        self.n = n\\n        self.left = None\\n        self.right = None", "def __init__(self, n):\\n        self.n = n\\n        self.left = None\\n        self.right = None"]}
{"id": "1473", "ref_py": ["def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        heap = []\\n        res2,res1 = 0,0\\n        for s,e,p in events:\\n            while heap and heap[0][0]<s:\\n                res1 = max(res1,heapq.heappop(heap)[1])\\n            \\n            res2 = max(res2,res1+p)\\n            heapq.heappush(heap,(e,p))\\n        \\n        return res2", "def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        heap = []\\n        res2,res1 = 0,0\\n        for s,e,p in events:\\n            while heap and heap[0][0]<s:\\n                res1 = max(res1,heapq.heappop(heap)[1])\\n            \\n            res2 = max(res2,res1+p)\\n            heapq.heappush(heap,(e,p))\\n        \\n        return res2", "def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        heap = []\\n        res2,res1 = 0,0\\n        for s,e,p in events:\\n            while heap and heap[0][0]<s:\\n                res1 = max(res1,heapq.heappop(heap)[1])\\n            \\n            res2 = max(res2,res1+p)\\n            heapq.heappush(heap,(e,p))\\n        \\n        return res2"]}
{"id": "1474", "ref_py": ["def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        ", "def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        ", "def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        "]}
{"id": "1475", "ref_py": ["def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        idx, i = [], 1\\n        prev, cur = head, head.next\\n        while cur and cur.next:\\n            if prev.val < cur.val > cur.next.val or prev.val > cur.val < cur.next.val:\\n                idx.append(i)\\n            prev = cur\\n            cur = cur.next\\n            i += 1", "def nodesBetweenCriticalPoints(self, head: ListNode) -> List[int]:", "def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        prev = None\\n        temp = head\\n        \\n        mini, maxi = 10 ** 5, 0\\n        count = 1\\n        \\n        diff = 10 ** 5\\n        while temp.next.next != None:\\n            prev = temp\\n            temp = temp.next\\n            count += 1\\n            \\n            if prev.val > temp.val < temp.next.val or prev.val < temp.val > temp.next.val:\\n            \\n                if maxi != 0:\\n                    mini = min(mini, count - maxi)\\n                diff = min(diff, count)\\n                maxi = count\\n        \\n        if diff == 10 ** 5 or mini == 10 ** 5:\\n            return [-1, -1]\\n        return [mini, maxi - diff]\\n"]}
{"id": "1476", "ref_py": ["def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start==goal:\\n            return 0\\n        \\n        q = [(start,0)]\\n        seen = {start}\\n        while q:\\n            n,s = q.pop(0)\\n            for num in nums:\\n                for cand in [n+num,n-num,n^num]:\\n                    if cand==goal:\\n                        return s+1\\n                    if 0<=cand<=1000 and cand not in seen:\\n                        seen.add(cand)\\n                        q.append((cand,s+1))\\n        \\n        return -1", "def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:", "def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:"]}
{"id": "1477", "ref_py": ["def countVowels(self, word: str) -> int:\\n        count = 0\\n        sz = len(word)\\n        \\n        for pos in range(sz):\\n            if word[pos] in \\'aeiou\\':\\n                count += (sz - pos) * (pos + 1)\\n        \\n        return count\\n```", "def countVowels(self, word: str) -> int:\\n        c, l = 0, len(word)\\n        d = {\\'a\\':1, \\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(l):\\n                if word[i] in d:\\n                    c += (l-i)*(i+1)\\n        return c\\n```\\n![image](https://assets.leetcode.com/users/images/697a073a-9322-4b45-a737-10da70505d33_1636264423.3988705.png)", "def countVowels(self, word: str) -> int:\\n        count = 0\\n        sz = len(word)\\n        \\n        for pos in range(sz):\\n            if word[pos] in \\'aeiou\\':\\n                count += (sz - pos) * (pos + 1)\\n        \\n        return count\\n```"]}
{"id": "1478", "ref_py": ["def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def cond(m, n):\\n            return sum([(q // m) + (q % m > 0) for q in quantities]) <= n\\n        \\n        l, r = 1, max(quantities)\\n        while l < r:\\n            m = (l + r) // 2\\n            if cond(m, n):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```", "def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        def helper(val ):\\n            crr = 0 \\n            for ele in quantities : \\n                crr += ceil(ele/val) \\n            if crr <= n : \\n                return False \\n            return True \\n        \\n        left = ceil(sum(quantities)/n) // min value will be average \\n        right = max(quantities) // right will be max as we give that completely\\n        \\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left  ", "def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        \\n        \\n        \\n        def isValid(x):\\n            \\n            count=0\\n            \\n            for val in quantities:\\n                count+=ceil(val/x)"]}
{"id": "1480", "ref_py": ["def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])", "def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:", "def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort(key=lambda x: x[0])\\n        prefix = [0]\\n        for _, b in items:\\n            prefix.append(max(b, prefix[-1]))\\n        \\n        ans = []\\n        for p in queries:\\n            t = bisect_right(items, p, key=lambda x:x[0])\\n            ans.append(prefix[t])\\n        return ans\\n```\\n"]}
{"id": "1481", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 ", "def reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 "]}
{"id": "1482", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1483", "ref_py": ["def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"\\n        prefix = strs[0]\\n        for string in strs[1:]:\\n            while string.find(prefix) != 0:\\n                prefix = prefix[:-1]\\n                if not prefix:\\n                    return \"\"\\n        return prefix\\n```", "def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return \"\"  "]}
{"id": "1485", "ref_py": ["def minimumBuckets(self, s):\\n        return -1 if \\'HHH\\' in s or s[:2] == \\'HH\\' or s[-2:] == \\'HH\\' or s == \\'H\\' else s.count(\\'H\\') - s.count(\\'H.H\\')\\n```", "def minimumBuckets(self, s):\\n        return -1 if \\'HHH\\' in s or s[:2] == \\'HH\\' or s[-2:] == \\'HH\\' or s == \\'H\\' else s.count(\\'H\\') - s.count(\\'H.H\\')\\n```", "def minimumBuckets(self, s):\\n        return -1 if \\'HHH\\' in s or s[:2] == \\'HH\\' or s[-2:] == \\'HH\\' or s == \\'H\\' else s.count(\\'H\\') - s.count(\\'H.H\\')\\n```"]}
{"id": "1486", "ref_py": ["def shiftingLetters(self, s: str, shifts: List[int]) -> str:\\n        ans, shift = \\'\\', 0\\n        for i in range(len(shifts) -1, -1, -1):\\n            ans += chr((ord(s[i]) - ord(\\'a\\') + shift+shifts[i]) % 26 + ord(\\'a\\'))\\n            shift += shifts[i]\\n        \\n        return ans[::-1]\\n```", "def shiftingLetters(self, s: str, shifts: List[int]) -> str:\\n        ans, shift = \\'\\', 0\\n        for i in range(len(shifts) -1, -1, -1):\\n            ans += chr((ord(s[i]) - ord(\\'a\\') + shift+shifts[i]) % 26 + ord(\\'a\\'))\\n            shift += shifts[i]\\n        \\n        return ans[::-1]\\n```", "def shiftingLetters(self, s: str, shifts: List[int]) -> str:\\n        ans, shift = \\'\\', 0\\n        for i in range(len(shifts) -1, -1, -1):\\n            ans += chr((ord(s[i]) - ord(\\'a\\') + shift+shifts[i]) % 26 + ord(\\'a\\'))\\n            shift += shifts[i]\\n        \\n        return ans[::-1]\\n```"]}
{"id": "1487", "ref_py": ["def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        ", "def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        ", "def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        "]}
{"id": "1488", "ref_py": ["def minimumDeletions(self, nums):\\n        \\n        mx=nums.index(max(nums))\\n        mn=nums.index(min(nums))\\n        mx_idx=max(mn,mx)\\n        mn_idx=min(mn,mx)\\n        lf_idx=len(nums)-mn_idx\\n        r_idx=len(nums)+1+mn_idx-mx_idx\\n        return min(lf_idx,mx_idx+1,r_idx)\\n        ", "def minimumDeletions(self, nums):\\n        \\n        mx=nums.index(max(nums))\\n        mn=nums.index(min(nums))\\n        mx_idx=max(mn,mx)\\n        mn_idx=min(mn,mx)\\n        lf_idx=len(nums)-mn_idx\\n        r_idx=len(nums)+1+mn_idx-mx_idx\\n        return min(lf_idx,mx_idx+1,r_idx)\\n        ", "def minimumDeletions(self, nums):\\n        \\n        mx=nums.index(max(nums))\\n        mn=nums.index(min(nums))\\n        mx_idx=max(mn,mx)\\n        mn_idx=min(mn,mx)\\n        lf_idx=len(nums)-mn_idx\\n        r_idx=len(nums)+1+mn_idx-mx_idx\\n        return min(lf_idx,mx_idx+1,r_idx)\\n        "]}
{"id": "1489", "ref_py": ["def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```"]}
{"id": "1490", "ref_py": ["def __init__(self):\\n        self.graph = defaultdict(list)\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\t", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1491", "ref_py": ["def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        @cache\\n        def get_left(i):\\n            if i - 1 >= 0 and security[i - 1] >= security[i]:\\n                return get_left(i - 1) + 1\\n            return 0", "def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        ", "def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        "]}
{"id": "1492", "ref_py": ["def maximumDetonation(self, bombs: list[list[int]]) -> int:\\n        Bomb = tuple[int, int, int]\\n        T = Hashable\\n        Graph = Mapping[T, Collection[T]]", "def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        def dfs(node: int, visited: set = None) -> set:\\n            if visited is None:\\n                visited = {node}", "defaultdict"]}
{"id": "1493", "ref_py": ["def subArrayRanges(self, A):\\n        res = 0\\n        n = len(A)\\n        for i in xrange(n):\\n            l,r = A[i],A[i]\\n            for j in xrange(i, n):\\n                l = min(l, A[j])\\n                r = max(r, A[j])\\n                res += r - l\\n        return res\\n```", "def subArrayRanges(self, A):\\n        res = 0\\n        n = len(A)\\n        for i in xrange(n):\\n            l,r = A[i],A[i]\\n            for j in xrange(i, n):\\n                l = min(l, A[j])\\n                r = max(r, A[j])\\n                res += r - l\\n        return res\\n```", "def subArrayRanges(self, A):\\n        res = 0\\n        n = len(A)\\n        for i in xrange(n):\\n            l,r = A[i],A[i]\\n            for j in xrange(i, n):\\n                l = min(l, A[j])\\n                r = max(r, A[j])\\n                res += r - l\\n        return res\\n```"]}
{"id": "1494", "ref_py": ["def findLUSlength(self, a: str, b: str) -> int:\\n        ", "def findLUSlength(self, a: str, b: str) -> int:\\n\\tdef isSub(x, y):\\n\\t\\ti = j = 0\\n\\t\\twhile(i<len(x) and j<len(y)):\\n\\t\\t\\tif(x[i] == y[j]):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tj += 1\\n\\t\\treturn i != len(x)\\n\\tt1, t2 = isSub(a, b), isSub(b, a)\\n\\tif(t1 and t2):\\n\\t\\treturn max(len(a), len(b))\\n\\tif(t1):\\n\\t\\treturn len(a)\\n\\tif(t2):\\n\\t\\treturn len(b)\\n", "def findLUSlength(self, a: str, b: str) -> int:\\n        "]}
{"id": "1495", "ref_py": ["def addSpaces(self, s: str, spaces: List[int]) -> str:\\n        res = \"\"\\n        lastIdx = 0\\n        for i in spaces:\\n            res += s[lastIdx:i]\\n            res += \" \"\\n            lastIdx = i\\n        res += s[lastIdx:]\\n        return(res)", "def addSpaces(self, s: str, spaces: List[int]) -> str:\\n        res = \"\"\\n        idx = 0\\n        n = len(spaces)\\n        \\n        for i in range(len(s)):\\n            space_idx = spaces[idx]\\n            if(i == space_idx):\\n                res += \" \"\\n                if(idx != n - 1): idx += 1 \\n            res += s[i]\\n                \\n        return res\\n```", "def addSpaces(self, s: str, spaces: List[int]) -> str:\\n\\t\\tspaces_idx = len(spaces)-1"]}
{"id": "1496", "ref_py": ["def flipgame(self, f, b):\\n        same = {x for x, y in zip(f, b) if x == y}\\n        return min([i for i in f + b if i not in same] or [0])\\n```", "def flipgame(self, f, b):\\n        same = {x for x, y in zip(f, b) if x == y}\\n        return min([i for i in f + b if i not in same] or [0])\\n```", "def flipgame(self, f, b):\\n        same = {x for x, y in zip(f, b) if x == y}\\n        return min([i for i in f + b if i not in same] or [0])\\n```"]}
{"id": "1497", "ref_py": ["defined as for completion of recipe `b` we should have ingredients `a`.", "def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        adj=defaultdict(list)\\n        ind=defaultdict(int)\\n        \\n        for i in range(len(ingredients)):\\n            for j in range(len(ingredients[i])):\\n                adj[ingredients[i][j]].append(recipes[i])\\n                ind[recipes[i]]+=1\\n        ans=[]\\n        q=deque()\\n        for i in range(len(supplies)):\\n            q.append(supplies[i])\\n        while q:\\n            node=q.popleft()\\n            for i in adj[node]:\\n                ind[i]-=1\\n                if ind[i]==0:\\n                    q.append(i)\\n                    ans.append(i)\\n        return ans", "def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        adj=defaultdict(list)\\n        ind=defaultdict(int)\\n        \\n        for i in range(len(ingredients)):\\n            for j in range(len(ingredients[i])):\\n                adj[ingredients[i][j]].append(recipes[i])\\n                ind[recipes[i]]+=1\\n        ans=[]\\n        q=deque()\\n        for i in range(len(supplies)):\\n            q.append(supplies[i])\\n        while q:\\n            node=q.popleft()\\n            for i in adj[node]:\\n                ind[i]-=1\\n                if ind[i]==0:\\n                    q.append(i)\\n                    ans.append(i)\\n        return ans"]}
{"id": "1498", "ref_py": ["def canBeValid(self, s, locked):\\n        if len(s) % 2:  ", "definitely is invalid and we return false. If there is a free right, then we decrement freeR by 1 and increment degree by 2, simulating swapping a prior free right into a left.", "definitely is invalid and we return false. If there is a free right, then we decrement freeR by 1 and increment degree by 2, simulating swapping a prior free right into a left."]}
{"id": "1499", "ref_py": ["def executeInstructions(self, n, start, s):\\n        na = len(s)\\n        def test(i):\\n            res = 0\\n            x,y = start\\n            for j in xrange(i, na):\\n                o = s[j]\\n                if o == \\'L\\': y -= 1\\n                if o == \\'R\\': y += 1\\n                if o == \\'U\\': x -= 1\\n                if o == \\'D\\': x += 1\\n                if not (0 <= x < n and 0 <= y < n):\\n                    return j - i\\n            return na - i\\n        return map(test, range(na))\\n```\\n<br>", "def executeInstructions(self, n, start, s):\\n        ", "def executeInstructions(self, n, start, s):\\n        "]}
{"id": "1500", "ref_py": ["define Presum and Postsum as following:", "def getDistances(self, nums: List[int]) -> List[int]:\\n        ", "define Presum and Postsum as following:"]}
{"id": "1501", "ref_py": ["def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        \\n        ", "def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        \\n        ", "def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        \\n        "]}
{"id": "1502", "ref_py": ["def reorderList(self, head: ListNode) -> None:\\n        \\n\\t\\t\\n\\t\\t", "def reorderList(self, head: Optional[ListNode]) -> None:\\n        ", "def reorderList(self, head: ListNode) -> None:\\n        \\n\\t\\t\\n\\t\\t"]}
{"id": "1503", "ref_py": ["def pairSum(self, head: Optional[ListNode]) -> int:\\n\\tslow, fast = head, head\\n\\tmaxVal = 0", "def pairSum(head: ListNode) -> int:\\n    list = []\\n    cur = head\\n    while cur:\\n        list.append(cur.val)\\n        cur = cur.next\\n    s, e, ans = 0, len(list) - 1, 0\\n    while s < e:\\n        ans = max(ans, list[s] + list[e])\\n        s += 1\\n        e -= 1\\n    return ans\\n```\\n", "def pairSum(self, head: Optional[ListNode]) -> int:\\n\\tslow, fast = head, head\\n\\tmaxVal = 0"]}
{"id": "1504", "ref_py": ["def stoneGameVII(self, S: List[int]) -> int:\\n        N, dp = len(S), [0] * len(S)\\n        for i in range(N - 2, -1, -1):\\n            total = S[i]\\n            for j in range(i + 1, N):\\n                total += S[j]\\n                dp[j] = max(total - S[i] - dp[j], total - S[j] - dp[j-1])\\n        return dp[-1]\\n```", "def stoneGameVII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        \\n        prefix = [0]\\n        for i in stones:\\n            prefix.append(prefix[-1]+i)\\n        \\n        def solve(left, right):\\n            if left == right:\\n                return 0\\n            \\n            leftScore = prefix[right+1] - prefix[left+1] - solve(left+1,right)\\n            rightScore = prefix[right] - prefix[left] - solve(left,right-1)\\n            return max(leftScore,rightScore)\\n        \\n        return solve(0,n-1)\\n```", "def stoneGameVII(self, stones: List[int]) -> int:\\n        n = len(stones)\\n        \\n        prefix = [0]\\n        for i in stones:\\n            prefix.append(prefix[-1]+i)\\n        \\n        def solve(left, right):\\n            if left == right:\\n                return 0\\n            \\n            leftScore = prefix[right+1] - prefix[left+1] - solve(left+1,right)\\n            rightScore = prefix[right] - prefix[left] - solve(left,right-1)\\n            return max(leftScore,rightScore)\\n        \\n        return solve(0,n-1)\\n```"]}
{"id": "1505", "ref_py": ["define the current window.\\n   - `currentWindowOnes`: Count of ones in the current window.\\n   - `swaps`: Initialize it with the maximum possible swaps (`n`).", "define the current window.\\n   - `currentWindowOnes`: Count of ones in the current window.\\n   - `swaps`: Initialize it with the maximum possible swaps (`n`).", "define the current window.\\n   - `currentWindowOnes`: Count of ones in the current window.\\n   - `swaps`: Initialize it with the maximum possible swaps (`n`)."]}
{"id": "1506", "ref_py": ["def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        for target in targetWords:\\n            for start in startWords:\\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\\n                    cnt += 1\\n                    break\\n        return cnt", "def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        for target in targetWords:\\n            for start in startWords:\\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\\n                    cnt += 1\\n                    break\\n        return cnt", "def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        for target in targetWords:\\n            for start in startWords:\\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\\n                    cnt += 1\\n                    break\\n        return cnt"]}
{"id": "1507", "ref_py": ["def minMoves(self, target: int, maxDoubles: int) -> int:\\n        cnt=0\\n        while target>1 and maxDoubles>0:\\n            if target%2==0:\\n                target=target//2\\n                maxDoubles-=1\\n            else:\\n                target-=1\\n            cnt+=1\\n        if target>1:cnt+=target-1\\n        return cnt", "def minMoves(self, target: int, maxDoubles: int) -> int:\\n        cnt=0\\n        while target>1 and maxDoubles>0:\\n            if target%2==0:\\n                target=target//2\\n                maxDoubles-=1\\n            else:\\n                target-=1\\n            cnt+=1\\n        if target>1:cnt+=target-1\\n        return cnt", "def minMoves(self, target: int, maxDoubles: int) -> int:\\n        cnt=0\\n        while target>1 and maxDoubles>0:\\n            if target%2==0:\\n                target=target//2\\n                maxDoubles-=1\\n            else:\\n                target-=1\\n            cnt+=1\\n        if target>1:cnt+=target-1\\n        return cnt"]}
{"id": "1508", "ref_py": ["def mostPoints(self, qns: list[list[int]]) -> int:\\n        @cache\\n        def max_score(i: int) -> int:\\n            return i < len(qns) and max(qns[i][0] + max_score(i + 1 + qns[i][1]), max_score(i + 1))\\n        \\n        return max_score(0)", "def mostPoints(self, qns: list[list[int]]) -> int:\\n        @cache\\n        def max_score(i: int) -> int:\\n            return i < len(qns) and max(qns[i][0] + max_score(i + 1 + qns[i][1]), max_score(i + 1))\\n        \\n        return max_score(0)", "def mostPoints(self, qns: list[list[int]]) -> int:\\n        @cache\\n        def max_score(i: int) -> int:\\n            return i < len(qns) and max(qns[i][0] + max_score(i + 1 + qns[i][1]), max_score(i + 1))\\n        \\n        return max_score(0)"]}
{"id": "1509", "ref_py": ["def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        ", "def complexNumberMultiply(self, n1, n2):\\n        \\n        a1,b1=n1.split(\\'+\\')\\n        a1=int(a1)\\n        b1=int(b1[:-1])\\n        a2,b2=n2.split(\\'+\\')\\n        a2=int(a2)\\n        b2=int(b2[:-1])\\n        return str(a1*a2-b1*b2)+\\'+\\'+str(a1*b2+a2*b1)+\\'i\\'\\n```", "def complexNumberMultiply(self, n1, n2):\\n        \\n        a1,b1=n1.split(\\'+\\')\\n        a1=int(a1)\\n        b1=int(b1[:-1])\\n        a2,b2=n2.split(\\'+\\')\\n        a2=int(a2)\\n        b2=int(b2[:-1])\\n        return str(a1*a2-b1*b2)+\\'+\\'+str(a1*b2+a2*b1)+\\'i\\'\\n```"]}
{"id": "1510", "ref_py": ["def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True", "def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n", "def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)"]}
{"id": "1511", "ref_py": ["def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        for i,j in zip(pos,neg):\\n            ans.append(i)\\n            ans.append(j)\\n        return ans\\n  ```\\n  ", "def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        for i,j in zip(pos,neg):\\n            ans.append(i)\\n            ans.append(j)\\n        return ans\\n  ```\\n  ", "def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        for i,j in zip(pos,neg):\\n            ans.append(i)\\n            ans.append(j)\\n        return ans\\n  ```\\n  "]}
{"id": "1512", "ref_py": ["def diagonalSum(self, mat):\\n        \\n        s=0\\n        for i in range(0,len(mat)):\\n            a=mat[i][i]\\n            b=mat[i][len(mat)-i-1]\\n            s=s+a+b\\n        if len(mat)%2==0:\\n            return(s)\\n        else:\\n            mid=(1+len(mat))/2-1\\n            return(s-mat[mid][mid])", "def diagonalSum(self, mat: list[list[int]]) -> int:\\n        return (n := len(mat)) and sum(\\n            mat[i][i] + mat[i][n - 1 - i] for i in range(n)\\n        ) - mat[n // 2][n // 2] * (n % 2)", "def diagonalSum(self, mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        res = 0\\n\\t\\t"]}
{"id": "1513", "ref_py": ["def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        zeroFromLeft = [0] * (len(nums) + 1)\\n        oneFromRight = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\\n            else:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\\n                \\n        for i in range(len(nums))[::-1]:\\n            if nums[i] == 1:\\n                oneFromRight[i] = oneFromRight[i + 1] + 1\\n            else:\\n                oneFromRight[i] = oneFromRight[i + 1]\\n        \\n        allSum = [0] * (len(nums) + 1)\\n        currentMax = 0\\n        res = []\\n        for i in range(len(nums) + 1):\\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\\n            if allSum[i] > currentMax:\\n                res = []\\n                currentMax = allSum[i]\\n            if allSum[i] == currentMax:\\n                res.append(i)\\n        return res\\n            \\n```", "def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        score = max_score = sum(nums)\\n        highest_scores = [0]\\n        \\n        for i, v in enumerate(nums, 1):\\n            score += 1 if v == 0 else -1\\n            if score > max_score:\\n                highest_scores = [i]\\n                max_score = score\\n            elif score == max_score:\\n                highest_scores.append(i)\\n        \\n        return highest_scores\\n```", "def maxScoreIndices(self, nums: List[int]) -> List[int]:\\n        zeroFromLeft = [0] * (len(nums) + 1)\\n        oneFromRight = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\\n            else:\\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\\n                \\n        for i in range(len(nums))[::-1]:\\n            if nums[i] == 1:\\n                oneFromRight[i] = oneFromRight[i + 1] + 1\\n            else:\\n                oneFromRight[i] = oneFromRight[i + 1]\\n        \\n        allSum = [0] * (len(nums) + 1)\\n        currentMax = 0\\n        res = []\\n        for i in range(len(nums) + 1):\\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\\n            if allSum[i] > currentMax:\\n                res = []\\n                currentMax = allSum[i]\\n            if allSum[i] == currentMax:\\n                res.append(i)\\n        return res\\n            \\n```"]}
{"id": "1514", "ref_py": ["def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```", "def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```", "def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```"]}
{"id": "1515", "ref_py": ["def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```", "def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```", "def mostFrequent(self, nums, key):\\n        counts = {}\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i-1]==key:\\n                if nums[i] not in counts: counts[nums[i]] = 1\\n                else: counts[nums[i]] += 1\\n        \\n        return max(counts, key=counts.get)\\n```"]}
{"id": "1516", "ref_py": ["def smallestNumber(self, num):", "def smallestNumber(self, num):", "def smallestNumber(self, num):"]}
{"id": "1518", "ref_py": ["def minimumOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if n == 1: return 0", "def minimumOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if n == 1: return 0", "def minimumOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if n == 1: return 0"]}
{"id": "1519", "ref_py": ["def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```", "def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```", "def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```"]}
{"id": "1520", "ref_py": ["def sumOfThree(self, num):\\n        if num % 3: return []\\n        x = num // 3\\n        return list(range(x-1,x+2))\\n```", "def sumOfThree(self, num):\\n        \\n        val=num//3\\n        while val>=0 and 3*val==num:\\n            return [val-1,val,val+1]\\n        return []", "def sumOfThree(self, num):\\n        \\n        val=num//3\\n        while val>=0 and 3*val==num:\\n            return [val-1,val,val+1]\\n        return []"]}
{"id": "1521", "ref_py": ["def maximumEvenSplit(self, finalSum: int) -> List[int]:", "def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        l=set()\\n        if finalSum%2!=0:\\n            return l\\n        else:\\n            s=0\\n            i=2                       ", "def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        l=set()\\n        if finalSum%2!=0:\\n            return l\\n        else:\\n            s=0\\n            i=2                       "]}
{"id": "1522", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n", "def __init__(self, val=0, next=None):\\n"]}
{"id": "1523", "ref_py": ["def repeatLimitedString(self, s: str, repeatLimit: int) -> str:", "def repeatLimitedString(self, s: str, repeatLimit: int) -> str:", "def repeatLimitedString(self, s: str, repeatLimit: int) -> str:"]}
{"id": "1524", "ref_py": ["def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\\n<br>", "def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\\n<br>", "def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\\n<br>"]}
{"id": "1525", "ref_py": ["def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```\\nhere\\'s a step-by-step explanation of the code:", "def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```\\nhere\\'s a step-by-step explanation of the code:", "def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```\\nhere\\'s a step-by-step explanation of the code:"]}
{"id": "1526", "ref_py": ["def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```", "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = set(list1) & set(list2)  ", "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```"]}
{"id": "1527", "ref_py": ["def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________", "def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________"]}
{"id": "1528", "ref_py": ["def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        ", "def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        ", "def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        "]}
{"id": "1529", "ref_py": ["def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hashmap = {}\\n        nodes = set()\\n        children = set()\\n        for parent,child,isLeft in descriptions:\\n            nodes.add(parent)\\n            nodes.add(child)\\n            children.add(child)\\n            if parent not in hashmap:\\n                hashmap[parent] = TreeNode(parent)\\n            if child not in hashmap:\\n                hashmap[child] = TreeNode(child)\\n            if isLeft:\\n                hashmap[parent].left = hashmap[child]\\n            if not isLeft:\\n                hashmap[parent].right = hashmap[child]\\n        \\n        for node in nodes:\\n            if node not in children:\\n                return hashmap[node]", "def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hashmap = {}\\n        nodes = set()\\n        children = set()\\n        for parent,child,isLeft in descriptions:\\n            nodes.add(parent)\\n            nodes.add(child)\\n            children.add(child)\\n            if parent not in hashmap:\\n                hashmap[parent] = TreeNode(parent)\\n            if child not in hashmap:\\n                hashmap[child] = TreeNode(child)\\n            if isLeft:\\n                hashmap[parent].left = hashmap[child]\\n            if not isLeft:\\n                hashmap[parent].right = hashmap[child]\\n        \\n        for node in nodes:\\n            if node not in children:\\n                return hashmap[node]", "def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\\n        hashmap = {}\\n        nodes = set()\\n        children = set()\\n        for parent,child,isLeft in descriptions:\\n            nodes.add(parent)\\n            nodes.add(child)\\n            children.add(child)\\n            if parent not in hashmap:\\n                hashmap[parent] = TreeNode(parent)\\n            if child not in hashmap:\\n                hashmap[child] = TreeNode(child)\\n            if isLeft:\\n                hashmap[parent].left = hashmap[child]\\n            if not isLeft:\\n                hashmap[parent].right = hashmap[child]\\n        \\n        for node in nodes:\\n            if node not in children:\\n                return hashmap[node]"]}
{"id": "1530", "ref_py": ["def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\t    ", "def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\t    ", "def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\t    "]}
{"id": "1531", "ref_py": ["def areNumbersAscending(self, s: str) -> bool:\\n\\tprev = -1", "def __init__(self):\\n        self.res = []", "def areNumbersAscending(self, s: str) -> bool:\\n\\tprev = -1"]}
{"id": "1532", "ref_py": ["def maximumSubsequenceCount(self, text, pattern):\\n        res = cnt1 = cnt2 = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                res += cnt1\\n                cnt2 += 1\\n            if c == pattern[0]:\\n                cnt1 += 1\\n        return res + max(cnt1, cnt2)\\n```\\n<br>", "def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\\n        total = count_a = count_b = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                total += count_a\\n                count_b += 1\\n            if c == pattern[0]:\\n                count_a += 1\\n        \\n        return total + max(count_a, count_b)\\n```\\n**Note:** \\n", "def maximumSubsequenceCount(self, text, pattern):\\n        res = cnt1 = cnt2 = 0\\n        for c in text:\\n            if c == pattern[1]:\\n                res += cnt1\\n                cnt2 += 1\\n            if c == pattern[0]:\\n                cnt1 += 1\\n        return res + max(cnt1, cnt2)\\n```\\n<br>"]}
{"id": "1533", "ref_py": ["def halveArray(self, nums: List[int]) -> int:\\n        ", "def halveArray(self, nums: List[int]) -> int:\\n        ", "def halveArray(self, nums: List[int]) -> int:\\n        "]}
{"id": "1534", "ref_py": ["def minimumBuckets(self, s):\\n        return -1 if \\'HHH\\' in s or s[:2] == \\'HH\\' or s[-2:] == \\'HH\\' or s == \\'H\\' else s.count(\\'H\\') - s.count(\\'H.H\\')\\n```", "def minimumBuckets(self, s):\\n        return -1 if \\'HHH\\' in s or s[:2] == \\'HH\\' or s[-2:] == \\'HH\\' or s == \\'H\\' else s.count(\\'H\\') - s.count(\\'H.H\\')\\n```", "def minimumBuckets(self, s):\\n        return -1 if \\'HHH\\' in s or s[:2] == \\'HH\\' or s[-2:] == \\'HH\\' or s == \\'H\\' else s.count(\\'H\\') - s.count(\\'H.H\\')\\n```"]}
{"id": "1535", "ref_py": ["def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows+1) for _ in range(SIZE + 1)]\\n        for i in range(SIZE):\\n            for score in range(1, numArrows+1):\\n                dp[i+1][score] = max(dp[i][score], (dp[i][score - aliceArrows[i] - 1] + i) if score > aliceArrows[i] else 0)\\n        ans = [0] * SIZE\\n        cur = numArrows\\n        used = 0\\n        for i in range(SIZE, 0, -1):\\n            if dp[i][cur] == dp[i-1][cur]:\\n                continue\\n            ans[i-1] = aliceArrows[i-1] + 1\\n            used += ans[i-1]\\n            cur -= aliceArrows[i-1] + 1\\n        if numArrows - used > 0: ans[0] += numArrows - used\\n        return ans\\n```\\n", "def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows+1) for _ in range(SIZE + 1)]\\n        for i in range(SIZE):\\n            for score in range(1, numArrows+1):\\n                dp[i+1][score] = max(dp[i][score], (dp[i][score - aliceArrows[i] - 1] + i) if score > aliceArrows[i] else 0)\\n        ans = [0] * SIZE\\n        cur = numArrows\\n        used = 0\\n        for i in range(SIZE, 0, -1):\\n            if dp[i][cur] == dp[i-1][cur]:\\n                continue\\n            ans[i-1] = aliceArrows[i-1] + 1\\n            used += ans[i-1]\\n            cur -= aliceArrows[i-1] + 1\\n        if numArrows - used > 0: ans[0] += numArrows - used\\n        return ans\\n```\\n", "def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows+1) for _ in range(SIZE + 1)]\\n        for i in range(SIZE):\\n            for score in range(1, numArrows+1):\\n                dp[i+1][score] = max(dp[i][score], (dp[i][score - aliceArrows[i] - 1] + i) if score > aliceArrows[i] else 0)\\n        ans = [0] * SIZE\\n        cur = numArrows\\n        used = 0\\n        for i in range(SIZE, 0, -1):\\n            if dp[i][cur] == dp[i-1][cur]:\\n                continue\\n            ans[i-1] = aliceArrows[i-1] + 1\\n            used += ans[i-1]\\n            cur -= aliceArrows[i-1] + 1\\n        if numArrows - used > 0: ans[0] += numArrows - used\\n        return ans\\n```\\n"]}
{"id": "1536", "ref_py": ["def minDeletion(self, A):\\n        res = []\\n        for a in A:\\n            if len(res) % 2 == 0 or a != res[-1]:\\n                res.append(a)\\n        return len(A) - (len(res) - len(res) % 2)\\n```\\n<br>", "def minDeletion(self, A):\\n        res = []\\n        for a in A:\\n            if len(res) % 2 == 0 or a != res[-1]:\\n                res.append(a)\\n        return len(A) - (len(res) - len(res) % 2)\\n```\\n<br>", "def minDeletion(self, A):\\n        res = []\\n        for a in A:\\n            if len(res) % 2 == 0 or a != res[-1]:\\n                res.append(a)\\n        return len(A) - (len(res) - len(res) % 2)\\n```\\n<br>"]}
{"id": "1537", "ref_py": ["def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1", "def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1", "def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1"]}
{"id": "1538", "ref_py": ["def triangularSum(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        j = 0\\n        n = len(nums)\\n        while(j < n-1):\\n            for i in range(n-j-1):\\n                nums[i] = (nums[i] + nums[i+1]) % 10\\n            j += 1\\n        return nums[0]\\n\\t\\t\\n\\t```\\n\\t\\n\\t////////// C++ //////\\n\\t\\n", "def triangularSum(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        j = 0\\n        n = len(nums)\\n        while(j < n-1):\\n            for i in range(n-j-1):\\n                nums[i] = (nums[i] + nums[i+1]) % 10\\n            j += 1\\n        return nums[0]\\n\\t\\t\\n\\t```\\n\\t\\n\\t////////// C++ //////\\n\\t\\n", "def triangularSum(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        j = 0\\n        n = len(nums)\\n        while(j < n-1):\\n            for i in range(n-j-1):\\n                nums[i] = (nums[i] + nums[i+1]) % 10\\n            j += 1\\n        return nums[0]\\n\\t\\t\\n\\t```\\n\\t\\n\\t////////// C++ //////\\n\\t\\n"]}
{"id": "1539", "ref_py": ["def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def selectBuildings(prev, index, count):\\n            if (prev, index, count) in memo:\\n                return memo[(prev, index, count)]\\n            if count == 3:\\n                return 1\\n            if index >= len(s):\\n                return 0\\n        \\n            takeBuilding = 0\\n            if s[index] != prev:\\n                takeBuilding = selectBuildings(s[index], index+1, count+1)\\n            dontTakeBuilding = selectBuildings(prev, index+1, count)\\n            memo[(prev, index, count)] = takeBuilding + dontTakeBuilding\\n            return takeBuilding + dontTakeBuilding\\n        \\n        return selectBuildings(\\'\\', 0, 0)", "def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def selectBuildings(prev, index, count):\\n            if (prev, index, count) in memo:\\n                return memo[(prev, index, count)]\\n            if count == 3:\\n                return 1\\n            if index >= len(s):\\n                return 0\\n        \\n            takeBuilding = 0\\n            if s[index] != prev:\\n                takeBuilding = selectBuildings(s[index], index+1, count+1)\\n            dontTakeBuilding = selectBuildings(prev, index+1, count)\\n            memo[(prev, index, count)] = takeBuilding + dontTakeBuilding\\n            return takeBuilding + dontTakeBuilding\\n        \\n        return selectBuildings(\\'\\', 0, 0)", "def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def selectBuildings(prev, index, count):\\n            if (prev, index, count) in memo:\\n                return memo[(prev, index, count)]\\n            if count == 3:\\n                return 1\\n            if index >= len(s):\\n                return 0\\n        \\n            takeBuilding = 0\\n            if s[index] != prev:\\n                takeBuilding = selectBuildings(s[index], index+1, count+1)\\n            dontTakeBuilding = selectBuildings(prev, index+1, count)\\n            memo[(prev, index, count)] = takeBuilding + dontTakeBuilding\\n            return takeBuilding + dontTakeBuilding\\n        \\n        return selectBuildings(\\'\\', 0, 0)"]}
{"id": "1540", "ref_py": ["def numberOfRounds(self, startTime: str, finishTime: str) -> int:", "def numberOfRounds(self, startTime: str, finishTime: str) -> int:", "def numberOfRounds(self, startTime: str, finishTime: str) -> int:"]}
{"id": "1541", "ref_py": ["def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```\\n<br>", "def canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```", "def canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```"]}
{"id": "1542", "ref_py": ["def minimizeResult(self, expression: str) -> str:\\n        if not expression: return expression\\n        \\n        num1, num2 = expression.split(\\'+\\')\\n        min_result = float(\\'inf\\')\\n        min_expression = \\'\\'\\n        \\n        for i in range(len(num1)):\\n            for j in range(1, len(num2)+1):\\n                parenthesis_part1 = int(num1[i:])\\n                parenthesis_part2 = int(num2[0:j])\\n                \\n                outside_part1 = 1\\n                outside_part2 = 1\\n                is_outside_part1_empty = True\\n                is_outside_part2_empty = True\\n                if i != 0:\\n                    outside_part1 = int(num1[0:i])\\n                    is_outside_part1_empty = False\\n                if j != len(num2):\\n                    outside_part2 = int(num2[j:])\\n                    is_outside_part2_empty = False\\n                \\n                curr_result = outside_part1 * (parenthesis_part1 + parenthesis_part2) * outside_part2\\n                if curr_result < min_result:\\n                    min_result = curr_result\\n                    str_outside_part1 = \\'\\' if is_outside_part1_empty else str(outside_part1)\\n                    str_outside_part2 = \\'\\' if is_outside_part2_empty else str(outside_part2)\\n                    min_expression = (str_outside_part1 \\n                                      + \\'(\\' + str(parenthesis_part1) \\n                                      + \\'+\\' + str(parenthesis_part2) \\n                                      + \\')\\' + str_outside_part2)\\n        \\n        return min_expression", "def minimizeResult(self, expression: str) -> str:                   ", "def minimizeResult(self, expression: str) -> str:\\n        if not expression: return expression\\n        \\n        num1, num2 = expression.split(\\'+\\')\\n        min_result = float(\\'inf\\')\\n        min_expression = \\'\\'\\n        \\n        for i in range(len(num1)):\\n            for j in range(1, len(num2)+1):\\n                parenthesis_part1 = int(num1[i:])\\n                parenthesis_part2 = int(num2[0:j])\\n                \\n                outside_part1 = 1\\n                outside_part2 = 1\\n                is_outside_part1_empty = True\\n                is_outside_part2_empty = True\\n                if i != 0:\\n                    outside_part1 = int(num1[0:i])\\n                    is_outside_part1_empty = False\\n                if j != len(num2):\\n                    outside_part2 = int(num2[j:])\\n                    is_outside_part2_empty = False\\n                \\n                curr_result = outside_part1 * (parenthesis_part1 + parenthesis_part2) * outside_part2\\n                if curr_result < min_result:\\n                    min_result = curr_result\\n                    str_outside_part1 = \\'\\' if is_outside_part1_empty else str(outside_part1)\\n                    str_outside_part2 = \\'\\' if is_outside_part2_empty else str(outside_part2)\\n                    min_expression = (str_outside_part1 \\n                                      + \\'(\\' + str(parenthesis_part1) \\n                                      + \\'+\\' + str(parenthesis_part2) \\n                                      + \\')\\' + str_outside_part2)\\n        \\n        return min_expression"]}
{"id": "1543", "ref_py": ["def count_low_high(self,sl,x):\\n        lo =           sl.bisect_left(x)\\n        hi = len(sl) - lo\\n        return lo, hi\\n    \\n    def numTeams(self, A):\\n        result = 0\\n        left   = SortedList()\\n        right  = SortedList(A)\\n        for x in A:\\n            right.remove(x)\\n            lo_L, hi_L  =  self.count_low_high(left ,x)\\n            lo_R, hi_R  =  self.count_low_high(right,x)\\n            result     +=  lo_L*hi_R + hi_L*lo_R\\n            left .add(x)\\n        return result\\n```", "def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n    \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s", "def numTeams(self, rating: List[int]) -> int:\\n        res = 0\\n        for i in range(1, len(rating) - 1):\\n            less, greater = [0, 0], [0, 0]\\n            for j in range(i):\\n                if rating[j] < rating[i]:\\n                    less[0] += 1\\n                else:\\n                    greater[0] += 1\\n            \\n            for k in range(i+1, len(rating)):\\n                if rating[i] < rating[k]:\\n                    less[1] += 1\\n                else:\\n                    greater[1] += 1\\n            res += less[0] * less[1] + greater[0] * greater[1]\\n        return res\\n```"]}
{"id": "1544", "ref_py": ["def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )", "def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )", "def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\\n        c, C = sorted([cost1, cost2])\\n        blocksize = c * C\\n        return sum(\\n            (rest//c+1) * blocks + C * comb(blocks, 2)\\n            for rest in range(total % C, min(blocksize, total+1), C)\\n            for blocks in [(total-rest) // blocksize + 1]\\n        )"]}
{"id": "1546", "ref_py": ["def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks = Counter(tasks)\\n        rounds = 0", "def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks = Counter(tasks)\\n        rounds = 0", "def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks = Counter(tasks)\\n        rounds = 0"]}
{"id": "1547", "ref_py": ["def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```\\nMy helper function `cumdivs` first computes divisibility by divisor 2 or 5, as that\\'s the factors we need to get zeros: It counts for each value in the grid how often it is divisible by divisor `d`. I try up to 9 times, since 2<sup>9</sup>=512 is the largest possible (since the numbers are guaranteed to not exceed 1000). Then it computes and combines the cumulative sums of the divisibilities on both axes (and subtracts each value\\'s divisibility in order to not double-count it).", "def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        accumlatedProduct = [[[1,1] for i in range(m)] for j in range(n)] ", "def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```\\nMy helper function `cumdivs` first computes divisibility by divisor 2 or 5, as that\\'s the factors we need to get zeros: It counts for each value in the grid how often it is divisible by divisor `d`. I try up to 9 times, since 2<sup>9</sup>=512 is the largest possible (since the numbers are guaranteed to not exceed 1000). Then it computes and combines the cumulative sums of the divisibilities on both axes (and subtracts each value\\'s divisibility in order to not double-count it)."]}
{"id": "1548", "ref_py": ["def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        res = set()\\n        \\n        def point(x, y, r):\\n            nonlocal res\\n            \\n            for a in range(x-r, x+r+1):\\n                for b in range(y-r, y+r+1):\\n                    if (a-x)*(a-x) + (b-y)*(b-y) <= r*r:\\n                        res.add((a,b))", "def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        ans = set()\\n        for xc, yc, r in circles:\\n            for y in range(yc-r, yc+r+1):\\n                for x in range(xc-r, xc+r+1):\\n                    if (x, y) not in ans and self.distanceSquare(x, y, xc, yc) <= r * r:\\n                        ans.add((x,y))\\n        return len(ans)", "def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        res = set()\\n        \\n        def point(x, y, r):\\n            nonlocal res\\n            \\n            for a in range(x-r, x+r+1):\\n                for b in range(y-r, y+r+1):\\n                    if (a-x)*(a-x) + (b-y)*(b-y) <= r*r:\\n                        res.add((a,b))"]}
{"id": "1549", "ref_py": ["def binarySearch(self, arr, target):\\n        left, right = 0, len(arr)\\n        ans = None\\n        while left < right:\\n            mid = left + ((right-left)//2)\\n            if arr[mid] >= target:\\n                ", "def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        maxH = 101 \\n        hToL = [[] for _ in range(maxH)]\\n        \\n\\t\\t", "def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n        \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s"]}
{"id": "1550", "ref_py": ["def minimumAverageDifference(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        if l==1: return 0\\n        \\n        s1, s2 = nums[0], sum(nums[1:])\\n        i_smallest, abs_smallest = 0, abs(s1//1 - s2//(l-1))\\n        for i in range(1,l):\\n            n = nums[i]\\n            l1, l2 = i+1, l-i-1\\n            s1 += n; s2 -= n\\n            if i!=l-1:\\n                abs_curr = abs(s1//l1 - s2//l2)\\n            else:\\n                abs_curr = s1//l1\\n            if abs_curr<abs_smallest:\\n                abs_smallest = abs_curr\\n                i_smallest = i\\n                \\n        return i_smallest  \\n```", "def minimumAverageDifference(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        if l==1: return 0\\n        \\n        s1, s2 = nums[0], sum(nums[1:])\\n        i_smallest, abs_smallest = 0, abs(s1//1 - s2//(l-1))\\n        for i in range(1,l):\\n            n = nums[i]\\n            l1, l2 = i+1, l-i-1\\n            s1 += n; s2 -= n\\n            if i!=l-1:\\n                abs_curr = abs(s1//l1 - s2//l2)\\n            else:\\n                abs_curr = s1//l1\\n            if abs_curr<abs_smallest:\\n                abs_smallest = abs_curr\\n                i_smallest = i\\n                \\n        return i_smallest  \\n```", "def minimumAverageDifference(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        if l==1: return 0\\n        \\n        s1, s2 = nums[0], sum(nums[1:])\\n        i_smallest, abs_smallest = 0, abs(s1//1 - s2//(l-1))\\n        for i in range(1,l):\\n            n = nums[i]\\n            l1, l2 = i+1, l-i-1\\n            s1 += n; s2 -= n\\n            if i!=l-1:\\n                abs_curr = abs(s1//l1 - s2//l2)\\n            else:\\n                abs_curr = s1//l1\\n            if abs_curr<abs_smallest:\\n                abs_smallest = abs_curr\\n                i_smallest = i\\n                \\n        return i_smallest  \\n```"]}
{"id": "1551", "ref_py": ["def countUnguarded(m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\\n    for x, y in guards:\\n        matrix[x][y] = \\'G\\'\\n    for x, y in walls:\\n        matrix[x][y] = \\'W\\'", "def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\t", "def countUnguarded(m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\\n    for x, y in guards:\\n        matrix[x][y] = \\'G\\'\\n    for x, y in walls:\\n        matrix[x][y] = \\'W\\'"]}
{"id": "1552", "ref_py": ["def minimumCardPickup(self, cards: List[int]) -> int:\\n        if len(set(cards))==len(cards):\\n            return -1\\n        dic={}   \\n        ma=1000000\\n        for i in range (len(cards)):\\n            if cards[i] not in dic:\\n                dic[cards[i]]=i\\n            else:\\n                if ma>(i-(dic[cards[i]])):\\n                    ma=(i-dic[cards[i]])\\n                dic[cards[i]]=i\\n        return ma+1", "def minimumCardPickup(self, cards: List[int]) -> int:\\n        ", "def minimumCardPickup(self, cards: List[int]) -> int:\\n        "]}
{"id": "1553", "ref_py": ["def countDistinct(self, nums: List[int], k: int, p: int) -> int:\\n        n = len(nums)                        \\n        sub_arrays = set()\\n        \\n\\t\\t", "def countDistinct(self, nums: List[int], k: int, p: int) -> int:\\n        pref_sum,l,s,sol=list(accumulate(nums2:=[int(x%p==0) for x in nums])),len(nums),set(),0\\n        for left,x in enumerate(pref_sum):\\n            for end in range(left+1,bisect_left(pref_sum,x+k if nums2[left] else x+1+k ,lo=left)+1):\\n                if (t:=tuple(nums[left:end])) not in s:s.add(t)\\n        return len(s)", "def countDistinct(self, nums: List[int], k: int, p: int) -> int:\\n        pref_sum,l,s,sol=list(accumulate(nums2:=[int(x%p==0) for x in nums])),len(nums),set(),0\\n        for left,x in enumerate(pref_sum):\\n            for end in range(left+1,bisect_left(pref_sum,x+k if nums2[left] else x+1+k ,lo=left)+1):\\n                if (t:=tuple(nums[left:end])) not in s:s.add(t)\\n        return len(s)"]}
{"id": "1554", "ref_py": ["def __init__(self):\\n        self.matchingSubtreeCount = 0  ", "def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def walk(node):\\n            if node:\\n                s = node.val\\n                c = 1\\n                sl,cl = walk(node.left)\\n                sr,cr = walk(node.right)\\n                \\n                s += sl + sr\\n                c += cl + cr\\n                if node.val == s//c:\\n                    self.ans += 1\\n                return s,c\\n            return 0,0\\n        \\n        walk(root)\\n        return self.ans\\n```", "def __init__(self):\\n        self.matchingSubtreeCount = 0  "]}
{"id": "1555", "ref_py": ["def countTexts(self, pressedKeys):\\n        \\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            ", "def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } ", "def countTexts(self, pressedKeys):\\n        \\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            "]}
{"id": "1556", "ref_py": ["def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum.append(nums[i] + prefix_sum[-1]) \\n        \\n        count = 0\\n        for i in range(n-1):\\n            if prefix_sum[i] >= prefix_sum[n-1] - prefix_sum[i]:\\n                count += 1\\n        return count\\n```", "def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum.append(nums[i] + prefix_sum[-1]) \\n        \\n        count = 0\\n        for i in range(n-1):\\n            if prefix_sum[i] >= prefix_sum[n-1] - prefix_sum[i]:\\n                count += 1\\n        return count\\n```", "def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum.append(nums[i] + prefix_sum[-1]) \\n        \\n        count = 0\\n        for i in range(n-1):\\n            if prefix_sum[i] >= prefix_sum[n-1] - prefix_sum[i]:\\n                count += 1\\n        return count\\n```"]}
{"id": "1557", "ref_py": ["def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        prefix, start_indx = [0], []\\n        for i, j in tiles:\\n            start_indx.append(i)\\n            prefix.append(j - i + 1 + prefix[-1])\\n            \\n        ans = 0\\n        for i, elem in enumerate(tiles):\\n            u, v = elem\\n            length_to_cover = u + carpetLen - 1\\n            \\n            if v >= length_to_cover:\\n                return carpetLen\\n            \\n            end_indx = len(start_indx) - 1\\n            for indx, s in enumerate(start_indx):\\n                if s > length_to_cover:\\n                    end_indx = indx - 1\\n                    break\\n            \\n            length_diff = 0\\n            if tiles[end_indx][1] > length_to_cover:\\n                length_diff = tiles[end_indx][1] - length_to_cover\\n            ans = max(ans, prefix[end_indx + 1] - prefix[i] - length_diff)\\n            \\n        return ans\\n```\\nThe above code runs good for fairly large input size (but still not large enough to get accepted).\\n![image](https://assets.leetcode.com/users/images/feac0b51-549d-427a-a754-cec9794a4087_1652573226.6494923.png)", "def maximumWhiteTiles(self, tiles: List[List[int]], l: int) -> int:\\n        ", "def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        prefix, start_indx = [0], []\\n        for i, j in tiles:\\n            start_indx.append(i)\\n            prefix.append(j - i + 1 + prefix[-1])\\n            \\n        ans = 0\\n        for i, elem in enumerate(tiles):\\n            u, v = elem\\n            length_to_cover = u + carpetLen - 1\\n            \\n            if v >= length_to_cover:\\n                return carpetLen\\n            \\n            end_indx = len(start_indx) - 1\\n            for indx, s in enumerate(start_indx):\\n                if s > length_to_cover:\\n                    end_indx = indx - 1\\n                    break\\n            \\n            length_diff = 0\\n            if tiles[end_indx][1] > length_to_cover:\\n                length_diff = tiles[end_indx][1] - length_to_cover\\n            ans = max(ans, prefix[end_indx + 1] - prefix[i] - length_diff)\\n            \\n        return ans\\n```\\nThe above code runs good for fairly large input size (but still not large enough to get accepted).\\n![image](https://assets.leetcode.com/users/images/feac0b51-549d-427a-a754-cec9794a4087_1652573226.6494923.png)"]}
{"id": "1558", "ref_py": ["def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\\n        special.sort()\\n        special.insert(0, bottom - 1)\\n        special.append(top + 1)\\n        \\n        ans = 0\\n        for i in range(len(special)-1):\\n            ans = max(ans, special[i+1] - special[i] - 1)\\n        return ans\\n```", "def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\\n        special.sort()\\n        special.insert(0, bottom - 1)\\n        special.append(top + 1)\\n        \\n        ans = 0\\n        for i in range(len(special)-1):\\n            ans = max(ans, special[i+1] - special[i] - 1)\\n        return ans\\n```", "def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\\n        special.sort()\\n        special.insert(0, bottom - 1)\\n        special.append(top + 1)\\n        \\n        ans = 0\\n        for i in range(len(special)-1):\\n            ans = max(ans, special[i+1] - special[i] - 1)\\n        return ans\\n```"]}
{"id": "1559", "ref_py": ["def largestCombination(self, candidates: List[int]) -> int:\\n        ans = 0\\n        for bit in range(32):\\n            count = 0\\n            for i in range(len(candidates)):\\n                if candidates[i] & (1<<(31 - bit)) == 0:\\n                    continue\\n                count += 1\\n            ans = max(ans, count)\\n        return ans\\n```", "def largestCombination(self, candidates: List[int]) -> int:\\n        ans = 0\\n        for bit in range(32):\\n            count = 0\\n            for i in range(len(candidates)):\\n                if candidates[i] & (1<<(31 - bit)) == 0:\\n                    continue\\n                count += 1\\n            ans = max(ans, count)\\n        return ans\\n```", "def largestCombination(self, candidates: List[int]) -> int:\\n        ans = 0\\n        for bit in range(32):\\n            count = 0\\n            for i in range(len(candidates)):\\n                if candidates[i] & (1<<(31 - bit)) == 0:\\n                    continue\\n                count += 1\\n            ans = max(ans, count)\\n        return ans\\n```"]}
{"id": "1560", "ref_py": ["def printVertically(self, s: str) -> Iterable[str]:\\n        return map(str.rstrip, map(\\'\\'.join, zip_longest(*s.split(), fillvalue=\\' \\')))", "def printVertically(self, s: str) -> Iterable[str]:\\n        return map(str.rstrip, map(\\'\\'.join, zip_longest(*s.split(), fillvalue=\\' \\')))", "def printVertically(self, s: str) -> Iterable[str]:\\n        return map(str.rstrip, map(\\'\\'.join, zip_longest(*s.split(), fillvalue=\\' \\')))"]}
{"id": "1561", "ref_py": ["def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = (nxt[1]-cur[1])/(nxt[0]-cur[0]) ", "def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = (nxt[1]-cur[1])/(nxt[0]-cur[0]) ", "def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = (nxt[1]-cur[1])/(nxt[0]-cur[0]) "]}
{"id": "1562", "ref_py": ["def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        l=[]\\n        for i in range(len(messages)):\\n            if senders[i] not in d:\\n                d[senders[i]]=len(messages[i].split())\\n            else:\\n                d[senders[i]]+=len(messages[i].split())\\n        x=max(d.values())\\n        for k,v in d.items():\\n            if v==x :\\n                l.append(k)\\n        if len(l)==1:\\n            return l[0]\\n        else:\\n            l=sorted(l)[::-1]      ", "def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        l=[]\\n        for i in range(len(messages)):\\n            if senders[i] not in d:\\n                d[senders[i]]=len(messages[i].split())\\n            else:\\n                d[senders[i]]+=len(messages[i].split())\\n        x=max(d.values())\\n        for k,v in d.items():\\n            if v==x :\\n                l.append(k)\\n        if len(l)==1:\\n            return l[0]\\n        else:\\n            l=sorted(l)[::-1]      ", "def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        l=[]\\n        for i in range(len(messages)):\\n            if senders[i] not in d:\\n                d[senders[i]]=len(messages[i].split())\\n            else:\\n                d[senders[i]]+=len(messages[i].split())\\n        x=max(d.values())\\n        for k,v in d.items():\\n            if v==x :\\n                l.append(k)\\n        if len(l)==1:\\n            return l[0]\\n        else:\\n            l=sorted(l)[::-1]      "]}
{"id": "1563", "ref_py": ["def pickGifts(self, gifts: List[int], k: int) -> int:", "def pickGifts(self, gifts: List[int], k: int) -> int:", "def pickGifts(self, gifts: List[int], k: int) -> int:"]}
{"id": "1564", "ref_py": ["def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() ", "def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() ", "def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() "]}
{"id": "1565", "ref_py": ["def totalSteps(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[i] > A[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```\\n<br>", "def totalSteps(self, nums: List[int]) -> int:\\n        ", "def totalSteps(self, nums: List[int]) -> int:\\n        "]}
{"id": "1566", "ref_py": ["def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```", "def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```", "def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```"]}
{"id": "1567", "ref_py": ["def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n            replacements = {}\\n            for x, y in reversed(operations):\\n                replacements[x] = replacements.get(y, y)\\n            for idx, val in enumerate(nums):\\n                if val in replacements:\\n                    nums[idx] = replacements[val]\\n            return nums\\n```", "def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        dic = {num: i for i, num in enumerate(nums)}\\n        for s, e in operations:\\n            i = dic[s]\\n            nums[i] = e\\n            dic[e] = i\\n            del dic[s]\\n        return nums\\n```\\n**Solution 2: Swap mapping**\\nLet say we have the following operations: a -> b, b -> c, c -> d, we know that in the end a will be transformed to d\\nSo we want to build a hashmap that contains a -> d key-value pair\\nWe can do this by traversing the operations backward and with this line `swaps[s] = swaps[e] if e in swaps else e`, the dictionary will be updated each iteration. Example:\\nIteration 1: {c -> d}\\nIteration 2: {c -> d, b -> d}\\nIteration 3: {c -> d, b -> d, a -> d}\\nTotal runtime: `O(len(operations))` to build the hashmap + `O(len(nums))` to update the output array => `O(max(len(operations), len(nums))`\\n```\\ndef arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n\\tswaps = {}\\n\\tfor s, e in reversed(operations):\\n\\t\\tswaps[s] = swaps[e] if e in swaps else e\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif num in swaps:\\n\\t\\t\\tnums[i] = swaps[num]\\n", "def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        dic = {num: i for i, num in enumerate(nums)}\\n        for s, e in operations:\\n            i = dic[s]\\n            nums[i] = e\\n            dic[e] = i\\n            del dic[s]\\n        return nums\\n```\\n**Solution 2: Swap mapping**\\nLet say we have the following operations: a -> b, b -> c, c -> d, we know that in the end a will be transformed to d\\nSo we want to build a hashmap that contains a -> d key-value pair\\nWe can do this by traversing the operations backward and with this line `swaps[s] = swaps[e] if e in swaps else e`, the dictionary will be updated each iteration. Example:\\nIteration 1: {c -> d}\\nIteration 2: {c -> d, b -> d}\\nIteration 3: {c -> d, b -> d, a -> d}\\nTotal runtime: `O(len(operations))` to build the hashmap + `O(len(nums))` to update the output array => `O(max(len(operations), len(nums))`\\n```\\ndef arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n\\tswaps = {}\\n\\tfor s, e in reversed(operations):\\n\\t\\tswaps[s] = swaps[e] if e in swaps else e\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif num in swaps:\\n\\t\\t\\tnums[i] = swaps[num]\\n"]}
{"id": "1568", "ref_py": ["def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs", "def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs", "def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs"]}
{"id": "1569", "ref_py": ["def vector<vector<int>> vvi;\\nclass Solution {\\nprivate:\\n    int fun(int idx, int jdx, int m, int n, vvi& grid, vvi& moveCost){\\n        // base case\\n        if(idx==m-1) return grid[idx][jdx];", "def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        max_row, max_col = len(grid), len(grid[0])\\n        dp = [[-1] * max_col for _ in range(max_row)] ", "def minPathCost(self, grid, moveCost):\\n        \\n        m,n = len(grid), len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        def get_min_path(upRow, col):\\n            mc = 999999\\n            for column in range(n):\\n                cost = dp[upRow][column] + moveCost[grid[upRow][column]][col] \\n                if(cost < mc):\\n                    mc = cost\\n            return mc"]}
{"id": "1570", "ref_py": ["def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n=len(cookies)", "def distributeCookies(self, cookies: list[int], k: int) -> int:\\n        average = sum(cookies) // k", "def distributeCookies(self, cookies, k):\\n        self.ans = float(\\'inf\\')\\n        self.count = [0] * k"]}
{"id": "1571", "ref_py": ["def minimumNumbers(self, num: int, k: int) -> int:", "def minimumNumbers(self, num: int, k: int) -> int:", "def minimumNumbers(self, num: int, k: int) -> int:"]}
{"id": "1572", "ref_py": ["def longestSubsequence(self, s, k):\\n        dp = [0]\\n        for v in map(int, s):\\n            if dp[-1] * 2 + v <= k:\\n                dp.append(dp[-1] * 2 + v)\\n            for i in range(len(dp) - 1, 0, -1):\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n        return len(dp) - 1\\n```\\n<br>", "def longestSubsequence(self, s, k):\\n        dp = [0]\\n        for v in map(int, s):\\n            if dp[-1] * 2 + v <= k:\\n                dp.append(dp[-1] * 2 + v)\\n            for i in range(len(dp) - 1, 0, -1):\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n        return len(dp) - 1\\n```\\n<br>", "def longestSubsequence(self, s, k):\\n        dp = [0]\\n        for v in map(int, s):\\n            if dp[-1] * 2 + v <= k:\\n                dp.append(dp[-1] * 2 + v)\\n            for i in range(len(dp) - 1, 0, -1):\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n        return len(dp) - 1\\n```\\n<br>"]}
{"id": "1573", "ref_py": ["def long long ll;\\n    \\n    void dfs(int node, int n, ll &currentcount, vector<int> &vis, unordered_map<int,vector<int>> &adj){\\n        vis[node] = 1;\\n        \\n        for(auto it : adj[node]){\\n            if(vis[it] == 0){\\n                vis[it] = 1; \\n                currentcount++;\\n                dfs(it, n, currentcount, vis, adj);   \\n            }\\n        }\\n    }\\n    \\n    long long countPairs(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj; \\n        vector<int> vis(n, 0); \\n        \\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        ll totalprev = 0, ans = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == 0){\\n                vis[i] = 1; \\n                ll currentcount = 1;                  //Calculate count of current component\\n                dfs(i, n, currentcount, vis, adj);    \\n                ans += totalprev * currentcount;      // All current elements make pair with totalprevious elements\\n                totalprev += currentcount;            // Add current elements in totalprevious elements\\n            }     \\n        }\\n        \\n        return ans;\\n    }\\n};", "def countPairs(self, n: int, edges: list[list[int]]) -> int:\\n        dsu = DSU(range(n))\\n        for u, v in edges: dsu.union(u, v)\\n        counts = Counter(map(dsu.find, range(n))).values()\\n        return sum(map(mul, accumulate(counts, add, initial=0), counts))", "def countPairs(self, n: int, edges: List[List[int]]) -> int:\\n        graph = {i: set() for i in range(n)}\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)"]}
{"id": "1574", "ref_py": ["def smallestRangeI(self, nums, k):\\n        min_val = min(nums)\\n        max_val = max(nums)", "def smallestRangeI(self, A: List[int], K: int) -> int:", "def smallestRangeI(self, nums, k):\\n        min_val = min(nums)\\n        max_val = max(nums)"]}
{"id": "1575", "ref_py": ["def countHousePlacements(self, n: int) -> int:\\n        \\n        \\n        @lru_cache(None)\\n        def rec(i, k):\\n            \\n            ", "def countHousePlacements(self, n):\\n        a, b, mod = 1, 1, 10**9 + 7\\n        for i in range(n):\\n            a, b = b, (a + b) % mod\\n        return b * b % mod\\n```\\n<br>", "def countHousePlacements(self, n: int) -> int:\\n\\ta, b = 1, 2\\n\\tfor i in range(1, n):\\n\\t\\ta, b = b, a + b\\n\\treturn (b ** 2) % (10**9 + 7)\\n```"]}
{"id": "1576", "ref_py": ["def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] ", "def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] ", "def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] "]}
{"id": "1577", "ref_py": ["def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:", "def peopleAwareOfSecret(self, n, delay, forget):\\n        dp = [1] + [0] * (n - 1)\\n        mod = 10 ** 9 + 7\\n        share = 0\\n        for i in range(1, n):\\n            dp[i] = share = (share + dp[i - delay] - dp[i - forget]) % mod\\n        return sum(dp[-forget:]) % mod\\n```\\n<br>", "def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\\n        table = [0]*(forget+1)\\n        table[1] = 1\\n        days = 1\\n        while days<=n-1:\\n            count = 0\\n            for k in range(forget-1,-1,-1):\\n                if k+1>delay:\\n                    table[k+1] = table[k]\\n                    count+=table[k]\\n                elif k+1<=delay:\\n                    table[k+1] = table[k]\\n            table[1] = count\\n            days+=1\\n        count = 0\\n        for k in range(1,forget+1):\\n            count+=table[k]\\n        return count%(pow(10,9)+7)\\n"]}
{"id": "1578", "ref_py": ["def longestCommonSubsequence(self, text1: str, text2: str):\\n        l1 = len(text1)\\n        l2 = len(text2)", "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def memo_solve(ptr1, ptr2):\\n            if ptr1 == len(text1) or ptr2 == len(text2):\\n                return 0\\n            \\n            ", "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\\n        \\n        @lru_cache(maxsize=None)\\n        def memo_solve(ptr1, ptr2):\\n            if ptr1 == len(text1) or ptr2 == len(text2):\\n                return 0\\n            \\n            "]}
{"id": "1579", "ref_py": ["def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        count = SortedDict(Counter(diff))\\n        print(diff, count)\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        while k > 0:\\n            key, value = count.popitem()\\n            if k >= value:\\n                k -= value\\n                count[key - 1] = count.get(key - 1, 0) + value\\n            elif k < value:\\n                count[key] = value - k\\n                count[key - 1] = count.get(key - 1, 0) + k\\n                k = 0\\n                \\n        res = 0\\n        for key, val in count.items():\\n            res += key ** 2 * val\\n            \\n        return res\\n```", "def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        count = SortedDict(Counter(diff))\\n        print(diff, count)\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        while k > 0:\\n            key, value = count.popitem()\\n            if k >= value:\\n                k -= value\\n                count[key - 1] = count.get(key - 1, 0) + value\\n            elif k < value:\\n                count[key] = value - k\\n                count[key - 1] = count.get(key - 1, 0) + k\\n                k = 0\\n                \\n        res = 0\\n        for key, val in count.items():\\n            res += key ** 2 * val\\n            \\n        return res\\n```", "def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        count = SortedDict(Counter(diff))\\n        print(diff, count)\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        while k > 0:\\n            key, value = count.popitem()\\n            if k >= value:\\n                k -= value\\n                count[key - 1] = count.get(key - 1, 0) + value\\n            elif k < value:\\n                count[key] = value - k\\n                count[key - 1] = count.get(key - 1, 0) + k\\n                k = 0\\n                \\n        res = 0\\n        for key, val in count.items():\\n            res += key ** 2 * val\\n            \\n        return res\\n```"]}
{"id": "1581", "ref_py": ["def canChange(self, start: str, target: str) -> bool:\\n                                                          \\n        if (len(start) != len(target) or \\n            start.count(\\'_\\') != target.count(\\'_\\')): return False   ", "def canChange(self, start: str, target: str) -> bool:\\n                                                          \\n        if (len(start) != len(target) or \\n            start.count(\\'_\\') != target.count(\\'_\\')): return False   ", "def canChange(self, start: str, target: str) -> bool:\\n                                                          \\n        if (len(start) != len(target) or \\n            start.count(\\'_\\') != target.count(\\'_\\')): return False   "]}
{"id": "1582", "ref_py": ["def minCostToMoveChips(self, position: List[int]) -> int:\\n        ", "def minCostToMoveChips(self, position: List[int]) -> int:\\n        ", "def minCostToMoveChips(self, position: List[int]) -> int:\\n        "]}
{"id": "1583", "ref_py": ["def buddyStrings(self, s, goal):\\n        ind = []", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        c1=Counter(s)\\n        c2=Counter(goal)\\n        if c1!=c2:\\n            return False", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False"]}
{"id": "1584", "ref_py": ["def zeroFilledSubarray(self, nums: list[int]) -> int:\\n        return sum(accumulate(nums, lambda a, x: 0 if x else a + 1, initial=0))", "def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        appear = 0\\n        res = 0\\n        for num in nums:\\n            if num == 0:\\n                appear += 1\\n                res += appear\\n            else:\\n                appear = 0\\n        return res\\n```", "def zeroFilledSubarray(self, nums: list[int]) -> int:\\n        return sum(accumulate(nums, lambda a, x: 0 if x else a + 1, initial=0))"]}
{"id": "1586", "ref_py": ["def equalPairs(self, grid):\\n        n = len(grid)\\n        _dict = {}\\n        for i in range(n):\\n            sum = 0\\n            for j in range(n):\\n                sum = sum + grid[i][j]\\n            if sum in _dict:\\n                _dict[sum].append(i)\\n            else:\\n                _dict[sum] = [i]\\n        \\n        res = 0", "def equalPairs(self, grid):\\n        \\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])", "def equalPairs(self, grid):\\n        \\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])"]}
{"id": "1588", "ref_py": ["def maximumGroups(self, A: List[int]) -> int:\\n        n = len(A)\\n        k = 0\\n        while n >= k + 1:\\n            k += 1\\n            n -= k\\n        return k\\n```\\n<br>", "def maximumGroups(self, grades: List[int]) -> int:\\n        N, k = len(grades), 1\\n        while k * (k+1) // 2 <= N: \\n            k += 1\\n        return k-1", "def maximumGroups(self, grades: List[int]) -> int:\\n        \\n        return  int(-.5+sqrt(.25+2*len(grades)))\\n\\t\\t\\n```"]}
{"id": "1589", "ref_py": ["def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def traverse(node):\\n            curr, dist, ds = node, 0, {node:0}\\n            while True:\\n                curr = edges[curr]\\n                if (curr==-1) or (curr in ds): ", "def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def traverse(node):\\n            curr, dist, ds = node, 0, {node:0}\\n            while True:\\n                curr = edges[curr]\\n                if (curr==-1) or (curr in ds): ", "def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def traverse(node):\\n            curr, dist, ds = node, 0, {node:0}\\n            while True:\\n                curr = edges[curr]\\n                if (curr==-1) or (curr in ds): "]}
{"id": "1590", "ref_py": ["def countBadPairs(self, nums: List[int]) -> int:\\n        nums_len = len(nums)\\n        count_dict = dict()\\n        for i in range(nums_len):\\n            nums[i] -= i\\n            if nums[i] not in count_dict:\\n                count_dict[nums[i]] = 0\\n            count_dict[nums[i]] += 1\\n        \\n        count = 0\\n        for key in count_dict:\\n            count += math.comb(count_dict[key], 2)\\n        return math.comb(nums_len, 2) - count\\n```", "def countBadPairs(self, nums: List[int]) -> int:\\n        count=0\\n        n=len(nums)\\n        ", "def countBadPairs(self, nums: List[int]) -> int:\\n        count=0\\n        n=len(nums)\\n        "]}
{"id": "1591", "ref_py": ["def taskSchedulerII(self, A, space):\\n        last = defaultdict(lambda: - len(A) - 10)\\n        res = 0\\n        for a in A:\\n            last[a] = res = max(res, last[a] + space) + 1\\n        return res\\n```\\n<br>", "def taskSchedulerII(self, A, space):\\n        last = defaultdict(lambda: - len(A) - 10)\\n        res = 0\\n        for a in A:\\n            last[a] = res = max(res, last[a] + space) + 1\\n        return res\\n```\\n<br>", "def taskSchedulerII(self, A, space):\\n        last = defaultdict(lambda: - len(A) - 10)\\n        res = 0\\n        for a in A:\\n            last[a] = res = max(res, last[a] + space) + 1\\n        return res\\n```\\n<br>"]}
{"id": "1592", "ref_py": ["def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\t", "def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\tgraph = defaultdict(list)\\n        visited = [False]*n\\n        queue = deque([0])\\n        res = 0\\n        \\n        for u in restricted:\\n            visited[u] = True\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        while queue:\\n            res += len(queue)\\n            for _ in range(len(queue)):\\n                u = queue.popleft()\\n                visited[u] = True\\n                queue.extend([v for v in graph[u] if not visited[v]])\\n        \\n        return res\\n```", "def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n\\t\\t"]}
{"id": "1593", "ref_py": ["def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): nums[i + 2] = -abs(nums[i + 2])", "def validPartition(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        @cache\\n        def fn(index):\\n            if index==n:\\n                return True", "def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        if nums[1] == nums[0]:\\n            dp[2] = True\\n        \\n        for i in range(2, n):\\n            if nums[i] == nums[i - 1]:\\n                dp[i + 1] = dp[i + 1] or dp[i - 1]\\n            \\n            if nums[i] == nums[i - 1] and nums[i] == nums[i - 2]:\\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\\n            \\n            if nums[i] == nums[i - 1] + 1 and nums[i] == nums[i - 2] + 2:\\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\\n        \\n        return dp[n]"]}
{"id": "1594", "ref_py": ["def longestIdealString(self, s: str, k: int) -> int:\\n        DP = [0 for _ in range(26)]\\n        ans = 1\\n        \\n        for ch in s:\\n            i = ord(ch) - ord(\\'a\\')\\n            DP[i] = DP[i] + 1\\n            \\n            for j in range(max(0, i - k), min(25, i + k) + 1):\\n                if j != i:\\n                    DP[i] = max(DP[i], DP[j] + 1)\\n            \\n            ans = max(ans, DP[i])\\n        \\n        return ans\\n```", "def longestIdealString(self, s: str, k: int) -> int:\\n        DP = [0 for _ in range(26)]\\n        ans = 1\\n        \\n        for ch in s:\\n            i = ord(ch) - ord(\\'a\\')\\n            DP[i] = DP[i] + 1\\n            \\n            for j in range(max(0, i - k), min(25, i + k) + 1):\\n                if j != i:\\n                    DP[i] = max(DP[i], DP[j] + 1)\\n            \\n            ans = max(ans, DP[i])\\n        \\n        return ans\\n```", "def longestIdealString(self, s: str, k: int) -> int:\\n        DP = [0 for _ in range(26)]\\n        ans = 1\\n        \\n        for ch in s:\\n            i = ord(ch) - ord(\\'a\\')\\n            DP[i] = DP[i] + 1\\n            \\n            for j in range(max(0, i - k), min(25, i + k) + 1):\\n                if j != i:\\n                    DP[i] = max(DP[i], DP[j] + 1)\\n            \\n            ans = max(ans, DP[i])\\n        \\n        return ans\\n```"]}
{"id": "1595", "ref_py": ["def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key=len): dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```", "def longestStrChain(self, words):\\n        \\n        ", "def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key=len): dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```"]}
{"id": "1596", "ref_py": ["def smallestNumber(self, s):\\n        res, stack = [], []\\n        for i,c in enumerate(s + \\'I\\', 1):\\n            stack.append(str(i))\\n            if c == \\'I\\':\\n                res += stack[::-1]\\n                stack = []\\n        return \\'\\'.join(res)", "def smallestNumber(self, pattern: str) -> str:\\n        dq = [1] ", "def smallestNumber(self, s):\\n        res, stack = [], []\\n        for i,c in enumerate(s + \\'I\\', 1):\\n            stack.append(str(i))\\n            if c == \\'I\\':\\n                res += stack[::-1]\\n                stack = []\\n        return \\'\\'.join(res)"]}
{"id": "1597", "ref_py": ["def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):", "def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):", "def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):"]}
{"id": "1598", "ref_py": ["def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)", "def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)", "def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)"]}
{"id": "1599", "ref_py": ["def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        if len(c)==1 and c[\\'0\\']>=1:\\n            return \"0\"\\n        m = -1   ", "def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        if len(c)==1 and c[\\'0\\']>=1:\\n            return \"0\"\\n        m = -1   ", "def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        if len(c)==1 and c[\\'0\\']>=1:\\n            return \"0\"\\n        m = -1   "]}
{"id": "1600", "ref_py": ["def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n\\t", "def amountOfTime(self, root, start):\\n        \\n        self.startNode = None\\n        parent = {}\\n        def helper(root):\\n            if not root:\\n                return\\n            if root.val == start:\\n                self.startNode = root\\n            if root.left:\\n                parent[root.left] = root\\n                helper(root.left)\\n            if root.right:\\n                parent[root.right] = root\\n                helper(root.right)\\n        helper(root)", "def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n\\t"]}
{"id": "1601", "ref_py": ["def removeStars(self, s):\\n        ans = []\\n        for i in s:\\n            if i != \\'*\\':\\n                ans.append(i)\\n            else:\\n                ans.pop()\\n        return \\'\\'.join(ans)", "def removeStars(self, s: str) -> str:\\n        ", "def removeStars(self, s):\\n        stack = []"]}
{"id": "1602", "ref_py": ["def garbageCollection(self, garbage, travel):\\n        hash = {}\\n        string = \\' \\'.join(garbage)  \\n        counter = 0  \\n    \\n        for char in string:\\n            if char != \\' \\':\\n                if char not in hash:\\n                    hash[char] = []\\n                hash[char].append(counter)\\n            else:\\n                counter += 1\\n        if \\'G\\' in hash: \\n            last_g = hash[\\'G\\'][-1]\\n        if \\'P\\' in hash:\\n            last_p = hash[\\'P\\'][-1]\\n        if \\'M\\' in hash:\\n            last_m = hash[\\'M\\'][-1]\\n        total_time = 0\\n        i=0\\n        \\n        if \\'P\\' in hash:    \\n            while i < last_p  :\\n                print(travel[i])\\n                total_time += travel[i]\\n                i+=1\\n            total_time += len(hash[\\'P\\'])\\n            \\n        i=0 \\n        if \\'G\\' in hash:    \\n            while i < last_g :\\n                print(travel[i])\\n                total_time += travel[i]\\n                i+=1\\n            total_time += len(hash[\\'G\\'])\\n            \\n        i=0\\n        if \\'M\\' in hash:    \\n            while i < last_m :\\n                total_time += travel[i]\\n                i+=1\\n            total_time += len(hash[\\'M\\'])\\n            \\n        return total_time", "def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        ans = 0", "def garbageCollection(self, garbage, travel):\\n        hash = {}\\n        string = \\' \\'.join(garbage)  \\n        counter = 0  \\n    \\n        for char in string:\\n            if char != \\' \\':\\n                if char not in hash:\\n                    hash[char] = []\\n                hash[char].append(counter)\\n            else:\\n                counter += 1\\n        if \\'G\\' in hash: \\n            last_g = hash[\\'G\\'][-1]\\n        if \\'P\\' in hash:\\n            last_p = hash[\\'P\\'][-1]\\n        if \\'M\\' in hash:\\n            last_m = hash[\\'M\\'][-1]\\n        total_time = 0\\n        i=0\\n        \\n        if \\'P\\' in hash:    \\n            while i < last_p  :\\n                print(travel[i])\\n                total_time += travel[i]\\n                i+=1\\n            total_time += len(hash[\\'P\\'])\\n            \\n        i=0 \\n        if \\'G\\' in hash:    \\n            while i < last_g :\\n                print(travel[i])\\n                total_time += travel[i]\\n                i+=1\\n            total_time += len(hash[\\'G\\'])\\n            \\n        i=0\\n        if \\'M\\' in hash:    \\n            while i < last_m :\\n                total_time += travel[i]\\n                i+=1\\n            total_time += len(hash[\\'M\\'])\\n            \\n        return total_time"]}
{"id": "1603", "ref_py": ["def firstUniqChar(self, s):\\n        \\n        \\n        dictBag={}\\n        for char in range (len(s)):\\n            if s[char] not in dictBag:\\n                dictBag[s[char]]=1\\n            else:\\n                dictBag[s[char]]=-1\\n        for char in range(len(s)):\\n            if dictBag[s[char]]==1:\\n                return char\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```", "def firstUniqChar(self, s: str) -> int:\\n        d=OrderedDict()\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if v==1:\\n                return s.index(k)\\n        return -1\\n```"]}
{"id": "1604", "ref_py": ["def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount ", "def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount ", "def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount "]}
{"id": "1605", "ref_py": ["def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\\n        \\n        @cache\\n        def dp(p, s):\\n            if s == 0:\\n                return 1 if p == endPos else 0\\n            \\n            return (dp(p - 1, s - 1) + dp(p + 1, s - 1)) % (10**9 + 7)", "def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\\n        \\n        @cache\\n        def dp(p, s):\\n            if s == 0:\\n                return 1 if p == endPos else 0\\n            \\n            return (dp(p - 1, s - 1) + dp(p + 1, s - 1)) % (10**9 + 7)", "def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\\n        \\n        @cache\\n        def dp(p, s):\\n            if s == 0:\\n                return 1 if p == endPos else 0\\n            \\n            return (dp(p - 1, s - 1) + dp(p + 1, s - 1)) % (10**9 + 7)"]}
{"id": "1606", "ref_py": ["def longestNiceSubarray(self, A):\\n        res = AND = i = 0\\n        for j in range(len(A)):\\n            while AND & A[j]:\\n                AND ^= A[i]\\n                i += 1\\n            AND |= A[j]\\n            res = max(res, j - i + 1)\\n        return res\\n```\\n<br>", "def longestNiceSubarray(self, A):\\n        res = AND = i = 0\\n        for j in range(len(A)):\\n            while AND & A[j]:\\n                AND ^= A[i]\\n                i += 1\\n            AND |= A[j]\\n            res = max(res, j - i + 1)\\n        return res\\n```\\n<br>", "def longestNiceSubarray(self, A):\\n        res = AND = i = 0\\n        for j in range(len(A)):\\n            while AND & A[j]:\\n                AND ^= A[i]\\n                i += 1\\n            AND |= A[j]\\n            res = max(res, j - i + 1)\\n        return res\\n```\\n<br>"]}
{"id": "1607", "ref_py": ["def partitionString(self, s):\\n        idx = 0\\n        count = 0\\n        mp = {} ", "def partitionString(self, s):\\n        idx = 0\\n        count = 0\\n        mp = {} ", "def partitionString(self, s):\\n        idx = 0\\n        count = 0\\n        mp = {} "]}
{"id": "1608", "ref_py": ["def minGroups(self, intervals):\\n        A = []\\n        for a,b in intervals:\\n            A.append([a, 1])\\n            A.append([b + 1, -1])\\n        res = cur = 0\\n        for a, diff in sorted(A):\\n            cur += diff\\n            res = max(res, cur)\\n        return res\\n```\\n<br>", "def minGroups(self, intervals):\\n        A = []\\n        for a,b in intervals:\\n            A.append([a, 1])\\n            A.append([b + 1, -1])\\n        res = cur = 0\\n        for a, diff in sorted(A):\\n            cur += diff\\n            res = max(res, cur)\\n        return res\\n```\\n<br>", "def minGroups(self, intervals):\\n        A = []\\n        for a,b in intervals:\\n            A.append([a, 1])\\n            A.append([b + 1, -1])\\n        res = cur = 0\\n        for a, diff in sorted(A):\\n            cur += diff\\n            res = max(res, cur)\\n        return res\\n```\\n<br>"]}
{"id": "1609", "ref_py": ["def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        result = 0\\n        for i in range(len(players)):\\n            if len(players)==0 or len(trainers)==0:\\n                break;\\n            if players[-1]<=trainers[-1]:\\n                players.pop()\\n                trainers.pop()\\n                result+=1\\n            else:\\n                players.pop()\\n        return result\\n```", "def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players, trainers = sorted(players), sorted(trainers)\\n        i, j, matchings = len(players) - 1, len(trainers) - 1, 0\\n        while i >= 0 and j >= 0:\\n\\t\\t\\t", "def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players, trainers = sorted(players), sorted(trainers)\\n        i, j, matchings = len(players) - 1, len(trainers) - 1, 0\\n        while i >= 0 and j >= 0:\\n\\t\\t\\t"]}
{"id": "1610", "ref_py": ["def smallestSubarrays(self, nums: List[int]) -> List[int]:        ", "def smallestSubarrays(self, nums: List[int]) -> List[int]:", "def smallestSubarrays(self, nums: List[int]) -> List[int]:"]}
{"id": "1611", "ref_py": ["def longestContinuousSubstring(self, s: str) -> int:\\n        cur = 1 ", "def longestContinuousSubstring(self, s: str) -> int:\\n        cur = 1 ", "def longestContinuousSubstring(self, s: str) -> int:\\n        cur = 1 "]}
{"id": "1612", "ref_py": ["def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        q = deque([root]) ", "def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        q = deque([root]) ", "def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        q = deque([root]) "]}
{"id": "1613", "ref_py": ["def longestSubarray(self, nums: List[int]) -> int:\\n        max_n = max(nums)\\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)\\n```", "def longestSubarray(self, nums: List[int]) -> int:\\n\\t\\t", "def longestSubarray(self, nums: List[int]) -> int:\\n        max_n = max(nums)\\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)\\n```"]}
{"id": "1614", "ref_py": ["def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) <= 2 * k:\\n            return []", "def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) <= 2 * k:\\n            return []", "def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) <= 2 * k:\\n            return []"]}
{"id": "1616", "ref_py": ["def xorAllNums(self, a: List[int], b: List[int]) -> int:\\n        return reduce(xor, a * (len(b) & 1) + b * (len(a) & 1), 0)\\n```", "def xorAllNums(self, A, B):\\n        x = y = 0\\n        for a in A:\\n            x ^= a\\n        for b in B:\\n            y ^= b\\n        return (len(A) % 2 * y) ^ (len(B) % 2 * x)\\n```\\n**Python**\\n```py\\n    def xorAllNums(self, A, B):\\n        return (len(A) % 2 * reduce(xor, B)) ^ (len(B) % 2 * reduce(xor, A))\\n```", "def xorAllNums(self, A, B):\\n        x = y = 0\\n        for a in A:\\n            x ^= a\\n        for b in B:\\n            y ^= b\\n        return (len(A) % 2 * y) ^ (len(B) % 2 * x)\\n```\\n**Python**\\n```py\\n    def xorAllNums(self, A, B):\\n        return (len(A) % 2 * reduce(xor, B)) ^ (len(B) % 2 * reduce(xor, A))\\n```"]}
{"id": "1617", "ref_py": ["def maxSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        return max(\\n            self.get_hourglass(grid, i, j)\\n            for i in range(1, n - 1)\\n            for j in range(1, m - 1)\\n        )", "def maxSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        return max(\\n            self.get_hourglass(grid, i, j)\\n            for i in range(1, n - 1)\\n            for j in range(1, m - 1)\\n        )", "def maxSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        return max(\\n            self.get_hourglass(grid, i, j)\\n            for i in range(1, n - 1)\\n            for j in range(1, m - 1)\\n        )"]}
{"id": "1618", "ref_py": ["def minimizeXor(self, num1: int, num2: int) -> int:\\n\\t\\t\\n\\t\\tnum1 = bin(num1)[2:].rjust(31,\\'0\\'),\\n        bitNum, ans =  bin(num2).count(\\'1\\'), [\\'0\\']*31", "def minimizeXor(self, num1: int, num2: int) -> int:\\n\\t\\t\\n\\t\\tnum1 = bin(num1)[2:].rjust(31,\\'0\\'),\\n        bitNum, ans =  bin(num2).count(\\'1\\'), [\\'0\\']*31", "def minimizeXor(self, num1: int, num2: int) -> int:\\n\\t\\t\\n\\t\\tnum1 = bin(num1)[2:].rjust(31,\\'0\\'),\\n        bitNum, ans =  bin(num2).count(\\'1\\'), [\\'0\\']*31"]}
{"id": "1619", "ref_py": ["def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [0] * len(pref)\\n        ans[0] = pref[0]\\n        for i in range(1, len(ans)):\\n            ans[i] = pref[i] ^ pref[i - 1]\\n        return ans\\n```\\n```Python []\\nclass Solution(object):\\n    def findArray(self, pref):\\n        ans = [0] * len(pref)\\n        ans[0] = pref[0]\\n        for i in range(1, len(ans)):\\n            ans[i] = pref[i] ^ pref[i - 1]\\n        return ans\\n```", "def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [0] * len(pref)\\n        ans[0] = pref[0]\\n        for i in range(1, len(ans)):\\n            ans[i] = pref[i] ^ pref[i - 1]\\n        return ans\\n```\\n```Python []\\nclass Solution(object):\\n    def findArray(self, pref):\\n        ans = [0] * len(pref)\\n        ans[0] = pref[0]\\n        for i in range(1, len(ans)):\\n            ans[i] = pref[i] ^ pref[i - 1]\\n        return ans\\n```", "def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [0] * len(pref)\\n        ans[0] = pref[0]\\n        for i in range(1, len(ans)):\\n            ans[i] = pref[i] ^ pref[i - 1]\\n        return ans\\n```\\n```Python []\\nclass Solution(object):\\n    def findArray(self, pref):\\n        ans = [0] * len(pref)\\n        ans[0] = pref[0]\\n        for i in range(1, len(ans)):\\n            ans[i] = pref[i] ^ pref[i - 1]\\n        return ans\\n```"]}
{"id": "1620", "ref_py": ["default value)", "default value)", "default value)"]}
{"id": "1621", "ref_py": ["def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        positions = []\\n        position = 0\\n        while n>0:\\n            if n &1 == 1:\\n                positions.append(position)\\n            \\n            position += 1\\n            n = n >> 1\\n        \\n        powers = []\\n        for i in range(len(positions)):\\n            powers.append(2**positions[i])\\n        \\n        partial_product = [powers[0] for i in range(len(powers))]\\n        for i in range(1,len(powers)):\\n            partial_product[i] = partial_product[i-1] * powers[i]\\n        \\n        \\n        ans = []\\n        for left,right in queries:\\n            if left==0:\\n                x = partial_product[right] % (10**9 + 7)\\n                ans.append(x)\\n            else:\\n                x = (partial_product[right]//partial_product[left-1])%(10**9 + 7)\\n                ans.append(x)\\n        \\n        return ans\\n            \\n            \\n               ", "def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        inp=bin(n).replace(\"0b\", \"\")        \\n        pows, result = [] , []\\n        multiple, N = 1, len(inp)\\n        for i in range(N - 1, -1, -1):                        \\n            if i < N - 1:\\n                multiple *= 2            \\n            if inp[i] == \\'1\\':\\n                pows.append(multiple)                \\n        for s, e in queries:\\n            tmp = 1\\n            for i in range(s, e + 1):\\n                tmp *= pows[i]\\n            result.append( tmp % ((10 ** 9) +7 ))              \\n        return result", "def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        inp=bin(n).replace(\"0b\", \"\")        \\n        pows, result = [] , []\\n        multiple, N = 1, len(inp)\\n        for i in range(N - 1, -1, -1):                        \\n            if i < N - 1:\\n                multiple *= 2            \\n            if inp[i] == \\'1\\':\\n                pows.append(multiple)                \\n        for s, e in queries:\\n            tmp = 1\\n            for i in range(s, e + 1):\\n                tmp *= pows[i]\\n            result.append( tmp % ((10 ** 9) +7 ))              \\n        return result"]}
{"id": "1622", "ref_py": ["def minimizeArrayValue(self, nums: List[int]) -> int:\\n        sm,mx = 0,0\\n        for i in range(len(nums)):\\n            sm += nums[i]\\n            mx = max(mx,(sm + i)//(i + 1))\\n        return mx\\n", "def minimizeArrayValue(self, nums: list[int]) -> int:\\n        return max(ceil(x / i) for i, x in enumerate(accumulate(nums), 1))", "def minimizeArrayValue(self, nums: list[int]) -> int:\\n        return max(ceil(x / i) for i, x in enumerate(accumulate(nums), 1))"]}
{"id": "1623", "ref_py": ["def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]", "def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]", "def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]"]}
{"id": "1624", "ref_py": ["def sumOfNumberAndReverse(self, num: int) -> bool:\\n        def reverse_digits(n):\\n            return int(str(n)[::-1])", "def sumOfNumberAndReverse(self, num: int) -> bool:\\n        if num <= 18:\\n\\t\\t   ", "def sumOfNumberAndReverse(self, num: int) -> bool:\\n        if num <= 18:\\n\\t\\t   "]}
{"id": "1625", "ref_py": ["def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```", "def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```", "def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```"]}
{"id": "1626", "ref_py": ["def twoEditWords(self, queries, dictionary):\\n        \\n        lst=[]\\n        val=Counter(queries)\\n        for i in queries:\\n            for j in dictionary:\\n                cnt=len(i)\\n                idx1=0\\n                while idx1<len(i):\\n                    if i[idx1]==j[idx1]:\\n                        cnt-=1\\n                    idx1+=1\\n                if cnt<=2 and val[i]!=0:\\n                    val[i]-=1\\n                    lst.append(i)\\n                    break\\n        return lst", "def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        a=[]\\n        s=set(dictionary)\\n        for i in queries:\\n            if i in s:\\n                a.append(i)\\n            else:\\n                for j in s:\\n                    c=0\\n                    for k in range(len(i)):\\n                        if i[k]!=j[k]:\\n                            c+=1\\n                    if c<=2:\\n                        a.append(i)\\n                        break\\n        return a\\n                \\n```", "def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        a=[]\\n        s=set(dictionary)\\n        for i in queries:\\n            if i in s:\\n                a.append(i)\\n            else:\\n                for j in s:\\n                    c=0\\n                    for k in range(len(i)):\\n                        if i[k]!=j[k]:\\n                            c+=1\\n                    if c<=2:\\n                        a.append(i)\\n                        break\\n        return a\\n                \\n```"]}
{"id": "1627", "ref_py": ["def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dct = dict() \\n        mx = 0 ", "def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dct = dict() \\n        mx = 0 ", "def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dct = dict() \\n        mx = 0 "]}
{"id": "1628", "ref_py": ["def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()", "def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()", "def reformatDate(self, date: str) -> str:\\n        day, month, year = date.split()"]}
{"id": "1629", "ref_py": ["def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```", "def sortedSquares(self, nums):\\n        result = [0]*len(nums)\\n        i = 0\\n        j = len(nums)-1\\n        k = len(nums)-1\\n        while k>=0:\\n            if nums[i]*nums[i] <= nums[j]*nums[j]:\\n                result[k] = nums[j]*nums[j]\\n                k-=1\\n                j-=1\\n            else:\\n                result[k] = nums[i]*nums[i]\\n                i+=1\\n                k-=1\\n        return result        ", "def getAbsMin(lst):\\n    \\n    l, r = 0, len(lst) - 1\\n    while l <= r:\\n        mid = l + (r - l) // 2\\n        if lst[mid] == 0:L\\n            return mid\\n        elif lst[mid] < 0:\\n            l = mid + 1\\n        elif lst[mid] > 0:\\n            r = mid -1\\n    return l\\nprint(getAbsMin([-4,-1,2,3,10]))\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        minVal = -1\\n        ans = []\\n        j = getAbsMin(nums)\\n        i = j -1\\n        while i != -1 and j != len(nums):\\n            if nums[i]**2 < nums[j]**2:\\n                ans.append(nums[i]**2)\\n                i-=1\\n            else:\\n                ans.append(nums[j]**2)\\n                j+=1\\n        while i != -1:\\n            ans.append(nums[i]**2)\\n            i-=1\\n        while j != len(nums):\\n            ans.append(nums[j]**2)\\n            j+=1"]}
{"id": "1630", "ref_py": ["def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        @cache\\n        def get_left(i):\\n            if i - 1 >= 0 and security[i - 1] >= security[i]:\\n                return get_left(i - 1) + 1\\n            return 0", "def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        ", "def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        "]}
{"id": "1631", "ref_py": ["def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        l, r = candidates, n - candidates - 1", "def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        l, r = candidates, n - candidates - 1", "def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\\n        n = len(costs)\\n        l, r = candidates, n - candidates - 1"]}
{"id": "1632", "ref_py": ["def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tdp = [0]*(high+1)  ", "def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        @cache\\n        def dp(length: int) -> int:\\n            if length > high:\\n                return 0\\n            return (\\n                    int(low <= length) +\\n                    dp(length + zero) +\\n                    dp(length + one)\\n            ) % self.MOD", "def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tdp = [0]*(high+1)  "]}
{"id": "1633", "ref_py": ["def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n        \\n        n=len(nums)\\n        dp=[[[-1 for _ in range(k+1)] for _ in range(n+1)] for _ in range(n+1)]\\n        \\n        def recur(i,j,par):\\n            ", "def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\tn = len(nums)\\n\\tpre = [0]\\n\\tfor i in nums:\\n\\t\\tpre.append(pre[-1] + i)\\n\\tdef solve(i, k):\\n\\t\\tif(k == 1): return sum(nums[i:])/(n-i)", "def largestSumOfAverages(self, nums: List[int], k: int) -> float:\\n\\tn = len(nums)\\n\\tpre = [0]\\n\\tfor i in nums:\\n\\t\\tpre.append(pre[-1] + i)\\n\\tdef solve(i, k):\\n\\t\\tif(k == 1): return sum(nums[i:])/(n-i)"]}
{"id": "1634", "ref_py": ["def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)", "def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)", "def lcm(self,a, b):\\n        return abs(a*b) // math.gcd(a, b)"]}
{"id": "1635", "ref_py": ["def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\\n        products.sort()\\n        n=len(products)\\n        indices=[i for i in range(n)]\\n        res=[]\\n        for idx, c in enumerate(searchWord):\\n            indices = [i for i in indices if len(products[i])>idx and products[i][idx] == c]                                                                \\n            res.append(products[i] for i in indices[:3])        \\n        return res        \\n```", "def suggestedProducts(self, P: List[str], S: str) -> List[List[str]]:\\n        P.sort()\\n        ans, left, right = [], 0, len(P) - 1\\n        for i in range(len(S)):\\n            c, res = S[i], []\\n            while left <= right and (len(P[left]) == i or P[left][i] < c): left += 1\\n            while left <= right and (len(P[right]) == i or P[right][i] > c): right -= 1\\n            for j in range(3):\\n                if left + j > right: break\\n                else: res.append(P[left+j])\\n            ans.append(res)\\n        return ans\\n```", "def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\\n        products.sort()\\n        n=len(products)\\n        indices=[i for i in range(n)]\\n        res=[]\\n        for idx, c in enumerate(searchWord):\\n            indices = [i for i in indices if len(products[i])>idx and products[i][idx] == c]                                                                \\n            res.append(products[i] for i in indices[:3])        \\n        return res        \\n```"]}
{"id": "1636", "ref_py": ["def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        ", "def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        ", "def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\\n        "]}
{"id": "1637", "ref_py": ["defaultdict", "defaultdict", "defaultdict"]}
{"id": "1638", "ref_py": ["def onesMinusZeros(self, grid):\\n        m, n = len(grid), len(grid[0])", "def onesMinusZeros(self, grid):\\n        m, n = len(grid), len(grid[0])", "def onesMinusZeros(self, grid):\\n        m, n = len(grid), len(grid[0])"]}
{"id": "1639", "ref_py": ["def bestClosingTime(self, customers: str) -> int:", "def bestClosingTime(self, customers: str) -> int:\\n        max_score = 0\\n        score = 0\\n        right_time = -1\\n        for i in range(len(customers)):\\n            score += 1 if customers[i] == \\'Y\\' else -1\\n            if score > max_score:\\n                max_score = score\\n                right_time = i\\n        return right_time + 1\\n```\\n", "def bestClosingTime(self, customers: str) -> int:\\n        max_score = 0\\n        score = 0\\n        right_time = -1\\n        for i in range(len(customers)):\\n            score += 1 if customers[i] == \\'Y\\' else -1\\n            if score > max_score:\\n                max_score = score\\n                right_time = i\\n        return right_time + 1\\n```\\n"]}
{"id": "1640", "ref_py": ["def appendCharacters(self, s: str, t: str) -> int:\\n \\n        tLen, i = len(t), 0             ", "def appendCharacters(self, s: str, t: str) -> int:\\n \\n        tLen, i = len(t), 0             ", "def appendCharacters(self, s: str, t: str) -> int:\\n \\n        tLen, i = len(t), 0             "]}
{"id": "1641", "ref_py": ["def __init__(self, val=0, next=None):\\n", "def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:", "def __init__(self, val=0, next=None):\\n"]}
{"id": "1642", "ref_py": ["def divide(self, dividend, divisor):\\n        \\n        if abs(divisor) == 1:\\n            dividend = divisor * dividend\\n            if dividend > 2**31 - 1:\\n                return 2**31 - 1", "def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result", "def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result"]}
{"id": "1643", "ref_py": ["def minScore(self, n, roads):", "def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ans = maxsize\\n        gr = [[] for _ in range(n+1)]\\n        for edge in roads:\\n            gr[edge[0]].append((edge[1], edge[2])) ", "def minScore(self, n, roads):"]}
{"id": "1644", "ref_py": ["def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n    if k == 0:\\n      return max(vals)", "def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n    if k == 0:\\n      return max(vals)", "def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\\n    if k == 0:\\n      return max(vals)"]}
{"id": "1645", "ref_py": ["def buddyStrings(self, s, goal):\\n        ind = []", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        c1=Counter(s)\\n        c2=Counter(goal)\\n        if c1!=c2:\\n            return False", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False"]}
{"id": "1646", "ref_py": ["def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        seen = {}\\n        ans = -1", "def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        seen = {}\\n        ans = -1", "def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        seen = {}\\n        ans = -1"]}
{"id": "1648", "ref_py": ["def smallestValue(self, n: int) -> int:\\n        while n != (n:=self.factorization(n)) pass\\n        return n\\n    \\n    def factorization(self, n):\\n        factors_sum = 0\\n        i = 2\\n        while n > 1:\\n            while n % i == 0:\\n                n //= i\\n                factors_sum +=i\\n            i += 1\\n        return factors_sum\\n        \\n        \\n```\\n", "def smallestValue(self, n):\\n        \\n        ans = []\\n        if n == 4:\\n            return 4\\n        while len(ans) != 1:\\n              ans = []\\n              self.primeFactors(n, ans)\\n              n = sum(ans)\\n        \\n        return ans[0]\\n        \\n    def primeFactors(self, n, ans):\\n        while n % 2 == 0:\\n            ans.append(2)\\n            n = n / 2", "def smallestValue(self, n):\\n        \\n        ans = []\\n        if n == 4:\\n            return 4\\n        while len(ans) != 1:\\n              ans = []\\n              self.primeFactors(n, ans)\\n              n = sum(ans)\\n        \\n        return ans[0]\\n        \\n    def primeFactors(self, n, ans):\\n        while n % 2 == 0:\\n            ans.append(2)\\n            n = n / 2"]}
{"id": "1649", "ref_py": ["def maxRepOpt1(S):\\n    \\n    ", "def maxRepOpt1(self, text: str) -> int:\\n        total = [0] * 26\\n        win = [0] * 26\\n        distinct = 0\\n        left = 0\\n        ans = 0\\n        for x in text: total[ord(x) - ord(\\'a\\')] += 1\\n        \\n        for i, x in enumerate(text):\\n            \\n            if win[ord(x) - ord(\\'a\\')] == 0: distinct += 1\\n            win[ord(x) - ord(\\'a\\')] += 1\\n            total[ord(x) - ord(\\'a\\')] -= 1\\n            \\n            while distinct > 2 or distinct == 2 and min(y for y in win if y) > 1:\\n                win[ord(text[left]) - ord(\\'a\\')] -= 1\\n                if win[ord(text[left]) - ord(\\'a\\')] == 0: distinct -= 1\\n                total[ord(text[left]) - ord(\\'a\\')] += 1\\n                left += 1\\n            ans = max(ans, i - left + 1 - (distinct == 2) + (total[max(range(26), key=lambda x: win[x])] > 0))", "def maxRepOpt1(self, text: str) -> int:\\n        total = [0] * 26\\n        win = [0] * 26\\n        distinct = 0\\n        left = 0\\n        ans = 0\\n        for x in text: total[ord(x) - ord(\\'a\\')] += 1\\n        \\n        for i, x in enumerate(text):\\n            \\n            if win[ord(x) - ord(\\'a\\')] == 0: distinct += 1\\n            win[ord(x) - ord(\\'a\\')] += 1\\n            total[ord(x) - ord(\\'a\\')] -= 1\\n            \\n            while distinct > 2 or distinct == 2 and min(y for y in win if y) > 1:\\n                win[ord(text[left]) - ord(\\'a\\')] -= 1\\n                if win[ord(text[left]) - ord(\\'a\\')] == 0: distinct -= 1\\n                total[ord(text[left]) - ord(\\'a\\')] += 1\\n                left += 1\\n            ans = max(ans, i - left + 1 - (distinct == 2) + (total[max(range(26), key=lambda x: win[x])] > 0))"]}
{"id": "1650", "ref_py": ["def simplifyPath(self, path):\\n         ", "def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)", "def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)"]}
{"id": "1651", "ref_py": ["def takeCharacters(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = Counter(s)\\n\\t\\t\\ts = s+s \\n\\t\\t\\tn = len(s) ", "def takeCharacters(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = Counter(s)\\n\\t\\t\\ts = s+s \\n\\t\\t\\tn = len(s) ", "def takeCharacters(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = Counter(s)\\n\\t\\t\\ts = s+s \\n\\t\\t\\tn = len(s) "]}
{"id": "1652", "ref_py": ["def countGoodNumbers(self, n: int) -> int:\\n        ans = 1\\n        rem = n % 2\\n        n -= rem\\n        ans = pow(20, n//2, 10**9 + 7)\\n        if rem == 1:\\n            ans *= 5\\n        return ans % (10**9 + 7)\\n```\\n**Note:** It can be solved in constant time, by using math.pow funtion.", "def countGoodNumbers(self, n: int) -> int:\\n        mod = 1000000007\\n        odd = n//2\\n        even = n//2 + n%2\\n        return (self.binaryExp(5, even)%mod *self.binaryExp(4, odd)%mod)%mod\\n    \\n    def binaryExp(self, x, n):\\n        mod = 1000000007\\n        if n==0:\\n            return 1\\n        if n < 0:\\n            return 1/self.binaryExp(x, -n)\\n        \\n        if n%2==0:\\n            return self.binaryExp((x*x)%mod, n//2)\\n        else:\\n            return x * self.binaryExp((x*x)%mod, (n-1)//2)\\n        ", "def countGoodNumbers(self, n: int) -> int:\\n        ans = 1\\n        rem = n % 2\\n        n -= rem\\n        ans = pow(20, n//2, 10**9 + 7)\\n        if rem == 1:\\n            ans *= 5\\n        return ans % (10**9 + 7)\\n```\\n**Note:** It can be solved in constant time, by using math.pow funtion."]}
{"id": "1653", "ref_py": ["def distinctPrimeFactors(self, nums: List[int]) -> int:", "def distinctPrimeFactors(self, nums: List[int]) -> int:", "def distinctPrimeFactors(self, nums: List[int]) -> int:"]}
{"id": "1654", "ref_py": ["def minimumPartition(self, s: str, k: int) -> int:\\n        ", "def minimumPartition(self, s: str, k: int) -> int:\\n        ", "def minimumPartition(self, s: str, k: int) -> int:\\n        "]}
{"id": "1655", "ref_py": ["def closestPrimes(self, left: int, right: int) -> list[int]:\\n        sieve = [False] * (right+1)\\n        \\n        last_prime = -1\\n        result = [-1, -1]\\n        for p in range(2, right+1):\\n            if not sieve[p]:\\n                for p2 in range(p*2, right+1, p):\\n                    sieve[p2] = True\\n                if left <= p <= right:\\n                    if last_prime == -1:\\n                        last_prime = p\\n                    elif result == [-1, -1]:\\n                        result = [last_prime, p]\\n                    elif p - last_prime < result[1] - result[0]:\\n                        result = [last_prime, p]\\n                    last_prime = p\\n        return result", "def closestPrimes(self, left: int, right: int) -> list[int]:\\n        sieve = [False] * (right+1)\\n        \\n        last_prime = -1\\n        result = [-1, -1]\\n        for p in range(2, right+1):\\n            if not sieve[p]:\\n                for p2 in range(p*2, right+1, p):\\n                    sieve[p2] = True\\n                if left <= p <= right:\\n                    if last_prime == -1:\\n                        last_prime = p\\n                    elif result == [-1, -1]:\\n                        result = [last_prime, p]\\n                    elif p - last_prime < result[1] - result[0]:\\n                        result = [last_prime, p]\\n                    last_prime = p\\n        return result", "def closestPrimes(self, left: int, right: int) -> list[int]:\\n        sieve = [False] * (right+1)\\n        \\n        last_prime = -1\\n        result = [-1, -1]\\n        for p in range(2, right+1):\\n            if not sieve[p]:\\n                for p2 in range(p*2, right+1, p):\\n                    sieve[p2] = True\\n                if left <= p <= right:\\n                    if last_prime == -1:\\n                        last_prime = p\\n                    elif result == [-1, -1]:\\n                        result = [last_prime, p]\\n                    elif p - last_prime < result[1] - result[0]:\\n                        result = [last_prime, p]\\n                    last_prime = p\\n        return result"]}
{"id": "1657", "ref_py": ["def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```", "def xorBeauty(self, nums: list[int]) -> int:\\n        beauty = 0", "def xorBeauty(self, nums: list[int]) -> int:\\n        beauty = 0"]}
{"id": "1658", "ref_py": ["def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        ", "def reverseVowels(self, s):\\n        "]}
{"id": "1659", "ref_py": ["def isItPossible(self, word1: str, word2: str) -> bool:\\n        d1 = Counter(word1)\\n        d2 = Counter(word2)\\n        \\n        ", "def insertAndRemove(self, mp, toInsert, toRemove): \\n        mp[toInsert]+=1\\n        mp[toRemove]-=1\\n        \\n        if(mp[toRemove]==0):\\n            del mp[toRemove]     ", "def isItPossible(self, word1: str, word2: str) -> bool:\\n        d1 = Counter(word1)\\n        d2 = Counter(word2)\\n        \\n        "]}
{"id": "1660", "ref_py": ["def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```", "def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```", "def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```"]}
{"id": "1661", "ref_py": ["def countGood(self, A: List[int], k: int) -> int:\\n        res = cur = i = 0\\n        count = Counter()\\n        for j in range(len(A)):\\n            k -= count[A[j]]\\n            count[A[j]] += 1\\n            while k <= 0:\\n                count[A[i]] -= 1\\n                k += count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```\\n<br>", "def countGood(self, A: List[int], k: int) -> int:\\n        res = cur = i = 0\\n        count = Counter()\\n        for j in range(len(A)):\\n            k -= count[A[j]]\\n            count[A[j]] += 1\\n            while k <= 0:\\n                count[A[i]] -= 1\\n                k += count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```\\n<br>", "def countGood(self, A: List[int], k: int) -> int:\\n        res = cur = i = 0\\n        count = Counter()\\n        for j in range(len(A)):\\n            k -= count[A[j]]\\n            count[A[j]] += 1\\n            while k <= 0:\\n                count[A[i]] -= 1\\n                k += count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```\\n<br>"]}
{"id": "1662", "ref_py": ["def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if nums1 == nums2:\\n            return 0", "def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    if k == 0:\\n      return 0 if nums1 == nums2 else -1", "def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    if k == 0:\\n      return 0 if nums1 == nums2 else -1"]}
{"id": "1663", "ref_py": ["def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res, prefixSum, minHeap = 0, 0, []\\n        \\n        for a, b in sorted(list(zip(nums1, nums2)), key=itemgetter(1), reverse=True):\\n            prefixSum += a\\n            heappush(minHeap, a)\\n            if len(minHeap) == k:\\n                res = max(res, prefixSum * b)\\n                prefixSum -= heappop(minHeap)                               \\n        \\n        return res\\n```\\n![Screenshot 2023-10-07 at 18.04.38.png](https://assets.leetcode.com/users/images/a3554218-80fe-4fb7-8193-c4eeb252b5d0_1696691096.3730836.png)", "def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\t\\t\\t", "def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res, prefixSum, minHeap = 0, 0, []\\n        \\n        for a, b in sorted(list(zip(nums1, nums2)), key=itemgetter(1), reverse=True):\\n            prefixSum += a\\n            heappush(minHeap, a)\\n            if len(minHeap) == k:\\n                res = max(res, prefixSum * b)\\n                prefixSum -= heappop(minHeap)                               \\n        \\n        return res\\n```\\n![Screenshot 2023-10-07 at 18.04.38.png](https://assets.leetcode.com/users/images/a3554218-80fe-4fb7-8193-c4eeb252b5d0_1696691096.3730836.png)"]}
{"id": "1664", "ref_py": ["def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(score, key=lambda s:s[k], reverse=True)\\n```", "def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(score, key=lambda s:s[k], reverse=True)\\n```", "def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\\n        return sorted(score, key=lambda s:s[k], reverse=True)\\n```"]}
{"id": "1665", "ref_py": ["def makeStringsEqual(self, s, t):\\n        return (\\'1\\' in s) == (\\'1\\' in t)\\n```\\n<br>", "def makeStringsEqual(self, s: str, target: str) -> bool:\\n        return \\'1\\' in s and \\'1\\' in target or \\'1\\' not in target and \\'1\\' not in s\\n```", "def makeStringsEqual(self, s, t):\\n        return (\\'1\\' in s) == (\\'1\\' in t)\\n```\\n<br>"]}
{"id": "1666", "ref_py": ["def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```\\n", "def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```\\n", "def monkeyMove(self, n: int) -> int:\\n        return (pow(2, n, 1000000007) - 2) % 1000000007\\n```\\n"]}
{"id": "1667", "ref_py": ["def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))"]}
{"id": "1668", "ref_py": ["def maximizeWin(self, A, k):\\n        dp = [0] * (len(A) + 1)\\n        res = j = 0\\n        for i, a in enumerate(A):\\n            while A[j] < A[i] - k: j += 1\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n            res = max(res, i - j + 1 + dp[j])\\n        return res\\n```\\n<br>", "def maximizeWin(self, prizePositions, k):\\n        \\n        N = len(prizePositions)\\n        head, left_edge, right_edge, curr_left, curr_right, best_right, best = N-1, N, N-1, 1, 0, 0, 0\\n        \\n        while head >= 0:\\n            curr_left -= 1\\n            while (left_edge > 0) and (prizePositions[head] - prizePositions[left_edge - 1] <= k):\\n                left_edge -= 1\\n                curr_left += 1\\n            best = max(best, best_right + curr_left)\\n            curr_right += 1\\n            while prizePositions[right_edge] - prizePositions[head] > k:\\n                curr_right -= 1\\n                right_edge -= 1\\n            best_right = max(best_right, curr_right)\\n            head -= 1\\n        return best", "def maximizeWin(self, A, k):\\n        dp = [0] * (len(A) + 1)\\n        res = j = 0\\n        for i, a in enumerate(A):\\n            while A[j] < A[i] - k: j += 1\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n            res = max(res, i - j + 1 + dp[j])\\n        return res\\n```\\n<br>"]}
{"id": "1669", "ref_py": ["def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n == 2:\\n            return False\\n        \\n        \\n        def dfs(i=0,j=0):\\n            if i == m-1 and j == n-1:\\n                return True\\n            \\n            if i >= m or j >= n or grid[i][j]==0:\\n                return False\\n            \\n            grid[i][j]=0 ", "def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        def dfs(x, y):\\n            \\n            if x == len(grid) - 1 and y == len(grid[0]) - 1:\\n                grid[x][y] = 2\\n                return True\\n            \\n            if grid[x][y] == 2:\\n                return True\\n            grid[x][y] = 0\\n            for dx, dy in ((1, 0), (0, 1)):\\n                new_x, new_y = x + dx, y + dy\\n                if new_x < 0 or new_x >= len(grid) or new_y < 0 or new_y >= len(grid[0]) or grid[new_x][new_y] == 0:\\n                    continue\\n                elif grid[new_x][new_y] == 2:\\n                    grid[x][y] = 2\\n                elif grid[new_x][new_y] == 1 and dfs(new_x, new_y):\\n                    grid[x][y] = 2\\n            return grid[x][y] == 2\\n        \\n        dfs(0, 0)\\n        \\n        q = deque([(0,0)])\\n        visited = set([(0,0)])", "def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n == 2:\\n            return False\\n        \\n        \\n        def dfs(i=0,j=0):\\n            if i == m-1 and j == n-1:\\n                return True\\n            \\n            if i >= m or j >= n or grid[i][j]==0:\\n                return False\\n            \\n            grid[i][j]=0 "]}
{"id": "1670", "ref_py": ["def minPairSum(self, nums):\\n        nums.sort()\\n        sum = []\\n        for num in range(0,len(nums)):\\n            sum.append(nums[num] + nums[len(nums)-num-1])\\n        sum.sort(reverse = True)\\n        return sum[0]", "def minPairSum(self, nums):\\n        nums.sort()\\n        \\n        min_max_sum = 0\\n        for i in range(len(nums) // 2):\\n            min_max_sum = max(min_max_sum, nums[i] + nums[len(nums) - 1 - i])\\n            \\n        return min_max_sum\\n```", "def minPairSum(self, nums):\\n        nums.sort()\\n        \\n        min_max_sum = 0\\n        for i in range(len(nums) // 2):\\n            min_max_sum = max(min_max_sum, nums[i] + nums[len(nums) - 1 - i])\\n            \\n        return min_max_sum\\n```"]}
{"id": "1671", "ref_py": ["def minCapability(self, A: List[int], k: int) -> int:\\n        l, r = min(A), max(A)\\n        while l < r:\\n            m = (l + r) // 2\\n            last = take = 0\\n            for a in A:\\n                if last:\\n                    last = 0\\n                    continue\\n                if a <= m:\\n                    take += 1\\n                    last = 1\\n            if take >= k:\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```", "def minCapability(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        def good(target):\\n            count=0\\n            i=0", "def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(cap):\\n            kk = i = 0\\n            while i < len(nums) and kk < k:\\n                if nums[i] <= cap:\\n                    kk += 1\\n                    i += 2\\n                else:\\n                    i += 1\\n            \\n            return kk == k"]}
{"id": "1672", "ref_py": ["def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum(\\n            bisect(nums, upper - num, hi=i) - bisect_left(nums, lower - num, hi=i)\\n            for i, num in enumerate(nums)\\n        )", "def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum(\\n            bisect(nums, upper - num, hi=i) - bisect_left(nums, lower - num, hi=i)\\n            for i, num in enumerate(nums)\\n        )", "def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\\n        nums.sort()\\n        return sum(\\n            bisect(nums, upper - num, hi=i) - bisect_left(nums, lower - num, hi=i)\\n            for i, num in enumerate(nums)\\n        )"]}
{"id": "1673", "ref_py": ["def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        m = defaultdict(lambda: [-1, -1])\\n        for i, ch in enumerate(s):\\n            val = 0\\n            for j in range(i, min(i + 30, len(s))):\\n                val = val * 2 + ord(s[j]) - ord(\"0\")\\n                if val not in m:\\n                    m[val] = [i, j]\\n                if ch == \"0\":\\n                    break\\n        return [m[f ^ s] for f, s in queries] \\n```", "def substringXorQueries(self, s, queries):\\n        \\n        df = {}\\n        n = len(s)\\n        for i in range(n-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                df[0] = [i,i]\\n                continue\\n            for j in range(min(n,i+30), i, -1):\\n                df[int(s[i:j],2)] = [i,j-1]", "def substringXorQueries(self, s, queries):\\n        \\n        df = {}\\n        n = len(s)\\n        for i in range(n-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                df[0] = [i,i]\\n                continue\\n            for j in range(min(n,i+30), i, -1):\\n                df[int(s[i:j],2)] = [i,j-1]"]}
{"id": "1674", "ref_py": ["def minimizeSum(self, nums: list[int]) -> int:\\n        s_nums = sorted(nums)\\n        k = 2\\n        return min(\\n            s_nums[i] - s_nums[j]\\n            for i, j in zip(range(-1, -k - 2, -1), range(k, -1, -1))\\n        )", "def minimizeSum(self, nums: list[int]) -> int:\\n        s_nums = sorted(nums)\\n        k = 2\\n        return min(\\n            s_nums[i] - s_nums[j]\\n            for i, j in zip(range(-1, -k - 2, -1), range(k, -1, -1))\\n        )", "def minimizeSum(self, nums: list[int]) -> int:\\n        s_nums = sorted(nums)\\n        k = 2\\n        return min(\\n            s_nums[i] - s_nums[j]\\n            for i, j in zip(range(-1, -k - 2, -1), range(k, -1, -1))\\n        )"]}
{"id": "1675", "ref_py": ["def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        impossible = 1", "def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        impossible = 1", "def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        impossible = 1"]}
{"id": "1676", "ref_py": ["def minOperations(self, n: int) -> int:\\n        res = 0\\n        while n > 0:\\n            if n % 2 == 0:\\n                n >>= 1\\n            elif (n & 2) > 0:\\n                n += 1\\n                res += 1\\n            else:\\n                res += 1\\n                n >>= 2\\n        return res\\n```\\n<br>", "def minOperations(self, n: int) -> int:\\n        bin_rep = bin(n)[2:]\\n        num_ops = 0\\n        consecutive_ones = 0\\n        for i in range(len(bin_rep)-1,-1,-1):\\n            if bin_rep[i] == \"1\":\\n                consecutive_ones += 1\\n            else:\\n                if consecutive_ones == 1:\\n                    consecutive_ones = 0\\n                    num_ops += 1\\n                elif consecutive_ones > 1:\\n                    consecutive_ones = 1\\n                    num_ops += 1\\n        if consecutive_ones == 1:\\n            num_ops += 1\\n        elif consecutive_ones > 1:\\n            num_ops += 2\\n        return num_ops\\n```", "def minOperations(self, n: int) -> int:\\n        bin_rep = bin(n)[2:]\\n        num_ops = 0\\n        consecutive_ones = 0\\n        for i in range(len(bin_rep)-1,-1,-1):\\n            if bin_rep[i] == \"1\":\\n                consecutive_ones += 1\\n            else:\\n                if consecutive_ones == 1:\\n                    consecutive_ones = 0\\n                    num_ops += 1\\n                elif consecutive_ones > 1:\\n                    consecutive_ones = 1\\n                    num_ops += 1\\n        if consecutive_ones == 1:\\n            num_ops += 1\\n        elif consecutive_ones > 1:\\n            num_ops += 2\\n        return num_ops\\n```"]}
{"id": "1677", "ref_py": ["definitely too long. But this time complexity can be heavily minimized!", "definitely too long. But this time complexity can be heavily minimized!", "definitely too long. But this time complexity can be heavily minimized!"]}
{"id": "1678", "ref_py": ["def divisibilityArray(self, word: str, m: int) -> List[int]:", "def divisibilityArray(self, word: str, m: int) -> List[int]:", "def divisibilityArray(self, word: str, m: int) -> List[int]:"]}
{"id": "1679", "ref_py": ["def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        nums.sort()\\n        for j in range(n//2,n):\\n            i+= nums[j]>=nums[i]*2\\n        return i*2\\n```\\nSolution credits: @votrubac", "def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        for j in range((len(nums) + 1)// 2, len(nums)):\\n            if nums[i] * 2 <= nums[j]: i+=1\\n        return 2 * i\\n```", "def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=0\\n        nums.sort()\\n        for j in range(n//2,n):\\n            i+= nums[j]>=nums[i]*2\\n        return i*2\\n```\\nSolution credits: @votrubac"]}
{"id": "1680", "ref_py": ["def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```", "def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```", "def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```"]}
{"id": "1681", "ref_py": ["def maxEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        total_days = max(end for start, end in events)\\n        day = 0\\n        event_id = 0\\n        num_events_attended = 0\\n        min_heap = []\\n        \\n        for day in range(1, total_days+1):\\n            ", "def maxEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        total_days = max(end for start, end in events)\\n        day = 0\\n        event_id = 0\\n        num_events_attended = 0\\n        min_heap = []\\n        \\n        for day in range(1, total_days+1):\\n            ", "def maxEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        total_days = max(end for start, end in events)\\n        day = 0\\n        event_id = 0\\n        num_events_attended = 0\\n        min_heap = []\\n        \\n        for day in range(1, total_days+1):\\n            "]}
{"id": "1682", "ref_py": ["def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        def dfs(node, d):\\n            if not node:\\n                return\\n            levels[d] += node.val\\n            dfs(node.left, d + 1)\\n            dfs(node.right, d + 1)\\n            \\n        levels = defaultdict(int)\\n        dfs(root, 0)", "def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        def dfs(node, d):\\n            if not node:\\n                return\\n            levels[d] += node.val\\n            dfs(node.left, d + 1)\\n            dfs(node.right, d + 1)\\n            \\n        levels = defaultdict(int)\\n        dfs(root, 0)", "def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        def dfs(node, d):\\n            if not node:\\n                return\\n            levels[d] += node.val\\n            dfs(node.left, d + 1)\\n            dfs(node.right, d + 1)\\n            \\n        levels = defaultdict(int)\\n        dfs(root, 0)"]}
{"id": "1683", "ref_py": ["def maxScore(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse =True)\\n        \\n        prefix = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[-1] + nums[i])\\n        \\n        count  = 0\\n        \\n        for i in prefix:\\n            if i > 0:\\n                count +=1\\n        \\n        return count\\n```", "def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        prefix_sums = [0]\\n        for num in nums:\\n            prefix_sums.append(prefix_sums[-1] + num)\\n        max_score = 0\\n        for i in range(1, len(prefix_sums)):\\n            if prefix_sums[i] > 0:\\n                max_score = i\\n        return max_score", "def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        prefix_sums = [0]\\n        for num in nums:\\n            prefix_sums.append(prefix_sums[-1] + num)\\n        max_score = 0\\n        for i in range(1, len(prefix_sums)):\\n            if prefix_sums[i] > 0:\\n                max_score = i\\n        return max_score"]}
{"id": "1684", "ref_py": ["def beautifulSubarrays(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        pre_xor = [0] * (n+1)\\n        pre_xor[0]=0\\n        cnt = [0]*(1<<20)\\n        cnt[0] = 1\\n        \\n        for i in range(1,n+1):\\n            pre_xor[i] = pre_xor[i-1] ^ nums[i-1]\\n            res += cnt[pre_xor[i]]\\n            cnt[pre_xor[i]] += 1", "def beautifulSubarrays(self, nums: List[int]) -> int:\\n        count = 0\\n        xor = 0\\n        d = defaultdict(int)\\n        d[0] = 1\\n        \\n        for num in nums:\\n            xor ^= num\\n            \\n            count += d[xor]\\n            \\n            d[xor] += 1\\n            \\n        return count;\\n```", "def beautifulSubarrays(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        pre_xor = [0] * (n+1)\\n        pre_xor[0]=0\\n        cnt = [0]*(1<<20)\\n        cnt[0] = 1\\n        \\n        for i in range(1,n+1):\\n            pre_xor[i] = pre_xor[i-1] ^ nums[i-1]\\n            res += cnt[pre_xor[i]]\\n            cnt[pre_xor[i]] += 1"]}
{"id": "1685", "ref_py": ["def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0", "def maximizeGreatness(self, A):\\n        A.sort()\\n        res = 0\\n        for a in A:\\n            if a > A[res]:\\n                res += 1\\n        return res\\n```\\n<br>", "def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0"]}
{"id": "1686", "ref_py": ["defaultdict", "defaultdict", "defaultdict"]}
{"id": "1687", "ref_py": ["def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def check(maxtime):\\n            total=0\\n            for i in range(len(ranks)):\\n                total+=int(sqrt(maxtime//ranks[i]))\\n                if(total>=cars):\\n                    return True\\n            return False\\n        left=0\\n        right=cars*cars*max(ranks)\\n        ans=-1\\n        while(left<=right):\\n            mid=left+(right-left)//2\\n            if(check(mid)):\\n                ans=mid\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return ans", "def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def check(maxtime):\\n            total=0\\n            for i in range(len(ranks)):\\n                total+=int(sqrt(maxtime//ranks[i]))\\n                if(total>=cars):\\n                    return True\\n            return False\\n        left=0\\n        right=cars*cars*max(ranks)\\n        ans=-1\\n        while(left<=right):\\n            mid=left+(right-left)//2\\n            if(check(mid)):\\n                ans=mid\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return ans", "def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def check(maxtime):\\n            total=0\\n            for i in range(len(ranks)):\\n                total+=int(sqrt(maxtime//ranks[i]))\\n                if(total>=cars):\\n                    return True\\n            return False\\n        left=0\\n        right=cars*cars*max(ranks)\\n        ans=-1\\n        while(left<=right):\\n            mid=left+(right-left)//2\\n            if(check(mid)):\\n                ans=mid\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return ans"]}
{"id": "1688", "ref_py": ["def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])", "def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:", "def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort(key=lambda x: x[0])\\n        prefix = [0]\\n        for _, b in items:\\n            prefix.append(max(b, prefix[-1]))\\n        \\n        ans = []\\n        for p in queries:\\n            t = bisect_right(items, p, key=lambda x:x[0])\\n            ans.append(prefix[t])\\n        return ans\\n```\\n"]}
{"id": "1689", "ref_py": ["def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        frequencyMap = {}\\n        for num in nums:\\n            frequencyMap[num] = frequencyMap.get(num, 0) + 1", "def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        frequencyMap = {}\\n        for num in nums:\\n            frequencyMap[num] = frequencyMap.get(num, 0) + 1", "def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        frequencyMap = {}\\n        for num in nums:\\n            frequencyMap[num] = frequencyMap.get(num, 0) + 1"]}
{"id": "1690", "ref_py": ["def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        ", "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n\\t\\t", "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        "]}
{"id": "1691", "ref_py": ["def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime=[True]*1001\\n        prime[0]=prime[1]=False\\n        for x in range(2,1001):\\n            if prime[x]:\\n                for i in range(x*x,1001,x):\\n                    prime[i]=False", "def isprime(self, num):\\n        \\n        for i in range(2, math.ceil(math.sqrt(num+1))):\\n            if num%i==0:\\n                return False\\n        return True\\n        \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        prims = [i for i in range(2,1001) if self.isprime(i)]\\n        \\n        ", "def isprime(self, num):\\n        \\n        for i in range(2, math.ceil(math.sqrt(num+1))):\\n            if num%i==0:\\n                return False\\n        return True\\n        \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        prims = [i for i in range(2,1001) if self.isprime(i)]\\n        \\n        "]}
{"id": "1692", "ref_py": ["def minOperations(self,nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        aug = [(q, i) for i, q in enumerate(queries)]\\n        aug.sort()\\n        total = sum(nums)\\n        prefix = 0\\n        k = 0\\n        ans = [0] * len(queries)\\n        for q, i in aug:\\n            while k < len(nums) and nums[k] < q:\\n                prefix += nums[k]\\n                k += 1\\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\\n        return ans\\n```\\n```java []\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n        int n = nums.length,m = queries.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        long[] psum = new long[n + 1];\\n        for(int i = 0;i < n;i++) psum[i + 1] = psum[i] + nums[i];\\n        \\n        List<Long> ans = new ArrayList<>();\\n        \\n        for(int i = 0;i < m;i++){\\n            \\n            int si = 0,ei = n - 1,idx = 0;\\n            while(si <= ei){\\n                int mid = si + (ei - si) / 2;\\n                \\n                if(nums[mid] <= queries[i]){\\n                    idx = mid + 1;\\n                    si = mid + 1;\\n                }else{\\n                    idx = mid;\\n                    ei = mid - 1;\\n                }\\n            }\\n            \\n            long left = (1L * queries[i] * idx) - psum[si]; \\n            long right = (psum[n] - psum[idx]) - (1L * queries[i] * (n - idx));\\n            \\n            ans.add(left + right);\\n        }\\n        return ans;\\n    }\\n", "def minOperations(self,nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        aug = [(q, i) for i, q in enumerate(queries)]\\n        aug.sort()\\n        total = sum(nums)\\n        prefix = 0\\n        k = 0\\n        ans = [0] * len(queries)\\n        for q, i in aug:\\n            while k < len(nums) and nums[k] < q:\\n                prefix += nums[k]\\n                k += 1\\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\\n        return ans\\n```\\n```java []\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n        int n = nums.length,m = queries.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        long[] psum = new long[n + 1];\\n        for(int i = 0;i < n;i++) psum[i + 1] = psum[i] + nums[i];\\n        \\n        List<Long> ans = new ArrayList<>();\\n        \\n        for(int i = 0;i < m;i++){\\n            \\n            int si = 0,ei = n - 1,idx = 0;\\n            while(si <= ei){\\n                int mid = si + (ei - si) / 2;\\n                \\n                if(nums[mid] <= queries[i]){\\n                    idx = mid + 1;\\n                    si = mid + 1;\\n                }else{\\n                    idx = mid;\\n                    ei = mid - 1;\\n                }\\n            }\\n            \\n            long left = (1L * queries[i] * idx) - psum[si]; \\n            long right = (psum[n] - psum[idx]) - (1L * queries[i] * (n - idx));\\n            \\n            ans.add(left + right);\\n        }\\n        return ans;\\n    }\\n", "def minOperations(self,nums: List[int], queries: List[int]) -> List[int]:\\n        nums.sort()\\n        aug = [(q, i) for i, q in enumerate(queries)]\\n        aug.sort()\\n        total = sum(nums)\\n        prefix = 0\\n        k = 0\\n        ans = [0] * len(queries)\\n        for q, i in aug:\\n            while k < len(nums) and nums[k] < q:\\n                prefix += nums[k]\\n                k += 1\\n            ans[i] = total - 2 * prefix + q * (2 * k - len(nums))\\n        return ans\\n```\\n```java []\\npublic List<Long> minOperations(int[] nums, int[] queries) {\\n        int n = nums.length,m = queries.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        long[] psum = new long[n + 1];\\n        for(int i = 0;i < n;i++) psum[i + 1] = psum[i] + nums[i];\\n        \\n        List<Long> ans = new ArrayList<>();\\n        \\n        for(int i = 0;i < m;i++){\\n            \\n            int si = 0,ei = n - 1,idx = 0;\\n            while(si <= ei){\\n                int mid = si + (ei - si) / 2;\\n                \\n                if(nums[mid] <= queries[i]){\\n                    idx = mid + 1;\\n                    si = mid + 1;\\n                }else{\\n                    idx = mid;\\n                    ei = mid - 1;\\n                }\\n            }\\n            \\n            long left = (1L * queries[i] * idx) - psum[si]; \\n            long right = (psum[n] - psum[idx]) - (1L * queries[i] * (n - idx));\\n            \\n            ans.add(left + right);\\n        }\\n        return ans;\\n    }\\n"]}
{"id": "1693", "ref_py": ["def buildTree(self, inorder, postorder):\\n        \\n        ", "def buildTree(self, inorder, postorder):\\n        \\n        ", "def buildTree(self, inorder, postorder):\\n        \\n        "]}
{"id": "1694", "ref_py": ["def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans", "def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans", "def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans"]}
{"id": "1695", "ref_py": ["def myPow(self, x, n):\\n        return x**n\\n```\\n", "def solve(self, x, n):\\n        if n == 0:\\n            return 1  ", "def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            return 1.0 / self.pow(x, -n)\\n        return self.pow(x, n)\\n    \\n    def pow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1.0\\n        if n % 2 == 0:\\n            return self.pow(x * x, n // 2)\\n        else:\\n            return x * self.pow(x * x, (n - 1) // 2)"]}
{"id": "1696", "ref_py": ["def miceAndCheese(self, reward1, reward2, k):\\n        \\n        new_arr=[(reward1[i]-reward2[i],reward1[i] , reward2[i]) for i in range(len(reward2))]\\n        new_arr.sort(reverse=True)\\n        res = 0\\n        for i in range(k):\\n            res += new_arr[i][1]\\n            \\n        for i in range(k , len(reward1)):\\n            res += new_arr[i][2]\\n        return res", "def miceAndCheese(self, reward1, reward2, k):\\n        \\n        new_arr=[(reward1[i]-reward2[i],reward1[i] , reward2[i]) for i in range(len(reward2))]\\n        new_arr.sort(reverse=True)\\n        res = 0\\n        for i in range(k):\\n            res += new_arr[i][1]\\n            \\n        for i in range(k , len(reward1)):\\n            res += new_arr[i][2]\\n        return res", "def miceAndCheese(self, reward1, reward2, k):\\n        \\n        new_arr=[(reward1[i]-reward2[i],reward1[i] , reward2[i]) for i in range(len(reward2))]\\n        new_arr.sort(reverse=True)\\n        res = 0\\n        for i in range(k):\\n            res += new_arr[i][1]\\n            \\n        for i in range(k , len(reward1)):\\n            res += new_arr[i][2]\\n        return res"]}
{"id": "1697", "ref_py": ["def distance(self, nums):\\n        \\n        dict = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            dict[num].append(i)\\n        arr = [0]*len(nums)\\n        for key, value in dict.items():\\n            s = sum(value)\\n            partial_sum = 0\\n            n = len(value)\\n            for i in range(len(value)):\\n                partial_sum = partial_sum + value[i]\\n                arr[value[i]] = value[i]*(2*i-n+2) + s - 2*partial_sum\\n        return arr", "def distance(self, nums):\\n        \\n        dict = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            dict[num].append(i)\\n        arr = [0]*len(nums)\\n        for key, value in dict.items():\\n            s = sum(value)\\n            partial_sum = 0\\n            n = len(value)\\n            for i in range(len(value)):\\n                partial_sum = partial_sum + value[i]\\n                arr[value[i]] = value[i]*(2*i-n+2) + s - 2*partial_sum\\n        return arr", "def distance(self, nums):\\n        \\n        dict = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            dict[num].append(i)\\n        arr = [0]*len(nums)\\n        for key, value in dict.items():\\n            s = sum(value)\\n            partial_sum = 0\\n            n = len(value)\\n            for i in range(len(value)):\\n                partial_sum = partial_sum + value[i]\\n                arr[value[i]] = value[i]*(2*i-n+2) + s - 2*partial_sum\\n        return arr"]}
{"id": "1698", "ref_py": ["def minimizeMax(self, A: List[int], p: int) -> int:\\n        n = len(A)\\n        A.sort()\\n        l, r = 0, A[n - 1] - A[0]\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.helper(A, mid, p) >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n    \\n    def helper(self, A: List[int], diff: int, p: int) -> int:\\n        i, count = 1, 0\\n        while i < len(A):\\n            if A[i] - A[i - 1] <= diff:\\n                i += 1\\n                count += 1\\n            i += 1\\n        return count", "def minimizeMax(self, nums: list[int], p: int) -> int:\\n        diffs = tuple(b - a for a, b in pairwise(sorted(nums)))", "def minimizeMax(self, nums: list[int], p: int) -> int:\\n        diffs = tuple(b - a for a, b in pairwise(sorted(nums)))"]}
{"id": "1707", "ref_py": ["def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            ", "def loudAndRich(richer, quiet):\\n\\tg, loud = collections.defaultdict(set), [-1]*len(quiet)\\n\\tfor u, v in richer: g[v].add(u)\\n\\tdef dfs(node):\\n\\t\\tif loud[node] < 0: loud[node] = min([dfs(nei) for nei in g[node]]+[node], key=lambda x:quiet[x])\\n\\t\\treturn loud[node]\\n", "def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\\n        length = len(quiet)\\n        arr = [i for i in range(length)]\\n        indegree = [0 for _ in range(length)]\\n        graph = collections.defaultdict(list)\\n        dq = collections.deque([])\\n        \\n        for a, b in richer:\\n            "]}
{"id": "1708", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1709", "ref_py": ["def addMinimum(self, word):\\n        \\n        len_word = len(word)\\n        ans = 0\\n        i = 0\\n        while i < len_word - 1:\\n            c = word[i]\\n            cnex = word[i+1]\\n            if c == \\'a\\':\\n                if cnex == \\'a\\':\\n                    ans += 2\\n                elif i < len_word-2 and cnex == \\'b\\' and word[i+2] == \\'c\\':\\n                    i += 2\\n                else:\\n                    ans += 1\\n                    i += 1\\n            elif c == \\'b\\':\\n                if cnex == \\'c\\':\\n                    ans += 1\\n                    i += 1\\n                else:\\n                    ans += 2\\n            else:\\n                ans += 2\\n            i += 1\\n        if i < len_word:\\n            ans += 2\\n        return ans", "def addMinimum(self, word: str) -> int:\\n        k, prev = 0, \\'z\\'\\n        for c in word:\\n            k += c <= prev\\n            prev = c\\n        return k * 3 - len(word)\\n```", "def addMinimum(self, word: str) -> int:\\n        k, prev = 0, \\'z\\'\\n        for c in word:\\n            k += c <= prev\\n            prev = c\\n        return k * 3 - len(word)\\n```"]}
{"id": "1711", "ref_py": ["def maxValue(self, n: str, x: int) -> str:\\n        x = str(x)", "def maxValue(self, n: str, x: int) -> str:\\n        x = str(x)", "def maxValue(self, n: str, x: int) -> str:\\n        x = str(x)"]}
{"id": "1712", "ref_py": ["def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime=[True]*1001\\n        prime[0]=prime[1]=False\\n        for x in range(2,1001):\\n            if prime[x]:\\n                for i in range(x*x,1001,x):\\n                    prime[i]=False", "def isprime(self, num):\\n        \\n        for i in range(2, math.ceil(math.sqrt(num+1))):\\n            if num%i==0:\\n                return False\\n        return True\\n        \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        prims = [i for i in range(2,1001) if self.isprime(i)]\\n        \\n        ", "def isprime(self, num):\\n        \\n        for i in range(2, math.ceil(math.sqrt(num+1))):\\n            if num%i==0:\\n                return False\\n        return True\\n        \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        prims = [i for i in range(2,1001) if self.isprime(i)]\\n        \\n        "]}
{"id": "1713", "ref_py": ["def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```", "def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```", "def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```"]}
{"id": "1714", "ref_py": ["def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0", "def findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans", "def findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans"]}
{"id": "1715", "ref_py": ["def firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\\n```c++ []\\n", "def firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\\n```c++ []\\n", "def firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\\n```c++ []\\n"]}
{"id": "1716", "ref_py": ["def minimumCost(start, target, specialRoads):\\n    filteredRoads = []\\n    for road in specialRoads:\\n        a, b, c, d, cost = road\\n        if cost < abs(a - c) + abs(b - d):\\n            filteredRoads.append([a, b, c, d, cost])\\n    dist = {(start[0], start[1]): 0}\\n    heap = [(0, start[0], start[1])]\\n    while heap:\\n        currdist, x, y = heapq.heappop(heap)\\n        for road in filteredRoads:\\n            a, b, c, d, cost = road\\n            if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                heapq.heappush(heap, (dist[(c, d)], c, d))\\n    res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n    for road in filteredRoads:\\n        a, b, c, d, cost = road\\n        res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n    return res\\n```", "def minimumCost(start, target, specialRoads):\\n    filteredRoads = []\\n    for road in specialRoads:\\n        a, b, c, d, cost = road\\n        if cost < abs(a - c) + abs(b - d):\\n            filteredRoads.append([a, b, c, d, cost])\\n    dist = {(start[0], start[1]): 0}\\n    heap = [(0, start[0], start[1])]\\n    while heap:\\n        currdist, x, y = heapq.heappop(heap)\\n        for road in filteredRoads:\\n            a, b, c, d, cost = road\\n            if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                heapq.heappush(heap, (dist[(c, d)], c, d))\\n    res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n    for road in filteredRoads:\\n        a, b, c, d, cost = road\\n        res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n    return res\\n```", "def minimumCost(start, target, specialRoads):\\n    filteredRoads = []\\n    for road in specialRoads:\\n        a, b, c, d, cost = road\\n        if cost < abs(a - c) + abs(b - d):\\n            filteredRoads.append([a, b, c, d, cost])\\n    dist = {(start[0], start[1]): 0}\\n    heap = [(0, start[0], start[1])]\\n    while heap:\\n        currdist, x, y = heapq.heappop(heap)\\n        for road in filteredRoads:\\n            a, b, c, d, cost = road\\n            if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                heapq.heappush(heap, (dist[(c, d)], c, d))\\n    res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n    for road in filteredRoads:\\n        a, b, c, d, cost = road\\n        res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n    return res\\n```"]}
{"id": "1718", "ref_py": ["def minimumSwap(self, s1: str, s2: str) -> int:\\n        x_y, y_x = 0, 0\\n        for c1, c2 in zip(s1, s2):\\n            if c1 != c2:\\n                if c1 == \\'x\\':\\n                    x_y += 1\\n                else:\\n                    y_x += 1\\n                    \\n        if (x_y + y_x) % 2 == 1:\\n            return -1\\n        ", "def minimumSwap(self, s1: str, s2: str) -> int:\\n\\txy = yx = 0\\n\\tfor i in range(len(s1)):\\n\\t\\tif(s1[i] == \"x\" and s2[i] == \"y\"):\\n\\t\\t\\txy += 1\\n\\t\\tif(s2[i] == \"x\" and s1[i] == \"y\"):\\n\\t\\t\\tyx += 1\\n\\tif(xy%2 ^ yx%2):\\n\\t\\treturn -1\\n\\tans = xy//2 + yx//2 + (xy%2) * 2\\n", "def minimumSwap(self, s1: str, s2: str) -> int:\\n\\txy = yx = 0\\n\\tfor i in range(len(s1)):\\n\\t\\tif(s1[i] == \"x\" and s2[i] == \"y\"):\\n\\t\\t\\txy += 1\\n\\t\\tif(s2[i] == \"x\" and s1[i] == \"y\"):\\n\\t\\t\\tyx += 1\\n\\tif(xy%2 ^ yx%2):\\n\\t\\treturn -1\\n\\tans = xy//2 + yx//2 + (xy%2) * 2\\n"]}
{"id": "1719", "ref_py": ["def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```\\n<br>", "def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```\\n<br>", "def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```\\n<br>"]}
{"id": "1720", "ref_py": ["def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        ", "def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        ", "def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        "]}
{"id": "1721", "ref_py": ["def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 ", "def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 ", "def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 "]}
{"id": "1722", "ref_py": ["def finalPrices(self, prices: List[int]) -> List[int]:\\n        stack = [] ", "def finalPrices(self, prices: List[int]) -> List[int]:\\n        stack = [] ", "def finalPrices(self, prices: List[int]) -> List[int]:\\n        stack = [] "]}
{"id": "1723", "ref_py": ["def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def helper(row,col) :\\n            \\n            if row < 0 or row >= m or col >= n:\\n                return 0\\n            \\n            if dp[row][col] != -1:\\n                return dp[row][col]\\n            \\n            directions = [(row - 1, col + 1), (row, col + 1), (row + 1, col + 1) ]\\n            \\n            max_moves = 0\\n            \\n            for x,y in directions :\\n                \\n                if x>=0 and x < m and (y < n) and grid[x][y] > grid[row][col] :\\n                    \\n                    if dp[x][y] != -1:\\n                        max_moves = max(max_moves , 1+dp[x][y])\\n                        \\n                    else :\\n                        max_moves = max(max_moves , 1+helper(x,y))\\n                        \\n            dp[row][col] = max_moves\\n            return dp[row][col]\\n        \\n        \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        ans = 0\\n        \\n        dp = [[-1 for i in range(n)]for j in range(m)]", "def solve(self,grid,i,j,prev,vis):\\n        if(i<0 or i>=len(grid) or j<0 or j>=len(grid[0]) or grid[i][j]<=prev or vis[i][j]==1):\\n            return 0\\n        vis[i][j]=1\\n        a=self.solve(grid,i-1,j+1,grid[i][j],vis)\\n        b=self.solve(grid,i,j+1,grid[i][j],vis)\\n        c=self.solve(grid,i+1,j+1,grid[i][j],vis)\\n        return 1+max(a,b,c)", "def maxMoves(self, grid: List[List[int]]) -> int:\\n        \\n        def helper(row,col) :\\n            \\n            if row < 0 or row >= m or col >= n:\\n                return 0\\n            \\n            if dp[row][col] != -1:\\n                return dp[row][col]\\n            \\n            directions = [(row - 1, col + 1), (row, col + 1), (row + 1, col + 1) ]\\n            \\n            max_moves = 0\\n            \\n            for x,y in directions :\\n                \\n                if x>=0 and x < m and (y < n) and grid[x][y] > grid[row][col] :\\n                    \\n                    if dp[x][y] != -1:\\n                        max_moves = max(max_moves , 1+dp[x][y])\\n                        \\n                    else :\\n                        max_moves = max(max_moves , 1+helper(x,y))\\n                        \\n            dp[row][col] = max_moves\\n            return dp[row][col]\\n        \\n        \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        ans = 0\\n        \\n        dp = [[-1 for i in range(n)]for j in range(m)]"]}
{"id": "1724", "ref_py": ["def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        ", "def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        ", "def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        "]}
{"id": "1727", "ref_py": ["def punishmentNumber(self, n: int) -> int:\\n        def possible(sum_added,cache_sum, n, target):\\n            \\n            if not n:\\n                return target == sum_added+cache_sum\\n            num = int(n[0])\\n            cas = cache_sum", "def punishmentNumber(self, n: int) -> int:\\n        def partition_string(s):\\n            if len(s) == 0:\\n                return [[]]\\n            partitions = []\\n            for i in range(1, len(s) + 1):\\n                prefix, suffix = s[:i], s[i:]\\n                suffix_partitions = partition_string(suffix)\\n                for p in suffix_partitions:\\n                    partitions.append([prefix] + p)", "def punishmentNumber(self, n: int) -> int:\\n        def partition_string(s):\\n            if len(s) == 0:\\n                return [[]]\\n            partitions = []\\n            for i in range(1, len(s) + 1):\\n                prefix, suffix = s[:i], s[i:]\\n                suffix_partitions = partition_string(suffix)\\n                for p in suffix_partitions:\\n                    partitions.append([prefix] + p)"]}
{"id": "1729", "ref_py": ["def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n        n=len(s)\\n        @cache\\n        def dp(i:int,extra:int)->int:\\n            if i>=n:\\n                return extra", "def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n    n = len(s)\\n    dictionarySet = set(dictionary)\\n    dp = [0] + [n] * n", "def minExtraChar(self, s: str, dictionary: List[str]) -> int:\\n    n = len(s)\\n    dictionarySet = set(dictionary)\\n    dp = [0] + [n] * n"]}
{"id": "1730", "ref_py": ["def longestOnes(self, nums: List[int], k: int) -> int:\\n        zeros, l = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > k:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        return r - l + 1", "def longestOnes(self, nums: List[int], k: int) -> int:\\n\\tn, ans, l = len(nums), 0, 0\\n\\tfor r in range(n):\\n\\t\\tif nums[r] == 0:                       ", "def longestOnes(self, nums: List[int], k: int) -> int:\\n        zeros, l = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > k:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        return r - l + 1"]}
{"id": "1731", "ref_py": ["def differenceOfDistinctValues(self, grid):\\n        \\n        ar = []\\n        ro = len(grid)\\n        co = len(grid[0])\\n        for i in range(len(grid)):\\n            ls = []\\n            for j in range(len(grid[i])):\\n                le = set()\\n                re = set()\\n                x = i - 1\\n                y = j - 1\\n                while x >= 0 and y >= 0:\\n                    le.add(grid[x][y])\\n                    x -= 1\\n                    y -= 1\\n                x = i + 1\\n                y = j + 1\\n                while x < ro and y < co:\\n                    re.add(grid[x][y])\\n                    x += 1\\n                    y += 1\\n                ls.append(abs(len(le) - len(re)))\\n            ar.append(ls)  ", "def differenceOfDistinctValues(self, grid):\\n        ", "def differenceOfDistinctValues(self, grid):\\n        "]}
{"id": "1732", "ref_py": ["def minimumCost(self, s: str) -> int:", "def minimumCost(self, s: str) -> int:", "def minimumCost(self, s: str) -> int:"]}
{"id": "1733", "ref_py": ["def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi = 0\\n        row = set()\\n        col = set()", "def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        cntR, cntC = n, n\\n        R = [True] * n\\n        C = [True] * n\\n        for t, i, v in queries[::-1]:\\n            if t == 0 and R[i]:\\n                ans += v * cntC\\n                cntR -= 1\\n                R[i] = False\\n            elif t == 1 and C[i]:\\n                ans += v * cntR\\n                cntC -= 1\\n                C[i] = False\\n        return ans", "def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi = 0\\n        row = set()\\n        col = set()"]}
{"id": "1736", "ref_py": ["def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        max_length = 1\\n        previous_char_position = 0\\n        next_duplicate_char_position = 0\\n        for current_position, current_char in enumerate(s):\\n            if current_position == 0:\\n                continue\\n            if current_char == s[current_position - 1]:\\n                previous_char_position = next_duplicate_char_position\\n                next_duplicate_char_position = current_position\\n            max_length = max(max_length, current_position - previous_char_position + 1)\\n        return max_length\\n```", "def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        max_length = 1\\n        previous_char_position = 0\\n        next_duplicate_char_position = 0\\n        for current_position, current_char in enumerate(s):\\n            if current_position == 0:\\n                continue\\n            if current_char == s[current_position - 1]:\\n                previous_char_position = next_duplicate_char_position\\n                next_duplicate_char_position = current_position\\n            max_length = max(max_length, current_position - previous_char_position + 1)\\n        return max_length\\n```", "def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        max_length = 1\\n        previous_char_position = 0\\n        next_duplicate_char_position = 0\\n        for current_position, current_char in enumerate(s):\\n            if current_position == 0:\\n                continue\\n            if current_char == s[current_position - 1]:\\n                previous_char_position = next_duplicate_char_position\\n                next_duplicate_char_position = current_position\\n            max_length = max(max_length, current_position - previous_char_position + 1)\\n        return max_length\\n```"]}
{"id": "1737", "ref_py": ["def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count", "def countSeniors(details: List[str]) -> int:\\n    cnt = 0\\n    for tem in details:\\n        age = int(tem[11:13])\\n        if age > 60:\\n            cnt += 1\\n    return cnt\\n```\\n", "def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count"]}
{"id": "1738", "ref_py": ["def smallestString(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        \\n        ", "def smallestString(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        \\n        ", "def smallestString(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        \\n        "]}
{"id": "1739", "ref_py": ["def alternateDigitSum(self, n: int) -> int:\\n        nums = []\\n        while n > 0:\\n            nums.append(n%10)\\n            n = n//10", "def alternateDigitSum(self, n: int) -> int:\\n        sum = 0\\n        for i in range(len(str(n))):\\n            if i % 2 == 0:\\n                sum += int(str(n)[i])\\n            else:\\n                sum += -int(str(n)[i])\\n        return sum", "def alternateDigitSum(self, n: int) -> int:\\n        sum = 0\\n        for i in range(len(str(n))):\\n            if i % 2 == 0:\\n                sum += int(str(n)[i])\\n            else:\\n                sum += -int(str(n)[i])\\n        return sum"]}
{"id": "1740", "ref_py": ["definition, a global inversion*. Any number that represents part of a global inversion, however, could represent more than one global inversion.", "def isIdealPermutation(self, A: List[int]) -> bool:", "def isIdealPermutation(self, arr: List[int]) -> bool:\\n        n=len(arr)\\n        l=0\\n        for i in range(n-1):\\n            if arr[i]>arr[i+1]:\\n                l+=1\\n                if l>1:\\n                    return False\\n        g=self.mergeSort(arr,0,n-1)\\n        return g==l\\n    \\n    def merge(self,arr,l,m,r):\\n        left=l\\n        right=m+1\\n        temp=[]\\n        c=0\\n        while left<=m and right<=r:\\n            if arr[left]<=arr[right]:\\n                temp.append(arr[left])\\n                left+=1\\n            else:\\n                temp.append(arr[right])\\n                c+=m-left+1\\n                right+=1\\n        while left<=m:\\n            temp.append(arr[left])\\n            left+=1\\n        while right<=r:\\n            temp.append(arr[right])\\n            right+=1\\n        for i in range(l,r+1):\\n            arr[i]=temp[i-l]\\n        return c\\n            \\n    def mergeSort(self,arr,l,r):\\n        c=0\\n        if l>=r:\\n            return c\\n        m=(l+r)>>1\\n        c+=self.mergeSort(arr,l,m)\\n        c+=self.mergeSort(arr,m+1,r)\\n        c+=self.merge(arr,l,m,r)\\n        return c\\n```"]}
{"id": "1741", "ref_py": ["def specialPerm(self, nums: List[int]) -> int:\\n        @cache\\n        def dp(prev: int, mask: int) -> int:\\n            if mask == (1 << len(nums)) - 1:\\n                return 1", "def sb(self, x):\\n        ans = 0\\n        while x > 0:\\n            if x & 1:\\n                ans += 1\\n            x = x >> 1\\n        return ans", "def sb(self, x):\\n        ans = 0\\n        while x > 0:\\n            if x & 1:\\n                ans += 1\\n            x = x >> 1\\n        return ans"]}
{"id": "1742", "ref_py": ["def longestString(self, x: int, y: int, z: int) -> int:\\n        if x==y:\\n            return 4*x+2*z", "def longestString(self, x: int, y: int, z: int) -> int:\\n        if x==y:\\n            return 4*x+2*z", "def longestString(self, x: int, y: int, z: int) -> int:\\n        if x==y:\\n            return 4*x+2*z"]}
{"id": "1743", "ref_py": ["def c2i(ch): return ord(ch) - ord(\\'a\\')", "def minimizeConcatenatedLength(self, words: List[str]) -> int:\\n        n = len(words)", "def minimizeConcatenatedLength(self, words: List[str]) -> int:"]}
{"id": "1744", "ref_py": ["def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        logs.sort(key = lambda x: x[1])\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort(key = lambda x: x[0])\\n        d = [float(\\'-inf\\')] * (n + 1)\\n        ans = [0] * len(queries)\\n        lo, hi = 0, 0\\n        occupied_servers = set()\\n        for q, i in queries:\\n            while hi < len(logs) and logs[hi][1] <= q:\\n                d[logs[hi][0]] = logs[hi][1]\\n                occupied_servers.add(logs[hi][0])\\n                hi += 1\\n            while lo < len(logs) and logs[lo][1] < q - x:\\n                if d[logs[lo][0]] == logs[lo][1]:\\n                    occupied_servers.remove(logs[lo][0])\\n                lo += 1\\n            ans[i] = n - len(occupied_servers)\\n        return ans\\n```", "def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        logs.sort(key = lambda x: x[1])\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort(key = lambda x: x[0])\\n        d = [float(\\'-inf\\')] * (n + 1)\\n        ans = [0] * len(queries)\\n        lo, hi = 0, 0\\n        occupied_servers = set()\\n        for q, i in queries:\\n            while hi < len(logs) and logs[hi][1] <= q:\\n                d[logs[hi][0]] = logs[hi][1]\\n                occupied_servers.add(logs[hi][0])\\n                hi += 1\\n            while lo < len(logs) and logs[lo][1] < q - x:\\n                if d[logs[lo][0]] == logs[lo][1]:\\n                    occupied_servers.remove(logs[lo][0])\\n                lo += 1\\n            ans[i] = n - len(occupied_servers)\\n        return ans\\n```", "def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        logs.sort(key = lambda x: x[1])\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort(key = lambda x: x[0])\\n        d = [float(\\'-inf\\')] * (n + 1)\\n        ans = [0] * len(queries)\\n        lo, hi = 0, 0\\n        occupied_servers = set()\\n        for q, i in queries:\\n            while hi < len(logs) and logs[hi][1] <= q:\\n                d[logs[hi][0]] = logs[hi][1]\\n                occupied_servers.add(logs[hi][0])\\n                hi += 1\\n            while lo < len(logs) and logs[lo][1] < q - x:\\n                if d[logs[lo][0]] == logs[lo][1]:\\n                    occupied_servers.remove(logs[lo][0])\\n                lo += 1\\n            ans[i] = n - len(occupied_servers)\\n        return ans\\n```"]}
{"id": "1745", "ref_py": ["def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```", "def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```"]}
{"id": "1746", "ref_py": ["def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        ans, prev = 1, -1\\n        for curr in range(len(nums)):\\n            if nums[curr]:\\n                if prev != -1: ans = (ans * (curr - prev)) % 1000000007\\n                prev = curr\\n        return ans if prev != -1 else 0", "def numberOfGoodSubarraySplits(self, nums):\\n        \\n        mod = 10**9 + 7\\n        prev = -1\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                if prev == -1:\\n                    res = 1\\n                    prev = i\\n                else:\\n                    res *= (i - prev)\\n                    res %= mod\\n                    prev = i\\n        return res%mod", "def numberOfGoodSubarraySplits(self, nums):\\n        \\n        mod = 10**9 + 7\\n        prev = -1\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                if prev == -1:\\n                    res = 1\\n                    prev = i\\n                else:\\n                    res *= (i - prev)\\n                    res %= mod\\n                    prev = i\\n        return res%mod"]}
{"id": "1747", "ref_py": ["def findPrimePairs(self, n):\\n        prime = [True] * (n + 1)  ", "def findPrimePairs(self, n):\\n        prime = [True] * (n + 1)  ", "def findPrimePairs(self, n):\\n        prime = [True] * (n + 1)  "]}
{"id": "1748", "ref_py": ["def continuousSubarrays(self, nums):\\n        maxQ = deque()\\n        minQ = deque()\\n        left = 0\\n        res = 0", "def continuousSubarrays(self, nums):\\n        maxQ = deque()\\n        minQ = deque()\\n        left = 0\\n        res = 0", "def continuousSubarrays(self, nums):\\n        maxQ = deque()\\n        minQ = deque()\\n        left = 0\\n        res = 0"]}
{"id": "1749", "ref_py": ["def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\\n        nums = set(nums)\\n        for start, end in zip(moveFrom, moveTo):\\n            nums.discard(start)\\n            nums.add(end)\\n        \\n        return sorted(nums)\\n```\\n![Screenshot 2023-07-08 at 23.25.13.png](https://assets.leetcode.com/users/images/fb66d174-8336-43bb-8644-c3c60e5e7961_1688847930.506015.png)", "def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\\n        nums = set(nums)\\n        for start, end in zip(moveFrom, moveTo):\\n            nums.discard(start)\\n            nums.add(end)\\n        \\n        return sorted(nums)\\n```\\n![Screenshot 2023-07-08 at 23.25.13.png](https://assets.leetcode.com/users/images/fb66d174-8336-43bb-8644-c3c60e5e7961_1688847930.506015.png)", "def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\\n        nums = set(nums)\\n        for start, end in zip(moveFrom, moveTo):\\n            nums.discard(start)\\n            nums.add(end)\\n        \\n        return sorted(nums)\\n```\\n![Screenshot 2023-07-08 at 23.25.13.png](https://assets.leetcode.com/users/images/fb66d174-8336-43bb-8644-c3c60e5e7961_1688847930.506015.png)"]}
{"id": "1750", "ref_py": ["def isFive(self, num: int) -> bool:\\n        while num > 1:\\n            if num % 5 != 0:\\n                return False\\n            num //= 5\\n        return num == 1", "def isFive(self, num: int) -> bool:\\n        while num > 1:\\n            if num % 5 != 0:\\n                return False\\n            num //= 5\\n        return num == 1", "def isFive(self, num: int) -> bool:\\n        while num > 1:\\n            if num % 5 != 0:\\n                return False\\n            num //= 5\\n        return num == 1"]}
{"id": "1751", "ref_py": ["def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:", "def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:", "def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:"]}
{"id": "1752", "ref_py": ["def maximumJumps(self, nums: List[int], target: int) -> int:\\n        \\n        @cache\\n        def dp(i):\\n            if i == len(nums) - 1:\\n                return 0", "def solve(self, idx, dp, nums, target):\\n        if idx == len(nums) - 1:\\n            return 0", "def solve(self, idx, dp, nums, target):\\n        if idx == len(nums) - 1:\\n            return 0"]}
{"id": "1753", "ref_py": ["def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        flow = [[1]*n for _ in range(m)]", "def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        flow = [[1]*n for _ in range(m)]", "def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        flow = [[1]*n for _ in range(m)]"]}
{"id": "1754", "ref_py": ["def checkArray(self, A: List[int], k: int) -> bool:\\n        cur = 0\\n        for i, a in enumerate(A):\\n            if cur > a:\\n                return False\\n            A[i], cur = a - cur, a\\n            if i >= k - 1:\\n                cur -= A[i - k + 1]\\n        return cur == 0\\n```\\n<br>", "def checkArray(self, nums: List[int], k: int) -> bool:\\n        curr=0\\n        for i,a in enumerate(nums):\\n            if curr>a:\\n                return False", "def checkArray(self, A: List[int], k: int) -> bool:\\n        cur = 0\\n        for i, a in enumerate(A):\\n            if cur > a:\\n                return False\\n            A[i], cur = a - cur, a\\n            if i >= k - 1:\\n                cur -= A[i - k + 1]\\n        return cur == 0\\n```\\n<br>"]}
{"id": "1755", "ref_py": ["definition of beauty of an array,\\nwe want to find a window that `max - min <= k * 2`,\\nwhich can cover as many elements as possible.", "definition of beauty of an array,\\nwe want to find a window that `max - min <= k * 2`,\\nwhich can cover as many elements as possible.", "definition of beauty of an array,\\nwe want to find a window that `max - min <= k * 2`,\\nwhich can cover as many elements as possible."]}
{"id": "1756", "ref_py": ["def strWithout3a3b(self, a, b):\\n        \\n        n=a+b\\n        count_A=0\\n        count_b=0\\n        res=\"\"\\n        for i in range(n):\\n            if (a>b and count_A<2) or count_b>1:\\n                res+=\"a\"\\n                count_A+=1\\n                a=a-1\\n                count_b=0\\n            else:\\n                res+=\"b\"\\n                b-=1\\n                count_A=0\\n                count_b+=1\\n        return res", "def strWithout3a3b(self, a: int, b: int) -> str:", "def strWithout3a3b(self, a, b):\\n        \\n        n=a+b\\n        count_A=0\\n        count_b=0\\n        res=\"\"\\n        for i in range(n):\\n            if (a>b and count_A<2) or count_b>1:\\n                res+=\"a\"\\n                count_A+=1\\n                a=a-1\\n                count_b=0\\n            else:\\n                res+=\"b\"\\n                b-=1\\n                count_A=0\\n                count_b+=1\\n        return res"]}
{"id": "1757", "ref_py": ["def sortVowels(self, input_str: str) -> str:\\n        vowels_list = []\\n        vowel_positions = []\\n        \\n        for index, char in enumerate(input_str):\\n            if char.lower() in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                vowels_list.append(char)\\n                vowel_positions.append(index)\\n        \\n        vowels_list.sort()\\n        result_list = list(input_str)\\n        \\n        for position, vowel in zip(vowel_positions, vowels_list):\\n            result_list[position] = vowel\\n        \\n        return \\'\\'.join(result_list)\\n```", "def sortVowels(self, s: str) -> str:\\n        VOWELS = \"AEIOUaeiou\"\\n        q = deque(sorted(c for c in s if c in VOWELS))\\n        return \"\".join(q.popleft() if c in VOWELS else c for c in s)", "def sortVowels(self, s: str) -> str:\\n        VOWELS = \"AEIOUaeiou\"\\n        q = deque(sorted(c for c in s if c in VOWELS))\\n        return \"\".join(q.popleft() if c in VOWELS else c for c in s)"]}
{"id": "1758", "ref_py": ["def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        @cache\\n        def f(ind,p):\\n            if ind==n:\\n                return 0", "def maxScore(self, nums: List[int], x: int) -> int:\\n\\t\\tn = len(nums)", "def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        @cache\\n        def f(ind,p):\\n            if ind==n:\\n                return 0"]}
{"id": "1759", "ref_py": ["def numberOfWays(self, num: int, power: int) -> int:\\n        @cache\\n        def calc_ways(i: int, left: int) -> int:\\n            if left == 0:\\n                return 1\\n            elif left < 0 or i >= len(candidates) or candidates[i] > left:\\n                return 0\\n            else:\\n                return (\\n                    calc_ways(i + 1, left) + calc_ways(i + 1, left - candidates[i])\\n                ) % self.MOD", "def numberOfWays(self, num: int, power: int) -> int:\\n        @cache\\n        def calc_ways(i: int, left: int) -> int:\\n            if left == 0:\\n                return 1\\n            elif left < 0 or i >= len(candidates) or candidates[i] > left:\\n                return 0\\n            else:\\n                return (\\n                    calc_ways(i + 1, left) + calc_ways(i + 1, left - candidates[i])\\n                ) % self.MOD", "def numberOfWays(self, num: int, power: int) -> int:\\n        @cache\\n        def calc_ways(i: int, left: int) -> int:\\n            if left == 0:\\n                return 1\\n            elif left < 0 or i >= len(candidates) or candidates[i] > left:\\n                return 0\\n            else:\\n                return (\\n                    calc_ways(i + 1, left) + calc_ways(i + 1, left - candidates[i])\\n                ) % self.MOD"]}
{"id": "1760", "ref_py": ["def maxArrayValue(self, nums):\\n        a = [] ", "def maxArrayValue(self, nums):\\n        a = [] ", "def maxArrayValue(self, nums):\\n        a = [] "]}
{"id": "1761", "ref_py": ["def countCompleteSubarrays(self, A: List[int]) -> int:\\n        n, k = len(A), len(set(A))\\n        res = i = 0\\n        count = Counter()\\n        for j in range(n):\\n            count[A[j]] += 1\\n            while len(count) == k:\\n                count[A[i]] -= 1\\n                if count[A[i]] == 0:\\n                    del count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```\\n<br>", "define the sliding window boundaries.\\n4. Iterate through the array using the right pointer and expand the window by adding elements to windowCount.\\n5. Whenever the window contains all distinct elements (i.e., windowCount.size() becomes equal to totalDistinct), count the subarrays and increment the count variable by n - right. The reason for this is that when the window contains all distinct elements, it forms a complete subarray with the current right element and all the elements to its left. So, n - right subarrays can be formed with this right element.\\n6. Shrink the window from the left side by removing elements until the window becomes incomplete (i.e., windowCount.size() is less than totalDistinct).\\n7. Continue the process until the right pointer reaches the end of the array.\\n8. After the loop completes, the count variable will hold the total count of complete subarrays.", "def countCompleteSubarrays(self, A: List[int]) -> int:\\n        n, k = len(A), len(set(A))\\n        res = i = 0\\n        count = Counter()\\n        for j in range(n):\\n            count[A[j]] += 1\\n            while len(count) == k:\\n                count[A[i]] -= 1\\n                if count[A[i]] == 0:\\n                    del count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```\\n<br>"]}
{"id": "1762", "ref_py": ["def solve(a, b):\\n    x = a.find(b)\\n    if x != -1:\\n        return a\\n    ans = a\\n    for i in range(len(a)):\\n        j = 0\\n        k = i\\n        c = 0\\n        while k < len(a) and j < len(b):\\n            if a[k] == b[j]:\\n                c += 1\\n            else:\\n                break\\n            k += 1\\n            j += 1\\n        if k == len(a):\\n            for m in range(c, len(b)):\\n                ans += b[m]\\n            return ans\\n    for i in range(len(b)):\\n        ans += b[i]\\n    return ans", "def solve(a, b):\\n    x = a.find(b)\\n    if x != -1:\\n        return a\\n    ans = a\\n    for i in range(len(a)):\\n        j = 0\\n        k = i\\n        c = 0\\n        while k < len(a) and j < len(b):\\n            if a[k] == b[j]:\\n                c += 1\\n            else:\\n                break\\n            k += 1\\n            j += 1\\n        if k == len(a):\\n            for m in range(c, len(b)):\\n                ans += b[m]\\n            return ans\\n    for i in range(len(b)):\\n        ans += b[i]\\n    return ans", "def solve(a, b):\\n    x = a.find(b)\\n    if x != -1:\\n        return a\\n    ans = a\\n    for i in range(len(a)):\\n        j = 0\\n        k = i\\n        c = 0\\n        while k < len(a) and j < len(b):\\n            if a[k] == b[j]:\\n                c += 1\\n            else:\\n                break\\n            k += 1\\n            j += 1\\n        if k == len(a):\\n            for m in range(c, len(b)):\\n                ans += b[m]\\n            return ans\\n    for i in range(len(b)):\\n        ans += b[i]\\n    return ans"]}
{"id": "1763", "ref_py": ["def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def calculate_gcd(a, b):\\n            return a if b == 0 else calculate_gcd(b, a % b)\\n        if not head or not head.next:\\n            return head", "def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def calculate_gcd(a, b):\\n            return a if b == 0 else calculate_gcd(b, a % b)\\n        if not head or not head.next:\\n            return head", "def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def calculate_gcd(a, b):\\n            return a if b == 0 else calculate_gcd(b, a % b)\\n        if not head or not head.next:\\n            return head"]}
{"id": "1764", "ref_py": ["def minimumSeconds(self, nums: List[int]) -> int:\\n        ele = Counter(nums).keys()\\n        result = inf\\n        info = {}\\n        length = len(nums)", "def minimumSeconds(self, nums):\\n        ", "def minimumSeconds(self, nums: List[int]) -> int:\\n        ele = Counter(nums).keys()\\n        result = inf\\n        info = {}\\n        length = len(nums)"]}
{"id": "1765", "ref_py": ["def canSplitArray(self, nums: List[int], m: int) -> bool:\\n        n = len(nums)\\n        \\n        if n <= 2:\\n            return True\\n        \\n        if nums[0] + nums[1] >= m or nums[n - 1] + nums[n - 2] >= m:\\n            return True\\n        \\n        for i in range(1, n - 1):\\n            if nums[i] + nums[i + 1] >= m:\\n                return True\\n        \\n        return False\\n```", "def canSplitArray(self, nums: List[int], m: int) -> bool:\\n        n = len(nums)\\n        \\n        if n <= 2:\\n            return True\\n        \\n        if nums[0] + nums[1] >= m or nums[n - 1] + nums[n - 2] >= m:\\n            return True\\n        \\n        for i in range(1, n - 1):\\n            if nums[i] + nums[i + 1] >= m:\\n                return True\\n        \\n        return False\\n```", "def canSplitArray(self, nums: List[int], m: int) -> bool:\\n        n = len(nums)\\n        \\n        if n <= 2:\\n            return True\\n        \\n        if nums[0] + nums[1] >= m or nums[n - 1] + nums[n - 2] >= m:\\n            return True\\n        \\n        for i in range(1, n - 1):\\n            if nums[i] + nums[i + 1] >= m:\\n                return True\\n        \\n        return False\\n```"]}
{"id": "1766", "ref_py": ["def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: return 0\\n        n = len(grid)\\n        safe = [[0 if grid[i][j] == 1 else -1 for j in range(n)] for i in range(n)]\\n        queue = deque([(i,j) for (i,j) in product(range(n), repeat=2) if grid[i][j] == 1])\\n        while queue:\\n            r, c = queue.popleft()\\n            for nx, ny in (r + 1, c), (r, c + 1), (r, c - 1), (r - 1, c):\\n                if 0 <= nx < n and 0 <= ny < n and safe[nx][ny] == -1:\\n                    safe[nx][ny] = safe[r][c] + 1\\n                    queue.append((nx, ny))\\n        acceptable = safe[0][0]\\n        safe[0][0] = -1\\n        Q = defaultdict(list)\\n        queue = deque([(0,0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                r, c = queue.popleft()\\n                if (r, c) == (n - 1, n - 1):\\n                    return acceptable\\n                for nx, ny in (r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1):\\n                    if 0 <= nx < n and 0 <= ny < n:\\n                        if safe[nx][ny] >= acceptable:\\n                            queue.append((nx, ny))\\n                        elif safe[nx][ny] != -1:\\n                            Q[safe[nx][ny]].append((nx, ny))\\n                        ", "def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: return 0\\n        n = len(grid)\\n        safe = [[0 if grid[i][j] == 1 else -1 for j in range(n)] for i in range(n)]\\n        queue = deque([(i,j) for (i,j) in product(range(n), repeat=2) if grid[i][j] == 1])\\n        while queue:\\n            r, c = queue.popleft()\\n            for nx, ny in (r + 1, c), (r, c + 1), (r, c - 1), (r - 1, c):\\n                if 0 <= nx < n and 0 <= ny < n and safe[nx][ny] == -1:\\n                    safe[nx][ny] = safe[r][c] + 1\\n                    queue.append((nx, ny))\\n        acceptable = safe[0][0]\\n        safe[0][0] = -1\\n        Q = defaultdict(list)\\n        queue = deque([(0,0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                r, c = queue.popleft()\\n                if (r, c) == (n - 1, n - 1):\\n                    return acceptable\\n                for nx, ny in (r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1):\\n                    if 0 <= nx < n and 0 <= ny < n:\\n                        if safe[nx][ny] >= acceptable:\\n                            queue.append((nx, ny))\\n                        elif safe[nx][ny] != -1:\\n                            Q[safe[nx][ny]].append((nx, ny))\\n                        ", "def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: return 0\\n        n = len(grid)\\n        safe = [[0 if grid[i][j] == 1 else -1 for j in range(n)] for i in range(n)]\\n        queue = deque([(i,j) for (i,j) in product(range(n), repeat=2) if grid[i][j] == 1])\\n        while queue:\\n            r, c = queue.popleft()\\n            for nx, ny in (r + 1, c), (r, c + 1), (r, c - 1), (r - 1, c):\\n                if 0 <= nx < n and 0 <= ny < n and safe[nx][ny] == -1:\\n                    safe[nx][ny] = safe[r][c] + 1\\n                    queue.append((nx, ny))\\n        acceptable = safe[0][0]\\n        safe[0][0] = -1\\n        Q = defaultdict(list)\\n        queue = deque([(0,0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                r, c = queue.popleft()\\n                if (r, c) == (n - 1, n - 1):\\n                    return acceptable\\n                for nx, ny in (r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1):\\n                    if 0 <= nx < n and 0 <= ny < n:\\n                        if safe[nx][ny] >= acceptable:\\n                            queue.append((nx, ny))\\n                        elif safe[nx][ny] != -1:\\n                            Q[safe[nx][ny]].append((nx, ny))\\n                        "]}
{"id": "1767", "ref_py": ["def doubleIt(self, head):\\n        n = 0\\n        while(head):\\n            if head.next is not None:\\n                n = (n + head.val) * 10\\n            else: \\n                n += head.val\\n                break\\n            head = head.next\\n        n *= 2\\n        if n < 10:\\n            return ListNode(n, None)", "def doubleIt(self, head):\\n        n = 0\\n        while(head):\\n            if head.next is not None:\\n                n = (n + head.val) * 10\\n            else: \\n                n += head.val\\n                break\\n            head = head.next\\n        n *= 2\\n        if n < 10:\\n            return ListNode(n, None)", "def doubleIt(self, head):\\n        n = 0\\n        while(head):\\n            if head.next is not None:\\n                n = (n + head.val) * 10\\n            else: \\n                n += head.val\\n                break\\n            head = head.next\\n        n *= 2\\n        if n < 10:\\n            return ListNode(n, None)"]}
{"id": "1768", "ref_py": ["def find(num):\\n           nxt=rnk[dp[num]]\\n           if not active[nxt]:  dp[num]=find(rnk[dp[num]+d])\\n           return dp[num]", "def find(num):\\n           nxt=rnk[dp[num]]\\n           if not active[nxt]:  dp[num]=find(rnk[dp[num]+d])\\n           return dp[num]", "def find(num):\\n           nxt=rnk[dp[num]]\\n           if not active[nxt]:  dp[num]=find(rnk[dp[num]+d])\\n           return dp[num]"]}
{"id": "1769", "ref_py": ["define a binary search within the range of left and right for the smaller array (nums1). The initial values of left and right are 0 and the length of nums1, respectively.", "def findMedianSortedArrays(self, nums1, nums2) -> float:\\n        merged_array = [0] * (len(nums1) + len(nums2))\\n        idx_nums1 = 0  ", "def findMedianSortedArrays(self, nums1, nums2) -> float:\\n        merged_array = [0] * (len(nums1) + len(nums2))\\n        idx_nums1 = 0  "]}
{"id": "1770", "ref_py": ["def isMatch(self, s: str, p: str) -> bool:\\n        i, j = len(s) - 1, len(p) - 1\\n        return self.backtrack({}, s, p, i, j)", "def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True ", "defined by **s_index** and **p_index** where they define current char from **s** and **p** strings."]}
{"id": "1771", "ref_py": ["def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        \\n        mid = len(lists) // 2\\n        left = self.mergeKLists(lists[:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.merge(left, right)\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next\\n            curr = curr.next\\n        \\n        curr.next = l1 or l2\\n        \\n        return dummy.next\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};", "def __init__(self, val=0, next=None):\\n", "defined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};"]}
{"id": "1772", "ref_py": ["defaultdict\\nclass Solution:\\n    def minAreaRect(self, points: List[List[int]]) -> int:\\n        hashmap = defaultdict(set)\\n        for x, y in points:\\n            hashmap[x].add(y)\\n            \\n        min_area = math.inf\\n             \\n        i = 0\\n        for x1, y1 in points:\\n            i += 1\\n            for x2, y2 in points[i:]:\\n                if x1 != x2 and y1 != y2:\\n                    if y2 in hashmap[x1] and y1 in hashmap[x2]:\\n                        min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\\n                        if min_area == 1:\\n                            return 1\\n                \\n        return min_area if min_area != math.inf else 0\\n```", "def minAreaRect(self, points: List[List[int]]) -> int:\\n    points.sort()\\n    points_set = set([tuple(point) for point in points])\\n    smallest = float(\\'inf\\')\\n    for i, (x1, y1) in enumerate(points):\\n        for j, (x2, y2) in enumerate(points[i:], i):\\n            if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\\n                area = (x2 - x1) * (y2 - y1)\\n                smallest = min(smallest, area)\\n    return smallest if smallest != float(\\'inf\\') else 0\\n```", "def minAreaRect(self, points: List[List[int]]) -> int:\\n    points.sort()\\n    points_set = set([tuple(point) for point in points])\\n    smallest = float(\\'inf\\')\\n    for i, (x1, y1) in enumerate(points):\\n        for j, (x2, y2) in enumerate(points[i:], i):\\n            if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\\n                area = (x2 - x1) * (y2 - y1)\\n                smallest = min(smallest, area)\\n    return smallest if smallest != float(\\'inf\\') else 0\\n```"]}
{"id": "1773", "ref_py": ["defaultdict", "defaultdict", "defaultdict"]}
{"id": "1774", "ref_py": ["def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        l=[\\'0\\']*len(s)\\n        for ind,i in enumerate(s):\\n            if i==\\'(\\':\\n                stack.append(ind)\\n            else:\\n                if stack:\\n                    l[stack.pop()]=\\'1\\'\\n                    l[ind]=\\'1\\'\\n        return max(len(i) for i in \\'\\'.join(l).split(\\'0\\'))\\n```", "def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n        stck=[-1] ", "def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        l=[\\'0\\']*len(s)\\n        for ind,i in enumerate(s):\\n            if i==\\'(\\':\\n                stack.append(ind)\\n            else:\\n                if stack:\\n                    l[stack.pop()]=\\'1\\'\\n                    l[ind]=\\'1\\'\\n        return max(len(i) for i in \\'\\'.join(l).split(\\'0\\'))\\n```"]}
{"id": "1775", "ref_py": ["def solveSudoku(self, board: List[List[str]]) -> None:\\n        n = 9\\n        \\n        \\n        def isValid(row, col, ch):\\n            row, col = int(row), int(col)\\n            \\n            for i in range(9):\\n                \\n                if board[i][col] == ch:\\n                    return False\\n                if board[row][i] == ch:\\n                    return False\\n                \\n                if board[3*(row//3) + i//3][3*(col//3) + i%3] == ch:\\n                    return False\\n            \\n            return True\\n            \\n        def solve(row, col):\\n            if row == n:\\n                return True\\n            if col == n:\\n                return solve(row+1, 0)\\n            \\n            if board[row][col] == \".\":\\n                for i in range(1, 10):\\n                    if isValid(row, col, str(i)):\\n                        board[row][col] = str(i)\\n                        \\n                        if solve(row, col + 1):\\n                            return True\\n                        else:\\n                            board[row][col] = \".\"\\n                return False\\n            else:\\n                return solve(row, col + 1)\\n            \\n            \\n        \\n        solve(0, 0)\\n\\t\\t\\n", "def solveSudoku(self, board: List[List[str]]) -> None:\\n        n = 9\\n        \\n        \\n        def isValid(row, col, ch):\\n            row, col = int(row), int(col)\\n            \\n            for i in range(9):\\n                \\n                if board[i][col] == ch:\\n                    return False\\n                if board[row][i] == ch:\\n                    return False\\n                \\n                if board[3*(row//3) + i//3][3*(col//3) + i%3] == ch:\\n                    return False\\n            \\n            return True\\n            \\n        def solve(row, col):\\n            if row == n:\\n                return True\\n            if col == n:\\n                return solve(row+1, 0)\\n            \\n            if board[row][col] == \".\":\\n                for i in range(1, 10):\\n                    if isValid(row, col, str(i)):\\n                        board[row][col] = str(i)\\n                        \\n                        if solve(row, col + 1):\\n                            return True\\n                        else:\\n                            board[row][col] = \".\"\\n                return False\\n            else:\\n                return solve(row, col + 1)\\n            \\n            \\n        \\n        solve(0, 0)\\n\\t\\t\\n", "def solveSudoku(self, board: List[List[str]]) -> None:\\n        n = 9\\n        \\n        \\n        def isValid(row, col, ch):\\n            row, col = int(row), int(col)\\n            \\n            for i in range(9):\\n                \\n                if board[i][col] == ch:\\n                    return False\\n                if board[row][i] == ch:\\n                    return False\\n                \\n                if board[3*(row//3) + i//3][3*(col//3) + i%3] == ch:\\n                    return False\\n            \\n            return True\\n            \\n        def solve(row, col):\\n            if row == n:\\n                return True\\n            if col == n:\\n                return solve(row+1, 0)\\n            \\n            if board[row][col] == \".\":\\n                for i in range(1, 10):\\n                    if isValid(row, col, str(i)):\\n                        board[row][col] = str(i)\\n                        \\n                        if solve(row, col + 1):\\n                            return True\\n                        else:\\n                            board[row][col] = \".\"\\n                return False\\n            else:\\n                return solve(row, col + 1)\\n            \\n            \\n        \\n        solve(0, 0)\\n\\t\\t\\n"]}
{"id": "1776", "ref_py": ["definitely get in trouble if the `index` we\\'re flagging hasn\\'t been evaluated yet. Take an example of `[3,1,2]` (which supposed to have the answer `4`), here is how the `nums` array is being evaluated, in each loop-step:\\n** Before loop: `[3,1,2]`\\n** Loop at index 0: `[3, 1, None]`. The `index` that `3` points to is index `2`, therefore the value becomes `None`.  This is the part where we change index `2`, while index `2` itself hasn\\'t been evaluated yet.\\n** Loop at index 1: `[None, 1, None]`. The `index` that `1` points to is index `0`, therefore the value becomes `None`.\\n** Loop at index 2: `[None, 1, None]`. At this step, it\\'s doing nothing because the original value of `2` has already been changed to `None`, and we have no way to flag index `1` as `None`.", "definitely get in trouble if the `index` we\\'re flagging hasn\\'t been evaluated yet. Take an example of `[3,1,2]` (which supposed to have the answer `4`), here is how the `nums` array is being evaluated, in each loop-step:\\n** Before loop: `[3,1,2]`\\n** Loop at index 0: `[3, 1, None]`. The `index` that `3` points to is index `2`, therefore the value becomes `None`.  This is the part where we change index `2`, while index `2` itself hasn\\'t been evaluated yet.\\n** Loop at index 1: `[None, 1, None]`. The `index` that `1` points to is index `0`, therefore the value becomes `None`.\\n** Loop at index 2: `[None, 1, None]`. At this step, it\\'s doing nothing because the original value of `2` has already been changed to `None`, and we have no way to flag index `1` as `None`.", "definitely get in trouble if the `index` we\\'re flagging hasn\\'t been evaluated yet. Take an example of `[3,1,2]` (which supposed to have the answer `4`), here is how the `nums` array is being evaluated, in each loop-step:\\n** Before loop: `[3,1,2]`\\n** Loop at index 0: `[3, 1, None]`. The `index` that `3` points to is index `2`, therefore the value becomes `None`.  This is the part where we change index `2`, while index `2` itself hasn\\'t been evaluated yet.\\n** Loop at index 1: `[None, 1, None]`. The `index` that `1` points to is index `0`, therefore the value becomes `None`.\\n** Loop at index 2: `[None, 1, None]`. At this step, it\\'s doing nothing because the original value of `2` has already been changed to `None`, and we have no way to flag index `1` as `None`."]}
{"id": "1777", "ref_py": ["def sumBackets(self, height: list[int], left, right):", "def trap(self, height):\\n        n = len(height)\\n        water = 0\\n        for i in range(n):\\n            left_max, right_max = 0, 0\\n            j = i\\n            while j < n:\\n                right_max = max(right_max, height[j])\\n                j += 1\\n            j = i\\n            while j >= 0:\\n                left_max = max(left_max, height[j])\\n                j -= 1\\n            j = i\\n            water += min(left_max, right_max) - height[i]\\n        return water", "def trap(self, height):\\n        n = len(height)\\n        water = 0\\n        for i in range(n):\\n            left_max, right_max = 0, 0\\n            j = i\\n            while j < n:\\n                right_max = max(right_max, height[j])\\n                j += 1\\n            j = i\\n            while j >= 0:\\n                left_max = max(left_max, height[j])\\n                j -= 1\\n            j = i\\n            water += min(left_max, right_max) - height[i]\\n        return water"]}
{"id": "1778", "ref_py": ["def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: ", "def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: ", "def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: "]}
{"id": "1779", "ref_py": ["def solveNQueens(self, n: int) -> List[List[str]]:\\n        d, boards = set(), []", "def solveNQueens(self, n: int) -> List[List[str]]:\\n        def solve(col, board, ans, lr, ud, ld, n):\\n            if col == n:\\n                ans.append([\\'\\'.join(row) for row in board])\\n                return\\n            for row in range(n):\\n                if lr[row] == 0 and ld[row - col] == 0 and ud[row + col] == 0:\\n                    board[row][col] = \\'Q\\'\\n                    lr[row] = 1\\n                    ld[row - col] = 1\\n                    ud[row + col] = 1\\n                    \\n                    solve(col + 1, board, ans, lr, ud, ld, n)\\n                    \\n                    board[row][col] = \\'.\\'\\n                    lr[row] = 0\\n                    ld[row - col] = 0\\n                    ud[row + col] = 0\\n        \\n        ans = []\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        leftrow = [0] * n\\n        upperDiagonal = [0] * (2 * n - 1)\\n        lowerDiagonal = [0] * (2 * n - 1)\\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n)\\n        return ans", "def solveNQueens(self, n: int) -> List[List[str]]:\\n        d, boards = set(), []"]}
{"id": "1780", "ref_py": ["def maximumGroups(self, A: List[int]) -> int:\\n        n = len(A)\\n        k = 0\\n        while n >= k + 1:\\n            k += 1\\n            n -= k\\n        return k\\n```\\n<br>", "def maximumGroups(self, grades: List[int]) -> int:\\n        N, k = len(grades), 1\\n        while k * (k+1) // 2 <= N: \\n            k += 1\\n        return k-1", "def maximumGroups(self, grades: List[int]) -> int:\\n        \\n        return  int(-.5+sqrt(.25+2*len(grades)))\\n\\t\\t\\n```"]}
{"id": "1781", "ref_py": ["def getPermutation(self, n, k):\\n        ", "def getPermutation(self, n, k):\\n        \\n        k -= 1", "def getPermutation(self, n, k):\\n        "]}
{"id": "1782", "ref_py": ["def isNumber(self, S: str) -> bool:    \\n        num, exp, sign, dec = False, False, False, False\\n        for c in S:\\n            if c >= \\'0\\' and c <= \\'9\\': num = True     \\n            elif c == \\'e\\' or c == \\'E\\':\\n                if exp or not num: return False\\n                else: exp, num, sign, dec = True, False, False, False\\n            elif c == \\'+\\' or c == \\'-\\':\\n                if sign or num or dec: return False\\n                else: sign = True\\n            elif c == \\'.\\':\\n                if dec or exp: return False\\n                else: dec = True\\n            else: return False\\n        return num\\n```", "def isNumber(self, s: str) -> bool:\\n\\t\\t", "def isNumber(self, s: str) -> bool:\\n\\t\\t"]}
{"id": "1783", "ref_py": ["def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]", "def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                ", "def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                "]}
{"id": "1784", "ref_py": ["def minWindow(self, s: str, t: str) -> str:\\n        if len(s) < len(t): return \\'\\'\\n        \\n        need, match, l, start, windowLen = Counter(t), 0, 0, 0, len(s) + 1\\n        \\n        for r, ch in enumerate(s):\\n            if ch in need:\\n                need[ch] -= 1\\n                match += need[ch] == 0", "def minWindow(self, s, t):\\n        if len(s) < len(t):\\n            return \"\"\\n        map = {}\\n        for char in t:\\n            if char in map:\\n                map[char] += 1\\n            else:\\n                map[char] = 1\\n        count = 0\\n        start = 0\\n        min_length = float(\"inf\")\\n        min_start = 0\\n        for end in range(len(s)):\\n            if s[end] in map:\\n                map[s[end]] -= 1\\n                if map[s[end]] >= 0:\\n                    count += 1\\n            while count == len(t):\\n                if min_length > end - start + 1:\\n                    min_length = end - start + 1\\n                    min_start = start\\n                if s[start] in map:\\n                    map[s[start]] += 1\\n                    if map[s[start]] > 0:\\n                        count -= 1\\n                start += 1\\n        return \"\" if min_length == float(\"inf\") else s[min_start:min_start+min_length]", "def minWindow(self, s, t):\\n        if len(s) < len(t):\\n            return \"\"\\n        map = {}\\n        for char in t:\\n            if char in map:\\n                map[char] += 1\\n            else:\\n                map[char] = 1\\n        count = 0\\n        start = 0\\n        min_length = float(\"inf\")\\n        min_start = 0\\n        for end in range(len(s)):\\n            if s[end] in map:\\n                map[s[end]] -= 1\\n                if map[s[end]] >= 0:\\n                    count += 1\\n            while count == len(t):\\n                if min_length > end - start + 1:\\n                    min_length = end - start + 1\\n                    min_start = start\\n                if s[start] in map:\\n                    map[s[start]] += 1\\n                    if map[s[start]] > 0:\\n                        count -= 1\\n                start += 1\\n        return \"\" if min_length == float(\"inf\") else s[min_start:min_start+min_length]"]}
{"id": "1785", "ref_py": ["def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack = [-1]\\n        ans = 0\\n        for i in xrange(len(height)):\\n            while height[i] < height[stack[-1]]:\\n                h = height[stack.pop()]\\n                w = i - stack[-1] - 1\\n                ans = max(ans, h * w)\\n            stack.append(i)\\n        height.pop()\\n        return ans", "def largestRectangleArea(self, heights):\\n        n = len(heights)\\n        nsr = [0] * n\\n        nsl = [0] * n", "def largestRectangleArea(self, heights):\\n        n = len(heights)\\n        nsr = [0] * n\\n        nsl = [0] * n"]}
{"id": "1786", "ref_py": ["defined as follows: Given a binary matrix, find the largest rectangle containing only ones and return its area. This might sound a bit complex at first, but with the right algorithm, it becomes a manageable challenge.", "def maximalRectangle(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n = len(matrix[0])\\n        height = [0] * (n + 1)\\n        ans = 0\\n        for row in matrix:\\n            for i in xrange(n):\\n                height[i] = height[i] + 1 if row[i] == '1' else 0\\n            stack = [-1]\\n            for i in xrange(n + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - 1 - stack[-1]\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        return ans", "def maximalRectangle(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n = len(matrix[0])\\n        height = [0] * (n + 1)\\n        ans = 0\\n        for row in matrix:\\n            for i in xrange(n):\\n                height[i] = height[i] + 1 if row[i] == '1' else 0\\n            stack = [-1]\\n            for i in xrange(n + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - 1 - stack[-1]\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        return ans"]}
{"id": "1787", "ref_py": ["define a 3-dimensional array dp[l][i][j], where l denotes the length of the substring, i denotes the starting index of the substring in the first string s1, and j denotes the starting index of the substring in the second string s2.", "def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool: return any((is_scramble(i, j, k) and is_scramble(i + k, j + k, n - k)) or (is_scramble(i, j + n - k, k) and is_scramble(i + k, j, n - k)) for k in range(1, n)) if n > 1 else s1[i] == s2[j]\\n        return is_scramble(0, 0, len(s1))", "defined as any string that can be obtained by swapping some characters of the original string. So we can solve this problem recursively by dividing the string into left and right substrings and check for two cases i.e., whether we need to swap the substrings before checking for the next recursive call or not."]}
{"id": "1788", "ref_py": ["def numDistinct(self, s, t):\\n        dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\\n        for col in range(len(dp[0])):\\n            dp[0][col] = 1\\n        for x in range(1, len(s) + 1):\\n            for y in range(1, len(t) + 1):\\n                if s[x - 1] == t[y - 1]:\\n                    dp[y][x] = dp[y - 1][x - 1] + dp[y][x - 1]\\n                else:\\n                    dp[y][x] = dp[y][x - 1]\\n        return dp[-1][-1]\\n```", "def numDistinct(self, s: str, t: str) -> int:\\n        s_len, t_len = len(s), len(t)\\n        if t_len > s_len:\\n            return 0", "def numDistinct(self, s, t):\\n        dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\\n        for col in range(len(dp[0])):\\n            dp[0][col] = 1\\n        for x in range(1, len(s) + 1):\\n            for y in range(1, len(t) + 1):\\n                if s[x - 1] == t[y - 1]:\\n                    dp[y][x] = dp[y - 1][x - 1] + dp[y][x - 1]\\n                else:\\n                    dp[y][x] = dp[y][x - 1]\\n        return dp[-1][-1]\\n```"]}
{"id": "1789", "ref_py": ["def maxProfit(self, prices: List[int]) -> int:\\n    if not prices:\\n        return 0", "def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```", "def maxProfit(self, prices: List[int]) -> int:\\n    if not prices:\\n        return 0"]}
{"id": "1790", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1791", "ref_py": ["defer our path creation to later? That\\'s good, but not enough because we would have to start our traversal from `beginWord` all over again.", "def differ(str1, str2):\\n\\t\\t\\n\\t\\tdiff = 0", "def findLadders(beginWord, endWord, wordList):\\n\\ttree, words, n = collections.defaultdict(set), set(wordList), len(beginWord)\\n\\tif endWord not in wordList: return []\\n\\tfound, q, nq = False, {beginWord}, set()\\n\\twhile q and not found:\\n\\t\\twords -= set(q)\\n\\t\\tfor x in q:\\n\\t\\t\\tfor y in [x[:i]+c+x[i+1:] for i in range(n) for c in string.ascii_lowercase]:\\n\\t\\t\\t\\tif y in words:\\n\\t\\t\\t\\t\\tif y == endWord: \\n\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\tnq.add(y)\\n\\t\\t\\t\\t\\ttree[x].add(y)\\n\\t\\tq, nq = nq, set()\\n\\tdef bt(x): \\n\\t\\treturn [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)]\\n\\treturn bt(beginWord)\\n```\\nThat\\'s single one-way BFS which cost more than 2500ms. BFS\\'t time complexity is O(b^d) where  b is branch factor and d is depth. So if we go with a bi-directional way, expanding from both being word and end word, and choosing the queue (\\'begin\\' queue or \\'end\\' queue) with smaller size in each expansion, the branch factor will be greatly reduced.\\nAnd bi-directional BFS reducing running time from 2500ms to 100ms!\\n```\\ndef findLadders(beginWord, endWord, wordList):\\n\\ttree, words, n = collections.defaultdict(set), set(wordList), len(beginWord)\\n\\tif endWord not in wordList: return []\\n\\tfound, bq, eq, nq, rev = False, {beginWord}, {endWord}, set(), False\\n\\twhile bq and not found:\\n\\t\\twords -= set(bq)\\n\\t\\tfor x in bq:\\n\\t\\t\\tfor y in [x[:i]+c+x[i+1:] for i in range(n) for c in string.ascii_lowercase]:\\n\\t\\t\\t\\tif y in words:\\n\\t\\t\\t\\t\\tif y in eq: \\n\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\tnq.add(y)\\n\\t\\t\\t\\t\\ttree[y].add(x) if rev else tree[x].add(y)\\n\\t\\tbq, nq = nq, set()\\n\\t\\tif len(bq) > len(eq): \\n\\t\\t\\tbq, eq, rev = eq, bq, not rev\\n\\tdef bt(x): \\n\\t\\treturn [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)]\\n"]}
{"id": "1792", "ref_py": ["defense\\n    // 2. count weak characters (those defenses less than the current maximum defense)\\n    // 3. update the maximum defense\\n    int numberOfWeakCharacters(vector<vector<int>>& p) {\\n        // the final answer to be returned\\n        int weakCharacters = 0;\\n        // record maximum defense. since 1 <= defense_i <= 10 ^ 5\\n        // we can set the init value to x where x < 1\\n        int maxDefense = 0;\\n        // use a hash map to map the attack and defense with greater<int> as a key_compare\\n        map<int, vector<int>, greater<int>> m;\\n        for(auto x : p) m[x[0]].push_back(x[1]);\\n        // for each attack\\n        for(auto x : m) {\\n            // we count the number of weak characters \\n            // and add it to `weakCharacters`\\n            weakCharacters += count_if(x.second.begin(), x.second.end(), [&](int curDefense){ return curDefense < maxDefense;});\\n            // then update `maxDefense` which is the maximum value in current defenses\\n            maxDefense = max(maxDefense, *max_element(x.second.begin(), x.second.end()));\\n        }\\n        return weakCharacters;\\n    }\\n};\\n```", "def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\\n        \\n        properties.sort(key=lambda x: (-x[0],x[1]))\\n        \\n        ans = 0\\n        curr_max = 0\\n        \\n        for _, d in properties:\\n            if d < curr_max:\\n                ans += 1\\n            else:\\n                curr_max = d\\n        return ans\\n```", "defense\\n    // 2. count weak characters (those defenses less than the current maximum defense)\\n    // 3. update the maximum defense\\n    int numberOfWeakCharacters(vector<vector<int>>& p) {\\n        // the final answer to be returned\\n        int weakCharacters = 0;\\n        // record maximum defense. since 1 <= defense_i <= 10 ^ 5\\n        // we can set the init value to x where x < 1\\n        int maxDefense = 0;\\n        // use a hash map to map the attack and defense with greater<int> as a key_compare\\n        map<int, vector<int>, greater<int>> m;\\n        for(auto x : p) m[x[0]].push_back(x[1]);\\n        // for each attack\\n        for(auto x : m) {\\n            // we count the number of weak characters \\n            // and add it to `weakCharacters`\\n            weakCharacters += count_if(x.second.begin(), x.second.end(), [&](int curDefense){ return curDefense < maxDefense;});\\n            // then update `maxDefense` which is the maximum value in current defenses\\n            maxDefense = max(maxDefense, *max_element(x.second.begin(), x.second.end()));\\n        }\\n        return weakCharacters;\\n    }\\n};\\n```"]}
{"id": "1793", "ref_py": ["def minCut(self, s: str) -> int:\\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\\n        for length in range(len(s)):\\n            for start in range(len(s)-length):\\n                if length == 0 or (s[start] == s[start+length] and (dp[start+1][start+1+length-2] or length == 1)):\\n                    dp[start][start+length] = 1\\n                else:\\n                    dp[start][start+length] = 0", "def minCut(self, s: str) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            temp=\\'\\'\\n            mini=maxsize\\n            for j in range(ind,n):\\n                temp+=s[j]\\n                if temp==temp[-1::-1]:\\n                    cuts=1+solve(j+1)\\n                    mini=min(mini,cuts)\\n            return mini\\n        n=len(s)\\n        return solve(0)-1 \\n```\\n**We can notice that our function is actually counting an extra partition at the end of the string in each case. For example, the given string is \\u201Cabcd\\u201D. After doing a partition after \\u2018c\\u2019 the function will check if a partition can be done after \\u2018d\\u2019 to check if the last substring i.e. \\u2018d\\u2019 itself is a palindrome.**", "def minCut(self, s):\\n        if not s or len(s) <=1:\\n            return 0\\n        \\n        elif self.is_palindrome(s):\\n            return 0\\n        \\n        rows = len(s)\\n        cols = len(s)\\n        \\n        "]}
{"id": "1794", "ref_py": ["def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  ", "def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  ", "def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  "]}
{"id": "1795", "ref_py": ["def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)", "def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)", "def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)"]}
{"id": "1796", "ref_py": ["def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        if n == 1:\\n            return 1\\n        result = 2\\n        for i in range(n):\\n            cnt = collections.defaultdict(int)\\n            for j in range(n):\\n                if i != j:\\n                    cnt[math.atan2(points[j][1]-points[i][1], points[j][0]-points[i][0])] += 1\\n            result = max(result, max(cnt.values())+1)\\n        return result", "def maxPoints(self, points: List[List[int]]) -> int:\\n        res = 0\\n        for a,b in points:\\n            buckets = defaultdict(int)\\n            for c,d in points:\\n                if a == c and b == d:\\n                    continue\\n                if a == c:\\n                    index = \\'vertical\\'\\n                else:\\n                    index = (d-b)/(c-a)\\n                buckets[index] += 1\\n                res = max(res, buckets[index])\\n        return res+1\\n\\t```\\n\\tIt passed the test with 102 ms. I gave another try with the early stop version:\\n\\t```\\n\\tdef maxPoints(self, points: List[List[int]]) -> int:\\n        res = 0\\n        stop_criteria = len(points)\\n        for a,b in points:\\n            buckets = defaultdict(int)\\n            for c,d in points:\\n                if a == c and b == d:\\n                    continue\\n                if a == c:\\n                    index = \\'vertical\\'\\n                else:\\n                    index = (d-b)/(c-a)\\n                buckets[index] += 1\\n                res = max(res, buckets[index])\\n            stop_criteria = max(len(buckets), res)\\n            if res == stop_criteria-1:\\n                return stop_criteria\\n        return res+1\\n\\t```\\n\\tIt passed with 101 ms. I guess the overhead of stop_criteria also slow down the performance. I optimized the code a liitle bit and got 94ms.\\n\\t```\\n\\tdef maxPoints(self, points: List[List[int]]) -> int:\\n        res = 0\\n        for a,b in points:\\n            buckets = defaultdict(int)\\n            for c,d in points:\\n                if a == c and b == d:\\n                    continue\\n                if a == c:\\n                    index = \\'vertical\\'\\n                else:\\n                    index = (d-b)/(c-a)\\n                buckets[index] += 1\\n            if buckets:\\n                res = max(res, max(v for k,v in buckets.items()))\\n            if res > len(buckets):\\n                return res+1\\n        return res+1\\n\\t```\\n\\tAnd from this point, I did the **loop optimization**, and which usually will bring the better performance and examine your ideas. \\n\\t1. Try to eliminate ```if a == c and b == d:```, it make me think about that maybe we can start from next point instead of first point? So I change the forloop from ```for a,b in points:``` and ```for c,d in points:``` to ```for i in range(n):``` and ```for j in range(i+1,n):```\\n\\t2. Try to eliminate the ```a==c``` but I cannot figure out a way to get rid of it. (Unless there is way that program don\\'t throw the exception but store the exception at ```index```)\\n\\t3. Try to eliminate the ```if buckets:```, it comes from the case that if there is only one point, we will have no items in the dicationary and the ```max``` will fail. Instead of check buckets n times in the loop, we can check the ```len(points)``` in the begining once. Also we need to adjust the loop indexing to ```for i in range(n-1):``` and ```for j in range(i+1,n):```\\n\\t4. Stop criteria is removable for yon don\\'t want to grap the chance of early leaving, it depends on the problem size.\\nAnd here is my final submission(57-66ms)\\n```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n\\tn = len(points)\\n\\tif n == 1:\\n\\t\\treturn 1\\n\\tres = 1\\n\\tfor i in range(n-1):\\n\\t\\ta,b = points[i]\\n\\t\\tbuckets = defaultdict(int)\\n\\t\\tfor j in range(i+1,n):\\n\\t\\t\\tc,d = points[j]\\n\\t\\t\\tif a == c:\\n\\t\\t\\t\\tindex = \\'vertical\\'\\n\\t\\t\\telse:\\n\\t\\t\\t\\tindex = (d-b)/(c-a)\\n\\t\\t\\tbuckets[index] += 1\\n\\t\\tres = max(res, max(v for k,v in buckets.items()))\\n", "def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        if n == 1:\\n            return 1\\n        result = 2\\n        for i in range(n):\\n            cnt = collections.defaultdict(int)\\n            for j in range(n):\\n                if i != j:\\n                    cnt[math.atan2(points[j][1]-points[i][1], points[j][0]-points[i][0])] += 1\\n            result = max(result, max(cnt.values())+1)\\n        return result"]}
{"id": "1797", "ref_py": ["def findMin(self, nums: List[int]) -> int:\\n        start, end = 0, len(nums) - 1", "def findMin(self, nums):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = lo + (hi -lo) / 2\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return nums[lo] ", "def findMin(self, nums: List[int]) -> int:\\n        start, end = 0, len(nums) - 1"]}
{"id": "1798", "ref_py": ["define the size of our buckets such that the maximum gap will necessarily be larger than a single bucket. That would mean that our answer could then be found by comparing the highest value in each bucket with the lowest value in the next occupied bucket.", "def maximumGap(self, nums):\\n        if len(nums) < 2:\\n            return 0\\n    \\n        nums.sort()\\n        maxDiff = 0", "define a Solution class with a maximumGap method that takes a list of integers nums as input and returns an integer, the maximum gap between two successive elements in the sorted form of nums."]}
{"id": "1799", "ref_py": ["def calculateMinimumHP(self, dungeon):\\n\\tm, n = len(dungeon), len(dungeon[0])\\n\\tfor i in range(m-1, -1, -1):\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tif i == m-1 and j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = min(dungeon[i][j], 0) * -1 + 1\\n\\t\\t\\telif i == m-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i][j+1] - dungeon[i][j], 1)\\n\\t\\t\\telif j == n-1:\\n\\t\\t\\t\\tdungeon[i][j] = max(dungeon[i+1][j] - dungeon[i][j], 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdungeon[i][j] = max(min(dungeon[i][j+1], dungeon[i+1][j]) - dungeon[i][j], 1)\\n\\treturn dungeon[0][0]\\n```", "def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(m+1)]\\n        dp[m-1][n] = dp[m][n-1] = 1\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n        return dp[0][0]", "def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(m+1)]\\n        dp[m-1][n] = dp[m][n-1] = 1\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\\n        return dp[0][0]"]}
{"id": "1801", "ref_py": ["def maxProfit(self, k: int, prices: List[int]) -> int:\\n        ", "def maxProfit(self, k: int, prices: List[int]) -> int:\\n        ", "def maxProfit(self, k: int, prices: List[int]) -> int:\\n        "]}
{"id": "1802", "ref_py": ["def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = {}\\n        for w in words:\\n            node = root\\n            for l in w:\\n                if l not in node:\\n                    node[l] = {}\\n                node = node[l]\\n            node[\\'$\\'] = {}\\n                \\n        def remove(w):\\n            node = root\\n            stack = []\\n            stack.append(node)\\n            for l in w:\\n                node = node[l]\\n                stack.append(node)\\n            node = stack.pop()\\n            node.pop(\\'$\\')\\n            while stack:\\n                node = stack.pop()\\n                if \\'$\\' in node or len(node) > 1:\\n                    return\\n                k = list(node.keys())[0]\\n                if len(node[k]) == 0:\\n                    node.pop(k)\\n                else:\\n                    return", "def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class Trie():\\n        def __init__(self):\\n            self.root = TrieNode()\\n        \\n        def insert(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n        \\n        def search(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children.get(w)\\n                if not node:\\n                    return False\\n            return node.isWord\\n        \\n    class Solution(object):\\n        def findWords(self, board, words):\\n            res = []\\n            trie = Trie()\\n            node = trie.root\\n            for w in words:\\n                trie.insert(w)\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    self.dfs(board, node, i, j, \"\", res)\\n            return res\\n        \\n        def dfs(self, board, node, i, j, path, res):\\n            if node.isWord:\\n                res.append(path)\\n                node.isWord = False\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\\n                return \\n            tmp = board[i][j]\\n            node = node.children.get(tmp)\\n            if not node:\\n                return \\n            board[i][j] = \"", "def __init__(self, val: str = None, parent: Optional[\\'TrieNode\\'] = None):\\n        self.children = {}\\n        self.val = val\\n        self.parent = parent\\n        self.word = None\\n        "]}
{"id": "1803", "ref_py": ["def shortestPalindrome(self, s):\\n        r = s[::-1]\\n        for i in range(len(s) + 1):\\n            if s.startswith(r[i:]):\\n                return r[:i] + s", "def shortestPalindrome(self, s: str) -> str:\\n        t = s[::-1]", "def shortestPalindrome(self, s):\\n        r = s[::-1]\\n        for i in range(len(s) + 1):\\n            if s.startswith(r[i:]):\\n                return r[:i] + s"]}
{"id": "1804", "ref_py": ["def getSkyline(self, buildings):\\n        heights = []\\n        skyline = []\\n        pos = 0  ", "def getSkyline(self, buildings):\\n        heights = []\\n        skyline = []\\n        pos = 0  ", "def getSkyline(self, buildings):\\n        heights = []\\n        skyline = []\\n        pos = 0  "]}
{"id": "1805", "ref_py": ["def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if t < 0: return False\\n        n = len(nums)\\n        d = {}\\n        w = t + 1\\n        for i in xrange(n):\\n            m = nums[i] / w\\n            if m in d:\\n                return True\\n            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\\n                return True\\n            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\\n                return True\\n            d[m] = nums[i]\\n            if i >= k: del d[nums[i - k] / w]\\n        return False", "def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        buckets = {} ", "define a function getKey which takes an integer num as input and returns the key of the bucket to which the element belongs."]}
{"id": "1806", "ref_py": ["def __init__(self, s):\\n        self.s = s\\n        self.pc = 0\\n        self.skip_whitespaces()\\n        \\n    def has_next(self):\\n        return self.pc < len(self.s)\\n        \\n    def next(self):\\n        self.pc += 1\\n        self.skip_whitespaces()\\n            \\n    def skip_whitespaces(self):\\n        while self.has_next() and self.current() == \\' \\':\\n            self.pc += 1\\n        \\n    def is_digit(self):\\n        return self.current().isdigit()\\n        \\n    def current(self):\\n        return self.s[self.pc]\\n```", "def calculate(self, s):\\n        def evaluate(i):\\n            res, digit, sign = 0, 0, 1\\n            \\n            while i < len(s):\\n                if s[i].isdigit():\\n                    digit = digit * 10 + int(s[i])\\n                elif s[i] in \\'+-\\':\\n                    res += digit * sign\\n                    digit = 0\\n                    sign = 1 if s[i] == \\'+\\' else -1\\n                elif s[i] == \\'(\\':\\n                    subres, i = evaluate(i+1)\\n                    res += sign * subres\\n                elif s[i] == \\')\\':\\n                    res += digit * sign\\n                    return res, i\\n                i += 1", "def calculate(self, s):\\n        total = 0\\n        i, signs = 0, [1, 1]\\n        while i < len(s):\\n            c = s[i]\\n            if c.isdigit():\\n                start = i\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                total += signs.pop() * int(s[start:i])\\n                continue\\n            if c in '+-(':\\n                signs += signs[-1] * (1, -1)[c == '-'],\\n            elif c == ')':\\n                signs.pop()\\n            i += 1\\n        return total"]}
{"id": "1807", "ref_py": ["def countDigitOne(self, n):\\n        ones, m = 0, 1\\n        while m <= n:\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1)\\n            m *= 10\\n        return ones", "def countDigitOne(self, n):\\n        if n <= 0:\\n            return 0\\n        q, x, ans = n, 1, 0\\n        while q > 0:\\n            digit = q % 10\\n            q /= 10\\n            ans += q * x\\n            if digit == 1:\\n                ans += n % x + 1\\n            elif digit > 1:\\n                ans += x\\n            x *= 10\\n        return ans", "def countDigitOne(self, n):\\n        ones, m = 0, 1\\n        while m <= n:\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1)\\n            m *= 10\\n        return ones"]}
{"id": "1808", "ref_py": ["def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        q = deque() ", "def maxSlidingWindow(self, nums, k):\\n        v = []  ", "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        q = deque() "]}
{"id": "1810", "ref_py": ["def numberToWords(self, num):\\n        ", "def numberToWords(self, num):\\n        ", "def numberToWords(self, num):\\n        "]}
{"id": "1811", "ref_py": ["def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): ", "def addOperators(self, num: str, target: int) -> List[str]:", "def addOperators(self, num: str, target: int) -> List[str]:"]}
{"id": "1814", "ref_py": ["def removeInvalidParentheses(self, s):\\n        level = {s}\\n        while True:\\n            valid = []\\n            for s in level:\\n                try:\\n                    eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                    valid.append(s)\\n                except:\\n                    pass\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}", "def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def minRemoval(s):\\n            left = right = 0\\n            for i in s:\\n                if i == \\'(\\':\\n                    left+=1\\n                elif left and i== \\')\\':\\n                    left-=1\\n                elif i == \\')\\':\\n                    right+=1\\n            return (left,right)\\n      \\n        def backtrack(leftS,rightS,openR,closeR):\\n            if leftS+rightS in visited:\\n                return\\n            visited.add(leftS+rightS)\\n            if openR==0 and closeR == 0:\\n                l,r = minRemoval(leftS+rightS)\\n                if l+r==0:\\n                    output.append(leftS+rightS)\\n                return\\n            for i in range(len(rightS)):\\n                if rightS[i] == \\'(\\' and openR:\\n                    backtrack(leftS,rightS[i+1:],openR-1,closeR)\\n                elif rightS[i] == \")\" and closeR:\\n                    backtrack(leftS,rightS[i+1:],openR,closeR-1)\\n                leftS+=rightS[i]\\n            return\\n        \\n        visited = set()\\n        output = []\\n        openR,closeR = minRemoval(s)\\n        if openR+closeR == 0:\\n            return [s]\\n        backtrack(\"\",s,openR,closeR)   \\n        return output\\n", "def removeInvalidParentheses(self, s):\\n        level = {s}\\n        while True:\\n            valid = []\\n            for s in level:\\n                try:\\n                    eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                    valid.append(s)\\n                except:\\n                    pass\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"]}
{"id": "1815", "ref_py": ["def maxCoins(self, nums):\\n        @cache\\n        def search(nums):\\n            return 0 if len(nums) < 3 else max([search(nums[:i + 1]) + search(nums[i:]) \\n\\t\\t\\t        + nums[0] * nums[i] * nums[-1] for i in range(1, len(nums) - 1)])\\n        return search(tuple([1] + nums + [1]))\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  ", "def maxCoins(self, nums):\\n        @cache\\n        def search(nums):\\n            return 0 if len(nums) < 3 else max([search(nums[:i + 1]) + search(nums[i:]) \\n\\t\\t\\t        + nums[0] * nums[i] * nums[-1] for i in range(1, len(nums) - 1)])\\n        return search(tuple([1] + nums + [1]))\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  ", "def maxCoins(self, nums):\\n        @cache\\n        def search(nums):\\n            return 0 if len(nums) < 3 else max([search(nums[:i + 1]) + search(nums[i:]) \\n\\t\\t\\t        + nums[0] * nums[i] * nums[-1] for i in range(1, len(nums) - 1)])\\n        return search(tuple([1] + nums + [1]))\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  "]}
{"id": "1816", "ref_py": ["def __init__(self, n: int):\\n    self.sums = [0] * (n + 1)", "def countSmaller(self, nums):\\n        def sort(enum):\\n            half = len(enum) / 2\\n            if half:\\n                left, right = sort(enum[:half]), sort(enum[half:])\\n                for i in range(len(enum))[::-1]:\\n                    if not right or left and left[-1][1] > right[-1][1]:\\n                        smaller[left[-1][0]] += len(right)\\n                        enum[i] = left.pop()\\n                    else:\\n                        enum[i] = right.pop()\\n            return enum\\n        smaller = [0] * len(nums)\\n        sort(list(enumerate(nums)))\\n        return smaller", "def __init__(self, n: int):\\n    self.sums = [0] * (n + 1)"]}
{"id": "1817", "ref_py": ["def maxNumber(self, nums1, nums2, k):", "def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\\n        def get_max_subseq(nums, k):\\n            stack = []\\n            for i, num in enumerate(nums):\\n                while stack and len(nums) - i + len(stack) > k and stack[-1] < num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            return stack\\n        \\n        def merge(nums1, nums2):\\n            merged = []\\n            i, j = 0, 0\\n            while i < len(nums1) or j < len(nums2):\\n                if i >= len(nums1):\\n                    merged.append(nums2[j])\\n                    j += 1\\n                elif j >= len(nums2):\\n                    merged.append(nums1[i])\\n                    i += 1\\n                elif nums1[i:] > nums2[j:]:\\n                    merged.append(nums1[i])\\n                    i += 1\\n                else:\\n                    merged.append(nums2[j])\\n                    j += 1\\n            return merged\\n        \\n        ans = []\\n        for i in range(max(0, k - len(nums2)), min(len(nums1), k) + 1):\\n            j = k - i\\n            subseq1 = get_max_subseq(nums1, i)\\n            subseq2 = get_max_subseq(nums2, j)\\n            merged = merge(subseq1, subseq2)\\n            ans = max(ans, merged)\\n        return ans", "def maxNumber(self, nums1, nums2, k):"]}
{"id": "1818", "ref_py": ["def countRangeSum(self, nums, lower, upper):\\n        first = [0]\\n        for num in nums:\\n            first.append(first[-1] + num)\\n        def sort(lo, hi):\\n            mid = (lo + hi) / 2\\n            if mid == lo:\\n                return 0\\n            count = sort(lo, mid) + sort(mid, hi)\\n            i = j = mid\\n            for left in first[lo:mid]:\\n                while i < hi and first[i] - left <  lower: i += 1\\n                while j < hi and first[j] - left <= upper: j += 1\\n                count += j - i\\n            first[lo:hi] = sorted(first[lo:hi])\\n            return count\\n        return sort(0, len(first))", "def countRangeSum(self, nums: List[int], lo: int, up: int) -> int:\\n        A = SortedList()\\n        s = 0\\n        ans = 0\\n        A.add(0)\\n        for x in nums:\\n            s += x\\n            l = A.bisect_left(s-up)\\n            r = A.bisect_right(s-lo)\\n            ans += r - l\\n            A.add(s)\\n        return ans\\n```", "def countRangeSum(self, nums, lower, upper):\\n        n = len(nums)\\n        Sum, BITree = [0] * (n + 1), [0] * (n + 2)\\n        \\n        def count(x):\\n            s = 0\\n            while x:\\n                s += BITree[x]\\n                x -= (x & -x)\\n            return s\\n        \\n        def update(x):\\n            while x <= n + 1:\\n                BITree[x] += 1\\n                x += (x & -x)\\n                \\n        for i in range(n):\\n            Sum[i + 1] = Sum[i] + nums[i]\\n        sortSum, res = sorted(Sum), 0\\n        for sum_j in Sum:\\n            sum_i_count = count(bisect.bisect_right(sortSum, sum_j - lower)) - count(bisect.bisect_left(sortSum, sum_j - upper))\\n            res += sum_i_count\\n            update(bisect.bisect_left(sortSum, sum_j) + 1)\\n        return res"]}
{"id": "1819", "ref_py": ["def longestIncreasingPath(self, matrix):\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                val = matrix[i][j]\\n                dp[i][j] = 1 + max(\\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\\n                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,\\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\\n                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0)\\n            return dp[i][j]", "def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        is_valid = lambda i, j: 0 <= i < n and 0 <= j < m\\n        drn = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        outgoing = defaultdict(set)\\n        inDegree = {}\\n        for i in range(n):\\n            for j in range(m):\\n                inDegree[(i, j)] = 0\\n                for i_drn, j_drn in drn:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j):\\n                        if matrix[i][j] > matrix[new_i][new_j]:\\n                            inDegree[(i, j)] += 1\\n                            outgoing[(new_i, new_j)].add((i, j))\\n        \\n        queue = deque()\\n        \\n        for key in inDegree:\\n            if inDegree[key] == 0:\\n                queue.append((key, 1))\\n        ans = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                current, ln = queue.popleft()\\n                ans = max(ans, ln)\\n                for neigh in outgoing[current]:\\n                    inDegree[neigh] -= 1\\n                    if inDegree[neigh] == 0:\\n                        queue.append((neigh, ln+1))\\n        return ans\\n        ", "def longestIncreasingPath(self, matrix):\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                val = matrix[i][j]\\n                dp[i][j] = 1 + max(\\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\\n                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,\\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\\n                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0)\\n            return dp[i][j]"]}
{"id": "1820", "ref_py": ["def minPatches(self, nums: List[int], n: int) -> int:\\n    miss, i, patches = 1, 0, 0\\n    while miss <= n:\\n        if i < len(nums) and nums[i] <= miss:\\n            miss += nums[i]\\n            i += 1\\n        else:\\n            miss *= 2\\n            patches += 1\\n    return patches", "def minPatches(self, nums: List[int], ssum: int) -> int:\\n        n=len(nums)\\n        limit,cnt=0,0\\n        for i in range(n):\\n            if nums[i]>limit+1:\\n                while nums[i]>limit+1:\\n                    limit+=limit+1\\n                    cnt+=1\\n                    if limit>=ssum: break\\n            limit+=nums[i]\\n            if limit>=ssum: break\\n        while limit<ssum:\\n            limit+=limit+1\\n            cnt+=1\\n        return cnt", "def minPatches(self, nums: List[int], n: int) -> int:\\n    miss, i, patches = 1, 0, 0\\n    while miss <= n:\\n        if i < len(nums) and nums[i] <= miss:\\n            miss += nums[i]\\n            i += 1\\n        else:\\n            miss *= 2\\n            patches += 1\\n    return patches"]}
{"id": "1821", "ref_py": ["def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end", "def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end", "def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end"]}
{"id": "1822", "ref_py": ["def isSelfCrossing(self, x):\\n        return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\\n                   for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\\n                                            for i in xrange(len(x))))", "def isSelfCrossing(self, x: List[int]) -> bool:\\n    ", "def isSelfCrossing(self, distance):\\r\\n        return self.space_4_time(distance)\\r\\n\\r\\n    def space_4_time(self, distance):\\r\\n        if all(map(sub, distance[1:], distance[:-1])): return False  "]}
{"id": "1823", "ref_py": ["define a helper function (**isPal**) to check if a word is a palindrome. Rather than having to pass it a substring of a word, we can define it to take a range of indexes to check, so that we\\'re not constantly building new strings.", "define a helper function (**isPal**) to check if a word is a palindrome. Rather than having to pass it a substring of a word, we can define it to take a range of indexes to check, so that we\\'re not constantly building new strings.", "define a helper function (**isPal**) to check if a word is a palindrome. Rather than having to pass it a substring of a word, we can define it to take a range of indexes to check, so that we\\'re not constantly building new strings."]}
{"id": "1825", "ref_py": ["def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        LIS = []\\n        size = 0\\n        for (w, h) in envelopes:\\n            if not LIS or h > LIS[-1]:\\n                LIS.append(h)\\n                size += 1\\n            else:\\n                l, r = 0, size\\n                while l < r:\\n                    m = l + (r - l) // 2\\n                    if LIS[m] < h:\\n                        l = m + 1\\n                    else:\\n                        r = m\\n                LIS[l] = h\\n        return size\\n```\\nby @bettercoder168", "definite improvement.", "def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        \\n        res = []\\t\\t\\n\\t\\t"]}
{"id": "1826", "ref_py": ["def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        ", "def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:", "def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        ans = float(\"-inf\")\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(n):\\n            lstSum = [0] * m\\n            for j in range(i, n):\\n                currSum = 0\\n                curlstSum = [0]\\n                for t in range(m):\\n                    lstSum[t] += matrix[t][j]\\n                    currSum += lstSum[t]\\n                    pos = bisect_left(curlstSum, currSum - k)\\n                    if pos < len(curlstSum):\\n                        if curlstSum[pos] == currSum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, currSum - curlstSum[pos])\\n                    insort(curlstSum, currSum)\\n        return ans"]}
{"id": "1828", "ref_py": ["def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        ", "def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        ", "def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        "]}
{"id": "1829", "ref_py": ["def canCross(self, stones: List[int]) -> bool:\\n        m = {}  ", "def canCross(self, stones: List[int]) -> bool:\\n        m = {}  ", "def canCross(self, stones: List[int]) -> bool:\\n        m = {}  "]}
{"id": "1830", "ref_py": ["def trapRainWater(self, heightMap: List[List[int]]) -> int:\\n        ", "def trapRainWater(self, heightMap: List[List[int]]) -> int:\\n        if not heightMap or not heightMap[0]:\\n            return 0\\n        \\n        m, n = len(heightMap), len(heightMap[0])\\n        visited = [[False]*n for _ in range(m)]\\n        heap = []\\n        water_trapped = 0\\n        \\n        ", "def trapRainWater(self, heightMap: List[List[int]]) -> int:\\n        "]}
{"id": "1831", "ref_py": ["def countPartitions(self, nums, maxSum):\\n        partitions = 1\\n        subSum = 0\\n        for num in nums:\\n            if subSum + num <= maxSum:\\n                subSum += num\\n            else:\\n                partitions += 1\\n                subSum = num\\n        return partitions", "def countPartitions(self, nums, maxSum):\\n        partitions = 1\\n        subSum = 0\\n        for num in nums:\\n            if subSum + num <= maxSum:\\n                subSum += num\\n            else:\\n                partitions += 1\\n                subSum = num\\n        return partitions", "def countPartitions(self, nums, maxSum):\\n        partitions = 1\\n        subSum = 0\\n        for num in nums:\\n            if subSum + num <= maxSum:\\n                subSum += num\\n            else:\\n                partitions += 1\\n                subSum = num\\n        return partitions"]}
{"id": "1832", "ref_py": ["defined as one that satisfies the following criteria:", "defined as one that satisfies the following criteria:", "defined as one that satisfies the following criteria:"]}
{"id": "1834", "ref_py": ["def findKthNumber(self, n: int, k: int) -> int:\\n    cur = 1\\n    k -= 1\\n    while k > 0:\\n        steps = self.getSteps(n, cur, cur+1)\\n        if steps <= k:\\n            cur += 1\\n            k -= steps\\n        else:\\n            cur *= 10\\n            k -= 1\\n            \\n    return cur", "def findKthNumber(self, n, k):\\n        if k == 1: return 1\\n        return self.denary(n, k)", "def findKthNumber(self, n, k):\\n        if k == 1: return 1\\n        return self.denary(n, k)"]}
{"id": "1835", "ref_py": ["def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [{} for _ in range(n)]\\n        res = 0\\n        ", "def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[defaultdict(int)for _ in range(n)]\\n        output=0\\n        for i in range(n):\\n            for j in range(i):\\n                d=nums[i]-nums[j]\\n                dp[i][d] +=(1+dp[j][d])\\n                output +=dp[j][d]\\n        return output", "def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [{} for _ in range(n)]\\n        res = 0\\n        "]}
{"id": "1836", "ref_py": ["def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        return math.ceil(math.log(buckets, minutesToTest/minutesToDie + 1))\\n```\\n**Time complexity**: \\n - Ignore the log calculation: `O(1)`", "def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        ", "def poorPigs(self, buckets: int, minutes_to_die: int, minutes_to_test: int) -> int:\\n        pigs = log(buckets, minutes_to_test // minutes_to_die + 1)\\n        return round(pigs) if isclose(pigs, round(pigs)) else ceil(pigs)"]}
{"id": "1838", "ref_py": ["def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        dp = []\\n        for i in range(len(s2)):\\n            start = i\\n            cnt = 0\\n            for j in range(len(s1)):\\n                if s1[j] == s2[start]:\\n                    start += 1\\n                    if start == len(s2):\\n                        start = 0\\n                        cnt += 1\\n            dp.append((start,cnt))\\n        res = 0\\n        next = 0\\n        for _ in range(n1):\\n            res += dp[next][1]\\n            next = dp[next][0]\\n        return res // n2\\n", "def getMaxRepetitions(self, s1, n1, s2, n2):", "defined what \"contain\" is and the second function is to find maximum m."]}
{"id": "1839", "ref_py": ["def findAllConcatenatedWordsInADict(self, words):\\n        \\n        def is_concatenated(word, count):\\n            if word == \"\" and count >= 2:\\n                return True\\n            \\n            subword = \"\"\\n            for i in range(len(word)):\\n                subword += word[i] ", "def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s = set()\\n        concatenateWords = []\\n        for word in words:\\n            s.add(word)\\n        for word in words:\\n            if self.checkConcatenate(word, s) == True:\\n                concatenateWords.append(word)\\n        return concatenateWords\\n    def checkConcatenate(self, word: str, s: set) -> bool:\\n        for i in range(1, len(word)):\\n            prefixWord = word[:i]\\n            suffixWord = word[i:]\\n            if prefixWord in s and (suffixWord in s or self.checkConcatenate(suffixWord, s)):\\n                return True\\n        return False", "def __init__(self):\\n        self.children = [None] * 26\\n        self.is_end = False"]}
{"id": "1840", "ref_py": ["def largestPalindrome(self, n: int) -> int:\\n        ", "def largestPalindrome(self, n: int) -> int:\\n        ", "def largestPalindrome(self, n: int) -> int:\\n        "]}
{"id": "1841", "ref_py": ["def medianSlidingWindow(self, nums, k):\\n        window = SortedList(nums[:k])  ", "def find_median(self, max_heap, min_heap, heap_size):\\n        if heap_size % 2 == 1:\\n            return -max_heap[0]\\n        else:\\n            return (-max_heap[0] + min_heap[0]) / 2", "def find_median(self, max_heap, min_heap, heap_size):\\n        if heap_size % 2 == 1:\\n            return -max_heap[0]\\n        else:\\n            return (-max_heap[0] + min_heap[0]) / 2"]}
{"id": "1842", "ref_py": ["def smallestGoodBase(self, n: str) -> str:\\n        num = int(n)\\n        max_len = math.floor(math.log(num, 2)) + 1\\n        \\n        ", "def smallestGoodBase(self, n: str) -> str:\\n        num = int(n)\\n        max_len = math.floor(math.log(num, 2)) + 1\\n        \\n        ", "def smallestGoodBase(self, n: str) -> str:\\n        num = int(n)\\n        max_len = math.floor(math.log(num, 2)) + 1\\n        \\n        "]}
{"id": "1843", "ref_py": ["defined function.\\n7. Create a new hand string with the ball removed from the original hand string.\\n8. If the new board string is empty, return the current step count plus 1.\\n9. If the new board and hand tuple has not been visited before, add it to the queue and visited set with the step count incremented by 1.\\n10. If no solution is found, return -1.", "def findMinStep(self, board: str, hand: str) -> int:\\n        \\n        ", "def findMinStep(self, board: str, hand: str) -> int:\\n        \\n        "]}
{"id": "1844", "ref_py": ["def reversePairs(self, nums: List[int]) -> int:\\n        self.count = 0", "def reversePairs(self, nums: List[int]) -> int:\\n        ", "define a function merge_sort which takes in the starting and ending indices of a subarray and returns the count of reverse pairs within that subarray.\\n3. If the start index is greater than or equal to the end index, return 0 as there are no reverse pairs in a subarray of length 0 or 1.\\n4. Find the middle index of the subarray and recursively call merge_sort on the left and right halves of the subarray. Add the results of these recursive calls to count.\\n5. Initialize two pointers i and j to the start of the left and right halves, respectively. While both pointers are within their respective halves, compare the values at i and j. If the value at i is greater than twice the value at j, then increment count by the number of remaining elements in the left half (from i to mid). Increment j to move to the next element in the right half. Otherwise, increment i to move to the next element in the left half.\\n6. After counting the reverse pairs, merge the left and right halves of the subarray in sorted order.\\n7. Return count after all recursive calls have completed."]}
{"id": "1845", "ref_py": ["def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\\n        if w >= max(capital):\\n            return w + sum(nlargest(k, profits))\\n        cap_pro,executable_pro = [],[]\\n        for p,c in zip(profits,capital): heapq.heappush(cap_pro,(c,-p)) ", "def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\\n        n = len(profits)\\n        projects = [(capital[i], profits[i]) for i in range(n)]\\n        projects.sort()\\n        pq = []\\n        i = 0\\n        for _ in range(k):\\n            while i < n and projects[i][0] <= w:\\n                heapq.heappush(pq, -projects[i][1])\\n                i += 1\\n            if not pq:\\n                break\\n            w -= heapq.heappop(pq)\\n        return w\\n```", "def findMaximizedCapital(self, k: int, w: int, profits: list[int], capital: list[int]) -> int:\\n        pool = list(zip(capital, profits)); heapify(pool)\\n        available = []"]}
{"id": "1846", "ref_py": ["def findRotateSteps(self, ring: str, key: str) -> int:\\n        memo = {}\\n        def dp(i: int, j: int) -> int:\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if j == len(key):\\n                return 0\\n            ans = float(\\'inf\\')\\n            for k in range(len(ring)):\\n                if ring[k] == key[j]:\\n                    delta = abs(k - i)\\n                    steps = min(delta, len(ring) - delta)\\n                    ans = min(ans, steps + dp(k, j+1))\\n            memo[(i, j)] = ans\\n            return ans\\n        return dp(0, 0) + len(key)", "def findRotateSteps(self, ring, key):\\n        \\n        visited = {}\\n        heap = [[0, 0, ring]]\\n        heapq.heapify(heap)", "def findRotateSteps(self, ring, key):\\n        \\n        visited = {}\\n        heap = [[0, 0, ring]]\\n        heapq.heapify(heap)"]}
{"id": "1847", "ref_py": ["def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))", "def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        tmp=[]\\n        ans=[]\\n        dp=[-1]*n\\n        def lds(i,prev,tmp,ans):\\n            if i>=n:\\n                if len(tmp)>len(ans):\\n                    ans.append(tmp[:])\\n                return \\n            if len(tmp)>dp[i] and nums[i]%prev==0:\\n                dp[i]=len(tmp)\\n                tmp.append(nums[i])\\n                lds(i+1,nums[i],tmp,ans)\\n                tmp.pop()\\n            lds(i+1,prev,tmp,ans)\\n        lds(0,1,tmp,ans)\\n        p=[]\\n        res=0\\n        for i in ans:\\n            if len(i)>res:\\n                res=len(i)\\n                p=i\\n        return p", "def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))"]}
{"id": "1848", "ref_py": ["def removeBoxes(self, boxes: List[int]) -> int:\\n        ", "def removeBoxes(self, boxes: List[int]) -> int:\\n        colors, consecutive = [], []\\n        cnt = 0\\n        prev_color = None\\n        for color in boxes:\\n            if prev_color is None:\\n                cnt = 1\\n            elif color != prev_color:\\n                colors.append(prev_color)\\n                consecutive.append(cnt)\\n                cnt = 1\\n            else:\\n                cnt += 1\\n            prev_color = color\\n        colors.append(prev_color)\\n        consecutive.append(cnt)\\n                \\n        @cache\\n        def dp(i, j, carry_over):\\n            if i == j:\\n                return 0\\n            \\n            ", "def removeBoxes(self, boxes: List[int]) -> int:\\n        def f(i,j,count,dp):\\n            if i > j: return 0\\n            if dp[i][j][count] != -1:\\n                return dp[i][j][count]\\n            while i < j and boxes[i] == boxes[i+1]:\\n                i += 1\\n                count += 1\\n            ans = (count+1)*(count+1) + f(i+1,j,0,dp)\\n            for m in range(i+1,j+1):\\n                if boxes[m] == boxes[i]:\\n                    ans = max(ans,f(m,j,count+1,dp)+f(i+1,m-1,0,dp))\\n            dp[i][j][count] = ans\\n            return ans\\n        dp = []\\n        for i in range(len(boxes)):\\n            curr = []\\n            for j in range(len(boxes)):\\n                curr.append([-1 for _ in range(len(boxes))])\\n            dp.append(curr.copy())\\n        return f(0,len(boxes)-1,0,dp)\\n"]}
{"id": "1849", "ref_py": ["def checkRecord(self, n: int) -> int:\\n        kMod = 10**9 + 7\\n        dp = [[0] * 3 for _ in range(2)]\\n        dp[0][0] = 1", "def checkRecord(self, n: int) -> int:\\n    \\tC, m = [1,1,0,1,0,0], 10**9 + 7\\n    \\tfor i in range(n-1):\\n    \\t\\ta, b = sum(C[:3]) % m, sum(C[3:]) % m\\n    \\t\\tC = [a, C[0], C[1], a + b, C[3], C[4]]\\n    \\treturn (sum(C) % m)\\n\\t\\t\\n```\\n_Explanation_", "def checkRecord(self, n: int) -> int:\\n    \\tC, m = [1,1,0,1,0,0], 10**9 + 7\\n    \\tfor i in range(n-1):\\n    \\t\\ta, b = sum(C[:3]) % m, sum(C[3:]) % m\\n    \\t\\tC = [a, C[0], C[1], a + b, C[3], C[4]]\\n    \\treturn (sum(C) % m)\\n\\t\\t\\n```\\n_Explanation_"]}
{"id": "1850", "ref_py": ["def nearestPalindromic(self, n: str) -> str:\\n        ", "def nearestPalindromic(self, n: str) -> str:\\n        m = len(n)\\n        cand = [pow(10, m-1) - 1, pow(10, m) + 1]\\n        half = int(n[:(m+1) // 2])\\n        for x in range(half-1, half+2):\\n            y = x // 10 if m % 2 else x\\n            while y:\\n                x = x * 10 + y % 10\\n                y //= 10\\n            cand.append(x)\\n        target = int(n)\\n        return str(min(cand, key=lambda x: (abs(x - target) if x != target else inf, x)))\\n    \\n```", "def nearestPalindromic(self, n):\\n        if n == \"1\":\\n            return \"0\""]}
{"id": "1851", "ref_py": ["def outerTrees(self, points):\\n\\t\\n        def ccw(A, B, C):\\n            return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])", "def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def compare_slopes(point1, point2, point3):\\n            x_point1, y_point1 = point1\\n            x_point2, y_point2 = point2\\n            x_point3, y_point3 = point3\\n            return ((y_point3 - y_point2)*(x_point2 - x_point1)) - ((y_point2 - y_point1)*(x_point3 - x_point2))", "def outerTrees(self, points):\\n\\t\\n        def ccw(A, B, C):\\n            return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])"]}
{"id": "1852", "ref_py": ["defined: isValidCdata and isValidTagName. isValidCdata checks if a given string is a valid CDATA section, which starts with \\'<![CDATA[\\' and ends with \\']]>\\'. isValidTagName checks if a given tag name is valid. A tag name is valid if it is not empty, has a length of at most 9 characters, and all characters are uppercase. If isEndTag is True, it also checks if the corresponding start tag is at the top of the stack.", "defined: isValidCdata and isValidTagName. isValidCdata checks if a given string is a valid CDATA section, which starts with \\'<![CDATA[\\' and ends with \\']]>\\'. isValidTagName checks if a given tag name is valid. A tag name is valid if it is not empty, has a length of at most 9 characters, and all characters are uppercase. If isEndTag is True, it also checks if the corresponding start tag is at the top of the stack.", "defined: isValidCdata and isValidTagName. isValidCdata checks if a given string is a valid CDATA section, which starts with \\'<![CDATA[\\' and ends with \\']]>\\'. isValidTagName checks if a given tag name is valid. A tag name is valid if it is not empty, has a length of at most 9 characters, and all characters are uppercase. If isEndTag is True, it also checks if the corresponding start tag is at the top of the stack."]}
{"id": "1853", "ref_py": ["def findIntegers(self, n: int) -> int:\\n        ", "def findIntegers(self, n: int) -> int:\\n\\tif n <= 1: return n + 1\\n\\tk = int(log2(n))            \\n", "def findIntegers(self, n: int) -> int:\\n\\tif n <= 1: return n + 1\\n\\tk = int(log2(n))            \\n"]}
{"id": "1855", "ref_py": ["def kInversePairs(self, n: int, k: int) -> int:\\n        \\n        max_possible_inversions = (n * (n-1)//2)\\n        if k > max_possible_inversions:\\n            return 0\\n        if k == 0 or k == max_possible_inversions:\\n            return 1\\n        \\n        MOD = pow(10,9) + 7\\n        \\n        dp = [[0]*(k+1) for _ in range(n+1)]\\n        \\n        for i in range(1, n+1):\\n            dp[i][0] = 1", "def kInversePairs(self, n: int, k: int) -> int:\\n        mod = 10**9 + 7\\n        dp = [0 for _ in range(k + 1)]\\n        dp[-1] = 1\\n        \\n        for i in range(n):\\n            new = [0 for _ in range(k + 1)]\\n            for j in range(k, -1, -1):\\n                for j2 in range(j, min(k + 1, j + n - i)):\\n                    new[j] = (new[j] + dp[j2]) % mod\\n                    \\n            dp = new\\n        return dp[0]\\n```", "def kInversePairs(self, n: int, k: int) -> int:\\n        mod = 10**9 + 7\\n        dp = [0 for _ in range(k + 1)]\\n        dp[-1] = 1\\n        \\n        for i in range(n):\\n            new = [0 for _ in range(k + 1)]\\n            for j in range(k, -1, -1):\\n                for j2 in range(j, min(k + 1, j + n - i)):\\n                    new[j] = (new[j] + dp[j2]) % mod\\n                    \\n            dp = new\\n        return dp[0]\\n```"]}
{"id": "1856", "ref_py": ["defaults to a **min heap**, we can just switch the sign before insertion and after extraction to mimic a **max heap**.", "def scheduleCourse(self, courses):\\n        ", "def scheduleCourse(self, courses: List[List[int]]) -> int:\\n\\t\\t"]}
{"id": "1857", "ref_py": ["def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        ", "def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        ", "def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        "]}
{"id": "1858", "ref_py": ["def numDecodings(self, s: str) -> int:\\n        mapping = dict(zip(map(str, range(1, 27)), [1]*26))\\n        mapping[\"1*\"] = 9\\n        mapping[\"2*\"] = 6\\n        mapping[\"*\"] = 9\\n        mapping[\"**\"] = 15\\n        dp = [0]*(len(s)+1)\\n        dp[len(s)] = 1\\n        dp[len(s)-1] = mapping[s[len(s)-1]] if s[len(s)-1] != \"0\" else 0\\n        mod = 10**9+7\\n        for i in reversed(range(len(s)-1)):\\n            if s[i] in mapping:\\n                dp[i] += (mapping[s[i]]*dp[i+1])%mod\\n            if i < len(s)-1:\\n                key = s[i:i+2]\\n                if key in mapping:\\n                    dp[i] += (mapping[key]*dp[i+2])%mod\\n                elif s[i] == \"*\":\\n                    if s[i+1] <= \"6\":\\n                        dp[i] += (2*dp[i+2])%mod\\n                    else:\\n                        dp[i] += dp[i+2]%mod\\n        return dp[0]%(mod)\\n                    \\n                \\n```", "def numDecodings(self, s: str) -> int:\\n        \\n        n = len(s)\\n        \\n        @cache\\n        def dp(i=0):\\n            \\n            ", "def numDecodings(self, s: str) -> int:\\n        \\n        n = len(s)\\n        \\n        @cache\\n        def dp(i=0):\\n            \\n            "]}
{"id": "1859", "ref_py": ["def strangePrinter(self, s: str) -> int:\\n        n=len(s)\\n        if not s:\\n            return 0", "define `f(low, high) = minimal prints needed to print s[low:high+1]`. Suppose we work with `s = \"abaca\"`. We call `sp(\"abaca\") = f(0,4)`. By observation 3, we will print `a`\\'s first. In this case, it is optimal to print `\"aaaaa\"`. After doing so, what exactly do we recurse on? My initial thought is to recurse on `\"bac\"` since the first and last `\"a\"` in `s` are correctly printed. Let\\'s not worry about the exact recursive relationship here since anything you can come up with for this definition of `f` will be wrong (and I will explain why). This is just a demo incorrect relationship. ", "define the function `minTurns(s)` which takes a string `s` as input.\\n- `n = len(s)` calculates the length of the input string `s`.\\n- `dp = [[0] * n for _ in range(n)]` initializes a 2D DP (Dynamic Programming) table with `n` rows and `n` columns, where `dp[i][j]` will store the minimum number of turns needed to print the substring `s[i:j+1]` (inclusive) using the given printer properties."]}
{"id": "1860", "ref_py": ["def findKthNumber(self, m: int, n: int, k: int) -> int:\\n        \\n        ", "def findKthNumber(self, m: int, n: int, k: int) -> int:\\n\\t\\tif k == 1 or k == m*n:\\n\\t\\t\\treturn k\\n\\t\\t", "def findKthNumber(self, m: int, n: int, k: int) -> int:\\n        \\n        "]}
{"id": "1861", "ref_py": ["define a bfs function which takes in the starting coordinates sx and sy, and the target coordinates tx and ty. We use a heap to implement Dijkstra\\'s algorithm for finding the shortest path. We keep track of the minimum distance d, current coordinates x and y, and push the tuple (d, x, y) into the heap.", "def cutOffTree(self, forest: List[List[int]]) -> int:\\n        self.createTreeLocationsPriorityQueue(forest)\\n        steps = 0\\n        treeLoc = self.getNextTreeLocation()\\n        currLoc = (0,0)\\n        while treeLoc != -1: \\n\\t\\t", "define a bfs function which takes in the starting coordinates sx and sy, and the target coordinates tx and ty. We use a heap to implement Dijkstra\\'s algorithm for finding the shortest path. We keep track of the minimum distance d, current coordinates x and y, and push the tuple (d, x, y) into the heap."]}
{"id": "1862", "ref_py": ["def judgePoint24(self, nums: List[int]) -> bool:\\n    def generate(a: float, b: float) -> List[float]:\\n      return [a * b,\\n              math.inf if b == 0 else a / b,\\n              math.inf if a == 0 else b / a,\\n              a + b, a - b, b - a]", "def judgePoint24(self, cards: List[int]) -> bool:\\n        \\n        self.allcombos = []\\n        \\n        ", "def judgePoint24(self, cards: List[int]) -> bool:\\n        \\n        self.allcombos = []\\n        \\n        "]}
{"id": "1863", "ref_py": ["def findRedundantDirectedConnection(self, edges):\\n        \\n        incomingEdge = collections.defaultdict(list)\\n        parents = [i for i in range (len(edges)+1)]\\n        ", "def __init__(self, n: int):\\n    self.parent = list(range(n))\\n    self.rank = [0] * n", "def findRedundantDirectedConnection(self, edges):\\n        \\n        incomingEdge = collections.defaultdict(list)\\n        parents = [i for i in range (len(edges)+1)]\\n        "]}
{"id": "1864", "ref_py": ["def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        \\n        ", "def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:", "def maxSumOfThreeSubarraysCustom(self, nums: List[int], k: int) -> List[int]:\\n        res = self.window_sum(nums, k, 0, 0)\\n        return res[1]"]}
{"id": "1865", "ref_py": ["def minStickers(self, W: List[str], target: str) -> int:\\n        A = []\\n        \\n        NL = 26\\n        for w in W:\\n            l = [0] * NL\\n            for c in w:\\n                l[ord(c) - ord(\\'a\\')] += 1\\n            A.append(l)\\n        \\n        T = [0] * NL\\n        for c in target:\\n            T[ord(c) - ord(\\'a\\')] += 1\\n        \\n        X = len(A)\\n        @cache\\n        def dp(i,state):\\n            if sum(state) == 0: return 0\\n            if i >= X: return inf\\n            \\n            s1 = dp(i+1,state)\\n            s2 = inf\\n            for x,y in zip(state, A[i]):\\n                if x and y:\\n                    break\\n            else:\\n                return s1\\n            S = list(state)\\n            for j,(x,y) in enumerate(zip(state, A[i])):\\n                if x and y:\\n                    S[j] = max(0,x-y)\\n            s2 = 1 + dp(i, tuple(S))\\n            return min(s1,s2)\\n        \\n        ans = dp(0,tuple(T))\\n        return -1 if ans == inf else ans\\n```", "def minStickers(self, stickers: List[str], target: str) -> int:\\n        tgt = Counter(target)\\n        sticker_map = defaultdict(list)\\n        visited = set()\\n\\t\\t\\n        for sticker in stickers:\\n            for c in set(sticker):\\n                sticker_map[c].append(Counter(sticker))\\n        \\n\\t\\t", "def minStickers(self, W: List[str], target: str) -> int:\\n        A = []\\n        \\n        NL = 26\\n        for w in W:\\n            l = [0] * NL\\n            for c in w:\\n                l[ord(c) - ord(\\'a\\')] += 1\\n            A.append(l)\\n        \\n        T = [0] * NL\\n        for c in target:\\n            T[ord(c) - ord(\\'a\\')] += 1\\n        \\n        X = len(A)\\n        @cache\\n        def dp(i,state):\\n            if sum(state) == 0: return 0\\n            if i >= X: return inf\\n            \\n            s1 = dp(i+1,state)\\n            s2 = inf\\n            for x,y in zip(state, A[i]):\\n                if x and y:\\n                    break\\n            else:\\n                return s1\\n            S = list(state)\\n            for j,(x,y) in enumerate(zip(state, A[i])):\\n                if x and y:\\n                    S[j] = max(0,x-y)\\n            s2 = 1 + dp(i, tuple(S))\\n            return min(s1,s2)\\n        \\n        ans = dp(0,tuple(T))\\n        return -1 if ans == inf else ans\\n```"]}
{"id": "1866", "ref_py": ["def fallingSquares(self, positions: List[List[int]]) -> List[int]:\\n        ", "def __init__(self, total, left_index, right_index):\\n        self.total=total\\n        self.left=None\\n        self.right=None\\n        self.left_index=left_index\\n        self.right_index=right_index\\n        self.lazy=0\\n    \\n    @staticmethod\\n    def init(left, right):\\n        if left==right:\\n            return Segment(0, left, right)\\n        mid=(left+right)//2\\n        root=Segment(0, left, right)\\n        root.left=Segment.init(left, mid)\\n        root.right=Segment.init(mid+1, right)\\n        return root", "definitely not the most concise, but I think it\\'s logically clear what\\'s happening. The comments explain everything but the strategy is to keep a list of ranges and find the tallest height of the ranges which intersect the shadow of the new square. While we find this height, we can simultaneously update/remove ranges to account for this new square. Any partially covered range gets chopped off at the corresponding edge of the new square. Any range that is completely covered by the square gets deleted. If the square is in the middle of a range, then the range gets cut off at the left side of the new square and a new range covers from the right side onward until the end of the original range."]}
{"id": "1869", "ref_py": ["def smallestDistancePair(nums, k):\\n    ", "def smallestDistancePair(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n    nums.sort()", "def smallestDistancePair(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n    nums.sort()"]}
{"id": "1870", "ref_py": ["def countOfAtoms(self, formula: str) -> str:\\n        stack, elem, i = [{}], \"\", 0\\n        \\n        while i < len(formula):\\n            ", "def countOfAtoms(self, formula: str) -> str:\\n        stack, elem, i = [{}], \"\", 0\\n        \\n        while i < len(formula):\\n            ", "def countOfAtoms(self, formula: str) -> str:\\n        stack, elem, i = [{}], \"\", 0\\n        \\n        while i < len(formula):\\n            "]}
{"id": "1871", "ref_py": ["def countPalindromicSubsequences(self, S):\\n        \\n        def cache(start, end):            ", "def countPalindromicSubsequences(self, s: str):\\n    M = 10**9 + 7", "def countPalindromicSubsequences(self, s: str):\\n    M = 10**9 + 7"]}
{"id": "1873", "ref_py": ["def parse(e: str) -> list[str]:\\n    tokens, s, parenthesis = [], \\'\\', 0", "def evaluate(self, expression: str) -> int:\\n        stack = []\\n        parenEnd = {}\\n        \\n        ", "def parse(e: str) -> list[str]:\\n    tokens, s, parenthesis = [], \\'\\', 0"]}
{"id": "1874", "ref_py": ["def cherryPickup(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        memo = [[[None] * N for _1 in range(N)] for _2 in range(N)]", "def cherryPickup(self, grid: List[List[int]]) -> int:\\n        r=len(grid)\\n        c=len(grid[0])\\n        \\n        dp=[[[None for _ in range(r)] for _ in range(r)]for _ in range(r)]\\n        \\n        def rec(grid,r,c,rp1,cp1,rp2,cp2,dp):\\n            if rp1>=r or cp1>=c or rp2>=r or cp2>=c or grid[rp1][cp1]==-1 or grid[rp2][cp2]==-1:\\n                return -math.inf\\n            if dp[rp1][cp1][cp2]!=None:\\n                return dp[rp1][cp1][cp2]\\n            collectedcherries=0\\n            if rp1==r-1 and cp1==c-1:\\n                return grid[rp1][cp1]\\n            if rp2==r-1 and cp2==c-1:\\n                return grid[rp2][cp2]\\n            \\n            if rp1==rp2 and cp1==cp2:\\n                collectedcherries+=grid[rp1][cp1]\\n            else:\\n                collectedcherries+=(grid[rp1][cp1]+grid[rp2][cp2])\\n            ", "def cherryPickup(self, grid: List[List[int]]) -> int:\\n"]}
{"id": "1876", "ref_py": ["def dfs(i, j, visited):\\n```", "def containVirus(self, mat: List[List[int]]) -> int:\\n        m,n = len(mat),len(mat[0])", "def dfs(i, j, visited):\\n```"]}
{"id": "1877", "ref_py": ["def dfs(self, node, k, seen, result):\\n    for i in range(k):\\n        edge = node + str(i)", "defaultdict", "def crackSafe(self, n, k):\\n        \\n        "]}
{"id": "1878", "ref_py": ["def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda e: (e[1], -e[0]))", "def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda e: (e[1], -e[0]))", "def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda e: (e[1], -e[0]))"]}
{"id": "1879", "ref_py": ["def makeLargestSpecial(self, s: str) -> str:\\n        count = i = 0\\n        res = []\\n        for j, c in enumerate(s):\\n            count += 1 if c == \\'1\\' else -1\\n            if count == 0:\\n                res.append(\\'1\\' + self.makeLargestSpecial(s[i + 1:j]) + \\'0\\')\\n                i = j + 1\\n        return \\'\\'.join(sorted(res)[::-1])", "definition of the special string as \\'(\\' and \\')\\' separately,", "definition of the special string as \\'(\\' and \\')\\' separately,"]}
{"id": "1880", "ref_py": ["def minSwapsCouples(self, row: List[int]) -> int:\\n    ...\\n    n = len(row) // 2\\n    parent = [i for i in range(n)]\\n    ...\\n```", "def minSwapsCouples(self, row: List[int]) -> int:\\n        \\n        move = 0 ", "def minSwapsCouples(self, row: List[int]) -> int:\\n    ...\\n    n = len(row) // 2\\n    parent = [i for i in range(n)]\\n    ...\\n```"]}
{"id": "1881", "ref_py": ["def maxChunksToSorted(self, nums: List[int]) -> int:\\n        \\n        st = []\\n        for n in nums:\\n            if len(st)==0 or st[-1]<=n:\\n                st.append(n)\\n            else:\\n                ma = st[-1]\\n                while st and st[-1]>n:\\n                    ma = max(ma,st.pop())\\n                st.append(ma)\\n        \\n        return len(st)", "def maxChunksToSorted(self, nums: List[int]) -> int:\\n        \\n        st = []\\n        for n in nums:\\n            if len(st)==0 or st[-1]<=n:\\n                st.append(n)\\n            else:\\n                ma = st[-1]\\n                while st and st[-1]>n:\\n                    ma = max(ma,st.pop())\\n                st.append(ma)\\n        \\n        return len(st)", "def maxChunksToSorted(self, nums: List[int]) -> int:\\n        \\n        st = []\\n        for n in nums:\\n            if len(st)==0 or st[-1]<=n:\\n                st.append(n)\\n            else:\\n                ma = st[-1]\\n                while st and st[-1]>n:\\n                    ma = max(ma,st.pop())\\n                st.append(ma)\\n        \\n        return len(st)"]}
{"id": "1882", "ref_py": ["def split(i: int,  stack: list) -> int: \\n\\t\\t\\t\\n            while i < len(exprs):\\n                if exprs[i] == \\')\\': return i\\n                elif exprs[i] == \\'(\\':\\n                    stack.append([])\\n                    i = split(i+1, stack[-1]) ", "def __init__(self, exp: Optional[str]=\\'\\', *, term: Optional[Mapping[str, int]]={}) -> None:\\n        self.d = defaultdict(int, **term)\\n        ", "defaultdict"]}
{"id": "1883", "ref_py": ["def slidingPuzzle(self, board: List[List[int]]) -> int:\\n\\t", "define neighboring index relations in a graph ```g``` as board size is fixed and small.", "def slidingPuzzle(self, board: List[List[int]]) -> int:\\n\\t"]}
{"id": "1884", "ref_py": ["defaults to a max priority queue, so we can just flip the signs on each of the insertions and extractions to convert to a min priority queue.", "definitely there is no path in time <= t. So, we need to search in the boundary [t+1, max height of buildings in grid].", "def swimInWater(self, grid: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\theap = [(grid[0][0], [0, 0])]\\n\\tvis = {(0, 0)}\\n\\tans = 0\\n\\twhile(True):\\n\\t\\tht, [i, j] = heappop(heap)\\n\\t\\tans = max(ans, ht)\\n\\t\\tif(i == j == n-1):\\n\\t\\t\\treturn ans\\n\\t\\tfor x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tvis.add((i+x, j+y))\\n"]}
{"id": "1885", "ref_py": ["def reachingPoints(self, sx, sy, tx, ty):\\n        \\n        ", "def reachingPoints(self, sx, sy, tx, ty):\\n        \\n        ", "def reachingPoints(self, sx, sy, tx, ty):\\n        \\n        "]}
{"id": "1886", "ref_py": ["def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\\n                    return -1\\n        \\n        row_sum = sum(board[0])\\n        col_sum = sum(board[i][0] for i in range(n))", "def movesToChessboard(self, board):\\n        N = len(board)\\n        ans = 0\\n        ", "def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\\n                    return -1\\n        \\n        row_sum = sum(board[0])\\n        col_sum = sum(board[i][0] for i in range(n))"]}
{"id": "1887", "ref_py": ["def preimageSizeFZF(self, k: int) -> int:\\n        def count_trailing_zeros(n: int) -> int:\\n            count = 0\\n            while n > 0:\\n                n //= 5\\n                count += n\\n            return count", "def preimageSizeFZF(self, k: int) -> int:\\n        def count_trailing_zeros(n: int) -> int:\\n            count = 0\\n            while n > 0:\\n                n //= 5\\n                count += n\\n            return count", "def preimageSizeFZF(self, k: int) -> int:\\n        def count_trailing_zeros(n: int) -> int:\\n            count = 0\\n            while n > 0:\\n                n //= 5\\n                count += n\\n            return count"]}
{"id": "1888", "ref_py": ["def bestRotation(self, nums: List[int]) -> int:", "definitely ingenious. Here is another idea with heap/pirority queue at O(NlogN) for reference.", "definitely ingenious. Here is another idea with heap/pirority queue at O(NlogN) for reference."]}
{"id": "1889", "ref_py": ["def dp(self, nums1, nums2, prev1, prev2, i, swapped, lookup):\\n        if i == len(nums1):\\n            return 0\\n        \\n        key = (i, swapped)\\n        if key not in lookup:\\n            minSwaps = sys.maxsize\\n            ", "def dp(self, nums1, nums2, prev1, prev2, i, swapped, lookup):\\n        if i == len(nums1):\\n            return 0\\n        \\n        key = (i, swapped)\\n        if key not in lookup:\\n            minSwaps = sys.maxsize\\n            ", "def dp(self, nums1, nums2, prev1, prev2, i, swapped, lookup):\\n        if i == len(nums1):\\n            return 0\\n        \\n        key = (i, swapped)\\n        if key not in lookup:\\n            minSwaps = sys.maxsize\\n            "]}
{"id": "1890", "ref_py": ["def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        ", "defaultdict", "def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        "]}
{"id": "1891", "ref_py": ["def splitArraySameAverage(self, nums: List[int]) -> bool:", "def splitArraySameAverage(self, nums: List[int]) -> bool:\\n        total_sum = sum(nums)\\n        n = len(nums)\\n        \\n        if all(total_sum * i % n != 0 for i in range(1, n // 2 + 1)):\\n            return False", "def splitArraySameAverage(self, nums: List[int]) -> bool:"]}
{"id": "1892", "ref_py": ["default because there are no moves left for Bob to make without losing.", "def xorGame(self, nums: List[int]) -> bool:\\n        test, i = 0, 0\\n        for n in nums:\\n            test = test ^ n\\n            i += 1\\n        return True if test == 0 else i % 2 == 0\\n```", "default because there are no moves left for Bob to make without losing."]}
{"id": "1893", "ref_py": ["def numBusesToDestination(self, routes, source, target):\\n        if source == target:\\n            return 0", "def numBusesToDestination(self, routes: List[List[int]], s: int, t: int) -> int:\\n        mp = {}\\n        n = len(routes)", "def numBusesToDestination(self, routes: List[List[int]], s: int, t: int) -> int:\\n        mp = {}\\n        n = len(routes)"]}
{"id": "1894", "ref_py": ["def racecar(self, target: int) -> int:\\n        q = deque([(0, 1, 0)])\\n        v = set()\\n        \\n        while q:\\n            p, s, t = q.popleft()\\n            if p == target:\\n                return t", "def racecar(self, target: int) -> int:\\n        q = deque([(0, 1, 0)])\\n        v = set()\\n        \\n        while q:\\n            p, s, t = q.popleft()\\n            if p == target:\\n                return t", "def racecar(self, target: int) -> int:\\n        q = deque([(0, 1, 0)])\\n        v = set()\\n        \\n        while q:\\n            p, s, t = q.popleft()\\n            if p == target:\\n                return t"]}
{"id": "1895", "ref_py": ["def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.size = [1] * size", "def largestIsland(self, grid: List[List[int]]) -> int:\\n        def find(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=find(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=find(u),find(v)\\n            if pu==pv:\\n                return \\n            if size[pv]>size[pu]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n        \\n        n=len(grid)\\n        parent=[i for i in range(n*n)]\\n        size=[1 for i in range(n*n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    a=i*n+j\\n                    for u,v in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                        if 0<=u<n and 0<=v<n and grid[u][v]:\\n                            b=u*n+v\\n                            union(a,b)\\n        m=0 \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]==0:\\n", "def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.size = [1] * size"]}
{"id": "1896", "ref_py": ["def uniqueLetterString(self, S):\\n        index = {c: [-1, -1] for c in ascii_uppercase}\\n        res = 0\\n        for i, c in enumerate(S):\\n            k, j = index[c]\\n            res += (i - j) * (j - k)\\n            index[c] = [j, i]\\n        for c in index:\\n            k, j = index[c]\\n            res += (len(S) - j) * (j - k)\\n        return res % (10**9 + 7)\\n```", "def uniqueLetterString(self, s: str) -> int:\\n        dict_index = {}\\n        seen = set()\\n        \\n        for i in range(len(s)):\\n            if s[i] not in seen:\\n                seen.add(s[i])\\n                dict_index[s[i]] = [i]\\n            else:\\n                dict_index[s[i]].append(i)\\n        \\n        print(\"dict_index: \", dict_index)\\n        print(\"seen: \", seen)", "def uniqueLetterString(self, S):\\n        index = {c: [-1, -1] for c in ascii_uppercase}\\n        res = 0\\n        for i, c in enumerate(S):\\n            k, j = index[c]\\n            res += (i - j) * (j - k)\\n            index[c] = [j, i]\\n        for c in index:\\n            k, j = index[c]\\n            res += (len(S) - j) * (j - k)\\n        return res % (10**9 + 7)\\n```"]}
{"id": "1897", "ref_py": ["def consecutiveNumbersSum(self, n: int) -> int:\\n        i=1\\n        res=0\\n        k=int((n*2)**0.5)\\n        while i<=k:\\n            if i%2:\\n                if n%i==0:\\n                    res+=1\\n            elif (n-(i//2))%i==0:\\n                res+=1\\n            i+=1\\n        return res\\n```", "def consecutiveNumbersSum(self, n: int) -> int:\\n        i=1\\n        res=0\\n        k=int((n*2)**0.5)\\n        while i<=k:\\n            if i%2:\\n                if n%i==0:\\n                    res+=1\\n            elif (n-(i//2))%i==0:\\n                res+=1\\n            i+=1\\n        return res\\n```", "def consecutiveNumbersSum(self, n: int) -> int:\\n        i=1\\n        res=0\\n        k=int((n*2)**0.5)\\n        while i<=k:\\n            if i%2:\\n                if n%i==0:\\n                    res+=1\\n            elif (n-(i//2))%i==0:\\n                res+=1\\n            i+=1\\n        return res\\n```"]}
{"id": "1898", "ref_py": ["definitely HARD (or not after you know what\\'s going on???) and interesting.", "definitely HARD (or not after you know what\\'s going on???) and interesting.", "definitely HARD (or not after you know what\\'s going on???) and interesting."]}
{"id": "1899", "ref_py": ["def similar(self, string1, string2):\\n        count = 0\\n        if string1 == string2: return True\\n        \\n        for i in range(len(string2)):\\n            if string1[i] != string2[i]: count += 1\\n            if count > 2: return False\\n            \\n        return count == 2\\n    \\n    def graph(self, strs):\\n        n = len(strs)\\n        group = {string: [] for string in strs}\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if self.similar(strs[i], strs[j]):\\n                    group[strs[i]].append(strs[j])\\n                    group[strs[j]].append(strs[i])\\n    \\n        return group\\n                \\n    def bfs(self,visited, node, graph):\\n        q = collections.deque([node])\\n        visited.add(node)\\n        \\n        while q:\\n            curr_node = q.popleft()\\n            for neighbor in graph[curr_node]:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    q.append(neighbor)\\n        \\n        \\n    def numSimilarGroups(self, strs: List[str]) -> int:\\n        group = self.graph(strs)\\n        visited = set()\\n        group_count = 0\\n        \\n        for node in group:\\n            if node not in visited:\\n                self.bfs(visited, node, group)\\n                group_count += 1\\n                \\n        return group_count\\n        \\n```", "def __init__(self, n):\\n        self.parents = list(range(n))\\n        \\n    def find(self, x):\\n        if self.parents[x] != x:\\n            return self.find(self.parents[x])\\n        return x\\n    \\n    def union(self, u, v):\\n        self.parents[self.find(u)] = self.find(v)", "def numSimilarGroups(self, strs: list[str]) -> int:\\n        is_similar = lambda s1, s2: sum(map(ne, s1, s2)) in (0, 2)\\n        splat = lambda f: lambda args: f(*args)\\n        \\n        pairs = filter(splat(is_similar), product(strs, strs))"]}
{"id": "1900", "ref_py": ["def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        while wordlist:\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            ", "def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        while wordlist:\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            ", "def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        while wordlist:\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            "]}
{"id": "1901", "ref_py": ["def shortestPathLength(self, graph: List[List[int]]) -> int:\\n        n = len(graph)", "def shortestPathLength(self, graph: List[List[int]]) -> int:\\n    n, success = len(graph), (1 << len(graph)) - 1\\n    if n == 1:\\n      return 0", "def shortestPathLength(self, graph: List[List[int]]) -> int:\\n        "]}
{"id": "1902", "ref_py": ["def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n    def mergeIntervals(intervals):\\n        if not intervals: return []\\n        intervals.sort()\\n        res = [[*intervals[0]]]\\n        for i in range(1, len(intervals)):\\n            left, right = intervals[i]\\n            if left <= res[-1][1]:\\n                res[-1][1] = max(right, res[-1][1])\\n            else:\\n                res.append([left, right])\\n        return res\\n    \\n    x = defaultdict(list)\\n    for x1,y1,x2,y2 in rectangles:\\n        x[x1].append([1, y1, y2])\\n        x[x2].append([-1, y1, y2])\\n    \\n    x_vals = sorted(x.keys())\\n    c_intervals = defaultdict(int)\\n    area = 0\\n    for i in range(len(x_vals)-1):\\n        for freq,y1,y2 in x[x_vals[i]]:\\n            c_intervals[(y1, y2)] += freq\\n        \\n        intervals = mergeIntervals([interval for interval,f in c_intervals.items() if f])\\n        area += sum([(y2 - y1)*(x_vals[i+1] - x_vals[i]) for y1,y2 in intervals])\\n    \\n    return area%1000000007", "def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n    def mergeIntervals(intervals):\\n        if not intervals: return []\\n        intervals.sort()\\n        res = [[*intervals[0]]]\\n        for i in range(1, len(intervals)):\\n            left, right = intervals[i]\\n            if left <= res[-1][1]:\\n                res[-1][1] = max(right, res[-1][1])\\n            else:\\n                res.append([left, right])\\n        return res\\n    \\n    x = defaultdict(list)\\n    for x1,y1,x2,y2 in rectangles:\\n        x[x1].append([1, y1, y2])\\n        x[x2].append([-1, y1, y2])\\n    \\n    x_vals = sorted(x.keys())\\n    c_intervals = defaultdict(int)\\n    area = 0\\n    for i in range(len(x_vals)-1):\\n        for freq,y1,y2 in x[x_vals[i]]:\\n            c_intervals[(y1, y2)] += freq\\n        \\n        intervals = mergeIntervals([interval for interval,f in c_intervals.items() if f])\\n        area += sum([(y2 - y1)*(x_vals[i+1] - x_vals[i]) for y1,y2 in intervals])\\n    \\n    return area%1000000007", "def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n    def mergeIntervals(intervals):\\n        if not intervals: return []\\n        intervals.sort()\\n        res = [[*intervals[0]]]\\n        for i in range(1, len(intervals)):\\n            left, right = intervals[i]\\n            if left <= res[-1][1]:\\n                res[-1][1] = max(right, res[-1][1])\\n            else:\\n                res.append([left, right])\\n        return res\\n    \\n    x = defaultdict(list)\\n    for x1,y1,x2,y2 in rectangles:\\n        x[x1].append([1, y1, y2])\\n        x[x2].append([-1, y1, y2])\\n    \\n    x_vals = sorted(x.keys())\\n    c_intervals = defaultdict(int)\\n    area = 0\\n    for i in range(len(x_vals)-1):\\n        for freq,y1,y2 in x[x_vals[i]]:\\n            c_intervals[(y1, y2)] += freq\\n        \\n        intervals = mergeIntervals([interval for interval,f in c_intervals.items() if f])\\n        area += sum([(y2 - y1)*(x_vals[i+1] - x_vals[i]) for y1,y2 in intervals])\\n    \\n    return area%1000000007"]}
{"id": "1903", "ref_py": ["def kSimilarity(A, B):\\n\\tdef nei(x):\\n\\t\\ti = 0\\n\\t\\twhile x[i] == B[i]: i+=1\\n\\t\\tfor j in range(i+1, len(x)):\\n\\t\\t\\tif x[j] == B[i]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\\n\\tq, seen = [(A,0)], {A}\\n\\tfor x, d in q:\\n\\t\\tif x == B: return d\\n\\t\\tfor y in nei(x):\\n\\t\\t\\tif y not in seen:\\n", "def kSimilarity(self, A: str, B: str) -> int:\\n        N = len(A)\\n        def dfs(A, B, pos):\\n            if A == B:\\n                return 0\\n            \\n            while A[pos] == B[pos]:\\n                pos += 1\\n                \\n            minCnt = float(\\'inf\\')\\n            for i in range(pos + 1, N):\\n                if B[i] == A[pos] and B[i] != A[i]:\\n                    B[i], B[pos] = B[pos], B[i]\\n                    tmp = dfs(A, B, pos + 1) + 1\\n                    minCnt = min(tmp, minCnt)\\n                    B[i], B[pos] = B[pos], B[i]\\n                    \\n            return minCnt\\n        \\n        return dfs(list(A), list(B), 0)", "def kSimilarity(A, B):\\n\\tdef nei(x):\\n\\t\\ti = 0\\n\\t\\twhile x[i] == B[i]: i+=1\\n\\t\\tfor j in range(i+1, len(x)):\\n\\t\\t\\tif x[j] == B[i]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\\n\\tq, seen = [(A,0)], {A}\\n\\tfor x, d in q:\\n\\t\\tif x == B: return d\\n\\t\\tfor y in nei(x):\\n\\t\\t\\tif y not in seen:\\n"]}
{"id": "1904", "ref_py": ["def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\\n        n = len(quality)\\n        workers = []", "def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\\n        \\n        ", "def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\\n        n = len(quality)\\n        workers = []"]}
{"id": "1905", "ref_py": ["def shortestSubarray(self, A, K):\\n        d = collections.deque([[0, 0]])\\n        res, cur = float(\\'inf\\'), 0\\n        for i, a in enumerate(A):\\n            cur += a\\n            while d and cur - d[0][1] >= K:\\n                res = min(res, i + 1 - d.popleft()[0])\\n            while d and cur <= d[-1][1]:\\n                d.pop()\\n            d.append([i + 1, cur])\\n        return res if res < float(\\'inf\\') else -1\\n```\\n<br>", "def shortestSubarray(self, A: List[int], K: int) -> int:\\n        pre = [0]\\n        for num in A:\\n            pre.append(pre[-1]+num)\\n            \\n        deque = collections.deque()\\n        result = float(inf)\\n        for i,sum_ in enumerate(pre):\\n            \\n            while(deque and deque[-1][1] >=sum_):\\n                deque.pop()\\n            \\n            while deque and sum_ - deque[0][1] >= K:\\n                result = min(i-deque[0][0], result)\\n                deque.popleft()\\n                \\n            deque.append([i,sum_])\\n        return result if result!= float(inf) else -1           ", "def shortestSubarray(self, A: List[int], K: int) -> int:\\n        pre = [0]\\n        for num in A:\\n            pre.append(pre[-1]+num)\\n            \\n        deque = collections.deque()\\n        result = float(inf)\\n        for i,sum_ in enumerate(pre):\\n            \\n            while(deque and deque[-1][1] >=sum_):\\n                deque.pop()\\n            \\n            while deque and sum_ - deque[0][1] >= K:\\n                result = min(i-deque[0][0], result)\\n                deque.popleft()\\n                \\n            deque.append([i,sum_])\\n        return result if result!= float(inf) else -1           "]}
{"id": "1906", "ref_py": ["def shortestPathAllKeys(self, grid: List[str]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        arr=deque([])\\n        numOfKeys=0\\n        keys={\\'a\\':0,\\'b\\':1,\\'c\\':2,\\'d\\':3,\\'e\\':4,\\'f\\':5}\\n        locks={\\'A\\':0,\\'B\\':1,\\'C\\':2,\\'D\\':3,\\'E\\':4,\\'F\\':5}\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'@\\':\\n                    arr.append((i,j,0,0))\\n                elif grid[i][j] in keys:\\n                    numOfKeys+=1", "def shortestPathAllKeys(self, grid: List[str]) -> int:\\n        EMPTY = \\'.\\'\\n        WALL = \\'", "def shortestPathAllKeys(self, grid: List[str]) -> int:\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]"]}
{"id": "1907", "ref_py": ["def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        stations.append([target, 0])    ", "def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:", "def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        stations.append([target, 0])    "]}
{"id": "1908", "ref_py": ["def gcd(self,a,b):\\n        if a < b:\\n            a,b = b,a\\n        if a % b == 0:\\n            return b\\n        else:\\n            return self.gcd(b,a%b)", "def gcd(self,a,b):\\n        if a < b:\\n            a,b = b,a\\n        if a % b == 0:\\n            return b\\n        else:\\n            return self.gcd(b,a%b)", "def gcd(self,a,b):\\n        if a < b:\\n            a,b = b,a\\n        if a % b == 0:\\n            return b\\n        else:\\n            return self.gcd(b,a%b)"]}
{"id": "1909", "ref_py": ["definitely solvable using `Knapsack` approach, using `2D` or `3D array`", "def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:", "def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:"]}
{"id": "1910", "ref_py": ["def reachableNodes(self, edges, M, N):\\n        graph = [[-1] * N for _ in range(N)]\\n        for edge in edges:\\n            graph[edge[0]][edge[1]] = edge[2]\\n            graph[edge[1]][edge[0]] = edge[2]\\n        \\n        result = 0\\n        pq = [(-M, 0)]\\n        visited = [False] * N\\n        \\n        while pq:\\n            move, start = heapq.heappop(pq)\\n            move = -move\\n            \\n            if visited[start]:\\n                continue\\n            \\n            visited[start] = True\\n            result += 1\\n            \\n            for i in range(N):\\n                if graph[start][i] > -1:\\n                    if move > graph[start][i] and not visited[i]:\\n                        heapq.heappush(pq, (-(move - graph[start][i] - 1), i))\\n                    graph[i][start] -= min(move, graph[start][i])\\n                    result += min(move, graph[start][i])\\n        \\n        return result", "def reachableNodes(self, edges, M, N):\\n        graph = [[-1] * N for _ in range(N)]\\n        for edge in edges:\\n            graph[edge[0]][edge[1]] = edge[2]\\n            graph[edge[1]][edge[0]] = edge[2]\\n        \\n        result = 0\\n        pq = [(-M, 0)]\\n        visited = [False] * N\\n        \\n        while pq:\\n            move, start = heapq.heappop(pq)\\n            move = -move\\n            \\n            if visited[start]:\\n                continue\\n            \\n            visited[start] = True\\n            result += 1\\n            \\n            for i in range(N):\\n                if graph[start][i] > -1:\\n                    if move > graph[start][i] and not visited[i]:\\n                        heapq.heappush(pq, (-(move - graph[start][i] - 1), i))\\n                    graph[i][start] -= min(move, graph[start][i])\\n                    result += min(move, graph[start][i])\\n        \\n        return result", "def reachableNodes(self, edges, M, N):\\n        graph = [[-1] * N for _ in range(N)]\\n        for edge in edges:\\n            graph[edge[0]][edge[1]] = edge[2]\\n            graph[edge[1]][edge[0]] = edge[2]\\n        \\n        result = 0\\n        pq = [(-M, 0)]\\n        visited = [False] * N\\n        \\n        while pq:\\n            move, start = heapq.heappop(pq)\\n            move = -move\\n            \\n            if visited[start]:\\n                continue\\n            \\n            visited[start] = True\\n            result += 1\\n            \\n            for i in range(N):\\n                if graph[start][i] > -1:\\n                    if move > graph[start][i] and not visited[i]:\\n                        heapq.heappush(pq, (-(move - graph[start][i] - 1), i))\\n                    graph[i][start] -= min(move, graph[start][i])\\n                    result += min(move, graph[start][i])\\n        \\n        return result"]}
{"id": "1911", "ref_py": ["def superEggDrop(self, e: int, f: int) -> int:", "def superEggDrop(self, e: int, f: int) -> int:", "def superEggDrop(self, e: int, f: int) -> int:"]}
{"id": "1912", "ref_py": ["def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        def distance(p1, p2):\\n            x1, y1 = p1 \\n            x2, y2 = p2", "defaultdict called distances to keep track of the number of points that are a certain distance away from p1.\\n5. Iterate through each point, p2, in the points list.\\n6. If p1 is the same as p2, continue to the next iteration of the loop.\\n7. Calculate the squared distance between p1 and p2.\\n8. Increment the value in distances corresponding to the squared distance by 1.\\n9. Iterate through each value in distances.\\n10. For each value dist in distances, calculate the number of boomerangs that can be formed with p1 as the center point and dist as the distance.\\n11. Add the number of boomerangs calculated in step 10 to boomerangs.\\n12. Return the final value of boomerangs.", "def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        def distance(p1, p2):\\n            x1, y1 = p1 \\n            x2, y2 = p2"]}
{"id": "1914", "ref_py": ["def longestOnes(self, nums: List[int], k: int) -> int:\\n        zeros, l = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > k:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        return r - l + 1", "def longestOnes(self, nums: List[int], k: int) -> int:\\n\\tn, ans, l = len(nums), 0, 0\\n\\tfor r in range(n):\\n\\t\\tif nums[r] == 0:                       ", "def longestOnes(self, nums: List[int], k: int) -> int:\\n        zeros, l = 0, 0\\n        for r, n in enumerate(nums):\\n            zeros += n == 0\\n            if zeros > k:\\n                zeros -= nums[l] == 0\\n                l += 1\\n        return r - l + 1"]}
{"id": "1915", "ref_py": ["def atMostNGivenDigitSetDFS(self, digits: List[str], n: int) -> int:\\n\\tdigits = list(map(int, digits))", "def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\\n        \\n        \\n        abhi = defaultdict(int)\\n        for i in digits:\\n            abhi[int(i)]=1\\n        \\n        def getlist(x):\\n            ans=[]\\n            while x:\\n                ans.append(x%10)\\n                x//=10\\n            return ans[::-1]\\n        \\n        def getans(index, tight, prefix):\\n            if index == len(numlist):\\n             \\n                return 1\\n            \\n            if dp[index][tight][prefix] !=-1 and tight !=1:\\n                return dp[index][tight][prefix]\\n            \\n            if tight:\\n                k = numlist[index]\\n            else:\\n                k = 9\\n            ret = 0\\n            \\n            for i in range(k+1):\\n                newtight = 0\\n                \\n                if i== numlist[index]:\\n                    newtight = tight\\n                    \\n                if abhi[i]==1 :\\n                    ret+= getans(index+1, newtight  ,0)\\n                else:\\n                    if i==0 and prefix:\\n                        ret+= getans(index+1, newtight, prefix)\\n                ", "def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\\n    n = [i for i in str(n)]\\n    m = len(digits)"]}
{"id": "1916", "ref_py": ["def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)", "def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)", "def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)"]}
{"id": "1917", "ref_py": ["def superpalindromesInRange(self, left: str, right: str) -> int:\\n        ans = 1 if 9 >= int(left) and 9 <= int(right) else 0\\n        \\n        def isPal(s: str) -> bool:\\n            return s == s[::-1]\\n        \\n        for dig in range(1, 10):\\n            isOdd = dig % 2 and dig != 1\\n            innerLen = (dig >> 1) - 1\\n            innerLim = max(1, 2 ** innerLen)\\n            midPos = dig >> 1\\n            midLim = 3 if isOdd else 1\\n            for edge in range (1, 3):\\n                pal = [0] * dig\\n                pal[0], pal[-1] = edge, edge\\n                if edge == 2: innerLim, midLim = 1, min(midLim, 2)\\n                for inner in range(innerLim):\\n                    if inner > 0:\\n                        innerStr = list(bin(inner)[2:].zfill(innerLen))\\n                        pal[1:1+innerLen] = innerStr\\n                        pal[-innerLen-1:-1] = reversed(innerStr)\\n                    for mid in range(midLim):\\n                        if isOdd: pal[midPos] = mid\\n                        palin = int(\"\".join([str(n) for n in pal]))\\n                        square = palin * palin\\n                        if square > int(right): return ans\\n                        if square >= int(left) and isPal(str(square)): ans += 1\\n        return ans\\n```", "def superpalindromesInRange(self, left: str, right: str) -> int:\\n        \\n        left = int(left)\\n        right= int(right)\\n        limit= 100000\\n        c=0\\n        \\n        def is_pal(num):\\n            return str(num)==str(num)[::-1]\\n        \\n        ", "def superpalindromesInRange(self, left: str, right: str) -> int:\\n        ans = 1 if 9 >= int(left) and 9 <= int(right) else 0\\n        \\n        def isPal(s: str) -> bool:\\n            return s == s[::-1]\\n        \\n        for dig in range(1, 10):\\n            isOdd = dig % 2 and dig != 1\\n            innerLen = (dig >> 1) - 1\\n            innerLim = max(1, 2 ** innerLen)\\n            midPos = dig >> 1\\n            midLim = 3 if isOdd else 1\\n            for edge in range (1, 3):\\n                pal = [0] * dig\\n                pal[0], pal[-1] = edge, edge\\n                if edge == 2: innerLim, midLim = 1, min(midLim, 2)\\n                for inner in range(innerLim):\\n                    if inner > 0:\\n                        innerStr = list(bin(inner)[2:].zfill(innerLen))\\n                        pal[1:1+innerLen] = innerStr\\n                        pal[-innerLen-1:-1] = reversed(innerStr)\\n                    for mid in range(midLim):\\n                        if isOdd: pal[midPos] = mid\\n                        palin = int(\"\".join([str(n) for n in pal]))\\n                        square = palin * palin\\n                        if square > int(right): return ans\\n                        if square >= int(left) and isPal(str(square)): ans += 1\\n        return ans\\n```"]}
{"id": "1918", "ref_py": ["def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False", "def canPlaceFlowers(self, flowerbed, n):\\n        if n == 0: return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):  ", "def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        if n == 0:\\n            return True\\n        for i in range(len(flowerbed)):\\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\\n                flowerbed[i] = 1\\n                n -= 1\\n                if n == 0:\\n                    return True\\n        return False"]}
{"id": "1919", "ref_py": ["def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\\n        @cache\\n        def num_lists(i: int, j: int) -> int:\\n            if not i and not j: return 1\\n            if not i  or not j: return 0\\n            return (num_lists(i - 1, j - 1) * (n - j + 1) + num_lists(i - 1, j) * max(j - k, 0)) % 1_000_000_007\\n        \\n        return num_lists(goal, n)", "def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\\n        @cache\\n        def num_lists(i: int, j: int) -> int:\\n            if not i and not j: return 1\\n            if not i  or not j: return 0\\n            return (num_lists(i - 1, j - 1) * (n - j + 1) + num_lists(i - 1, j) * max(j - k, 0)) % 1_000_000_007\\n        \\n        return num_lists(goal, n)", "def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\\n        @cache\\n        def num_lists(i: int, j: int) -> int:\\n            if not i and not j: return 1\\n            if not i  or not j: return 0\\n            return (num_lists(i - 1, j - 1) * (n - j + 1) + num_lists(i - 1, j) * max(j - k, 0)) % 1_000_000_007\\n        \\n        return num_lists(goal, n)"]}
{"id": "1920", "ref_py": ["def minMalwareSpread(self, graph, initial):\\n        def BFS(del_node):\\n            stack, visited = [i for i in initial if i != del_node], {i for i in initial if i != del_node}", "def __init__(self, N):\\n        self.roots = list(range(N))\\n        self.ranks = [1] * N\\n        self.size = [1] * N", "def minMalwareSpread(self, graph, initial):\\n        def BFS(del_node):\\n            stack, visited = [i for i in initial if i != del_node], {i for i in initial if i != del_node}"]}
{"id": "1921", "ref_py": ["def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        n = len(arr)", "def threeEqualParts(self, arr: List[int]) -> List[int]:\\n        ", "def threeEqualParts(self, arr):\\r\\n        ones, remain = divmod(arr.count(1), 3)\\r\\n\\r\\n        if remain != 0: return [-1, -1]  "]}
{"id": "1922", "ref_py": ["def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\\n        def tarjan(i):\\n            nonlocal idVal\\n            \\n            ids[i] = idVal\\n            initLow[i] = idVal\\n            stack.append(i)\\n            inStack[i] = True\\n            idVal += 1\\n            \\n            for j in adj[i]:\\n                \\n                if ids[j] == -1:\\n                    tarjan(j)\\n                \\n                if inStack[j]:\\n                    initLow[i] = min(initLow[i], initLow[j])\\n            \\n            ", "def minMalwareSpread(self, graph, initial):\\n        n = len(graph)", "def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\\n        def tarjan(i):\\n            nonlocal idVal\\n            \\n            ids[i] = idVal\\n            initLow[i] = idVal\\n            stack.append(i)\\n            inStack[i] = True\\n            idVal += 1\\n            \\n            for j in adj[i]:\\n                \\n                if ids[j] == -1:\\n                    tarjan(j)\\n                \\n                if inStack[j]:\\n                    initLow[i] = min(initLow[i], initLow[j])\\n            \\n            "]}
{"id": "1923", "ref_py": ["def movesToStamp(self, stamp: str, target: str) -> List[int]:\\n        slen, tlen = len(stamp), len(target)\\n        res = []\\n        \\n        s_covers = set()   ", "def movesToStamp(self, S: str, T: str) -> List[int]:\\n\\t\\t\\t\\tif S == T: return [0]\\n\\t\\t\\t\\tS, T = list(S), list(T)\\n\\t\\t\\t\\tslen, tlen = len(S), len(T) - len(S) + 1\\n\\t\\t\\t\\tans, tdiff, sdiff = [], True, True\\n\\t\\t\\t\\twhile tdiff:\\n\\t\\t\\t\\t\\ttdiff = False\\n\\t\\t\\t\\t\\tfor i in range(tlen):\\n\\t\\t\\t\\t\\t\\tsdiff = False\\n\\t\\t\\t\\t\\t\\tfor j in range(slen):\\n\\t\\t\\t\\t\\t\\t\\tif T[i+j] == \"*\": continue\\n\\t\\t\\t\\t\\t\\t\\tif T[i+j] != S[j]: break\\n\\t\\t\\t\\t\\t\\t\\tsdiff = True\\n\\t\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\t\\tif sdiff:\\n\\t\\t\\t\\t\\t\\t\\t\\ttdiff = True\\n\\t\\t\\t\\t\\t\\t\\t\\tfor j in range(i, i + slen): T[j] = \"*\"\\n\\t\\t\\t\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\t\\tfor i in range(len(T)):\\n\\t\\t\\t\\t\\tif T[i] != \"*\": return []\\n\\t\\t\\t\\treturn reversed(ans)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n", "def movesToStamp(self, S: str, T: str) -> List[int]:\\n        if S == T: return [0]\\n        S, T = list(S), list(T)\\n        slen, tlen = len(S), len(T) - len(S) + 1\\n        ans, tdiff, sdiff = [], True, True\\n        while tdiff:\\n            tdiff = False\\n            for i in range(tlen):\\n                sdiff = False\\n                for j in range(slen):\\n                    if T[i+j] == \"*\": continue\\n                    if T[i+j] != S[j]: break\\n                    sdiff = True\\n                else: \\n                    if sdiff:\\n                        tdiff = True\\n                        for j in range(i, i + slen): T[j] = \"*\"\\n                        ans.append(i)\\n        for i in range(len(T)):\\n            if T[i] != \"*\": return []\\n        return reversed(ans)\\n```"]}
{"id": "1924", "ref_py": ["def solve(self, week):\\n        result = 0\\n        for i in range(week):\\n            result += 28 + (i * 7)\\n        return result", "def totalMoney(self, n: int) -> int:\\n        total = 0\\n        \\n        for day in range(n):\\n            total += (day // 7 + 1) + (day % 7)\\n        \\n        return total\\n```\\n```javascript []\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalMoney = function(n) {\\n    let total = 0;", "def total_money(n):\\n  sum = 0\\n  current_value = 1\\n  for i in range(1, n + 1):\\n    sum += current_value"]}
{"id": "1925", "ref_py": ["define each subset with just an integer._\\n   - _Use **bit manipulation** to store the savings and its source node in a single int for each **dp** entry, rather than requiring a second matrix._\\n   - _Rebuild the circular **path** once the final **dp** result is found by backtracking previous nodes._\\n   - _Find the best place to cut the circular **path** into a linear **ans**._\\n   - _Combine the words in proper order into a single string, trimming off the overlaps, then **return** the string._", "def shortestSuperstring(self, words):\\r\\n        words.insert(0, \\'~\\')  ", "define each subset with just an integer._\\n   - _Use **bit manipulation** to store the savings and its source node in a single int for each **dp** entry, rather than requiring a second matrix._\\n   - _Rebuild the circular **path** once the final **dp** result is found by backtracking previous nodes._\\n   - _Find the best place to cut the circular **path** into a linear **ans**._\\n   - _Combine the words in proper order into a single string, trimming off the overlaps, then **return** the string._"]}
{"id": "1926", "ref_py": ["def largestComponentSize(self, A: List[int]) -> int:\\n        primes = []\\n        for x in range(2, int(max(A)**0.5)+1):\\n            for y in primes:\\n                if x % y == 0:\\n                    break\\n            else:\\n                primes.append(x)\\n    \\n        factors = collections.defaultdict(list)         ", "def __init__(self):\\n        self.data = collections.defaultdict(int)", "def largestComponentSize(self, A):\\n        primes = []\\n        for x in range(2, int(max(A)**0.5)+1):\\n            for y in primes:\\n                if x % y == 0:\\n                    break\\n            else:\\n                primes.append(x)\\n    \\n        factors = collections.defaultdict(list)         "]}
{"id": "1927", "ref_py": ["def tallestBillboard(self, rods):\\n        dp = {}; n = len(rods)\\n        def recurse(sum1, sum2, i):\\n            if i == n: return sum1 if sum1==sum2 else -1\\n            diff = abs(sum1-sum2)\\n            if(dp.get((i, diff))==None):\\n                m = max([-1, recurse(sum1+rods[i], sum2, i+1), recurse(sum1, sum2+rods[i], i+1), recurse(sum1, sum2, i+1)])\\n                dp[i, diff] = max(m - max(sum1, sum2), -1)\\n            return (dp[i, diff] + max(sum1, sum2)) if dp.get((i, diff))!=-1 else -1\\n        return max(0, recurse(0,0,0))\\n```", "def tallestBillboard(self, rods: List[int]) -> int:\\n        ans={}\\n        return self.dfs(rods,0,0,ans)", "def tallestBillboard(self, rods: List[int]) -> int:\\n        ans={}\\n        return self.dfs(rods,0,0,ans)"]}
{"id": "1928", "ref_py": ["def minDeletionSize(self, strs: List[str]) -> int:\\n        ", "def minDeletionSize(self, strs: List[str]) -> int:\\n        n = len(strs[0])\\n        \\n        def checkRest(idx1, idx2):\\n            for i in range(1, len(strs)):\\n                if not strs[i][idx1] <= strs[i][idx2]: return False\\n            return True\\n                \\n        @cache\\n        def lis(idx):\\n            longest = 1\\n            for i in range(idx + 1, n):\\n                if strs[0][idx] <= strs[0][i] and checkRest(idx, i):\\n                        longest = max(longest, 1 + lis(i))\\n            return longest", "def minDeletionSize(self, strs: List[str]) -> int:\\n        "]}
{"id": "1929", "ref_py": ["def leastOpsExpressTarget(self, x: int, target: int) -> int:\\n        @cache\\n        def solve(x: int, target: int) -> int:\\n            ", "def go(x,target):\\n    if target == 1:\\n        return 1                               ", "def leastOpsExpressTarget(self, x: int, target: int) -> int:\\n        @cache\\n        def solve(x: int, target: int) -> int:\\n            "]}
{"id": "1930", "ref_py": ["def minCameraCover(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode) -> int:\\n            if not node: return 0\\n            val = dfs(node.left) + dfs(node.right)\\n            if val == 0: return 3\\n            if val < 3: return 0\\n            self.ans += 1\\n            return 1\\n        return self.ans + 1 if dfs(root) > 2 else self.ans\\n```", "define a priority list as follows:", "define a priority list as follows:"]}
{"id": "1931", "ref_py": ["def isRationalEqual(self, s: str, t: str) -> bool:\\n        repeat = 1000\\n        \\n        res =  []\\n                \\n        for word in (s, t):\\n            stack = []\\n            for char in word:\\n                if char == \")\":\\n                    nums = \"\"\\n                    char = \"\"\\n                    \\n                    while char != \"(\" and stack:\\n                        nums += char\\n                        char = stack.pop(-1)\\n        \\n                    stack.append( nums[::-1] * repeat )\\n                else:\\n                    stack.append(char)\\n            \\n            res.append((\"\".join(stack))[:100])\\n            \\n        return float(res[0]) == float(res[1])\\n                    ", "def isRationalEqual(self, S: str, T: str) -> bool:\\n        L, A = [len(S), len(T)], [S,T]\\n        for i,p in enumerate([S,T]):\\n            if \\'(\\' in p:\\n                I = p.index(\\'(\\')\\n                A[i] = p[0:I] + 7*p[I+1:L[i]-1]\\n        return abs(float(A[0])-float(A[1])) < 1E-7\\n\\t\\t\\n", "def isRationalEqual(self, s: str, t: str) -> bool:\\n\\tdef toFrac(n):\\n\\t\\ttry:\\n\\t\\t\\treturn Fraction(n) "]}
{"id": "1932", "ref_py": ["def oddEvenJumps(self, A: List[int]) -> int:\\n        \\n\\t\\t", "def doJump(self, sortedArray, i, isGoodEvenJump, isGoodOddJump):\\n        currentNumber, currentNumberIndex = sortedArray[i]", "def doJump(self, sortedArray, i, isGoodEvenJump, isGoodOddJump):\\n        currentNumber, currentNumberIndex = sortedArray[i]"]}
{"id": "1933", "ref_py": ["def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\tpass  ", "def uniquePathsIII(self, grid: List[List[int]]) -> int:", "def __init__(self):\\n\\t\\t\\tself.ans = 0"]}
{"id": "1934", "ref_py": ["def maxDivScore(self, nums, divisors):\\n         \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]", "def maxDivScore(self, nums, divisors):\\n         \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]", "def maxDivScore(self, nums, divisors):\\n         \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]"]}
{"id": "1935", "ref_py": ["def main(self,elm):\\n\\t\\t", "def main(self,elm):\\n\\t\\t", "def main(self,elm):\\n\\t\\t"]}
{"id": "1936", "ref_py": ["def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```", "def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```", "def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```"]}
{"id": "1937", "ref_py": ["def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  ", "def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  ", "def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  "]}
{"id": "1938", "ref_py": ["def numSquarefulPerms(self, A: List[int]) -> int:\\n        N = len(A)\\n        graph = defaultdict(set)\\n        for i,a in enumerate(A):\\n            for j in range(i+1, N):\\n                b = A[j]\\n                c = b + a\\n                if sqrt(c).is_integer():\\n                    graph[a].add(b)\\n                    graph[b].add(a)\\n        C = Counter(A)", "def numSquarefulPerms(self, nums: List[int]) -> int:\\n        cnt = defaultdict(int)\\n        size = len(nums)\\n        is_square = [[False] * size for _ in range(size)]\\n        \\n        for i, x in enumerate(nums):\\n            cnt[x] += 1\\n            for j in range(i+1, size):\\n                if int(sqrt(x + nums[j])) ** 2 == x + nums[j]:\\n                    is_square[i][j] = is_square[j][i] = True\\n                    \\n        \\n        dp = [[0] * size for i in range(1 << size)]", "def numSquarefulPerms(self, A: List[int]) -> int:\\n        N = len(A)\\n        graph = defaultdict(set)\\n        for i,a in enumerate(A):\\n            for j in range(i+1, N):\\n                b = A[j]\\n                c = b + a\\n                if sqrt(c).is_integer():\\n                    graph[a].add(b)\\n                    graph[b].add(a)\\n        C = Counter(A)"]}
{"id": "1939", "ref_py": ["def buddyStrings(self, s, goal):\\n        ind = []", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        c1=Counter(s)\\n        c2=Counter(goal)\\n        if c1!=c2:\\n            return False", "def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False"]}
{"id": "1940", "ref_py": ["def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\\n        def check(i, j, dRow, dCol, dDiagS, dDiagP):\\n            if (i in dRow and dRow[i] > 0) or (j in dCol and dCol[j] > 0) or (\\n                    i + j in dDiagS and dDiagS[i + j] > 0) or (\\n                    i - j in dDiagP and dDiagP[i - j] > 0):\\n                return True\\n            return False\\n        \\n        def decrement(i, j, dRow, dCol, dDiagS, dDiagP):\\n            dRow[i] -= 1\\n            dCol[j] -= 1\\n            dDiagS[i + j] -= 1\\n            dDiagP[i - j] -= 1\\n        \\n        my_set = set()\\n        dRow, dCol, dDiagS, dDiagP = {}, {}, {}, {} \\n        for i in range(len(lamps)):\\n            if (lamps[i][0], lamps[i][1]) not in my_set:\\n                if lamps[i][0] not in dRow:\\n                    dRow[lamps[i][0]] = 1\\n                else:\\n                    dRow[lamps[i][0]] += 1\\n                if lamps[i][1] not in dCol:\\n                    dCol[lamps[i][1]] = 1\\n                else:\\n                    dCol[lamps[i][1]] += 1\\n                if sum(lamps[i]) not in dDiagS:\\n                    dDiagS[sum(lamps[i])] = 1\\n                else:\\n                    dDiagS[sum(lamps[i])] += 1\\n                if lamps[i][0] - lamps[i][1] not in dDiagP:\\n                    dDiagP[lamps[i][0] - lamps[i][1]] = 1\\n                else:\\n                    dDiagP[lamps[i][0] - lamps[i][1]] += 1\\n                my_set.add((lamps[i][0], lamps[i][1]))\\n        ans = []\\n        directions = [(-1, -1), (-1, 0), (0, -1), (0, 0), (0, 1), (1, 0), (1, 1), (1, -1), (-1, 1)]\\n        for i in range(len(queries)):\\n            ", "def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\\n        def check(i, j, dRow, dCol, dDiagS, dDiagP):\\n            if (i in dRow and dRow[i] > 0) or (j in dCol and dCol[j] > 0) or (\\n                    i + j in dDiagS and dDiagS[i + j] > 0) or (\\n                    i - j in dDiagP and dDiagP[i - j] > 0):\\n                return True\\n            return False\\n        \\n        def decrement(i, j, dRow, dCol, dDiagS, dDiagP):\\n            dRow[i] -= 1\\n            dCol[j] -= 1\\n            dDiagS[i + j] -= 1\\n            dDiagP[i - j] -= 1\\n        \\n        my_set = set()\\n        dRow, dCol, dDiagS, dDiagP = {}, {}, {}, {} \\n        for i in range(len(lamps)):\\n            if (lamps[i][0], lamps[i][1]) not in my_set:\\n                if lamps[i][0] not in dRow:\\n                    dRow[lamps[i][0]] = 1\\n                else:\\n                    dRow[lamps[i][0]] += 1\\n                if lamps[i][1] not in dCol:\\n                    dCol[lamps[i][1]] = 1\\n                else:\\n                    dCol[lamps[i][1]] += 1\\n                if sum(lamps[i]) not in dDiagS:\\n                    dDiagS[sum(lamps[i])] = 1\\n                else:\\n                    dDiagS[sum(lamps[i])] += 1\\n                if lamps[i][0] - lamps[i][1] not in dDiagP:\\n                    dDiagP[lamps[i][0] - lamps[i][1]] = 1\\n                else:\\n                    dDiagP[lamps[i][0] - lamps[i][1]] += 1\\n                my_set.add((lamps[i][0], lamps[i][1]))\\n        ans = []\\n        directions = [(-1, -1), (-1, 0), (0, -1), (0, 0), (0, 1), (1, 0), (1, 1), (1, -1), (-1, 1)]\\n        for i in range(len(queries)):\\n            ", "def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\\n        def check(i, j, dRow, dCol, dDiagS, dDiagP):\\n            if (i in dRow and dRow[i] > 0) or (j in dCol and dCol[j] > 0) or (\\n                    i + j in dDiagS and dDiagS[i + j] > 0) or (\\n                    i - j in dDiagP and dDiagP[i - j] > 0):\\n                return True\\n            return False\\n        \\n        def decrement(i, j, dRow, dCol, dDiagS, dDiagP):\\n            dRow[i] -= 1\\n            dCol[j] -= 1\\n            dDiagS[i + j] -= 1\\n            dDiagP[i - j] -= 1\\n        \\n        my_set = set()\\n        dRow, dCol, dDiagS, dDiagP = {}, {}, {}, {} \\n        for i in range(len(lamps)):\\n            if (lamps[i][0], lamps[i][1]) not in my_set:\\n                if lamps[i][0] not in dRow:\\n                    dRow[lamps[i][0]] = 1\\n                else:\\n                    dRow[lamps[i][0]] += 1\\n                if lamps[i][1] not in dCol:\\n                    dCol[lamps[i][1]] = 1\\n                else:\\n                    dCol[lamps[i][1]] += 1\\n                if sum(lamps[i]) not in dDiagS:\\n                    dDiagS[sum(lamps[i])] = 1\\n                else:\\n                    dDiagS[sum(lamps[i])] += 1\\n                if lamps[i][0] - lamps[i][1] not in dDiagP:\\n                    dDiagP[lamps[i][0] - lamps[i][1]] = 1\\n                else:\\n                    dDiagP[lamps[i][0] - lamps[i][1]] += 1\\n                my_set.add((lamps[i][0], lamps[i][1]))\\n        ans = []\\n        directions = [(-1, -1), (-1, 0), (0, -1), (0, 0), (0, 1), (1, 0), (1, 1), (1, -1), (-1, 1)]\\n        for i in range(len(queries)):\\n            "]}
{"id": "1941", "ref_py": ["def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, has_leading0s):\\n            if i == len(s): return int(not has_leading0s)\\n            sub = 0\\n            if has_leading0s:\\n                sub = dfs(i+1, mask, False, True)\\n            low = 1 if has_leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                if mask >> d & 1 == 0:\\n                    sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False)\\n            return sub\\n        \\n        return n - dfs(0, 0, True, True)\\n```", "def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        nums = [int(i) for i in str(n+1)] ", "def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        nums = [int(i) for i in str(n+1)] "]}
{"id": "1942", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "1944", "ref_py": ["def isEscapePossible(self, blocked, source, target):\\n        \\n        \\n        self.blocked = blocked\\n        self.source = source\\n        self.target = target\\n        \\n        ", "def isWall(self, x1:int, y1:int, x2:int, y2:int) -> int:\\n        return abs(x2 - x1) < 2 and abs(y2 - y1) < 2\\n    \\n    ", "def isEscapePossible(self, blocked, source, target):\\n        \\n        \\n        self.blocked = blocked\\n        self.source = source\\n        self.target = target\\n        \\n        "]}
{"id": "1945", "ref_py": ["defaultdict\\nfrom operator import itemgetter", "def longestDupSubstring(self, s: str) -> str:\\n        \\n        ans = \"\"\\n        j   = 1\\n        for i in range(len(s)):\\n            window = s[i:i+j]\\n            heystack = s[i+1:]\\n            while window in heystack:\\n                ans = window\\n                j += 1\\n                window = s[i:i+j]\\n        return ans\\n```", "defaultdict\\nfrom operator import itemgetter"]}
{"id": "1946", "ref_py": ["def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ", "defaultdict** for **res** (Thanks, [@slcheungcasado](https://leetcode.com/slcheungcasado)!)", "def subarraySum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pre_sum = 0\\n        res = defaultdict(int)\\n        res[0] = 1 "]}
{"id": "1947", "ref_py": ["def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        n=len(s1)\\n        m=len(s2)\\n           \\n        dp=[[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        ans=\\'\\'\\n        i=n\\n        j=m\\n        while i>0 and j>0:\\n            if s1[i-1]==s2[j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n                j-=1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n            else:\\n                ans+=s2[j-1]\\n                j-=1\\n        while i>0:\\n            ans+=s1[i-1]\\n            i-=1 \\n        while j>0:\\n            ans+=s2[j-1]\\n            j-=1\\n        return ans[::-1]\\n```", "def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        ", "def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        n=len(s1)\\n        m=len(s2)\\n           \\n        dp=[[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        ans=\\'\\'\\n        i=n\\n        j=m\\n        while i>0 and j>0:\\n            if s1[i-1]==s2[j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n                j-=1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n            else:\\n                ans+=s2[j-1]\\n                j-=1\\n        while i>0:\\n            ans+=s1[i-1]\\n            i-=1 \\n        while j>0:\\n            ans+=s2[j-1]\\n            j-=1\\n        return ans[::-1]\\n```"]}
{"id": "1948", "ref_py": ["def findInMountainArray(self, target, mountainArr):\\n        n = mountainArr.length()\\n        maxPosition = -1\\n        left = 1\\n        right = n - 2\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if mountainArr.get(mid) < mountainArr.get(mid + 1):\\n                left = mid + 1\\n            else:\\n                right = mid\\n        maxPosition = left\\n        left = 0\\n        right = maxPosition\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            me = mountainArr.get(mid)\\n            if me == target:\\n                return mid\\n            if me > target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        left = maxPosition\\n        right = n - 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            me = mountainArr.get(mid)\\n            if me == target:\\n                return mid\\n            if me < target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return -1", "def get(self, index: int) -> int:\\n", "defined as an array that satisfies the conditions:\\n    - The array has a length **greater** than or **equal** to `3`.\\n    - There exists an index `i` `(0 < i < arr.length - 1)` such that elements from index `0` up to `i` are in strictly **increasing** order, and elements from index `i` onwards are in strictly **decreasing** order.\\n![image.png](https://assets.leetcode.com/users/images/d94f4788-d450-4ae4-8c43-78a2d71b89cc_1697073718.6206074.png)"]}
{"id": "1949", "ref_py": ["def exp(s):\\n            res=term(s)\\n            while s and s[-1]==\\',\\':\\n                s.pop()\\n                res|=term(s)                                                           \\n            return res", "def braceExpansionII(self, expression: str) -> List[str]:\\n        def distribute(L1, L2):\\n            if L1 and L2:\\n                output = set()\\n                for elem1 in L1:\\n                    for elem2 in L2:\\n                        output.add(elem1 + elem2)\\n                return output\\n            else:\\n                return L1 or L2\\n        \\n        def build_set():\\n            nonlocal i\\n            output = set()\\n            while i < len(expression):\\n                if expression[i].isalpha():\\n                    prev = expression[i-1] if i != 0 else None\\n                    word = \"\"\\n                    while i < len(expression) and expression[i].isalpha():\\n                        word += expression[i]\\n                        i += 1\\n                    if prev == \"}\":\\n                        output = distribute(output, {word})\\n                    else:\\n                        output.add(word)\\n                elif expression[i] == \",\":\\n                    i += 1\\n                    return output | build_set()\\n                elif expression[i] == \"{\":\\n                    i += 1\\n                    output = distribute(output, build_set())\\n                else:\\n                    i += 1\\n                    return output\\n            return output\\n        \\n        i = 0\\n        return sorted(list(build_set()))\\n```", "def braceExpansionII(self, expression: str) -> List[str]:\\n        def distribute(L1, L2):\\n            if L1 and L2:\\n                output = set()\\n                for elem1 in L1:\\n                    for elem2 in L2:\\n                        output.add(elem1 + elem2)\\n                return output\\n            else:\\n                return L1 or L2\\n        \\n        def build_set():\\n            nonlocal i\\n            output = set()\\n            while i < len(expression):\\n                if expression[i].isalpha():\\n                    prev = expression[i-1] if i != 0 else None\\n                    word = \"\"\\n                    while i < len(expression) and expression[i].isalpha():\\n                        word += expression[i]\\n                        i += 1\\n                    if prev == \"}\":\\n                        output = distribute(output, {word})\\n                    else:\\n                        output.add(word)\\n                elif expression[i] == \",\":\\n                    i += 1\\n                    return output | build_set()\\n                elif expression[i] == \"{\":\\n                    i += 1\\n                    output = distribute(output, build_set())\\n                else:\\n                    i += 1\\n                    return output\\n            return output\\n        \\n        i = 0\\n        return sorted(list(build_set()))\\n```"]}
{"id": "1950", "ref_py": ["def parseBoolExpr(self, expression: str) -> bool:\\n        logics = []\\n        stack = []\\n        \\n        def cal(tmp, top, op):\\n            if op == \\'!\\':\\n                tmp = \\'t\\' if tmp == \\'f\\' else \\'f\\'\\n            elif op == \\'&\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' and top == \\'t\\') else \\'f\\'\\n            elif op == \\'|\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' or top == \\'t\\') else \\'f\\'\\n            return tmp", "def parseBoolExpr(self, expression: str) -> bool:\\n        stack1 = []\\n        stack2 = []\\n        top = \\'\\'\\n        for i in expression:\\n            if i == \\',\\':\\n                continue\\n            \\n            elif i == \\')\\':\\n                top = stack1.pop()", "def parseBoolExpr(self, expression: str) -> bool:\\n        logics = []\\n        stack = []\\n        \\n        def cal(tmp, top, op):\\n            if op == \\'!\\':\\n                tmp = \\'t\\' if tmp == \\'f\\' else \\'f\\'\\n            elif op == \\'&\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' and top == \\'t\\') else \\'f\\'\\n            elif op == \\'|\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' or top == \\'t\\') else \\'f\\'\\n            return tmp"]}
{"id": "1951", "ref_py": ["def smallestSufficientTeam(self, req_skills: list[str], people: list[list[str]]) -> list[int]:\\n        n, k = len(people), len(req_skills)", "def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\\n        m=len(req_skills)\\n        n=len(people)\\n        skill_index={v:i for i,v in enumerate(req_skills)}\\n        cand=[]\\n        for skills in people:\\n            val=0\\n            for skill in skills:\\n                val |=1<<skill_index[skill]", "def smallestSufficientTeam(self, req_skills: list[str], people: list[list[str]]) -> list[int]:\\n        n, k = len(people), len(req_skills)"]}
{"id": "1952", "ref_py": ["def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)", "def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)", "def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)"]}
{"id": "1954", "ref_py": ["def tallestBillboard(self, rods):\\n        dp = {}; n = len(rods)\\n        def recurse(sum1, sum2, i):\\n            if i == n: return sum1 if sum1==sum2 else -1\\n            diff = abs(sum1-sum2)\\n            if(dp.get((i, diff))==None):\\n                m = max([-1, recurse(sum1+rods[i], sum2, i+1), recurse(sum1, sum2+rods[i], i+1), recurse(sum1, sum2, i+1)])\\n                dp[i, diff] = max(m - max(sum1, sum2), -1)\\n            return (dp[i, diff] + max(sum1, sum2)) if dp.get((i, diff))!=-1 else -1\\n        return max(0, recurse(0,0,0))\\n```", "def tallestBillboard(self, rods: List[int]) -> int:\\n        ans={}\\n        return self.dfs(rods,0,0,ans)", "def tallestBillboard(self, rods: List[int]) -> int:\\n        ans={}\\n        return self.dfs(rods,0,0,ans)"]}
{"id": "1956", "ref_py": ["def getBitMask(self, word: str) -> int:\\n        mask = 0\\n        for c in word:\\n\\t\\t    ", "def __init__(self, ch: Optional[str] = \\'\\'):\\n        self.ch = ch        ", "def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        \\n        dic = defaultdict(list)\\n        for w in words:\\n            for c in w:\\n                dic[c].append(w)"]}
{"id": "1957", "ref_py": ["define a two-dimensional array dp where dp[i][j] represents the minimum number of operations needed to make the subarray arr1[0:i] strictly increasing, where the last element of arr1 is arr1[i], and the last element of arr2 used in the operation is arr2[j].", "def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:\\n        arr2 = sorted(arr2)\\n        bisect_cache = dict(chain(\\n            ((-1, 0),),\\n            ((x, i) for i, x in enumerate(arr2, 1)),\\n            ((x, bisect_right(arr2, x)) for x in arr1),\\n        ))", "def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:\\n        arr2 = sorted(arr2)\\n        bisect_cache = dict(chain(\\n            ((-1, 0),),\\n            ((x, i) for i, x in enumerate(arr2, 1)),\\n            ((x, bisect_right(arr2, x)) for x in arr1),\\n        ))"]}
{"id": "1958", "ref_py": ["def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\\n        def dfs(sv,parent,c):\\n            visited[sv]=1\\n            time[sv]=low[sv]=c\\n            c+=1\\n            for u in adj[sv]:\\n                if u==parent:\\n                    continue\\n                if visited[u]==0:\\n                    dfs(u,sv,c)\\n                    low[sv]=min(low[sv],low[u])\\n", "def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\\n        ", "defined by this problem, is the same as a bridge in the graph. To find out which edges are bridges, we can employ **Tarjan\\'s Bridge-Finding Algorithm** (**TBFA**)."]}
{"id": "1959", "ref_py": ["def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\\n        for i in range(n):\\n            if group[i]==-1:\\n                group[i]=i+m", "def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\\n        groupId = m\\n        for i in range(n):\\n            if group[i] == -1:\\n                group[i] = groupId\\n                groupId += 1\\n        \\n        itemGraph = defaultdict(list)\\n        itemIndegree = [0] * n\\n        groupGraph = defaultdict(list)  ", "def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\\n        for i in range(n):\\n            if group[i]==-1:\\n                group[i]=i+m"]}
{"id": "1961", "ref_py": ["def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]", "def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]", "def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]"]}
{"id": "1962", "ref_py": ["def0d4_1698463035.3767874.png)\\n![image.png](https://assets.leetcode.com/users/images/528cf5e5-ffce-486c-ad6f-468550b8eb6e_1698463087.8022835.png)", "def countVowelPermutation(self, n: int) -> int:\\n        MOD = 1000000007\\n        a = e = i = o = u = 1", "def0d4_1698463035.3767874.png)\\n![image.png](https://assets.leetcode.com/users/images/528cf5e5-ffce-486c-ad6f-468550b8eb6e_1698463087.8022835.png)"]}
{"id": "1963", "ref_py": ["def superEggDrop(self, e: int, f: int) -> int:", "def superEggDrop(self, e: int, f: int) -> int:", "def superEggDrop(self, e: int, f: int) -> int:"]}
{"id": "1964", "ref_py": ["def maxEqualFreq(self, nums):\\n\\tcounts, freq = collections.Counter(), collections.Counter()\\n\\tres = 0\\n\\tfor i, num in enumerate(nums):\\n\\t\\t", "def maxEqualFreq(self, nums):\\n\\tcounts, freq = collections.Counter(), collections.Counter()\\n\\tres = 0\\n\\tfor i, num in enumerate(nums):\\n\\t\\t", "def maxEqualFreq(self, nums):\\n\\tcounts, freq = collections.Counter(), collections.Counter()\\n\\tres = 0\\n\\tfor i, num in enumerate(nums):\\n\\t\\t"]}
{"id": "1965", "ref_py": ["def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\\n        jobs = []\\n        \\n        for i in range(len(startTime)):\\n            jobs.append( (startTime[i], endTime[i], profit[i]) )\\n            \\n        jobs.sort(key = lambda job: job[0])\\n        memo = [-1] * len(jobs)\\n        \\n        for idx,job in enumerate(jobs):\\n            startTime[idx] = job[0]\\n        \\n        def findMaxProfit(memo, pos):\\n           \\n            if pos == len(memo):\\n                return 0\\n            if memo[pos] != -1:\\n                return memo[pos]\\n            \\n            nextIndex = bisect_left(startTime, jobs[pos][1]) ", "def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\\n        jobs = sorted([(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))], key=lambda x: x[0])\\n        heap = []\\n        currentProfit = 0\\n        maxProfit = 0\\n        for start, end, profit in jobs:\\n            ", "def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\\n        \\n        dp = [[0,0]]                                            "]}
{"id": "1966", "ref_py": ["def solve(self, x1, y1, x2, y2):\\n        if y2 > x2:                             ", "def tilingRectangle(self, n: int, m: int) -> int:\\n\\t\\tboard = [[False for _ in range(m)] for _ in range(n)]\\n            self.min_n_tiles = float(\\'inf\\')\\n            \\n            def find_next_empty_cell(board):\\n\\t\\t\\t\\t", "defined as below picture\\n![image](https://assets.leetcode.com/users/images/121e3463-41d4-47f2-a1f0-da98ac23f8e3_1656969508.78159.png)"]}
{"id": "1967", "ref_py": ["def isGoodArray(self, nums):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a", "def isGoodArray(self, nums):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a", "def isGoodArray(self, nums):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a"]}
{"id": "1968", "ref_py": ["def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:", "def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        \\n        def bckt(i, counts):\\n            if i == len(words): return 0\\n            word = Counter(words[i])\\n            if word == word & counts:\\n                curr = sum([score[ord(c) - ord(\"a\")] * word[c] for c in word])\\n                return max(curr + bckt(i + 1 , counts - word), bckt(i + 1, counts))\\n            return bckt(i + 1, counts)", "def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        \\n        def bckt(i, counts):\\n            if i == len(words): return 0\\n            word = Counter(words[i])\\n            if word == word & counts:\\n                curr = sum([score[ord(c) - ord(\"a\")] * word[c] for c in word])\\n                return max(curr + bckt(i + 1 , counts - word), bckt(i + 1, counts))\\n            return bckt(i + 1, counts)"]}
{"id": "1969", "ref_py": ["def minPushBox(self, grid: List[List[str]]) -> int:", "def minPushBox(self, grid: List[List[str]]) -> int:", "def minPushBox(self, grid: List[List[str]]) -> int:"]}
{"id": "1970", "ref_py": ["def numWays(self, steps: int, arrLen: int) -> int:\\n        m = 10 ** 9 + 7\\n        arrLen = min(arrLen, steps + 1)\\n        dp = [[0] * (steps + 1) for _ in range(arrLen)]\\n        dp[0][0] = 1", "def numWays(self, steps: int, arrLen: int) -> int:\\n        m = 10 ** 9 + 7\\n        arrLen = min(arrLen, steps + 1)\\n        dp = [[0] * (steps + 1) for _ in range(arrLen)]\\n        dp[0][0] = 1", "def numWays(self, steps: int, arrLen: int) -> int:\\n        m = 10 ** 9 + 7\\n        arrLen = min(arrLen, steps + 1)\\n        dp = [[0] * (steps + 1) for _ in range(arrLen)]\\n        dp[0][0] = 1"]}
{"id": "1971", "ref_py": ["def palindromePartition(self, s: str, k: int) -> int:\\n        def cost(l, r):\\n            cnt = 0\\n            while l < r:\\n                if s[l]!=s[r]: cnt+=1\\n                l += 1\\n                r -= 1\\n            return cnt\\n        dp = [[len(s)] * len(s) for _ in range(k)]\\n        for i in range(k):\\n            for j in range(i, len(s)):\\n                if i == 0: dp[i][j] = cost(i, j)\\n                elif i == j: dp[i][j] = 0\\n                else:\\n                    for m in range(i-1, j): dp[i][j] = min(dp[i][j], dp[i-1][m] + cost(m+1, j))\\n        return dp[k-1][len(s)-1]\\n```\\n", "def palindromePartition(self, s: str, k: int) -> int:", "def palindromePartition(self, s: str, k: int) -> int:"]}
{"id": "1972", "ref_py": ["def minFlips(self, mat: List[List[int]]) -> int:", "def minFlips(self, mat: List[List[int]]) -> int:\\n        board = mat\\n        M = len(board)\\n        N = len(board[0])\\n        coeff = [[0]*(N*M) for _ in range(M*N)]\\n        y = [0]*(N*M)", "def minFlips(self, mat: List[List[int]]) -> int:\\n        board = mat\\n        M = len(board)\\n        N = len(board[0])\\n        coeff = [[0]*(N*M) for _ in range(M*N)]\\n        y = [0]*(N*M)"]}
{"id": "1973", "ref_py": ["def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        dp = [[0] * n for _ in range(n)]\\n        minHeap = []\\n        for j in range(n):\\n            dp[0][j] = grid[0][j]\\n            heappush(minHeap, (dp[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp[i][j] = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp[i][j], j))\\n        return minHeap[0][0]\\n```\\nI found dp array is unnecessary, just use min heap to store ```dp[i-1]```\\ntc is ```O(N^2logN)```, sc is ```O(N)```\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        minHeap = []\\n        for j in range(n):\\n            heappush(minHeap, (grid[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp_i_j, j))\\n        return minHeap[0][0]\\n```\\nnow, just find the first min valuse and its index, and the second min value during calculating ```dp_i_j```\\ntc is ```O(len(grid)*len(grid[0]))```, sc is ```O(1)```\\nanother mothod ```O(N^2)``` is to use prefix and suffix array to find min value, but sc is ```O(N)```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n        \\n        for j in range(n):\\n            if grid[0][j] < firstMin[0]:\\n                secondMin = firstMin[:] ", "def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        dp = [[0] * n for _ in range(n)]\\n        minHeap = []\\n        for j in range(n):\\n            dp[0][j] = grid[0][j]\\n            heappush(minHeap, (dp[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp[i][j] = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp[i][j], j))\\n        return minHeap[0][0]\\n```\\nI found dp array is unnecessary, just use min heap to store ```dp[i-1]```\\ntc is ```O(N^2logN)```, sc is ```O(N)```\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        minHeap = []\\n        for j in range(n):\\n            heappush(minHeap, (grid[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp_i_j, j))\\n        return minHeap[0][0]\\n```\\nnow, just find the first min valuse and its index, and the second min value during calculating ```dp_i_j```\\ntc is ```O(len(grid)*len(grid[0]))```, sc is ```O(1)```\\nanother mothod ```O(N^2)``` is to use prefix and suffix array to find min value, but sc is ```O(N)```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n        \\n        for j in range(n):\\n            if grid[0][j] < firstMin[0]:\\n                secondMin = firstMin[:] ", "def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        dp = [[0] * n for _ in range(n)]\\n        minHeap = []\\n        for j in range(n):\\n            dp[0][j] = grid[0][j]\\n            heappush(minHeap, (dp[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp[i][j] = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp[i][j], j))\\n        return minHeap[0][0]\\n```\\nI found dp array is unnecessary, just use min heap to store ```dp[i-1]```\\ntc is ```O(N^2logN)```, sc is ```O(N)```\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        minHeap = []\\n        for j in range(n):\\n            heappush(minHeap, (grid[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp_i_j, j))\\n        return minHeap[0][0]\\n```\\nnow, just find the first min valuse and its index, and the second min value during calculating ```dp_i_j```\\ntc is ```O(len(grid)*len(grid[0]))```, sc is ```O(1)```\\nanother mothod ```O(N^2)``` is to use prefix and suffix array to find min value, but sc is ```O(N)```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n        \\n        for j in range(n):\\n            if grid[0][j] < firstMin[0]:\\n                secondMin = firstMin[:] "]}
{"id": "1974", "ref_py": ["definition = (nr,nc,left_obstacle_removers)\".\\nThis is the classic BFS (shortest paths) with O(ROWS\\\\*COLS\\\\*k)", "def shortestPath(self, grid: List[List[int]], k: int) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        ", "definition = (nr,nc,left_obstacle_removers)\".\\nThis is the classic BFS (shortest paths) with O(ROWS\\\\*COLS\\\\*k)"]}
{"id": "1975", "ref_py": ["def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime=[True]*1001\\n        prime[0]=prime[1]=False\\n        for x in range(2,1001):\\n            if prime[x]:\\n                for i in range(x*x,1001,x):\\n                    prime[i]=False", "def isprime(self, num):\\n        \\n        for i in range(2, math.ceil(math.sqrt(num+1))):\\n            if num%i==0:\\n                return False\\n        return True\\n        \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        prims = [i for i in range(2,1001) if self.isprime(i)]\\n        \\n        ", "def isprime(self, num):\\n        \\n        for i in range(2, math.ceil(math.sqrt(num+1))):\\n            if num%i==0:\\n                return False\\n        return True\\n        \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        prims = [i for i in range(2,1001) if self.isprime(i)]\\n        \\n        "]}
{"id": "1976", "ref_py": ["def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(row: int, col: int) -> Tuple[int]:\\n            numRows, numCols = len(board), len(board[0])\\n            if row >= numRows or col >= numCols or board[row][col] == \\'X\\':\\n                return(-inf, 0)\\n            score = ord(board[row][col]) - ord(\\'0\\')\\n            if board[row][col] == \\'E\\':\\n                score = 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return (0, 1)\\n            option1 = dp(row + 1, col)\\n            option2 = dp(row, col + 1)\\n            option3 = dp(row + 1, col + 1)\\n            count, ans = 0, score + max(option1[0], option2[0], option3[0])\\n            if score + option1[0] == ans: \\n                count = (count + option1[1]) % MOD\\n            if score + option2[0] == ans: \\n                count = (count + option2[1]) % MOD\\n            if score + option3[0] == ans:\\n                count = (count + option3[1]) % MOD\\n            return (ans, count % MOD)", "def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(row: int, col: int) -> Tuple[int]:\\n            numRows, numCols = len(board), len(board[0])\\n            if row >= numRows or col >= numCols or board[row][col] == \\'X\\':\\n                return(-inf, 0)\\n            score = ord(board[row][col]) - ord(\\'0\\')\\n            if board[row][col] == \\'E\\':\\n                score = 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return (0, 1)\\n            option1 = dp(row + 1, col)\\n            option2 = dp(row, col + 1)\\n            option3 = dp(row + 1, col + 1)\\n            count, ans = 0, score + max(option1[0], option2[0], option3[0])\\n            if score + option1[0] == ans: \\n                count = (count + option1[1]) % MOD\\n            if score + option2[0] == ans: \\n                count = (count + option2[1]) % MOD\\n            if score + option3[0] == ans:\\n                count = (count + option3[1]) % MOD\\n            return (ans, count % MOD)", "def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(row: int, col: int) -> Tuple[int]:\\n            numRows, numCols = len(board), len(board[0])\\n            if row >= numRows or col >= numCols or board[row][col] == \\'X\\':\\n                return(-inf, 0)\\n            score = ord(board[row][col]) - ord(\\'0\\')\\n            if board[row][col] == \\'E\\':\\n                score = 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return (0, 1)\\n            option1 = dp(row + 1, col)\\n            option2 = dp(row, col + 1)\\n            option3 = dp(row + 1, col + 1)\\n            count, ans = 0, score + max(option1[0], option2[0], option3[0])\\n            if score + option1[0] == ans: \\n                count = (count + option1[1]) % MOD\\n            if score + option2[0] == ans: \\n                count = (count + option2[1]) % MOD\\n            if score + option3[0] == ans:\\n                count = (count + option3[1]) % MOD\\n            return (ans, count % MOD)"]}
{"id": "1977", "ref_py": ["def isSolvable(self, words: List[str], result: str) -> bool:\\n        ", "def isSolvable(self, words, result):\\n        ", "def isSolvable(self, words, result):\\n        "]}
{"id": "1978", "ref_py": ["def minInsertions(self, s: str) -> int:", "def minInsertions(self, s: str) -> int:\\n        n=len(s)\\n        dp=[[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        def solve(i,j):\\n            if i>j : return 0", "def minInsertions(self, s: str) -> int:\\n        n=len(s)\\n        dp=[[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        def solve(i,j):\\n            if i>j : return 0"]}
{"id": "1979", "ref_py": ["def distinctEchoSubstrings(self, text: str) -> int:\\n        text_values = [ord(char) - 97 for char in text]\\n        hash_map = {}\\n        powers_of_26 = [1]\\n        ", "def distinctEchoSubstrings(self, text):", "def distinctEchoSubstrings(self, text: str) -> int:\\n        count=0\\n        dic=dict()\\n        for i in range(len(text)):\\n            a=i\\n            b=a+1\\n            for j in range(len(text[i:])):\\n                if text[a:b]==text[b:len(text[a:b])+b]:\\n                    if not text[a:b] in dic:\\n                        count+=1\\n                    dic[text[a:b]]=0\\n                b+=1\\n        \\n        return count "]}
{"id": "1980", "ref_py": ["def minimumDistance(self, A):\\n        \\n        @lru_cache(maxsize=None)\\n        def get_distance(current_pos, next_pos):\\n            if current_pos == -1: return 0\\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\\n        \\n        @lru_cache(maxsize=None)\\n        def to_num(c):\\n            return ord(c) - ord(\\'A\\')", "def minimumDistance(self, A):\\n        \\n        @lru_cache(maxsize=None)\\n        def get_distance(current_pos, next_pos):\\n            if current_pos == -1: return 0\\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\\n        \\n        @lru_cache(maxsize=None)\\n        def to_num(c):\\n            return ord(c) - ord(\\'A\\')", "def minimumDistance(self, A):\\n        \\n        @lru_cache(maxsize=None)\\n        def get_distance(current_pos, next_pos):\\n            if current_pos == -1: return 0\\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\\n        \\n        @lru_cache(maxsize=None)\\n        def to_num(c):\\n            return ord(c) - ord(\\'A\\')"]}
{"id": "1981", "ref_py": ["def minTaps(self, n: int, ranges: List[int]) -> int:\\n        arr = [0] * (n + 1)\\n        for idx, cur_radius in enumerate(ranges):\\n            if cur_radius == 0:\\n                continue\\n            \\n            left_border_idx = max(0, idx - cur_radius)\\n            arr[left_border_idx] = max(arr[left_border_idx], idx + cur_radius)", "def minTaps(self, n: int, ranges: List[int]) -> int:\\n        memo = {}", "def minTaps(self, n: int, ranges: List[int]) -> int:\\n        memo = {}"]}
{"id": "1982", "ref_py": ["def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        test_list = sorted(nums)\\n        answer = []\\n        for i in nums:\\n            answer.append(test_list.index(i))\\n        return answer\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>ordered_version = nums;\\n        vector<int>answer;\\n        sort(ordered_version.begin(), ordered_version.end());\\n        \\n        for (auto it = nums.begin(); it != nums.end(); it++){\\n            for (int i = 0; i < ordered_version.size(); i++){\\n                if ( *it == ordered_version.at(i)){\\n                    answer.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```", "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```"]}
{"id": "1983", "ref_py": ["def minDifficulty(self, job_diff: list[int], d: int) -> int:\\n        \\n        ", "def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        jobCount = len(jobDifficulty)    \\n        if jobCount < d:\\n            return -1", "def dfs(jobs, d):\\n\\tif d == 1:\\n\\t\\treturn max(jobs)\\n\\tminDiff = float(\"inf\")\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tcurr = max(jobs[:i]) + dfs(jobs[i:], d - 1)\\n\\t\\tminDiff = min(minDiff, curr)\\n\\treturn minDiff\\nreturn dfs(jobDifficulty, d)\\n```\\nThis is a standard tree traversal, where at each node, we acquire some cost `m(...)`, and then continue down the tree until we hit the base case `(if d == 1: return max(jobs))`.  Therefore, we are looking for the minimum cost root -> leaf path of length `d`.  This DFS approach solves the problem, however for larger inputs it takes far too long and times out.  Why is that?  Notice in the DFS tree, we have the two recursive calls\\n```\\nm(a) + m(b) + dfs(cd)\\nm(a, b) + dfs(cd)\\n```\\nWe encounter `dfs(cd)` twice.  The solution to both of these recursive calls will always return the same solution, and thus we are wasting time recalculating it.  This issue becomes exponentially worse as the the inputs become larger and the DFS tree grows taller.  This is where the DP solution comes in.\\nIn the DFS approach, we are calculating the solution from the top down, meaning we need to recurse all the way down the tree to have any understanding of how much a path costs.  Instead, let\\'s build the solution from the ground up, saving the solution to a given subproblem at each step.  Our recursion relation will be the same, except now we are going to traverse backwards through `jobs`.\\n![image](https://assets.leetcode.com/users/images/0fcd120b-6e1a-41a5-a73f-088686075ab2_1604593819.8360617.png)\\nFor the right branch, we would have already calculated the solution to `dfs(a, b)`, so all we need to do is reference it and add `m(c)`.  In DP terms, the subproblem we are solving is `Let A[i][d] = the minimum difficulty schedule including jobs {1...i } partitioned into d days`.  Thus, we have\\n```\\ndef dp(jobs, d):\\n\\tA = [[float(\"inf\")] * d for i in range(len(jobs))]\\n\\tA[0][0] = jobs[0]\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tA[i][0] = max(A[i - 1][0], jobs[i])"]}
{"id": "1984", "ref_py": ["def maxJumps(self, nums: List[int], d: int) -> int:\\n        N = len(nums)\\n        seen = set() ", "def maxJumps(self, A, d):\\n        n = len(A)\\n        dp = [1] * n\\n        for i in sorted(range(n), key = lambda x: -A[x]):\\n            for x in range(i - 1, max(0, i - d) - 1, -1):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n            for x in range(i + 1, min(n, i + d + 1)):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n        return max(dp)\\n```", "def maxJumps(self, A, d):\\n        n = len(A)\\n        dp = [1] * n\\n        for i in sorted(range(n), key = lambda x: -A[x]):\\n            for x in range(i - 1, max(0, i - d) - 1, -1):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n            for x in range(i + 1, min(n, i + d + 1)):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n        return max(dp)\\n```"]}
{"id": "1985", "ref_py": ["def minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1: return 0\\n        dict = collections.defaultdict(list)\\n        for i , n in enumerate(arr): dict[n].append(i)", "def minJumps(self, arr):\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()  \\n        vstd_val = set()  \\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       \\n        queue.append(0)  \\n        while queue:\\n            for _ in range(len(queue)): \\n                ndx = queue.popleft()   \\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      ", "def minJumps(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    "]}
{"id": "1986", "ref_py": ["def maxStudents(self, seats: List[List[str]]) -> int:\\n        numRows, numCols = len(seats), len(seats[0])", "def maxStudents(self, seats):\\n        m, n = len(seats), len(seats[0])\\n        \\n        def combination_row(i, end=0, prev=\\'\\', count=0, front=None):\\n            if end >= n:\\n                yield prev, count; return\\n            elif seats[i][end] == \\'.\\' and \\\\\\n                    (not prev or prev[-1] == \\'", "def maxStudents(self, seats: List[List[str]]) -> int:\\n        numRows, numCols = len(seats), len(seats[0])"]}
{"id": "1987", "ref_py": ["defaults to a **min-heap**, so we can simulate a **max-heap** by changing the sign on each element when it is inserted and removed from the heap.", "def isPossible(self, target: List[int]) -> bool:", "def isPossible(self, target: List[int]) -> bool:\\n        maxHeap = []\\n        for num in target:\\n            heappush(maxHeap,-num)\\n        totalSum = sum(target)\\n        while maxHeap:\\n            top = -maxHeap[0]\\n            remSum = totalSum-top\\n            heappop(maxHeap)\\n            totalSum -= top\\n            if remSum == 1 or top == 1:\\n                return True\\n            if remSum > top or remSum == 0 or top % remSum == 0:\\n                return False\\n            heappush(maxHeap, -(top % remSum))\\n            totalSum += top % remSum\\n        return False\\n```"]}
{"id": "1988", "ref_py": ["def countOrders(self, n: int) -> int:\\n        \\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = (i * dp[i-1] * (2*i - 1)) % (10 ** 9 + 7)\\n            \\n        return dp[n]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countOrders(int n) {\\n        vector<long long> dp(n + 1);\\n        dp[0] = 1;", "def countOrders(self, n: int) -> int:\\n        \\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = (i * dp[i-1] * (2*i - 1)) % (10 ** 9 + 7)\\n            \\n        return dp[n]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countOrders(int n) {\\n        vector<long long> dp(n + 1);\\n        dp[0] = 1;", "def countOrders(self, n: int) -> int:\\n        \\n        dp = [0] * (n+1)\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = (i * dp[i-1] * (2*i - 1)) % (10 ** 9 + 7)\\n            \\n        return dp[n]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countOrders(int n) {\\n        vector<long long> dp(n + 1);\\n        dp[0] = 1;"]}
{"id": "1989", "ref_py": ["def del1(self,ans):\\n        i=len(ans)-1\\n        ones={\"1\",\"4\",\"7\"}\\n        while i>-1 and ans[i] not in ones:i-=1\\n        if i==-1:return self.del2(self.del2(ans))\\n        return ans[:i]+ans[i+1:]", "def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        count = [0] * 10\\n        sum_, leng = 0, len(digits)\\n \\n        for n in digits:\\n            count[n] += 1\\n            sum_ += n\\n    \\n        remainder = sum_ % 3\\n        if remainder == 0: ", "def largestMultipleOfThree(self, digits: List[int]) -> str:\\n        count = [0] * 10\\n        sum_, leng = 0, len(digits)\\n \\n        for n in digits:\\n            count[n] += 1\\n            sum_ += n\\n    \\n        remainder = sum_ % 3\\n        if remainder == 0: "]}
{"id": "1990", "ref_py": ["def minCost(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dist = [[1e9 for _ in range(n)] for _ in range(m)]  ", "default algorithm of choice to solve the problem would be **Dijkstra\\'s** with a time complexity of ```O(E + V log V)```.", "def minCost(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dist = [[1e9 for _ in range(n)] for _ in range(m)]  "]}
{"id": "1991", "ref_py": ["def maxSumBST(self, root: Optional[TreeNode]) -> int:", "def __init__(self, minNode, maxNode, Sum):\\n        self.maxNode = maxNode\\n        self.minNode = minNode\\n        self.Sum = Sum", "def __init__(self, minNode, maxNode, Sum):\\n        self.maxNode = maxNode\\n        self.minNode = minNode\\n        self.Sum = Sum"]}
{"id": "1992", "ref_py": ["def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:", "def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if n == 1: return 1\\n        g = self.buildGraph(edges)\\n        def dfs(cur, prev, second):\\n            if second == t or (cur != 1 and len(g[cur]) == 1):\\n                return cur == target\\n            p = 1 / (len(g[cur]) - (1 if cur != 1 else 0))\\n            for ch in g[cur]:\\n                if ch != prev:\\n                    tmp = dfs(ch, cur, second+1)\\n                    if tmp != 0: return tmp * p\\n            return 0.\\n        return dfs(1, 0, 0)", "def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if n == 1: return 1\\n        g = self.buildGraph(edges)\\n        def dfs(cur, prev, second):\\n            if second == t or (cur != 1 and len(g[cur]) == 1):\\n                return cur == target\\n            p = 1 / (len(g[cur]) - (1 if cur != 1 else 0))\\n            for ch in g[cur]:\\n                if ch != prev:\\n                    tmp = dfs(ch, cur, second+1)\\n                    if tmp != 0: return tmp * p\\n            return 0.\\n        return dfs(1, 0, 0)"]}
{"id": "1993", "ref_py": ["def minimumSwap(self, s1: str, s2: str) -> int:\\n        x_y, y_x = 0, 0\\n        for c1, c2 in zip(s1, s2):\\n            if c1 != c2:\\n                if c1 == \\'x\\':\\n                    x_y += 1\\n                else:\\n                    y_x += 1\\n                    \\n        if (x_y + y_x) % 2 == 1:\\n            return -1\\n        ", "def minimumSwap(self, s1: str, s2: str) -> int:\\n\\txy = yx = 0\\n\\tfor i in range(len(s1)):\\n\\t\\tif(s1[i] == \"x\" and s2[i] == \"y\"):\\n\\t\\t\\txy += 1\\n\\t\\tif(s2[i] == \"x\" and s1[i] == \"y\"):\\n\\t\\t\\tyx += 1\\n\\tif(xy%2 ^ yx%2):\\n\\t\\treturn -1\\n\\tans = xy//2 + yx//2 + (xy%2) * 2\\n", "def minimumSwap(self, s1: str, s2: str) -> int:\\n\\txy = yx = 0\\n\\tfor i in range(len(s1)):\\n\\t\\tif(s1[i] == \"x\" and s2[i] == \"y\"):\\n\\t\\t\\txy += 1\\n\\t\\tif(s2[i] == \"x\" and s1[i] == \"y\"):\\n\\t\\t\\tyx += 1\\n\\tif(xy%2 ^ yx%2):\\n\\t\\treturn -1\\n\\tans = xy//2 + yx//2 + (xy%2) * 2\\n"]}
{"id": "1994", "ref_py": ["def maxSizeSlices(self, slices: List[int]) -> int:\\n        n = len(slices) // 3\\n        def linear(arr):\\n            eat = [[0] + [-math.inf]*n] * 2\\n            for x in arr:\\n                eat.append([i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)])\\n            return max(l[n] for l in eat)\\n        return max(linear(slices[1:]), linear(slices[:-1]))\\n```", "def maxSizeSlices(self, slices: List[int]) -> int:\\n        numSlices = len(slices)", "def maxSizeSlices(self, slices: List[int]) -> int:\\n        numSlices = len(slices)"]}
{"id": "1995", "ref_py": ["def longestPrefix(self, s: str) -> str:\\n        res = 0\\n        z = [0]*len(s)\\n        l = r = 0\\n        for k in range(1,len(s)):\\n            if k>r:\\n                l=r=k\\n                while r<len(s) and s[r]==s[r-l]:\\n                    r+=1\\n                z[k] = r-l\\n                r-=1\\n            else:\\n                k1 = k-l\\n                if z[k1]<r-k+1:\\n                    z[k] = z[k1]\\n                else:\\n                    l = k\\n                    while r<len(s) and s[r]==s[r-l]:\\n                        r+=1\\n                    z[k] = r-l\\n                    r-=1\\n            if z[k] == len(s)-k:\\n                return s[:z[k]]\\n        return \\'\\'\"\\n", "def lps(self, s):\\n    ", "def longestPrefix(self, s: str) -> str:\\n        res = 0\\n        z = [0]*len(s)\\n        l = r = 0\\n        for k in range(1,len(s)):\\n            if k>r:\\n                l=r=k\\n                while r<len(s) and s[r]==s[r-l]:\\n                    r+=1\\n                z[k] = r-l\\n                r-=1\\n            else:\\n                k1 = k-l\\n                if z[k1]<r-k+1:\\n                    z[k] = z[k1]\\n                else:\\n                    l = k\\n                    while r<len(s) and s[r]==s[r-l]:\\n                        r+=1\\n                    z[k] = r-l\\n                    r-=1\\n            if z[k] == len(s)-k:\\n                return s[:z[k]]\\n        return \\'\\'\"\\n"]}
{"id": "1996", "ref_py": ["def srange(a, b):\\n    yield from (chr(i) for i in range(ord(a), ord(b)+1))\\n        \\ndef failure(pat): \\n    res = [0]\\n    i, target = 1, 0\\n    while i < len(pat): \\n        if pat[i] == pat[target]: \\n            target += 1\\n            res += target,\\n            i += 1\\n        elif target: \\n            target = res[target-1] \\n        else: \\n            res += 0,\\n            i += 1\\n    return res                        ", "def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\\n        chars, lenEvil = string.ascii_lowercase, len(evil)\\n        lps, left = [0] * lenEvil, 0\\n        for right in range(1, lenEvil):\\n            while left and evil[left] != evil[right]:\\n                left = lps[left - 1]\\n            if evil[left] == evil[right]:\\n                left += 1\\n            lps[right] = left\\n        \\n        @cache\\n        def dp(charIdx: int, largerThanS1: bool, smallerThanS2: bool, evilIdx: int) -> int:\\n            if charIdx == n:\\n                return 1\\n            ways = 0\\n            for char in chars:\\n                if not largerThanS1 and char < s1[charIdx]: continue\\n                if not smallerThanS2 and char > s2[charIdx]: continue\\n                if evilIdx == lenEvil - 1 and char == evil[evilIdx]: continue\\n                if char == evil[evilIdx]:\\n                    newEvilIdx = evilIdx + 1\\n                else:\\n                    newEvilIdx = evilIdx\\n                    while newEvilIdx and evil[newEvilIdx] != char:\\n                        newEvilIdx = lps[newEvilIdx - 1]\\n                    if evil[newEvilIdx] == char:\\n                        newEvilIdx += 1\\n                ways += dp(charIdx + 1, largerThanS1 | (char > s1[charIdx]), smallerThanS2 | (char < s2[charIdx]), newEvilIdx)\\n            return ways % 1000000007", "def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\\n    chars = string.ascii_lowercase\\n    m = len(evil)\\n    @lru_cache(None)\\n    def dp(c_i, prev_larger, prev_smaller, c_evil):\\n        if c_i == n:\\n            return 1\\n        \\n        e_i = len(c_evil)\\n        ways = 0\\n        for ch in chars:\\n            if not prev_larger and ch < s1[c_i]: continue\\n            if not prev_smaller and ch > s2[c_i]: continue\\n            if e_i == m-1 and ch == evil[e_i]: continue"]}
{"id": "1997", "ref_py": ["defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level. Therefore, the chef would want to cook the most satisfying dishes first and minimize the time taken to cook them. Additionally, since the chef can discard some dishes to maximize the total like-time coefficient, we can discard dishes with negative satisfaction levels to avoid decreasing the overall satisfaction.", "defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level. Therefore, the chef would want to cook the most satisfying dishes first and minimize the time taken to cook them. Additionally, since the chef can discard some dishes to maximize the total like-time coefficient, we can discard dishes with negative satisfaction levels to avoid decreasing the overall satisfaction.", "defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level. Therefore, the chef would want to cook the most satisfying dishes first and minimize the time taken to cook them. Additionally, since the chef can discard some dishes to maximize the total like-time coefficient, we can discard dishes with negative satisfaction levels to avoid decreasing the overall satisfaction."]}
{"id": "1998", "ref_py": ["def racecar(self, target: int) -> int:\\n        q = deque([(0, 1, 0)])\\n        v = set()\\n        \\n        while q:\\n            p, s, t = q.popleft()\\n            if p == target:\\n                return t", "def racecar(self, target: int) -> int:\\n        q = deque([(0, 1, 0)])\\n        v = set()\\n        \\n        while q:\\n            p, s, t = q.popleft()\\n            if p == target:\\n                return t", "def racecar(self, target: int) -> int:\\n        q = deque([(0, 1, 0)])\\n        v = set()\\n        \\n        while q:\\n            p, s, t = q.popleft()\\n            if p == target:\\n                return t"]}
{"id": "1999", "ref_py": ["def numOfWays(self, n: int) -> int:\\n        @cache\\n        def dfs(i, color):\\n            if i == 0: return 1\\n            sub = 0\\n            for j in G[color]:\\n                sub += dfs(i-1, j)\\n            return sub % MOD\\n        \\n        return sum(dfs(n-1, i) for i in range(len(STATUS))) % MOD\\n```\\n", "def numOfWays(self, n: int) -> int:\\n        @cache\\n        def dfs(i, color):\\n            if i == 0: return 1\\n            sub = 0\\n            for j in G[color]:\\n                sub += dfs(i-1, j)\\n            return sub % MOD\\n        \\n        return sum(dfs(n-1, i) for i in range(len(STATUS))) % MOD\\n```\\n", "def numOfWays(self, n: int) -> int:\\n        @cache\\n        def dfs(i, color):\\n            if i == 0: return 1\\n            sub = 0\\n            for j in G[color]:\\n                sub += dfs(i-1, j)\\n            return sub % MOD\\n        \\n        return sum(dfs(n-1, i) for i in range(len(STATUS))) % MOD\\n```\\n"]}
{"id": "2000", "ref_py": ["def numberOfArrays(self, s: str, k: int) -> int:\\n        \\n        @cache\\n        def backtrack(index):\\n            if index == len(s):\\n                ", "def numberOfArrays(self, s: str, k: int) -> int:\\n        if s.startswith(\\'0\\'):\\n            return 0\\n        mod_num = 10**9 + 7\\n        n = len(s)\\n        k_digits = len(str(k))\\n        dp = [int(s[i] != \\'0\\') for i in range(n)]\\n        dp.append(1)", "def numberOfArrays(self, s: str, k: int) -> int:\\n        if s.startswith(\\'0\\'):\\n            return 0\\n        mod_num = 10**9 + 7\\n        n = len(s)\\n        k_digits = len(str(k))\\n        dp = [int(s[i] != \\'0\\') for i in range(n)]\\n        dp.append(1)"]}
{"id": "2001", "ref_py": ["def solve(self, idx, lenLis, lar):\\n        if idx == self.n:\\n            if lenLis == self.k:\\n                return 1\\n            return 0", "defined as the number of elements in the array that are greater than all the elements to their left.\\n- We use dynamic programming to solve this problem, creating a 3D array `dp` to store intermediate results.\\n- `dp[i][cost][max_val]` represents the number of ways to build an array of length i+1 with a maximum value of `max_val+1` and a search cost of cost+1.\\n- We initialize the base case where `i = 0`, and `cost = 0`, setting `dp[0][0][max_val]` to 1 for all possible `max_val`.\\n- We iterate through the remaining values of `i`, `cost`, and `max_val`, calculating the number of ways to build the array based on the previous values in `dp`.\\n- To calculate `dp[i][cost][max_val]`, we consider two cases:\\n1. Adding `max_val+1` as the maximum element to the array.\\n1. Not adding max_val+1 as the maximum element to the array.\\n- We update `dp[i][cost][max_val]` accordingly and take care of the modulo operation to prevent overflow.\\n- Finally, we sum up the values of `dp[n-1][k-1][max_val]` for all possible `max_val` to get the total number of arrays with the desired properties.\\n- The result is returned as `(int) ans` after taking the modulo `10^9 + 7`.", "defined as the number of elements in the array that are greater than all the elements to their left.\\n- We use dynamic programming to solve this problem, creating a 3D array `dp` to store intermediate results.\\n- `dp[i][cost][max_val]` represents the number of ways to build an array of length i+1 with a maximum value of `max_val+1` and a search cost of cost+1.\\n- We initialize the base case where `i = 0`, and `cost = 0`, setting `dp[0][0][max_val]` to 1 for all possible `max_val`.\\n- We iterate through the remaining values of `i`, `cost`, and `max_val`, calculating the number of ways to build the array based on the previous values in `dp`.\\n- To calculate `dp[i][cost][max_val]`, we consider two cases:\\n1. Adding `max_val+1` as the maximum element to the array.\\n1. Not adding max_val+1 as the maximum element to the array.\\n- We update `dp[i][cost][max_val]` accordingly and take care of the modulo operation to prevent overflow.\\n- Finally, we sum up the values of `dp[n-1][k-1][max_val]` for all possible `max_val` to get the total number of arrays with the desired properties.\\n- The result is returned as `(int) ans` after taking the modulo `10^9 + 7`."]}
{"id": "2002", "ref_py": ["def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```", "def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```", "def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```"]}
{"id": "2003", "ref_py": ["def numberWays(self, hats: List[List[int]]) -> int:\\n        ", "def numberWays(self, hats: List[List[int]]) -> int:\\n        ", "def numberWays(self, hats: List[List[int]]) -> int:\\n        "]}
{"id": "2004", "ref_py": ["def kthSmallest(self, mat: List[List[int]], k: int) -> int:", "def kthSmallest(self, m, k):\\n        for r in range(1, len(m)): m[0] = sorted([a+b for a in m[0] for b in m[r][:]])[:k]\\n        return m[0][k-1]", "def kthSmallest(self, mat: List[List[int]], k: int) -> int:"]}
{"id": "2005", "ref_py": ["define a constant for modulo arithmetic\\n        int rows = pizza.size(); // get the number of rows in the pizza\\n        int cols = pizza[0].size(); // get the number of columns in the pizza\\n        int dp[55][55][11] = {}; // initialize a 3D array to store the number of ways to cut the pizza\\n        int cnt[55][55] = {}; // initialize a 2D array to store the number of \\'A\\' toppings in each sub-rectangle", "def ways(self, pizza: List[str], k: int) -> int:", "def ways(self, pizza: List[str], k: int) -> int:"]}
{"id": "2006", "ref_py": ["def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [[-inf] * (target + 1) for _ in range(10)]\\n        for i in range(1, 10):\\n            dp[i][0] = 0\\n            for size in range(1, target+1):\\n                if size - cost[i-1] >= 0:\\n                    dp[i][size] = max(dp[i][size-cost[i-1]] + 1, dp[i-1][size])\\n                else: dp[i][size] = dp[i-1][size]\\n        if dp[9][target] < 0: return \"0\"\\n        ans = []\\n        digit = 9\\n        while digit > 0:\\n            c = cost[digit-1]\\n            if target >= c and dp[digit][target] == dp[digit][target-c] + 1:\\n                ans.append(str(digit))\\n                target -= c\\n            else: digit -= 1\\n        return \\'\\'.join(ans)\\n```\\n", "def bigger(self, a, b):\\n        if len(a) != len(b): return len(a) > len(b)\\n        return a > b\\n    def largestNumber(self, cost, target):\\n        dp = [None] * (target + 1)\\n        dp[0] = \\'\\'\\n        for t in range(1, target + 1):\\n            for d in range(1, 10):\\n                c = cost[d-1]\\n                if t-c >= 0:\\n                    if dp[t-c] is not None:\\n                        candidate = dp[t-c] + str(d)\\n                        if dp[t] is None or self.bigger(candidate, dp[t]):\\n                            dp[t] = candidate", "def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [[-inf] * (target + 1) for _ in range(10)]\\n        for i in range(1, 10):\\n            dp[i][0] = 0\\n            for size in range(1, target+1):\\n                if size - cost[i-1] >= 0:\\n                    dp[i][size] = max(dp[i][size-cost[i-1]] + 1, dp[i-1][size])\\n                else: dp[i][size] = dp[i-1][size]\\n        if dp[9][target] < 0: return \"0\"\\n        ans = []\\n        digit = 9\\n        while digit > 0:\\n            c = cost[digit-1]\\n            if target >= c and dp[digit][target] == dp[digit][target-c] + 1:\\n                ans.append(str(digit))\\n                target -= c\\n            else: digit -= 1\\n        return \\'\\'.join(ans)\\n```\\n"]}
{"id": "2007", "ref_py": ["def numPoints(self, points: List[List[int]], r: int) -> int:\\n        \\n        def getPointsInside(i, r, n):\\n            ", "def numPoints(self, points: List[List[int]], r: int) -> int:\\n        ans = 0\\n        for h in range(r+1):\\n            for k in range(r+1):\\n                c = 0\\n                for x,y in points:\\n                    if (x-h)**2 + (y-k)**2 <= r**2:\\n                        c+=1\\n                ans = max(ans,c)\\n        return ans\\n```", "def numPoints(self, points: List[List[int]], r: int) -> int:\\n        ans = 0\\n        for h in range(r+1):\\n            for k in range(r+1):\\n                c = 0\\n                for x,y in points:\\n                    if (x-h)**2 + (y-k)**2 <= r**2:\\n                        c+=1\\n                ans = max(ans,c)\\n        return ans\\n```"]}
{"id": "2008", "ref_py": ["def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        m = len(nums2)\\n        dp = [[-10] * (m + 1) for _ in range(n + 1)]", "def __init__(self):\\n        self.dp = [[-1] * 505 for _ in range(505)]  ", "def __init__(self):\\n        self.cache = {}"]}
{"id": "2009", "ref_py": ["define the `dp` first\\n\\t* `dp[k][i][j]` donotes if the two robots start from `grid[k][i]` and `grid[k][j]` the maximum total cherries they can pickup at last. Note they can only move downstairs.\\n\\t\\t* After we fulfill `dp`, the final answer is `dp[0][0][COL_NUM - 1]`\\n* For the last row of grid, we have\\n\\t* `dp[-1][i][j] = grid[-1][i] if i == j else grid[-1][i] + grid[-1][j]`\\n\\t* Note if 2 robots stay at the same place, they can only pickup once.\\n* For other rows, we need to traverse all `3 * 3` direction combinations they may choose in next layer and find the maximum, because for each robot there are 3 directions that they can move.", "def f(i1,j1,i2,j2):  ===> def f(i,j1,j2):", "define the `dp` first\\n\\t* `dp[k][i][j]` donotes if the two robots start from `grid[k][i]` and `grid[k][j]` the maximum total cherries they can pickup at last. Note they can only move downstairs.\\n\\t\\t* After we fulfill `dp`, the final answer is `dp[0][0][COL_NUM - 1]`\\n* For the last row of grid, we have\\n\\t* `dp[-1][i][j] = grid[-1][i] if i == j else grid[-1][i] + grid[-1][j]`\\n\\t* Note if 2 robots stay at the same place, they can only pickup once.\\n* For other rows, we need to traverse all `3 * 3` direction combinations they may choose in next layer and find the maximum, because for each robot there are 3 directions that they can move."]}
{"id": "2010", "ref_py": ["def getProbability(self, balls: List[int]) -> float:\\n\\t\\t\\tdef solve(idx,num,k1,k2,p):\\n\\t\\t\\t\\t", "def getProbability(self, balls: List[int]) -> float:\\n    M = len(balls)\\n    N = sum(balls)\\n    F = [math.factorial(n) for n in range(N // 2 + 1)]", "def getProbability(self, balls: List[int]) -> float:\\n        allComb = comb(sum(balls),sum(balls)//2)\\n        @lru_cache(None)\\n        "]}
{"id": "2011", "ref_py": ["def minCost(self, houses, cost, m, n, target) -> int:", "def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\\n        @cache\\n        def dp(i, p, h):\\n            if (h > target) or (i == m and h != target):\\n                return inf\\n            if i == m:\\n                return 0\\n            if houses[i] != 0:\\n                return dp(i + 1, houses[i], h + int(p != houses[i]))", "def dp(self, houses, costs, target, house, prevPaint, neighborhood, lookup):\\n        if house == len(houses):\\n            return 0 if neighborhood == target else sys.maxsize\\n        key = (house, prevPaint, neighborhood)\\n        if key not in lookup:\\n            if houses[house] == 0:\\n                cost = sys.maxsize\\n                for j in range(len(costs[house])):\\n                    currentPaint = j+1\\n                    cost = min(cost, costs[house][j] + self.dp(houses, costs, target, house+1, currentPaint, neighborhood+int(currentPaint != prevPaint), lookup))\\n                lookup[key] = cost\\n            else:\\n                lookup[key] = self.dp(houses, costs, target, house+1, houses[house], neighborhood+int(houses[house] != prevPaint), lookup)\\n        return lookup[key]\\n    \\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\\n        cost = self.dp(houses, cost, target, 0, 0, 0, {})\\n        return cost if cost != sys.maxsize else -1\\n```"]}
{"id": "2012", "ref_py": ["def minDistance(self, houses: List[int], k: int) -> int:\\n        @functools.cache\\n        def _loop(start: int, end: int, num_mailboxes: int) -> int:\\n            num_houses = end - start + 1\\n            if num_houses == num_mailboxes:\\n                return 0\\n            if num_mailboxes == 1:\\n                if num_houses % 2 == 0:\\n                    mid = start + num_houses // 2\\n                    pos = houses[mid - 1] + (houses[mid] - houses[mid - 1]) // 2\\n                else:\\n                    mid = start + (num_houses - 1) // 2\\n                    pos = houses[mid]", "def minDistance(self, houses: List[int], k: int) -> int:\\n        \\n        n = len(houses)\\n        houses.sort()\\n        cost = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mid_house = houses[(i+j)//2]\\n                for t in range(i,j+1):\\n                    cost[i][j]+= abs(mid_house-houses[t])\\n        \\n        @lru_cache(None)\\n        def dp(k,ind):\\n            if k==0 and ind==n: return 0\\n            if k==0 or ind==n: return float(\\'inf\\')\\n            res = float(\\'inf\\')\\n            for j in range(ind,n):\\n                c = cost[ind][j]\\n                res = min(res, c + dp(k-1,j+1))\\n            \\n            return res\\n        \\n        return dp(k,0)", "def minDistance(self, houses: List[int], k: int) -> int:\\n        \\n        n = len(houses)\\n        houses.sort()\\n        cost = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mid_house = houses[(i+j)//2]\\n                for t in range(i,j+1):\\n                    cost[i][j]+= abs(mid_house-houses[t])\\n        \\n        @lru_cache(None)\\n        def dp(k,ind):\\n            if k==0 and ind==n: return 0\\n            if k==0 or ind==n: return float(\\'inf\\')\\n            res = float(\\'inf\\')\\n            for j in range(ind,n):\\n                c = cost[ind][j]\\n                res = min(res, c + dp(k-1,j+1))\\n            \\n            return res\\n        \\n        return dp(k,0)"]}
{"id": "2014", "ref_py": ["def find(self,u,parent):\\n        if u==parent[u]:\\n            return u\\n        return self.find(parent[u],parent)", "def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\tdef kruskal(n, graph):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\tres= 0\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")", "def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find_parent(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union_sets(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv"]}
{"id": "2015", "ref_py": ["defaultdict\\nfrom itertools import combinations", "defaultdict\\nfrom itertools import combinations", "defaultdict\\nfrom itertools import combinations"]}
{"id": "2016", "ref_py": ["def findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24", "def findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24", "def findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24"]}
{"id": "2017", "ref_py": ["def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    ", "def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    ", "def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    "]}
{"id": "2018", "ref_py": ["def winnerSquareGame(self, n: int) -> bool:\\n        squares = lambda x: (i * i for i in range(isqrt(x), 0, -1))\\n        \\n        @cache\\n        def can_win(n: int) -> bool:\\n            return n and not all(can_win(n - s) for s in squares(n))\\n        \\n        return can_win(n)", "def winnerSquareGame(self, n: int) -> bool:\\n        dp = [False] * (n + 1)\\n        squares = []\\n        curSquare = 1\\n        for i in range(1, n + 1):\\n            if i == curSquare * curSquare:\\n                squares.append(i)\\n                curSquare += 1\\n                dp[i] = True\\n            else:\\n                for square in squares:\\n                    if not dp[i - square]:\\n                        dp[i] = True\\n                        break\\n        return dp[n]\\n```", "def winnerSquareGame(self, n: int) -> bool:\\n        squares = lambda x: (i * i for i in range(isqrt(x), 0, -1))\\n        \\n        @cache\\n        def can_win(n: int) -> bool:\\n            return n and not all(can_win(n - s) for s in squares(n))\\n        \\n        return can_win(n)"]}
{"id": "2019", "ref_py": ["def getMinDistSum(self, P: List[List[int]]) -> float:\\n        from math import sqrt\\n        def dist_all(x, y):  ", "def getMinDistSum(self, positions: List[List[int]]) -> float:\\n        def dist(x, y):\\n            return sum(math.sqrt((x-i)**2 + (y-j)**2) for i, j in positions)\\n        \\n        def pdx(x, y):  ", "def _dist(self, curr, positions):\\n        dist = 0\\n        x, y = curr\\n        for a, b in positions:\\n            dist += math.sqrt((x - a) ** 2 + (y - b) ** 2)\\n        return dist"]}
{"id": "2020", "ref_py": ["def maxNumOfSubstrings(self, s: str) -> List[str]:\\n\\ttmp = {c: [s.index(c), s.rindex(c)+1] for c in set(s)}\\n\\t", "def maxNumOfSubstrings(self, s: str) -> List[str]:\\n\\ttmp = {c: [s.index(c), s.rindex(c)+1] for c in set(s)}\\n\\t", "def maxNumOfSubstrings(self, s: str) -> List[str]:\\n\\ttmp = {c: [s.index(c), s.rindex(c)+1] for c in set(s)}\\n\\t"]}
{"id": "2021", "ref_py": ["def closestToTarget(self, arr: List[int], target: int) -> int:\\n        occ = [0] * 20\\n        left = 0\\n        val = (1 << 21) - 1\\n        ans = inf\\n        for i, x in enumerate(arr):\\n            val = val & x\\n            for j in range(20):\\n                occ[j] += x >> j & 1\\n            ans = min(ans, abs(target - val))\\n            while val < target and i > left:\\n                y = arr[left]\\n                left += 1\\n                for j in range(20):\\n                    occ[j] -= y >> j & 1\\n                    if y >> j & 1 == 0 and occ[j] == i - left + 1:\\n                        val += 1 << j\\n                ans = min(ans, abs(target - val))\\n        return ans\\n```", "def __init__(self, arr, func, init):\\n        self.func = func\\n        self.init = init\\n        n = len(arr)\\n        k = n.bit_length()\\n        table = [[self.init] * k for _ in range(n)]\\n        self.mpow = [(0, 1)] * (n + 1)\\n        l = 0\\n        p = 1\\n        for i in range(1, n + 1):\\n            if p * 2 <= i:\\n                l += 1\\n                p *= 2\\n            self.mpow[i] = (l, p)\\n        for l in range(k):\\n            for i in range(n):\\n                if l == 0:\\n                    table[i][l] = arr[i]\\n                else:\\n                    a = table[i][l - 1]\\n                    b = self.init\\n                    if i + (1 << l - 1) < n:\\n                        b = table[i + (1 << l - 1)][l - 1]\\n                    table[i][l] = self.func(a, b)\\n        self.table = table", "def closestToTarget(self, arr: List[int], target: int) -> int:\\n        occ = [0] * 20\\n        left = 0\\n        val = (1 << 21) - 1\\n        ans = inf\\n        for i, x in enumerate(arr):\\n            val = val & x\\n            for j in range(20):\\n                occ[j] += x >> j & 1\\n            ans = min(ans, abs(target - val))\\n            while val < target and i > left:\\n                y = arr[left]\\n                left += 1\\n                for j in range(20):\\n                    occ[j] -= y >> j & 1\\n                    if y >> j & 1 == 0 and occ[j] == i - left + 1:\\n                        val += 1 << j\\n                ans = min(ans, abs(target - val))\\n        return ans\\n```"]}
{"id": "2022", "ref_py": ["defines a class `Solution` with a method `subsets` that takes a list of integers `nums` as input and returns a list of all possible subsets of the input list. The subsets are generated using a recursive helper function `subb`.", "def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    ", "def combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    "]}
{"id": "2023", "ref_py": ["def getLengthOfOptimalCompression(self, s: str, k: int) -> int:", "def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        def helper(s, cur, last, count, k, dp):\\n            ", "def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        def helper(s, cur, last, count, k, dp):\\n            "]}
{"id": "2024", "ref_py": ["def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\tM, N = len(nums1), len(nums2)\\n        sum1, sum2 = 0, 0\\n        i, j = 0, 0\\n        res = 0\\n        while i < M and j < N:\\n            if nums1[i] < nums2[j]:\\n                sum1 += nums1[i]\\n                i += 1\\n            elif nums1[i] > nums2[j]:\\n                sum2 += nums2[j]\\n                j += 1\\n            else:\\n                res += max(sum1, sum2) + nums1[i]\\n                i += 1\\n                j += 1\\n                sum1 = 0\\n                sum2 = 0\\n                \\n        while i < M:\\n            sum1 += nums1[i]\\n            i += 1\\n        while j < N:\\n            sum2 += nums2[j]\\n            j += 1\\n        return (res + max(sum1, sum2)) % 1000000007\\n```", "def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        @cache\\n        def dp(i, j):\\n            if j == 1 and i == len(nums1):\\n                return 0\\n            if j == 2 and i == len(nums2):\\n                return 0", "def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        @cache\\n        def dp(i, j):\\n            if j == 1 and i == len(nums1):\\n                return 0\\n            if j == 2 and i == len(nums2):\\n                return 0"]}
{"id": "2025", "ref_py": ["def longestAwesome(self, s: str) -> int:\\n        masks = [-2] * 1024\\n        masks[0] = -1\\n        cur = 0\\n        ans = 1\\n        for i, x in enumerate(s):\\n            cur ^= 1 << int(x)\\n            if masks[cur] != -2: ans = max(ans, i - masks[cur])\\n            for j in range(10):\\n                if masks[cur ^ (1 << j)] != -2: ans = max(ans, i - masks[cur ^ (1 << j)])\\n            if masks[cur] == -2: masks[cur] = i\\n        return ans\\n```", "def longestAwesome(self, s: str) -> int:\\n        masks = [-2] * 1024\\n        masks[0] = -1\\n        cur = 0\\n        ans = 1\\n        for i, x in enumerate(s):\\n            cur ^= 1 << int(x)\\n            if masks[cur] != -2: ans = max(ans, i - masks[cur])\\n            for j in range(10):\\n                if masks[cur ^ (1 << j)] != -2: ans = max(ans, i - masks[cur ^ (1 << j)])\\n            if masks[cur] == -2: masks[cur] = i\\n        return ans\\n```", "def longestAwesome(self, s: str) -> int:\\n        masks = [-2] * 1024\\n        masks[0] = -1\\n        cur = 0\\n        ans = 1\\n        for i, x in enumerate(s):\\n            cur ^= 1 << int(x)\\n            if masks[cur] != -2: ans = max(ans, i - masks[cur])\\n            for j in range(10):\\n                if masks[cur ^ (1 << j)] != -2: ans = max(ans, i - masks[cur ^ (1 << j)])\\n            if masks[cur] == -2: masks[cur] = i\\n        return ans\\n```"]}
{"id": "2026", "ref_py": ["def minCost(self, n: int, cuts: list[int]) -> int:\\n        s_cuts = sorted(chain(cuts, (0, n)))", "def minCost(self, n: int, cuts: list[int]) -> int:\\n        s_cuts = sorted(chain(cuts, (0, n)))", "def minCost(self, n: int, cuts: list[int]) -> int:\\n        s_cuts = sorted(chain(cuts, (0, n)))"]}
{"id": "2027", "ref_py": ["def removeDuplicates(self, s: str, k: int) -> str:        \\n        stck = [[\\'$\\', 0]]     ", "def removeDuplicates(self, s: str, k: int) -> str:\\n        a=[]\\n        for i in s:\\n            if a and a[-1][0]==i:\\n                a[-1][1]+=1\\n                if a[-1][1]==k: a.pop()\\n            else: a.append([i,1])\\n        return \\'\\'.join(key*value for key, value in a)        \\n```", "def removeDuplicates(self, s: str, k: int) -> str:        \\n        stck = [[\\'$\\', 0]]     "]}
{"id": "2028", "ref_py": ["def findMiddleIndex(self, nums: List[int]) -> int:               \\n\\tleftSum = 0\\n\\trightSum = sum(nums)", "def findMiddleIndex(self, nums: List[int]) -> int:               \\n\\tleftSum = 0\\n\\trightSum = sum(nums)", "def findMiddleIndex(self, nums: List[int]) -> int:               \\n\\tleftSum = 0\\n\\trightSum = sum(nums)"]}
{"id": "2029", "ref_py": ["def minDays(self, grid: List[List[int]]) -> int:\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    cnt += 1 ", "def minDays(self, grid: List[List[int]]) -> int:\\n        \\n        def countislands(grid):\\n            islands = 0\\n            visited = set()", "defaultdict\\nfrom collections import deque"]}
{"id": "2030", "ref_py": ["def numOfWays(self, nums: list[int]) -> int:\\n        M = 1_000_000_007", "def numOfWays(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        \\n        def f(nums):\\n            n=len(nums)\\n            if n<=1:\\n                return len(nums) ", "def numOfWays(self, nums):\\n        \\n        self.ans = 1\\n        mod = 1000000007\\n        class BST:\\n            self.right = None\\n            self.left = None\\n            self.val = None\\n            self.below_count = None\\n            self.cont_ans = None"]}
{"id": "2031", "ref_py": ["def solve(self, locations, currCity, remainingFuel):\\n        if remainingFuel < 0:\\n            return 0\\n        if self.dp[currCity][remainingFuel] != -1:\\n            return self.dp[currCity][remainingFuel]", "def countRoutes(self, locations: list[int], start: int, finish: int, fuel: int) -> int:\\n        @cache\\n        def routes(s: int, f: int) -> int:\\n            return ((s == finish) + sum(routes(e, f - d) for e in range(len(locations)) if s != e and (d := abs(locations[s] - locations[e])) <= f)) % 1_000_000_007\\n        \\n        return routes(start, fuel)", "def solve(self, locations, currCity, remainingFuel):\\n        if remainingFuel < 0:\\n            return 0\\n        if self.dp[currCity][remainingFuel] != -1:\\n            return self.dp[currCity][remainingFuel]"]}
{"id": "2032", "ref_py": ["def dfs(self,vis,li,com,i):\\n        if(vis[i]):\\n            return 0\\n        vis[i]=com\\n        ans=1\\n        for j in li[i]:\\n            ans+=self.dfs(vis,li,com,j)\\n        return ans", "def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\\n        es = reduce(lambda a, x: a[x[0]].append((x[1], x[2])) or a, edges, ([], [], [], []))", "def maxNumEdgesToRemove(self, n, edges):\\n        def find(x, parent):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x], parent)\\n            return parent[x]"]}
{"id": "2033", "ref_py": ["defaultdict\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        ", "def isTransformable(self, s: str, t: str) -> bool:\\n        ", "def isTransformable(self, s: str, t: str) -> bool:\\n        "]}
{"id": "2034", "ref_py": ["def isPrintable(self, targetGrid):\\n        \\n        ", "def get_color_borders(self, g, R, C):\\n        color_border = dict()\\n        for r in range(R):\\n            for c in range(C):\\n                color = g[r][c]\\n                if color in color_border:\\n                    border = color_border[color]\\n                    border[0], border[1] = min(border[0], r), min(border[1], c)\\n                    border[2], border[3] = max(border[2], r), max(border[3], c)\\n                else: color_border[color] = [r, c, r, c]     \\n        return color_border", "def isPrintable(self, targetGrid):\\n        \\n        "]}
{"id": "2035", "ref_py": ["def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m = len(cost), len(cost[0])\\n        dp_0 = [inf] * (1 << m)\\n        dp_1 = [inf] * (1 << m)\\n        dp_0[0] = 0\\n        for i in range(n):\\n            for mask in range(1, 1 << m):\\n                for j in range(m):\\n                    if mask >> j & 1:\\n                        dp_1[mask] = min(dp_1[mask], dp_0[mask ^ (1 << j)] + cost[i][j], dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])\\n            dp_0, dp_1 = dp_1, dp_0\\n            for mask in range(1 << m): dp_1[mask] = inf\\n        return dp_0[(1 << m) - 1]\\n```", "def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        Lmin = [0 for _ in range(rows)]\\n        Rmin = [0 for _ in range(cols)]", "def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m = len(cost), len(cost[0])\\n        dp_0 = [inf] * (1 << m)\\n        dp_1 = [inf] * (1 << m)\\n        dp_0[0] = 0\\n        for i in range(n):\\n            for mask in range(1, 1 << m):\\n                for j in range(m):\\n                    if mask >> j & 1:\\n                        dp_1[mask] = min(dp_1[mask], dp_0[mask ^ (1 << j)] + cost[i][j], dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])\\n            dp_0, dp_1 = dp_1, dp_0\\n            for mask in range(1 << m): dp_1[mask] = inf\\n        return dp_0[(1 << m) - 1]\\n```"]}
{"id": "2036", "ref_py": ["def subsetsWithDup(self, nums):\\n        \\n        res = []\\n        nums.sort()", "def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        l=len(requests)\\n        for i in range(l,0,-1):\\n            for j in combinations(requests,i):\\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\\n                    return i", "def maximumRequests(self, n: int, requests: list[list[int]]) -> int:\\n        is_achievable = lambda reqs: not any((Counter(u for u, _ in reqs) - Counter(v for _, v in reqs)).values())\\n        powerset_reqs = chain.from_iterable(combinations(requests, k) for k in range(len(requests), 0, -1))\\n        return next(map(len, filter(is_achievable, powerset_reqs)), 0)"]}
{"id": "2037", "ref_py": ["defined routing algorithm in the question, I keep a sorted list of the avaiable servers indices.\\tThis gives me the ability to do a binary search (O(logk)) in order to find the next available server\\n\\t", "defined routing algorithm in the question, I keep a sorted list of the avaiable servers indices.\\tThis gives me the ability to do a binary search (O(logk)) in order to find the next available server\\n\\t", "defined routing algorithm in the question, I keep a sorted list of the avaiable servers indices.\\tThis gives me the ability to do a binary search (O(logk)) in order to find the next available server\\n\\t"]}
{"id": "2038", "ref_py": ["def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        ", "def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        ", "def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        "]}
{"id": "2039", "ref_py": ["def minimumOneBitOperations(self, n: int) -> int:\\n        ans, f = 0, 0\\n        for i in range(31, -1, -1):\\n            if ((n >> i) & 1) == 1:\\n                if f == 0:\\n                    ans = ans + ((1 << (i + 1))) - 1\\n                    f = 1\\n                else:\\n                    ans = ans - ((1 << (i + 1)) - 1)\\n                    f = 0\\n                print(ans)\\n        return ans", "def minimumOneBitOperations(self, n: int) -> int:\\n        ans, f = 0, 0\\n        for i in range(31, -1, -1):\\n            if ((n >> i) & 1) == 1:\\n                if f == 0:\\n                    ans = ans + ((1 << (i + 1))) - 1\\n                    f = 1\\n                else:\\n                    ans = ans - ((1 << (i + 1)) - 1)\\n                    f = 0\\n                print(ans)\\n        return ans", "def minimumOneBitOperations(self, n: int) -> int:\\n        ans, f = 0, 0\\n        for i in range(31, -1, -1):\\n            if ((n >> i) & 1) == 1:\\n                if f == 0:\\n                    ans = ans + ((1 << (i + 1))) - 1\\n                    f = 1\\n                else:\\n                    ans = ans - ((1 << (i + 1)) - 1)\\n                    f = 0\\n                print(ans)\\n        return ans"]}
{"id": "2040", "ref_py": ["def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        ", "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n\\t\\t", "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        "]}
{"id": "2042", "ref_py": ["def findparent(self, node, parent):\\n        if parent[node] == node:\\n            return node", "def areConnected(self, n, threshold, queries):\\n        def union(x, y):\\n            root_x, root_y = find(x), find(y)\\n            if root_x != root_y:\\n                parent[root_y] = root_x", "def __init__(self, n):\\n        self.root = [*range(n)]\\n        self.rank = [0]*n\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        \\n        if rootx  == rooty:\\n            return \\n        \\n        if self.rank[rootx] > self.rank[rooty]:\\n            self.root[rooty] = rootx\\n            \\n        elif self.rank[rooty] > self.rank[rootx]:\\n            self.root[rootx] = rooty\\n            \\n        else:\\n            self.root[rooty] = rootx\\n            self.rank[rootx] += 1\\n    \\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)"]}
{"id": "2043", "ref_py": ["def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\\n    m = len(matrix); n = len(matrix[0])\\n    \\n    vals = defaultdict(list)\\n    for i in range(m):\\n        for j in range(n):\\n            vals[matrix[i][j]].append([i, j])\\n    \\n    def find(i):\\n        if i != parent[i]:\\n            parent[i] = find(parent[i])\\n        return parent[i]\\n    \\n    rank = [0]*(m + n)\\n    \\n    for val in sorted(vals):\\n        parent = list(range(m + n))", "def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def find_root(x: int, y: int):\\n            if parent[x][y] == (x, y):\\n                return (x, y)\\n            else:\\n                r = find_root(parent[x][y][0], parent[x][y][1])\\n                parent[x][y] = r\\n                return r\\n        \\n        def union(x1, y1, x2, y2):\\n            root_a = find_root(x1, y1)\\n            root_b = find_root(x2, y2)\\n            parent[root_b[0]][root_b[1]] = root_a\\n            \\n        ", "def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\\n    m = len(matrix); n = len(matrix[0])\\n    \\n    vals = defaultdict(list)\\n    for i in range(m):\\n        for j in range(n):\\n            vals[matrix[i][j]].append([i, j])\\n    \\n    def find(i):\\n        if i != parent[i]:\\n            parent[i] = find(parent[i])\\n        return parent[i]\\n    \\n    rank = [0]*(m + n)\\n    \\n    for val in sorted(vals):\\n        parent = list(range(m + n))"]}
{"id": "2044", "ref_py": ["def __init__(self):\\n        self.char_set = set()\\n        self.frequencies = defaultdict(int)\\n    def add_char(self, char):\\n        self.char_set.add(char)\\n        self.frequencies[char] += 1", "def __init__(self):\\n        self.char_set = set()\\n        self.frequencies = defaultdict(int)\\n    def add_char(self, char):\\n        self.char_set.add(char)\\n        self.frequencies[char] += 1", "def __init__(self):\\n        self.char_set = set()\\n        self.frequencies = defaultdict(int)\\n    def add_char(self, char):\\n        self.char_set.add(char)\\n        self.frequencies[char] += 1"]}
{"id": "2045", "ref_py": ["def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```", "def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```", "def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```"]}
{"id": "2046", "ref_py": ["def createSortedArray(self, instructions):\\n        t = [0] * 100001\\n        \\n        def incr(i):\\n            while i < 100001:\\n                t[i] += 1\\n                i += i & -i\\n                \\n        def query(i):\\n            ret = 0\\n            while i > 0:\\n                ret += t[i]\\n                i -= i & -i\\n            return ret\\n        \\n        ans = 0\\n        for i, x in enumerate(instructions):\\n            ans += min(query(x - 1), i - query(x))\\n            ans %= 1000000007\\n            incr(x)", "def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n\\t\\t", "def createSortedArray(self, instructions):\\n        t = [0] * 100001\\n        \\n        def incr(i):\\n            while i < 100001:\\n                t[i] += 1\\n                i += i & -i\\n                \\n        def query(i):\\n            ret = 0\\n            while i > 0:\\n                ret += t[i]\\n                i -= i & -i\\n            return ret\\n        \\n        ans = 0\\n        for i, x in enumerate(instructions):\\n            ans += min(query(x - 1), i - query(x))\\n            ans %= 1000000007\\n            incr(x)"]}
{"id": "2047", "ref_py": ["def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        ", "def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        ", "def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        "]}
{"id": "2048", "ref_py": ["def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\\n        def calc(x, y): ", "def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\\n        def calc(x, y): ", "def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\\n        def calc(x, y): "]}
{"id": "2049", "ref_py": ["def minimumEffort(self, tasks: List[List[int]]) -> int:\\n\\t\\t", "def minimumEffort(self, tasks: List[List[int]]) -> int:\\n        tasks.sort()\\n        dic=dict()\\n        for i in tasks:\\n            if i[1]-i[0] in dic:dic[i[1]-i[0]].append(i)\\n            else:dic[i[1]-i[0]]=[i]\\n        vals,arr,res=sorted(dic.keys()),[],0\\n        for i in vals:\\n            for  j in dic[i]:\\n                arr.append(j)\\n        for i in range(len(arr)):\\n            if res+arr[i][0]>=arr[i][1]:res+=arr[i][0]\\n            else:res=arr[i][1]\\n        return res", "def minimumEffort(self, tasks: List[List[int]]) -> int:\\n        tasks.sort()\\n        dic=dict()\\n        for i in tasks:\\n            if i[1]-i[0] in dic:dic[i[1]-i[0]].append(i)\\n            else:dic[i[1]-i[0]]=[i]\\n        vals,arr,res=sorted(dic.keys()),[],0\\n        for i in vals:\\n            for  j in dic[i]:\\n                arr.append(j)\\n        for i in range(len(arr)):\\n            if res+arr[i][0]>=arr[i][1]:res+=arr[i][0]\\n            else:res=arr[i][1]\\n        return res"]}
{"id": "2050", "ref_py": ["def largestGoodInteger(self, num: str) -> str:\\n        maxi=\"\"\\n        for i in range(0,len(num)-2):  \\n            if len(set([num[i],num[i+1],num[i+2]]))==1:\\n                maxi=max(maxi,num[i])\\n        return maxi*3\\n\\t\\n```", "def largestGoodInteger(self, num: str) -> str:\\n        maxi=\"\"\\n        for i in range(0,len(num)-2):  \\n            if len(set([num[i],num[i+1],num[i+2]]))==1:\\n                maxi=max(maxi,num[i])\\n        return maxi*3\\n\\t\\n```", "def largestGoodInteger(self, num: str) -> str:\\n        maxi=\"\"\\n        for i in range(0,len(num)-2):  \\n            if len(set([num[i],num[i+1],num[i+2]]))==1:\\n                maxi=max(maxi,num[i])\\n        return maxi*3\\n\\t\\n```"]}
{"id": "2051", "ref_py": ["def minimumDeviation(nums: List[int]) -> int:\\n    mn = min(nums)\\n    pq = [-x if x % 2 else -x // 2 for x in nums]\\n    heapq.heapify(pq)\\n    ans = float(\\'inf\\')\\n    while True:\\n        x = -heapq.heappop(pq)\\n        ans = min(ans, x - mn)\\n        if x % 2 == 1:\\n            break\\n        heapq.heappush(pq, -x // 2)\\n    return ans", "def minimumDeviation(self, nums: List[int]) -> int:\\n        ", "defined as the difference between the maximum and minimum values of the array, where each value can be either the original value or twice the original value (if it is odd).\\n<!-- Describe your first thoughts on how to solve this problem. -->"]}
{"id": "2052", "ref_py": ["def minimumIncompatibility(self, nums, k):\\n        nums.sort(reverse = True)\\n        upperbound = len(nums) // k\\n        arr = [[] for _ in range(k)]\\n        self.res = float(\\'inf\\')\\n        def assign(i):\\n            if i == len(nums):\\n                self.res = min(self.res, sum(arr[i][0]-arr[i][-1] for i in range(k)))\\n                return True\\n            flag = 0\\n            for j in range(k):\\n                if not arr[j] or (len(arr[j]) < upperbound and arr[j][-1] != nums[i]):\\n                    arr[j].append(nums[i])\\n                    if assign(i+1):\\n                        flag += 1\\n                    arr[j].pop()\\n                if flag >= 2: break\\n            return flag != 0\\n        if max(collections.Counter(nums).values()) > k: return -1\\n        assign(0)\\n        return self.res\\n```", "def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        @lru_cache(None)\\n        def dfs(d, k, count):\\n            d = dict(d)\\n            ", "def minimumIncompatibility(self, nums, k):\\n        nums.sort(reverse = True)\\n        upperbound = len(nums) // k\\n        arr = [[] for _ in range(k)]\\n        self.res = float(\\'inf\\')\\n        def assign(i):\\n            if i == len(nums):\\n                self.res = min(self.res, sum(arr[i][0]-arr[i][-1] for i in range(k)))\\n                return True\\n            flag = 0\\n            for j in range(k):\\n                if not arr[j] or (len(arr[j]) < upperbound and arr[j][-1] != nums[i]):\\n                    arr[j].append(nums[i])\\n                    if assign(i+1):\\n                        flag += 1\\n                    arr[j].pop()\\n                if flag >= 2: break\\n            return flag != 0\\n        if max(collections.Counter(nums).values()) > k: return -1\\n        assign(0)\\n        return self.res\\n```"]}
{"id": "2053", "ref_py": ["def boxDelivering(boxes, portsCount, maxBoxes, maxWeight):\\n\\tn = len(boxes)", "def boxDelivering(boxes, portsCount, maxBoxes, maxWeight):\\n\\tn = len(boxes)", "def boxDelivering(boxes, portsCount, maxBoxes, maxWeight):\\n\\tn = len(boxes)"]}
{"id": "2054", "ref_py": ["def __init__(self, n):\\n        self.n = n\\n        self.arr = [0] * (n+1)\\n    \\n    def get(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans = max(ans, self.arr[i])\\n            i -= i & -i\\n        return ans\\n    \\n    def set(self, i, x):\\n        i += 1\\n        while i <= self.n:\\n            self.arr[i] = max(self.arr[i], x)\\n            i += i & -i\\n    \\n    def unset(self, i):\\n        i += 1\\n        while i <= self.n:\\n            self.arr[i] = 0\\n            i += i & -i", "def maxHeight(self, cuboids: List[List[int]]) -> int:\\n        n = len(cuboids)\\n        \\n        dp = [0]*n\\n        for c in cuboids:\\n            c.sort()\\n        cuboids.sort()\\n        \\n        for i in range(n):\\n            dp[i] = cuboids[i][2]\\n            for j in range(i):\\n                if cuboids[j][1] <= cuboids[i][1] and cuboids[j][2] <= cuboids[i][2]:\\n                    dp[i] = max(dp[i],dp[j]+cuboids[i][2])\\n                    \\n        return max(dp)\\n\\t\\t", "def __init__(self, n):\\n        self.n = n\\n        self.arr = [0] * (n+1)\\n    \\n    def get(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans = max(ans, self.arr[i])\\n            i -= i & -i\\n        return ans\\n    \\n    def set(self, i, x):\\n        i += 1\\n        while i <= self.n:\\n            self.arr[i] = max(self.arr[i], x)\\n            i += i & -i\\n    \\n    def unset(self, i):\\n        i += 1\\n        while i <= self.n:\\n            self.arr[i] = 0\\n            i += i & -i"]}
{"id": "2055", "ref_py": ["defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]`. denotes an edge between nodes `ui` and `v`i with distance `disi`.", "def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parents = defaultdict(lambda: None)\\n        sizes = defaultdict(int)\\n        \\n        def find(a):\\n            if a not in parents:\\n                parents[a] = a\\n                sizes[a] = 1\\n                return a", "def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N"]}
{"id": "2056", "ref_py": ["def minMoves(self, nums: List[int], k: int) -> int:\\n        p = [i for i, v in enumerate(nums) if v == 1]\\n        ", "def minMoves(self, nums: List[int], k: int) -> int:\\n        pos = [p for p,x in enumerate(nums) if x == 1]\\n        print(pos)", "def minMoves(self, nums: List[int], k: int) -> int:\\n        if k == 1:\\n            return 0\\n        ones = 0\\n        half = (k + 1) >> 1\\n        leftSum = rightSum = 0\\n        for i, num in enumerate(nums):\\n            if not num:\\n                continue\\n            ones += 1\\n            if ones < half:\\n                leftSum += i\\n                if ones == 1:\\n                    left = i\\n            elif ones == half:\\n                mid = i\\n            else:\\n                rightSum += i\\n                if ones == k:\\n                    right = i\\n                    break\\n        if k == 2:\\n            left = mid\\n        if k & 1:\\n            leftHalf = rightHalf = half - 1\\n        else:\\n            leftHalf, rightHalf = half - 1, half\\n        leftOffset = (leftHalf*leftHalf - leftHalf) >> 1\\n        rightOffset = (rightHalf*rightHalf - rightHalf) >> 1\\n        cur = res = (\\n            leftHalf * (mid - 1) - leftSum - leftOffset +\\n            rightSum - rightHalf * (mid + 1) - rightOffset\\n        )\\n        n = len(nums)\\n        while True:\\n            right += 1\\n            while right < n and not nums[right]:\\n                right += 1\\n            if right == n:\\n                break\\n            rightSum += right\\n            leftSum -= left\\n            left += 1\\n            while not nums[left]:\\n                left += 1\\n            leftSum += mid\\n            mid += 1\\n            while not nums[mid]:\\n                mid += 1\\n            rightSum -= mid\\n            cur = (\\n                leftHalf * (mid - 1) - leftSum - leftOffset +\\n                rightSum - rightHalf * (mid + 1) - rightOffset\\n            )\\n            res = min(res, cur)\\n        return res\\n            \\n        \\n        \\n        "]}
{"id": "2057", "ref_py": ["def __init__(self):\\n        self.root={}\\n        self.m=0\\n    \\n    def insert(self,word):\\n        node=self.root\\n        for ch in word:\\n            if ch not in node:\\n                node[ch]={}\\n            node=node[ch]", "def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        answer = []\\n        append = answer.append\\n        for x, m in queries:\\n            if nums[0] > m:\\n                append(-1)\\n                continue\\n            start, stop = 0, bisect_right(nums, m)\\n            num = 0\\n            bit = 2 ** m.bit_length()\\n            while bit:\\n                plus = num + bit\\n                if nums[start] >= plus:\\n                    num = plus\\n                elif nums[stop-1] >= plus:\\n                    cut = bisect_left(nums, plus, start, stop)\\n                    if x & bit:\\n                        stop = cut\\n                    else:\\n                        start = cut\\n                        num = plus\\n                bit //= 2\\n            append(num ^ x)\\n        return answer    \\n```\\n<h1> C++</h1>", "def __init__(self):\\n        self.root={}\\n        self.m=0\\n    \\n    def insert(self,word):\\n        node=self.root\\n        for ch in word:\\n            if ch not in node:\\n                node[ch]={}\\n            node=node[ch]"]}
{"id": "2058", "ref_py": ["def maxCoins(self, piles):\\n        piles.sort()\\n        ans = 0\\n        n = len(piles)", "def maxCoins(self, piles):\\n        piles.sort()\\n        ans = 0\\n        n = len(piles)", "def maxCoins(self, piles):\\n        piles.sort()\\n        ans = 0\\n        n = len(piles)"]}
{"id": "2059", "ref_py": ["defaultdict", "defaultdict", "defaultdict"]}
{"id": "2060", "ref_py": ["def minimumTimeRequired(self, jobs, k):\\n        \\n        jobs.sort(reverse=True)\\n        h = []", "def minimumTimeRequired(self, jobs, k):\\n        ", "def minimumTimeRequired(self, jobs, k):\\n        \\n        jobs.sort(reverse=True)\\n        h = []"]}
{"id": "2061", "ref_py": ["def canMouseWin(self, grid: list[str], catJump: int, mouseJump: int) -> bool:\\n        N, M = len(grid), len(grid[0])\\n        mouse_pos = None\\n        cat_pos = None\\n        food_pos = None\\n        _grid = [list(row) for row in grid]", "definitely be resolved in fewer moves.  By trial and\\nerror 2&middot;R&middot;C is a satisfactory bound for the maximum number of turns.\\n*Note: since the cat moves on odd turns, it is important that this number is even.*", "definitely be resolved in fewer moves.  By trial and\\nerror 2&middot;R&middot;C is a satisfactory bound for the maximum number of turns.\\n*Note: since the cat moves on odd turns, it is important that this number is even.*"]}
{"id": "2062", "ref_py": ["def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\\n        mod = 10**9 + 7", "definitely just store them in a hard-coded list and have optimal trial division (to me this is kinda cheating though, because I like my solutions to be more general, and not rely so hard on knowing the upper bound of the inputs in advance - I did try this though, and my runtime was a little faster at 364 ms, my memory usage was about the same, and my code was a little more readable - I should also note that there are only 3 numbers in this range which that 30k + m trial division tests that aren\\'t actually prime, so for this problem that\\'s pretty close to optimal already).", "def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\\n        mod = 10**9 + 7"]}
{"id": "2063", "ref_py": ["def minimumBoxes(self, n: int) -> int:\\n    \\n    p = -1\\n    q = 3*n\\n    r = 2/3\\n    m = floor((q + (q**2 + (r - p**2)**3)**(1/2))**(1/3) + (q - (q**2 + (r - p**2)**3)**(1/2))**(1/3) + p + 0.0001)\\n    \\n    diff = n - (m)*(m+1)*(m+2)//6\\n    return ceil(((1 + 8*diff)**0.5 - 1)/2) + (m*(m+1))//2\\n```", "def minimumBoxes(self, n: int) -> int:\\n    \\n    p = -1\\n    q = 3*n\\n    r = 2/3\\n    m = floor((q + (q**2 + (r - p**2)**3)**(1/2))**(1/3) + (q - (q**2 + (r - p**2)**3)**(1/2))**(1/3) + p + 0.0001)\\n    \\n    diff = n - (m)*(m+1)*(m+2)//6\\n    return ceil(((1 + 8*diff)**0.5 - 1)/2) + (m*(m+1))//2\\n```", "def minimumBoxes(self, n: int) -> int:\\n    \\n    p = -1\\n    q = 3*n\\n    r = 2/3\\n    m = floor((q + (q**2 + (r - p**2)**3)**(1/2))**(1/3) + (q - (q**2 + (r - p**2)**3)**(1/2))**(1/3) + p + 0.0001)\\n    \\n    diff = n - (m)*(m+1)*(m+2)//6\\n    return ceil(((1 + 8*diff)**0.5 - 1)/2) + (m*(m+1))//2\\n```"]}
{"id": "2064", "ref_py": ["def checkPartitioning(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tis_palindrome=[[False]*n for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tis_palindrome[i][i]=True\\n\\t\\t\\tfor l in range(n-2,-1,-1):\\n\\t\\t\\t\\tfor r in range(l+1,n):\\n\\t\\t\\t\\t\\tif s[l]==s[r]:\\n\\t\\t\\t\\t\\t\\tis_palindrome[l][r]|=is_palindrome[l+1][r-1] if r-1>=l+1 else True\\n\\t\\t\\tfor i in range(n-1):\\n\\t\\t\\t\\tfor j in range(i+1,n-1):\\n\\t\\t\\t\\t\\tif is_palindrome[0][i] and is_palindrome[i+1][j] and is_palindrome[j+1][n-1]:\\n\\t\\t\\t\\t\\t\\treturn True\\n", "def Manachen(string, fill_char=\\'", "def checkPartitioning(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tis_palindrome=[[False]*n for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tis_palindrome[i][i]=True\\n\\t\\t\\tfor l in range(n-2,-1,-1):\\n\\t\\t\\t\\tfor r in range(l+1,n):\\n\\t\\t\\t\\t\\tif s[l]==s[r]:\\n\\t\\t\\t\\t\\t\\tis_palindrome[l][r]|=is_palindrome[l+1][r-1] if r-1>=l+1 else True\\n\\t\\t\\tfor i in range(n-1):\\n\\t\\t\\t\\tfor j in range(i+1,n-1):\\n\\t\\t\\t\\t\\tif is_palindrome[0][i] and is_palindrome[i+1][j] and is_palindrome[j+1][n-1]:\\n\\t\\t\\t\\t\\t\\treturn True\\n"]}
{"id": "2065", "ref_py": ["def maxValue(self, events, k):\\n        ", "def maxValue(self, events, k):\\n        ", "def maxValue(self, events, k):\\n        "]}
{"id": "2066", "ref_py": ["def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def get_subset_sums(start, size): ", "def solve(self, nums, i, sums, path, goal):\\n        if i == len(nums):\\n            ", "def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        def get_subset_sums(start, size): "]}
{"id": "2067", "ref_py": ["def minTrioDegree(self, n, edges):\\n        ", "def minTrioDegree(self, n, edges):\\n        ", "def minTrioDegree(self, n, edges):\\n        "]}
{"id": "2068", "ref_py": ["def getCoprimes(self, nums, edges):\\n        \\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)", "def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\\n        def gcd(a, b):\\n            if b:\\n                return gcd(b, a%b)\\n            return a\\n            \\n        n = len(nums)\\n        G = [set() for _ in range(n)]\\n        for i, j in edges:\\n            G[i].add(j)\\n            G[j].add(i)\\n        \\n        primes = [set() for _ in range(51)]\\n        for i in range(1, 51):\\n            for j in range(i, 51):\\n                if gcd(i, j) == 1:\\n                    primes[i].add(j)\\n                    primes[j].add(i)", "def getCoprimes(self, nums, edges):\\n        \\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)"]}
{"id": "2069", "ref_py": ["defined by two variables `i` and `j`. Let\\'s used `X` to denote state, and thus, `X` represents the array where data will be memoized.", "defined by two variables `i` and `j`. Let\\'s used `X` to denote state, and thus, `X` represents the array where data will be memoized.", "defined by two variables `i` and `j`. Let\\'s used `X` to denote state, and thus, `X` represents the array where data will be memoized."]}
{"id": "2070", "ref_py": ["def numMovesStonesII(self, stones: List[int]) -> List[int]:\\n        \\n        stones.sort()\\n        n, lo = len(stones), inf", "def numMovesStonesII(self, stones: List[int]) -> List[int]:\\n        \\n        stones.sort()\\n        n, lo = len(stones), inf", "def numMovesStonesII(self, stones: List[int]) -> List[int]:\\n        \\n        stones.sort()\\n        n, lo = len(stones), inf"]}
{"id": "2071", "ref_py": ["def __init__(self, pos, speed, idx, prev=None, next=None):\\n        self.pos = pos\\n        self.speed = speed\\n        self.idx = idx\\n        self.prev = prev\\n        self.next = next", "def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\\n        \\n        \\n        N = len(cars)\\n        ans = [inf] * N\\n        stack = []\\n        \\n        def collision(a, b, i):\\n            ", "def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\\n        \\n        \\n        N = len(cars)\\n        ans = [inf] * N\\n        stack = []\\n        \\n        def collision(a, b, i):\\n            "]}
{"id": "2072", "ref_py": ["def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        self.count = 0\\n        self.prefix_sum = {0: 1}\\n        self.dfs(root, targetSum, 0)\\n        return self.count\\n        \\n    def dfs(self, node: TreeNode, targetSum: int, curr_sum: int) -> None:\\n        if not node:\\n            return\\n        \\n        curr_sum += node.val\\n        self.count += self.prefix_sum.get(curr_sum - targetSum, 0)\\n        self.prefix_sum[curr_sum] = self.prefix_sum.get(curr_sum, 0) + 1\\n        \\n        self.dfs(node.left, targetSum, curr_sum)\\n        self.dfs(node.right, targetSum, curr_sum)\\n        \\n        self.prefix_sum[curr_sum] -= 1", "def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:", "def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        self.count = 0\\n        self.prefix_sum = {0: 1}\\n        self.dfs(root, targetSum, 0)\\n        return self.count\\n        \\n    def dfs(self, node: TreeNode, targetSum: int, curr_sum: int) -> None:\\n        if not node:\\n            return\\n        \\n        curr_sum += node.val\\n        self.count += self.prefix_sum.get(curr_sum - targetSum, 0)\\n        self.prefix_sum[curr_sum] = self.prefix_sum.get(curr_sum, 0) + 1\\n        \\n        self.dfs(node.left, targetSum, curr_sum)\\n        self.dfs(node.right, targetSum, curr_sum)\\n        \\n        self.prefix_sum[curr_sum] -= 1"]}
{"id": "2073", "ref_py": ["def minChanges(self, A: List[int], k: int) -> int:\\n    n = len(A)\\n    cnts = [collections.Counter(A[j] for j in range(i, n, k)) for i in range(k)]\\n    \\n    ", "def minChanges(self, nums: List[int], k: int) -> int:\\n\\t", "def minChanges(self, A: List[int], k: int) -> int:\\n    n = len(A)\\n    cnts = [collections.Counter(A[j] for j in range(i, n, k)) for i in range(k)]\\n    \\n    "]}
{"id": "2074", "ref_py": ["defined by the **product** of the **minimum** value within the subarray and its **length**. Where `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)` and `i <= k <= j`.", "defined by the **product** of the **minimum** value within the subarray and its **length**. Where `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)` and `i <= k <= j`.", "defined by the **product** of the **minimum** value within the subarray and its **length**. Where `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)` and `i <= k <= j`."]}
{"id": "2075", "ref_py": ["def maxScore(self, nums: list[int]) -> int:\\n        \\n        def score(xs: list[int]) -> int:\\n            n = len(xs)\\n            return max((\\n                n // 2 * gcd(xs[i], xs[j]) +\\n                score(xs[:i] + xs[i + 1 : j] + xs[j + 1:])\\n                for i in range(n)\\n                for j in range(i + 1, n)),\\n                default=0,\\n            )\\n        \\n        return score(nums)", "def maxScore(self, nums: List[int]) -> int:\\n        @cache\\n        def fn(nums,k):\\n            if not nums:\\n                return 0", "def maxScore(self, nums: List[int]) -> int:\\n        @cache\\n        def fn(nums,k):\\n            if not nums:\\n                return 0"]}
{"id": "2076", "ref_py": ["def brokenCalc(self, x: int, y: int) -> int:\\n    steps = 0\\n    while y > x:\\n      steps += 1 + y % 2 ", "def brokenCalc(self, startValue, target):\\n        result = 0;\\n        while (startValue < target) :\\n            result+=1;\\n            if target % 2 == 0: target = target/2;\\n            else: target+=1;\\n        return result+startValue-target;\\n```", "def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```"]}
{"id": "2077", "ref_py": ["def dp(i, unique_vals, total_nice):\\n            if i == primeFactors: \\n                \\n                return total_nice\\n            \\n            ", "def dp(i, unique_vals, total_nice):\\n            if i == primeFactors: \\n                \\n                return total_nice\\n            \\n            ", "def dp(i, unique_vals, total_nice):\\n            if i == primeFactors: \\n                \\n                return total_nice\\n            \\n            "]}
{"id": "2078", "ref_py": ["def maxHappyGroups(self, batchSize, groups):", "def maxHappyGroups(self, batchSize, groups):", "def maxHappyGroups(self, batchSize, groups):"]}
{"id": "2079", "ref_py": ["def gcd(a,b):                 ", "def gcd(a,b):                 ", "def gcd(a,b):                 "]}
{"id": "2081", "ref_py": ["def makeStringSorted(self, s: str) -> int:\\n        \\n        cnt, ans, tot, comb_tot = [0]*26, 0, 0, 1           ", "def makeStringSorted(self, s: str) -> int:\\n        \\n        cnt, ans, tot, comb_tot = [0]*26, 0, 0, 1           ", "def makeStringSorted(self, s: str) -> int:\\n        \\n        cnt, ans, tot, comb_tot = [0]*26, 0, 0, 1           "]}
{"id": "2082", "ref_py": ["def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))", "def reverseStr(self, s: str, k: int) -> str:\\n        l, r = 0, min(k, len(s))"]}
{"id": "2083", "ref_py": ["def maxBuilding(self, n, restrictions):\\n        \\n        h=[(1,0)]\\n        restrictions.sort(key=lambda x:x[0])\\n        for rest in restrictions:\\n            tmp=min(rest[1], h[-1][1]+rest[0]-h[-1][0])\\n            h.append((rest[0], tmp))\\n        if len(restrictions)==0 or restrictions[-1]!=n:\\n            h.append((n, h[-1][1]+n-h[-1][0]))\\n        l=len(h)\\n        for i in range(l-2, -1, -1):\\n            tmp=min(h[i][1], h[i+1][1]+h[i+1][0]-h[i][0])\\n            h[i]=(h[i][0], tmp)\\n        ans=0\\n        for i in range(l-1):\\n            tmp=(h[i+1][1]+h[i][1]+h[i+1][0]-h[i][0])>>1\\n            if tmp>ans:\\n                ans=tmp\\n        return ans", "def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:\\n        if not restrictions:\\n            return n - 1\\n        restrictions.append([1, 0])  ", "def maxBuilding(self, n, restrictions):\\n        \\n        h=[(1,0)]\\n        restrictions.sort(key=lambda x:x[0])\\n        for rest in restrictions:\\n            tmp=min(rest[1], h[-1][1]+rest[0]-h[-1][0])\\n            h.append((rest[0], tmp))\\n        if len(restrictions)==0 or restrictions[-1]!=n:\\n            h.append((n, h[-1][1]+n-h[-1][0]))\\n        l=len(h)\\n        for i in range(l-2, -1, -1):\\n            tmp=min(h[i][1], h[i+1][1]+h[i+1][0]-h[i][0])\\n            h[i]=(h[i][0], tmp)\\n        ans=0\\n        for i in range(l-1):\\n            tmp=(h[i+1][1]+h[i][1]+h[i+1][0]-h[i][0])>>1\\n            if tmp>ans:\\n                ans=tmp\\n        return ans"]}
{"id": "2084", "ref_py": ["def canReach(self, arr: List[int], start: int) -> bool:\\n        ", "def canReach(self, arr: List[int], start: int) -> bool:\\n        ", "def canReach(self, arr: List[int], start: int) -> bool:\\n        "]}
{"id": "2085", "ref_py": ["def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1", "def searchInsert(self, nums, target):\\n        \\n        if target > nums[len(nums) - 1]:\\n            return len(nums)", "def search_insert(nums, target):\\n        low, high = 0, len(nums) - 1"]}
{"id": "2086", "ref_py": ["def largestPathValue(self, colors, edges):\\n        n = len(colors)\\n        Adj = [[] for _ in range(n)]\\n        Indegree = [0] * n", "def largestPathValue(self, colors, edges):\\n        n = len(colors)\\n        Adj = [[] for _ in range(n)]\\n        Indegree = [0] * n", "def largestPathValue(self, colors, edges):\\n        n = len(colors)\\n        Adj = [[] for _ in range(n)]\\n        Indegree = [0] * n"]}
{"id": "2087", "ref_py": ["def sumOfFlooredPairs(self, nums: List[int]) -> int:\\n        \\n        incs, counter=[0]*(max(nums)+1), Counter(nums)            ", "def sumOfFlooredPairs(self, n: List[int]) -> int:\\n        f, m, c = Counter(n), max(n), [0]*(max(n)+1)\\n        for k in f:\\n            d, r = f[k], 1\\n            while r*k <= m: c[r*k] += d; r += 1\\n        r, j = 0, 0\\n        for i in range(m+1):\\n            r += c[i]\\n            if i in f: j += f[i]*r\\n        return j%(10**9+7)\\n", "def sumOfFlooredPairs(self, nums: List[int]) -> int:\\n        \\n        incs, counter=[0]*(max(nums)+1), Counter(nums)            "]}
{"id": "2088", "ref_py": ["def rearrangeSticks(self, n: int, k: int) -> int:\\n        return dp(n, k)", "def rearrangeSticks(self, n: int, k: int) -> int:\\n        return dp(n, k)", "def rearrangeSticks(self, n: int, k: int) -> int:\\n        return dp(n, k)"]}
{"id": "2089", "ref_py": ["def stoneGameVIII(self, stones: List[int]) -> int:\\n    prefix = list(accumulate(stones))\\n    n = len(stones)", "def stoneGameVIII(self, stones: List[int]) -> int:\\n        sums, memory, n = [0], {}, len(stones)\\n        for s in stones:\\n            sums.append(s + sums[-1])\\n        \\n        memory, biggest = [sums[-1]] * n, sums[-1] \\n        for start in range(n - 2, -1, -1):\\n            memory[start] = max(biggest, sums[start + 1] - biggest)\\n            biggest = max(biggest, memory[start])\\n        return memory[1]", "def stoneGameVIII(self, A):\\n        for i in range(1,len(A)):\\n            A[i] += A[i-1]\\n        res = curr = A[-1]\\n        for i in range(len(A)-2,0,-1):\\n            res = max(res, A[i] - curr)\\n            curr = max(curr, A[i] - curr)\\n        return res\\n```"]}
{"id": "2090", "ref_py": ["def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res", "def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res", "def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res"]}
{"id": "2091", "ref_py": ["define DP function as `f(till_road_i, skips) = min_hour_used`", "def minSkips(self, dist: List[int], speed: int, target: int) -> int:\\n    n = len(dist)\\n    e = 0.000000001\\n    if sum(dist) > target*speed:\\n        return -1", "def minSkips(self, dist: List[int], speed: int, target: int) -> int:\\n    n = len(dist)\\n    e = 0.000000001\\n    if sum(dist) > target*speed:\\n        return -1"]}
{"id": "2092", "ref_py": ["def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\\n    packages.sort()\\n    space_to_fill = sum(packages)    ", "def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\\n    packages.sort()\\n    space_to_fill = sum(packages)    ", "def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\\n    packages.sort()\\n    space_to_fill = sum(packages)    "]}
{"id": "2093", "ref_py": ["def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```", "def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```", "def minimumRemoval(self, beans: List[int]) -> int:\\n        totalSum = sum(beans)\\n        beanLen = len(beans)\\n        beans.sort()\\n        minRm = float(\\'inf\\')\\n        for i, bean in enumerate(beans):\\n            minRm = min(minRm, totalSum - (beanLen - i) * bean)\\n        return minRm\\n```"]}
{"id": "2094", "ref_py": ["def earliestAndLatest(self, n, a, b):\\n        \\n        def simplify(n, a, b):\\n            ", "def earliestAndLatest(self, n: int, first: int, second: int) -> List[int]:\\n\\t\\tdef ceiling_of_log2(x: int) -> int:\\n\\t\\t\\t\\n\\t\\t\\tassert 0 < x < 0x100000000\\n\\t\\t\\t", "def earliestAndLatest(self, n: int, first: int, second: int) -> List[int]:\\n\\t\\tdef ceiling_of_log2(x: int) -> int:\\n\\t\\t\\t\\n\\t\\t\\tassert 0 < x < 0x100000000\\n\\t\\t\\t"]}
{"id": "2096", "ref_py": ["def waysToBuildRooms(self, prevRoom: List[int]) -> int:\\n\\t\\tmod = 10 ** 9 + 7\\n\\t\\tn = len(prevRoom)", "def waysToBuildRooms(self, prevRoom: List[int]) -> int:\\n\\t\\tmod = 10 ** 9 + 7\\n\\t\\tn = len(prevRoom)", "def waysToBuildRooms(self, prevRoom: List[int]) -> int:\\n\\t\\tmod = 10 ** 9 + 7\\n\\t\\tn = len(prevRoom)"]}
{"id": "2097", "ref_py": ["defend against any future updates of test cases, randomly chosen large primes can help to minimize the possibility of failing on them.", "defend against any future updates of test cases, randomly chosen large primes can help to minimize the possibility of failing on them.", "defend against any future updates of test cases, randomly chosen large primes can help to minimize the possibility of failing on them."]}
{"id": "2098", "ref_py": ["def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v, t = edge\\n            adj[u].append((v, t, passingFees[v]))\\n            adj[v].append((u, t, passingFees[u]))", "def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v, t = edge\\n            adj[u].append((v, t, passingFees[v]))\\n            adj[v].append((u, t, passingFees[u]))", "def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v, t = edge\\n            adj[u].append((v, t, passingFees[v]))\\n            adj[v].append((u, t, passingFees[u]))"]}
{"id": "2099", "ref_py": ["def colorTheGrid(self, m: int, n: int) -> int:\\n        \\'\\'\\'\\n            Solves a given recurrence relation\\n            @params dp: the nth sum per ith equation\\n            @params coeff: coefficients for the ith equation\\n        \\'\\'\\'\\n        def solve_rel(dp, coeff):\\n            for _ in range(n - 1):\\n                for i in range(len(dp)):\\n                    tmp = 0\\n                    for j, c in enumerate(coeff[i]):\\n                        ", "def colorTheGrid(self, m: int, n: int) -> int:\\n        from functools import reduce\\n        MOD = 10**9 + 7\\n        sum_mod = lambda x,y: (x+y)%MOD\\n        \\n        def normalize(pat_var):\\n            mapping = { e:i+1 for i, e in enumerate(pat_var[0:2]) }\\n            mapping[list({1,2,3}.difference(mapping.keys()))[0]] = 3\\n            return tuple([ mapping[e] for e in pat_var])\\n        \\n        def get_pats(m, i, pat, pats):\\n            if i == m-1:\\n                pats.append(tuple(pat))\\n                return\\n            i_nx = i+1\\n            for p_it_nx in (1,2,3):\\n                if (i_nx <= 1 and p_it_nx == i_nx+1 ) or (i_nx >= 2 and p_it_nx != pat[-1]):\\n                    pat.append(p_it_nx)\\n                    get_pats(m, i_nx, pat, pats)\\n                    pat.pop()\\n            return pats\\n        \\n        def get_trans(pat, i, pat_pre, trans):\\n            if i == len(pat)-1:\\n                pat_nl = normalize(pat_pre)\\n                trans[pat_nl] = trans.get(pat_nl, 0) + 1\\n                return\\n            for p_it_pre in (1,2,3):\\n                i_nx = i+1\\n                if (p_it_pre != pat[i_nx]\\n                    and (not pat_pre or p_it_pre != pat_pre[-1])):\\n                    pat_pre.append(p_it_pre)\\n                    get_trans(pat, i_nx, pat_pre, trans)\\n                    pat_pre.pop()\\n            return trans", "def colorTheGrid(self, m: int, n: int) -> int:\\n        mod = 10 ** 9 + 7"]}
{"id": "2100", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def canMerge(self, trees: List[TreeNode]) -> TreeNode:\\n\\t\\tn = len(trees)\\n\\t\\tif n == 1: return trees[0]", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "2101", "ref_py": ["defaultdict", "defaultdict", "defaultdict"]}
{"id": "2102", "ref_py": ["def canSeePersonsCount(self, heights):\\n        ans = [0 for i in range(len(heights))]\\n        stack = []\\n        for i in range(len(heights)):\\n            height = heights[i]\\n            while stack and heights[stack[-1]] <= height:\\n                ans[stack.pop()] += 1\\n            if stack:\\n                ans[stack[-1]] += 1\\n            stack.append(i)\\n        return ans\\n```", "def canSeePersonsCount(self, heights: List[int]) -> List[int]:\\n\\theights = heights[::-1] ", "def canSeePersonsCount(self, heights: List[int]) -> List[int]:\\n\\theights = heights[::-1] "]}
{"id": "2103", "ref_py": ["def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:\\n    tree = {\"", "def get_path(folder):\\n    out = \"/\"", "def get_path(folder):\\n    out = \"/\""]}
{"id": "2104", "ref_py": ["def countSpecialSubsequences(self, nums: List[int]) -> int:\\n        \\n        zero=0\\n        zeroone=0\\n        zeroonewo=0\\n        \\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                zero=2*zero+1\\n            elif nums[i]==1:\\n                zeroone=2*zeroone+zero\\n            elif nums[i]==2:\\n                zeroonewo=2*zeroonewo+zeroone\\n        return (zeroonewo)%(10**9+7)\\n        \\n", "def countSpecialSubsequences(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        last_0 = 0\\n        last_1 = 0\\n        last_2 = 0\\n        \\n        for i in nums:\\n            if i == 0:\\n                last_0 = (2*last_0 + 1)% 1000000007\\n            elif i == 1:\\n                last_1 = (last_0 + 2*last_1) % 1000000007\\n            elif i == 2:\\n                last_2 = (last_1 + 2*last_2) % 1000000007\\n        return last_2 % 1000000007\\n```", "def countSpecialSubsequences(self, nums: List[int]) -> int:\\n        \\n        zero=0\\n        zeroone=0\\n        zeroonewo=0\\n        \\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                zero=2*zero+1\\n            elif nums[i]==1:\\n                zeroone=2*zeroone+zero\\n            elif nums[i]==2:\\n                zeroonewo=2*zeroonewo+zeroone\\n        return (zeroonewo)%(10**9+7)\\n        \\n"]}
{"id": "2105", "ref_py": ["def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while (a != b):\\n            a = headB if not a else a.next\\n            b = headA if not b else b.next\\n        return a\\n```", "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next", "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next"]}
{"id": "2106", "ref_py": ["def longestObstacleCourseAtEachPosition(obstacles: List[int]) -> List[int]:\\n    n = len(obstacles)\\n    longestObstacleCourse, lis = [0] * n, [0] * n\\n    lisLength = 0\\n    for i in range(n):\\n        left, right = 0, lisLength\\n        while left < right:\\n            middle = (left + right) >> 1\\n            if lis[middle] <= obstacles[i]:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        if left >= lisLength or lis[left] > obstacles[i]:\\n            lis[left] = obstacles[i]\\n        if left == lisLength:\\n            lisLength += 1\\n        longestObstacleCourse[i] = left + 1\\n    return longestObstacleCourse\\n```", "def longestObstacleCourseAtEachPosition(obstacles: List[int]) -> List[int]:\\n    n = len(obstacles)\\n    longestObstacleCourse, lis = [0] * n, [0] * n\\n    lisLength = 0\\n    for i in range(n):\\n        left, right = 0, lisLength\\n        while left < right:\\n            middle = (left + right) >> 1\\n            if lis[middle] <= obstacles[i]:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        if left >= lisLength or lis[left] > obstacles[i]:\\n            lis[left] = obstacles[i]\\n        if left == lisLength:\\n            lisLength += 1\\n        longestObstacleCourse[i] = left + 1\\n    return longestObstacleCourse\\n```", "def longestObstacleCourseAtEachPosition(obstacles: List[int]) -> List[int]:\\n    n = len(obstacles)\\n    longestObstacleCourse, lis = [0] * n, [0] * n\\n    lisLength = 0\\n    for i in range(n):\\n        left, right = 0, lisLength\\n        while left < right:\\n            middle = (left + right) >> 1\\n            if lis[middle] <= obstacles[i]:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        if left >= lisLength or lis[left] > obstacles[i]:\\n            lis[left] = obstacles[i]\\n        if left == lisLength:\\n            lisLength += 1\\n        longestObstacleCourse[i] = left + 1\\n    return longestObstacleCourse\\n```"]}
{"id": "2107", "ref_py": ["def __init__(self):\\n        self.row = 0\\n        self.col = 0\\n        self.cells = []\\n        self.directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]", "def latestDayToCross(self, m: int, n: int, cells: list[list[int]]) -> int:\\n        LAND, WATER = 0, 1\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        grid = [[WATER] * n for _ in range(m)]", "def __init__(self):\\n        self.row = 0\\n        self.col = 0\\n        self.cells = []\\n        self.directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]"]}
{"id": "2108", "ref_py": ["def numberOfCombinations(self, num):\\n        if num[0] == \\'0\\': return 0\\n        \\n        mod, n = 10**9 + 7, len(num)\\n        same = [[0] * (n+1) for _ in range(n+1)]\\n        \\n        range_down = range(n-1, -1, -1)\\n        range_down_n = range(n, 0, -1)\\n        \\n        for i in range_down:\\n            for j in range_down:\\n                if num[i] == num[j]: same[i][j] = same[i+1][j+1] + 1\\n        \\n        dp = [[0] * (n+2) for _ in range_down]\\n        for i in range_down:\\n            for j in range_down_n:\\n                if num[i] == \\'0\\' or i+j > n: continue\\n                if i+j == n: dp[i][j] = 1\\n                if i+j+1 <= n: dp[i][j] = dp[i][j+1] % mod\\n                p = same[i][i+j]\\n                if p >= j or (i + j + p < n and num[i + p] <= num[i + j + p]):\\n                    dp[i][j] = (dp[i][j] + dp[i+j][j]) % mod\\n                elif i + 2 * j + 1 <= n:\\n                    dp[i][j] = (dp[i][j] + dp[i+j][j+1]) % mod", "def numberOfCombinations(self, num):\\n        if num[0] == \\'0\\': return 0\\n        \\n        mod, n = 10**9 + 7, len(num)\\n        same = [[0] * (n+1) for _ in range(n+1)]\\n        \\n        range_down = range(n-1, -1, -1)\\n        range_down_n = range(n, 0, -1)\\n        \\n        for i in range_down:\\n            for j in range_down:\\n                if num[i] == num[j]: same[i][j] = same[i+1][j+1] + 1\\n        \\n        dp = [[0] * (n+2) for _ in range_down]\\n        for i in range_down:\\n            for j in range_down_n:\\n                if num[i] == \\'0\\' or i+j > n: continue\\n                if i+j == n: dp[i][j] = 1\\n                if i+j+1 <= n: dp[i][j] = dp[i][j+1] % mod\\n                p = same[i][i+j]\\n                if p >= j or (i + j + p < n and num[i + p] <= num[i + j + p]):\\n                    dp[i][j] = (dp[i][j] + dp[i+j][j]) % mod\\n                elif i + 2 * j + 1 <= n:\\n                    dp[i][j] = (dp[i][j] + dp[i+j][j+1]) % mod", "def numberOfCombinations(self, num):\\n        if num[0] == \\'0\\': return 0\\n        \\n        mod, n = 10**9 + 7, len(num)\\n        same = [[0] * (n+1) for _ in range(n+1)]\\n        \\n        range_down = range(n-1, -1, -1)\\n        range_down_n = range(n, 0, -1)\\n        \\n        for i in range_down:\\n            for j in range_down:\\n                if num[i] == num[j]: same[i][j] = same[i+1][j+1] + 1\\n        \\n        dp = [[0] * (n+2) for _ in range_down]\\n        for i in range_down:\\n            for j in range_down_n:\\n                if num[i] == \\'0\\' or i+j > n: continue\\n                if i+j == n: dp[i][j] = 1\\n                if i+j+1 <= n: dp[i][j] = dp[i][j+1] % mod\\n                p = same[i][i+j]\\n                if p >= j or (i + j + p < n and num[i + p] <= num[i + j + p]):\\n                    dp[i][j] = (dp[i][j] + dp[i+j][j]) % mod\\n                elif i + 2 * j + 1 <= n:\\n                    dp[i][j] = (dp[i][j] + dp[i+j][j+1]) % mod"]}
{"id": "2109", "ref_py": ["def subfun(n,sums):\\n        if n==1:\\n            return [sum(sums),]\\n        \\n\\t\\t", "def subfun(n,sums):\\n        if n==1:\\n            return [sum(sums),]\\n        \\n\\t\\t", "def subfun(n,sums):\\n        if n==1:\\n            return [sum(sums),]\\n        \\n\\t\\t"]}
{"id": "2110", "ref_py": ["def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\\n\\t\\t\\tans = 1\\n\\t\\t\\tif \"0\" in binary:\\n\\t\\t\\t\\tans += 1\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tn = len(binary)\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i< n and binary[i] == \"0\":\\n\\t\\t\\t\\ti+= 1\\n\\t\\t\\tif i == n:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tbinary = binary[i:]\\n\\t\\t\\ttrie = [1,1]", "def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\\n        \\n        \\n        ", "def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\\n\\t\\ttotal_len = 1\\n\\t\\tif \"0\" in binary:\\n\\t\\t\\ttotal_len = 2"]}
{"id": "2111", "ref_py": ["def factor(n) -> Tuple[int, bool]:\\n    \\n    output = 0", "define mask\\nIdeas from https://leetcode.com/problems/the-number-of-good-subsets/discuss/1444338/python-dp-on-subsets-explained\\nSome little tweek to focus on only numbers present in inputs (take out 1) and only return 1 if mask > 0", "define mask\\nIdeas from https://leetcode.com/problems/the-number-of-good-subsets/discuss/1444338/python-dp-on-subsets-explained\\nSome little tweek to focus on only numbers present in inputs (take out 1) and only return 1 if mask > 0"]}
{"id": "2112", "ref_py": ["def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [[-inf] * (target + 1) for _ in range(10)]\\n        for i in range(1, 10):\\n            dp[i][0] = 0\\n            for size in range(1, target+1):\\n                if size - cost[i-1] >= 0:\\n                    dp[i][size] = max(dp[i][size-cost[i-1]] + 1, dp[i-1][size])\\n                else: dp[i][size] = dp[i-1][size]\\n        if dp[9][target] < 0: return \"0\"\\n        ans = []\\n        digit = 9\\n        while digit > 0:\\n            c = cost[digit-1]\\n            if target >= c and dp[digit][target] == dp[digit][target-c] + 1:\\n                ans.append(str(digit))\\n                target -= c\\n            else: digit -= 1\\n        return \\'\\'.join(ans)\\n```\\n", "def bigger(self, a, b):\\n        if len(a) != len(b): return len(a) > len(b)\\n        return a > b\\n    def largestNumber(self, cost, target):\\n        dp = [None] * (target + 1)\\n        dp[0] = \\'\\'\\n        for t in range(1, target + 1):\\n            for d in range(1, 10):\\n                c = cost[d-1]\\n                if t-c >= 0:\\n                    if dp[t-c] is not None:\\n                        candidate = dp[t-c] + str(d)\\n                        if dp[t] is None or self.bigger(candidate, dp[t]):\\n                            dp[t] = candidate", "def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [[-inf] * (target + 1) for _ in range(10)]\\n        for i in range(1, 10):\\n            dp[i][0] = 0\\n            for size in range(1, target+1):\\n                if size - cost[i-1] >= 0:\\n                    dp[i][size] = max(dp[i][size-cost[i-1]] + 1, dp[i-1][size])\\n                else: dp[i][size] = dp[i-1][size]\\n        if dp[9][target] < 0: return \"0\"\\n        ans = []\\n        digit = 9\\n        while digit > 0:\\n            c = cost[digit-1]\\n            if target >= c and dp[digit][target] == dp[digit][target-c] + 1:\\n                ans.append(str(digit))\\n                target -= c\\n            else: digit -= 1\\n        return \\'\\'.join(ans)\\n```\\n"]}
{"id": "2113", "ref_py": ["def __init__(self, n):\\n        self.parents = list(range(n + 1))\\n    \\n    def find(self, u):\\n        if self.parents[u] != u:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n        \\n    def union(self, u, v):\\n        p, q = self.find(u), self.find(v)\\n        if p == q: return 0\\n        self.parents[p] = q\\n        return q\\n    \\nclass Solution:\\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\\n        def dfs(tree):\\n            smallest = max({dfs(subTree) for subTree in graph[tree]} | {1})\\n            for subTree in graph[tree]:\\n                uf.union(nums[tree], nums[subTree])\\n                \\n            for i in range(smallest, n + 1):\\n                if uf.find(i) != uf.find(nums[tree]):\\n                    res[tree] = i\\n                    return i\\n            else: return i + 1\\n            \\n        n, graph = len(nums), defaultdict(list)\\n        uf, res = UF(100000), [1] * n\\n        for i, p in enumerate(parents):\\n            graph[p].append(i)", "def __init__(self, n):\\n        self.parents = list(range(n + 1))\\n    \\n    def find(self, u):\\n        if self.parents[u] != u:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n        \\n    def union(self, u, v):\\n        p, q = self.find(u), self.find(v)\\n        if p == q: return 0\\n        self.parents[p] = q\\n        return q\\n    \\nclass Solution:\\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\\n        def dfs(tree):\\n            smallest = max({dfs(subTree) for subTree in graph[tree]} | {1})\\n            for subTree in graph[tree]:\\n                uf.union(nums[tree], nums[subTree])\\n                \\n            for i in range(smallest, n + 1):\\n                if uf.find(i) != uf.find(nums[tree]):\\n                    res[tree] = i\\n                    return i\\n            else: return i + 1\\n            \\n        n, graph = len(nums), defaultdict(list)\\n        uf, res = UF(100000), [1] * n\\n        for i, p in enumerate(parents):\\n            graph[p].append(i)", "def __init__(self, n):\\n        self.parents = list(range(n + 1))\\n    \\n    def find(self, u):\\n        if self.parents[u] != u:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n        \\n    def union(self, u, v):\\n        p, q = self.find(u), self.find(v)\\n        if p == q: return 0\\n        self.parents[p] = q\\n        return q\\n    \\nclass Solution:\\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\\n        def dfs(tree):\\n            smallest = max({dfs(subTree) for subTree in graph[tree]} | {1})\\n            for subTree in graph[tree]:\\n                uf.union(nums[tree], nums[subTree])\\n                \\n            for i in range(smallest, n + 1):\\n                if uf.find(i) != uf.find(nums[tree]):\\n                    res[tree] = i\\n                    return i\\n            else: return i + 1\\n            \\n        n, graph = len(nums), defaultdict(list)\\n        uf, res = UF(100000), [1] * n\\n        for i, p in enumerate(parents):\\n            graph[p].append(i)"]}
{"id": "2114", "ref_py": ["def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = sorted(set(nums))\\n\\t\\t\\n        answer = float(\"+inf\")\\n        for i, start in enumerate(nums):\\n            \\n            search = start + n - 1  ", "def minOperations(self, nums):\\n        n = len(nums)\\n        nums.sort()  ", "def minOperations(self, nums: List[int]) -> int:\\n    j, res, n = 0, float(\\'inf\\'), len(nums)\\n    nums = sorted(set(nums))"]}
{"id": "2115", "ref_py": ["def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\\n        n=len(s)\\n        count=collections.Counter(s)\\n        candidates=[i for i in count if count[i]>=k]\\n        candidates.sort(reverse=True)\\n        def isSubseq(a,b):\\n            m,n=len(a),len(b)\\n            i,j=0,0\\n            count=0\\n            while i<m and j<n:\\n                if a[i]==b[j]:\\n                    i+=1\\n                    j+=1\\n                    count+=1\\n                else:\\n                    j+=1\\n            return True if count==m else False\\n        optimal_count=collections.Counter()\\n        for c in candidates:\\n            optimal_count[c]=count[c]//k\\n        length=1\\n        ans=\"\"\\n        q=deque()\\n        q.append((\"\",optimal_count.copy()))\\n        while q:\\n            l=len(q)\\n            for _ in range(l):\\n                s1,new_count=q.popleft()\\n                for c in candidates:\\n                    if new_count[c]>0:\\n                        s1+=c\\n                        new_count[c]-=1\\n                        if isSubseq(s1*k,s):\\n                            q.append((s1,new_count.copy()))\\n                        s1=s1[:len(s1)-1:1]\\n                        new_count[c]+=1\\n            if q: ans=q[0][0]\\n        return ans\\n                        \\n            ", "def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\\n        n=len(s)\\n        count=collections.Counter(s)\\n        candidates=[i for i in count if count[i]>=k]\\n        candidates.sort(reverse=True)\\n        def isSubseq(a,b):\\n            m,n=len(a),len(b)\\n            i,j=0,0\\n            count=0\\n            while i<m and j<n:\\n                if a[i]==b[j]:\\n                    i+=1\\n                    j+=1\\n                    count+=1\\n                else:\\n                    j+=1\\n            return True if count==m else False\\n        optimal_count=collections.Counter()\\n        for c in candidates:\\n            optimal_count[c]=count[c]//k\\n        length=1\\n        ans=\"\"\\n        q=deque()\\n        q.append((\"\",optimal_count.copy()))\\n        while q:\\n            l=len(q)\\n            for _ in range(l):\\n                s1,new_count=q.popleft()\\n                for c in candidates:\\n                    if new_count[c]>0:\\n                        s1+=c\\n                        new_count[c]-=1\\n                        if isSubseq(s1*k,s):\\n                            q.append((s1,new_count.copy()))\\n                        s1=s1[:len(s1)-1:1]\\n                        new_count[c]+=1\\n            if q: ans=q[0][0]\\n        return ans\\n                        \\n            ", "def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\\n        n=len(s)\\n        count=collections.Counter(s)\\n        candidates=[i for i in count if count[i]>=k]\\n        candidates.sort(reverse=True)\\n        def isSubseq(a,b):\\n            m,n=len(a),len(b)\\n            i,j=0,0\\n            count=0\\n            while i<m and j<n:\\n                if a[i]==b[j]:\\n                    i+=1\\n                    j+=1\\n                    count+=1\\n                else:\\n                    j+=1\\n            return True if count==m else False\\n        optimal_count=collections.Counter()\\n        for c in candidates:\\n            optimal_count[c]=count[c]//k\\n        length=1\\n        ans=\"\"\\n        q=deque()\\n        q.append((\"\",optimal_count.copy()))\\n        while q:\\n            l=len(q)\\n            for _ in range(l):\\n                s1,new_count=q.popleft()\\n                for c in candidates:\\n                    if new_count[c]>0:\\n                        s1+=c\\n                        new_count[c]-=1\\n                        if isSubseq(s1*k,s):\\n                            q.append((s1,new_count.copy()))\\n                        s1=s1[:len(s1)-1:1]\\n                        new_count[c]+=1\\n            if q: ans=q[0][0]\\n        return ans\\n                        \\n            "]}
{"id": "2116", "ref_py": ["def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        correct_ans = eval(s)\\n        standard_form = []\\n        for x in s:\\n            if x == \\'+\\':\\n                standard_form.append(0)\\n            elif x == \\'*\\':\\n                standard_form.append(1)\\n            else:\\n                standard_form.append(int(x))", "def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        ", "def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n        @functools.lru_cache\\n        def dfs_all(lo, hi):\\n            \\n            if lo == hi:\\n                return {int(s[lo])}\\n            \\n            res = set()\\n            for j in range(lo+1, hi, 2):    "]}
{"id": "2117", "ref_py": ["def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix_sums = list(accumulate(nums))\\n        total_sum = prefix_sums[-1]\\n        best = 0\\n        if total_sum % 2 == 0:\\n            best = prefix_sums[:-1].count(total_sum // 2)  ", "def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix_sums = list(accumulate(nums))\\n        total_sum = prefix_sums[-1]\\n        best = 0\\n        if total_sum % 2 == 0:\\n            best = prefix_sums[:-1].count(total_sum // 2)  ", "def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix_sums = list(accumulate(nums))\\n        total_sum = prefix_sums[-1]\\n        best = 0\\n        if total_sum % 2 == 0:\\n            best = prefix_sums[:-1].count(total_sum // 2)  "]}
{"id": "2118", "ref_py": ["def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next", "def swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```\\n", "def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next"]}
{"id": "2119", "ref_py": ["def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2 ", "def f(self,target,index,nums,dp):\\n        \\n        if target==0:\\n\\t\\t    dp[index][target]=True\\n            return dp[index][target]\\n        if index==0: \\n\\t\\t\\tdp[index][target]=nums[index]==target\\n", "def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2 "]}
{"id": "2120", "ref_py": ["def makeStringSorted(self, s: str) -> int:\\n        \\n        cnt, ans, tot, comb_tot = [0]*26, 0, 0, 1           ", "def makeStringSorted(self, s: str) -> int:\\n        \\n        cnt, ans, tot, comb_tot = [0]*26, 0, 0, 1           ", "def makeStringSorted(self, s: str) -> int:\\n        \\n        cnt, ans, tot, comb_tot = [0]*26, 0, 0, 1           "]}
{"id": "2121", "ref_py": ["def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        D = [set() for _ in range(n+1)]\\n        D[1].add(0)\\n        adj, heap = defaultdict(list), [(0, 1)]\\n        ", "def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        D = [set() for _ in range(n+1)]\\n        D[1].add(0)\\n        adj, heap = defaultdict(list), [(0, 1)]\\n        ", "def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        D = [set() for _ in range(n+1)]\\n        D[1].add(0)\\n        adj, heap = defaultdict(list), [(0, 1)]\\n        "]}
{"id": "2122", "ref_py": ["def minimumTime(self, n, relations, time):\\n        graph = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        maxTime = [0] * n", "def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = [[] for _ in range(n)]", "def __init__(self):\\n        self.adjacencyList = []  "]}
{"id": "2123", "ref_py": ["def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        board = [[set() for _ in range(8)] for _ in range(8)]\\n        n = len(pieces)\\n        for pos in positions:\\n            pos[0] -= 1\\n            pos[1] -= 1\\n        all_time = set(range(1, 8))\\n        def recur(i):\\n            if i == n:\\n                return 1\\n            ans = 0\\n            line = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n            diag = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n            r, c = positions[i]\\n            if not board[r][c] & all_time:\\n                board[r][c] |= all_time\\n                ans += recur(i + 1)\\n                board[r][c].clear()\\n            directions = []\\n            if pieces[i] in (\"queen\", \"rook\"):\\n                directions.extend(line)\\n            if pieces[i] in (\"queen\", \"bishop\"):\\n                directions.extend(diag)                \\n            for dr, dc in directions:\\n                x, y = r + dr, c + dc\\n                count = 1\\n                while 0 <= x < 8 and 0 <= y < 8 and count not in board[x][y]:\\n                    board[x][y].add(count)\\n                    count += 1\\n                    rest = set(range(count, 8))\\n                    if not board[x][y] & rest:\\n                        board[x][y] |= rest\\n                        ans += recur(i + 1)\\n                        board[x][y] -= rest\\n                    x += dr\\n                    y += dc\\n                count -= 1\\n                x -= dr\\n                y -= dc\\n                while count:\\n                    board[x][y].remove(count)\\n                    count -= 1\\n                    x -= dr\\n                    y -= dc\\n            return ans\\n        return recur(0)\\n```", "def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        \\n        moves = { \"rook\" : [ (1,0),(-1,0),(0,-1),(0,1) ],\\n                  \"bishop\" : [ (1,1),(-1,-1),(1,-1),(-1,1) ],\\n                  \"queen\" : [ (1,0),(-1,0),(0,-1),(0,1),(1,1),(-1,-1),(1,-1),(-1,1) ] }", "def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        \\n        moves = { \"rook\" : [ (1,0),(-1,0),(0,-1),(0,1) ],\\n                  \"bishop\" : [ (1,1),(-1,-1),(1,-1),(-1,1) ],\\n                  \"queen\" : [ (1,0),(-1,0),(0,-1),(0,1),(1,1),(-1,-1),(1,-1),(-1,1) ] }"]}
{"id": "2124", "ref_py": ["def getValidPrefixLength(s,start):\\n\\tend = start\\n\\twhile end < len(s) and s[end].isdigit(): end += 1\\n\\treturn end\\n```\\n2.  To get all possibles lengths that the numeric substrings \\'s\\' could represent we use the following code:-\\n```\\n@lru_cache(None)\\ndef possibleLengths(s): \\n\\t\\n\\tlengths = {int(s)}\\n\\tfor i in range(1, len(s)):\\n\\t\\t", "def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        def findHead(s):\\n            \\n            i = 0\\n            if s[0].isalpha():\\n                return s[0], s[1: ]\\n            else:\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                return s[:i], s[i:] ", "def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        repr1 = Solution.parse(s1)\\n        repr2 = Solution.parse(s2)\\n        i = j = 0\\n        \\n        @cache\\n        def dfs(i, j, diff):\\n            "]}
{"id": "2125", "ref_py": ["def maximalPathQuality(self, values, edges, maxTime):\\n        n = len(values)\\n        adj = [[] for _ in range(n)]", "def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:", "def maximalPathQuality(self, values, edges, maxTime):\\n        n = len(values)\\n        adj = [[] for _ in range(n)]"]}
{"id": "2126", "ref_py": ["def maxTaskAssign(self, tasks, workers, p, strength):\\n        n = len(tasks)\\n        m = len(workers)", "def maxTaskAssign(self, t: List[int], workers: List[int], pills: int, s: int) -> int:\\n        \\n        t.sort()\\n        workers.sort()\\n        \\n        A=t.copy()\\n        B=workers.copy()\\n        p=pills\\n        ans=0\\n        a=False\\n        b=False\\n        while(len(A)>0 and len(B)>0):\\n            ", "def maxTaskAssign(self, t: List[int], workers: List[int], pills: int, s: int) -> int:\\n        \\n        t.sort()\\n        workers.sort()\\n        \\n        A=t.copy()\\n        B=workers.copy()\\n        p=pills\\n        ans=0\\n        a=False\\n        b=False\\n        while(len(A)>0 and len(B)>0):\\n            "]}
{"id": "2127", "ref_py": ["def __init__(self, n):\\n        self.data = range(n)", "def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result", "def __init__(self, n):\\n        self.data = range(n)"]}
{"id": "2128", "ref_py": ["def kMirror(self, k: int, n: int) -> int:", "def kMirror(self, k: int, N: int) -> int:\\n        return sum(islice((n for n in mirror10() if iskm(n, k)), N)) ", "def kMirror(self, k: int, n: int) -> int:\\n        count = 0\\n        sum = 0\\n        prevPalindromes = []\\n        digits = 1\\n        while count < n:\\n            "]}
{"id": "2129", "ref_py": ["def downcount(i,j):\\n            \\n            \\n            cnt = 0 \\n            base_length = 1 \\n            while i + 1 < row and j + 1 < col and grid[i+1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i += 1\\n                j += 1\\n                base_length += 2\\n                \\n            return cnt\\n        \\n        def upcount(i,j):\\n            \\n            cnt = 0 \\n            base_length = 1 \\n            \\n            while i-1 >= 0 and j + 1 < col and grid[i-1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i -= 1 \\n                j += 1 \\n                base_length += 2 \\n                \\n            return cnt \\n        \\n        \\n        ", "def countPyramids(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t", "def downcount(i,j):\\n            \\n            \\n            cnt = 0 \\n            base_length = 1 \\n            while i + 1 < row and j + 1 < col and grid[i+1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i += 1\\n                j += 1\\n                base_length += 2\\n                \\n            return cnt\\n        \\n        def upcount(i,j):\\n            \\n            cnt = 0 \\n            base_length = 1 \\n            \\n            while i-1 >= 0 and j + 1 < col and grid[i-1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i -= 1 \\n                j += 1 \\n                base_length += 2 \\n                \\n            return cnt \\n        \\n        \\n        "]}
{"id": "2130", "ref_py": ["defaultdict(list)\\nfor x, y, t in meetings:\\n    time2meets[t].append((x, y))\\ntime2meets = sorted(time2meets.items())\\n```", "def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        meetings.sort(key=lambda x:x[2])\\n        groups = itertools.groupby(meetings,key = lambda x:x[2])\\n        \\n        sh = {0,firstPerson}\\n        for key,grp in groups:\\n            seen = set()\\n            graph = defaultdict(list)\\n            for a,b,t in grp:\\n                graph[a].append(b)\\n                graph[b].append(a)\\n                if a in sh:\\n                    seen.add(a)\\n                if b in sh:\\n                    seen.add(b)\\n            \\n            queue = deque(seen)\\n            while queue:\\n                node = queue.popleft()\\n                for neig in graph[node]:\\n                    if neig not in sh:\\n                        sh.add(neig)\\n                        queue.append(neig)\\n            \\n        return list(sh)", "defaultdict(list)\\nfor x, y, t in meetings:\\n    time2meets[t].append((x, y))\\ntime2meets = sorted(time2meets.items())\\n```"]}
{"id": "2131", "ref_py": ["defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check.", "defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check.", "defensive approach that thwarts her progress. By strategically selecting the optimal number of stones from the remaining piles, Bob effectively hinders Alice\\'s cumulative sum, ensuring that her score remains in check."]}
{"id": "2133", "ref_py": ["def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        arr = [0 for _ in range(2*k+1)]\\n        for pos, numOfFruit in fruits:\\n            if pos < startPos-k or pos > startPos+k:\\n                continue\\n            arr[pos-(startPos-k)] += numOfFruit\\n        \\n        left, right = sum(arr[:k+1]), sum(arr[k:])\\n        maxSeen = max(left, right)\\n        \\n        turn = 1                            ", "def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n\\t\\t", "def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        arr = [0 for _ in range(2*k+1)]\\n        for pos, numOfFruit in fruits:\\n            if pos < startPos-k or pos > startPos+k:\\n                continue\\n            arr[pos-(startPos-k)] += numOfFruit\\n        \\n        left, right = sum(arr[:k+1]), sum(arr[k:])\\n        maxSeen = max(left, right)\\n        \\n        turn = 1                            "]}
{"id": "2134", "ref_py": ["def kIncreasing(self, arr, k):\\n        ans = len(arr)\\n        for i in range(k):\\n            tails = []\\n            for j in range(i, len(arr), k):\\n                if tails and tails[-1] > arr[j]:\\n                    tails[bisect.bisect(tails, arr[j])] = arr[j]\\n                else:\\n                    tails.append(arr[j])\\n            ans -= len(tails)\\n        return ans\\n```", "def kIncreasing(self, arr, k):\\n        ans = len(arr)\\n        for i in range(k):\\n            tails = []\\n            for j in range(i, len(arr), k):\\n                if tails and tails[-1] > arr[j]:\\n                    tails[bisect.bisect(tails, arr[j])] = arr[j]\\n                else:\\n                    tails.append(arr[j])\\n            ans -= len(tails)\\n        return ans\\n```", "def kIncreasing(self, arr, k):\\n        ans = len(arr)\\n        for i in range(k):\\n            tails = []\\n            for j in range(i, len(arr), k):\\n                if tails and tails[-1] > arr[j]:\\n                    tails[bisect.bisect(tails, arr[j])] = arr[j]\\n                else:\\n                    tails.append(arr[j])\\n            ans -= len(tails)\\n        return ans\\n```"]}
{"id": "2135", "ref_py": ["def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans", "def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:", "def longestAlternatingSubarray(self, v, k):\\n        ans = 0\\n        for i in range(len(v)):\\n            ct = 0\\n            if (v[i] % 2 == 0) and (v[i] <= k):\\n                ct = 1\\n                for j in range(i + 1, len(v)):\\n                    if (v[j] % 2 == v[j - 1] % 2) or v[j] > k:\\n                        break\\n                    ct += 1\\n            ans = max(ans, ct)\\n        return ans"]}
{"id": "2136", "ref_py": ["def recoverArray(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    nums.sort()", "def recoverArray(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    nums.sort()", "def recoverArray(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    nums.sort()"]}
{"id": "2137", "ref_py": ["def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        for i, j in enumerate(favorite):\\n            pre[j].append(i)", "def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        for i, j in enumerate(favorite):\\n            pre[j].append(i)", "def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        for i, j in enumerate(favorite):\\n            pre[j].append(i)"]}
{"id": "2138", "ref_py": ["default ans would be True because we dont have to cover any 0\\'s\\n4. Stamp size is more than given matrix but given matrix have 0\\'s in it. We can never cover those 0\\'s because our stamp would exceed boundary of given matrix.", "def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        def get_pre_sum(matrix):\\n            rows = len(matrix)\\n            cols = len(matrix[0])\\n            pre_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\\n            for row in range(1, rows + 1):\\n                for col in range(1, cols + 1):\\n                    pre_sum[row][col] = matrix[row - 1][col - 1] + pre_sum[row][col - 1] + pre_sum[row - 1][col] - pre_sum[row - 1][col - 1]\\n            return pre_sum\\n        \\n        def query_2d_range_sum(presum, row, col, row2, col2):\\n            ", "default ans would be True because we dont have to cover any 0\\'s\\n4. Stamp size is more than given matrix but given matrix have 0\\'s in it. We can never cover those 0\\'s because our stamp would exceed boundary of given matrix."]}
{"id": "2139", "ref_py": ["def total_time(self) -> int:\\n        \\n        return self.plant_time + self.bloom_time", "def earliestFullBloom(self, plantTime, growTime):\\n        ma=0\\n        lastp=0\\n        combo=[[growTime[i],plantTime[i]] for i in range(len(growTime))]\\n        combo.sort(reverse=True)\\n        for i in range(0,len(plantTime)):\\n            lastp+=combo[i][1]\\n            ma=max(ma,lastp+combo[i][0])\\n        return ma\\n```", "def total_time(self) -> int:\\n        \\n        return self.plant_time + self.bloom_time"]}
{"id": "2140", "ref_py": ["def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        left=0\\n        right=sum(batteries)//n+1\\n        def check(time):\\n            return sum(min(time,b) for b in batteries)>=n*time", "def maxRunTime(self, n, batteries):\\n        \\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        live = batteries[-n:]\\n        for i in range(n - 1):\\n            if extra // (i + 1) > live[i + 1] - live[i]: \\n                extra -= (i + 1) * (live[i + 1] - live[i])\\n            else:\\n                return live[i] + extra // (i + 1) ", "def maxRunTime(self, n, batteries):\\n        \\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        live = batteries[-n:]\\n        for i in range(n - 1):\\n            if extra // (i + 1) > live[i + 1] - live[i]: \\n                extra -= (i + 1) * (live[i + 1] - live[i])\\n            else:\\n                return live[i] + extra // (i + 1) "]}
{"id": "2141", "ref_py": ["def numberOfWays(self, corridor: str) -> int:\\n        array = list(corridor)\\n        chairs = 0\\n        result = 1", "def numberOfWays(self, corridor: str) -> int:\\n        array = list(corridor)\\n        chairs = 0\\n        result = 1", "def numberOfWays(self, corridor: str) -> int:\\n        array = list(corridor)\\n        chairs = 0\\n        result = 1"]}
{"id": "2142", "ref_py": ["def findLHS(self, nums: List[int]) -> int:\\n        freq = Counter(nums)\\n        max_length = 0\\n        \\n        for key in freq:\\n            if key + 1 in freq:\\n                max_length = max(max_length, freq[key] + freq[key+1])\\n                \\n        return max_length", "def findLHS(self, nums: List[int]) -> int:\\n        freq = Counter(nums)\\n        max_length = 0\\n        \\n        for key in freq:\\n            if key + 1 in freq:\\n                max_length = max(max_length, freq[key] + freq[key+1])\\n                \\n        return max_length", "def findLHS(self, nums: List[int]) -> int:\\n        freq = Counter(nums)\\n        max_length = 0\\n        \\n        for key in freq:\\n            if key + 1 in freq:\\n                max_length = max(max_length, freq[key] + freq[key+1])\\n                \\n        return max_length"]}
{"id": "2143", "ref_py": ["definition `hash(s, p, m)` in the description is the hash of string `s` based on `p`.", "def subStrHash(self, s: str, power: int, mod: int, k: int, hashValue: int) -> str:\\n        val = lambda ch : ord(ch) - ord(\"a\") + 1\\n        hash, res, power_k = 0, 0, pow(power, k, mod)\\n        for i in reversed(range(len(s))):\\n            hash = (hash * power + val(s[i])) % mod\\n            if i < len(s) - k:\\n                hash = (mod + hash - power_k * val(s[i + k]) % mod) % mod\\n            res = i if hash == hashValue else res\\n        return s[res:res + k]\\n```", "definition `hash(s, p, m)` in the description is the hash of string `s` based on `p`."]}
{"id": "2144", "ref_py": ["default(x, i)`, so we can find the index of first word with bitmask `x`.\\n`f[i]` is the \"father\" of `i`, which we will use for union find.", "def __init__(self, n):\\n        self.root = list(range(n))\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)", "def __init__(self, num):\\n        self.parents = list(range(num))\\n        self.ranks = [0] * num\\n    \\n    def find_set(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find_set(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, set1, set2):\\n        if set1 == set2:\\n            return\\n        rank1, rank2 = self.ranks[set1], self.ranks[set2]\\n        if rank1 > rank2:\\n            self.parents[set2] = set1\\n        else:\\n            self.parents[set1] = set2\\n            if rank1 == rank2:\\n                self.ranks[set2] += 1"]}
{"id": "2145", "ref_py": ["def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3", "def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3", "def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3"]}
{"id": "2146", "ref_py": ["def minimumTime(self, s):\\n        left, res, n = 0, len(s), len(s)\\n        for i,c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            res = min(res, left + n - 1 - i)\\n        return res\\n```", "def minimumTime(self, s: str) -> int:\\n\\t\\t\\n\\t\\t", "def minimumTime(self, s: str) -> int:\\n\\t\\t\\n\\t\\t"]}
{"id": "2147", "ref_py": ["define bit mask.", "def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        @cache\\n        def dp(i=0, m1=0, m2=0): ", "def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        self.nums, self.n = nums, len(nums)\\n        \\n        counts = [0 for _ in range(numSlots)]\\n        \\n        return self.dfs(0, tuple(counts))"]}
{"id": "2148", "ref_py": ["def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        elemToIndexMappingInB = {}\\n        n = len(nums1)\\n        segmentTree = [0] * (n * 4 + 1)\\n        ans = 0\\n        for i in range(len(nums2)):\\n            elemToIndexMappingInB[nums2[i]] = i\\n        self.update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]])\\n        for i in range(1, n):\\n            indexInB = elemToIndexMappingInB[nums1[i]]\\n            commonElementsOnLeft = self.query(segmentTree, 1, 0, n - 1, 0, indexInB)\\n            uniqueElementsOnLeftInA = i - commonElementsOnLeft\\n            elementsAfterIndexInB = n - 1 - indexInB\\n            commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA\\n            ans += commonElementsOnLeft * commonElementsOnRight\\n            self.update(segmentTree, 1, 0, n - 1, indexInB)\\n        return ans", "def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        elemToIndexMappingInB = {}\\n        n = len(nums1)\\n        segmentTree = [0] * (n * 4 + 1)\\n        ans = 0\\n        for i in range(len(nums2)):\\n            elemToIndexMappingInB[nums2[i]] = i\\n        self.update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]])\\n        for i in range(1, n):\\n            indexInB = elemToIndexMappingInB[nums1[i]]\\n            commonElementsOnLeft = self.query(segmentTree, 1, 0, n - 1, 0, indexInB)\\n            uniqueElementsOnLeftInA = i - commonElementsOnLeft\\n            elementsAfterIndexInB = n - 1 - indexInB\\n            commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA\\n            ans += commonElementsOnLeft * commonElementsOnRight\\n            self.update(segmentTree, 1, 0, n - 1, indexInB)\\n        return ans", "def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        elemToIndexMappingInB = {}\\n        n = len(nums1)\\n        segmentTree = [0] * (n * 4 + 1)\\n        ans = 0\\n        for i in range(len(nums2)):\\n            elemToIndexMappingInB[nums2[i]] = i\\n        self.update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]])\\n        for i in range(1, n):\\n            indexInB = elemToIndexMappingInB[nums1[i]]\\n            commonElementsOnLeft = self.query(segmentTree, 1, 0, n - 1, 0, indexInB)\\n            uniqueElementsOnLeftInA = i - commonElementsOnLeft\\n            elementsAfterIndexInB = n - 1 - indexInB\\n            commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA\\n            ans += commonElementsOnLeft * commonElementsOnRight\\n            self.update(segmentTree, 1, 0, n - 1, indexInB)\\n        return ans"]}
{"id": "2149", "ref_py": ["def coutPairs(self, nums: List[int], k: int) -> int:\\n        N, output = len(nums), 0\\n        divisors = []\\n        counter = Counter()\\n        \\n        for i in range(1, k + 1):\\n            if k % i == 0:\\n                divisors.append(i)\\n```\\n**For each number, there is the smallest value to multiply that makes it divisible by \\'k\\'**\\nex:  6 should be multiplied by at least 2 to be divisible by 4\\n\\t&nbsp;&nbsp;&nbsp;&nbsp; 4 should be multiplied by at least 1 to be divisible by 4\\n\\t&nbsp;&nbsp;&nbsp;&nbsp; 3 should be multiplied by at least 4 to be divisible by 4\\n\\t\\n**Divisors collects all the posiibility of those smallest numbers**\\n > divisor = [1,2,4]\\n ", "def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = Counter() ", "def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = Counter() "]}
{"id": "2150", "ref_py": ["def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n    minimum = [] ", "def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        ", "def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n    minimum = [] "]}
{"id": "2151", "ref_py": ["defintely pass by `\"a\"` and thus always requires one more extra moves than the **3.1.**", "defintely pass by `\"a\"` and thus always requires one more extra moves than the **3.1.**", "defintely pass by `\"a\"` and thus always requires one more extra moves than the **3.1.**"]}
{"id": "2152", "ref_py": ["def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for num in nums:\\n            while res and gcd(res[-1], num) > 1:\\n                num = lcm(res[-1], num)\\n                res.pop()\\n            res.append(num)\\n        return res\\n```\\n- JavaScript (is there any built-in `gcd` or `lcm` in js?)\\n```\\nfunction gcd(a, b) {\\n    while (b > 0) {\\n        a %= b;\\n        [a, b] = [b, a];\\n    }\\n    return a;\\n}\\nfunction lcm(a, b) {\\n    return a / gcd(a, b) * b;\\n}", "def __init__(self, val=0):\\n        self.val = val\\n        self.prev = None\\n        self.next = None", "def __init__(self, val=0):\\n        self.val = val\\n        self.prev = None\\n        self.next = None"]}
{"id": "2153", "ref_py": ["def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount ", "def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount ", "def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount "]}
{"id": "2154", "ref_py": ["def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t", "def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t", "def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t"]}
{"id": "2155", "ref_py": ["def longestKSubstr(s,k):\\n", "def longestKSubstr(s,k):\\n", "def longestKSubstr(s,k):\\n"]}
{"id": "2156", "ref_py": ["def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def dp(i,K):\\n            if k==0 or i==len(piles):\\n                return 0", "def maxValueOfCoins(self, piles, k):\\n        \\n        cache ={}\\n        def dfs(i,k ):\\n            if (i,k) in cache:\\n                return cache[(i,k)]\\n            if k==0 or i == len(piles):\\n                return 0\\n            ", "def maxValueOfCoins(self, piles, k):\\n        \\n        cache ={}\\n        def dfs(i,k ):\\n            if (i,k) in cache:\\n                return cache[(i,k)]\\n            if k==0 or i == len(piles):\\n                return 0\\n            "]}
{"id": "2157", "ref_py": ["def calcZ(s):\\n    ", "def sumScores(self, s: str) -> int:\\n        n = len(s)\\n        lps = [0] * n\\n        dp = [1] * n\\n        j = 0\\n        i = 1\\n        while i < n:\\n            if s[i] == s[j]:\\n                lps[i] = j + 1", "def sumScores(self, s: str) -> int:\\n        n = len(s)\\n        lps = [0] * n\\n        dp = [1] * n\\n        j = 0\\n        i = 1\\n        while i < n:\\n            if s[i] == s[j]:\\n                lps[i] = j + 1"]}
{"id": "2159", "ref_py": ["def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        ", "def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        ", "def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        "]}
{"id": "2160", "ref_py": ["defaultdict is the same as Python\\'s usual dictionary, but if an\\n", "def __init__(self, node, score):\\n        self.node = node\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score < other.score", "defaultdict is the same as Python\\'s usual dictionary, but if an\\n"]}
{"id": "2161", "ref_py": ["defined by a parent array where parent[i] is the parent of node i. The root node is assumed to be node 0 and its parent is -1.", "def __init__(self):\\n        self.ans = 0\\n        \\n    def longestPath(self, parent, s):\\n        n = len(parent)\\n        subtrees = [[] for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            subtrees[parent[i]].append(i)\\n        \\n        self.dfs(0, -1, subtrees, s)\\n        \\n        return self.ans", "defined by a parent array where parent[i] is the parent of node i. The root node is assumed to be node 0 and its parent is -1."]}
{"id": "2162", "ref_py": ["def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\\n        sorted_arrival_times = sorted(people)\\n        flowers.sort()  ", "def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\\n        sorted_arrival_times = sorted(people)\\n        flowers.sort()  ", "def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\\n        sorted_arrival_times = sorted(people)\\n        flowers.sort()  "]}
{"id": "2163", "ref_py": ["def maximumMinutes(self, A):\\n        m, n = len(A), len(A[0])\\n        inf = 10 ** 10\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if A[i][j] == 1]\\n        A = [[inf if a < 2 else -1 for a in r] for r in A]", "def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]", "def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]"]}
{"id": "2164", "ref_py": ["def appealSum(self, s):\\n        last = {}\\n        res = 0\\n        for i,c in enumerate(s):\\n            last[c] = i + 1\\n            res += sum(last.values())\\n        return res\\n```\\n<br>\\n<br>", "def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        dp[0] = 1\\n        hashmap = {s[0]: 0}\\n        for i in range(1, n):\\n            if s[i] not in hashmap:\\n                dp[i] = dp[i - 1] + (i + 1)\\n                hashmap[s[i]] = i\\n            else:\\n                dp[i] = dp[i - 1] + (i - hashmap[s[i]])\\n                hashmap[s[i]] = i\\n        return sum(dp)\\n```", "def appealSum(self, s):\\n        last = {}\\n        res = 0\\n        for i,c in enumerate(s):\\n            last[c] = i + 1\\n            res += sum(last.values())\\n        return res\\n```\\n<br>\\n<br>"]}
{"id": "2165", "ref_py": ["def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            ", "def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1", "def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            "]}
{"id": "2166", "ref_py": ["def largestVariance(self, s: str) -> int:\\n        chars = {}\\n        for c in s:\\n            chars[c] = chars.get(c, 0) + 1", "def largestVariance(self, s):\\n        \\n        counter=[0]*26\\n        for ch in s:\\n            counter[ord(ch)-ord(\\'a\\')]+=1\\n        global_max=0\\n        for i in range(26):\\n            for j in range(26):\\n                if i==j or counter[i]==0 or counter[j]==0:\\n                    continue\\n                \\n                major= chr(ord(\\'a\\')+i)\\n                minor= chr(ord(\\'a\\')+j)\\n                majorCount=0\\n                minorCount=0", "def largestVariance(self, s: str) -> int:\\n        freq = Counter(s)\\n        res = 0\\n        for a in freq.keys():\\n            for b in freq.keys():\\n                if a == b:\\n                    continue\\n                left_a = freq[a]\\n                left_b = freq[b]\\n                running_sum = 0\\n                has_a = has_b = False\\n                for c in s:\\n                    if c != a and c != b:\\n                        continue\\n                    if c == a:\\n                        running_sum += 1 "]}
{"id": "2168", "ref_py": ["def totalStrength(self, A):\\n        mod = 10 ** 9 + 7\\n        n = len(A)\\n        \\n        ", "def totalStrength(self, stp: List[int]) -> int:\\n          st = []\\n          n = len(stp)\\n          m1 = defaultdict(lambda:-1)\\n          ps = [0]\\n          for i in range(n):\\n              while st and stp[st[-1]] >= stp[i]:\\n                  st.pop()\\n              if st: m1[i] = st[-1]\\n              st.append(i)\\n              ps.append(ps[-1] + stp[i])\\n          pss = [0]\\n          for i in ps:\\n              pss.append(pss[-1] + i)\\n          st = []\\n          m2 = defaultdict(lambda:n)\\n          for i in range(n-1,-1,-1):\\n              while st and stp[st[-1]] > stp[i]:\\n                  st.pop()\\n              if st: m2[i] = st[-1]\\n              st.append(i)", "def totalStrength(self, stp: List[int]) -> int:\\n          st = []\\n          n = len(stp)\\n          m1 = defaultdict(lambda:-1)\\n          ps = [0]\\n          for i in range(n):\\n              while st and stp[st[-1]] >= stp[i]:\\n                  st.pop()\\n              if st: m1[i] = st[-1]\\n              st.append(i)\\n              ps.append(ps[-1] + stp[i])\\n          pss = [0]\\n          for i in ps:\\n              pss.append(pss[-1] + i)\\n          st = []\\n          m2 = defaultdict(lambda:n)\\n          for i in range(n-1,-1,-1):\\n              while st and stp[st[-1]] > stp[i]:\\n                  st.pop()\\n              if st: m2[i] = st[-1]\\n              st.append(i)"]}
{"id": "2170", "ref_py": ["def minimumObstacles(self, grid):\\n        \\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t", "def minimumObstacles(self, grid):\\n        \\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t", "def minimumObstacles(self, grid):\\n        \\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t"]}
{"id": "2172", "ref_py": ["def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\\n        regexp = []\\n        m = defaultdict(lambda: set())\\n        for f, t in mappings:\\n            m[f].add(t)\\n        def search(i, j):\\n            len_s = len(s)\\n            len_sub = len(sub)\\n            while j < len(sub):\\n                lenlefts = len_s - i\\n                lenleftsub = len_sub - j\\n                if lenlefts < lenleftsub:\\n                    return False\\n                elif (s[i] == sub[j]) or (s[i] in m[sub[j]]):\\n                    i+=1\\n                    j+=1\\n                    continue\\n                else:\\n                    return False\\n            return True\\n        for i in range(len(s)):\\n            if search(i, 0):\\n                return True\\n        return False\\n```", "def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\\n        s_maps = defaultdict(lambda : set())\\n        for x,y in mappings:\\n            s_maps[x].add(y)\\n                \\n        ", "def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\\n        regexp = []\\n        m = defaultdict(lambda: set())\\n        for f, t in mappings:\\n            m[f].add(t)\\n        def search(i, j):\\n            len_s = len(s)\\n            len_sub = len(sub)\\n            while j < len(sub):\\n                lenlefts = len_s - i\\n                lenleftsub = len_sub - j\\n                if lenlefts < lenleftsub:\\n                    return False\\n                elif (s[i] == sub[j]) or (s[i] in m[sub[j]]):\\n                    i+=1\\n                    j+=1\\n                    continue\\n                else:\\n                    return False\\n            return True\\n        for i in range(len(s)):\\n            if search(i, 0):\\n                return True\\n        return False\\n```"]}
{"id": "2173", "ref_py": ["def countSubarrays(self, A, k):\\n        res = cur = i = 0\\n        for j in range(len(A)):\\n            cur += A[j]\\n            while cur * (j - i + 1) >= k:\\n                cur -= A[i]\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```\\n<br>", "def countSubarrays(self, A, k):\\n        res = cur = i = 0\\n        for j in range(len(A)):\\n            cur += A[j]\\n            while cur * (j - i + 1) >= k:\\n                cur -= A[i]\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```\\n<br>", "def countSubarrays(self, A, k):\\n        res = cur = i = 0\\n        for j in range(len(A)):\\n            cur += A[j]\\n            while cur * (j - i + 1) >= k:\\n                cur -= A[i]\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```\\n<br>"]}
{"id": "2174", "ref_py": ["def distinctNames(self, ideas: List[str]) -> int:\\n        hashmap = defaultdict(set)\\n        for name in set(ideas):\\n            hashmap[name[0]].add(name[1:])\\n        ans=0\\n        for index_1 , (pre_a,suf_a) in enumerate(hashmap.items()):\\n            for index_2 , (pre_b,suf_b) in enumerate(hashmap.items()):        ", "def distinctNames(self, ideas: List[str]) -> int:\\n        \\n        nameMap = collections.defaultdict(set)\\n        result = 0", "def distinctNames(self, ideas: List[str]) -> int:\\n        \\n        nameMap = collections.defaultdict(set)\\n        result = 0"]}
{"id": "2175", "ref_py": ["def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```", "def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```", "def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```"]}
{"id": "2176", "ref_py": ["def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        def gcd(x, y):\\n            return x if y == 0 else gcd(y, x % y)\\n        \\n        dp = [[[0] * 6 for _ in range(6)] for _ in range(n+1)]\\n        dp[2] = [[int(i != j and gcd(i+1, j+1) == 1) for j in range(6)] for i in range(6)]\\n        for i in range(3, n+1):\\n            for x in range(6):\\n                for y in range(6):\\n                    if x != y and gcd(x+1, y+1) == 1:\\n                        dp[i][x][y] = sum(dp[i-1][y][z] for z in range(6) if z != x) % mod\\n        return sum(sum(row) for row in dp[n]) % mod\\n```", "def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        def gcd(x, y):\\n            return x if y == 0 else gcd(y, x % y)\\n        \\n        dp = [[[0] * 6 for _ in range(6)] for _ in range(n+1)]\\n        dp[2] = [[int(i != j and gcd(i+1, j+1) == 1) for j in range(6)] for i in range(6)]\\n        for i in range(3, n+1):\\n            for x in range(6):\\n                for y in range(6):\\n                    if x != y and gcd(x+1, y+1) == 1:\\n                        dp[i][x][y] = sum(dp[i-1][y][z] for z in range(6) if z != x) % mod\\n        return sum(sum(row) for row in dp[n]) % mod\\n```", "def distinctSequences(self, n: int) -> int:\\n        if n == 1: return 6\\n        def gcd(x, y):\\n            return x if y == 0 else gcd(y, x % y)\\n        \\n        dp = [[[0] * 6 for _ in range(6)] for _ in range(n+1)]\\n        dp[2] = [[int(i != j and gcd(i+1, j+1) == 1) for j in range(6)] for i in range(6)]\\n        for i in range(3, n+1):\\n            for x in range(6):\\n                for y in range(6):\\n                    if x != y and gcd(x+1, y+1) == 1:\\n                        dp[i][x][y] = sum(dp[i-1][y][z] for z in range(6) if z != x) % mod\\n        return sum(sum(row) for row in dp[n]) % mod\\n```"]}
{"id": "2177", "ref_py": ["def maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:", "define num3, ```num3[i] = num2[i]-num1[i], 0<=i<n```\\nand num4, ```num4[i] = num1[i]-num2[i], 0<=i<n```\\nwhat we need to find is the max subarray of num3, num4, which is an old question\\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem ", "define num3, ```num3[i] = num2[i]-num1[i], 0<=i<n```\\nand num4, ```num4[i] = num1[i]-num2[i], 0<=i<n```\\nwhat we need to find is the max subarray of num3, num4, which is an old question\\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem "]}
{"id": "2178", "ref_py": ["def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        visited = [False for _ in range(n)]\\n        pc = [] ", "defaultdict\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        s = reduce(lambda x,y:x^y, nums)\\n        adj = defaultdict(list)\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        self.res = float(\\'inf\\')\\n        \\n        def calc_res(a,b,c):\\n            return max(a,b,c) - min(a,b,c)\\n        \\n        def dfs(root,parent,others):\\n            subtrees = set()\\n            cur = nums[root]\\n            for i in adj[root]:\\n                if i!=parent:\\n                    v, children = dfs(i,root,others|subtrees)\\n                    subtrees |= children\\n                    cur ^= v\\n\\t\\t\\t\\n            for other in others:\\n                self.res = min(self.res,calc_res(cur,i,s^cur^other))\\n            if parent!=-1:\\n                for child in subtrees:\\n                    self.res = min(self.res,calc_res(cur^child,s^cur,child))\\n            subtrees.add(cur)\\n            return cur,subtrees\\n        \\n        dfs(0,-1,set())\\n        \\n        return self.res\\n```", "defaultdict\\nclass Solution:\\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\\n        s = reduce(lambda x,y:x^y, nums)\\n        adj = defaultdict(list)\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        self.res = float(\\'inf\\')\\n        \\n        def calc_res(a,b,c):\\n            return max(a,b,c) - min(a,b,c)\\n        \\n        def dfs(root,parent,others):\\n            subtrees = set()\\n            cur = nums[root]\\n            for i in adj[root]:\\n                if i!=parent:\\n                    v, children = dfs(i,root,others|subtrees)\\n                    subtrees |= children\\n                    cur ^= v\\n\\t\\t\\t\\n            for other in others:\\n                self.res = min(self.res,calc_res(cur,i,s^cur^other))\\n            if parent!=-1:\\n                for child in subtrees:\\n                    self.res = min(self.res,calc_res(cur^child,s^cur,child))\\n            subtrees.add(cur)\\n            return cur,subtrees\\n        \\n        dfs(0,-1,set())\\n        \\n        return self.res\\n```"]}
{"id": "2179", "ref_py": ["def countPaths(self, grid: List[List[int]]) -> int:\\n        mod = 10**9+7       \\n        n = len(grid)        \\n        m = len(grid[0])       \\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\\n        \\n        def solve(row,col,grid,prev,dp):\\n          \\n            if row < 0 or col<0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            directions=[[1,0],[-1,0],[0,-1],[0,1]]            \\n            total=1\\n            for dir in directions:\\n                new_row=row+dir[0]\\n                new_col=col+dir[1]\\n                total += solve(new_row,new_col,grid,grid[row][col],dp)\\n            dp[row][col] = total\\n            return total\\n      \\n        res=0\\n        for row in range(n):\\n            for col in range(m):\\n                res += solve(row,col,grid,-1,dp)\\n        return res % mod", "def countPaths(self, g: List[List[int]]) -> int:\\n        e=enumerate;return sum(map(f:=cache(lambda z:1+sum(f(t)for k in range(4)if g[z]>\\\\\\n", "def countPaths(self, grid: list[list[int]]) -> int:\\n        M = 1_000_000_007\\n        m, n = len(grid), len(grid[0])\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))"]}
{"id": "2180", "ref_py": ["def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```", "def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```", "def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```"]}
{"id": "2181", "ref_py": ["def primesUpTo(self, n):\\n        primes = set(range(2, n + 1))\\n        for i in range(2, n):\\n            if i in primes:\\n                it = i * 2\\n                while it <= n:\\n                    if it in primes:\\n                        primes.remove(it)\\n                    it += i", "def idealArrays(self, n: int, mx: int) -> int:\\n        \\n        @lru_cache(None)\\n        def gen(k):            \\n            return math.comb(n-1, k-1)\\n        \\n        q = deque([[i, 1] for i in range(1, mx+1)])\\n        res = 0\\n        \\n        while q:\\n            cur, l = q.popleft()\\n            res += gen(l)\\n            nxt = cur * 2\\n            if l == n or nxt > mx:\\n                continue\\n            while nxt <= mx:\\n                q.append([nxt, l+1])\\n                nxt += cur\\n                \\n        return res % (10**9 + 7)\\n\\t\\t\\n```", "def idealArrays(self, n: int, mx: int) -> int:\\n        \\n        @lru_cache(None)\\n        def gen(k):            \\n            return math.comb(n-1, k-1)\\n        \\n        q = deque([[i, 1] for i in range(1, mx+1)])\\n        res = 0\\n        \\n        while q:\\n            cur, l = q.popleft()\\n            res += gen(l)\\n            nxt = cur * 2\\n            if l == n or nxt > mx:\\n                continue\\n            while nxt <= mx:\\n                q.append([nxt, l+1])\\n                nxt += cur\\n                \\n        return res % (10**9 + 7)\\n\\t\\t\\n```"]}
{"id": "2182", "ref_py": ["def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        for i,a in enumerate(sorted(A)):\\n            if g % a == 0: return i\\n            if a > g: break\\n        return -1\\n```\\nCompressed version\\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        return next((i for i,a in enumerate(sorted(A)) if g % a == 0), -1)\\n```\\n<br>", "def minOperations(self, nums: List[int], divs: List[int]) -> int:\\n        div = reduce(gcd, divs)\\n        return next((i for i, n in enumerate(sorted(nums)) if div % n == 0), -1)\\n```", "def minOperations(self, nums: List[int], divs: List[int]) -> int:\\n        div = reduce(gcd, divs)\\n        return next((i for i, n in enumerate(sorted(nums)) if div % n == 0), -1)\\n```"]}
{"id": "2183", "ref_py": ["def numUniqueEmails(self, emails: List[str]) -> int:\\n        \\n        res = set()\\n        for email in emails:\\n            local,domain = email.split(\\'@\\')\\n            tmp = \"\"\\n            for c in local:\\n                if c==\".\": continue\\n                elif c==\"+\": break\\n                else: tmp+=c\\n            res.add(tmp+\"@\"+domain)\\n        \\n        return len(res)", "def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                ", "def numUniqueEmails(self, emails: List[str]) -> int:\\n        m=set()\\n        for i in emails:\\n            if i.count(\".\")>0 and i.count(\"@\")>0:\\n                a,b=map(str,i.split(\"@\"))\\n                a=a.replace(\".\",\"\")\\n                "]}
{"id": "2184", "ref_py": ["def countExcellentPairs(self, A: List[int], k: int) -> int:\\n        c = Counter(map(int.bit_count, set(A)))\\n        return sum(c[k1] * c[k2] for k1 in c for k2 in c if k1 + k2 >= k)\\n```", "define a couple functions which will be helpful in this discussion:\\n* **bits(n) = {the set of all \\'1\\' bits in the binary representation of n}**\\n* **f(m, n) = |bits(m | n)| + |bits(m & n)|**\\nwhere |A| is the number of elements in the set A, | is bitwise OR, and & is bitwise AND\\n(also note that a pair (m, n) is excellent if f(m, n) >= k)", "define a couple functions which will be helpful in this discussion:\\n* **bits(n) = {the set of all \\'1\\' bits in the binary representation of n}**\\n* **f(m, n) = |bits(m | n)| + |bits(m & n)|**\\nwhere |A| is the number of elements in the set A, | is bitwise OR, and & is bitwise AND\\n(also note that a pair (m, n) is excellent if f(m, n) >= k)"]}
{"id": "2185", "ref_py": ["def longestCycle(self, edges):\\n        cycleLength = [-1] * len(edges)  ", "def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        visit=set()\\n        ranks=[float(\\'inf\\')]*n", "def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indeg = Counter(edges)"]}
{"id": "2186", "ref_py": ["def minimumReplacement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ops = 0", "def minimumReplacement(self, nums: List[int]) -> int:\\n        n = len(nums)  ", "def minimumReplacement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ops = 0"]}
{"id": "2187", "ref_py": ["def reverse(self, x: int) -> int:\\n        MAX_INT = 2 ** 31 - 1 ", "def reverse(self, x):\\n        reverse = 0\\n        sign = -1 if x < 0 else 1\\n        x = abs(x)\\n        while x:\\n            digit = x % 10\\n            reverse = reverse * 10 + digit\\n            x /= 10\\n        result = sign * reverse\\n        if result > 2 ** 31 - 1 or result < -(2 ** 31):\\n            return 0\\n        return result", "def reverse(self, x: int) -> int:\\n        MAX_INT = 2 ** 31 - 1 "]}
{"id": "2188", "ref_py": ["def maximumSegmentSum(self, nums, removeQueries):\\n        \\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n", "def maximumSegmentSum(self, nums, removeQueries):\\n        \\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n", "def maximumSegmentSum(self, nums, removeQueries):\\n        \\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n"]}
{"id": "2189", "ref_py": ["def kSum(self, nums: List[int], k: int) -> int:\\n        maxSum = sum([max(0, num) for num in nums])\\n        absNums = sorted([abs(num) for num in nums])\\n        maxHeap = [(-maxSum + absNums[0], 0)]\\n        ans = [maxSum]\\n        while len(ans) < k:\\n            nextSum, i = heapq.heappop(maxHeap)\\n            heapq.heappush(ans, -nextSum)\\n            if i + 1 < len(absNums):\\n                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))\\n                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))\\n        return ans[0]\\n```", "def kSum(self, nums: List[int], k: int) -> int:\\n        maxSum = sum([max(0, num) for num in nums])\\n        absNums = sorted([abs(num) for num in nums])\\n        maxHeap = [(-maxSum + absNums[0], 0)]\\n        ans = [maxSum]\\n        while len(ans) < k:\\n            nextSum, i = heapq.heappop(maxHeap)\\n            heapq.heappush(ans, -nextSum)\\n            if i + 1 < len(absNums):\\n                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))\\n                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))\\n        return ans[0]\\n```", "def kSum(self, nums: List[int], k: int) -> int:\\n        maxSum = sum([max(0, num) for num in nums])\\n        absNums = sorted([abs(num) for num in nums])\\n        maxHeap = [(-maxSum + absNums[0], 0)]\\n        ans = [maxSum]\\n        while len(ans) < k:\\n            nextSum, i = heapq.heappop(maxHeap)\\n            heapq.heappush(ans, -nextSum)\\n            if i + 1 < len(absNums):\\n                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))\\n                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))\\n        return ans[0]\\n```"]}
{"id": "2190", "ref_py": ["def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        try:\\n            row_conditions_topsort, row_node_to_index = self.top_sort(k, rowConditions)\\n            col_conditions_topsort, col_node_to_index = self.top_sort(k, colConditions)\\n            matrix = [[0 for _ in range(k)] for _ in range(k)]\\n            \\n            for n in range(1, k + 1):\\n                row, col = row_node_to_index[n], col_node_to_index[n]\\n                matrix[row][col] = n\\n            \\n            return matrix\\n            \\n            \\n        except:\\n            ", "def buildMatrix(self, kk: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\tres = [[0]*kk for i in range(kk)]\\n\\t\\t\\t\\tdef f(a):\\n\\t\\t\\t\\t\\tpreq = {i+1:set() for i in range(kk)}\\n\\t\\t\\t\\t\\tgraph = collections.defaultdict(set)\\n\\t\\t\\t\\t\\tfor i,j in a:\\n\\t\\t\\t\\t\\t\\tpreq[i].add(j)\\n\\t\\t\\t\\t\\t\\tgraph[j].add(i)", "def buildMatrix(self, kk: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\tres = [[0]*kk for i in range(kk)]\\n\\t\\t\\t\\tdef f(a):\\n\\t\\t\\t\\t\\tpreq = {i+1:set() for i in range(kk)}\\n\\t\\t\\t\\t\\tgraph = collections.defaultdict(set)\\n\\t\\t\\t\\t\\tfor i,j in a:\\n\\t\\t\\t\\t\\t\\tpreq[i].add(j)\\n\\t\\t\\t\\t\\t\\tgraph[j].add(i)"]}
{"id": "2191", "ref_py": ["def maximumRobots(self, times: List[int], costs: List[int], budget: int) -> int:\\n        cur = i = 0\\n        n = len(times)\\n        s = SortedList()\\n        for j in range(n):\\n            cur += costs[j]\\n            s.add(times[j])\\n            if s[-1] + (j - i + 1) * cur > budget:\\n                s.remove(times[i])\\n                cur -= costs[i]\\n                i += 1\\n        return n - i\\n```", "def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\\n        maxQ = deque()\\n        maxCons = current = p1 = 0\\n        getBudget = lambda: chargeTimes[maxQ[0]]  + ((p2 - p1 + 1) * current) if(maxQ) else 0\\n        \\n        for p2, (charge, running) in enumerate(zip(chargeTimes, runningCosts)):\\n            current += running\\n            while(maxQ and chargeTimes[maxQ[-1]] < charge):\\n                maxQ.pop()\\n            maxQ.append(p2)\\n            \\n            while(getBudget() > budget):\\n                current -= runningCosts[p1]\\n                p1 += 1\\n                while(maxQ and maxQ[0] < p1):\\n                    maxQ.popleft()\\n            \\n            maxCons = max(maxCons, p2 - p1 + 1)\\n        return maxCons\\n                \\n            \\n```", "def maximumRobots(self, times: List[int], costs: List[int], budget: int) -> int:\\n        cur = i = 0\\n        n = len(times)\\n        s = SortedList()\\n        for j in range(n):\\n            cur += costs[j]\\n            s.add(times[j])\\n            if s[-1] + (j - i + 1) * cur > budget:\\n                s.remove(times[i])\\n                cur -= costs[i]\\n                i += 1\\n        return n - i\\n```"]}
{"id": "2192", "ref_py": ["def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        logs.sort(key = lambda x: x[1])\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort(key = lambda x: x[0])\\n        d = [float(\\'-inf\\')] * (n + 1)\\n        ans = [0] * len(queries)\\n        lo, hi = 0, 0\\n        occupied_servers = set()\\n        for q, i in queries:\\n            while hi < len(logs) and logs[hi][1] <= q:\\n                d[logs[hi][0]] = logs[hi][1]\\n                occupied_servers.add(logs[hi][0])\\n                hi += 1\\n            while lo < len(logs) and logs[lo][1] < q - x:\\n                if d[logs[lo][0]] == logs[lo][1]:\\n                    occupied_servers.remove(logs[lo][0])\\n                lo += 1\\n            ans[i] = n - len(occupied_servers)\\n        return ans\\n```", "def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        logs.sort(key = lambda x: x[1])\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort(key = lambda x: x[0])\\n        d = [float(\\'-inf\\')] * (n + 1)\\n        ans = [0] * len(queries)\\n        lo, hi = 0, 0\\n        occupied_servers = set()\\n        for q, i in queries:\\n            while hi < len(logs) and logs[hi][1] <= q:\\n                d[logs[hi][0]] = logs[hi][1]\\n                occupied_servers.add(logs[hi][0])\\n                hi += 1\\n            while lo < len(logs) and logs[lo][1] < q - x:\\n                if d[logs[lo][0]] == logs[lo][1]:\\n                    occupied_servers.remove(logs[lo][0])\\n                lo += 1\\n            ans[i] = n - len(occupied_servers)\\n        return ans\\n```", "def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        logs.sort(key = lambda x: x[1])\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort(key = lambda x: x[0])\\n        d = [float(\\'-inf\\')] * (n + 1)\\n        ans = [0] * len(queries)\\n        lo, hi = 0, 0\\n        occupied_servers = set()\\n        for q, i in queries:\\n            while hi < len(logs) and logs[hi][1] <= q:\\n                d[logs[hi][0]] = logs[hi][1]\\n                occupied_servers.add(logs[hi][0])\\n                hi += 1\\n            while lo < len(logs) and logs[lo][1] < q - x:\\n                if d[logs[lo][0]] == logs[lo][1]:\\n                    occupied_servers.remove(logs[lo][0])\\n                lo += 1\\n            ans[i] = n - len(occupied_servers)\\n        return ans\\n```"]}
{"id": "2193", "ref_py": ["def __init__(self, n):\\n        ", "def __init__(self, A: list[int]):\\n        n = len(A)\\n        closest_2_power = math.ceil(math.log2(n))\\n        ", "def __init__(self, n, fn):\\n        self.n = n\\n        self.fn = fn\\n        self.tree = [0] * (2 * n)\\n       \\n    def query(self, l, r):\\n        l += self.n\\n        r += self.n\\n        res = 0\\n        while l < r:\\n            if l & 1:\\n                res = self.fn(res, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                res = self.fn(res, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return res\\n    \\n    def update(self, i, val):\\n        i += self.n\\n        self.tree[i] = val\\n        while i > 1:\\n            i >>= 1\\n            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])\\nclass Solution:\\n    "]}
{"id": "2194", "ref_py": ["def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n        \\n        def compare(x, y):            ", "def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n        \\n        def compare(x, y):            ", "def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n        \\n        def compare(x, y):            "]}
{"id": "2195", "ref_py": ["def sumPrefixScores(self, words: List[str]) -> List[int]:", "def sumPrefixScores(self, words: List[str]) -> List[int]:", "def sumPrefixScores(self, words: List[str]) -> List[int]:"]}
{"id": "2196", "ref_py": ["def numberOfGoodPaths(self, value: List[int], edges: List[List[int]]) -> int:\\n        if not edges and value:\\n            return len(value)\\n        ", "def numberOfGoodPaths(self, value: List[int], edges: List[List[int]]) -> int:\\n        if not edges and value:\\n            return len(value)\\n        ", "def numberOfGoodPaths(self, value: List[int], edges: List[List[int]]) -> int:\\n        if not edges and value:\\n            return len(value)\\n        "]}
{"id": "2197", "ref_py": ["def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t", "def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t", "def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t"]}
{"id": "2198", "ref_py": ["def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if n == 1: return 1\\n", "def deleteString(self, s: str) -> int:\\n        \\n        def max_dels(i_s, memo_max_dels):\\n            if i_s > len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            \\n            dels_max = 1\\n            ", "def deleteString(self, s: str) -> int:\\n        \\n        def max_dels(i_s, memo_max_dels):\\n            if i_s > len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            \\n            dels_max = 1\\n            "]}
{"id": "2199", "ref_py": ["def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def dfs(i, j):    \\n            if (i, j) in memo: return memo[(i, j)]\\n            currVal = grid[i][j]\\n            res = [0 for _ in range(k)]\\n            for di, dj in [(0, 1), (1, 0)]:\\n                ni, nj = i+di, j+dj\\n                if ni < m and nj < n:\\n                    cnts = dfs(ni, nj)\\n                    for l, cnt in enumerate(cnts):\\n                        if cnt == 0: continue\\n                        res[(l + currVal) % k] += cnt % (10 ** 9 + 7)\\n            \\n            memo[(i, j)] = res\\n            return res", "def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\tm = len(grid)\\n\\tn = len(grid[0])\\n\\tdp = []\\n\\t\\n\\tdef transfer(dct1,dct2,num):\\n\\t\\tnewDct = {}\\n\\t\\tfor key in dct1:\\n\\t\\t\\tnewDct[(key+num)%k] = dct1[key]\\n\\t\\tif dct2:\\n\\t\\t\\tfor key in dct2:\\n\\t\\t\\t\\tif (key+num)%k in newDct:\\n\\t\\t\\t\\t\\tnewDct[(key+num)%k] += dct2[key]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnewDct[(key+num)%k] = dct2[key]\\n\\t\\treturn newDct\\n\\t\\t\\n\\tfor i in range(m):\\n\\t\\tdp.append([])\\n\\t\\tif i == 0:\\n\\t\\t\\tdp[0].append({grid[0][0]%k:1})\\n\\t\\tfor j in range(i==0,n):\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i][j-1],None,grid[i][j]))\\n\\t\\t\\telif j == 0:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i-1][j],None,grid[i][j]))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i-1][j],dp[i][j-1],grid[i][j])) \\n\\tif 0 not in dp[-1][-1]:\\n\\t\\treturn 0\\n", "def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def dfs(i, j):    \\n            if (i, j) in memo: return memo[(i, j)]\\n            currVal = grid[i][j]\\n            res = [0 for _ in range(k)]\\n            for di, dj in [(0, 1), (1, 0)]:\\n                ni, nj = i+di, j+dj\\n                if ni < m and nj < n:\\n                    cnts = dfs(ni, nj)\\n                    for l, cnt in enumerate(cnts):\\n                        if cnt == 0: continue\\n                        res[(l + currVal) % k] += cnt % (10 ** 9 + 7)\\n            \\n            memo[(i, j)] = res\\n            return res"]}
{"id": "2200", "ref_py": ["def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:", "def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:", "def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:"]}
{"id": "2201", "ref_py": ["def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = last = 0\\n        min_index = max_index = -1\\n        for i, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                last = i + 1\\n                min_index = max_index = -1\\n                continue\\n            if num == minK:\\n                min_index = i\\n            if num == maxK:\\n                max_index = i\\n            if min_index != -1 and max_index != -1:\\n                count += min(max_index, min_index) - last + 1\\n        return count\\n```", "def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = last = 0\\n        min_index = max_index = -1\\n        for i, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                last = i + 1\\n                min_index = max_index = -1\\n                continue\\n            if num == minK:\\n                min_index = i\\n            if num == maxK:\\n                max_index = i\\n            if min_index != -1 and max_index != -1:\\n                count += min(max_index, min_index) - last + 1\\n        return count\\n```", "def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\\n        count = last = 0\\n        min_index = max_index = -1\\n        for i, num in enumerate(nums):\\n            if num < minK or num > maxK:\\n                last = i + 1\\n                min_index = max_index = -1\\n                continue\\n            if num == minK:\\n                min_index = i\\n            if num == maxK:\\n                max_index = i\\n            if min_index != -1 and max_index != -1:\\n                count += min(max_index, min_index) - last + 1\\n        return count\\n```"]}
{"id": "2202", "ref_py": ["def minCost(self, nums, cost):\\n        n = len(nums)\\n        v = []\\n        totalCost = 0", "def minCost(self, nums, cost):\\n        n = len(nums)\\n        v = []\\n        totalCost = 0", "def minCost(self, nums, cost):\\n        n = len(nums)\\n        v = []\\n        totalCost = 0"]}
{"id": "2203", "ref_py": ["def __init__(self, n: int):\\n    self.sums = [0] * (n + 1)", "def countSmaller(self, nums):\\n        def sort(enum):\\n            half = len(enum) / 2\\n            if half:\\n                left, right = sort(enum[:half]), sort(enum[half:])\\n                for i in range(len(enum))[::-1]:\\n                    if not right or left and left[-1][1] > right[-1][1]:\\n                        smaller[left[-1][0]] += len(right)\\n                        enum[i] = left.pop()\\n                    else:\\n                        enum[i] = right.pop()\\n            return enum\\n        smaller = [0] * len(nums)\\n        sort(list(enumerate(nums)))\\n        return smaller", "def __init__(self, n: int):\\n    self.sums = [0] * (n + 1)"]}
{"id": "2204", "ref_py": ["def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        res, s1, s2 = [-1] * len(A), [], []\\n        for i,a in enumerate(A):\\n            while s2 and A[s2[-1]] < a:\\n                res[s2.pop()] = a;\\n            tmp = []\\n            while s1 and A[s1[-1]] < a:\\n                tmp.append(s1.pop())\\n            s2 += tmp[::-1]\\n            s1.append(i)\\n        return res\\n```", "def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    ans = [-1] * len(nums)\\n    ", "def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        res, s1, s2 = [-1] * len(A), [], []\\n        for i,a in enumerate(A):\\n            while s2 and A[s2[-1]] < a:\\n                res[s2.pop()] = a;\\n            tmp = []\\n            while s1 and A[s1[-1]] < a:\\n                tmp.append(s1.pop())\\n            s2 += tmp[::-1]\\n            s1.append(i)\\n        return res\\n```"]}
{"id": "2205", "ref_py": ["def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n", "def __init__(self, val=0, left=None, right=None):\\n"]}
{"id": "2206", "ref_py": ["def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        R, F = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        \\n        ", "def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        R, F = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        \\n        ", "def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\\n        R, F = len(robot), len(factory)\\n        robot.sort()\\n        factory.sort()\\n        \\n        "]}
{"id": "2207", "ref_py": ["def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```", "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```", "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```"]}
{"id": "2208", "ref_py": ["def maxPalindromes(self, s, k):\\n        \\n        def isp(s):\\n            return s == s[::-1]", "def maxPalindromes(self, s, k):\\n        \\n        def isp(s):\\n            return s == s[::-1]", "def maxPalindromes(self, s, k):\\n        \\n        def isp(s):\\n            return s == s[::-1]"]}
{"id": "2209", "ref_py": ["def is_prime(x: str): return x in \\'2357\\'; \\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        if k * minLength > n or is_prime(s[0]) == False or is_prime(s[-1]) == True: return 0\\n        dp = [[0] * (n+1) for _ in range(k+1)]\\n        dp[0][0] = 1\\n        def can_partition(x:int) -> bool:\\n            return x == 0 or x == n or is_prime(s[x-1]) == False and is_prime(s[x]) == True\\n        for i in range(1, k+1):\\n            total = 0 ", "def is_prime(x: str): return x in \\'2357\\'; \\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        if k * minLength > n or is_prime(s[0]) == False or is_prime(s[-1]) == True: return 0\\n        dp = [[0] * (n+1) for _ in range(k+1)]\\n        dp[0][0] = 1\\n        def can_partition(x:int) -> bool:\\n            return x == 0 or x == n or is_prime(s[x-1]) == False and is_prime(s[x]) == True\\n        for i in range(1, k+1):\\n            total = 0 ", "def is_prime(x: str): return x in \\'2357\\'; \\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        if k * minLength > n or is_prime(s[0]) == False or is_prime(s[-1]) == True: return 0\\n        dp = [[0] * (n+1) for _ in range(k+1)]\\n        dp[0][0] = 1\\n        def can_partition(x:int) -> bool:\\n            return x == 0 or x == n or is_prime(s[x-1]) == False and is_prime(s[x]) == True\\n        for i in range(1, k+1):\\n            total = 0 "]}
{"id": "2210", "ref_py": ["def countPalindromes(self, s: str) -> int:\\n        \\n        MOD = 1_000_000_007\\n        n = len(s)\\n        pref = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        suff = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        \\n        count = [0] * 10\\n        for i in range(n):\\n            ch_idx = int(s[i])\\n            if i > 0:\\n                for x in range(10):\\n                    for y in range(10):\\n                        pref[i][x][y] = pref[i - 1][x][y]\\n                        if y == ch_idx:\\n                            pref[i][x][y] += count[x]\\n            count[ch_idx] += 1\\n            \\n        count = [0] * 10\\n        for i in range(n - 1, -1, -1):\\n            ch_idx = int(s[i])\\n            if i < n - 1:\\n                for x in range(10):\\n                    for y in range(10):\\n                        suff[i][x][y] = suff[i + 1][x][y]\\n                        if x == ch_idx:\\n                            suff[i][x][y] += count[y]\\n            count[ch_idx] += 1\\n            \\n        ans = 0\\n        for i in range(2, n - 2):\\n            for x in range(10):\\n                for y in range(10):\\n                    ans += pref[i-1][x][y] * suff[i+1][y][x]\\n                    ans %= MOD\\n        return ans\\n```", "def countPalindromes(self, s: str) -> int:\\n        \\n        MOD = 1_000_000_007\\n        n = len(s)\\n        pref = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        suff = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        \\n        count = [0] * 10\\n        for i in range(n):\\n            ch_idx = int(s[i])\\n            if i > 0:\\n                for x in range(10):\\n                    for y in range(10):\\n                        pref[i][x][y] = pref[i - 1][x][y]\\n                        if y == ch_idx:\\n                            pref[i][x][y] += count[x]\\n            count[ch_idx] += 1\\n            \\n        count = [0] * 10\\n        for i in range(n - 1, -1, -1):\\n            ch_idx = int(s[i])\\n            if i < n - 1:\\n                for x in range(10):\\n                    for y in range(10):\\n                        suff[i][x][y] = suff[i + 1][x][y]\\n                        if x == ch_idx:\\n                            suff[i][x][y] += count[y]\\n            count[ch_idx] += 1\\n            \\n        ans = 0\\n        for i in range(2, n - 2):\\n            for x in range(10):\\n                for y in range(10):\\n                    ans += pref[i-1][x][y] * suff[i+1][y][x]\\n                    ans %= MOD\\n        return ans\\n```", "def countPalindromes(self, s: str) -> int:\\n        \\n        MOD = 1_000_000_007\\n        n = len(s)\\n        pref = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        suff = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        \\n        count = [0] * 10\\n        for i in range(n):\\n            ch_idx = int(s[i])\\n            if i > 0:\\n                for x in range(10):\\n                    for y in range(10):\\n                        pref[i][x][y] = pref[i - 1][x][y]\\n                        if y == ch_idx:\\n                            pref[i][x][y] += count[x]\\n            count[ch_idx] += 1\\n            \\n        count = [0] * 10\\n        for i in range(n - 1, -1, -1):\\n            ch_idx = int(s[i])\\n            if i < n - 1:\\n                for x in range(10):\\n                    for y in range(10):\\n                        suff[i][x][y] = suff[i + 1][x][y]\\n                        if x == ch_idx:\\n                            suff[i][x][y] += count[y]\\n            count[ch_idx] += 1\\n            \\n        ans = 0\\n        for i in range(2, n - 2):\\n            for x in range(10):\\n                for y in range(10):\\n                    ans += pref[i-1][x][y] * suff[i+1][y][x]\\n                    ans %= MOD\\n        return ans\\n```"]}
{"id": "2211", "ref_py": ["def countSubarrays(self, a: List[int], k: int) -> int:", "def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        pos = nums.index(k)\\n        \\n        cnt = defaultdict(int)\\n        \\n        bal=0\\n        for i in range(pos, n):\\n            num = nums[i]\\n            \\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            cnt[bal] += 1\\n            \\n        res=0\\n        bal=0\\n        for i in reversed(range(pos+1)):\\n            num = nums[i]\\n            \\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            \\n            res += cnt[-bal] ", "def countSubarrays(self, a: List[int], k: int) -> int:"]}
{"id": "2212", "ref_py": ["def magnificentSets(self, n, edges):\\n        \\n        graph = collections.defaultdict(list)", "def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        parent = [i for i in range(n+1)]\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px <= py:\\n                parent[py] = px\\n            else:\\n                parent[px] = py", "def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        parent = [i for i in range(n+1)]\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px <= py:\\n                parent[py] = px\\n            else:\\n                parent[px] = py"]}
{"id": "2213", "ref_py": ["def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td = Counter(nums2)\\n\\t\\t\\tn = len(nums1)\\n\\t\\t\\th = n//2\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>h:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\td = defaultdict(int)\\n\\t\\t\\tans = 0\\n\\t\\t\\tcnt =0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif nums1[i]==nums2[i]:\\n\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\td[nums1[i]]+=1\\n\\t\\t\\tval =0\\n\\t\\t\\tmx =0\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>mx:\\n\\t\\t\\t\\t\\tmx =j\\n\\t\\t\\t\\t\\tval = i\\n\\t\\t\\tif mx+mx>cnt:\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\\n\\t\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\treturn ans\\n", "def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td = Counter(nums2)\\n\\t\\t\\tn = len(nums1)\\n\\t\\t\\th = n//2\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>h:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\td = defaultdict(int)\\n\\t\\t\\tans = 0\\n\\t\\t\\tcnt =0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif nums1[i]==nums2[i]:\\n\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\td[nums1[i]]+=1\\n\\t\\t\\tval =0\\n\\t\\t\\tmx =0\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>mx:\\n\\t\\t\\t\\t\\tmx =j\\n\\t\\t\\t\\t\\tval = i\\n\\t\\t\\tif mx+mx>cnt:\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\\n\\t\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\treturn ans\\n", "def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td = Counter(nums2)\\n\\t\\t\\tn = len(nums1)\\n\\t\\t\\th = n//2\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>h:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\td = defaultdict(int)\\n\\t\\t\\tans = 0\\n\\t\\t\\tcnt =0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif nums1[i]==nums2[i]:\\n\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\td[nums1[i]]+=1\\n\\t\\t\\tval =0\\n\\t\\t\\tmx =0\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>mx:\\n\\t\\t\\t\\t\\tmx =j\\n\\t\\t\\t\\t\\tval = i\\n\\t\\t\\tif mx+mx>cnt:\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\\n\\t\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\treturn ans\\n"]}
{"id": "2214", "ref_py": ["def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        numRows, numCols = len(grid), len(grid[0])\\n        queriesSorted, hashMap = sorted(queries), {}\\n        heap, visited = [(grid[0][0], 0, 0)], set()\\n        visited.add((0, 0))\\n        for query in queriesSorted:\\n            while heap:\\n                val, row, col = heap[0]\\n                if val >= query:\\n                    break\\n                heappop(heap)\\n                for newRow, newCol in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                    if newRow < 0 or newRow >= numRows or newCol < 0 or newCol >= numCols: \\n                        continue\\n                    if (newRow, newCol) in visited: \\n                        continue\\n                    heappush(heap, (grid[newRow][newCol], newRow, newCol))\\n                    visited.add((newRow, newCol))\\n            hashMap[query] = len(visited) - len(heap)\\n        return [hashMap[query] for query in queries]", "def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        numRows, numCols = len(grid), len(grid[0])\\n        queriesSorted, hashMap = sorted(queries), {}\\n        heap, visited = [(grid[0][0], 0, 0)], set()\\n        visited.add((0, 0))\\n        for query in queriesSorted:\\n            while heap:\\n                val, row, col = heap[0]\\n                if val >= query:\\n                    break\\n                heappop(heap)\\n                for newRow, newCol in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                    if newRow < 0 or newRow >= numRows or newCol < 0 or newCol >= numCols: \\n                        continue\\n                    if (newRow, newCol) in visited: \\n                        continue\\n                    heappush(heap, (grid[newRow][newCol], newRow, newCol))\\n                    visited.add((newRow, newCol))\\n            hashMap[query] = len(visited) - len(heap)\\n        return [hashMap[query] for query in queries]", "def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\\n        numRows, numCols = len(grid), len(grid[0])\\n        queriesSorted, hashMap = sorted(queries), {}\\n        heap, visited = [(grid[0][0], 0, 0)], set()\\n        visited.add((0, 0))\\n        for query in queriesSorted:\\n            while heap:\\n                val, row, col = heap[0]\\n                if val >= query:\\n                    break\\n                heappop(heap)\\n                for newRow, newCol in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\\n                    if newRow < 0 or newRow >= numRows or newCol < 0 or newCol >= numCols: \\n                        continue\\n                    if (newRow, newCol) in visited: \\n                        continue\\n                    heappush(heap, (grid[newRow][newCol], newRow, newCol))\\n                    visited.add((newRow, newCol))\\n            hashMap[query] = len(visited) - len(heap)\\n        return [hashMap[query] for query in queries]"]}
{"id": "2215", "ref_py": ["def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        edges=set([(min(u,v),max(u,v)) for u,v in edges])\\n        graph=defaultdict(lambda: set())\\n        degree=[0]*(n+1)\\n        for u,v in edges:\\n            degree[u]+=1\\n            degree[v]+=1\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        odd=0\\n        odds,evens=[],set()\\n        for i in range(1,n+1):\\n            if degree[i]%2==1:\\n                odd+=1\\n                odds.append(i)\\n            else:\\n                evens.add(i)\\n        if odd==0:\\n            return True\\n        if odd>4 or odd%2==1:\\n            return False\\n        if odd==2:\\n            if (odds[0],odds[1]) not in edges:\\n                return True\\n            okay=evens-(graph[odds[0]].union(graph[odds[1]]))\\n            if len(okay)>0:\\n                return True\\n            return False\\n        flag=False\\n        for i in range(4):\\n            if flag: break\\n            for j in range(i+1,4):\\n                f_edge=(odds[i],odds[j])\\n                odds2=odds[:i]+odds[i+1:j]+odds[j+1:]\\n                s_edge=(odds2[0],odds2[1])\\n                if (f_edge not in edges and s_edge not in edges):\\n                    flag=True\\n                    break\\n        return flag", "defaultdict", "defaultdict"]}
{"id": "2216", "ref_py": ["def maxJumps(self, nums: List[int], d: int) -> int:\\n        N = len(nums)\\n        seen = set() ", "def maxJumps(self, A, d):\\n        n = len(A)\\n        dp = [1] * n\\n        for i in sorted(range(n), key = lambda x: -A[x]):\\n            for x in range(i - 1, max(0, i - d) - 1, -1):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n            for x in range(i + 1, min(n, i + d + 1)):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n        return max(dp)\\n```", "def maxJumps(self, A, d):\\n        n = len(A)\\n        dp = [1] * n\\n        for i in sorted(range(n), key = lambda x: -A[x]):\\n            for x in range(i - 1, max(0, i - d) - 1, -1):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n            for x in range(i + 1, min(n, i + d + 1)):\\n                if A[x] >= A[i]: break\\n                dp[x] = max(dp[x], dp[i] + 1)\\n        return max(dp)\\n```"]}
{"id": "2217", "ref_py": ["def countAnagrams(self, s: str) -> int:\\n        return reduce(lambda ans, w: ans * perm(len(w)) // prod(map(perm, Counter(w).values())) % self.MOD, s.split(), 1)", "def countAnagrams(self, s: str) -> int:\\n        res = 1\\n        for w in s.split(\" \"):\\n            cnt, prem = Counter(w), factorial(len(w))\\n            for rep in cnt.values():\\n                prem = prem // factorial(rep)\\n            res = res * prem % 1000000007\\n        return res\\n```\\n**C++**\\nNeed to pre-compute factorials and inverse modulos (to simulate divisions).", "def countAnagrams(self, s: str) -> int:"]}
{"id": "2218", "ref_py": ["def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tnums[:] = sorted(set(nums))\\n\\t\\treturn len(nums)\\n```", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  ", "def removeDuplicates(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        k = 1  "]}
{"id": "2219", "ref_py": ["def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        best = min(stations)\\n        left,right = 0,10**12\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if self.isPossible(mid,stations[:],r,k):\\n                left = mid+1\\n                best = mid\\n            else:\\n                right = mid - 1\\n        return best\\n    \\n    def isPossible(self,min_power,stations,r,k):\\n        cur_power = 0\\n        for i in range(r+1):\\n            cur_power += stations[i]\\n        \\n        left,right = 0,r\\n        for i in range(0,len(stations)):\\n            if i-left>r:\\n                cur_power -= stations[left]\\n                left+=1\\n            if right-i<r and right<len(stations)-1:\\n                right+=1\\n                cur_power += stations[right]\\n                \\n            if cur_power < min_power:\\n                power_needed = min_power-cur_power\\n                if k<power_needed: return False\\n                stations[right] += power_needed\\n                cur_power += power_needed\\n                k-=power_needed\\n        return True\\n            \\n```", "def check(self, mid, psum, r, k):\\n        ", "def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n\\t\\n        prefix = [0] "]}
{"id": "2220", "ref_py": ["def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n    def mergeIntervals(intervals):\\n        if not intervals: return []\\n        intervals.sort()\\n        res = [[*intervals[0]]]\\n        for i in range(1, len(intervals)):\\n            left, right = intervals[i]\\n            if left <= res[-1][1]:\\n                res[-1][1] = max(right, res[-1][1])\\n            else:\\n                res.append([left, right])\\n        return res\\n    \\n    x = defaultdict(list)\\n    for x1,y1,x2,y2 in rectangles:\\n        x[x1].append([1, y1, y2])\\n        x[x2].append([-1, y1, y2])\\n    \\n    x_vals = sorted(x.keys())\\n    c_intervals = defaultdict(int)\\n    area = 0\\n    for i in range(len(x_vals)-1):\\n        for freq,y1,y2 in x[x_vals[i]]:\\n            c_intervals[(y1, y2)] += freq\\n        \\n        intervals = mergeIntervals([interval for interval,f in c_intervals.items() if f])\\n        area += sum([(y2 - y1)*(x_vals[i+1] - x_vals[i]) for y1,y2 in intervals])\\n    \\n    return area%1000000007", "def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n    def mergeIntervals(intervals):\\n        if not intervals: return []\\n        intervals.sort()\\n        res = [[*intervals[0]]]\\n        for i in range(1, len(intervals)):\\n            left, right = intervals[i]\\n            if left <= res[-1][1]:\\n                res[-1][1] = max(right, res[-1][1])\\n            else:\\n                res.append([left, right])\\n        return res\\n    \\n    x = defaultdict(list)\\n    for x1,y1,x2,y2 in rectangles:\\n        x[x1].append([1, y1, y2])\\n        x[x2].append([-1, y1, y2])\\n    \\n    x_vals = sorted(x.keys())\\n    c_intervals = defaultdict(int)\\n    area = 0\\n    for i in range(len(x_vals)-1):\\n        for freq,y1,y2 in x[x_vals[i]]:\\n            c_intervals[(y1, y2)] += freq\\n        \\n        intervals = mergeIntervals([interval for interval,f in c_intervals.items() if f])\\n        area += sum([(y2 - y1)*(x_vals[i+1] - x_vals[i]) for y1,y2 in intervals])\\n    \\n    return area%1000000007", "def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n    def mergeIntervals(intervals):\\n        if not intervals: return []\\n        intervals.sort()\\n        res = [[*intervals[0]]]\\n        for i in range(1, len(intervals)):\\n            left, right = intervals[i]\\n            if left <= res[-1][1]:\\n                res[-1][1] = max(right, res[-1][1])\\n            else:\\n                res.append([left, right])\\n        return res\\n    \\n    x = defaultdict(list)\\n    for x1,y1,x2,y2 in rectangles:\\n        x[x1].append([1, y1, y2])\\n        x[x2].append([-1, y1, y2])\\n    \\n    x_vals = sorted(x.keys())\\n    c_intervals = defaultdict(int)\\n    area = 0\\n    for i in range(len(x_vals)-1):\\n        for freq,y1,y2 in x[x_vals[i]]:\\n            c_intervals[(y1, y2)] += freq\\n        \\n        intervals = mergeIntervals([interval for interval,f in c_intervals.items() if f])\\n        area += sum([(y2 - y1)*(x_vals[i+1] - x_vals[i]) for y1,y2 in intervals])\\n    \\n    return area%1000000007"]}
{"id": "2221", "ref_py": ["define a dfs function with two key parameters (cur, prev) to control the direction we will move along an edge between cur and prev\\n3. within dfs(cur,prev), the recursion is to call t(nxt,cur) for nxt in adj[cur]-{prev}\\n4. we add memorization (@cache) so that each edge between cur and prev will only be visited twice: one from cur to prev, one from prev to cur\\n5. we call dfs(i,-1) for i in range(n). -1 denotes no prev for i, so i is the root.", "def rec(p):\\n\\tnonlocal m\\n\\ta = rec(p.left)\\n\\tb = rec(p.right)\\n\\tm = max(m, a + b + p.val)\\n\\treturn max(a, b) + p.val\\nrec(0)\\nreturn m\\n```\\nWe start from node `0` as the old root, get the values from sub-trees and try to combine them.  And then, instead of returning the combined value, we still return the max value while record the max of combined value all the way.", "define a dfs function with two key parameters (cur, prev) to control the direction we will move along an edge between cur and prev\\n3. within dfs(cur,prev), the recursion is to call t(nxt,cur) for nxt in adj[cur]-{prev}\\n4. we add memorization (@cache) so that each edge between cur and prev will only be visited twice: one from cur to prev, one from prev to cur\\n5. we call dfs(i,-1) for i in range(n). -1 denotes no prev for i, so i is the root."]}
{"id": "2222", "ref_py": ["def isReachable(self, x: int, y: int) -> bool:\\n        v = gcd(x, y)\\n        return v == (v & -v)\\n```\\n<br>", "def isReachable(self, x: int, y: int) -> bool:\\n        v = gcd(x, y)\\n        return v == (v & -v)\\n```\\n<br>", "def isReachable(self, x: int, y: int) -> bool:\\n        v = gcd(x, y)\\n        return v == (v & -v)\\n```\\n<br>"]}
{"id": "2223", "ref_py": ["def minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)", "def minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)", "def minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)"]}
{"id": "2224", "ref_py": ["def putMarbles(self, weights: list[int], k: int) -> int:\\n        return (lambda xs: sum(nlargest(k - 1, xs)) - sum(nsmallest(k - 1, xs)))(tuple(map(sum, pairwise(weights))))", "def putMarbles(self, weights, k):\\n        i=0\\n        j=0\\n        l=[]\\n        for j in range(len(weights)-1):\\n            sum=weights[j]+weights[j+1]\\n            l.append(sum)\\n            sum=0\\n        l.sort()\\n        p=len(l)-1\\n        sum1=0\\n        sum2=0\\n        while k>1:\\n            sum1=sum1+l[i]\\n            sum2=sum2+l[p]\\n            i=i+1\\n            p=p-1\\n            k=k-1\\n        return sum2-sum1", "def putMarbles(self, weights, k):\\n        i=0\\n        j=0\\n        l=[]\\n        for j in range(len(weights)-1):\\n            sum=weights[j]+weights[j+1]\\n            l.append(sum)\\n            sum=0\\n        l.sort()\\n        p=len(l)-1\\n        sum1=0\\n        sum2=0\\n        while k>1:\\n            sum1=sum1+l[i]\\n            sum2=sum2+l[p]\\n            i=i+1\\n            p=p-1\\n            k=k-1\\n        return sum2-sum1"]}
{"id": "2225", "ref_py": ["def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```", "def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```", "def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```"]}
{"id": "2226", "ref_py": ["def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans\\n                    \\n        \\n```\\nSubmission:\\n![submit.jpg](https://assets.leetcode.com/users/images/f0c9c91f-8abe-44d5-9970-a0cc48a238a2_1675597492.0397966.png)", "def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans\\n                    \\n        \\n```\\nSubmission:\\n![submit.jpg](https://assets.leetcode.com/users/images/f0c9c91f-8abe-44d5-9970-a0cc48a238a2_1675597492.0397966.png)", "def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans\\n                    \\n        \\n```\\nSubmission:\\n![submit.jpg](https://assets.leetcode.com/users/images/f0c9c91f-8abe-44d5-9970-a0cc48a238a2_1675597492.0397966.png)"]}
{"id": "2227", "ref_py": ["def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```\\nMy helper function `cumdivs` first computes divisibility by divisor 2 or 5, as that\\'s the factors we need to get zeros: It counts for each value in the grid how often it is divisible by divisor `d`. I try up to 9 times, since 2<sup>9</sup>=512 is the largest possible (since the numbers are guaranteed to not exceed 1000). Then it computes and combines the cumulative sums of the divisibilities on both axes (and subtracts each value\\'s divisibility in order to not double-count it).", "def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        accumlatedProduct = [[[1,1] for i in range(m)] for j in range(n)] ", "def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```\\nMy helper function `cumdivs` first computes divisibility by divisor 2 or 5, as that\\'s the factors we need to get zeros: It counts for each value in the grid how often it is divisible by divisor `d`. I try up to 9 times, since 2<sup>9</sup>=512 is the largest possible (since the numbers are guaranteed to not exceed 1000). Then it computes and combines the cumulative sums of the divisibilities on both axes (and subtracts each value\\'s divisibility in order to not double-count it)."]}
{"id": "2228", "ref_py": ["define ll long long\\n\\tclass LST {\\n\\tpublic:\\n\\t vector<ll>seg, lazy;\\n\\t LST(ll n) {\\n\\t  seg.resize(4 * n + 1);\\n\\t  lazy.resize(4 * n + 1);\\n\\t }", "define ll long long\\n\\tclass LST {\\n\\tpublic:\\n\\t vector<ll>seg, lazy;\\n\\t LST(ll n) {\\n\\t  seg.resize(4 * n + 1);\\n\\t  lazy.resize(4 * n + 1);\\n\\t }", "define ll long long\\n\\tclass LST {\\n\\tpublic:\\n\\t vector<ll>seg, lazy;\\n\\t LST(ll n) {\\n\\t  seg.resize(4 * n + 1);\\n\\t  lazy.resize(4 * n + 1);\\n\\t }"]}
{"id": "2229", "ref_py": ["def findTheString(self, lcp):\\n        \\n        n = len(lcp)\\n        \\n        \\n\\t\\t\\n\\t\\t", "def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        \\n    def find(self, a):\\n        if a == self.parent[a]:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]", "def findTheString(self, lcp):\\n        \\n        n = len(lcp)\\n        \\n        \\n\\t\\t\\n\\t\\t"]}
{"id": "2230", "ref_py": ["def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```", "def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```", "def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```"]}
{"id": "2231", "ref_py": ["def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:", "defaultdict(set), Counter(map(tuple,guesses))\\n        for i,j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n              \\n        @cache\\n        def t(cur,prev):\\n            return g[prev,cur]+sum(t(kid,cur) for kid in adj[cur]-{prev})", "def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:"]}
{"id": "2232", "ref_py": ["def findValidSplit(self, nums: List[int]) -> int:\\n        def gcd(a, b):\\n            a, b = min(a, b), max(a, b)\\n            \\n            if b%a == 0:\\n                return a\\n            return(gcd(b%a, a))\\n        \\n        ", "def findValidSplit(self, nums: List[int]) -> int:\\n        def gcd(a, b):\\n            a, b = min(a, b), max(a, b)\\n            \\n            if b%a == 0:\\n                return a\\n            return(gcd(b%a, a))\\n        \\n        ", "def findValidSplit(self, nums: List[int]) -> int:\\n        def gcd(a, b):\\n            a, b = min(a, b), max(a, b)\\n            \\n            if b%a == 0:\\n                return a\\n            return(gcd(b%a, a))\\n        \\n        "]}
{"id": "2233", "ref_py": ["def findLexSmallestString(self, s, a, b):\\n        ", "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tque = deque([s])\\n\\t\\t\\tans = s\\n\\t\\t\\tvisited = set([s])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\ts = que.popleft()\\n\\t\\t\\t\\tans = min(ans, s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsumm = \"\"\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\t\\tsumm += str((int(s[i])+a)%10)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm += s[i]  \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif summ not in visited:\\n\\t\\t\\t\\t\\tque.append(summ)\\n\\t\\t\\t\\t\\tvisited.add(summ)\\n\\t\\t\\t\\tif s[-b:]+s[:-b] not in visited:\\n\\t\\t\\t\\t\\tque.append(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\tvisited.add(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans \\n", "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tque = deque([s])\\n\\t\\t\\tans = s\\n\\t\\t\\tvisited = set([s])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\ts = que.popleft()\\n\\t\\t\\t\\tans = min(ans, s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsumm = \"\"\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\t\\tsumm += str((int(s[i])+a)%10)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm += s[i]  \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif summ not in visited:\\n\\t\\t\\t\\t\\tque.append(summ)\\n\\t\\t\\t\\t\\tvisited.add(summ)\\n\\t\\t\\t\\tif s[-b:]+s[:-b] not in visited:\\n\\t\\t\\t\\t\\tque.append(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\tvisited.add(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans \\n"]}
{"id": "2234", "ref_py": ["def distinctPrimeFactors(self, nums: List[int]) -> int:", "def distinctPrimeFactors(self, nums: List[int]) -> int:", "def distinctPrimeFactors(self, nums: List[int]) -> int:"]}
{"id": "2235", "ref_py": ["def collectTheCoins(self, coins, edges):\\n        \\n        if not edges:\\n            return 0", "def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\\n    n = len(coins)\\n    tree = [set() for _ in range(n)]\\n    \\n    ", "def collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\\n    n = len(coins)\\n    tree = [set() for _ in range(n)]\\n    \\n    "]}
{"id": "2236", "ref_py": ["def findShortestCycle(self, n, edges):\\n        ", "def findShortestCycle(self, n, edges):\\n        ", "def findShortestCycle(self, n, edges):\\n        "]}
{"id": "2237", "ref_py": ["def minReverseOperations(self, total_nodes, start_point, restricted_nodes, jump):\\n        slots = [SortedList(), SortedList()]\\n        forbidden = set(restricted_nodes)\\n        for idx in range(total_nodes):\\n            if idx != start_point and idx not in forbidden:\\n                slots[idx & 1].add(idx)", "def minReverseOperations(self, N, p, banned, k):\\n        if k == 1 or len(banned) == N-1:\\n            numOps = [IMPOSSIBLE] * N\\n            numOps[p] = 0\\n            return numOps\\n        \\n        numOps = [IMPOSSIBLE] * N\\n        numOps[p] = 0\\n        \\n        remaining = [[], []]\\n        banned = set(banned)\\n        for pos in range(0, N, 2):\\n            if pos != p and pos not in banned:\\n                remaining[EVEN].append(pos)\\n            pos += 1\\n            if pos != p and pos not in banned:\\n                remaining[ODD].append(pos)\\n        \\n        ", "def minReverseOperations(self, total_nodes, start_point, restricted_nodes, jump):\\n        slots = [SortedList(), SortedList()]\\n        forbidden = set(restricted_nodes)\\n        for idx in range(total_nodes):\\n            if idx != start_point and idx not in forbidden:\\n                slots[idx & 1].add(idx)"]}
{"id": "2238", "ref_py": ["def __init__(self, distance, x, y):\\n        self.distance = distance\\n        self.x = x\\n        self.y = y\\n        \\n    def __lt__(self, other):\\n        return self.distance < other.distance", "def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = deque([[0, 0]])\\n        c = 0\\n        m, n = len(grid), len(grid[0])\\n        vis = set()\\n        row = [0 for _ in range(m)]\\n        col = [0 for _ in range(n)]\\n        while(q):\\n            l = len(q)\\n            c += 1\\n            for _ in range(l):\\n                i, j = q.popleft()\\n                if(i == m-1 and j == n-1):\\n                    return c\\n                val = grid[i][j]", "def minimumVisitedCells(self, grid: List[List[int]]) -> int:\\n        q = deque([[0, 0]])\\n        c = 0\\n        m, n = len(grid), len(grid[0])\\n        vis = set()\\n        row = [0 for _ in range(m)]\\n        col = [0 for _ in range(n)]\\n        while(q):\\n            l = len(q)\\n            c += 1\\n            for _ in range(l):\\n                i, j = q.popleft()\\n                if(i == m-1 and j == n-1):\\n                    return c\\n                val = grid[i][j]"]}
{"id": "2241", "ref_py": ["def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n       \\n        count = Counter()\\n    \\n        totalCost = 0", "def __init__(self):\\n        self.next = [[] for _ in range(55)]\\n        self.count = [0] * 55\\n        self.plan0 = [-1] * 55\\n        self.plan1 = [-1] * 55\\n        self.val = [0] * 55", "def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        \\n        graph=defaultdict(list)\\n        \\n        count=defaultdict(int)\\n        \\n        for start,end in edges:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        \\n        def dfs(node, end, path,visited):\\n            visited.add(node)\\n            if node == end:\\n                \\n                return path\\n            temp=[]\\n            for neighbour in graph[node]:\\n                if neighbour not in visited:\\n                    t=dfs(neighbour, end, path + [neighbour],visited)\\n                    if t!=[]:\\n                        return t"]}
{"id": "2243", "ref_py": ["def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        pos = {a: i for i, a in enumerate(A)}\\n        res = n = len(A)\\n        A.sort()\\n        for i in range(1, n):\\n            if pos[A[i]] < pos[A[i - 1]]:\\n                res += n - i\\n        return res\\n```\\n<br>", "def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    map = {nums[i]: i for i in range(n)}\\n    nums.sort()\\n    ans = 1\\n    for i in range(n - 2, -1, -1):\\n        ans += (map[nums[i]] > map[nums[i+1]]) * (n - i) + (map[nums[i]] <= map[nums[i+1]])\\n    return ans\\n```\\n```c++ []\\n long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]] = i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long ans = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            ans += (map[nums[i]] > map[nums[i+1]]) ? n - i : 1;\\n        }\\n        return ans;\\n    }\\n```", "def __init__(self, capacity):\\n    self.fwt = [0] * capacity\\n    self.capacity = len(self.fwt)"]}
{"id": "2244", "ref_py": ["def smallestBeautifulString(self, s: str, k: int) -> str:\\n    i, n = len(s) - 1, len(s)\\n    s = s[:i] + chr(ord(s[i]) + 1) ", "def isValid(self, s, i):\\n        return (i == 0 or s[i - 1] != s[i]) and (i < 2 or s[i - 2] != s[i])", "def smallestBeautifulString(self, s, k):\\n        \\n        letters = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        avail = letters[:k]\\n        temp = list(s)\\n        changed = True\\n        index = len(temp)-1\\n        place = -1\\n        while changed and index >= 0:\\n            cur = avail.index(temp[index])\\n            canchange = False\\n            for i in range (cur+1,len(avail)):\\n                if index == 0:\\n                    temp[index] = avail[i]\\n                    canchange = True\\n                    break\\n                elif index == 1:\\n                    if temp[index-1] != avail[i]:\\n                        temp[index] = avail[i]\\n                        canchange = True\\n                        break\\n                else:\\n                    if temp[index-1] != avail[i] and temp[index-2] != avail[i]:\\n                        temp[index] = avail[i]\\n                        canchange = True\\n                        break\\n            "]}
{"id": "2245", "ref_py": ["def sumOfPower(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        ", "def sumOfPower(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        ", "def sumOfPower(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        "]}
{"id": "2246", "ref_py": ["def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        adjs = [{} for _ in range(n)]", "defaultdict", "def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        adjs = [{} for _ in range(n)]"]}
{"id": "2247", "ref_py": ["def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        f = [_ for _ in range(0, n)]\\n        num = [1] * n\\n        \\n        def getf(x: int) -> int:\\n            if f[x] == x:\\n                return x\\n            f[x] = getf(f[x])\\n            return f[x]\\n        \\n        def merge(x: int, y: int):\\n            x, y = getf(x), getf(y)\\n            if x == y:\\n                return\\n            if num[x] < num[y]:\\n                x, y = y, x\\n            f[y] = x\\n            num[x] += num[y]\\n            \\n        have = {}\\n        for i in range(0, n):\\n            x = nums[i]\\n            if x == 1:\\n                return False\\n            d = 2\\n            while d * d <= x:\\n                if x % d == 0:\\n                    if d in have:\\n                        merge(i, have[d])\\n                    else:\\n                        have[d] = i\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1:\\n                if x in have:\\n                    merge(i, have[x])\\n                else:\\n                    have[x] = i\\n        return num[getf(0)] == n\\n        \\n```", "def canTraverseAllPairs(self, nums: List[int]) -> bool:", "def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n\\t\\t"]}
{"id": "2248", "ref_py": ["def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        r, c = [0] * m, [0] * n\\n        vmap = {}\\n        from sortedcontainers import SortedSet\\n        s = SortedSet()\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if not -mat[i][j] in vmap:\\n                    vmap[-mat[i][j]] = []\\n                vmap[-mat[i][j]].append([i, j])\\n                s.add(-mat[i][j])\\n        temp = [[0] * n for _ in range(m)]\\n        for x in s:\\n            for v in vmap.get(x):\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1\\n            for v in vmap.get(x):\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]])\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]])\\n        return max(max(r), max(c))\\n             \\n```", "def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        r, c = [0] * m, [0] * n\\n        vmap = {}\\n        from sortedcontainers import SortedSet\\n        s = SortedSet()\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if not -mat[i][j] in vmap:\\n                    vmap[-mat[i][j]] = []\\n                vmap[-mat[i][j]].append([i, j])\\n                s.add(-mat[i][j])\\n        temp = [[0] * n for _ in range(m)]\\n        for x in s:\\n            for v in vmap.get(x):\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1\\n            for v in vmap.get(x):\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]])\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]])\\n        return max(max(r), max(c))\\n             \\n```", "def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        r, c = [0] * m, [0] * n\\n        vmap = {}\\n        from sortedcontainers import SortedSet\\n        s = SortedSet()\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if not -mat[i][j] in vmap:\\n                    vmap[-mat[i][j]] = []\\n                vmap[-mat[i][j]].append([i, j])\\n                s.add(-mat[i][j])\\n        temp = [[0] * n for _ in range(m)]\\n        for x in s:\\n            for v in vmap.get(x):\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1\\n            for v in vmap.get(x):\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]])\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]])\\n        return max(max(r), max(c))\\n             \\n```"]}
{"id": "2249", "ref_py": ["def add(self, x, y) -> int:\\n        x += y\\n        if x >= self.M:\\n            x -= self.M\\n        return x", "def add(self, x, y) -> int:\\n        x += y\\n        if x >= self.M:\\n            x -= self.M\\n        return x", "def add(self, x, y) -> int:\\n        x += y\\n        if x >= self.M:\\n            x -= self.M\\n        return x"]}
{"id": "2250", "ref_py": ["def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        left, right = (self.lowestCommonAncestor(kid, p, q)\\n                       for kid in (root.left, root.right))\\n        return root if left and right else left or right", "def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n    if not root or root == p or root == q:\\n      return root", "def lowestCommonAncestor(self, root, p, q):\\n        stack = [root]\\n        parent = {root: None}\\n        while p not in parent or q not in parent:\\n            node = stack.pop()\\n            if node.left:\\n                parent[node.left] = node\\n                stack.append(node.left)\\n            if node.right:\\n                parent[node.right] = node\\n                stack.append(node.right)\\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        while q not in ancestors:\\n            q = parent[q]\\n        return q"]}
{"id": "2251", "ref_py": ["def query(self, tree: List[int], ind: int, left: int, right: int, x: int, y: int) -> int:\\n        if left >= x and right <= y:\\n            return tree[ind]\\n        mid = (left + right) >> 1\\n        r = -1\\n        if x <= mid:\\n            r = self.query(tree, ind << 1, left, mid, x, y)\\n        if y > mid:\\n            r = max(r, self.query(tree, (ind << 1) | 1, mid + 1, right, x, y))\\n        return r", "def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        def getSmallestGreater(value):\\n            l=0\\n            r=len(mappings)-1\\n            ans=len(mappings)\\n            while l<=r:\\n                m=(l+r)//2\\n                if mappings[m][0]==value:\\n                    return m\\n                elif mappings[m][0]>value:\\n                    ans=m\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return ans\\n        \\n        n=len(nums1)\\n        ans=[0]*len(queries)\\n        ", "def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        def getSmallestGreater(value):\\n            l=0\\n            r=len(mappings)-1\\n            ans=len(mappings)\\n            while l<=r:\\n                m=(l+r)//2\\n                if mappings[m][0]==value:\\n                    return m\\n                elif mappings[m][0]>value:\\n                    ans=m\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return ans\\n        \\n        n=len(nums1)\\n        ans=[0]*len(queries)\\n        "]}
{"id": "2252", "ref_py": ["def paintWalls(self, cost, time):\\n        n = len(cost)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0", "def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        postfix_times = time.copy()", "def solve(self, cost, time, i, wallsrem, dp):\\n        "]}
{"id": "2253", "ref_py": ["def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        ind = [i for i in range(n)]\\n        ind.sort(key=lambda x: positions[x])\\n        s = []\\n        for x in ind:\\n            if directions[x] == \\'L\\':\\n                while s:\\n                    y = s[-1]\\n                    if healths[x] == healths[y]:\\n                        healths[x] = healths[y] = 0\\n                        s.pop()\\n                        break\\n                    if healths[x] > healths[y]:\\n                        healths[x] -= 1\\n                        healths[y] = 0\\n                        s.pop()\\n                    else:\\n                        healths[x] = 0\\n                        healths[y] -= 1\\n                        break\\n            else:\\n                s.append(x)\\n        r = [x for x in healths if x]\\n        return r", "defined, which has four members: position, health, direction, and index. This struct represents the properties of a robot.", "def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\\n        n = len(positions)\\n        ind = [i for i in range(n)]\\n        ind.sort(key=lambda x: positions[x])\\n        s = []\\n        for x in ind:\\n            if directions[x] == \\'L\\':\\n                while s:\\n                    y = s[-1]\\n                    if healths[x] == healths[y]:\\n                        healths[x] = healths[y] = 0\\n                        s.pop()\\n                        break\\n                    if healths[x] > healths[y]:\\n                        healths[x] -= 1\\n                        healths[y] = 0\\n                        s.pop()\\n                    else:\\n                        healths[x] = 0\\n                        healths[y] -= 1\\n                        break\\n            else:\\n                s.append(x)\\n        r = [x for x in healths if x]\\n        return r"]}
{"id": "2254", "ref_py": ["def sumImbalanceNumbers(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = 0\\n        for i in range(n):\\n            s = set()\\n            cur = -1\\n            for j in range(i, n):\\n                cur += 0 if A[j] in s else 1 - (A[j] + 1 in s) - (A[j] - 1 in s)\\n                s.add(A[j])\\n                res += cur\\n        return res\\n```\\n<br>", "def sumImbalanceNumbers(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = 0\\n        for i in range(n):\\n            s = set()\\n            cur = -1\\n            for j in range(i, n):\\n                cur += 0 if A[j] in s else 1 - (A[j] + 1 in s) - (A[j] - 1 in s)\\n                s.add(A[j])\\n                res += cur\\n        return res\\n```\\n<br>", "def sumImbalanceNumbers(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = 0\\n        for i in range(n):\\n            s = set()\\n            cur = -1\\n            for j in range(i, n):\\n                cur += 0 if A[j] in s else 1 - (A[j] + 1 in s) - (A[j] - 1 in s)\\n                s.add(A[j])\\n                res += cur\\n        return res\\n```\\n<br>"]}
{"id": "2255", "ref_py": ["def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        \\n        n = len(word)\\n        \\n        aux = []\\n        \\n        lns = [False]*11\\n        \\n        st = set()\\n        \\n        for z in forbidden:\\n            \\n            l = len(z)\\n            \\n            if z not in st:\\n            \\n                aux.append([l, z])", "def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        length = 0\\n        all = set()\\n        for s in forbidden:\\n            all.add(s)\\n            length = max(length, len(s))\\n        n = len(word)\\n        r = 0\\n        right = n\\n        for i in range(n - 1, -1, -1):\\n            if right <= r:\\n                break\\n            now = 0\\n            temp = \\'\\'\\n            for j in range(i, min(right, i + length)):\\n                temp += word[j]\\n                if temp in all:\\n                    right = j\\n                    break\\n            r = max(r, right - i)\\n        return r", "def longestValidSubstring(self, s: str, forbidden: List[str]) -> int:\\n        seen = set(forbidden)\\n        n = len(s)\\n        dp = [n] * (n + 1)\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = dp[i + 1]\\n            for j in range(i, min(dp[i], n, i + 10)):\\n                if s[i:j + 1] in seen:\\n                    dp[i] = j\\n                    break\\n            res = max(res, dp[i] - i)\\n        return res\\n```\\n<br>"]}
{"id": "2256", "ref_py": ["def maxIncreasingGroups(self, A: List[int]) -> int:\\n        A.sort()\\n        total = k = 0\\n        for a in A:\\n            total += a\\n            if total >= (k + 1) * (k + 2) // 2:\\n                k += 1\\n        return k\\n```\\n<br>", "def maxIncreasingGroups(self, A: List[int]) -> int:\\n        A.sort()\\n        total = k = 0\\n        for a in A:\\n            total += a\\n            if total >= (k + 1) * (k + 2) // 2:\\n                k += 1\\n        return k\\n```\\n<br>", "def maxIncreasingGroups(self, A: List[int]) -> int:\\n        A.sort()\\n        total = k = 0\\n        for a in A:\\n            total += a\\n            if total >= (k + 1) * (k + 2) // 2:\\n                k += 1\\n        return k\\n```\\n<br>"]}
{"id": "2257", "ref_py": ["def dfs(self, x: int, mask: int, s: str, con: List[List[int]], have: Dict[int, int]) -> int:\\n        r: int = 0\\n        if x:\\n            mask ^= 1 << (ord(s[x]) - ord(\\'a\\'))\\n            i: int = 1 << 25\\n            while i:\\n                if mask ^ i in have:\\n                    r += have[mask ^ i]\\n                i >>= 1\\n            r += have.get(mask, 0)\\n            have[mask] = have.get(mask, 0) + 1\\n        for y in con[x]:\\n            r += self.dfs(y, mask, s, con, have)\\n        return r", "def countPalindromePaths(self, parent: List[int], s: str) -> int:\\n        @cache\\n        def f(i):\\n            return f(parent[i]) ^ (1 << (ord(s[i]) - ord(\\'a\\'))) if i else 0", "def countPalindromePaths(self, parent: List[int], s: str) -> int:\\n        @cache\\n        def f(i):\\n            return f(parent[i]) ^ (1 << (ord(s[i]) - ord(\\'a\\'))) if i else 0"]}
{"id": "2258", "ref_py": ["def getLowIsValid(low):\\n    lowIsValid = 1\\n    for i in range(1, len(low)):\\n        if abs(int(low[i]) - int(low[i-1])) != 1:\\n            lowIsValid = 0\\n            break\\n    return lowIsValid\\n def solve(numString, currentIndex, previousDigit, bound, isZero):\\n    if currentIndex == len(numString):\\n        return 1 - isZero\\n    if dp[currentIndex][previousDigit+1][isZero][bound] != -1:\\n        return dp[currentIndex][previousDigit+1][isZero][bound]\\n    limit = int(numString[currentIndex])\\n    if bound == 0:\\n        limit = 9\\n    ans = 0\\n    for i in range(limit+1):\\n        nextBound = 1 if (bound == 1 and i == limit) else 0\\n        nextZero = 1 if (isZero == 1 and i == 0) else 0\\n        if isZero == 1 or abs(i - previousDigit) == 1:\\n            ans += solve(numString, currentIndex+1, i, nextBound, nextZero)\\n    dp[currentIndex][previousDigit+1][isZero][bound] = ans % mod\\n    return dp[currentIndex][previousDigit+1][isZero][bound]\\n def resetArray():\\n    for i in range(101):\\n        for j in range(11):\\n            for k in range(2):\\n                for l in range(2):\\n                    dp[i][j][k][l] = -1\\n def countSteppingNumbers(low, high):\\n    resetArray()\\n    result = solve(high, 0, -1, 1, 1)\\n    resetArray()\\n    result -= solve(low, 0, -1, 1, 1)\\n    result = (result + mod) % mod\\n    lowIsValid = getLowIsValid(low)\\n    result = (result + mod + lowIsValid) % mod\\n    return int(result)\\n```", "def t(i,j,k,l,m):\\n            \\n            if i==len(high): return 1", "def getLowIsValid(low):\\n    lowIsValid = 1\\n    for i in range(1, len(low)):\\n        if abs(int(low[i]) - int(low[i-1])) != 1:\\n            lowIsValid = 0\\n            break\\n    return lowIsValid\\n def solve(numString, currentIndex, previousDigit, bound, isZero):\\n    if currentIndex == len(numString):\\n        return 1 - isZero\\n    if dp[currentIndex][previousDigit+1][isZero][bound] != -1:\\n        return dp[currentIndex][previousDigit+1][isZero][bound]\\n    limit = int(numString[currentIndex])\\n    if bound == 0:\\n        limit = 9\\n    ans = 0\\n    for i in range(limit+1):\\n        nextBound = 1 if (bound == 1 and i == limit) else 0\\n        nextZero = 1 if (isZero == 1 and i == 0) else 0\\n        if isZero == 1 or abs(i - previousDigit) == 1:\\n            ans += solve(numString, currentIndex+1, i, nextBound, nextZero)\\n    dp[currentIndex][previousDigit+1][isZero][bound] = ans % mod\\n    return dp[currentIndex][previousDigit+1][isZero][bound]\\n def resetArray():\\n    for i in range(101):\\n        for j in range(11):\\n            for k in range(2):\\n                for l in range(2):\\n                    dp[i][j][k][l] = -1\\n def countSteppingNumbers(low, high):\\n    resetArray()\\n    result = solve(high, 0, -1, 1, 1)\\n    resetArray()\\n    result -= solve(low, 0, -1, 1, 1)\\n    result = (result + mod) % mod\\n    lowIsValid = getLowIsValid(low)\\n    result = (result + mod + lowIsValid) % mod\\n    return int(result)\\n```"]}
{"id": "2259", "ref_py": ["def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\\n        n = len(nums1)\\n        ind = list(range(n))\\n        s, d = 0, 0\\n        for i in range(n):\\n            s += nums1[i]\\n            d += nums2[i]\\n        if s <= x:\\n            return 0", "def minimumTime(nums1: List[int], nums2: List[int], x: int) -> int:\\n    n = len(nums1)\\n    nums = [[nums1[i], nums2[i]] for i in range(n)]\\n    nums.sort(key=lambda a: a[1])\\n    dp = [[0]*(n+1) for _ in range(n+1)]\\n    for i in range(1, n+1):\\n        for j in range(1, i+1):\\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i-1][0] + j * nums[i-1][1])\\n    for j in range(n, -1, -1):\\n        if dp[n][j] <= x:\\n            return j\\n    return -1\\n```", "def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\\n        n = len(nums1)\\n        ind = list(range(n))\\n        s, d = 0, 0\\n        for i in range(n):\\n            s += nums1[i]\\n            d += nums2[i]\\n        if s <= x:\\n            return 0"]}
{"id": "2260", "ref_py": ["definition, swapping out any item by a new item in a as yet unused category, will decrease the total profits, but increase the number of unique categories.", "definition, swapping out any item by a new item in a as yet unused category, will decrease the total profits, but increase the number of unique categories.", "definition, swapping out any item by a new item in a as yet unused category, will decrease the total profits, but increase the number of unique categories."]}
{"id": "2261", "ref_py": ["def maximumScore(self, nums, k):\\n        \\n        MOD = 10 ** 9 + 7\\n        n = len(nums)\\n        factor=[0]*n\\n        scores=[]\\n        for i in range(n):\\n            score=self.prime_factors_count(nums[i])\\n            factor[i]=score\\n            ", "def maximumScore(self, nums: List[int], k: int) -> int:\\n        n = len(nums)", "def maximumScore(self, nums, k):\\n        \\n        MOD = 10 ** 9 + 7\\n        n = len(nums)\\n        factor=[0]*n\\n        scores=[]\\n        for i in range(n):\\n            score=self.prime_factors_count(nums[i])\\n            factor[i]=score\\n            "]}
